
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 29 14:33:36 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a8					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b0					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b8					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b9					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bb					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bd					Tim_SR:		.byte ? 						; Processor Status
>03be					Tim_A:		.byte ? 						; Processor Registers
>03bf					Tim_X:		.byte ?
>03c0					Tim_Y:		.byte ?
>03c1					Tim_Z:		.byte ?
>03c2					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0d 64 00 ff 09 48 65 6c			.byte	$0d,$64,$00,$ff,$09,$48,$65,$6c
>1008	6c 6f 20 21 00 0c c8 00			.byte	$6c,$6f,$20,$21,$00,$0c,$c8,$00
>1010	d0 43 48 bf 46 50 c0 c4			.byte	$d0,$43,$48,$bf,$46,$50,$c0,$c4
>1018	00 18 2c 01 18 bb 84 40			.byte	$00,$18,$2c,$01,$18,$bb,$84,$40
>1020	c0 d6 fe 08 53 74 61 72			.byte	$c0,$d6,$fe,$08,$53,$74,$61,$72
>1028	74 2e c1 40 fd 04 32 33			.byte	$74,$2e,$c1,$40,$fd,$04,$32,$33
>1030	00 0a 90 01 91 c0 19 bb			.byte	$00,$0a,$90,$01,$91,$c0,$19,$bb
>1038	84 40 00 21 f4 01 91 c0			.byte	$84,$40,$00,$21,$f4,$01,$91,$c0
>1040	19 bb 84 19 bb 8a 41 c0			.byte	$19,$bb,$84,$19,$bb,$8a,$41,$c0
>1048	d6 18 bb c1 19 bb 8a 40			.byte	$d6,$18,$bb,$c1,$19,$bb,$8a,$40
>1050	fd 04 30 35 c1 c0 96 19			.byte	$fd,$04,$30,$35,$c1,$c0,$96,$19
>1058	bb 84 43 00 14 58 02 d6			.byte	$bb,$84,$43,$00,$14,$58,$02,$d6
>1060	c0 18 bb 84 18 bb 8a 41			.byte	$c0,$18,$bb,$84,$18,$bb,$8a,$41
>1068	c0 96 18 bb 84 4f 68 00			.byte	$c0,$96,$18,$bb,$84,$4f,$68,$00
>1070	0b bc 02 d6 fe 06 45 6e			.byte	$0b,$bc,$02,$d6,$fe,$06,$45,$6e
>1078	64 2e 00 05 20 03 c4 00			.byte	$64,$2e,$00,$05,$20,$03,$c4,$00
>1080	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 4c 87 01	jmp $01874c		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 05	sta $0500			sta 	IFT_XCursor
.018065	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018068	ad 01 05	lda $0501			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 05	inc $0500			inc 	IFT_XCursor
.018144	ad 00 05	lda $0500			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 05	dec $0501			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 05	sta $0501			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 05	inc $0501			inc 	IFT_YCursor
.01815c	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 05	lda $0501			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 05	inc $0500			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae c2 03	ldx $03c2			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad bd 03	lda $03bd			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad be 03	lda $03be			lda 	TIM_A 						; restore AXYZ
.018281	ae bf 03	ldx $03bf			ldx 	TIM_X
.018284	ac c0 03	ldy $03c0			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d bc 03	sta $03bc			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d bb 03	sta $03bb			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd b9 03	lda $03b9,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d be 03	sta $03be			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e bf 03	stx $03bf			stx 	TIM_X
.01838b	8c c0 03	sty $03c0			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d bd 03	sta $03bd			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d ba 03	sta $03ba			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d b9 03	sta $03b9			sta 	TIM_PC 						; high byte
.01839a	ad ba 03	lda $03ba			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce b9 03	dec $03b9			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce ba 03	dec $03ba			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e c2 03	stx $03c2			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d ba 03	sta $03ba			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d b9 03	sta $03b9			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d bd 03	sta $03bd,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.018400					StackReset:
.018400	48		pha				pha
.018401	5a		phy				phy
.018402	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018404	85 26		sta $26				sta 	zBasicSP
.018406	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018408	85 27		sta $27				sta 	zBasicSP+1
.01840a	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.01840c	98		tya				tya 								; be a legal token.
.01840d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01840f	7a		ply				ply
.018410	68		pla				pla
.018411	60		rts				rts
.018412					StackPushFrame:
.018412	48		pha				pha
.018413	5a		phy				phy
.018414	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.018415	48		pha				pha 								; save it.
.018416	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.018418	18		clc				clc 								; add to Basic Stack
.018419	65 26		adc $26				adc 	zBasicSP
.01841b	85 26		sta $26				sta 	zBasicSP
.01841d	90 02		bcc $018421			bcc 	_SPFNoBump
.01841f	e6 27		inc $27				inc 	zBasicSP+1
.018421					_SPFNoBump:
.018421	a0 00		ldy #$00			ldy 	#0
.018423	68		pla				pla
.018424	91 26		sta ($26),y			sta 	(zBasicSP),y
.018426	7a		ply				ply
.018427	68		pla				pla
.018428	60		rts				rts
.018429					StackPopFrame:
.018429	48		pha				pha
.01842a	5a		phy				phy
.01842b	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.01842d	51 26		eor ($26),y			eor 	(zBasicSP),y
.01842f	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.018431	d0 12		bne $018445			bne 	_SPFError 					; mixed structures
.018433	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.018435	29 0f		and #$0f			and 	#$0F
.018437	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.018439	38		sec				sec
.01843a	65 26		adc $26				adc 	zBasicSP
.01843c	85 26		sta $26				sta 	zBasicSP
.01843e	b0 02		bcs $018442			bcs 	_SPFNoBump
.018440	c6 27		dec $27				dec 	zBasicSP+1
.018442					_SPFNoBump:
.018442	7a		ply				ply
.018443	68		pla				pla
.018444	60		rts				rts
.018445					_SPFError:
.018445	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018448	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>018450	72 75 63 74 75 72 65 73 00
.018459					StackSavePosition:
.018459	98		tya				tya
.01845a	5a		phy				phy
.01845b	a0 05		ldy #$05			ldy 	#5
.01845d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01845f	a0 01		ldy #$01			ldy 	#1
.018461	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018463	91 26		sta ($26),y			sta 	(zBasicSP),y
.018465	c8		iny				iny
.018466	a5 17		lda $17				lda 	zCodePtr+1
.018468	91 26		sta ($26),y			sta 	(zBasicSP),y
.01846a	c8		iny				iny
.01846b	a5 18		lda $18				lda 	zCodePtr+2
.01846d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01846f	c8		iny				iny
.018470	a5 19		lda $19				lda 	zCodePtr+3
.018472	91 26		sta ($26),y			sta 	(zBasicSP),y
.018474	7a		ply				ply
.018475	60		rts				rts
.018476					StackRestorePosition:
.018476	5a		phy				phy
.018477	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018479	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01847b	85 16		sta $16				sta 	zCodePtr+0
.01847d	c8		iny				iny
.01847e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018480	85 17		sta $17				sta 	zCodePtr+1
.018482	c8		iny				iny
.018483	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018485	85 18		sta $18				sta 	zCodePtr+2
.018487	c8		iny				iny
.018488	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01848a	85 19		sta $19				sta 	zCodePtr+3
.01848c	c8		iny				iny
.01848d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01848f	7a		ply				ply 								; restore Y
.018490	a8		tay				tay
.018491	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018492					CharPrint:
.018492	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018495					CharGet:
.018495	4c e6 81	jmp $0181e6			jmp 	IF_GetKey
.018498					CheckBreak:
.018498	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01849b					SyntaxError:
.01849b	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>01849e	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>0184a6	72 72 6f 72 00
.0184ab					TypeError:
.0184ab	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>0184ae	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>0184b6	70 65 00
.0184b9					BadParamError:
.0184b9	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>0184bc	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>0184c4	6d 65 74 65 72 00
.0184ca					ERR_Handler:
.0184ca	a0 00		ldy #$00			ldy 	#0
.0184cc	c8		iny				iny
.0184cd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184cf	85 80		sta $80				sta 	XS_Mantissa
.0184d1	c8		iny				iny
.0184d2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184d4	85 81		sta $81				sta 	XS_Mantissa+1
.0184d6	fa		plx				plx 								; address in XY
.0184d7	7a		ply				ply
.0184d8	e8		inx				inx 								; bump, because of RTS/JSR address -1
.0184d9	d0 01		bne $0184dc			bne 	_EHNoSkip
.0184db	c8		iny				iny
.0184dc					_EHNoSkip:
.0184dc	20 fb 84	jsr $0184fb			jsr 	PrintROMMessage 			; print message from ROM.
.0184df	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.0184e1	05 81		ora $81				ora 	XS_Mantissa+1
.0184e3	f0 0c		beq $0184f1			beq 	_EHNoLine
.0184e5	a2 f6		ldx #$f6			ldx 	#_EHAt & $FF 				; print " at "
.0184e7	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.0184e9	20 fb 84	jsr $0184fb			jsr 	PrintROMMessage
.0184ec	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0184ee	20 10 85	jsr $018510			jsr 	Print16BitInteger
.0184f1					_EHNoLine:
.0184f1	80 fe		bra $0184f1			bra 	_EHNoLine
.0184f3	4c 7d 87	jmp $01877d			jmp 	WarmStart
>0184f6	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0184fb					PrintROMMessage:
.0184fb	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0184fd	84 1b		sty $1b				sty 	zLTemp1+1
.0184ff	4b		phk				phk
.018500	68		pla				pla
.018501	85 1c		sta $1c				sta 	ZLTemp1+2
.018503	a0 00		ldy #$00			ldy 	#0
.018505					_PRMLoop:
.018505	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018507	f0 06		beq $01850f			beq		_PRMExit
.018509	c8		iny				iny
.01850a	20 92 84	jsr $018492			jsr 	CharPrint
.01850d	80 f6		bra $018505			bra 	_PRMLoop
.01850f					_PRMExit:
.01850f	60		rts				rts
.018510					Print16BitInteger:
.018510	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018512	85 82		sta $82				sta 	XS_Mantissa+2
.018514	85 83		sta $83				sta 	XS_Mantissa+3
.018516					Print32BitInteger:
.018516	a9 00		lda #$00			lda 	#0
.018518	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.01851b	aa		tax				tax 								; convert bottom level.
.01851c	20 58 99	jsr $019958			jsr 	INTToString 				; make string
.01851f	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018521	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.018524	f0 06		beq $01852c			beq 	_P1Exit
.018526	20 92 84	jsr $018492			jsr 	CharPrint
.018529	e8		inx				inx
.01852a	80 f5		bra $018521			bra 	_P1Loop
.01852c	8a		txa		_P1Exit:txa 								; return chars printed.
.01852d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.01852e					VectorTable:
>01852e	cc 8d					.word BinaryOp_And         & $FFFF ; $80 and
>018530	e8 8d					.word BinaryOp_Or          & $FFFF ; $81 or
>018532	04 8e					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018534	04 8e					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018536	3b 8e					.word Binary_Equal         & $FFFF ; $84 =
>018538	55 8e					.word Binary_NotEqual      & $FFFF ; $85 <>
>01853a	5e 8e					.word Binary_Less          & $FFFF ; $86 <
>01853c	67 8e					.word Binary_LessEqual     & $FFFF ; $87 <=
>01853e	79 8e					.word Binary_Greater       & $FFFF ; $88 >
>018540	70 8e					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018542	fe 8e					.word BinaryOp_Add         & $FFFF ; $8a +
>018544	1a 8f					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018546	2b 8f					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018548	3c 8f					.word BinaryOp_Divide      & $FFFF ; $8d /
>01854a	ea 85					.word NotImplemented       & $FFFF ; $8e ^
>01854c	ea 85					.word NotImplemented       & $FFFF ; $8f if
>01854e	ea 85					.word NotImplemented       & $FFFF ; $90 while
>018550	f0 8b					.word Command_REPEAT       & $FFFF ; $91 repeat
>018552	ea 85					.word NotImplemented       & $FFFF ; $92 for
>018554	ea 85					.word NotImplemented       & $FFFF ; $93 then
>018556	ea 85					.word NotImplemented       & $FFFF ; $94 endif
>018558	ea 85					.word NotImplemented       & $FFFF ; $95 wend
>01855a	f9 8b					.word Command_UNTIL        & $FFFF ; $96 until
>01855c	ea 85					.word NotImplemented       & $FFFF ; $97 next
>01855e	ea 85					.word NotImplemented       & $FFFF ; $98 not
>018560	ea 85					.word NotImplemented       & $FFFF ; $99 fn(
>018562	41 90					.word Unary_Abs            & $FFFF ; $9a abs(
>018564	82 91					.word Unary_Asc            & $FFFF ; $9b asc(
>018566	47 a0					.word Unary_Int            & $FFFF ; $9c int(
>018568	5b 90					.word Unary_Peek           & $FFFF ; $9d peek(
>01856a	c8 9f					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01856c	c2 90					.word Unary_Usr            & $FFFF ; $9f usr(
>01856e	c1 91					.word Unary_Left           & $FFFF ; $a0 left$(
>018570	d6 91					.word Unary_Right          & $FFFF ; $a1 right$(
>018572	a8 91					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018574	1f 93					.word Unary_Spc            & $FFFF ; $a3 spc(
>018576	50 91					.word Unary_Str            & $FFFF ; $a4 str$(
>018578	e4 90					.word Unary_Val            & $FFFF ; $a5 val(
>01857a	99 91					.word Unary_Len            & $FFFF ; $a6 len(
>01857c	4e 92					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01857e	ea 85					.word NotImplemented       & $FFFF ; $a8 sin(
>018580	ea 85					.word NotImplemented       & $FFFF ; $a9 cos(
>018582	ea 85					.word NotImplemented       & $FFFF ; $aa tan(
>018584	ea 85					.word NotImplemented       & $FFFF ; $ab atn(
>018586	ea 85					.word NotImplemented       & $FFFF ; $ac exp(
>018588	ea 85					.word NotImplemented       & $FFFF ; $ad log(
>01858a	ea 85					.word NotImplemented       & $FFFF ; $ae sqr(
>01858c	a4 92					.word Unary_Dec            & $FFFF ; $af dec(
>01858e	5f 90					.word Unary_Deek           & $FFFF ; $b0 deek(
>018590	63 90					.word Unary_Leek           & $FFFF ; $b1 leek(
>018592	8f 90					.word Unary_Mod            & $FFFF ; $b2 mod(
>018594	fb 8f					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018596	01 93					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018598	ea 85					.word NotImplemented       & $FFFF ; $b5 pos(
>01859a	ea 85					.word NotImplemented       & $FFFF ; $b6 tab(
>01859c	ea 85					.word NotImplemented       & $FFFF ; $b7 $
>01859e	ea 85					.word NotImplemented       & $FFFF ; $b8 $(
>0185a0	ea 85					.word NotImplemented       & $FFFF ; $b9 #
>0185a2	ea 85					.word NotImplemented       & $FFFF ; $ba #(
>0185a4	ea 85					.word NotImplemented       & $FFFF ; $bb %
>0185a6	ea 85					.word NotImplemented       & $FFFF ; $bc %(
>0185a8	ea 85					.word NotImplemented       & $FFFF ; $bd (
>0185aa	ea 85					.word NotImplemented       & $FFFF ; $be )
>0185ac	ea 85					.word NotImplemented       & $FFFF ; $bf ,
>0185ae	a0 88					.word Command_COLON        & $FFFF ; $c0 :
>0185b0	ea 85					.word NotImplemented       & $FFFF ; $c1 ;
>0185b2	ea 85					.word NotImplemented       & $FFFF ; $c2 def
>0185b4	d4 8b					.word Command_CLR          & $FFFF ; $c3 clr
>0185b6	e8 8b					.word Command_STOP         & $FFFF ; $c4 stop
>0185b8	ea 85					.word NotImplemented       & $FFFF ; $c5 data
>0185ba	ea 85					.word NotImplemented       & $FFFF ; $c6 read
>0185bc	8a 87					.word Command_DIM          & $FFFF ; $c7 dim
>0185be	ea 85					.word NotImplemented       & $FFFF ; $c8 to
>0185c0	ea 85					.word NotImplemented       & $FFFF ; $c9 step
>0185c2	50 8b					.word Command_GOSUB        & $FFFF ; $ca gosub
>0185c4	5e 8b					.word Command_RETURN       & $FFFF ; $cb return
>0185c6	4a 8b					.word Command_GOTO         & $FFFF ; $cc goto
>0185c8	c2 88					.word Command_END          & $FFFF ; $cd end
>0185ca	ea 85					.word NotImplemented       & $FFFF ; $ce input
>0185cc	a1 88					.word Command_LET          & $FFFF ; $cf let
>0185ce	c6 88					.word Command_LIST         & $FFFF ; $d0 list
>0185d0	f3 8a					.word Command_NEW          & $FFFF ; $d1 new
>0185d2	0f 8b					.word Command_OLD          & $FFFF ; $d2 old
>0185d4	ea 85					.word NotImplemented       & $FFFF ; $d3 on
>0185d6	ea 85					.word NotImplemented       & $FFFF ; $d4 restore
>0185d8	c2 8a					.word Command_POKE         & $FFFF ; $d5 poke
>0185da	3b 8a					.word Command_PRINT        & $FFFF ; $d6 print
>0185dc	12 88					.word Command_RUN          & $FFFF ; $d7 run
>0185de	ea 85					.word NotImplemented       & $FFFF ; $d8 wait
>0185e0	ea 85					.word NotImplemented       & $FFFF ; $d9 sys
>0185e2	c6 8a					.word Command_DOKE         & $FFFF ; $da doke
>0185e4	ca 8a					.word Command_LOKE         & $FFFF ; $db loke
>0185e6	aa 8a					.word Command_ASSERT       & $FFFF ; $dc assert
>0185e8	ea 85					.word NotImplemented       & $FFFF ; $dd get
.0185ea					NotImplemented:
.0185ea	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0185ed	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0185f5	65 6d 65 6e 74 65 64 00
.0185fd					BinaryPrecedence:
>0185fd	01					.byte 1    ; $80 and
>0185fe	01					.byte 1    ; $81 or
>0185ff	01					.byte 1    ; $82 xor
>018600	01					.byte 1    ; $83 eor
>018601	02					.byte 2    ; $84 =
>018602	02					.byte 2    ; $85 <>
>018603	02					.byte 2    ; $86 <
>018604	02					.byte 2    ; $87 <=
>018605	02					.byte 2    ; $88 >
>018606	02					.byte 2    ; $89 >=
>018607	03					.byte 3    ; $8a +
>018608	03					.byte 3    ; $8b -
>018609	04					.byte 4    ; $8c *
>01860a	04					.byte 4    ; $8d /
>01860b	05					.byte 5    ; $8e ^
.01860c					KeywordText:
>01860c	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01860f	4f d2					.byte $4f,$d2                          ; $81 or
>018611	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>018614	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>018617	bd					.byte $bd                              ; $84 =
>018618	3c be					.byte $3c,$be                          ; $85 <>
>01861a	bc					.byte $bc                              ; $86 <
>01861b	3c bd					.byte $3c,$bd                          ; $87 <=
>01861d	be					.byte $be                              ; $88 >
>01861e	3e bd					.byte $3e,$bd                          ; $89 >=
>018620	ab					.byte $ab                              ; $8a +
>018621	ad					.byte $ad                              ; $8b -
>018622	aa					.byte $aa                              ; $8c *
>018623	af					.byte $af                              ; $8d /
>018624	de					.byte $de                              ; $8e ^
>018625	49 c6					.byte $49,$c6                          ; $8f if
>018627	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>01862c	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018632	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>018635	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018639	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>01863e	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018642	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018647	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01864b	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>01864e	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018651	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018655	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>018659	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01865d	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018662	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018666	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01866a	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018670	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018677	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01867c	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018680	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018685	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018689	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01868d	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018692	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018696	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01869a	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01869e	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>0186a2	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>0186a6	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>0186aa	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>0186ae	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>0186b2	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>0186b7	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>0186bc	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>0186c0	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>0186c4	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>0186c9	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>0186cd	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>0186d1	a4					.byte $a4                              ; $b7 $
>0186d2	24 a8					.byte $24,$a8                          ; $b8 $(
>0186d4	a3					.byte $a3                              ; $b9 #
>0186d5	23 a8					.byte $23,$a8                          ; $ba #(
>0186d7	a5					.byte $a5                              ; $bb %
>0186d8	25 a8					.byte $25,$a8                          ; $bc %(
>0186da	a8					.byte $a8                              ; $bd (
>0186db	a9					.byte $a9                              ; $be )
>0186dc	ac					.byte $ac                              ; $bf ,
>0186dd	ba					.byte $ba                              ; $c0 :
>0186de	bb					.byte $bb                              ; $c1 ;
>0186df	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0186e2	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0186e5	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0186e9	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0186ed	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0186f1	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0186f4	54 cf					.byte $54,$cf                          ; $c8 to
>0186f6	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0186fa	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0186ff	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>018705	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018709	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>01870c	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018711	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>018714	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>018718	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>01871b	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>01871e	4f ce					.byte $4f,$ce                          ; $d3 on
>018720	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>018727	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>01872b	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018730	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>018733	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>018737	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>01873a	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>01873e	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018742	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>018748	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01874b	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.01874c					BASIC_Start:
.01874c	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.01874f	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018752	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018754	8d 10 03	sta $0310			sta 	LocalVector
.018757	8d 0c 03	sta $030c			sta 	UserVector
.01875a	a9 d2		lda #$d2			lda 	#USRDefault & $FF 			; reset USR vector
.01875c	8d 0d 03	sta $030d			sta 	UserVector+1
.01875f	a9 90		lda #$90			lda 	#(USRDefault >> 8) & $FF
.018761	8d 0e 03	sta $030e			sta 	UserVector+2
.018764	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018766	8d 0f 03	sta $030f			sta 	UserVector+3
.018769	20 79 93	jsr $019379			jsr 	UpdateProgramEnd 			; update the program end.
.01876c	20 d4 8b	jsr $018bd4			jsr 	ResetRunStatus 				; clear everything (CLR command)
.01876f	c2 30		rep #$30			rep 	#$30
.018771	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018774	1b		tcs				tcs
.018775	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018778	e2 30		sep #$30			sep 	#$30
.01877a	4c 12 88	jmp $018812			jmp 	COMMAND_Run
.01877d					WarmStart:
.01877d	c2 30		rep #$30			rep 	#$30
.01877f	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018782	1b		tcs				tcs
.018783	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018786	e2 30		sep #$30			sep 	#$30
.018788	80 f3		bra $01877d			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01878a					Command_DIM:
.01878a	98		tya				tya
.01878b	48		pha				pha 								; push on stack.
.01878c	20 e1 94	jsr $0194e1			jsr 	VariableExtract 			; get the identifier
.01878f	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018792	29 01		and #$01			and 	#1
.018794	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018796	d0 6c		bne $018804			bne 	_CDIError
.018798	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01879a	8d b8 03	sta $03b8			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.01879d					_CDIGetDimension:
.01879d	ad b8 03	lda $03b8			lda 	UsrArrayIdx 				; done too many ?
.0187a0	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0187a2	f0 60		beq $018804			beq 	_CDIError
.0187a4	20 ad 8d	jsr $018dad			jsr 	EvaluateInteger 			; evaluate an index size
.0187a7	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.0187a9	29 80		and #$80			and 	#$80
.0187ab	05 82		ora $82				ora 	XS_Mantissa+2
.0187ad	05 83		ora $83				ora 	XS_Mantissa+3
.0187af	d0 53		bne $018804			bne 	_CDIError
.0187b1	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy into the array table.
.0187b4	18		clc				clc 								; add 1 - max index => size.
.0187b5	a5 80		lda $80				lda 	XS_Mantissa+0
.0187b7	69 01		adc #$01			adc 	#1
.0187b9	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+0,x
.0187bc	a5 81		lda $81				lda 	XS_Mantissa+1
.0187be	69 00		adc #$00			adc 	#0
.0187c0	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+1,x
.0187c3	30 3f		bmi $018804			bmi 	_CDIError 					; could be dim a(32767)
.0187c5	e8		inx				inx 								; bump index.
.0187c6	e8		inx				inx
.0187c7	8e b8 03	stx $03b8			stx 	UsrArrayIdx
.0187ca	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187cc	c8		iny				iny
.0187cd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0187cf	f0 cc		beq $01879d			beq 	_CDIGetDimension
.0187d1	88		dey				dey
.0187d2	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; closing ) present ?
.0187d5	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy USR array to default
.0187d8	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0187da	9d a9 03	sta $03a9,x			sta 	ArrayDef+1,x
.0187dd					_CDICopy:
.0187dd	bd b0 03	lda $03b0,x			lda 	UsrArrayDef,x
.0187e0	9d a8 03	sta $03a8,x			sta 	ArrayDef,x
.0187e3	ca		dex				dex
.0187e4	10 f7		bpl $0187dd			bpl 	_CDICopy
.0187e6	68		pla				pla									; position of array identifier
.0187e7	85 10		sta $10				sta 	zTemp1
.0187e9	98		tya				tya
.0187ea	48		pha				pha
.0187eb	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0187ed	a8		tay				tay
.0187ee	20 e1 94	jsr $0194e1			jsr 	VariableExtract 			; get the identifier
.0187f1	20 7a 97	jsr $01977a			jsr 	VariableLocate 				; check if it exists already.
.0187f4	b0 0e		bcs $018804			bcs 	_CDIError
.0187f6	20 6d 95	jsr $01956d			jsr 	VariableCreate 				; create it using the current ArrayDef
.0187f9	68		pla				pla 								; restore code position
.0187fa	a8		tay				tay
.0187fb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187fd	c8		iny				iny
.0187fe	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018800	f0 88		beq $01878a			beq 	Command_DIM
.018802	88		dey				dey
.018803	60		rts				rts
.018804					_CDIError:
.018804	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018807	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.01880f					_CDISyntax:
.01880f	4c 9b 84	jmp $01849b			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018812					Command_RUN:
.018812	20 d4 8b	jsr $018bd4			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018815	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018817	85 16		sta $16				sta 	zCodePtr+0
.018819	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01881b	85 17		sta $17				sta 	zCodePtr+1
.01881d	a9 00		lda #$00			lda 	#0
.01881f	85 18		sta $18				sta 	zCodePtr+2
.018821	85 19		sta $19				sta 	zCodePtr+3
.018823	a0 03		ldy #$03			ldy 	#3
.018825					RUN_NewLine:
.018825	a0 00		ldy #$00			ldy 	#0
.018827	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018829	c8		iny				iny
.01882a	c8		iny				iny
.01882b	c8		iny				iny
.01882c	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.01882e	d0 16		bne $018846			bne 	RUN_NextCommand
.018830	4c c2 88	jmp $0188c2			jmp 	Command_END 				; go do the command code.
.018833					RUN_Skip:
.018833	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018835	c8		iny				iny 								; skip
.018836	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018838	90 0c		bcc $018846			bcc 	_SEDone 					; so just skip over it.
.01883a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01883c	90 07		bcc $018845			bcc 	_SEDouble
.01883e	98		tya				tya 								; this is Y + 1
.01883f	18		clc				clc
.018840	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018842	a8		tay				tay 								; back in Y.
.018843	88		dey				dey 								; fix up, one for the +1, one for the iny
.018844	88		dey				dey
.018845					_SEDouble:
.018845	c8		iny				iny
.018846					_SEDone:
.018846					RUN_NextCommand:
.018846	ad a7 03	lda $03a7			lda 	BreakCount 					; break counter
.018849	69 10		adc #$10			adc 	#16 						; one time in 16
.01884b	8d a7 03	sta $03a7			sta 	BreakCount
.01884e	90 0a		bcc $01885a			bcc 	RUN_NoCheckBreak
.018850	20 98 84	jsr $018498			jsr 	CheckBreak 					; check for break
.018853	c9 00		cmp #$00			cmp 	#0
.018855	f0 03		beq $01885a			beq 	RUN_NoCheckBreak
.018857	4c e8 8b	jmp $018be8			jmp 	Command_STOP 				; stop on BREAK.
.01885a					RUN_NoCheckBreak:
.01885a	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01885c	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.01885e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018860	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018862	f0 cf		beq $018833			beq 	RUN_Skip
.018864	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018866	d0 0f		bne $018877			bne 	RUN_Execute
.018868					RUN_NextLine:
.018868	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01886a	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01886c	18		clc				clc
.01886d	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01886f	85 16		sta $16				sta 	zCodePtr
.018871	90 02		bcc $018875			bcc 	_SNLNoCarry
.018873	e6 17		inc $17				inc 	zCodePtr+1
.018875					_SNLNoCarry:
.018875	80 ae		bra $018825			bra 	RUN_NewLine 				; go do the new line code
.018877					RUN_Execute:
.018877	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018879	b0 1e		bcs $018899			bcs 	RUN_Extension
.01887b	c8		iny				iny
.01887c	0a		asl a				asl 	a 							; double the character read.
.01887d	90 14		bcc $018893			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.01887f	aa		tax				tax 								; ready to look up.
.018880	bf 2e 85 01	lda $01852e,x			lda 	VectorTable,x 				; copy address into LocalVector
.018884	8d 11 03	sta $0311			sta 	LocalVector+1
.018887	bf 2f 85 01	lda $01852f,x			lda 	VectorTable+1,x
.01888b	8d 12 03	sta $0312			sta 	LocalVector+2
.01888e	20 fa 8c	jsr $018cfa			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018891	80 b3		bra $018846			bra 	RUN_NextCommand 			; do the next command.
.018893					RUN_Default:
.018893	88		dey				dey
.018894	20 a1 88	jsr $0188a1			jsr 	Command_LET 				; and try LET.
.018897	80 ad		bra $018846			bra 	RUN_NextCommand
.018899					RUN_Extension:
.018899	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01889b	f0 96		beq $018833			beq 	RUN_Skip 					; skip over it.
.01889d	4c 9b 84	jmp $01849b			jmp 	SyntaxError
.0188a0					Command_COLON:
.0188a0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.0188a1					Command_LET:
.0188a1	20 76 94	jsr $019476			jsr 	VariableFind 				; get reference to one variable.
.0188a4	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.0188a6	20 be 93	jsr $0193be			jsr 	CheckNextToken
.0188a9	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.0188ab	48		pha				pha
.0188ac	a5 23		lda $23				lda 	zVarDataPtr+1
.0188ae	48		pha				pha
.0188af	a5 24		lda $24				lda 	zVarType
.0188b1	48		pha				pha
.0188b2	20 17 8c	jsr $018c17			jsr 	EvaluateExpression 			; evaluate the RHS.
.0188b5	68		pla				pla 								; restore target variable information.
.0188b6	85 24		sta $24				sta 	zVarType
.0188b8	68		pla				pla
.0188b9	85 23		sta $23				sta 	zVarDataPtr+1
.0188bb	68		pla				pla
.0188bc	85 22		sta $22				sta 	zVarDataPtr
.0188be	20 0f 98	jsr $01980f			jsr 	VariableSet 				; set the value out.
.0188c1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.0188c2					Command_END:
>0188c2	02						.byte 	2
.0188c3	4c 7d 87	jmp $01877d			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.0188c6					Command_LIST:
.0188c6	20 e0 89	jsr $0189e0			jsr 	ListGetRange				; get any parameters
.0188c9	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188cb	85 16		sta $16				sta 	zCodePtr+0
.0188cd	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188cf	85 17		sta $17				sta 	zCodePtr+1
.0188d1	a9 00		lda #$00			lda 	#0
.0188d3	85 18		sta $18				sta 	zCodePtr+2
.0188d5	85 19		sta $19				sta 	zCodePtr+3
.0188d7	a0 03		ldy #$03			ldy 	#3
.0188d9					_CILLoop:
.0188d9	a0 00		ldy #$00			ldy 	#0
.0188db	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188dd	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.0188df	f0 23		beq $018904			beq 	_CILExit
.0188e1	20 98 84	jsr $018498			jsr 	CheckBreak 					; check break
.0188e4	c9 00		cmp #$00			cmp 	#0
.0188e6	d0 1c		bne $018904			bne 	_CILExit
.0188e8	20 1b 8a	jsr $018a1b			jsr 	ListCheckRange 				; check current line in range.
.0188eb	b0 08		bcs $0188f5			bcs		_CILNext
.0188ed	a0 00		ldy #$00			ldy 	#0
.0188ef	c8		iny				iny
.0188f0	c8		iny				iny
.0188f1	c8		iny				iny
.0188f2	20 07 89	jsr $018907			jsr 	ListLine 					; list one line.
.0188f5					_CILNext:
.0188f5	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0188f7	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0188f9	18		clc				clc
.0188fa	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0188fc	85 16		sta $16				sta 	zCodePtr
.0188fe	90 02		bcc $018902			bcc 	_SNLNoCarry
.018900	e6 17		inc $17				inc 	zCodePtr+1
.018902					_SNLNoCarry:
.018902	80 d5		bra $0188d9			bra 	_CILLoop
.018904					_CILExit:
.018904	4c 7d 87	jmp $01877d			jmp 	WarmStart
.018907					ListLine:
.018907	a0 00		ldy #$00			ldy 	#0
.018909	c8		iny				iny
.01890a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01890c	85 80		sta $80				sta 	XS_Mantissa
.01890e	c8		iny				iny
.01890f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018911	85 81		sta $81				sta 	XS_Mantissa+1
.018913	20 10 85	jsr $018510			jsr 	Print16BitInteger 			; print integer.
.018916	aa		tax				tax 								; print spaces to column 6
.018917					_LISpace:
.018917	a9 20		lda #$20			lda 	#" "
.018919	20 92 84	jsr $018492			jsr 	CharPrint
.01891c	e8		inx				inx
.01891d	e0 06		cpx #$06			cpx 	#6
.01891f	d0 f6		bne $018917			bne 	_LISpace
.018921					_LIDecode:
.018921	c8		iny				iny
.018922	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018924	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018926	f0 0f		beq $018937			beq 	_LIExit
.018928	30 12		bmi $01893c			bmi 	_LIToken
.01892a	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.01892c	b0 50		bcs $01897e			bcs 	_LIInteger
.01892e	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018930	69 20		adc #$20			adc 	#$20
.018932	20 d3 89	jsr $0189d3			jsr 	ListPrintLC 				; print in LC
.018935	80 ea		bra $018921			bra 	_LIDecode
.018937					_LIExit:
.018937	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018939	4c 92 84	jmp $018492			jmp 	CharPrint
.01893c					_LIToken:
.01893c	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.01893e	90 49		bcc $018989			bcc		_LICommandToken
.018940	48		pha				pha 								; save in case end
.018941	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018943	c9 fe		cmp #$fe			cmp 	#$FE
.018945	f0 17		beq $01895e			beq 	_LIPrint
.018947	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018949	c9 fd		cmp #$fd			cmp 	#$FD
.01894b	f0 11		beq $01895e			beq 	_LIPrint
.01894d	a9 52		lda #$52			lda 	#'R'						; must be REM
.01894f	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.018952	a9 45		lda #$45			lda 	#'E'
.018954	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.018957	a9 4d		lda #$4d			lda 	#'M'
.018959	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.01895c	a2 20		ldx #$20			ldx 	#' '
.01895e					_LIPrint:
.01895e	8a		txa				txa
.01895f	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.018962	c8		iny				iny
.018963	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018965	aa		tax				tax 								; put in X
.018966	ca		dex				dex
.018967					_LILoop:
.018967	ca		dex				dex 								; exit when count reached zero.
.018968	f0 08		beq $018972			beq 	_LIEnd
.01896a	c8		iny				iny
.01896b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01896d	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.018970	80 f5		bra $018967			bra 	_LILoop
.018972	68		pla		_LIEnd:	pla 								; get A back
.018973	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018975	d0 aa		bne $018921			bne 	_LIDecode
.018977	a9 22		lda #$22			lda 	#'"'
.018979	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.01897c	80 a3		bra $018921			bra 	_LIDecode
.01897e					_LIInteger:
.01897e	a2 00		ldx #$00			ldx 	#0
.018980	20 1f 8d	jsr $018d1f			jsr 	EvaluateGetInteger 			; get an atom
.018983	88		dey				dey
.018984	20 16 85	jsr $018516			jsr 	Print32BitInteger 			; print integer.
.018987	80 98		bra $018921			bra 	_LIDecode
.018989					_LICommandToken:
.018989	5a		phy				phy 								; save Y
.01898a	48		pha				pha 								; save token
.01898b	a2 0c		ldx #$0c			ldx  	#KeywordText & $FF 			; address of keyword text table.
.01898d	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.01898f	86 1a		stx $1a				stx 	zLTemp1
.018991	85 1b		sta $1b				sta 	zLTemp1+1
.018993	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018995	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018997	68		pla				pla 								; get token, chuck bit 7.
.018998	29 7f		and #$7f			and 	#127
.01899a	f0 16		beq $0189b2			beq 	_LIFoundToken
.01899c	aa		tax				tax
.01899d					_LITokenLoop:
.01899d	a0 00		ldy #$00			ldy 	#0
.01899f					_LIFindEnd:
.01899f	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.0189a1	c8		iny				iny
.0189a2	0a		asl a				asl 	a
.0189a3	90 fa		bcc $01899f			bcc 	_LIFindEnd
.0189a5	98		tya				tya 								; that is step to the next
.0189a6	18		clc				clc 								; we don't bother bumping the 3rd byte
.0189a7	65 1a		adc $1a				adc 	zLTemp1 					; here.
.0189a9	85 1a		sta $1a				sta 	zLTemp1
.0189ab	90 02		bcc $0189af			bcc 	_LINoBump
.0189ad	e6 1b		inc $1b				inc 	zLTemp1+1
.0189af					_LINoBump:
.0189af	ca		dex				dex 								; no go round again.
.0189b0	d0 eb		bne $01899d			bne 	_LITokenLoop
.0189b2					_LIFoundToken:
.0189b2	a0 00		ldy #$00			ldy 	#0
.0189b4					_LIPrintToken:
.0189b4	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.0189b6	c8		iny				iny
.0189b7	48		pha				pha 								; save it
.0189b8	29 7f		and #$7f			and 	#$7F
.0189ba	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.0189bd	68		pla				pla
.0189be	10 f4		bpl $0189b4			bpl 	_LIPrintToken 				; go back if not end
.0189c0	7a		ply				ply 								; restore Y
.0189c1	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.0189c3	c9 41		cmp #$41			cmp 	#"A"
.0189c5	90 09		bcc $0189d0			bcc 	_LINotLetter
.0189c7	c9 5b		cmp #$5b			cmp 	#"Z"+1
.0189c9	b0 05		bcs $0189d0			bcs 	_LINotLetter
.0189cb	a9 20		lda #$20			lda 	#" " 						; add spacing
.0189cd	20 d3 89	jsr $0189d3			jsr 	ListPrintLC
.0189d0					_LINotLetter:
.0189d0	4c 21 89	jmp $018921			jmp 	_LIDecode
.0189d3					ListPrintLC:
.0189d3	c9 41		cmp #$41			cmp 	#"A"
.0189d5	90 06		bcc $0189dd			bcc 	_LPLC0
.0189d7	c9 5b		cmp #$5b			cmp 	#"Z"+1
.0189d9	b0 02		bcs $0189dd			bcs 	_LPLC0
.0189db	69 20		adc #$20			adc 	#$20
.0189dd	4c 92 84	jmp $018492	_LPLC0:	jmp 	CharPrint
.0189e0					ListGetRange:
.0189e0	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.0189e2					_LGRClear:
.0189e2	a9 00		lda #$00			lda 	#0
.0189e4	95 80		sta $80,x			sta 	XS_Mantissa,x
.0189e6	ca		dex				dex
.0189e7	10 f9		bpl $0189e2			bpl 	_LGRClear
.0189e9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189eb	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.0189ed	f0 18		beq $018a07			beq 	_LGREnd 					; then it's LIST ,x
.0189ef	20 ad 8d	jsr $018dad			jsr 	EvaluateInteger 			; get the first number into bottom
.0189f2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189f4	c9 bf		cmp #$bf			cmp 	#token_Comma
.0189f6	f0 0f		beq $018a07			beq 	_LGREnd 					; then it is LIST a,b
.0189f8	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.0189fa	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.0189fc	a5 81		lda $81				lda 	XS_Mantissa+1
.0189fe	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018a00					_LGRBumpExit:
.018a00	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018a02	d0 02		bne $018a06			bne 	_LGRBump2
.018a04	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018a06					_LGRBump2:
.018a06	60		rts				rts
.018a07					_LGREnd:
.018a07	c8		iny				iny
.018a08	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018a0a	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018a0c	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018a0e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a10	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018a11	b0 f3		bcs $018a06			bcs 	_LGRBump2
.018a13	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018a15	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX
.018a18	80 e6		bra $018a00			bra 	_LGRBumpExit
.018a1a	60		rts				rts
.018a1b					ListCheckRange:
.018a1b	c8		iny				iny
.018a1c	a2 00		ldx #$00			ldx 	#0 							; test low
.018a1e	20 2b 8a	jsr $018a2b			jsr 	_LCRCompare
.018a21	90 06		bcc $018a29			bcc 	_LCRFail
.018a23	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018a25	20 2b 8a	jsr $018a2b			jsr 	_LCRCompare
.018a28	60		rts				rts
.018a29					_LCRFail:
.018a29	38		sec				sec
.018a2a	60		rts				rts
.018a2b					_LCRCompare:
.018a2b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a2d	38		sec				sec
.018a2e	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018a30	08		php				php
.018a31	c8		iny				iny
.018a32	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a34	28		plp				plp
.018a35	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018a37	08		php				php
.018a38	88		dey				dey
.018a39	28		plp				plp
.018a3a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018a3b					Command_PRINT:
.018a3b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a3d	c9 00		cmp #$00			cmp 	#0 							; end
.018a3f	f0 65		beq $018aa6			beq 	_CPR_NewLine
.018a41	c9 c0		cmp #$c0			cmp 	#token_Colon
.018a43	f0 61		beq $018aa6			beq 	_CPR_NewLine
.018a45	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018a47	f0 50		beq $018a99			beq 	_CPR_Skip
.018a49	c9 bf		cmp #$bf			cmp 	#token_Comma
.018a4b	f0 49		beq $018a96			beq 	_CPR_Tab
.018a4d	20 17 8c	jsr $018c17			jsr 	EvaluateExpression 			; get expression.
.018a50	a5 85		lda $85				lda 	XS_Type 					; get type.
.018a52	29 02		and #$02			and 	#2
.018a54	d0 24		bne $018a7a			bne 	_CPR_String 				; if type = 2 output as string.
.018a56					_CPR_Number:
.018a56	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018a58	8d 14 03	sta $0314			sta 	NumBufX
.018a5b	a5 85		lda $85				lda 	XS_Type 					; get type
.018a5d	4a		lsr a				lsr 	a
.018a5e	b0 05		bcs $018a65			bcs 	_CPRInt 					; if msb set do as integer
.018a60	20 93 9e	jsr $019e93			jsr 	FPToString 					; call fp to str otherwise
.018a63	80 03		bra $018a68			bra 	_CPRNPrint
.018a65	20 58 99	jsr $019958	_CPRInt:jsr 	IntToString
.018a68					_CPRNPrint:
.018a68	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018a6b	c9 2d		cmp #$2d			cmp 	#"-"
.018a6d	f0 05		beq $018a74			beq 	_CPRNoSpace
.018a6f	a9 20		lda #$20			lda 	#" "						; print the leading space
.018a71	20 92 84	jsr $018492			jsr 	CharPrint 					; so beloved of MS Basics.
.018a74					_CPRNoSpace:
.018a74	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018a76	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018a78	80 04		bra $018a7e			bra 	_CPRPrint
.018a7a					_CPR_String:
.018a7a	a6 80		ldx $80				ldx 	XS_Mantissa
.018a7c	a5 81		lda $81				lda 	XS_Mantissa+1
.018a7e					_CPRPrint:
.018a7e	86 1e		stx $1e				stx 	zGenPtr
.018a80	85 1f		sta $1f				sta 	zGenPtr+1
.018a82	5a		phy				phy
.018a83	a0 00		ldy #$00			ldy 	#0							; get length into X
.018a85	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018a87	aa		tax				tax
.018a88	f0 09		beq $018a93			beq 	_CPREndPrint 				; nothing to print
.018a8a					_CPRLoop:
.018a8a	c8		iny				iny
.018a8b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018a8d	20 92 84	jsr $018492			jsr 	CharPrint
.018a90	ca		dex				dex
.018a91	d0 f7		bne $018a8a			bne 	_CPRLoop
.018a93					_CPREndPrint:
.018a93	7a		ply				ply
.018a94	80 a5		bra $018a3b			bra 	Command_Print
.018a96					_CPR_Tab:
.018a96	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018a99					_CPR_Skip:
.018a99	c8		iny				iny
.018a9a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a9c	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018a9e	f0 09		beq $018aa9			beq 	_CPR_Exit
.018aa0	c9 00		cmp #$00			cmp 	#0
.018aa2	d0 97		bne $018a3b			bne 	Command_PRINT 				; if not go round again.
.018aa4	80 03		bra $018aa9			bra 	_CPR_Exit
.018aa6					_CPR_NewLine:
.018aa6	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018aa9					_CPR_Exit:
.018aa9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018aaa					Command_ASSERT:
.018aaa	20 ad 8d	jsr $018dad			jsr 	EvaluateInteger 			; calculate thing being asserted
.018aad	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018aaf	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018ab1	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018ab3	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018ab5	f0 01		beq $018ab8			beq 	_ASFail
.018ab7	60		rts				rts
.018ab8					_ASFail:
.018ab8	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018abb	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018ac2					Command_POKE:
.018ac2	a9 01		lda #$01			lda 	#1
.018ac4	80 06		bra $018acc			bra 	CmdPoke_Main
.018ac6					Command_DOKE:
.018ac6	a9 02		lda #$02			lda 	#2
.018ac8	80 02		bra $018acc			bra 	CmdPoke_Main
.018aca					Command_LOKE:
.018aca	a9 04		lda #$04			lda 	#4
.018acc					CmdPoke_Main:
.018acc	48		pha				pha
.018acd	20 ad 8d	jsr $018dad			jsr 	EvaluateInteger 			; get two parameters.
.018ad0	e8		inx				inx
.018ad1	e8		inx				inx
.018ad2	e8		inx				inx
.018ad3	e8		inx				inx
.018ad4	e8		inx				inx
.018ad5	e8		inx				inx
.018ad6	20 dd 93	jsr $0193dd			jsr 	CheckNextComma
.018ad9	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX
.018adc	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018ade	85 1a		sta $1a				sta 	zLTemp1
.018ae0	a5 81		lda $81				lda 	XS_Mantissa+1
.018ae2	85 1b		sta $1b				sta 	zLTemp1+1
.018ae4	a5 82		lda $82				lda 	XS_Mantissa+2
.018ae6	85 1c		sta $1c				sta 	zLTemp1+2
.018ae8	a5 83		lda $83				lda 	XS_Mantissa+3
.018aea	85 1d		sta $1d				sta 	zLTemp1+3
.018aec	68		pla				pla 								; get count
.018aed	5a		phy				phy 								; save Y
.018aee	20 68 93	jsr $019368			jsr 	MemWrite 					; write it out
.018af1	7a		ply				ply 								; restore Y and done.
.018af2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018af3					Command_NEW:
.018af3	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018af5	85 16		sta $16				sta 	zCodePtr+0
.018af7	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018af9	85 17		sta $17				sta 	zCodePtr+1
.018afb	a9 00		lda #$00			lda 	#0
.018afd	85 18		sta $18				sta 	zCodePtr+2
.018aff	85 19		sta $19				sta 	zCodePtr+3
.018b01	a0 03		ldy #$03			ldy 	#3
.018b03	a0 00		ldy #$00			ldy 	#0
.018b05	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018b07	97 16		sta [$16],y			sta 	[zCodePtr],y
.018b09	20 79 93	jsr $019379			jsr 	UpdateProgramEnd 			; update program end.
.018b0c	4c 7d 87	jmp $01877d			jmp 	WarmStart
.018b0f					Command_OLD:
.018b0f	ea		nop				nop
.018b10	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b12	85 16		sta $16				sta 	zCodePtr+0
.018b14	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b16	85 17		sta $17				sta 	zCodePtr+1
.018b18	a9 00		lda #$00			lda 	#0
.018b1a	85 18		sta $18				sta 	zCodePtr+2
.018b1c	85 19		sta $19				sta 	zCodePtr+3
.018b1e	a0 03		ldy #$03			ldy 	#3
.018b20					_COL_Find:
.018b20	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b22	c8		iny				iny
.018b23	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018b25	f0 18		beq $018b3f			beq 	_COL_Found
.018b27	98		tya				tya
.018b28	c9 00		cmp #$00			cmp 	#0
.018b2a	d0 f4		bne $018b20			bne 	_COL_Find 					; can't find old EOL, give up.
.018b2c	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018b2f	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018b37	43 6f 72 72 75 70 74 00
.018b3f					_COL_Found:
.018b3f	98		tya				tya
.018b40	48		pha				pha
.018b41	a0 00		ldy #$00			ldy 	#0
.018b43	68		pla				pla
.018b44	97 16		sta [$16],y			sta 	[zCodePtr],y
.018b46	20 79 93	jsr $019379			jsr 	UpdateProgramEnd 			; reset variable pointer
.018b49	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018b4a					Command_GOTO:
.018b4a	20 67 8b	jsr $018b67			jsr 	GotoGetLineNumber
.018b4d	4c 84 8b	jmp $018b84			jmp 	GotoChangeToLineNumber
.018b50					Command_GOSUB:
.018b50	20 67 8b	jsr $018b67			jsr 	GotoGetLineNumber
.018b53	20 59 84	jsr $018459			jsr 	StackSavePosition
.018b56	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018b58	20 12 84	jsr $018412			jsr 	StackPushFrame
.018b5b	4c 84 8b	jmp $018b84			jmp 	GotoChangeToLineNumber
.018b5e					Command_RETURN:
.018b5e	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.018b60	20 29 84	jsr $018429			jsr 	StackPopFrame
.018b63	20 76 84	jsr $018476			jsr 	StackRestorePosition
.018b66	60		rts				rts
.018b67					GotoGetLineNumber:
.018b67	20 ad 8d	jsr $018dad			jsr 	EvaluateInteger
.018b6a	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018b6c	05 83		ora $83				ora 	XS_Mantissa+3
.018b6e	d0 01		bne $018b71			bne 	_GLINError
.018b70	60		rts				rts
.018b71					_GLINError:
.018b71	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018b74	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018b7c	20 4e 75 6d 62 65 72 00
.018b84					GotoChangeToLineNumber:
.018b84	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.018b86	05 81		ora $81				ora 	XS_Mantissa+1
.018b88	f0 37		beq $018bc1			beq 	_GCTLFail
.018b8a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b8c	85 16		sta $16				sta 	zCodePtr+0
.018b8e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b90	85 17		sta $17				sta 	zCodePtr+1
.018b92	a9 00		lda #$00			lda 	#0
.018b94	85 18		sta $18				sta 	zCodePtr+2
.018b96	85 19		sta $19				sta 	zCodePtr+3
.018b98	a0 03		ldy #$03			ldy 	#3
.018b9a					_GCTLLoop:
.018b9a	a0 00		ldy #$00			ldy 	#0
.018b9c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b9e	c9 00		cmp #$00			cmp 	#0
.018ba0	f0 1f		beq $018bc1			beq 	_GCTLFail
.018ba2	c8		iny				iny
.018ba3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ba5	c5 80		cmp $80				cmp 	XS_Mantissa+0
.018ba7	d0 07		bne $018bb0			bne 	_GCTLNext
.018ba9	c8		iny				iny
.018baa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bac	c5 81		cmp $81				cmp 	XS_Mantissa+1
.018bae	f0 0f		beq $018bbf			beq 	_GCTLExit
.018bb0					_GCTLNext:
.018bb0	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018bb2	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018bb4	18		clc				clc
.018bb5	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018bb7	85 16		sta $16				sta 	zCodePtr
.018bb9	90 02		bcc $018bbd			bcc 	_SNLNoCarry
.018bbb	e6 17		inc $17				inc 	zCodePtr+1
.018bbd					_SNLNoCarry:
.018bbd	80 db		bra $018b9a			bra 	_GCTLLoop 					; try next line.
.018bbf					_GCTLExit:
.018bbf	c8		iny				iny
.018bc0	60		rts				rts
.018bc1					_GCTLFail:
.018bc1	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018bc4	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018bcc	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018bd4					Command_CLR:
.018bd4					ResetRunStatus:
.018bd4	20 b2 94	jsr $0194b2			jsr 	VariableClear
.018bd7	20 00 84	jsr $018400			jsr 	StackReset
.018bda	a9 00		lda #$00			lda 	#HighMemory & $FF
.018bdc	8d 00 03	sta $0300			sta 	StringPtr
.018bdf	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018be1	8d 01 03	sta $0301			sta 	StringPtr+1
.018be4	20 7c 96	jsr $01967c			jsr 	ArrayResetDefault
.018be7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018be8					Command_STOP:
.018be8	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018beb	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018bf0					Command_REPEAT:
.018bf0	20 59 84	jsr $018459			jsr 	StackSavePosition			; save position into stack
.018bf3	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018bf5	20 12 84	jsr $018412			jsr 	StackPushFrame 				; push on stack
.018bf8	60		rts				rts
.018bf9					Command_UNTIL:
.018bf9	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.018bfb	20 29 84	jsr $018429			jsr 	StackPopFrame
.018bfe	20 ad 8d	jsr $018dad			jsr 	EvaluateInteger				; work out UNTIL
.018c01	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018c03	05 81		ora $81				ora 	XS_Mantissa+1
.018c05	05 82		ora $82				ora 	XS_Mantissa+2
.018c07	05 83		ora $83				ora 	XS_Mantissa+3
.018c09	d0 08		bne $018c13			bne 	_CUTExit 					; if not, just exit
.018c0b	20 76 84	jsr $018476			jsr 	StackRestorePosition 		; otherwise loop round again.
.018c0e	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018c10	20 12 84	jsr $018412			jsr 	StackPushFrame 				; fix the stack back.
.018c13					_CUTExit:
.018c13	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018c14					EVESyntax:
.018c14	4c 9b 84	jmp $01849b			jmp 	SyntaxError
.018c17					EvaluateExpression:
.018c17	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018c19					EvaluateExpressionX:
.018c19	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018c1b					EvaluateExpressionXA:
.018c1b	48		pha				pha 								; save precedence on stack.
.018c1c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c1e	f0 f4		beq $018c14			beq 	EVESyntax 					; end of line, syntax error.
.018c20	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018c22	b0 03		bcs $018c27			bcs 	_EVNotVariable
.018c24	4c f1 8c	jmp $018cf1			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018c27					_EVNotVariable:
.018c27	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018c29	90 e9		bcc $018c14			bcc 	EVESyntax
.018c2b	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018c2d	b0 58		bcs $018c87			bcs 	_EVNotInteger
.018c2f	20 1f 8d	jsr $018d1f			jsr 	EvaluateGetInteger
.018c32					_EVCheckDecimal:
.018c32	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c34	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018c36	d0 05		bne $018c3d			bne 	_EVGotAtom 					; no, get atom.
.018c38					_EVIsDecimal:
.018c38	20 45 8d	jsr $018d45			jsr 	EVGetDecimal 				; extend to the decimal part.
.018c3b	80 00		bra $018c3d			bra 	_EVGotAtom 					; and continue to got atom.
.018c3d					_EVGotAtom:
.018c3d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c3f	10 44		bpl $018c85			bpl 	_EVExitDrop 				; must be a token.
.018c41	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018c43	b0 40		bcs $018c85			bcs 	_EVExitDrop
.018c45	68		pla				pla 								; get current precedence
.018c46	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018c48	da		phx				phx 								; save X
.018c49	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c4b	aa		tax				tax 								; put in X
.018c4c	bf 7d 85 01	lda $01857d,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018c50	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018c52	fa		plx				plx 								; restore X
.018c53	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018c55	90 2f		bcc $018c86			bcc 	_EVExit 					; exit if too low.
.018c57	f0 2d		beq $018c86			beq 	_EVExit 					; exit if equals
.018c59	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018c5b	48		pha				pha
.018c5c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c5e	48		pha				pha
.018c5f	c8		iny				iny
.018c60	da		phx				phx 								; save current position
.018c61	e8		inx				inx
.018c62	e8		inx				inx
.018c63	e8		inx				inx
.018c64	e8		inx				inx
.018c65	e8		inx				inx
.018c66	e8		inx				inx
.018c67	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018c69	20 1b 8c	jsr $018c1b			jsr 	EvaluateExpressionXA 		; do the RHS.
.018c6c	fa		plx				plx 								; restore X
.018c6d	68		pla				pla 								; get the binary operator in A.
.018c6e					_EVCallA:
.018c6e	da		phx				phx 								; save X again
.018c6f	0a		asl a				asl 	a 							; double, lose the MSB.
.018c70	aa		tax				tax									; put in X
.018c71	bf 2e 85 01	lda $01852e,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018c75	8d 11 03	sta $0311			sta 	LocalVector+1
.018c78	bf 2f 85 01	lda $01852f,x			lda 	VectorTable+1,x
.018c7c	8d 12 03	sta $0312			sta 	LocalVector+2
.018c7f	fa		plx				plx 								; restore X
.018c80	20 fa 8c	jsr $018cfa			jsr 	EVCallLocalVector
.018c83	80 b8		bra $018c3d			bra 	_EVGotAtom 					; and loop back.
.018c85					_EVExitDrop:
.018c85	68		pla				pla
.018c86					_EVExit:
.018c86	60		rts				rts
.018c87					_EVNotInteger:
.018c87	c8		iny				iny
.018c88	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018c8a	d0 16		bne $018ca2			bne 	_EVNotMinus
.018c8c	20 8e 8d	jsr $018d8e			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018c8f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018c91	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018c93	f0 05		beq $018c9a			beq 	_EVMinusFloat
.018c95	20 3b 99	jsr $01993b			jsr 	IntegerNegateAlways 		; negation
.018c98	80 a3		bra $018c3d			bra 	_EVGotAtom 					; and go back.
.018c9a					_EVMinusFloat:
.018c9a	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.018c9c	49 80		eor #$80			eor 	#$80
.018c9e	95 85		sta $85,x			sta 	XS_Type,x
.018ca0	80 9b		bra $018c3d			bra 	_EVGotAtom
.018ca2					_EVNotMinus:
.018ca2	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.018ca4	d0 17		bne $018cbd			bne 	_EVNotParenthesis
.018ca6	20 19 8c	jsr $018c19			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.018ca9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cab	c8		iny				iny
.018cac	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.018cae	f0 8d		beq $018c3d			beq 	_EVGotAtom
.018cb0	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018cb3	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018cbb	29 00
.018cbd					_EVNotParenthesis:
.018cbd	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.018cbf	d0 0c		bne $018ccd			bne 	_EVNotNot
.018cc1	20 8e 8d	jsr $018d8e			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018cc4	20 94 9d	jsr $019d94			jsr 	FPUToInteger 				; make it an integer - if possible.
.018cc7	20 73 8d	jsr $018d73			jsr 	NotInteger 					; do the not calculation
.018cca	4c 3d 8c	jmp $018c3d			jmp 	_EVGotAtom
.018ccd					_EVNotNot:
.018ccd	c9 fe		cmp #$fe			cmp 	#$FE
.018ccf	d0 12		bne $018ce3			bne 	_EVNotString
.018cd1	20 50 94	jsr $019450			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.018cd4	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018cd6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018cd8	a5 21		lda $21				lda 	zTempStr+1
.018cda	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018cdc	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018cde	95 85		sta $85,x			sta 	XS_Type,x
.018ce0	4c 3d 8c	jmp $018c3d			jmp 	_EVGotAtom
.018ce3					_EVNotString:
.018ce3	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018ce5	90 04		bcc $018ceb			bcc 	_EVBadElement
.018ce7	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.018ce9	90 03		bcc $018cee			bcc 	_EVUnaryFunction
.018ceb					_EVBadElement:
.018ceb	4c 9b 84	jmp $01849b			jmp 	SyntaxError
.018cee					_EVUnaryFunction:
.018cee	4c 6e 8c	jmp $018c6e			jmp 	_EVCallA
.018cf1					_EVVariableHandler:
.018cf1	20 76 94	jsr $019476			jsr 	VariableFind 				; locate a variable
.018cf4	20 be 97	jsr $0197be			jsr 	VariableGet 				; copy into memory.
.018cf7	4c 3d 8c	jmp $018c3d			jmp 	_EVGotAtom 					; and go round.
.018cfa					EVCallLocalVector:
.018cfa	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.018cfd					EVShiftMantissaLeft6:
.018cfd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018cff	95 84		sta $84,x			sta 	XS_Exponent,x
.018d01	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018d03	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d05	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d07	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d09	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018d0b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d0d	a9 00		lda #$00			lda 	#0
.018d0f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d11	20 14 8d	jsr $018d14			jsr 	_EVSMLShift 					; call it here to do it twice
.018d14					_EVSMLShift:
.018d14	56 84		lsr $84,x			lsr 	XS_Exponent,x
.018d16	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.018d18	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.018d1a	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.018d1c	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.018d1e	60		rts				rts
.018d1f					EvaluateGetInteger:
.018d1f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d21	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018d23	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018d25	a9 00		lda #$00			lda 	#0
.018d27	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d29	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d2b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d2d	1a		inc a				inc 	a 							; set to type 1 (integer)
.018d2e	95 85		sta $85,x			sta 	XS_Type,x
.018d30					_EVCheckNextInteger:
.018d30	c8		iny				iny
.018d31	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d33	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018d35	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018d37	b0 0b		bcs $018d44			bcs 	_EVEndInteger
.018d39	48		pha				pha 								; save it.
.018d3a	20 fd 8c	jsr $018cfd			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018d3d	68		pla				pla
.018d3e	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018d40	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d42	80 ec		bra $018d30			bra 	_EVCheckNextInteger
.018d44					_EVEndInteger:
.018d44	60		rts				rts
.018d45					EVGetDecimal:
.018d45	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018d47	8d 15 03	sta $0315			sta 	Num_Buffer
.018d4a	da		phx				phx
.018d4b	c8		iny				iny
.018d4c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d4e	c8		iny				iny
.018d4f	3a		dec a				dec 	a								; convert to a string length.
.018d50	3a		dec a				dec 	a
.018d51	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018d53					_EVGDCopy:
.018d53	48		pha				pha 									; save count
.018d54	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d56	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.018d59	e8		inx				inx 									; forward ....
.018d5a	c8		iny				iny
.018d5b	68		pla				pla 									; get count
.018d5c	3a		dec a				dec 	a 								; until zero
.018d5d	d0 f4		bne $018d53			bne 	_EVGDCopy
.018d5f	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018d62	fa		plx				plx 									; restore X
.018d63	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018d65	85 1e		sta $1e				sta 	zGenPtr
.018d67	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.018d69	85 1f		sta $1f				sta 	zGenPtr+1
.018d6b	5a		phy				phy 									; save Y
.018d6c	a0 00		ldy #$00			ldy 	#0 								; start position
.018d6e	20 4e 9f	jsr $019f4e			jsr 	FPFromString 					; convert current
.018d71	7a		ply				ply 									; restore Y
.018d72	60		rts				rts
.018d73					NotInteger:
.018d73	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018d75	49 ff		eor #$ff			eor 	#$FF
.018d77	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018d79	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018d7b	49 ff		eor #$ff			eor 	#$FF
.018d7d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018d7f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018d81	49 ff		eor #$ff			eor 	#$FF
.018d83	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018d85	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018d87	49 ff		eor #$ff			eor 	#$FF
.018d89	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018d8b	60		rts				rts
.018d8c					EvaluateGetAtom:
.018d8c	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018d8e					EvaluateGetAtomX:
.018d8e	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018d90	20 1b 8c	jsr $018c1b			jsr 	EvaluateExpressionXA
.018d93	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018d95	29 0f		and #$0f			and 	#15
.018d97	c9 02		cmp #$02			cmp 	#2
.018d99	b0 01		bcs $018d9c			bcs 	EvaluateType
.018d9b	60		rts				rts
.018d9c					EvaluateType:
.018d9c	4c ab 84	jmp $0184ab			jmp 	TypeError
.018d9f					EvaluateNumber:
.018d9f	a2 00		ldx #$00			ldx 	#0
.018da1					EvaluateNumberX:
.018da1	20 19 8c	jsr $018c19			jsr 	EvaluateExpressionX
.018da4	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.018da6	29 0f		and #$0f			and 	#15
.018da8	c9 02		cmp #$02			cmp 	#2
.018daa	b0 f0		bcs $018d9c			bcs 	EvaluateType
.018dac	60		rts				rts
.018dad					EvaluateInteger:
.018dad	a2 00		ldx #$00			ldx 	#0
.018daf					EvaluateIntegerX:
.018daf	20 a1 8d	jsr $018da1			jsr 	EvaluateNumberX
.018db2	20 94 9d	jsr $019d94			jsr 	FPUToInteger
.018db5	60		rts				rts
.018db6					EvaluateString:
.018db6	a2 00		ldx #$00			ldx 	#0
.018db8					EvaluateStringX:
.018db8	20 19 8c	jsr $018c19			jsr 	EvaluateExpressionX
.018dbb	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.018dbd	29 0f		and #$0f			and 	#15
.018dbf	c9 02		cmp #$02			cmp 	#2
.018dc1	d0 d9		bne $018d9c			bne 	EvaluateType
.018dc3	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018dc5	85 1e		sta $1e				sta 	zGenPtr
.018dc7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018dc9	85 1f		sta $1f				sta 	zGenPtr+1
.018dcb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018dcc					BinaryOp_And:
.018dcc	20 20 8e	jsr $018e20			jsr 	BinaryMakeBothInteger
.018dcf	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018dd1	35 86		and $86,x			and 	XS2_Mantissa+0,x
.018dd3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018dd5	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018dd7	35 87		and $87,x			and 	XS2_Mantissa+1,x
.018dd9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018ddb	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018ddd	35 88		and $88,x			and 	XS2_Mantissa+2,x
.018ddf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018de1	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018de3	35 89		and $89,x			and 	XS2_Mantissa+3,x
.018de5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018de7	60		rts				rts
.018de8					BinaryOp_Or:
.018de8	20 20 8e	jsr $018e20			jsr 	BinaryMakeBothInteger
.018deb	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018ded	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.018def	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018df1	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018df3	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.018df5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018df7	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018df9	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.018dfb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018dfd	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018dff	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.018e01	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018e03	60		rts				rts
.018e04					BinaryOp_Eor:
.018e04					BinaryOp_Xor:
.018e04	20 20 8e	jsr $018e20			jsr 	BinaryMakeBothInteger
.018e07	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018e09	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.018e0b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018e0d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018e0f	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.018e11	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018e13	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018e15	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.018e17	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018e19	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018e1b	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.018e1d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018e1f	60		rts				rts
.018e20					BinaryMakeBothInteger:
.018e20	da		phx				phx 								; save X
.018e21	e8		inx				inx
.018e22	e8		inx				inx
.018e23	e8		inx				inx
.018e24	e8		inx				inx
.018e25	e8		inx				inx
.018e26	e8		inx				inx
.018e27	20 2b 8e	jsr $018e2b			jsr 	BinaryMakeInteger 			; convert to integer.
.018e2a	fa		plx				plx 								; restore X and fall through.
.018e2b					BinaryMakeInteger:
.018e2b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018e2d	29 0f		and #$0f			and 	#15 						; check type zero
.018e2f	f0 04		beq $018e35			beq 	_BMIConvert 				; if float convert to integer.
.018e31	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018e32	90 04		bcc $018e38			bcc 	_BMIError
.018e34	60		rts				rts
.018e35					_BMIConvert:
.018e35	4c 94 9d	jmp $019d94			jmp 	FPUToInteger 				; convert to integer
.018e38					_BMIError:
.018e38	4c ab 84	jmp $0184ab			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018e3b					Binary_Equal:
.018e3b	20 82 8e	jsr $018e82			jsr 	CompareValues
.018e3e	09 00		ora #$00			ora 	#0
.018e40	f0 04		beq $018e46			beq 	CCTrue
.018e42	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018e44	80 02		bra $018e48			bra 	CCWrite
.018e46	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018e48	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018e4a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018e4c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018e4e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018e50	a9 01		lda #$01			lda 	#1
.018e52	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.018e54	60		rts				rts
.018e55					Binary_NotEqual:
.018e55	20 82 8e	jsr $018e82			jsr 	CompareValues
.018e58	09 00		ora #$00			ora 	#0
.018e5a	f0 e6		beq $018e42			beq 	CCFalse
.018e5c	80 e8		bra $018e46			bra 	CCTrue
.018e5e					Binary_Less:
.018e5e	20 82 8e	jsr $018e82			jsr 	CompareValues
.018e61	09 00		ora #$00			ora 	#0
.018e63	30 e1		bmi $018e46			bmi 	CCTrue
.018e65	80 db		bra $018e42			bra 	CCFalse
.018e67					Binary_LessEqual:
.018e67	20 82 8e	jsr $018e82			jsr 	CompareValues
.018e6a	c9 01		cmp #$01			cmp 	#1
.018e6c	d0 d8		bne $018e46			bne 	CCTrue
.018e6e	80 d2		bra $018e42			bra 	CCFalse
.018e70					Binary_GreaterEqual:
.018e70	20 82 8e	jsr $018e82			jsr 	CompareValues
.018e73	09 00		ora #$00			ora 	#0
.018e75	10 cf		bpl $018e46			bpl 	CCTrue
.018e77	80 c9		bra $018e42			bra 	CCFalse
.018e79					Binary_Greater:
.018e79	20 82 8e	jsr $018e82			jsr 	CompareValues
.018e7c	c9 01		cmp #$01			cmp 	#1
.018e7e	f0 c6		beq $018e46			beq 	CCTrue
.018e80	80 c0		bra $018e42			bra 	CCFalse
.018e82					CompareValues:
.018e82	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.018e84	35 8b		and $8b,x			and 	XS2_Type,x
.018e86	c9 02		cmp #$02			cmp 	#2
.018e88	f0 11		beq $018e9b			beq 	_CVString
.018e8a	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018e8c	35 8b		and $8b,x			and 	XS2_Type,x
.018e8e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018e8f	90 03		bcc $018e94			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018e91	4c dd 8e	jmp $018edd			jmp 	CompareInteger32 							; so execute code at \1
.018e94					_BCFloat:
.018e94	20 81 8f	jsr $018f81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018e97	4c ca 9c	jmp $019cca			jmp 	FPCompare 							; and execute code at \2
.018e9a	60		rts				rts
.018e9b					_CVString:
.018e9b	da		phx				phx 								; save XY
.018e9c	5a		phy				phy
.018e9d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018e9f	85 1a		sta $1a				sta		zLTemp1+0
.018ea1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018ea3	85 1b		sta $1b				sta 	zLTemp1+1
.018ea5	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018ea7	85 1c		sta $1c				sta 	zLTemp1+2
.018ea9	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018eab	85 1d		sta $1d				sta 	zLTemp1+3
.018ead	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018eaf	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018eb1	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018eb3	90 02		bcc $018eb7			bcc 	_CVCommon
.018eb5	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018eb7					_CVCommon:
.018eb7	aa		tax				tax 								; put shorter string length in zero.
.018eb8	f0 0c		beq $018ec6			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018eba					_CVCompare:
.018eba	c8		iny				iny 								; next character
.018ebb	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018ebd	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018ebf	90 13		bcc $018ed4			bcc 	_CVReturnLess 				; <
.018ec1	d0 15		bne $018ed8			bne 	_CVReturnGreater 			; >
.018ec3	ca		dex				dex 								; until common length matched.
.018ec4	d0 f4		bne $018eba			bne 	_CVCompare
.018ec6					_CVMatch:
.018ec6	a0 00		ldy #$00			ldy 	#0
.018ec8	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018eca	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018ecc	90 06		bcc $018ed4			bcc 	_CVReturnLess 				; <
.018ece	d0 08		bne $018ed8			bne 	_CVReturnGreater 			; >
.018ed0	a9 00		lda #$00			lda 	#0
.018ed2	80 06		bra $018eda			bra 	_CVExit 					; same common, same length, same string
.018ed4					_CVReturnLess:
.018ed4	a9 ff		lda #$ff			lda 	#$FF
.018ed6	80 02		bra $018eda			bra 	_CVExit
.018ed8					_CVReturnGreater:
.018ed8	a9 01		lda #$01			lda 	#$01
.018eda					_CVExit:
.018eda	7a		ply				ply
.018edb	fa		plx				plx
.018edc	60		rts				rts
.018edd					CompareInteger32:
.018edd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018edf	49 80		eor #$80			eor 	#$80
.018ee1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018ee3	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.018ee5	49 80		eor #$80			eor 	#$80
.018ee7	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.018ee9	20 67 8f	jsr $018f67			jsr 	SubInteger32 				; subtraction
.018eec	90 0d		bcc $018efb			bcc 	_CI32Less 					; cc return -1
.018eee	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.018ef0	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018ef2	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018ef4	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018ef6	f0 02		beq $018efa			beq 	_CI32Exit
.018ef8	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018efa					_CI32Exit:
.018efa	60		rts				rts
.018efb					_CI32Less:
.018efb	a9 ff		lda #$ff			lda 	#$FF
.018efd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018efe					BinaryOp_Add:
.018efe	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.018f00	35 8b		and $8b,x			and 	XS2_Type,x
.018f02	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018f04	d0 11		bne $018f17			bne 	_BOAString
.018f06	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018f08	35 8b		and $8b,x			and 	XS2_Type,x
.018f0a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018f0b	90 03		bcc $018f10			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018f0d	4c 4d 8f	jmp $018f4d			jmp 	AddInteger32 							; so execute code at \1
.018f10					_BCFloat:
.018f10	20 81 8f	jsr $018f81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018f13	4c a5 9a	jmp $019aa5			jmp 	FPAdd 							; and execute code at \2
.018f16	60		rts				rts
.018f17					_BOAString:
.018f17	4c 9b 8f	jmp $018f9b			jmp 	ConcatenateString 			; concatenate two strings.
.018f1a					BinaryOp_Subtract:
.018f1a	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018f1c	35 8b		and $8b,x			and 	XS2_Type,x
.018f1e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018f1f	90 03		bcc $018f24			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018f21	4c 67 8f	jmp $018f67			jmp 	SubInteger32 							; so execute code at \1
.018f24					_BCFloat:
.018f24	20 81 8f	jsr $018f81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018f27	4c 9d 9a	jmp $019a9d			jmp 	FPSubtract 							; and execute code at \2
.018f2a	60		rts				rts
.018f2b					BinaryOp_Multiply:
.018f2b	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018f2d	35 8b		and $8b,x			and 	XS2_Type,x
.018f2f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018f30	90 03		bcc $018f35			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018f32	4c 76 98	jmp $019876			jmp 	MulInteger32 							; so execute code at \1
.018f35					_BCFloat:
.018f35	20 81 8f	jsr $018f81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018f38	4c cc 9b	jmp $019bcc			jmp 	FPMultiply 							; and execute code at \2
.018f3b	60		rts				rts
.018f3c					BinaryOp_Divide:
.018f3c	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018f3e	35 8b		and $8b,x			and 	XS2_Type,x
.018f40	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018f41	90 03		bcc $018f46			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018f43	4c b4 98	jmp $0198b4			jmp 	DivInteger32 							; so execute code at \1
.018f46					_BCFloat:
.018f46	20 81 8f	jsr $018f81			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018f49	4c 59 9b	jmp $019b59			jmp 	FPDivide 							; and execute code at \2
.018f4c	60		rts				rts
.018f4d					AddInteger32:
.018f4d	18		clc				clc
.018f4e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018f50	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.018f52	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018f54	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018f56	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.018f58	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f5a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018f5c	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.018f5e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018f60	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018f62	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.018f64	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018f66	60		rts				rts
.018f67					SubInteger32:
.018f67	38		sec				sec
.018f68	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018f6a	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.018f6c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018f6e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018f70	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.018f72	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f74	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018f76	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.018f78	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018f7a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018f7c	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.018f7e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018f80	60		rts				rts
.018f81					BinaryMakeBothFloat:
.018f81	da		phx				phx 								; save X
.018f82	e8		inx				inx
.018f83	e8		inx				inx
.018f84	e8		inx				inx
.018f85	e8		inx				inx
.018f86	e8		inx				inx
.018f87	e8		inx				inx
.018f88	20 8c 8f	jsr $018f8c			jsr 	BinaryMakeFloat 			; convert to float.
.018f8b	fa		plx				plx 								; restore X and fall through.
.018f8c					BinaryMakeFloat:
.018f8c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018f8e	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018f8f	b0 04		bcs $018f95			bcs 	_BMFConvert
.018f91	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018f92	b0 04		bcs $018f98			bcs 	_BMFError
.018f94	60		rts				rts
.018f95					_BMFConvert:
.018f95	4c 48 9d	jmp $019d48			jmp 	FPUToFloat 					; convert to float
.018f98					_BMFError:
.018f98	4c ab 84	jmp $0184ab			jmp 	TypeError
.018f9b					ConcatenateString:
.018f9b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018f9d	85 1a		sta $1a				sta		zLTemp1+0
.018f9f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018fa1	85 1b		sta $1b				sta 	zLTemp1+1
.018fa3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.018fa5	85 1c		sta $1c				sta 	zLTemp1+2
.018fa7	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018fa9	85 1d		sta $1d				sta 	zLTemp1+3
.018fab	5a		phy				phy
.018fac	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018fae	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018fb0	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018fb2	7a		ply				ply
.018fb3	b0 33		bcs $018fe8			bcs 	_CSError					; check in range.
.018fb5	c9 fe		cmp #$fe			cmp 	#maxString+1
.018fb7	b0 2f		bcs $018fe8			bcs 	_CSError
.018fb9	20 15 94	jsr $019415			jsr 	AllocateTempString 			; store the result
.018fbc	20 d3 8f	jsr $018fd3			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018fbf	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018fc1	85 1a		sta $1a				sta 	zLTemp1
.018fc3	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.018fc5	85 1b		sta $1b				sta 	zLTemp1+1
.018fc7	20 d3 8f	jsr $018fd3			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018fca	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018fcc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018fce	a5 21		lda $21				lda 	zTempStr+1
.018fd0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018fd2	60		rts				rts
.018fd3					_CSCopyString:
.018fd3	da		phx				phx
.018fd4	5a		phy				phy
.018fd5	a0 00		ldy #$00			ldy 	#0 							; get length
.018fd7	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018fd9	f0 0a		beq $018fe5			beq 	_CSCSExit 					; if zero, exit
.018fdb	aa		tax				tax 								; put in X
.018fdc					_CSCSLoop:
.018fdc	c8		iny				iny 								; get next char
.018fdd	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018fdf	20 40 94	jsr $019440			jsr		WriteTempString 			; copy out
.018fe2	ca		dex				dex 								; do whole string
.018fe3	d0 f7		bne $018fdc			bne 	_CSCSLoop
.018fe5					_CSCSExit:
.018fe5	7a		ply				ply
.018fe6	fa		plx				plx
.018fe7	60		rts				rts
.018fe8					_CSError:
.018fe8	20 ca 84	jsr $0184ca			jsr ERR_Handler
>018feb	53 74 72 69 6e 67 20 74			.text "String too long",0
>018ff3	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018ffb					Unary_Sgn:
.018ffb	20 a1 8d	jsr $018da1			jsr 	EvaluateNumberX 			; get value
.018ffe	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; check right bracket.
.019001	20 1f 90	jsr $01901f			jsr 	GetSignCurrent 				; get sign.
.019004	09 00		ora #$00			ora 	#0
.019006	10 08		bpl $019010			bpl		UnarySetAInteger			; if 0,1 return that.
.019008	80 00		bra $01900a			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.01900a					UnarySetAMinus1:
.01900a	a9 ff		lda #$ff			lda 	#$FF
.01900c	95 80		sta $80,x			sta 	XS_Mantissa,x
.01900e	80 04		bra $019014			bra 	UnarySetAFill
.019010					UnarySetAInteger:
.019010	95 80		sta $80,x			sta 	XS_Mantissa,x
.019012	a9 00		lda #$00			lda 	#0
.019014					UnarySetAFill:
.019014	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019016	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019018	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01901a	a9 01		lda #$01			lda 	#1
.01901c	95 85		sta $85,x			sta 	XS_Type,x
.01901e	60		rts				rts
.01901f					GetSignCurrent:
.01901f	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019021	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.019022	90 15		bcc $019039			bcc 	_GSCFloat
.019024	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019026	30 0e		bmi $019036			bmi 	_GSCMinus1
.019028	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01902a	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01902c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01902e	d0 03		bne $019033			bne 	_GSCPlus1
.019030					_GSCZero:
.019030	a9 00		lda #$00			lda 	#0
.019032	60		rts				rts
.019033					_GSCPlus1:
.019033	a9 01		lda #$01			lda 	#$01
.019035	60		rts				rts
.019036					_GSCMinus1:
.019036	a9 ff		lda #$ff			lda 	#$FF
.019038	60		rts				rts
.019039					_GSCFloat:
.019039	34 85		bit $85,x			bit 	XS_Type,x
.01903b	70 f3		bvs $019030			bvs 	_GSCZero
.01903d	30 f7		bmi $019036			bmi 	_GSCMinus1
.01903f	80 f2		bra $019033			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019041					Unary_Abs:
.019041	20 a1 8d	jsr $018da1			jsr 	EvaluateNumberX 			; get value
.019044	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; check right bracket.
.019047	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019049	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01904b	f0 07		beq $019054			beq 	_UAMinusFloat
.01904d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.01904f	10 09		bpl $01905a			bpl 	_UAExit
.019051	4c 3b 99	jmp $01993b			jmp 	IntegerNegateAlways 		; negation
.019054					_UAMinusFloat:
.019054	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.019056	29 7f		and #$7f			and		#$7F
.019058	95 85		sta $85,x			sta 	XS_Type,x
.01905a					_UAExit:
.01905a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.01905b					Unary_Peek:
.01905b	a9 01		lda #$01			lda 	#1
.01905d	80 06		bra $019065			bra 	UPMain
.01905f					Unary_Deek:
.01905f	a9 02		lda #$02			lda 	#2
.019061	80 02		bra $019065			bra 	UPMain
.019063					Unary_Leek:
.019063	a9 04		lda #$04			lda 	#4
.019065					UPMain:
.019065	48		pha				pha 								; set bytes to copy.
.019066	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX 			; numeric parameter
.019069	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.01906c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.01906e	85 1a		sta $1a				sta 	zLTemp1
.019070	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019072	85 1b		sta $1b				sta 	zLTemp1+1
.019074	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019076	85 1c		sta $1c				sta 	zLTemp1+2
.019078	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01907a	85 1d		sta $1d				sta 	zLTemp1+3
.01907c	a9 00		lda #$00			lda 	#0 							; clear target area
.01907e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019080	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019082	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019084	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019086	68		pla				pla 								; restore bytes to copy
.019087	da		phx				phx 								; save XY
.019088	5a		phy				phy
.019089	20 57 93	jsr $019357			jsr 	MemRead 					; read the bytes in
.01908c	7a		ply				ply 								; restore and exit
.01908d	fa		plx				plx
.01908e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.01908f					Unary_Mod:
.01908f	20 b7 90	jsr $0190b7			jsr 	_UMParameter 				; first parameter
.019092	20 dd 93	jsr $0193dd			jsr 	CheckNextComma
.019095	da		phx				phx 								; second parameter
.019096	e8		inx				inx
.019097	e8		inx				inx
.019098	e8		inx				inx
.019099	e8		inx				inx
.01909a	e8		inx				inx
.01909b	e8		inx				inx
.01909c	20 b7 90	jsr $0190b7			jsr 	_UMParameter
.01909f	fa		plx				plx
.0190a0	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen
.0190a3	20 b4 98	jsr $0198b4			jsr 	DivInteger32 				; divide
.0190a6	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0190a8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190aa	a5 1b		lda $1b				lda 	zLTemp1+1
.0190ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190ae	a5 1c		lda $1c				lda 	zLTemp1+2
.0190b0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190b2	a5 1d		lda $1d				lda 	zLTemp1+3
.0190b4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190b6	60		rts				rts
.0190b7					_UMParameter:
.0190b7	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX 			; get value
.0190ba	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.0190bc	10 03		bpl $0190c1			bpl 	_UMNotSigned
.0190be	20 3b 99	jsr $01993b			jsr 	IntegerNegateAlways
.0190c1					_UMNotSigned:
.0190c1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.0190c2					Unary_Usr:
.0190c2	20 a1 8d	jsr $018da1			jsr 	EvaluateNumberX 			; numeric parameter
.0190c5	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.0190c8	da		phx				phx 								; save XY
.0190c9	5a		phy				phy
.0190ca	ea		nop				nop
.0190cb	22 0c 03 00	jsl $00030c			jsl 	UserVector
.0190cf	7a		ply				ply 								; and exit
.0190d0	fa		plx				plx
.0190d1	60		rts				rts
.0190d2					USRDefault:
.0190d2	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0190d5	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0190dd	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0190e4					Unary_Val:
.0190e4	20 b8 8d	jsr $018db8			jsr 	EvaluateStringX 			; get string
.0190e7	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; check right bracket.
.0190ea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0190ec	85 1e		sta $1e				sta 	zGenPtr
.0190ee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190f0	85 1f		sta $1f				sta 	zGenPtr+1
.0190f2	5a		phy				phy
.0190f3	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0190f5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0190f7	f0 54		beq $01914d			beq 	_UVBadNumber
.0190f9	48		pha				pha 								; save length.
.0190fa	1a		inc a				inc 	a 							; one for the length, one for the terminator
.0190fb	1a		inc a				inc 	a
.0190fc	20 15 94	jsr $019415			jsr 	AllocateTempString
.0190ff	c8		iny				iny 								; move to the next.
.019100	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.019102	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.019104	8d a0 03	sta $03a0			sta 	ValSign
.019107	d0 04		bne $01910d			bne 	_UVNotMinus
.019109	c8		iny				iny 								; skip over it.
.01910a	68		pla				pla 								; decrement character count.
.01910b	3a		dec a				dec 	a
.01910c	48		pha				pha
.01910d					_UVNotMinus:
.01910d	68		pla				pla 								; this is the count.
.01910e	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.01910f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019111	c8		iny				iny
.019112	20 40 94	jsr $019440			jsr 	WriteTempString
.019115	68		pla				pla
.019116	3a		dec a				dec 	a
.019117	d0 f5		bne $01910e			bne 	_UVCopy
.019119	20 40 94	jsr $019440			jsr 	WriteTempString 			; make it ASCIIZ
.01911c	18		clc				clc
.01911d	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.01911f	69 01		adc #$01			adc 	#1
.019121	85 1e		sta $1e				sta 	zGenPtr
.019123	a5 21		lda $21				lda 	zTempStr+1
.019125	69 00		adc #$00			adc 	#0
.019127	85 1f		sta $1f				sta 	zGenPtr+1
.019129	18		clc				clc
.01912a	20 0d 9a	jsr $019a0d			jsr 	IntFromString 				; first bit.
.01912d	b0 1e		bcs $01914d			bcs 	_UVBadNumber
.01912f	20 4e 9f	jsr $019f4e			jsr 	FPFromString				; try for a float part.
.019132	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.019135	d0 10		bne $019147			bne 	_UVNotNegative
.019137	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.019139	4a		lsr a				lsr 	a
.01913a	b0 08		bcs $019144			bcs 	_UVInteger
.01913c	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.01913e	09 80		ora #$80			ora 	#$80
.019140	95 85		sta $85,x			sta 	XS_Type,x
.019142	80 03		bra $019147			bra 	_UVNotNegative
.019144					_UVInteger:
.019144	20 3b 99	jsr $01993b			jsr 	IntegerNegateAlways 		; sign it.
.019147					_UVNotNegative:
.019147	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.019149	d0 02		bne $01914d			bne 	_UVBadNumber
.01914b	7a		ply				ply
.01914c	60		rts				rts
.01914d					_UVBadNumber:
.01914d	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019150					Unary_Str:
.019150	20 a1 8d	jsr $018da1			jsr 	EvaluateNumberX 			; numeric parameter
.019153	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.019156	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019158	8d 14 03	sta $0314			sta 	NumBufX
.01915b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01915d	4a		lsr a				lsr 	a
.01915e	b0 05		bcs $019165			bcs 	_USInt 						; if msb set do as integer
.019160	20 93 9e	jsr $019e93			jsr 	FPToString 					; call fp to str otherwise
.019163	80 03		bra $019168			bra 	_USDuplicate
.019165	20 58 99	jsr $019958	_USInt:	jsr 	IntToString
.019168					_USDuplicate:
.019168	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01916b	1a		inc a				inc 	a 							; one more for length
.01916c	20 15 94	jsr $019415			jsr 	AllocateTempString 			; allocate space for it.
.01916f	5a		phy				phy 								; save Y
.019170	a0 00		ldy #$00			ldy 	#0 							; start copying
.019172	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019175	20 40 94	jsr $019440			jsr 	WriteTempString
.019178	c8		iny				iny
.019179	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01917c	d0 f4		bne $019172			bne 	_USCopy
.01917e	7a		ply				ply 								; restore Y
.01917f	4c 4a 93	jmp $01934a			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019182					Unary_Asc:
.019182	20 b8 8d	jsr $018db8			jsr 	EvaluateStringX 			; string parameter
.019185	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.019188	5a		phy				phy 								; get the string length
.019189	a0 00		ldy #$00			ldy 	#0
.01918b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01918d	f0 07		beq $019196			beq 	_UAIllegal 					; must be at least one character
.01918f	c8		iny				iny
.019190	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.019192	7a		ply				ply
.019193	4c 10 90	jmp $019010			jmp 	UnarySetAInteger
.019196					_UAIllegal:
.019196	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.019199					Unary_Len:
.019199	20 b8 8d	jsr $018db8			jsr 	EvaluateStringX 			; string parameter
.01919c	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.01919f	5a		phy				phy 								; get the string length
.0191a0	a0 00		ldy #$00			ldy 	#0
.0191a2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0191a4	7a		ply				ply
.0191a5	4c 10 90	jmp $019010			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0191a8					Unary_Mid:
.0191a8	20 b8 8d	jsr $018db8			jsr 	EvaluateStringX 				; get string.
.0191ab	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0191ad	48		pha				pha
.0191ae	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191b0	48		pha				pha
.0191b1	20 dd 93	jsr $0193dd			jsr 	CheckNextComma 					; skip comma
.0191b4	20 3d 92	jsr $01923d			jsr 	SLIByteParameter 				; get a byte parameter (start)
.0191b7	48		pha				pha 									; and push it.
.0191b8	20 dd 93	jsr $0193dd			jsr 	CheckNextComma 					; skip comma
.0191bb	20 3d 92	jsr $01923d			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.0191be	48		pha				pha 									; and push it.
.0191bf	80 41		bra $019202			bra 	SLIProcess
.0191c1					Unary_Left:
.0191c1	20 b8 8d	jsr $018db8			jsr 	EvaluateStringX 				; get string.
.0191c4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0191c6	48		pha				pha
.0191c7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191c9	48		pha				pha
.0191ca	a9 01		lda #$01			lda 	#1 								; push start position (1)
.0191cc	48		pha				pha
.0191cd	20 dd 93	jsr $0193dd			jsr 	CheckNextComma 					; skip comma
.0191d0	20 3d 92	jsr $01923d			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.0191d3	48		pha				pha 									; and push it.
.0191d4	80 2c		bra $019202			bra 	SLIProcess
.0191d6					Unary_Right:
.0191d6	20 b8 8d	jsr $018db8			jsr 	EvaluateStringX 				; get string.
.0191d9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0191db	48		pha				pha
.0191dc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191de	48		pha				pha
.0191df	da		phx				phx 									; get the string length and push on stack.
.0191e0	a2 00		ldx #$00			ldx 	#0
.0191e2	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.0191e4	fa		plx				plx
.0191e5	48		pha				pha
.0191e6	20 dd 93	jsr $0193dd			jsr 	CheckNextComma 					; skip comma
.0191e9	20 3d 92	jsr $01923d			jsr 	SLIByteParameter 				; get a byte parameter.
.0191ec	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0191ef	68		pla				pla 									; restore string length.
.0191f0	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0191f1	38		sec				sec
.0191f2	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0191f5	f0 02		beq $0191f9			beq 	_URStart 						; if <= 0 start from 1.
.0191f7	10 02		bpl $0191fb			bpl 	_UROkay
.0191f9					_URStart:
.0191f9	a9 01		lda #$01			lda 	#1
.0191fb					_UROkay:
.0191fb	48		pha				pha 									; push start
.0191fc	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0191ff	48		pha				pha
.019200	80 00		bra $019202			bra 	SLIProcess
.019202					SLIProcess:
.019202	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 				; closing right bracket.
.019205	68		pla				pla
.019206	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.019209	1a		inc a				inc 	a 								; allocate +1 for it.
.01920a	20 15 94	jsr $019415			jsr 	AllocateTempString
.01920d	68		pla				pla 									; pop start number off stack.
.01920e	f0 3b		beq $01924b			beq 	SLIError 						; exit if start = 0
.019210	8d a1 03	sta $03a1			sta 	SliceStart
.019213	68		pla				pla  									; pop string address.
.019214	85 1f		sta $1f				sta 	zGenPtr+1
.019216	68		pla				pla
.019217	85 1e		sta $1e				sta 	zGenPtr
.019219	da		phx				phx
.01921a	5a		phy				phy
.01921b	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01921d	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019220					_SLICopy:
.019220	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019223	f0 12		beq $019237			beq 	_SLIExit
.019225	ce a2 03	dec $03a2			dec 	SliceCount
.019228	98		tya				tya 									; index of character
.019229	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.01922b	f0 02		beq $01922f			beq 	_SLIOk 							; if equal, okay.
.01922d	b0 08		bcs $019237			bcs 	_SLIExit 						; if past end, then exit.
.01922f	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019231	c8		iny				iny
.019232	20 40 94	jsr $019440			jsr 	WriteTempString
.019235	80 e9		bra $019220			bra 	_SLICopy 						; go round till copied characters
.019237					_SLIExit:
.019237	7a		ply				ply 									; restore YX
.019238	fa		plx				plx
.019239	4c 4a 93	jmp $01934a			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01923c	ea		nop				nop
.01923d					SLIByteParameter:
.01923d	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX 				; get integer
.019240	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019242	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019244	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019246	d0 03		bne $01924b			bne 	SLIError
.019248	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01924a	60		rts				rts
.01924b					SLIError:
.01924b	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.01924e					Unary_Hex:
.01924e	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX 			; numeric parameter
.019251	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.019254	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019256	20 15 94	jsr $019415			jsr 	AllocateTempString			; allocate string space
.019259	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01925b	20 7f 92	jsr $01927f			jsr 	_UHConvert
.01925e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019260	20 7f 92	jsr $01927f			jsr 	_UHConvert
.019263	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019265	20 7f 92	jsr $01927f			jsr 	_UHConvert
.019268	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01926a	20 7f 92	jsr $01927f			jsr 	_UHConvert
.01926d	5a		phy				phy 								; get length of new string
.01926e	a0 00		ldy #$00			ldy 	#0
.019270	b1 20		lda ($20),y			lda 	(zTempStr),y
.019272	7a		ply				ply
.019273	c9 00		cmp #$00			cmp 	#0
.019275	d0 05		bne $01927c			bne 	_UHExit 					; if it was non zero okay
.019277	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019279	20 40 94	jsr $019440			jsr 	WriteTempString
.01927c					_UHExit:
.01927c	4c 4a 93	jmp $01934a			jmp 	UnaryReturnTempStr 			; return new temporary string.
.01927f					_UHConvert:
.01927f	48		pha				pha
.019280	4a		lsr a				lsr 	a 							; do MSB
.019281	4a		lsr a				lsr 	a
.019282	4a		lsr a				lsr 	a
.019283	4a		lsr a				lsr 	a
.019284	20 88 92	jsr $019288			jsr 	_UHNibble
.019287	68		pla				pla 								; do LSB
.019288					_UHNibble:
.019288	29 0f		and #$0f			and 	#15 						; get nibble
.01928a	d0 0c		bne $019298			bne 	_UHNonZero
.01928c	5a		phy				phy									; get the length
.01928d	a0 00		ldy #$00			ldy 	#0
.01928f	b1 20		lda ($20),y			lda 	(zTempStr),y
.019291	7a		ply				ply
.019292	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019294	f0 0d		beq $0192a3			beq 	_UHExit2
.019296	a9 00		lda #$00			lda 	#0
.019298					_UHNonZero:
.019298	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01929a	90 02		bcc $01929e			bcc 	_UHDigit
.01929c	69 06		adc #$06			adc 	#7-1
.01929e					_UHDigit:
.01929e	69 30		adc #$30			adc 	#48
.0192a0	20 40 94	jsr $019440			jsr 	WriteTempString				; output.
.0192a3					_UHExit2:
.0192a3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0192a4					Unary_Dec:
.0192a4	20 b8 8d	jsr $018db8			jsr 	EvaluateStringX 			; string parameter
.0192a7	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.0192aa	5a		phy				phy
.0192ab	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0192ad	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0192af	f0 41		beq $0192f2			beq 	_UDFail 					; must fail if zero.
.0192b1	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.0192b4	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.0192b6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192b8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ba	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192bc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192be	a9 01		lda #$01			lda 	#1
.0192c0	95 85		sta $85,x			sta 	XS_Type,x
.0192c2					_UDConvertLoop:
.0192c2	5a		phy				phy 								; shift mantissa left 4
.0192c3	a0 04		ldy #$04			ldy 	#4
.0192c5					_UDShift:
.0192c5	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.0192c7	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0192c9	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0192cb	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0192cd	88		dey				dey
.0192ce	d0 f5		bne $0192c5			bne 	_UDShift
.0192d0	7a		ply				ply
.0192d1	c8		iny				iny 								; next character
.0192d2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.0192d4	20 f5 92	jsr $0192f5			jsr 	ConvertUpper 				; convert to U/C
.0192d7	c9 30		cmp #$30			cmp 	#"0"
.0192d9	90 17		bcc $0192f2			bcc 	_UDFail
.0192db	c9 3a		cmp #$3a			cmp 	#"9"+1
.0192dd	90 06		bcc $0192e5			bcc 	_UDOkay
.0192df	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.0192e1	c9 10		cmp #$10			cmp 	#16
.0192e3	b0 0d		bcs $0192f2			bcs 	_UDFail
.0192e5					_UDOkay:
.0192e5	29 0f		and #$0f			and 	#15 						; nibble only
.0192e7	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0192e9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192eb	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.0192ee	d0 d2		bne $0192c2			bne 	_UDConvertLoop
.0192f0	7a		ply				ply
.0192f1	60		rts				rts
.0192f2					_UDFail:
.0192f2	4c b9 84	jmp $0184b9			jmp 	BadParamError
.0192f5					ConvertUpper:
.0192f5	c9 61		cmp #$61			cmp 	#"a"
.0192f7	90 07		bcc $019300			bcc 	_CUExit
.0192f9	c9 7b		cmp #$7b			cmp 	#"z"+1
.0192fb	b0 03		bcs $019300			bcs 	_CUExit
.0192fd	38		sec				sec
.0192fe	e9 20		sbc #$20			sbc 	#32
.019300	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019301					Unary_Chr:
.019301	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX			; numeric parameter
.019304	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.019307	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019309	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01930b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01930d	d0 0d		bne $01931c			bne 	_UCChar
.01930f	a9 01		lda #$01			lda 	#1 							; one character string
.019311	20 15 94	jsr $019415			jsr 	AllocateTempString
.019314	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019316	20 40 94	jsr $019440			jsr 	WriteTempString
.019319	4c 4a 93	jmp $01934a			jmp 	UnaryReturnTempStr
.01931c					_UCChar:
.01931c	4c b9 84	jmp $0184b9			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.01931f					Unary_Spc:
.01931f	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX 			; numeric parameter
.019322	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; right bracket.
.019325	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019327	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019329	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01932b	d0 1a		bne $019347			bne 	_USSize
.01932d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01932f	c9 fe		cmp #$fe			cmp 	#maxString+1
.019331	b0 14		bcs $019347			bcs 	_USSize
.019333	48		pha				pha 								; save length
.019334	1a		inc a				inc 	a 							; allocate one more.
.019335	20 15 94	jsr $019415			jsr 	AllocateTempString
.019338	68		pla				pla 								; get length
.019339	f0 0f		beq $01934a			beq 	UnaryReturnTempStr 			; return the current temp string
.01933b					_USLoop:
.01933b	48		pha				pha
.01933c	a9 20		lda #$20			lda 	#" "
.01933e	20 40 94	jsr $019440			jsr 	WriteTempString
.019341	68		pla				pla
.019342	3a		dec a				dec 	a
.019343	d0 f6		bne $01933b			bne 	_USLoop
.019345	80 03		bra $01934a			bra 	UnaryReturnTempStr
.019347					_USSize:
.019347	4c b9 84	jmp $0184b9			jmp 	BadParamError
.01934a					UnaryReturnTempStr:
.01934a	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.01934c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01934e	a5 21		lda $21				lda 	zTempStr+1
.019350	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019352	a9 02		lda #$02			lda 	#2 							; set type to string
.019354	95 85		sta $85,x			sta 	XS_Type,x
.019356	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019357					MemRead:
.019357	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01935a	a0 00		ldy #$00			ldy 	#0 							; start from here
.01935c	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01935e	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019360	c8		iny				iny 								; next to copy
.019361	e8		inx				inx
.019362	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019365	d0 f5		bne $01935c			bne 	_MLoop1
.019367	60		rts				rts
.019368					MemWrite:
.019368	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01936b	a0 00		ldy #$00			ldy 	#0 							; start from here
.01936d	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.01936f	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019371	c8		iny				iny 								; next to copy
.019372	e8		inx				inx
.019373	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019376	d0 f5		bne $01936d			bne 	_MLoop1
.019378	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019379					UpdateProgramEnd:
.019379	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01937b	85 16		sta $16				sta 	zCodePtr+0
.01937d	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01937f	85 17		sta $17				sta 	zCodePtr+1
.019381	a9 00		lda #$00			lda 	#0
.019383	85 18		sta $18				sta 	zCodePtr+2
.019385	85 19		sta $19				sta 	zCodePtr+3
.019387	a0 03		ldy #$03			ldy 	#3
.019389					_UPDLoop:
.019389	a0 00		ldy #$00			ldy 	#0
.01938b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01938d	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.01938f	f0 0f		beq $0193a0			beq 	_UPDFoundEnd
.019391	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019393	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019395	18		clc				clc
.019396	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019398	85 16		sta $16				sta 	zCodePtr
.01939a	90 02		bcc $01939e			bcc 	_SNLNoCarry
.01939c	e6 17		inc $17				inc 	zCodePtr+1
.01939e					_SNLNoCarry:
.01939e	80 e9		bra $019389			bra 	_UPDLoop
.0193a0					_UPDFoundEnd:
.0193a0	18		clc				clc 								; end of program 2 on.
.0193a1	a5 16		lda $16				lda 	zCodePtr
.0193a3	69 02		adc #$02			adc 	#2
.0193a5	8d 04 03	sta $0304			sta 	endOfProgram
.0193a8	a5 17		lda $17				lda 	zCodePtr+1
.0193aa	69 00		adc #$00			adc 	#0
.0193ac	8d 05 03	sta $0305			sta 	endOfProgram+1
.0193af	a5 18		lda $18				lda 	zCodePtr+2
.0193b1	69 00		adc #$00			adc		#0
.0193b3	8d 06 03	sta $0306			sta 	endOfProgram+2
.0193b6	a5 19		lda $19				lda 	zCodePtr+3
.0193b8	69 00		adc #$00			adc 	#0
.0193ba	8d 07 03	sta $0307			sta 	endOfProgram+3
.0193bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0193be					CheckNextToken:
.0193be	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.0193c0	d0 02		bne $0193c4			bne 	CTFail 						; no, then fail
.0193c2	c8		iny				iny
.0193c3	60		rts				rts
.0193c4					CTFail:
.0193c4	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0193c7	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0193cf	74 6f 6b 65 6e 00
.0193d5					CheckNextRParen:
.0193d5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0193d7	c9 be		cmp #$be			cmp 	#token_rparen
.0193d9	d0 e9		bne $0193c4			bne 	CTFail
.0193db	c8		iny				iny
.0193dc	60		rts				rts
.0193dd					CheckNextComma:
.0193dd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0193df	c9 bf		cmp #$bf			cmp 	#token_comma
.0193e1	d0 e1		bne $0193c4			bne 	CTFail
.0193e3	c8		iny				iny
.0193e4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0193e5					StringConcrete:
.0193e5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0193e7	85 10		sta $10				sta 	zTemp1
.0193e9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193eb	85 11		sta $11				sta 	zTemp1+1
.0193ed	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.0193ef	18		clc				clc 								; from the string pointer
.0193f0	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0193f3	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0193f5	8d 00 03	sta $0300			sta 	StringPtr
.0193f8	85 12		sta $12				sta 	zTemp2
.0193fa	ad 01 03	lda $0301			lda 	StringPtr+1
.0193fd	e9 00		sbc #$00			sbc 	#0
.0193ff	8d 01 03	sta $0301			sta 	StringPtr+1
.019402	85 13		sta $13				sta 	zTemp2+1
.019404	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019406	1a		inc a				inc 	a
.019407	aa		tax				tax
.019408	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.01940a	91 12		sta ($12),y			sta 	(zTemp2),y
.01940c	c8		iny				iny
.01940d	ca		dex				dex
.01940e	d0 f8		bne $019408			bne 	_SCCopy
.019410	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019412	a6 12		ldx $12				ldx 	zTemp2
.019414	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019415					AllocateTempString:
.019415	48		pha				pha 								; save required count.
.019416	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019418	d0 0b		bne $019425			bne 	_ATSInitialised
.01941a	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.01941d	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.01941f	ad 01 03	lda $0301			lda 	StringPtr+1
.019422	3a		dec a				dec 	a
.019423	85 21		sta $21				sta 	zTempStr+1
.019425					_ATSInitialised:
.019425	68		pla				pla 								; get required count back.
.019426	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.019428	1a		inc a				inc 	a
.019429	18		clc				clc
.01942a	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.01942c	85 20		sta $20				sta 	zTempStr
.01942e	a9 ff		lda #$ff			lda 	#$FF
.019430	65 21		adc $21				adc 	zTempStr+1
.019432	85 21		sta $21				sta 	zTempStr+1
.019434	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019436	5a		phy				phy
.019437	a8		tay				tay
.019438	91 20		sta ($20),y			sta 	(zTempStr),y
.01943a	7a		ply				ply
.01943b	1a		inc a				inc 	a 							; reset the write index.
.01943c	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.01943f	60		rts				rts
.019440					WriteTempString:
.019440	5a		phy				phy 								; save Y
.019441	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019444	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019446	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019449	98		tya				tya 								; unchanged Y is now length
.01944a	a0 00		ldy #$00			ldy 	#0
.01944c	91 20		sta ($20),y			sta 	(zTempStr),y
.01944e	7a		ply				ply 								; restore Y and exit
.01944f	60		rts				rts
.019450					CreateTempStringCopy:
.019450	da		phx				phx 								; save X
.019451	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019453	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019454	20 15 94	jsr $019415			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019457	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019459	c8		iny				iny
.01945a	3a		dec a				dec 	a 							; make the actual length in charactes
.01945b	3a		dec a				dec 	a
.01945c	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01945e	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019460	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019462	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019464	f0 0e		beq $019474			beq 	_CTSCExit
.019466					_CTSCLoop:
.019466	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019468	c8		iny				iny
.019469	5a		phy				phy 								; save in Y
.01946a	e8		inx				inx 								; bump index
.01946b	da		phx				phx 								; index into Y
.01946c	7a		ply				ply
.01946d	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.01946f	7a		ply				ply 								; restore Y
.019470	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019472	d0 f2		bne $019466			bne 	_CTSCLoop
.019474					_CTSCExit:
.019474	fa		plx				plx 								; restore X
.019475	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019476					VariableFind:
.019476	20 e1 94	jsr $0194e1			jsr 	VariableExtract 		; find out all about it ....
.019479	20 7a 97	jsr $01977a			jsr 	VariableLocate 			; does it already exist ?
.01947c	b0 03		bcs $019481			bcs 	_VFExists 				; if so, use that.
.01947e	20 6d 95	jsr $01956d			jsr 	VariableCreate 			; otherwise create it.
.019481					_VFExists:
.019481	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019483	29 01		and #$01			and 	#1
.019485	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019487	d0 28		bne $0194b1			bne 	_VFSingleElement
.019489					_VFNextIndex:
.019489	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01948b	48		pha				pha
.01948c	a5 23		lda $23				lda 	zVarDataPtr+1
.01948e	48		pha				pha
.01948f	a5 24		lda $24				lda 	zVarType
.019491	48		pha				pha
.019492	20 af 8d	jsr $018daf			jsr 	EvaluateIntegerX 		; calculate the index.
.019495	68		pla				pla 							; restore and index.
.019496	85 24		sta $24				sta 	zVarType
.019498	68		pla				pla
.019499	85 23		sta $23				sta 	zVarDataPtr+1
.01949b	68		pla				pla
.01949c	85 22		sta $22				sta 	zVarDataPtr
.01949e	20 f8 95	jsr $0195f8			jsr 	ArrayIndexFollow 		; do the index.
.0194a1	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.0194a3	29 01		and #$01			and 	#1
.0194a5	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0194a7	d0 05		bne $0194ae			bne 	_VFArrayDone 			; if so then exit.
.0194a9	20 dd 93	jsr $0193dd			jsr 	CheckNextComma 			; comma should follow
.0194ac	80 db		bra $019489			bra 	_VFNextIndex
.0194ae					_VFArrayDone:
.0194ae	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 		; check closing right bracket.
.0194b1					_VFSingleElement:
.0194b1	60		rts				rts
.0194b2					VariableClear:
.0194b2	48		pha				pha 							; save registers
.0194b3	da		phx				phx
.0194b4	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.0194b6	8a		txa				txa
.0194b7	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.0194ba	e8		inx				inx
.0194bb	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.0194bd	d0 f8		bne $0194b7			bne 	_VCLoop
.0194bf	a9 00		lda #$00			lda 	#VariableMemory & $FF
.0194c1	8d 02 03	sta $0302			sta 	VarMemPtr
.0194c4	a9 30		lda #$30			lda 	#VariableMemory >> 8
.0194c6	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0194c9	fa		plx				plx 							; restore registers
.0194ca	68		pla				pla
.0194cb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0194cc					VariableNameError:
.0194cc	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0194cf	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0194d7	61 62 6c 65 20 4e 61 6d 65 00
.0194e1					VariableExtract:
.0194e1	da		phx				phx 							; save X.
.0194e2	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0194e4	8d 95 03	sta $0395			sta 	Var_Type
.0194e7	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0194ea	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0194ec	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0194ee	f0 dc		beq $0194cc			beq 	VariableNameError
.0194f0	c9 1b		cmp #$1b			cmp 	#26+1
.0194f2	b0 d8		bcs $0194cc			bcs 	VariableNameError
.0194f4	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0194f6					_VECopyBuffer:
.0194f6	e8		inx				inx
.0194f7	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0194f9	f0 d1		beq $0194cc			beq 	VariableNameError
.0194fb	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.0194fe	18		clc				clc  							; update the hash value for it.
.0194ff	6d 96 03	adc $0396			adc 	Var_Hash
.019502	8d 96 03	sta $0396			sta 	Var_Hash
.019505	c8		iny				iny
.019506	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019508	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.01950a	f0 0e		beq $01951a			beq 	_VECopyEnd
.01950c	30 0c		bmi $01951a			bmi 	_VECopyEnd
.01950e	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019510	90 e4		bcc $0194f6			bcc 	_VECopyBuffer
.019512	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019514	90 04		bcc $01951a			bcc 	_VECopyEnd
.019516	c9 3a		cmp #$3a			cmp 	#"9"+1
.019518	90 dc		bcc $0194f6			bcc 	_VECopyBuffer
.01951a					_VECopyEnd:
.01951a	c8		iny				iny
.01951b	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.01951d	90 04		bcc $019523			bcc 	_VEDefaultRequired
.01951f	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019521	90 0b		bcc $01952e			bcc 	_VEHaveType
.019523					_VEDefaultRequired:
.019523	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019525	f0 04		beq $01952b			beq 	_VESetType 				; default set above.
.019527	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.01952a	88		dey				dey
.01952b					_VESetType:
.01952b	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.01952e					_VEHaveType:
.01952e	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019531	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019534	09 80		ora #$80			ora 	#$80
.019536	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019539	e8		inx				inx 							; offset 3 => length 4.
.01953a	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.01953d	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019540	38		sec				sec
.019541	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019543	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019544	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019545	0a		asl a				asl 	a
.019546	0a		asl a				asl 	a
.019547	8d 98 03	sta $0398			sta 	Var_HashAddress
.01954a	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.01954d	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.01954f	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019550	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019553	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019555	8d 98 03	sta $0398			sta 	Var_HashAddress
.019558	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.01955a	ad 95 03	lda $0395			lda 	Var_Type
.01955d	c9 b9		cmp #$b9			cmp 	#token_Hash
.01955f	f0 07		beq $019568			beq 	_VEHaveSize
.019561	ca		dex				dex
.019562	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019564	f0 02		beq $019568			beq 	_VEHaveSize
.019566	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019568					_VEHaveSize:
.019568	8e 99 03	stx $0399			stx 	Var_DataSize
.01956b	fa		plx				plx
.01956c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.01956d					VariableCreate:
.01956d	da		phx				phx
.01956e	5a		phy				phy
.01956f	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019572	85 10		sta $10				sta 	zTemp1
.019574	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019577	85 11		sta $11				sta 	zTemp1+1
.019579	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.01957c	18		clc				clc
.01957d	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019580	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019582	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019585	8d 02 03	sta $0302			sta 	VarMemPtr
.019588	90 03		bcc $01958d			bcc 	_VCNoCarry
.01958a	ee 03 03	inc $0303			inc 	VarMemPtr+1
.01958d					_VCNoCarry:
.01958d	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019590	85 12		sta $12				sta 	zTemp2
.019592	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019594	85 13		sta $13				sta 	zTemp2+1
.019596	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019598	b1 12		lda ($12),y			lda 	(zTemp2),y
.01959a	91 10		sta ($10),y			sta 	(zTemp1),y
.01959c	c8		iny				iny
.01959d	b1 12		lda ($12),y			lda 	(zTemp2),y
.01959f	91 10		sta ($10),y			sta 	(zTemp1),y
.0195a1	c8		iny				iny
.0195a2	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.0195a5	91 10		sta ($10),y			sta 	(zTemp1),y
.0195a7	c8		iny				iny
.0195a8	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.0195aa					_VCCopyName:
.0195aa	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.0195ad	91 10		sta ($10),y			sta 	(zTemp1),y
.0195af	e8		inx				inx
.0195b0	c8		iny				iny
.0195b1	ec 97 03	cpx $0397			cpx 	Var_Length
.0195b4	d0 f4		bne $0195aa			bne 	_VCCopyName
.0195b6	5a		phy				phy 								; save the data offset.
.0195b7	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.0195ba	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.0195bc					_VCClearData:
.0195bc	91 10		sta ($10),y			sta 	(zTemp1),y
.0195be	c8		iny				iny
.0195bf	ca		dex				dex
.0195c0	d0 fa		bne $0195bc			bne 	_VCClearData
.0195c2	68		pla				pla 								; offset to the data
.0195c3	18		clc				clc
.0195c4	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.0195c6	85 22		sta $22				sta 	zVarDataPtr
.0195c8	a5 11		lda $11				lda 	zTemp1+1
.0195ca	69 00		adc #$00			adc 	#0
.0195cc	85 23		sta $23				sta 	zVarDataPtr+1
.0195ce	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.0195d1	85 24		sta $24				sta 	zVarType
.0195d3	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.0195d5	a0 00		ldy #$00			ldy 	#0
.0195d7	91 12		sta ($12),y			sta 	(zTemp2),y
.0195d9	c8		iny				iny
.0195da	a5 11		lda $11				lda 	zTemp1+1
.0195dc	91 12		sta ($12),y			sta 	(zTemp2),y
.0195de	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.0195e1	29 01		and #$01			and 	#1
.0195e3	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0195e5	d0 0e		bne $0195f5			bne 	_VCNotArray
.0195e7	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.0195e9	20 8f 96	jsr $01968f			jsr 	ArrayCreate
.0195ec	5a		phy				phy 								; save YA at zVarDataPtr
.0195ed	a0 00		ldy #$00			ldy 	#0
.0195ef	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195f1	c8		iny				iny
.0195f2	68		pla				pla
.0195f3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195f5					_VCNotArray:
.0195f5	7a		ply				ply
.0195f6	fa		plx				plx
.0195f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.0195f8					ArrayIndexFollow:
.0195f8	5a		phy				phy
.0195f9	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.0195fb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.0195fd	48		pha				pha
.0195fe	c8		iny				iny
.0195ff	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019601	85 23		sta $23				sta 	zVarDataPtr+1
.019603	68		pla				pla
.019604	85 22		sta $22				sta 	zVarDataPtr
.019606	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019608	29 80		and #$80			and 	#$80 						; must be zero.
.01960a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01960c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01960e	d0 59		bne $019669			bne 	_AIFError
.019610	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019612	18		clc				clc
.019613	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019615	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019617	c8		iny				iny
.019618	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01961a	08		php				php 								; clear bit 7 retaining borrow.
.01961b	29 7f		and #$7f			and 	#$7F
.01961d	28		plp				plp
.01961e	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019620	90 47		bcc $019669			bcc 	_AIFError 					; eror if size-current < 0
.019622	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019624	0a		asl a				asl 	a 							; (e.g. index * 2)
.019625	85 10		sta $10				sta 	zTemp1
.019627	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019629	2a		rol a				rol 	a
.01962a	85 11		sta $11				sta 	zTemp1+1
.01962c	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.01962e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019630	30 1d		bmi $01964f			bmi 	_AIFCalculate
.019632	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019634	a5 24		lda $24				lda 	zVarType 					; check that type
.019636	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019638	f0 15		beq $01964f			beq 	_AIFCalculate
.01963a	06 10		asl $10				asl 	zTemp1			 			; double the index
.01963c	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.01963e	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019640	f0 0d		beq $01964f			beq 	_AIFCalculate
.019642	18		clc				clc 								; add the original mantissa in again
.019643	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019645	65 10		adc $10				adc 	zTemp1
.019647	85 10		sta $10				sta 	zTemp1
.019649	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01964b	65 11		adc $11				adc 	zTemp1+1
.01964d	85 11		sta $11				sta 	zTemp1+1
.01964f					_AIFCalculate:
.01964f	18		clc				clc 								; add index x 2,4 or 5 to base
.019650	a5 22		lda $22				lda 	zVarDataPtr
.019652	65 10		adc $10				adc 	zTemp1
.019654	85 22		sta $22				sta 	zVarDataPtr
.019656	a5 23		lda $23				lda 	zVarDataPtr+1
.019658	65 11		adc $11				adc 	zTemp1+1
.01965a	85 23		sta $23				sta 	zVarDataPtr+1
.01965c	18		clc				clc 								; add 2 more for the length prefix.
.01965d	a5 22		lda $22				lda 	zVarDataPtr
.01965f	69 02		adc #$02			adc 	#2
.019661	85 22		sta $22				sta 	zVarDataPtr
.019663	90 02		bcc $019667			bcc 	_AIFNoBump
.019665	e6 23		inc $23				inc 	zVarDataPtr+1
.019667					_AIFNoBump:
.019667	7a		ply				ply
.019668	60		rts				rts
.019669					_AIFError:
.019669	20 ca 84	jsr $0184ca			jsr ERR_Handler
>01966c	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019674	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.01967c					ArrayResetDefault:
.01967c	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.01967e	8d a8 03	sta $03a8			sta 	ArrayDef+0
.019681	a9 00		lda #$00			lda 	#0
.019683	8d a9 03	sta $03a9			sta 	ArrayDef+1
.019686	a9 ff		lda #$ff			lda 	#$FF
.019688	8d aa 03	sta $03aa			sta 	ArrayDef+2 					; $FFFF implies no second element.
.01968b	8d ab 03	sta $03ab			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.01968e	60		rts				rts
.01968f					ArrayCreate:
.01968f	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019692	0a		asl a				asl 	a
.019693	85 10		sta $10				sta 	zTemp1
.019695	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.019698	2a		rol a				rol 	a
.019699	85 11		sta $11				sta 	zTemp1+1
.01969b	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.01969e	10 22		bpl $0196c2			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.0196a0	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.0196a3	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.0196a5	f0 1b		beq $0196c2			beq 	_ACSized
.0196a7	06 10		asl $10				asl 	zTemp1 						; double again
.0196a9	26 11		rol $11				rol 	zTemp1+1
.0196ab	b0 6f		bcs $01971c			bcs 	ArrayIndexError 			; too large.
.0196ad	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.0196af	f0 11		beq $0196c2			beq 	_ACSized
.0196b1	18		clc				clc 								; add original value x 5 for reals.
.0196b2	a5 10		lda $10				lda 	zTemp1
.0196b4	7d a8 03	adc $03a8,x			adc 	ArrayDef+0,x
.0196b7	85 10		sta $10				sta 	zTemp1
.0196b9	a5 11		lda $11				lda 	zTemp1+1
.0196bb	7d a9 03	adc $03a9,x			adc 	ArrayDef+1,x
.0196be	85 11		sta $11				sta 	zTemp1+1
.0196c0	b0 5a		bcs $01971c			bcs 	ArrayIndexError
.0196c2					_ACSized:
.0196c2	18		clc				clc
.0196c3	a5 10		lda $10				lda 	zTemp1
.0196c5	69 02		adc #$02			adc 	#2
.0196c7	85 10		sta $10				sta 	zTemp1
.0196c9	90 04		bcc $0196cf			bcc 	_ACNoBump
.0196cb	e6 10		inc $10				inc 	zTemp1
.0196cd	f0 4d		beq $01971c			beq 	ArrayIndexError
.0196cf					_ACNoBump:
.0196cf	18		clc				clc
.0196d0	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.0196d3	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.0196d5	85 14		sta $14				sta 	zTemp3
.0196d7	65 10		adc $10				adc 	zTemp1
.0196d9	8d 02 03	sta $0302			sta 	VarMemPtr
.0196dc	ad 03 03	lda $0303			lda 	VarMemPtr+1
.0196df	85 13		sta $13				sta 	zTemp2+1
.0196e1	85 15		sta $15				sta 	zTemp3+1
.0196e3	65 11		adc $11				adc 	zTemp1+1
.0196e5	8d 03 03	sta $0303			sta 	VarMemPtr+1
.0196e8	85 11		sta $11				sta 	zTemp1+1
.0196ea	b0 30		bcs $01971c			bcs 	ArrayIndexError
.0196ec	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.0196ee					_ACClear:
.0196ee	98		tya				tya
.0196ef	91 12		sta ($12),y			sta 	(zTemp2),y
.0196f1	e6 12		inc $12				inc 	zTemp2
.0196f3	d0 02		bne $0196f7			bne 	_ACCBump
.0196f5	e6 13		inc $13				inc 	zTemp2+1
.0196f7					_ACCBump:
.0196f7	a5 12		lda $12				lda 	zTemp2
.0196f9	cd 02 03	cmp $0302			cmp 	VarMemPtr
.0196fc	d0 f0		bne $0196ee			bne 	_ACClear
.0196fe	a5 13		lda $13				lda 	zTemp2+1
.019700	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019703	d0 e9		bne $0196ee			bne 	_ACClear
.019705	a0 00		ldy #$00			ldy 	#0
.019707	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; copy the size into the start
.01970a	91 14		sta ($14),y			sta 	(zTemp3),y
.01970c	c8		iny				iny
.01970d	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.019710	91 14		sta ($14),y			sta 	(zTemp3),y
.019712	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; have we reached the end
.019715	10 18		bpl $01972f			bpl 	ACCFillRecursive
.019717	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019719	a5 14		lda $14				lda 	zTemp3
.01971b	60		rts				rts
.01971c					ArrayIndexError:
.01971c	20 ca 84	jsr $0184ca			jsr ERR_Handler
>01971f	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019727	79 20 69 6e 64 65 78 00
.01972f					ACCFillRecursive:
.01972f	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019731	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019733	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019735	c8		iny				iny
.019736	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019738	09 80		ora #$80			ora 	#$80 						; an array of pointers
.01973a	91 14		sta ($14),y			sta 	(zTemp3),y
.01973c	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.01973e	48		pha				pha
.01973f	a5 15		lda $15				lda 	zTemp3+1
.019741	48		pha				pha
.019742					_ACCFillLoop:
.019742	18		clc				clc
.019743	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019745	69 02		adc #$02			adc 	#2
.019747	85 14		sta $14				sta 	zTemp3
.019749	90 02		bcc $01974d			bcc 	_ACCSkip2
.01974b	e6 15		inc $15				inc 	zTemp3+1
.01974d					_ACCSkip2:
.01974d	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.01974f	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019751	c8		iny				iny
.019752	11 14		ora ($14),y			ora 	(zTemp3),y
.019754	d0 21		bne $019777			bne 	_ACCExit
.019756	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019758	48		pha				pha
.019759	a5 15		lda $15				lda 	zTemp3+1
.01975b	48		pha				pha
.01975c	e8		inx				inx
.01975d	e8		inx				inx
.01975e	20 8f 96	jsr $01968f			jsr 	ArrayCreate 				; create array recursively.
.019761	ca		dex				dex
.019762	ca		dex				dex
.019763	85 12		sta $12				sta 	zTemp2 						; save A
.019765	68		pla				pla
.019766	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019768	68		pla				pla
.019769	85 14		sta $14				sta 	zTemp3
.01976b	98		tya				tya 								; write high bye from Y
.01976c	a0 01		ldy #$01			ldy 	#1
.01976e	91 14		sta ($14),y			sta 	(zTemp3),y
.019770	88		dey				dey 								; write low byte out.
.019771	a5 12		lda $12				lda 	zTemp2
.019773	91 14		sta ($14),y			sta 	(zTemp3),y
.019775	80 cb		bra $019742			bra 	_ACCFillLoop 				; and try again.
.019777					_ACCExit:
.019777	7a		ply				ply 								; restore the original address
.019778	68		pla				pla
.019779	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01977a					VariableLocate:
.01977a	da		phx				phx
.01977b	5a		phy				phy
.01977c	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01977f	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019781	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019783	85 13		sta $13				sta 	zTemp2+1
.019785	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019787	b1 12		lda ($12),y			lda 	(zTemp2),y
.019789	aa		tax				tax
.01978a	c8		iny				iny
.01978b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01978d	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01978f	86 12		stx $12				stx 	zTemp2
.019791	05 12		ora $12				ora 	zTemp2 						; got zero
.019793	18		clc				clc
.019794	f0 25		beq $0197bb			beq 	_VLExit 					; if so, then fail as end of chain.
.019796	c8		iny				iny 								; point to hash (offset + 2)
.019797	b1 12		lda ($12),y			lda 	(zTemp2),y
.019799	cd 96 03	cmp $0396			cmp 	Var_Hash
.01979c	d0 e7		bne $019785			bne 	_VLNext 					; try next if different.
.01979e					_VLCompare:
.01979e	c8		iny				iny 								; next character
.01979f	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.0197a1	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.0197a4	d0 df		bne $019785			bne 	_VLNext 					; fail if different, try next.
.0197a6	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.0197a7	90 f5		bcc $01979e			bcc 	_VLCompare
.0197a9	98		tya				tya
.0197aa	38		sec				sec 								; add 1 as Y points to last character
.0197ab	65 12		adc $12				adc 	zTemp2 						; add to the current address
.0197ad	85 22		sta $22				sta 	zVarDataPtr
.0197af	a5 13		lda $13				lda 	zTemp2+1
.0197b1	69 00		adc #$00			adc 	#0
.0197b3	85 23		sta $23				sta 	zVarDataPtr+1
.0197b5	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.0197b8	85 24		sta $24				sta 	zVarType
.0197ba	38		sec				sec 								; return CS
.0197bb	7a		ply		_VLExit:ply
.0197bc	fa		plx				plx
.0197bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.0197be					VariableGet:
.0197be	5a		phy				phy
.0197bf	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.0197c1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0197c3	95 80		sta $80,x			sta 	XS_Mantissa,x
.0197c5	c8		iny				iny
.0197c6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0197c8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0197ca	c8		iny				iny
.0197cb	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.0197cd	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0197cf	f0 2c		beq $0197fd			beq 	_VGString
.0197d1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.0197d3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0197d5	c8		iny				iny
.0197d6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0197d8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0197da	c8		iny				iny
.0197db	a9 01		lda #$01			lda 	#1 							; set type to 1.
.0197dd	95 85		sta $85,x			sta 	XS_Type,x
.0197df	a5 24		lda $24				lda 	zVarType
.0197e1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.0197e3	f0 28		beq $01980d			beq 	_VGExit
.0197e5	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.0197e7	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.0197e9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.0197eb	95 84		sta $84,x			sta 	XS_Exponent,x
.0197ed	f0 1e		beq $01980d			beq 	_VGExit 					; if exponent is zero ... it's zero.
.0197ef	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.0197f1	48		pha				pha
.0197f2	29 80		and #$80			and 	#$80
.0197f4	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.0197f6	68		pla				pla
.0197f7	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.0197f9	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.0197fb	80 10		bra $01980d			bra 	_VGExit
.0197fd					_VGString:
.0197fd	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.0197ff	95 85		sta $85,x			sta 	XS_Type,x
.019801	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019803	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019805	d0 06		bne $01980d			bne 	_VGExit 					; if not, exit.
.019807	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019809	a9 25		lda #$25			lda 	#zNullString
.01980b	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01980d					_VGExit:
.01980d	7a		ply				ply
.01980e	60		rts				rts
.01980f					VariableSet:
.01980f	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019811	29 02		and #$02			and 	#2 							; if so, it has to be
.019813	d0 4b		bne $019860			bne 	_VSString
.019815	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019817	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019819	f0 42		beq $01985d			beq 	_VSBadType
.01981b	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01981d	f0 05		beq $019824			beq 	_VSMakeInt
.01981f	20 48 9d	jsr $019d48			jsr 	FPUToFloat
.019822	80 03		bra $019827			bra 	_VSCopy
.019824					_VSMakeInt:
.019824	20 94 9d	jsr $019d94			jsr 	FPUToInteger
.019827					_VSCopy:
.019827	5a		phy				phy
.019828	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01982a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01982c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01982e	c8		iny				iny
.01982f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019831	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019833	c8		iny				iny
.019834	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019836	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019838	c8		iny				iny
.019839	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01983b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01983d	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.01983f	c9 bb		cmp #$bb			cmp 	#token_Percent
.019841	f0 18		beq $01985b			beq 	_VSExit
.019843	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019845	0a		asl a				asl 	a
.019846	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019848	08		php				php
.019849	0a		asl a				asl 	a
.01984a	28		plp				plp
.01984b	6a		ror a				ror 	a
.01984c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01984e	c8		iny				iny
.01984f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019851	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019853	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019855	50 04		bvc $01985b			bvc 	_VSExit
.019857	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019859	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01985b					_VSExit:
.01985b	7a		ply				ply
.01985c	60		rts				rts
.01985d					_VSBadType:
.01985d	4c ab 84	jmp $0184ab			jmp 	TypeError
.019860					_VSString:
.019860	a5 24		lda $24				lda 	zVarType 					; type must be $
.019862	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019864	d0 f7		bne $01985d			bne 	_VSBadType
.019866	da		phx				phx
.019867	5a		phy				phy
.019868	20 e5 93	jsr $0193e5			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01986b	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01986d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01986f	88		dey				dey 								; save low byte
.019870	8a		txa				txa
.019871	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019873	7a		ply				ply 								; and exit.
.019874	fa		plx				plx
.019875	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019876					MulInteger32:
.019876	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019878	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01987a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01987c	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01987e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019880	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019882	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019884	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019886	a9 00		lda #$00			lda 	#0
.019888	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.01988a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01988c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01988e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019890					_BFMMultiply:
.019890	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019892	29 01		and #$01			and 	#1
.019894	f0 03		beq $019899			beq 	_BFMNoAdd
.019896	20 4d 8f	jsr $018f4d			jsr 	AddInteger32
.019899					_BFMNoAdd:
.019899	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01989b	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01989d	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01989f	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.0198a1	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.0198a3	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.0198a5	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.0198a7	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.0198a9	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.0198ab	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.0198ad	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.0198af	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.0198b1	d0 dd		bne $019890			bne 	_BFMMultiply
.0198b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.0198b4					DivInteger32:
.0198b4	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.0198b6	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0198b8	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0198ba	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0198bc	d0 14		bne $0198d2			bne 	_BFDOkay
.0198be	20 ca 84	jsr $0184ca			jsr ERR_Handler
>0198c1	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>0198c9	20 62 79 20 5a 65 72 6f 00
.0198d2					_BFDOkay:
.0198d2	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.0198d4	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.0198d6	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.0198d8	85 1c		sta $1c				sta 	zLTemp1+2
.0198da	85 1d		sta $1d				sta 	zLTemp1+3
.0198dc	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.0198df	20 36 99	jsr $019936			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.0198e2	da		phx				phx
.0198e3	e8		inx				inx
.0198e4	e8		inx				inx
.0198e5	e8		inx				inx
.0198e6	e8		inx				inx
.0198e7	e8		inx				inx
.0198e8	e8		inx				inx
.0198e9	20 36 99	jsr $019936			jsr 	CheckIntegerNegate
.0198ec	fa		plx				plx
.0198ed	5a		phy				phy 								; Y is the counter
.0198ee	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.0198f0					_BFDLoop:
.0198f0	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.0198f2	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0198f4	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0198f6	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0198f8	26 1a		rol $1a				rol 	zLTemp1
.0198fa	26 1b		rol $1b				rol 	zLTemp1+1
.0198fc	26 1c		rol $1c				rol 	zLTemp1+2
.0198fe	26 1d		rol $1d				rol 	zLTemp1+3
.019900	38		sec				sec
.019901	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019903	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019905	48		pha				pha
.019906	a5 1b		lda $1b				lda 	zLTemp1+1
.019908	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01990a	48		pha				pha
.01990b	a5 1c		lda $1c				lda 	zLTemp1+2
.01990d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01990f	48		pha				pha
.019910	a5 1d		lda $1d				lda 	zLTemp1+3
.019912	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019914	90 13		bcc $019929			bcc 	_BFDNoAdd
.019916	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019918	68		pla				pla
.019919	85 1c		sta $1c				sta 	zLTemp1+2
.01991b	68		pla				pla
.01991c	85 1b		sta $1b				sta 	zLTemp1+1
.01991e	68		pla				pla
.01991f	85 1a		sta $1a				sta 	zLTemp1+0
.019921	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019923	09 01		ora #$01			ora 	#1
.019925	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019927	80 03		bra $01992c			bra 	_BFDNext
.019929					_BFDNoAdd:
.019929	68		pla				pla 								; Throw away the intermediate calculations
.01992a	68		pla				pla
.01992b	68		pla				pla
.01992c					_BFDNext:
.01992c	88		dey				dey
.01992d	d0 c1		bne $0198f0			bne 	_BFDLoop
.01992f	7a		ply				ply 								; restore Y and exit
.019930	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019933	b0 06		bcs $01993b			bcs		IntegerNegateAlways 			; negate the result
.019935	60		rts				rts
.019936					CheckIntegerNegate:
.019936	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019938	30 01		bmi $01993b			bmi 	IntegerNegateAlways
.01993a	60		rts				rts
.01993b					IntegerNegateAlways:
.01993b	ee 9e 03	inc $039e			inc 	SignCount
.01993e	38		sec				sec
.01993f	a9 00		lda #$00			lda 	#0
.019941	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019943	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019945	a9 00		lda #$00			lda 	#0
.019947	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019949	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01994b	a9 00		lda #$00			lda 	#0
.01994d	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01994f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019951	a9 00		lda #$00			lda 	#0
.019953	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019955	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019957	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019958					INTToString:
.019958	48		pha				pha
.019959	5a		phy				phy
.01995a	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01995c	10 08		bpl $019966			bpl 		_ITSNotMinus
.01995e	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019960	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter
.019963	20 3b 99	jsr $01993b			jsr 		IntegerNegateAlways 	; negate the number.
.019966					_ITSNotMinus:
.019966	a9 00		lda #$00			lda 		#0
.019968	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01996b	8a		txa				txa 								; use Y for the mantissa index.
.01996c	a8		tay				tay
.01996d	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01996f					_ITSNextSubtractor:
.01996f	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019971	8d 9b 03	sta $039b			sta 		NumConvCount
.019974					_ITSSubtract:
.019974	38		sec				sec
.019975	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019978	ff d6 99 01	sbc $0199d6,x			sbc 		_ITSSubtractors+0,x
.01997c	48		pha				pha
.01997d	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019980	ff d7 99 01	sbc $0199d7,x			sbc 		_ITSSubtractors+1,x
.019984	48		pha				pha
.019985	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019988	ff d8 99 01	sbc $0199d8,x			sbc 		_ITSSubtractors+2,x
.01998c	48		pha				pha
.01998d	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019990	ff d9 99 01	sbc $0199d9,x			sbc 		_ITSSubtractors+3,x
.019994	90 14		bcc $0199aa			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019996	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019999	68		pla				pla
.01999a	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01999d	68		pla				pla
.01999e	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.0199a1	68		pla				pla
.0199a2	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.0199a5	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.0199a8	80 ca		bra $019974			bra 		_ITSSubtract 			; go round again.
.0199aa					_ITSCantSubtract:
.0199aa	68		pla				pla 								; throw away interim answers
.0199ab	68		pla				pla
.0199ac	68		pla				pla
.0199ad	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.0199b0	c9 30		cmp #$30			cmp 		#"0"
.0199b2	d0 05		bne $0199b9			bne 		_ITSOutputDigit
.0199b4	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.0199b7	10 09		bpl $0199c2			bpl	 		_ITSGoNextSubtractor
.0199b9					_ITSOutputDigit:
.0199b9	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.0199bc	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.0199bf	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter 		; output it.
.0199c2					_ITSGoNextSubtractor:
.0199c2	e8		inx				inx 								; next dword
.0199c3	e8		inx				inx
.0199c4	e8		inx				inx
.0199c5	e8		inx				inx
.0199c6	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.0199c8	d0 a5		bne $01996f			bne 		_ITSNextSubtractor 		; do all the subtractors.
.0199ca	98		tya				tya 								; X is back as the mantissa index
.0199cb	aa		tax				tax
.0199cc	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.0199ce	09 30		ora #$30			ora 		#"0"
.0199d0	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter
.0199d3	7a		ply				ply 								; and exit
.0199d4	68		pla				pla
.0199d5	60		rts				rts
.0199d6					_ITSSubtractors:
>0199d6	00 ca 9a 3b					.dword 		1000000000
>0199da	00 e1 f5 05					.dword 		100000000
>0199de	80 96 98 00					.dword 		10000000
>0199e2	40 42 0f 00					.dword 		1000000
>0199e6	a0 86 01 00					.dword 		100000
>0199ea	10 27 00 00					.dword 		10000
>0199ee	e8 03 00 00					.dword 		1000
>0199f2	64 00 00 00					.dword 		100
>0199f6	0a 00 00 00					.dword 		10
.0199fa					_ITSSubtractorsEnd:
.0199fa					ITSOutputCharacter:
.0199fa	48		pha				pha
.0199fb	da		phx				phx
.0199fc	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.0199ff	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019a02	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019a04	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019a07	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019a0a	fa		plx				plx
.019a0b	68		pla				pla
.019a0c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019a0d					IntFromString:
.019a0d	a0 00		ldy #$00			ldy 	#0
.019a0f	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019a12					IntFromStringY:
.019a12	48		pha				pha
.019a13	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019a15	95 80		sta $80,x			sta 	XS_Mantissa,x
.019a17	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019a19	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019a1b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019a1d	a9 01		lda #$01			lda 	#1
.019a1f	95 85		sta $85,x			sta 	XS_Type,x
.019a21					_IFSLoop:
.019a21	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019a23	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019a25	90 4e		bcc $019a75			bcc 	_IFSExit
.019a27	c9 3a		cmp #$3a			cmp 	#"9"+1
.019a29	b0 4a		bcs $019a75			bcs 	_IFSExit
.019a2b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019a2d	c9 0c		cmp #$0c			cmp 	#12
.019a2f	b0 4e		bcs $019a7f			bcs 	_IFSOverflow
.019a31	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019a33	48		pha				pha
.019a34	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019a36	48		pha				pha
.019a37	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a39	48		pha				pha
.019a3a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019a3c	48		pha				pha
.019a3d	20 94 9a	jsr $019a94			jsr 	IFSX1ShiftLeft 				; double
.019a40	20 94 9a	jsr $019a94			jsr 	IFSX1ShiftLeft 				; x 4
.019a43	18		clc				clc 								; add saved value x 5
.019a44	68		pla				pla
.019a45	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019a47	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019a49	68		pla				pla
.019a4a	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019a4c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019a4e	68		pla				pla
.019a4f	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019a51	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019a53	68		pla				pla
.019a54	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019a56	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019a58	20 94 9a	jsr $019a94			jsr 	IFSX1ShiftLeft 				; x 10
.019a5b	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019a5e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019a60	29 0f		and #$0f			and 	#15
.019a62	c8		iny				iny
.019a63	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019a65	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019a67	90 b8		bcc $019a21			bcc 	_IFSLoop
.019a69	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019a6b	d0 b4		bne $019a21			bne 	_IFSLoop
.019a6d	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019a6f	d0 b0		bne $019a21			bne 	_IFSLoop
.019a71	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019a73	80 ac		bra $019a21			bra 	_IFSLoop
.019a75					_IFSExit:
.019a75	98		tya				tya 								; get offset
.019a76					_IFSOkay:
.019a76	38		sec				sec
.019a77	ad 9c 03	lda $039c			lda 	ExpTemp
.019a7a	f0 01		beq $019a7d			beq 	_IFSSkipFail
.019a7c	18		clc				clc
.019a7d					_IFSSkipFail:
.019a7d	68		pla				pla 								; and exit.
.019a7e	60		rts				rts
.019a7f					_IFSOverflow:
.019a7f	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>019a82	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019a8a	20 6f 76 65 72 66 6c 6f 77 00
.019a94					IFSX1ShiftLeft:
.019a94	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019a96	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019a98	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019a9a	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019a9c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019a9d					FPSubtract:
.019a9d	48		pha				pha
.019a9e	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019aa0	49 80		eor #$80			eor 	#$80
.019aa2	95 8b		sta $8b,x			sta 	XS2_Type,x
.019aa4	68		pla				pla 								; --- and fall through ---
.019aa5					FPAdd:
.019aa5	48		pha				pha
.019aa6	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019aa8	d0 05		bne $019aaf			bne 	_FPA_NegativeLHS
.019aaa	20 c6 9a	jsr $019ac6			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019aad	68		pla				pla
.019aae	60		rts				rts
.019aaf					_FPA_NegativeLHS:
.019aaf	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019ab1	49 80		eor #$80			eor 	#$80
.019ab3	95 85		sta $85,x			sta 	XS_Type,x
.019ab5	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019ab7	49 80		eor #$80			eor 	#$80
.019ab9	95 8b		sta $8b,x			sta 	XS2_Type,x
.019abb	20 c6 9a	jsr $019ac6			jsr 	FPAdd_Worker 				; do the add calculation.
.019abe	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019ac0	49 80		eor #$80			eor 	#$80
.019ac2	95 85		sta $85,x			sta 	XS_Type,x
.019ac4	68		pla				pla
.019ac5	60		rts				rts
.019ac6					FPAdd_Worker:
.019ac6	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019ac8	70 07		bvs $019ad1			bvs 	_FPAWExit 					; no change.
.019aca	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019acc	50 07		bvc $019ad5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019ace	20 06 9d	jsr $019d06			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019ad1					_FPAWExit:
.019ad1	20 75 9d	jsr $019d75			jsr 	FPUNormalise 				; normalise the result.
.019ad4	60		rts				rts
.019ad5					_FPAWMakeSame:
.019ad5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019ad7	38		sec				sec
.019ad8	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019ada	f0 16		beq $019af2			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019adc	da		phx				phx 								; save X
.019add	90 06		bcc $019ae5			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019adf	e8		inx				inx
.019ae0	e8		inx				inx
.019ae1	e8		inx				inx
.019ae2	e8		inx				inx
.019ae3	e8		inx				inx
.019ae4	e8		inx				inx
.019ae5					_FPAWShiftA:
.019ae5	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019ae7	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019ae9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019aeb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019aed	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019aef	fa		plx				plx 								; restore original X
.019af0	80 e3		bra $019ad5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019af2					_FPAW_DoArithmetic:
.019af2	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019af4	30 28		bmi $019b1e			bmi 	_FPAW_BNegative
.019af6	18		clc				clc
.019af7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019af9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019afb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019afd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019aff	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019b01	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b03	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019b05	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019b07	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b09	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019b0b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019b0d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b0f	90 c0		bcc $019ad1			bcc 	_FPAWExit 					; no carry.
.019b11	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019b13	38		sec				sec
.019b14	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019b16	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019b18	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019b1a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019b1c	80 b3		bra $019ad1			bra 	_FPAWExit
.019b1e					_FPAW_BNegative:
.019b1e	38		sec				sec
.019b1f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019b21	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019b23	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019b25	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b27	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019b29	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b2b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019b2d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019b2f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b31	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019b33	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019b35	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b37	b0 09		bcs $019b42			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019b39	20 2c 9d	jsr $019d2c			jsr 	FPUNegateInteger			; negate the mantissa
.019b3c	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019b3e	49 80		eor #$80			eor 	#$80
.019b40	95 85		sta $85,x			sta 	XS_Type,x
.019b42					_FPAWGoExit:
.019b42	4c d1 9a	jmp $019ad1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019b45					FPD_IsDivZero:
.019b45	20 ca 84	jsr $0184ca			jsr ERR_Handler
>019b48	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019b50	20 62 79 20 7a 65 72 6f 00
.019b59					FPDivide:
.019b59	48		pha				pha
.019b5a	5a		phy				phy
.019b5b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019b5d	70 e6		bvs $019b45			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019b5f	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019b61	f0 03		beq $019b66			beq 	_FPDCalculateExp
.019b63					_FPD_Exit:
.019b63	7a		ply				ply
.019b64	68		pla				pla
.019b65	60		rts				rts
.019b66					_FPDCalculateExp:
.019b66	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019b68	49 ff		eor #$ff			eor 	#$FF
.019b6a	1a		inc a				inc 	a
.019b6b	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019b6d	20 3d 9c	jsr $019c3d			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019b70	18		clc				clc 	 							; add 1 to the resulting exponent
.019b71	69 01		adc #$01			adc 	#1
.019b73	b0 54		bcs $019bc9			bcs 	_FPD_Overflow 				; which can overflow.
.019b75	95 84		sta $84,x			sta 	XS_Exponent,x
.019b77	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019b79	85 1a		sta $1a				sta 	zLTemp1+0
.019b7b	85 1b		sta $1b				sta 	zLTemp1+1
.019b7d	85 1c		sta $1c				sta 	zLTemp1+2
.019b7f	85 1d		sta $1d				sta 	zLTemp1+3
.019b81	a0 20		ldy #$20			ldy 	#32 						; times round.
.019b83					_FPD_Loop:
.019b83	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019b84	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019b86	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019b88	48		pha				pha
.019b89	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019b8b	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019b8d	48		pha				pha
.019b8e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019b90	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019b92	48		pha				pha
.019b93	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019b95	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019b97	90 13		bcc $019bac			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019b99	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019b9b	68		pla				pla
.019b9c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b9e	68		pla				pla
.019b9f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ba1	68		pla				pla
.019ba2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ba4	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019ba6	09 80		ora #$80			ora 	#$80
.019ba8	85 1d		sta $1d				sta 	zLTemp1+3
.019baa	80 03		bra $019baf			bra 	_FPD_Rotates
.019bac					_FPD_NoSubtract:
.019bac	68		pla				pla 								; throw away unwanted results
.019bad	68		pla				pla
.019bae	68		pla				pla
.019baf					_FPD_Rotates:
.019baf	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019bb1	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019bb3	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019bb5	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019bb7	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019bb9	26 1b		rol $1b				rol 	zLTemp1+1
.019bbb	26 1c		rol $1c				rol 	zLTemp1+2
.019bbd	26 1d		rol $1d				rol 	zLTemp1+3
.019bbf	90 02		bcc $019bc3			bcc 	_FPD_NoCarry
.019bc1	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019bc3					_FPD_NoCarry:
.019bc3	88		dey				dey 								; do 32 times
.019bc4	d0 bd		bne $019b83			bne 	_FPD_Loop
.019bc6	4c 21 9c	jmp $019c21			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019bc9					_FPD_Overflow:
.019bc9	4c d2 9d	jmp $019dd2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019bcc					FPMultiply:
.019bcc	48		pha				pha
.019bcd	5a		phy				phy
.019bce	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019bd0	70 07		bvs $019bd9			bvs 	_FPM_Exit
.019bd2	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019bd4	50 06		bvc $019bdc			bvc 	_FPM_CalcExponent
.019bd6	20 06 9d	jsr $019d06			jsr 	FPUCopyX2ToX1
.019bd9					_FPM_Exit:
.019bd9	7a		ply				ply
.019bda	68		pla				pla
.019bdb	60		rts				rts
.019bdc					_FPM_CalcExponent:
.019bdc	18		clc				clc
.019bdd	20 3d 9c	jsr $019c3d			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019be0	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019be2	a9 00		lda #$00			lda 	#0
.019be4	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019be6	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019be8	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019bea	85 1d		sta $1d				sta 	zLTemp1+3
.019bec	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019bee					_FPM_Loop:
.019bee	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019bf0	29 01		and #$01			and 	#1
.019bf2	18		clc				clc 								; clear carry for the long rotate.
.019bf3	f0 19		beq $019c0e			beq 	_FPM_NoAddition
.019bf5	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019bf6	a5 1a		lda $1a				lda 	zLTemp1+0
.019bf8	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019bfa	85 1a		sta $1a				sta 	zLTemp1+0
.019bfc	a5 1b		lda $1b				lda 	zLTemp1+1
.019bfe	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019c00	85 1b		sta $1b				sta 	zLTemp1+1
.019c02	a5 1c		lda $1c				lda 	zLTemp1+2
.019c04	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019c06	85 1c		sta $1c				sta 	zLTemp1+2
.019c08	a5 1d		lda $1d				lda 	zLTemp1+3
.019c0a	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019c0c	85 1d		sta $1d				sta 	zLTemp1+3
.019c0e					_FPM_NoAddition:
.019c0e	66 1d		ror $1d				ror 	3+zLTemp1
.019c10	66 1c		ror $1c				ror 	2+zLTemp1
.019c12	66 1b		ror $1b				ror 	1+zLTemp1
.019c14	66 1a		ror $1a				ror 	0+zLTemp1
.019c16	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019c18	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019c1a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019c1c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019c1e	88		dey				dey
.019c1f	d0 cd		bne $019bee			bne 	_FPM_Loop 					; do this 32 times.
.019c21					FPM_CopySignNormalize:
.019c21	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019c23	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019c25	a5 1b		lda $1b				lda 	zLTemp1+1
.019c27	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c29	a5 1c		lda $1c				lda 	zLTemp1+2
.019c2b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c2d	a5 1d		lda $1d				lda 	zLTemp1+3
.019c2f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c31	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.019c33	55 8b		eor $8b,x			eor 	XS2_Type,x
.019c35	95 85		sta $85,x			sta 	XS_Type,x
.019c37	20 75 9d	jsr $019d75			jsr 	FPUNormalise 				; normalise and exit.
.019c3a	7a		ply				ply
.019c3b	68		pla				pla
.019c3c	60		rts				rts
.019c3d					FPCalculateExponent:
.019c3d	18		clc				clc
.019c3e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019c40	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.019c42	b0 08		bcs $019c4c			bcs 	_FPCECarry 					; carry out ?
.019c44	10 03		bpl $019c49			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019c46	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019c48	60		rts				rts
.019c49					_FPCEExpZero:
.019c49	a9 00		lda #$00			lda 	#0
.019c4b	60		rts				rts
.019c4c					_FPCECarry:
.019c4c	30 03		bmi $019c51			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019c4e	09 80		ora #$80			ora 	#$80 						; put in right range
.019c50	60		rts				rts
.019c51					_FPCEOverflow:
.019c51	4c d2 9d	jmp $019dd2			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019c54					FPFractionalPart:
.019c54	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019c56	38		sec				sec 								; this flag tells us to keep the fractional part
.019c57	30 0d		bmi $019c66			bmi 	FPGetPart
.019c59	60		rts				rts
.019c5a					FPIntegerPart:
.019c5a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019c5c	18		clc				clc 								; this flag says keep the integer part.
.019c5d	30 07		bmi $019c66			bmi 	FPGetPart 					; -ve exponents are 0..127
.019c5f	48		pha				pha
.019c60	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019c62	95 85		sta $85,x			sta 	XS_Type,x
.019c64	68		pla				pla
.019c65	60		rts				rts
.019c66					FPGetPart:
.019c66	48		pha				pha
.019c67	5a		phy				phy 								; save Y
.019c68	08		php				php 								; save action
.019c69	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019c6b	70 59		bvs $019cc6			bvs 	_FPGP_Exit 					; then do nothing.
.019c6d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019c6f	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019c71	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019c73	85 1c		sta $1c				sta 	zLTemp1+2
.019c75	85 1d		sta $1d				sta 	zLTemp1+3
.019c77	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.019c79	38		sec				sec
.019c7a	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019c7c	f0 12		beq $019c90			beq 	_FPGP_NoShift 				; ... if any
.019c7e	c9 20		cmp #$20			cmp 	#32
.019c80	90 02		bcc $019c84			bcc 	_FPGP_NotMax
.019c82	a9 20		lda #$20			lda 	#32 						; max of 32.
.019c84					_FPGP_NotMax:
.019c84	a8		tay				tay 								; Y is the mask shift count.
.019c85					_FPGP_ShiftMask:
.019c85	46 1d		lsr $1d				lsr 	3+zLTemp1
.019c87	66 1c		ror $1c				ror 	2+zLTemp1
.019c89	66 1b		ror $1b				ror 	1+zLTemp1
.019c8b	66 1a		ror $1a				ror 	0+zLTemp1
.019c8d	88		dey				dey
.019c8e	d0 f5		bne $019c85			bne 	_FPGP_ShiftMask
.019c90					_FPGP_NoShift:
.019c90	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019c92	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.019c95					_FPGP_MaskLoop:
.019c95	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019c98	28		plp				plp 								; if CC we keep the top part, so we
.019c99	08		php				php		 							; flip the mask.
.019c9a	b0 02		bcs $019c9e			bcs		_FPGP_NoFlip
.019c9c	49 ff		eor #$ff			eor 	#$FF
.019c9e					_FPGP_NoFlip:
.019c9e	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019ca0	95 80		sta $80,x			sta 	XS_Mantissa,x
.019ca2	e8		inx				inx
.019ca3	c8		iny				iny
.019ca4	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019ca6	d0 ed		bne $019c95			bne 	_FPGP_MaskLoop
.019ca8	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.019cab	28		plp				plp
.019cac	08		php				php 								; get action flag on the stack
.019cad	90 04		bcc $019cb3			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019caf	a9 00		lda #$00			lda 	#0
.019cb1	95 85		sta $85,x			sta 	XS_Type,x
.019cb3					_FPGP_NotFractional:
.019cb3	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019cb5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019cb7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019cb9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019cbb	f0 05		beq $019cc2			beq 	_FPGP_Zero 					; if zero, return zero
.019cbd	20 75 9d	jsr $019d75			jsr 	FPUNormalise
.019cc0	80 04		bra $019cc6			bra 	_FPGP_Exit 					; and exit
.019cc2					_FPGP_Zero:
.019cc2	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019cc4	95 85		sta $85,x			sta 	XS_Type,x
.019cc6					_FPGP_Exit:
.019cc6	68		pla				pla 								; throw saved action flag.
.019cc7	7a		ply				ply
.019cc8	68		pla				pla
.019cc9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019cca					FPCompare:
.019cca	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019ccc	48		pha				pha
.019ccd	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.019ccf	48		pha				pha
.019cd0	20 9d 9a	jsr $019a9d			jsr 	FPSubtract 					; calculate X1-X2
.019cd3	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019cd5	70 2a		bvs $019d01			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019cd7	68		pla				pla
.019cd8	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.019cdb	68		pla				pla
.019cdc	38		sec				sec
.019cdd	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.019ce0	70 14		bvs $019cf6			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019ce2	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019ce3	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019ce5	b0 0f		bcs $019cf6			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019ce7	38		sec				sec
.019ce8	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.019ceb	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019ced	b0 02		bcs $019cf1			bcs 	_FPCNotRange 				; keep in range.
.019cef	a9 01		lda #$01			lda 	#1
.019cf1					_FPCNotRange:
.019cf1	38		sec				sec
.019cf2	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019cf4	b0 0d		bcs $019d03			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019cf6					_FPCNotEqual:
.019cf6	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019cf8	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019cfa	f0 02		beq $019cfe			beq 	_FPCNE2
.019cfc	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019cfe	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019cff	80 04		bra $019d05			bra 	_FPCExit
.019d01					_FPCPullZero:
.019d01	68		pla				pla 								; throw saved exponents
.019d02	68		pla				pla
.019d03					_FPCZero:
.019d03	a9 00		lda #$00			lda 	#0 							; and return zero
.019d05					_FPCExit:
.019d05	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019d06					FPUCopyX2ToX1:
.019d06	48		pha				pha
.019d07	da		phx				phx
.019d08	5a		phy				phy
.019d09	a0 08		ldy #$08			ldy 	#8
.019d0b	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.019d0d	95 80		sta $80,x			sta 	XS_Mantissa,x
.019d0f	e8		inx				inx
.019d10	88		dey				dey
.019d11	10 f8		bpl $019d0b			bpl 	_FPUC21
.019d13	7a		ply				ply
.019d14	fa		plx				plx
.019d15	68		pla				pla
.019d16	60		rts				rts
.019d17					FPUSetInteger:
.019d17	48		pha				pha
.019d18	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019d1a	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019d1c	10 02		bpl $019d20			bpl 	_FPUSIExtend
.019d1e	a9 ff		lda #$ff			lda 	#$FF
.019d20					_FPUSIExtend:
.019d20	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019d22	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d24	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d26	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019d28	95 85		sta $85,x			sta 	XS_Type,x
.019d2a	68		pla				pla
.019d2b	60		rts				rts
.019d2c					FPUNegateInteger:
.019d2c	48		pha				pha
.019d2d	38		sec				sec
.019d2e	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019d30	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019d32	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d34	a9 00		lda #$00			lda 	#0
.019d36	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019d38	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d3a	a9 00		lda #$00			lda 	#0
.019d3c	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019d3e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d40	a9 00		lda #$00			lda 	#0
.019d42	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019d44	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019d46	68		pla				pla
.019d47	60		rts				rts
.019d48					FPUToFloat:
.019d48	48		pha				pha
.019d49	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.019d4b	29 0f		and #$0f			and 	#$0F
.019d4d	f0 24		beq $019d73			beq 	_FPUFExit
.019d4f	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019d51	95 85		sta $85,x			sta 	XS_Type,x
.019d53	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019d55	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.019d57	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019d59	10 07		bpl $019d62			bpl		_FPUFPositive
.019d5b	20 2c 9d	jsr $019d2c			jsr 	FPUNegateInteger 			; negate the mantissa
.019d5e	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019d60	95 85		sta $85,x			sta 	XS_Type,x
.019d62					_FPUFPositive:
.019d62	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019d64	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019d66	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019d68	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019d6a	d0 04		bne $019d70			bne 	_FPUFNonZero
.019d6c	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019d6e	95 85		sta $85,x			sta 	XS_Type,x
.019d70					_FPUFNonZero:
.019d70	20 75 9d	jsr $019d75			jsr 	FPUNormalise 				; normalise the floating point.
.019d73					_FPUFExit:
.019d73	68		pla				pla
.019d74	60		rts				rts
.019d75					FPUNormalise:
.019d75	48		pha				pha
.019d76	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019d78	70 18		bvs $019d92			bvs 	_FPUNExit
.019d7a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019d7c	f0 10		beq $019d8e			beq 	_FPUNSetZero
.019d7e					_FPUNLoop:
.019d7e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019d80	30 10		bmi $019d92			bmi 	_FPUNExit 					; if so, we are normalised.
.019d82	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.019d84	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.019d86	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.019d88	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.019d8a	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.019d8c	d0 f0		bne $019d7e			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019d8e					_FPUNSetZero:
.019d8e	a9 40		lda #$40			lda 	#$40
.019d90	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.019d92					_FPUNExit:
.019d92	68		pla				pla
.019d93	60		rts				rts
.019d94					FPUToInteger:
.019d94	48		pha				pha
.019d95	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.019d97	29 01		and #$01			and 	#1
.019d99	d0 31		bne $019dcc			bne 	_FPUTOI_Exit
.019d9b	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.019d9d	70 23		bvs $019dc2			bvs 	_FPUTOI_Zero
.019d9f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019da1	10 1f		bpl $019dc2			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019da3	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019da5	b0 2b		bcs $019dd2			bcs 	FP_Overflow
.019da7					_FPUToIToInteger:
.019da7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019da9	c9 a0		cmp #$a0			cmp 	#128+32
.019dab	f0 0c		beq $019db9			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019dad	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.019daf	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019db1	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019db3	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019db5	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019db7	80 ee		bra $019da7			bra 	_FPUToIToInteger 			; keep going.
.019db9					_FPUToICheckSign:
.019db9	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.019dbb	10 0f		bpl $019dcc			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019dbd	20 2c 9d	jsr $019d2c			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019dc0	80 0a		bra $019dcc			bra 	_FPUTOI_Exit
.019dc2					_FPUTOI_Zero:
.019dc2	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019dc4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dc6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dc8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019dca	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019dcc					_FPUToI_Exit:
.019dcc	a9 01		lda #$01			lda 	#1 							; set type to integer
.019dce	95 85		sta $85,x			sta 	XS_Type,x
.019dd0	68		pla				pla
.019dd1	60		rts				rts
.019dd2					FP_Overflow:
.019dd2	20 ca 84	jsr $0184ca			jsr ERR_Handler
>019dd5	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019ddd	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019ded					FPUTimes10:
.019ded	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019def	85 1a		sta $1a				sta 	ZLTemp1+0
.019df1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019df3	85 1b		sta $1b				sta 	ZLTemp1+1
.019df5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019df7	85 1c		sta $1c				sta 	ZLTemp1+2
.019df9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019dfb	85 1d		sta $1d				sta 	ZLTemp1+3
.019dfd	20 32 9e	jsr $019e32			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019e00	20 32 9e	jsr $019e32			jsr 	_FPUT_LSR_ZLTemp1
.019e03	18		clc				clc
.019e04	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019e06	65 1a		adc $1a				adc 	ZLTemp1+0
.019e08	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e0a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e0c	65 1b		adc $1b				adc 	ZLTemp1+1
.019e0e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e10	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e12	65 1c		adc $1c				adc 	ZLTemp1+2
.019e14	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e16	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019e18	65 1d		adc $1d				adc 	ZLTemp1+3
.019e1a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e1c	90 0a		bcc $019e28			bcc 	_FPUTimes10
.019e1e	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019e20	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019e22	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019e24	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019e26	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.019e28					_FPUTimes10:
.019e28	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019e2a	18		clc				clc
.019e2b	69 03		adc #$03			adc 	#3
.019e2d	95 84		sta $84,x			sta 	XS_Exponent,x
.019e2f	b0 a1		bcs $019dd2			bcs 	FP_Overflow 				; error
.019e31	60		rts				rts
.019e32					_FPUT_LSR_ZLTemp1:
.019e32	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019e34	66 1c		ror $1c				ror 	ZLTemp1+2
.019e36	66 1b		ror $1b				ror 	ZLTemp1+1
.019e38	66 1a		ror $1a				ror 	ZLTemp1+0
.019e3a	60		rts				rts
.019e3b					FPUScale10A:
.019e3b	5a		phy				phy
.019e3c	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019e3e	f0 37		beq $019e77			beq 	_FPUScaleExit
.019e40	da		phx				phx 								; save X
.019e41	e8		inx				inx
.019e42	e8		inx				inx
.019e43	e8		inx				inx
.019e44	e8		inx				inx
.019e45	e8		inx				inx
.019e46	e8		inx				inx
.019e47	a8		tay				tay 								; save power scalar in Y.
.019e48	a9 00		lda #$00			lda 	#0
.019e4a	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019e4c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e4e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e50	95 85		sta $85,x			sta 	XS_Type,x
.019e52	a9 80		lda #$80			lda 	#$80
.019e54	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e56	a9 81		lda #$81			lda 	#$81
.019e58	95 84		sta $84,x			sta 	XS_Exponent,x
.019e5a	5a		phy				phy 								; save 10^n on stack.
.019e5b	c0 00		cpy #$00			cpy 	#0
.019e5d	10 05		bpl $019e64			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019e5f	98		tya				tya
.019e60	49 ff		eor #$ff			eor 	#$FF
.019e62	1a		inc a				inc 	a
.019e63	a8		tay				tay
.019e64					_FPUSAbs:
.019e64	20 ed 9d	jsr $019ded			jsr 	FPUTimes10
.019e67	88		dey				dey
.019e68	d0 fa		bne $019e64			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019e6a	68		pla				pla 								; restore count in A
.019e6b	fa		plx				plx 								; restore X pointing to number to scale.
.019e6c	0a		asl a				asl 	a
.019e6d	b0 05		bcs $019e74			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019e6f	20 cc 9b	jsr $019bcc			jsr 	FPMultiply 					; if clear multiply.
.019e72	80 03		bra $019e77			bra		_FPUScaleExit
.019e74					_FPUSDivide:
.019e74	20 59 9b	jsr $019b59			jsr 	FPDivide
.019e77					_FPUScaleExit:
.019e77	7a		ply				ply
.019e78	60		rts				rts
.019e79					FPUCopyToNext:
.019e79	a0 06		ldy #$06			ldy 		#6
.019e7b	da		phx				phx
.019e7c					_FPUCopy1:
.019e7c	b5 80		lda $80,x			lda 	XS_Mantissa,x
.019e7e	95 86		sta $86,x			sta 	XS2_Mantissa,x
.019e80	e8		inx				inx
.019e81	88		dey				dey
.019e82	d0 f8		bne $019e7c			bne 	_FPUCopy1
.019e84	fa		plx				plx
.019e85	60		rts				rts
.019e86					FPUCopyFromNext:
.019e86	a0 06		ldy #$06			ldy 		#6
.019e88	da		phx				phx
.019e89					_FPUCopy1:
.019e89	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.019e8b	95 80		sta $80,x			sta 	XS_Mantissa,x
.019e8d	e8		inx				inx
.019e8e	88		dey				dey
.019e8f	d0 f8		bne $019e89			bne 	_FPUCopy1
.019e91	fa		plx				plx
.019e92	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019e93					FPToString:
.019e93	48		pha				pha
.019e94	5a		phy				phy
.019e95	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.019e97	50 0a		bvc $019ea3			bvc 		_FPTSIsFloat 			; if zero,
.019e99					_FPTSZero:
.019e99	a9 30		lda #$30			lda 		#"0"
.019e9b	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter
.019e9e					_FPTSExit:
.019e9e	7a		ply				ply
.019e9f	68		pla				pla
.019ea0	60		rts				rts
.019ea1	80 fb		bra $019e9e			bra 		_FPTSExit
.019ea3					_FPTSIsFloat:
.019ea3	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.019ea5	10 09		bpl $019eb0			bpl 		_FPTSNotSigned
.019ea7	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019ea9	95 85		sta $85,x			sta 		XS_Type,x
.019eab	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019ead	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter
.019eb0					_FPTSNotSigned:
.019eb0	b5 84		lda $84,x			lda 		XS_Exponent,x
.019eb2	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019eb4	b0 09		bcs $019ebf			bcs 		_FPTSExponent
.019eb6	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019eb8	90 05		bcc $019ebf			bcc 		_FPTSExponent 			;
.019eba					_FPTSStandard:
.019eba	20 fe 9e	jsr $019efe			jsr 		FPTOutputBody 			; output the body.
.019ebd	80 df		bra $019e9e			bra 		_FPTSExit
.019ebf					_FPTSExponent:
.019ebf	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019ec1	8d 9d 03	sta $039d			sta 		ExpCount
.019ec4					_FPTSExponentLoop:
.019ec4	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019ec6	10 0e		bpl $019ed6			bpl 		_FPTSTimes
.019ec8	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019eca	90 14		bcc $019ee0			bcc 		_FPTSScaledToExp
.019ecc	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019ece	20 3b 9e	jsr $019e3b			jsr 		FPUScale10A
.019ed1	ee 9d 03	inc $039d			inc 		ExpCount
.019ed4	80 ee		bra $019ec4			bra 		_FPTSExponentLoop
.019ed6					_FPTSTimes:
.019ed6	a9 01		lda #$01			lda 		#1
.019ed8	20 3b 9e	jsr $019e3b			jsr 		FPUScale10A
.019edb	ce 9d 03	dec $039d			dec 		ExpCount
.019ede	80 e4		bra $019ec4			bra 		_FPTSExponentLoop
.019ee0					_FPTSScaledToExp:
.019ee0	20 fe 9e	jsr $019efe			jsr 		FPTOutputBody 			; output the body.
.019ee3	a9 65		lda #$65			lda 		#"e"					; output E
.019ee5	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter
.019ee8	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.019eeb	95 80		sta $80,x			sta 		XS_Mantissa,x
.019eed	29 80		and #$80			and 		#$80 					; sign extend it
.019eef	f0 02		beq $019ef3			beq 		_FPTSSExt
.019ef1	a9 ff		lda #$ff			lda 		#$FF
.019ef3					_FPTSSExt:
.019ef3	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.019ef5	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.019ef7	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.019ef9	20 58 99	jsr $019958			jsr 		INTToString 			; output the exponent.
.019efc	80 a0		bra $019e9e			bra			_FPTSExit 				; and exit.
.019efe					FPTOutputBody:
.019efe	20 79 9e	jsr $019e79			jsr 		FPUCopyToNext 			; copy to next slot.
.019f01	20 94 9d	jsr $019d94			jsr 		FPUToInteger 			; convert to an integer
.019f04	20 58 99	jsr $019958			jsr 		INTToString 			; output the main integer part.
.019f07	20 86 9e	jsr $019e86			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019f0a	20 54 9c	jsr $019c54			jsr 		FPFractionalPart 		; get the decimal part.
.019f0d	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.019f0f	70 3c		bvs $019f4d			bvs 		_FPTOExit 				; if not, exit now.
.019f11	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019f13	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter
.019f16					_FPOutLoop:
.019f16	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.019f18	70 1d		bvs $019f37			bvs 		_FPStripZeros 			; strip trailing zeros
.019f1a	20 ed 9d	jsr $019ded			jsr 		FPUTimes10 				; multiply by 10
.019f1d	20 79 9e	jsr $019e79			jsr 		FPUCopyToNext			; copy to next slot.
.019f20	20 94 9d	jsr $019d94			jsr 		FPUToInteger 			; convert to integer
.019f23	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.019f25	09 30		ora #$30			ora 		#"0"
.019f27	20 fa 99	jsr $0199fa			jsr 		ITSOutputCharacter
.019f2a	20 86 9e	jsr $019e86			jsr 		FPUCopyFromNext 		; get it back
.019f2d	20 54 9c	jsr $019c54			jsr 		FPFractionalPart 		; get fractional part
.019f30	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.019f33	c9 0b		cmp #$0b			cmp 	 	#11
.019f35	90 df		bcc $019f16			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019f37					_FPStripZeros:
.019f37	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.019f3a					_FPStripLoop:
.019f3a	88		dey				dey 								; back one, if at start then no strip
.019f3b	f0 10		beq $019f4d			beq 		_FPToExit
.019f3d	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.019f40	c9 30		cmp #$30			cmp 		#"0"
.019f42	f0 f6		beq $019f3a			beq 		_FPStripLoop
.019f44	c8		iny				iny
.019f45	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019f47	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.019f4a	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.019f4d					_FPTOExit:
.019f4d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019f4e					FPFromString:
.019f4e	48		pha				pha 								; push A
.019f4f	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019f51	c9 2e		cmp #$2e			cmp 	#"."
.019f53	f0 03		beq $019f58			beq	 	_FPFIsDecimal
.019f55	4c b4 9f	jmp $019fb4			jmp 	_FPFNotDecimal
.019f58					_FPFIsDecimal:
.019f58	c8		iny				iny 								; consume the decimal.
.019f59	20 48 9d	jsr $019d48			jsr 	FPUToFloat 					; convert the integer to float.
.019f5c	da		phx				phx 								; save X.
.019f5d	5a		phy				phy 								; save decimal start position
.019f5e	e8		inx				inx
.019f5f	e8		inx				inx
.019f60	e8		inx				inx
.019f61	e8		inx				inx
.019f62	e8		inx				inx
.019f63	e8		inx				inx
.019f64	20 12 9a	jsr $019a12			jsr 	INTFromStringY 				; get the part after the DP.
.019f67	20 48 9d	jsr $019d48			jsr 	FPUToFloat 					; convert that to a float.
.019f6a	68		pla				pla 								; calculate - chars consumed.
.019f6b	8c 9c 03	sty $039c			sty 	ExpTemp
.019f6e	38		sec				sec
.019f6f	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.019f72	20 3b 9e	jsr $019e3b			jsr 	FPUScale10A 				; scale it by 10^AC
.019f75	fa		plx				plx 								; restore original X
.019f76	20 a5 9a	jsr $019aa5			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019f79	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019f7b	c9 45		cmp #$45			cmp 	#"E"
.019f7d	f0 04		beq $019f83			beq 	_FPFExponent
.019f7f	c9 65		cmp #$65			cmp 	#"e"
.019f81	d0 31		bne $019fb4			bne 	_FPFNotDecimal 				; no, then exit normally.
.019f83					_FPFExponent:
.019f83	c8		iny				iny 								; skip over E symbol.
.019f84	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019f86	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019f88	d0 01		bne $019f8b			bne 	_FPFGotSign
.019f8a	c8		iny				iny 								; if it was - skip over it.
.019f8b					_FPFGotSign:
.019f8b	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019f8c	da		phx				phx
.019f8d	e8		inx				inx
.019f8e	e8		inx				inx
.019f8f	e8		inx				inx
.019f90	e8		inx				inx
.019f91	e8		inx				inx
.019f92	e8		inx				inx
.019f93	20 12 9a	jsr $019a12			jsr 	INTFromStringY 				; get the exponent
.019f96	fa		plx				plx 								; restore X.
.019f97	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019f99	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019f9b	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019f9d	d0 17		bne $019fb6			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019f9f	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019fa1	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019fa3	b0 11		bcs $019fb6			bcs 	_FPFXOverflow
.019fa5	68		pla				pla 								; get direction
.019fa6	d0 07		bne $019faf			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019fa8	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019faa	49 ff		eor #$ff			eor 	#$FF
.019fac	1a		inc a				inc 	a
.019fad	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.019faf					_FPFXScale:
.019faf	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019fb1	20 3b 9e	jsr $019e3b			jsr 	FPUScale10A 				; scale by the exponent.
.019fb4					_FPFNotDecimal:
.019fb4	68		pla				pla
.019fb5	60		rts				rts
.019fb6					_FPFXOverflow:
.019fb6	20 ca 84	jsr $0184ca			jsr 	ERR_Handler
>019fb9	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019fc1	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019fc8					Unary_Rnd:
.019fc8	20 a1 8d	jsr $018da1			jsr 	EvaluateNumberX 			; get value
.019fcb	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; check right bracket.
.019fce	20 1f 90	jsr $01901f			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019fd1	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019fd3	30 10		bmi $019fe5			bmi 	_URSetSeed
.019fd5	f0 28		beq $019fff			beq 	_URMakeRandom 				; if zero return same number.
.019fd7	da		phx				phx
.019fd8	a2 00		ldx #$00			ldx 	#0
.019fda	20 36 a0	jsr $01a036			jsr 	Random16
.019fdd	a2 02		ldx #$02			ldx 	#2
.019fdf	20 36 a0	jsr $01a036			jsr 	Random16
.019fe2	fa		plx				plx
.019fe3	80 1a		bra $019fff			bra 	_URMakeRandom
.019fe5					_URSetSeed:
.019fe5	20 48 9d	jsr $019d48			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019fe8	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019fea	8d a3 03	sta $03a3			sta 	RandomSeed+0
.019fed	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019fef	8d a4 03	sta $03a4			sta 	RandomSeed+1
.019ff2	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019ff4	8d a5 03	sta $03a5			sta 	RandomSeed+2
.019ff7	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019ff9	0a		asl a				asl 	a
.019ffa	49 db		eor #$db			eor 	#$DB
.019ffc	8d a6 03	sta $03a6			sta 	RandomSeed+3
.019fff					_URMakeRandom:
.019fff	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a002	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a005	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a008	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a00b	d0 0a		bne $01a017			bne 	_URNotZero
.01a00d	a9 47		lda #$47			lda 	#$47
.01a00f	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a012	a9 3d		lda #$3d			lda 	#$3D
.01a014	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a017					_URNotZero:
.01a017	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a01a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a01c	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a01f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a021	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a024	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a026	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a029	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a02b	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a02d	95 85		sta $85,x			sta 	XS_Type,x
.01a02f	a9 80		lda #$80			lda 	#$80
.01a031	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a033	4c 75 9d	jmp $019d75			jmp 	FPUNormalise
.01a036					Random16:
.01a036	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a039	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a03c	90 08		bcc $01a046			bcc 	_R16_NoXor
.01a03e	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a041	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a043	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a046					_R16_NoXor:
.01a046	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a047					Unary_Int:
.01a047	20 a1 8d	jsr $018da1			jsr 	EvaluateNumberX 			; get value
.01a04a	20 d5 93	jsr $0193d5			jsr 	CheckNextRParen 			; check right bracket.
.01a04d	4c 94 9d	jmp $019d94			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a050	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
