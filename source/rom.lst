
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 22 09:00:35 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042a					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>042c					Tim_SR:		.byte ? 						; Processor Status
>042d					Tim_A:		.byte ? 						; Processor Registers
>042e					Tim_X:		.byte ?
>042f					Tim_Y:		.byte ?
>0430					Tim_Z:		.byte ?
>0431					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	20 0a 00 d7 fe 08 48 65			.byte	$20,$0a,$00,$d7,$fe,$08,$48,$65
>1008	6c 6c 6f 2c 8a fe 07 77			.byte	$6c,$6c,$6f,$2c,$8a,$fe,$07,$77
>1010	6f 72 6c 64 8a fe 03 21			.byte	$6f,$72,$6c,$64,$8a,$fe,$03,$21
>1018	bc ff 06 68 69 20 21 00			.byte	$bc,$ff,$06,$68,$69,$20,$21,$00
>1020	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../common/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b2					lastUnaryFunction = $b2
.c000					VectorTable:
>c000	d3 c5					.word BinaryOp_And         ; $80 and
>c002	fb c5					.word BinaryOp_Or          ; $81 or
>c004	23 c6					.word BinaryOp_Xor         ; $82 xor
>c006	23 c6					.word BinaryOp_Eor         ; $83 eor
>c008	ae c0					.word NotImplemented       ; $84 =
>c00a	ae c0					.word NotImplemented       ; $85 <>
>c00c	ae c0					.word NotImplemented       ; $86 <
>c00e	ae c0					.word NotImplemented       ; $87 <=
>c010	ae c0					.word NotImplemented       ; $88 >
>c012	ae c0					.word NotImplemented       ; $89 >=
>c014	7c c6					.word BinaryOp_Add         ; $8a +
>c016	9c c6					.word BinaryOp_Subtract    ; $8b -
>c018	af c6					.word BinaryOp_Multiply    ; $8c *
>c01a	c2 c6					.word BinaryOp_Divide      ; $8d /
>c01c	ae c0					.word NotImplemented       ; $8e ^
>c01e	ae c0					.word NotImplemented       ; $8f if
>c020	ae c0					.word NotImplemented       ; $90 while
>c022	ae c0					.word NotImplemented       ; $91 repeat
>c024	ae c0					.word NotImplemented       ; $92 for
>c026	ae c0					.word NotImplemented       ; $93 then
>c028	ae c0					.word NotImplemented       ; $94 endif
>c02a	ae c0					.word NotImplemented       ; $95 wend
>c02c	ae c0					.word NotImplemented       ; $96 until
>c02e	ae c0					.word NotImplemented       ; $97 next
>c030	ae c0					.word NotImplemented       ; $98 not
>c032	ae c0					.word NotImplemented       ; $99 fn(
>c034	ae c0					.word NotImplemented       ; $9a abs(
>c036	ae c0					.word NotImplemented       ; $9b asc(
>c038	ae c0					.word NotImplemented       ; $9c int(
>c03a	ae c0					.word NotImplemented       ; $9d peek(
>c03c	ae c0					.word NotImplemented       ; $9e rnd(
>c03e	ae c0					.word NotImplemented       ; $9f usr(
>c040	ae c0					.word NotImplemented       ; $a0 left$(
>c042	ae c0					.word NotImplemented       ; $a1 right$(
>c044	ae c0					.word NotImplemented       ; $a2 mid$(
>c046	ae c0					.word NotImplemented       ; $a3 spc(
>c048	ae c0					.word NotImplemented       ; $a4 str$(
>c04a	ae c0					.word NotImplemented       ; $a5 val(
>c04c	ae c0					.word NotImplemented       ; $a6 len(
>c04e	ae c0					.word NotImplemented       ; $a7 hex$(
>c050	ae c0					.word NotImplemented       ; $a8 sin(
>c052	ae c0					.word NotImplemented       ; $a9 cos(
>c054	ae c0					.word NotImplemented       ; $aa tan(
>c056	ae c0					.word NotImplemented       ; $ab atn(
>c058	ae c0					.word NotImplemented       ; $ac exp(
>c05a	ae c0					.word NotImplemented       ; $ad log(
>c05c	ae c0					.word NotImplemented       ; $ae sqr(
>c05e	ae c0					.word NotImplemented       ; $af dec(
>c060	ae c0					.word NotImplemented       ; $b0 deek(
>c062	ae c0					.word NotImplemented       ; $b1 leek(
>c064	ae c0					.word NotImplemented       ; $b2 mod(
>c066	ae c0					.word NotImplemented       ; $b3 $(
>c068	ae c0					.word NotImplemented       ; $b4 $
>c06a	ae c0					.word NotImplemented       ; $b5 #(
>c06c	ae c0					.word NotImplemented       ; $b6 #
>c06e	ae c0					.word NotImplemented       ; $b7 %(
>c070	ae c0					.word NotImplemented       ; $b8 %
>c072	ae c0					.word NotImplemented       ; $b9 (
>c074	ae c0					.word NotImplemented       ; $ba )
>c076	ae c0					.word NotImplemented       ; $bb ,
>c078	ae c0					.word NotImplemented       ; $bc :
>c07a	ae c0					.word NotImplemented       ; $bd ;
>c07c	ae c0					.word NotImplemented       ; $be def
>c07e	18 c4					.word CLR_Command          ; $bf clr
>c080	ae c0					.word NotImplemented       ; $c1 data
>c082	ae c0					.word NotImplemented       ; $c2 read
>c084	ae c0					.word NotImplemented       ; $c3 dim
>c086	ae c0					.word NotImplemented       ; $c4 to
>c088	ae c0					.word NotImplemented       ; $c5 step
>c08a	ae c0					.word NotImplemented       ; $c6 gosub
>c08c	ae c0					.word NotImplemented       ; $c7 return
>c08e	ae c0					.word NotImplemented       ; $c8 goto
>c090	ae c0					.word NotImplemented       ; $c9 input
>c092	ae c0					.word NotImplemented       ; $ca let
>c094	ae c0					.word NotImplemented       ; $cb list
>c096	ae c0					.word NotImplemented       ; $cc new
>c098	ae c0					.word NotImplemented       ; $cd old
>c09a	ae c0					.word NotImplemented       ; $ce on
>c09c	ae c0					.word NotImplemented       ; $cf restore
>c09e	ae c0					.word NotImplemented       ; $d0 poke
>c0a0	ae c0					.word NotImplemented       ; $d1 print
>c0a2	ae c0					.word NotImplemented       ; $d2 run
>c0a4	ae c0					.word NotImplemented       ; $d3 stop
>c0a6	ae c0					.word NotImplemented       ; $d4 wait
>c0a8	ae c0					.word NotImplemented       ; $d5 doke
>c0aa	ae c0					.word NotImplemented       ; $d6 loke
>c0ac	ae c0					.word NotImplemented       ; $d7 assert
.c0ae					NotImplemented:
.c0ae	80 fe		bra $c0ae		_error: bra _error
>c0b0	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>c0b8	72 72 6f 72 00
.c0bd					BinaryPrecedence:
>c0bd	01					.byte 1    ; $80 and
>c0be	01					.byte 1    ; $81 or
>c0bf	01					.byte 1    ; $82 xor
>c0c0	01					.byte 1    ; $83 eor
>c0c1	02					.byte 2    ; $84 =
>c0c2	02					.byte 2    ; $85 <>
>c0c3	02					.byte 2    ; $86 <
>c0c4	02					.byte 2    ; $87 <=
>c0c5	02					.byte 2    ; $88 >
>c0c6	02					.byte 2    ; $89 >=
>c0c7	03					.byte 3    ; $8a +
>c0c8	03					.byte 3    ; $8b -
>c0c9	04					.byte 4    ; $8c *
>c0ca	04					.byte 4    ; $8d /
>c0cb	05					.byte 5    ; $8e ^
.c0cc					KeywordText:
>c0cc	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0cf	4f d2					.byte $4f,$d2                          ; $81 or
>c0d1	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0d4	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0d7	bd					.byte $bd                              ; $84 =
>c0d8	3c be					.byte $3c,$be                          ; $85 <>
>c0da	bc					.byte $bc                              ; $86 <
>c0db	3c bd					.byte $3c,$bd                          ; $87 <=
>c0dd	be					.byte $be                              ; $88 >
>c0de	3e bd					.byte $3e,$bd                          ; $89 >=
>c0e0	ab					.byte $ab                              ; $8a +
>c0e1	ad					.byte $ad                              ; $8b -
>c0e2	aa					.byte $aa                              ; $8c *
>c0e3	af					.byte $af                              ; $8d /
>c0e4	de					.byte $de                              ; $8e ^
>c0e5	49 c6					.byte $49,$c6                          ; $8f if
>c0e7	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0ec	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0f2	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0f5	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0f9	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0fe	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c102	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c107	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c10b	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c10e	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c111	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c115	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c119	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c11d	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c122	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c126	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c12a	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c130	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c137	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c13c	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c140	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c145	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c149	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c14d	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c152	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c156	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c15a	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c15e	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c162	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c166	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c16a	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c16e	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c172	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c177	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c17c	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c180	24 a8					.byte $24,$a8                          ; $b3 $(
>c182	a4					.byte $a4                              ; $b4 $
>c183	23 a8					.byte $23,$a8                          ; $b5 #(
>c185	a3					.byte $a3                              ; $b6 #
>c186	25 a8					.byte $25,$a8                          ; $b7 %(
>c188	a5					.byte $a5                              ; $b8 %
>c189	a8					.byte $a8                              ; $b9 (
>c18a	a9					.byte $a9                              ; $ba )
>c18b	ac					.byte $ac                              ; $bb ,
>c18c	ba					.byte $ba                              ; $bc :
>c18d	bb					.byte $bb                              ; $bd ;
>c18e	44 45 c6				.byte $44,$45,$c6                      ; $be def
>c191	43 4c d2				.byte $43,$4c,$d2                      ; $bf clr
>c194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c1 data
>c198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c2 read
>c19c	44 49 cd				.byte $44,$49,$cd                      ; $c3 dim
>c19f	54 cf					.byte $54,$cf                          ; $c4 to
>c1a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c5 step
>c1a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c6 gosub
>c1aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c7 return
>c1b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c8 goto
>c1b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c9 input
>c1b9	4c 45 d4				.byte $4c,$45,$d4                      ; $ca let
>c1bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cb list
>c1c0	4e 45 d7				.byte $4e,$45,$d7                      ; $cc new
>c1c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cd old
>c1c6	4f ce					.byte $4f,$ce                          ; $ce on
>c1c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $cf restore
>c1cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d0 poke
>c1d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d1 print
>c1d8	52 55 ce				.byte $52,$55,$ce                      ; $d2 run
>c1db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d3 stop
>c1df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d4 wait
>c1e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d5 doke
>c1e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d6 loke
>c1eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d7 assert
>c1f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_dollarlparen = $b3
=$b4					token_dollar = $b4
=$b5					token_hashlparen = $b5
=$b6					token_hash = $b6
=$b7					token_percentlparen = $b7
=$b8					token_percent = $b8
=$b9					token_lparen = $b9
=$ba					token_rparen = $ba
=$bb					token_comma = $bb
=$bc					token_colon = $bc
=$bd					token_semicolon = $bd
=$be					token_def = $be
=$bf					token_clr = $bf
=$c1					token_data = $c1
=$c2					token_read = $c2
=$c3					token_dim = $c3
=$c4					token_to = $c4
=$c5					token_step = $c5
=$c6					token_gosub = $c6
=$c7					token_return = $c7
=$c8					token_goto = $c8
=$c9					token_input = $c9
=$ca					token_let = $ca
=$cb					token_list = $cb
=$cc					token_new = $cc
=$cd					token_old = $cd
=$ce					token_on = $ce
=$cf					token_restore = $cf
=$d0					token_poke = $d0
=$d1					token_print = $d1
=$d2					token_run = $d2
=$d3					token_stop = $d3
=$d4					token_wait = $d4
=$d5					token_doke = $d5
=$d6					token_loke = $d6
=$d7					token_assert = $d7

;******  Return to file: modules/hardware/em65816.asm

.c1f2					StartROM:
.c1f2	18		clc				clc
.c1f3	fb		xce				xce
.c1f4	c2 30		rep #$30			rep 	#$30
.c1f6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f9	1b		tcs				tcs
.c1fa	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1fc	c2 30		rep #$30			rep 	#$30
.c1fe	a9 00 00	lda #$0000			lda 	#$0000
.c201	aa		tax				tax
.c202	a8		tay				tay
.c203	e2 30		sep #$30			sep 	#$30
.c205	20 a9 c3	jsr $c3a9			jsr 	IF_Reset 					; reset external interface
.c208	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen
.c20b	4c f8 c3	jmp $c3f8		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c20e					IFT_ClearScreen:
.c20e	48		pha				pha
.c20f	da		phx				phx
.c210	5a		phy				phy
.c211	20 aa c3	jsr $c3aa			jsr 	IF_Home 					; home cursor
.c214	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c216					_IFT_CS0:
.c216	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c218					_IFT_CS1:
.c218	a9 20		lda #$20			lda 	#' '						; clear line.
.c21a	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c21d	88		dey				dey
.c21e	d0 f8		bne $c218			bne 	_IFT_CS1
.c220	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; next line down
.c223	ca		dex				dex
.c224	d0 f0		bne $c216			bne 	_IFT_CS0
.c226	7a		ply				ply
.c227	fa		plx				plx
.c228	68		pla				pla
.c229					IFT_HomeCursor:
.c229	48		pha				pha
.c22a	20 aa c3	jsr $c3aa			jsr 	IF_Home
.c22d	a9 00		lda #$00			lda 	#0
.c22f	8d 00 02	sta $0200			sta 	IFT_XCursor
.c232	8d 01 02	sta $0201			sta 	IFT_YCursor
.c235	68		pla				pla
.c236	60		rts				rts
.c237					IFT_UpLine:
.c237	48		pha				pha
.c238	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c23b	3a		dec a				dec 	a 							; line above
.c23c	30 03		bmi $c241			bmi 	_IFTULExit 					; too far, abort
.c23e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos					; set to that line.
.c241					_IFTULExit:
.c241	68		pla				pla
.c242	60		rts				rts
.c243					IFT_PrintCharacter:
.c243	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c245	f0 16		beq $c25d			beq 	IFT_NewLine
.c247	48		pha				pha
.c248	20 75 c2	jsr $c275			jsr 	IFT_UpperCase 				; make upper case
.c24b	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write out.
.c24e	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c251	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c254	c9 40		cmp #$40			cmp 	#IF_Width
.c256	d0 03		bne $c25b			bne 	_IFT_PCNotEOL
.c258	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; if so do new line.
.c25b					_IFT_PCNotEOL:
.c25b	68		pla				pla
.c25c	60		rts				rts
.c25d					IFT_NewLine:
.c25d	48		pha				pha
.c25e	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; new line on actual screen.
.c261	a9 00		lda #$00			lda 	#0 							; reset x position
.c263	8d 00 02	sta $0200			sta 	IFT_XCursor
.c266	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c269	ad 01 02	lda $0201			lda 	IFT_YCursor
.c26c	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c26e	d0 03		bne $c273			bne 	_IFT_NL_NotEOS
.c270	20 80 c2	jsr $c280			jsr 	IFT_Scroll 					; scroll screen up.
.c273					_IFT_NL_NotEOS:
.c273	68		pla				pla
.c274	60		rts				rts
.c275					IFT_UpperCase:
.c275	c9 61		cmp #$61			cmp 	#"a"
.c277	90 06		bcc $c27f			bcc 	_IFT_UCExit
.c279	c9 7b		cmp #$7b			cmp 	#"z"+1
.c27b	b0 02		bcs $c27f			bcs 	_IFT_UCExit
.c27d	49 20		eor #$20			eor 	#$20
.c27f					_IFT_UCExit:
.c27f	60		rts				rts
.c280					IFT_Scroll:
.c280	48		pha				pha 								; save AXY
.c281	da		phx				phx
.c282	5a		phy				phy
.c283	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c285					_IFT_SLoop:
.c285	20 a5 c2	jsr $c2a5			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c288	e8		inx				inx
.c289	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c28b	d0 f8		bne $c285			bne 	_IFT_SLoop
.c28d	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c28f	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c292	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c294					_IFT_SBlank:
.c294	a9 20		lda #$20			lda 	#32
.c296	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c299	ca		dex				dex
.c29a	d0 f8		bne $c294			bne 	_IFT_SBlank
.c29c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c29e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2a1	7a		ply				ply
.c2a2	fa		plx				plx
.c2a3	68		pla				pla
.c2a4	60		rts				rts
.c2a5					_IFT_ScrollLine:
.c2a5	da		phx				phx
.c2a6	da		phx				phx
.c2a7	8a		txa				txa 								; copy line into buffer.
.c2a8	1a		inc a				inc 	a 							; next line down.
.c2a9	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2ac	a2 00		ldx #$00			ldx 	#0
.c2ae					_IFTScrollCopy1:
.c2ae	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c2b1	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2b4	e8		inx				inx
.c2b5	e0 40		cpx #$40			cpx 	#IF_Width
.c2b7	d0 f5		bne $c2ae			bne 	_IFTScrollCopy1
.c2b9	68		pla				pla
.c2ba	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2bd	a2 00		ldx #$00			ldx 	#0
.c2bf					_IFTScrollCopy2:
.c2bf	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2c2	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c2c5	e8		inx				inx
.c2c6	e0 40		cpx #$40			cpx 	#IF_Width
.c2c8	d0 f5		bne $c2bf			bne 	_IFTScrollCopy2
.c2ca	fa		plx				plx
.c2cb	60		rts				rts
.c2cc					IFT_SetYPos:
.c2cc	48		pha				pha
.c2cd	da		phx				phx
.c2ce	aa		tax				tax
.c2cf	20 29 c2	jsr $c229			jsr 	IFT_HomeCursor
.c2d2	e0 00		cpx #$00			cpx 	#0
.c2d4	f0 09		beq $c2df			beq 	_IFT_MOAExit
.c2d6					_IFT_MOALoop:
.c2d6	20 bd c3	jsr $c3bd			jsr 	IF_NewLine
.c2d9	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2dc	ca		dex				dex
.c2dd	d0 f7		bne $c2d6			bne		_IFT_MOALoop
.c2df					_IFT_MOAExit:
.c2df	fa		plx				plx
.c2e0	68		pla				pla
.c2e1	60		rts				rts
.c2e2					IFT_GetKeyCursor:
.c2e2	20 ea c2	jsr $c2ea			jsr 	_IFT_FlipCursor 			; reverse current
.c2e5					_IFT_GKCWait:
.c2e5	20 e7 c3	jsr $c3e7			jsr 	IF_GetKey 					; get key
.c2e8	f0 fb		beq $c2e5			beq 	_IFT_GKCWait
.c2ea					_IFT_FlipCursor:
.c2ea	48		pha				pha 								; save
.c2eb	20 cd c3	jsr $c3cd			jsr 	IF_Read 					; read
.c2ee	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f1	49 80		eor #$80			eor 	#$80 						; reverse
.c2f3	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write
.c2f6	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f9	68		pla				pla
.c2fa	60		rts				rts
.c2fb					IFT_ReadLine:
.c2fb	48		pha				pha
.c2fc					_IFT_RLLoop:
.c2fc	20 e2 c2	jsr $c2e2			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2ff	c9 0d		cmp #$0d			cmp 	#13							; return
.c301	f0 7d		beq $c380			beq 	_IFT_RLExit
.c303	c9 20		cmp #$20			cmp 	#32 						; control character
.c305	90 05		bcc $c30c			bcc 	_IFT_Control
.c307	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.c30a	80 f0		bra $c2fc			bra 	_IFT_RLLoop
.c30c					_IFT_Control:
.c30c	c9 01		cmp #$01			cmp 	#"A"-64
.c30e	f0 26		beq $c336			beq 	_IFT_Left
.c310	c9 04		cmp #$04			cmp 	#"D"-64
.c312	f0 2e		beq $c342			beq 	_IFT_Right
.c314	c9 17		cmp #$17			cmp 	#"W"-64
.c316	f0 36		beq $c34e			beq 	_IFT_Up
.c318	c9 13		cmp #$13			cmp 	#"S"-64
.c31a	f0 3e		beq $c35a			beq 	_IFT_Down
.c31c	c9 08		cmp #$08			cmp 	#"H"-64
.c31e	f0 09		beq $c329			beq 	_IFT_Backspace
.c320	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c322	d0 d8		bne $c2fc			bne 	_IFT_RLLoop
.c324	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen				; clear CTL-Z
.c327	80 d3		bra $c2fc			bra 	_IFT_RLLoop
.c329					_IFT_Backspace:
.c329	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c32c	f0 ce		beq $c2fc			beq 	_IFT_RLLoop
.c32e	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c331	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c333	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c336					_IFT_Left:
.c336	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c339	10 29		bpl $c364			bpl 	_IFT_Reposition
.c33b	a9 3f		lda #$3f			lda 	#IF_Width-1
.c33d					_IFT_SetX:
.c33d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c340	80 22		bra $c364			bra 	_IFT_Reposition
.c342					_IFT_Right:
.c342	ee 00 02	inc $0200			inc 	IFT_XCursor
.c345	ad 00 02	lda $0200			lda 	IFT_XCursor
.c348	49 40		eor #$40			eor 	#IF_Width
.c34a	f0 f1		beq $c33d			beq 	_IFT_SetX
.c34c	80 16		bra $c364			bra 	_IFT_Reposition
.c34e					_IFT_Up:
.c34e	ce 01 02	dec $0201			dec 	IFT_YCursor
.c351	10 11		bpl $c364			bpl 	_IFT_Reposition
.c353	a9 1f		lda #$1f			lda 	#IF_Height-1
.c355					_IFT_SetY:
.c355	8d 01 02	sta $0201			sta 	IFT_YCursor
.c358	80 0a		bra $c364			bra 	_IFT_Reposition
.c35a					_IFT_Down:
.c35a	ee 01 02	inc $0201			inc 	IFT_YCursor
.c35d	ad 01 02	lda $0201			lda 	IFT_YCursor
.c360	49 20		eor #$20			eor 	#IF_Height
.c362	f0 f1		beq $c355			beq 	_IFT_SetY
.c364					_IFT_Reposition:
.c364	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c367	48		pha				pha
.c368	ad 01 02	lda $0201			lda 	IFT_YCursor
.c36b	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c36e	68		pla				pla
.c36f	aa		tax				tax
.c370	e0 00		cpx #$00			cpx 	#0
.c372	f0 88		beq $c2fc			beq 	_IFT_RLLoop
.c374					_IFT_MoveRight:
.c374	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c377	ee 00 02	inc $0200			inc 	IFT_XCursor
.c37a	ca		dex				dex
.c37b	d0 f7		bne $c374			bne 	_IFT_MoveRight
.c37d	4c fc c2	jmp $c2fc			jmp 	_IFT_RLLoop
.c380					_IFT_RLExit:
.c380	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c383	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c386	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c388					_IFT_RLRead:
.c388	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c38b	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c38e	e8		inx				inx
.c38f	e0 40		cpx #$40			cpx 	#IF_Width
.c391	d0 f5		bne $c388			bne 	_IFT_RLRead
.c393					_IFT_RL_Trim:
.c393	ca		dex				dex 	 							; previous char
.c394	30 07		bmi $c39d			bmi 	_IFT_Found 					; gone too far
.c396	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c399	c9 20		cmp #$20			cmp 	#" "
.c39b	f0 f6		beq $c393			beq 	_IFT_RL_Trim
.c39d					_IFT_Found:
.c39d	e8		inx				inx 								; forward to non-space
.c39e	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c3a0	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c3a3	68		pla				pla
.c3a4	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a6	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a9					IF_Reset:
.c3a9	60		rts				rts
.c3aa					IF_Home:
.c3aa	48		pha				pha
.c3ab	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3ad	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3af	85 04		sta $04				sta 	IF_Pos
.c3b1	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3b3	85 05		sta $05				sta 	IF_Pos+1
.c3b5	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b7	85 06		sta $06				sta 	IF_Pos+2
.c3b9	64 07		stz $07				stz 	IF_Pos+3
.c3bb	68		pla				pla
.c3bc	60		rts				rts
.c3bd					IF_NewLine:
.c3bd	48		pha				pha
.c3be	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3c0	18		clc				clc 								; down one line
.c3c1	a5 04		lda $04				lda 	IF_Pos
.c3c3	69 40		adc #$40			adc 	#64
.c3c5	85 04		sta $04				sta 	IF_Pos
.c3c7	90 02		bcc $c3cb			bcc 	_IF_NoCarry 				; carry through.
.c3c9	e6 05		inc $05				inc 	IF_Pos+1
.c3cb					_IF_NoCarry:
.c3cb	68		pla				pla
.c3cc	60		rts				rts
.c3cd					IF_Read:
.c3cd	5a		phy				phy 								; save current Y
.c3ce	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3d0	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3d2	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d4	7a		ply				ply									; restore Y
.c3d5	60		rts				rts
.c3d6					IF_Write:
.c3d6	5a		phy				phy 								; save current Y
.c3d7	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d9	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3db	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3dd	7a		ply				ply									; restore Y
.c3de	60		rts				rts
.c3df					IF_LeftOne:
.c3df	c6 08		dec $08				dec 	IF_XPos
.c3e1	60		rts				rts
.c3e2					IF_CheckBreak:
.c3e2	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e6	60		rts				rts
.c3e7					IF_GetKey:
.c3e7	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3eb	f0 08		beq $c3f5			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3ed	48		pha				pha 								; key pressed, clear queue.
.c3ee	a9 00		lda #$00			lda 	#0
.c3f0	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3f4	68		pla				pla
.c3f5					_IFGK_NoKey:
.c3f5	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f8					BASIC_Start:
.c3f8	20 18 c4	jsr $c418			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c3fb	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c3fd	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c3ff	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c401	85 16		sta $16				sta 	zCodePtr+0
.c403	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c405	85 17		sta $17				sta 	zCodePtr+1
.c407	a9 00		lda #$00			lda 	#0
.c409	85 18		sta $18				sta 	zCodePtr+2
.c40b	85 19		sta $19				sta 	zCodePtr+3
.c40d	a0 03		ldy #$03			ldy 	#3
.c40f	c8		iny				iny
.c410	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c412	20 26 c4	jsr $c426			jsr 	EvaluateExpression
>c415	02						.byte 	2
.c416					SyntaxError:
.c416					ERR_Handler:
.c416	80 fe		bra $c416			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c418					CLR_Command:
.c418					ResetRunStatus:
.c418	a9 00		lda #$00			lda 	#HighMemory & $FF
.c41a	8d 26 04	sta $0426			sta 	StringPtr
.c41d	a9 80		lda #$80			lda 	#HighMemory >> 8
.c41f	8d 27 04	sta $0427			sta 	StringPtr+1
.c422	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c423					EVESyntax:
.c423	4c 16 c4	jmp $c416			jmp 	SyntaxError
.c426					EvaluateExpression:
.c426	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c428					EvaluateExpressionX:
.c428	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c42a					EvaluateExpressionXA:
.c42a	48		pha				pha 								; save precedence on stack.
.c42b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c42d	f0 f4		beq $c423			beq 	EVESyntax 					; end of line, syntax error.
.c42f	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c431	b0 03		bcs $c436			bcs 	_EVNotVariable
.c433	4c 2a c5	jmp $c52a			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c436					_EVNotVariable:
.c436	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c438	90 e9		bcc $c423			bcc 	EVESyntax
.c43a	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c43c	b0 7b		bcs $c4b9			bcs 	_EVNotInteger
.c43e	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c440	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c443	a9 00		lda #$00			lda 	#0
.c445	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c448	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c44b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c44e	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c450	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c453					_EVCheckNextInteger:
.c453	c8		iny				iny
.c454	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c456	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c458	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c45a	b0 0d		bcs $c469			bcs 	_EVCheckDecimal
.c45c	48		pha				pha 								; save it.
.c45d	20 2e c5	jsr $c52e			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c460	68		pla				pla
.c461	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c464	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c467	80 ea		bra $c453			bra 	_EVCheckNextInteger
.c469					_EVCheckDecimal:
.c469	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c46d	d0 05		bne $c474			bne 	_EVGotAtom 					; no, get atom.
.c46f					_EVIsDecimal:
.c46f	20 5e c5	jsr $c55e			jsr 	EVGetDecimal 				; extend to the decimal part.
.c472	80 00		bra $c474			bra 	_EVGotAtom 					; and continue to got atom.
.c474					_EVGotAtom:
.c474	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c476	10 3f		bpl $c4b7			bpl 	_EVExitDrop 				; must be a token.
.c478	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c47a	b0 3b		bcs $c4b7			bcs 	_EVExitDrop
.c47c	68		pla				pla 								; get current precedence
.c47d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c47f	da		phx				phx 								; save X
.c480	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c482	aa		tax				tax 								; put in X
.c483	bd 3d c0	lda $c03d,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c486	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c488	fa		plx				plx 								; restore X
.c489	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c48b	90 2b		bcc $c4b8			bcc 	_EVExit 					; exit if too low.
.c48d	f0 29		beq $c4b8			beq 	_EVExit 					; exit if equals
.c48f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c491	48		pha				pha
.c492	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c494	48		pha				pha
.c495	c8		iny				iny
.c496	da		phx				phx 								; save current position
.c497	e8		inx				inx
.c498	e8		inx				inx
.c499	e8		inx				inx
.c49a	e8		inx				inx
.c49b	e8		inx				inx
.c49c	e8		inx				inx
.c49d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c49f	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA 		; do the RHS.
.c4a2	fa		plx				plx 								; restore X
.c4a3	68		pla				pla 								; get the binary operator in A.
.c4a4	da		phx				phx 								; save X again
.c4a5	0a		asl a				asl 	a 							; double, lose the MSB.
.c4a6	aa		tax				tax									; put in X
.c4a7	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c4aa	85 1e		sta $1e				sta 	zGenPtr
.c4ac	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c4af	85 1f		sta $1f				sta 	zGenPtr+1
.c4b1	fa		plx				plx 								; restore X
.c4b2	20 2b c5	jsr $c52b			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4b5	80 bd		bra $c474			bra 	_EVGotAtom 					; and loop back.
.c4b7					_EVExitDrop:
.c4b7	68		pla				pla
.c4b8					_EVExit:
.c4b8	60		rts				rts
.c4b9					_EVNotInteger:
.c4b9	c8		iny				iny
.c4ba	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4bc	d0 19		bne $c4d7			bne 	_EVNotMinus
.c4be	20 af c5	jsr $c5af			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4c1	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4c4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4c6	f0 05		beq $c4cd			beq 	_EVMinusFloat
.c4c8	20 03 c9	jsr $c903			jsr 	IntegerNegateAlways 		; negation
.c4cb	80 a7		bra $c474			bra 	_EVGotAtom 					; and go back.
.c4cd					_EVMinusFloat:
.c4cd	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4d0	49 80		eor #$80			eor 	#$80
.c4d2	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4d5	80 9d		bra $c474			bra 	_EVGotAtom
.c4d7					_EVNotMinus:
.c4d7	c9 b9		cmp #$b9			cmp 	#token_lparen 				; is it left parenthesis
.c4d9	d0 24		bne $c4ff			bne 	_EVNotParenthesis
.c4db	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4de	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e0	c8		iny				iny
.c4e1	c9 ba		cmp #$ba			cmp 	#token_rparen 				; okay if right bracket.
.c4e3	f0 8f		beq $c474			beq 	_EVGotAtom
.c4e5	80 fe		bra $c4e5		_error: bra _error
>c4e7	4d 69 73 73 69 6e 67 20				.text	"Missing closing bracket",0
>c4ef	63 6c 6f 73 69 6e 67 20 62 72 61 63 6b 65 74 00
.c4ff					_EVNotParenthesis:
.c4ff	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c501	d0 0c		bne $c50f			bne 	_EVNotNot
.c503	20 af c5	jsr $c5af			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c506	20 08 ce	jsr $ce08			jsr 	FPUToInteger 				; make it an integer - if possible.
.c509	20 8c c5	jsr $c58c			jsr 	NotInteger 					; do the not calculation
.c50c	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c50f					_EVNotNot:
.c50f	c9 fe		cmp #$fe			cmp 	#$FE
.c511	d0 15		bne $c528			bne 	_EVNotString
.c513	20 f2 c7	jsr $c7f2			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c516	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c518	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c51b	a5 21		lda $21				lda 	zTempStr+1
.c51d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c520	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c522	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c525	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c528					_EVNotString:
.c528	80 fe		bra $c528			bra 	_EVNotString
.c52a					_EVVariableHandler:
.c52a	ea		nop				nop
.c52b					EVGoZGenPtr:
.c52b	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c52e					EVShiftMantissaLeft6:
.c52e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c531	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c534	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c537	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c53a	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c53d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c540	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c543	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c546	a9 00		lda #$00			lda 	#0
.c548	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c54b	20 4e c5	jsr $c54e			jsr 	_EVSMLShift 					; call it here to do it twice
.c54e					_EVSMLShift:
.c54e	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c551	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c554	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c557	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c55a	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c55d	60		rts				rts
.c55e					EVGetDecimal:
.c55e	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c560	8d 00 04	sta $0400			sta 	Num_Buffer
.c563	da		phx				phx
.c564	c8		iny				iny
.c565	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c567	c8		iny				iny
.c568	3a		dec a				dec 	a								; convert to a string length.
.c569	3a		dec a				dec 	a
.c56a	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c56c					_EVGDCopy:
.c56c	48		pha				pha 									; save count
.c56d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c56f	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c572	e8		inx				inx 									; forward ....
.c573	c8		iny				iny
.c574	68		pla				pla 									; get count
.c575	3a		dec a				dec 	a 								; until zero
.c576	d0 f4		bne $c56c			bne 	_EVGDCopy
.c578	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c57b	fa		plx				plx 									; restore X
.c57c	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c57e	85 1e		sta $1e				sta 	zGenPtr
.c580	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c582	85 1f		sta $1f				sta 	zGenPtr+1
.c584	5a		phy				phy 									; save Y
.c585	a0 00		ldy #$00			ldy 	#0 								; start position
.c587	20 f9 cf	jsr $cff9			jsr 	FPFromString 					; convert current
.c58a	7a		ply				ply 									; restore Y
.c58b	60		rts				rts
.c58c					NotInteger:
.c58c	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c58f	49 ff		eor #$ff			eor 	#$FF
.c591	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c594	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c597	49 ff		eor #$ff			eor 	#$FF
.c599	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c59c	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c59f	49 ff		eor #$ff			eor 	#$FF
.c5a1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5a4	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c5a7	49 ff		eor #$ff			eor 	#$FF
.c5a9	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5ac	60		rts				rts
.c5ad					EvaluateGetAtom:
.c5ad	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c5af					EvaluateGetAtomX:
.c5af	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c5b1	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA
.c5b4	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c5b7	29 0f		and #$0f			and 	#15
.c5b9	c9 02		cmp #$02			cmp 	#2
.c5bb	b0 01		bcs $c5be			bcs 	EvaluateType
.c5bd	60		rts				rts
.c5be					EvaluateType:
.c5be	80 fe		bra $c5be		_error: bra _error
>c5c0	57 72 6f 6e 67 20 74 79				.text 	"Wrong type of data",0
>c5c8	70 65 20 6f 66 20 64 61 74 61 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5d3					BinaryOp_And:
.c5d3	20 4b c6	jsr $c64b			jsr 	BinaryMakeBothInteger
.c5d6	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5d9	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5dc	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5df	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5e2	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5e5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5e8	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5eb	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5ee	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5f1	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5f4	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c5f7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5fa	60		rts				rts
.c5fb					BinaryOp_Or:
.c5fb	20 4b c6	jsr $c64b			jsr 	BinaryMakeBothInteger
.c5fe	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c601	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c604	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c607	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c60a	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c60d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c610	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c613	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c616	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c619	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c61c	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c61f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c622	60		rts				rts
.c623					BinaryOp_Eor:
.c623					BinaryOp_Xor:
.c623	20 4b c6	jsr $c64b			jsr 	BinaryMakeBothInteger
.c626	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c629	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c62c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c62f	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c632	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c635	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c638	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c63b	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c63e	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c641	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c644	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c647	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c64a	60		rts				rts
.c64b					BinaryMakeBothInteger:
.c64b	da		phx				phx 								; save X
.c64c	e8		inx				inx
.c64d	e8		inx				inx
.c64e	e8		inx				inx
.c64f	e8		inx				inx
.c650	e8		inx				inx
.c651	e8		inx				inx
.c652	20 56 c6	jsr $c656			jsr 	BinaryMakeInteger 			; convert to integer.
.c655	fa		plx				plx 								; restore X and fall through.
.c656					BinaryMakeInteger:
.c656	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c659	29 0f		and #$0f			and 	#15 						; check type zero
.c65b	f0 04		beq $c661			beq 	_BMIConvert 				; if float convert to integer.
.c65d	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c65e	90 04		bcc $c664			bcc 	_BMIError
.c660	60		rts				rts
.c661					_BMIConvert:
.c661	4c 08 ce	jmp $ce08			jmp 	FPUToInteger 				; convert to integer
.c664					_BMIError:
.c664	80 fe		bra $c664		_error: bra _error
>c666	4e 75 6d 65 72 69 63 20				.text 	"Numeric type required",0
>c66e	74 79 70 65 20 72 65 71 75 69 72 65 64 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c67c					BinaryOp_Add:
.c67c	bd 05 03	lda $0305,x			lda 	XS_Type,x  					; and types together
.c67f	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c682	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c684	d0 13		bne $c699			bne 	_BOAString
.c686	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c689	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c68c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c68d	90 03		bcc $c692			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c68f	4c d5 c6	jmp $c6d5			jmp 	AddInteger32 							; so execute code at \1
.c692					_BCFloat:
.c692	20 21 c7	jsr $c721			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c695	4c 8c ca	jmp $ca8c			jmp 	FPAdd 							; and execute code at \2
.c698	60		rts				rts
.c699					_BOAString:
.c699	4c 51 c7	jmp $c751			jmp 	ConcatenateString 			; concatenate two strings.
.c69c					BinaryOp_Subtract:
.c69c	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c69f	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6a2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6a3	90 03		bcc $c6a8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6a5	4c fb c6	jmp $c6fb			jmp 	SubInteger32 							; so execute code at \1
.c6a8					_BCFloat:
.c6a8	20 21 c7	jsr $c721			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6ab	4c 82 ca	jmp $ca82			jmp 	FPSubtract 							; and execute code at \2
.c6ae	60		rts				rts
.c6af					BinaryOp_Multiply:
.c6af	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6b2	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6b5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6b6	90 03		bcc $c6bb			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6b8	4c 17 c8	jmp $c817			jmp 	MulInteger32 							; so execute code at \1
.c6bb					_BCFloat:
.c6bb	20 21 c7	jsr $c721			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6be	4c f7 cb	jmp $cbf7			jmp 	FPMultiply 							; and execute code at \2
.c6c1	60		rts				rts
.c6c2					BinaryOp_Divide:
.c6c2	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6c5	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6c8	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6c9	90 03		bcc $c6ce			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6cb	4c 6e c8	jmp $c86e			jmp 	DivInteger32 							; so execute code at \1
.c6ce					_BCFloat:
.c6ce	20 21 c7	jsr $c721			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6d1	4c 6f cb	jmp $cb6f			jmp 	FPDivide 							; and execute code at \2
.c6d4	60		rts				rts
.c6d5					AddInteger32:
.c6d5	18		clc				clc
.c6d6	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c6d9	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c6dc	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c6df	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6e2	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c6e5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c6e8	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c6eb	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c6ee	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c6f1	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c6f4	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c6f7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c6fa	60		rts				rts
.c6fb					SubInteger32:
.c6fb	38		sec				sec
.c6fc	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c6ff	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c702	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c705	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c708	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c70b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c70e	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c711	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c714	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c717	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c71a	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c71d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c720	60		rts				rts
.c721					BinaryMakeBothFloat:
.c721	da		phx				phx 								; save X
.c722	e8		inx				inx
.c723	e8		inx				inx
.c724	e8		inx				inx
.c725	e8		inx				inx
.c726	e8		inx				inx
.c727	e8		inx				inx
.c728	20 2c c7	jsr $c72c			jsr 	BinaryMakeFloat 			; convert to float.
.c72b	fa		plx				plx 								; restore X and fall through.
.c72c					BinaryMakeFloat:
.c72c	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c72f	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c730	b0 04		bcs $c736			bcs 	_BMFConvert
.c732	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c733	b0 04		bcs $c739			bcs 	_BMFError
.c735	60		rts				rts
.c736					_BMFConvert:
.c736	4c a9 cd	jmp $cda9			jmp 	FPUToFloat 					; convert to float
.c739					_BMFError:
.c739	80 fe		bra $c739		_error: bra _error
>c73b	4e 75 6d 65 72 69 63 20				.text 	"Numeric type required",0
>c743	74 79 70 65 20 72 65 71 75 69 72 65 64 00
.c751					ConcatenateString:
.c751	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c754	85 1a		sta $1a				sta		zLTemp1+0
.c756	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c759	85 1b		sta $1b				sta 	zLTemp1+1
.c75b	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c75e	85 1c		sta $1c				sta 	zLTemp1+2
.c760	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c763	85 1d		sta $1d				sta 	zLTemp1+3
.c765	5a		phy				phy
.c766	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c768	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c76a	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c76c	7a		ply				ply
.c76d	b0 37		bcs $c7a6			bcs 	_CSError					; check in range.
.c76f	c9 fe		cmp #$fe			cmp 	#maxString+1
.c771	b0 33		bcs $c7a6			bcs 	_CSError
.c773	20 b7 c7	jsr $c7b7			jsr 	AllocateTempString 			; store the result
.c776	20 91 c7	jsr $c791			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c779	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c77c	85 1a		sta $1a				sta 	zLTemp1
.c77e	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c781	85 1b		sta $1b				sta 	zLTemp1+1
.c783	20 91 c7	jsr $c791			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c786	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c788	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c78b	a5 21		lda $21				lda 	zTempStr+1
.c78d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c790	60		rts				rts
.c791					_CSCopyString:
.c791	da		phx				phx
.c792	5a		phy				phy
.c793	a0 00		ldy #$00			ldy 	#0 							; get length
.c795	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c797	f0 0a		beq $c7a3			beq 	_CSCSExit 					; if zero, exit
.c799	aa		tax				tax 								; put in X
.c79a					_CSCSLoop:
.c79a	c8		iny				iny 								; get next char
.c79b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c79d	20 e2 c7	jsr $c7e2			jsr		WriteTempString 			; copy out
.c7a0	ca		dex				dex 								; do whole string
.c7a1	d0 f7		bne $c79a			bne 	_CSCSLoop
.c7a3					_CSCSExit:
.c7a3	7a		ply				ply
.c7a4	fa		plx				plx
.c7a5	60		rts				rts
.c7a6					_CSError:
.c7a6	80 fe		bra $c7a6		_error: bra _error
>c7a8	53 74 72 69 6e 67 20 74				.text 	"String too long"
>c7b0	6f 6f 20 6c 6f 6e 67

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c7b7					AllocateTempString:
.c7b7	48		pha				pha 								; save required count.
.c7b8	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.c7ba	d0 0b		bne $c7c7			bne 	_ATSInitialised
.c7bc	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c7bf	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.c7c1	ad 27 04	lda $0427			lda 	StringPtr+1
.c7c4	3a		dec a				dec 	a
.c7c5	85 21		sta $21				sta 	zTempStr+1
.c7c7					_ATSInitialised:
.c7c7	68		pla				pla 								; get required count back.
.c7c8	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.c7ca	1a		inc a				inc 	a
.c7cb	18		clc				clc
.c7cc	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.c7ce	85 20		sta $20				sta 	zTempStr
.c7d0	a9 ff		lda #$ff			lda 	#$FF
.c7d2	65 21		adc $21				adc 	zTempStr+1
.c7d4	85 21		sta $21				sta 	zTempStr+1
.c7d6	a9 00		lda #$00			lda 	#0 							; clear temp string.
.c7d8	5a		phy				phy
.c7d9	a8		tay				tay
.c7da	91 20		sta ($20),y			sta 	(zTempStr),y
.c7dc	7a		ply				ply
.c7dd	1a		inc a				inc 	a 							; reset the write index.
.c7de	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.c7e1	60		rts				rts
.c7e2					WriteTempString:
.c7e2	5a		phy				phy 								; save Y
.c7e3	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.c7e6	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.c7e8	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.c7eb	98		tya				tya 								; unchanged Y is now length
.c7ec	a0 00		ldy #$00			ldy 	#0
.c7ee	91 20		sta ($20),y			sta 	(zTempStr),y
.c7f0	7a		ply				ply 								; restore Y and exit
.c7f1	60		rts				rts
.c7f2					CreateTempStringCopy:
.c7f2	da		phx				phx 								; save X
.c7f3	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c7f5	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c7f6	20 b7 c7	jsr $c7b7			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c7f9	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c7fb	c8		iny				iny
.c7fc	3a		dec a				dec 	a 							; make the actual length in charactes
.c7fd	3a		dec a				dec 	a
.c7fe	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c800	81 20		sta ($20,x)			sta 	(zTempStr,x)
.c802	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.c804	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c806	f0 0d		beq $c815			beq 	_CTSCExit
.c808					_CTSCLoop:
.c808	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c80a	c8		iny				iny
.c80b	5a		phy				phy 								; save in Y
.c80c	e8		inx				inx 								; bump index
.c80d	9b		txy				txy 								; index into Y
.c80e	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.c810	7a		ply				ply 								; restore Y
.c811	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.c813	d0 f3		bne $c808			bne 	_CTSCLoop
.c815					_CTSCExit:
.c815	fa		plx				plx 								; restore X
.c816	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c817					MulInteger32:
.c817	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c81a	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c81d	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c820	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c823	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c826	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c829	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c82c	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c82f	a9 00		lda #$00			lda 	#0
.c831	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c834	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c837	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c83a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c83d					_BFMMultiply:
.c83d	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c840	29 01		and #$01			and 	#1
.c842	f0 03		beq $c847			beq 	_BFMNoAdd
.c844	20 d5 c6	jsr $c6d5			jsr 	AddInteger32
.c847					_BFMNoAdd:
.c847	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c84a	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.c84d	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.c850	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.c853	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c856	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.c859	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.c85c	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.c85f	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c862	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.c865	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.c868	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.c86b	d0 d0		bne $c83d			bne 	_BFMMultiply
.c86d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c86e					DivInteger32:
.c86e	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c871	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c874	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c877	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c87a	d0 13		bne $c88f			bne 	_BFDOkay
.c87c	80 fe		bra $c87c		_error: bra _error
>c87e	44 69 76 69 73 69 6f 6e				.text "Division by Zero",0
>c886	20 62 79 20 5a 65 72 6f 00
.c88f					_BFDOkay:
.c88f	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c891	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c893	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c895	85 1c		sta $1c				sta 	zLTemp1+2
.c897	85 1d		sta $1d				sta 	zLTemp1+3
.c899	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.c89c	20 fd c8	jsr $c8fd			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c89f	da		phx				phx
.c8a0	e8		inx				inx
.c8a1	e8		inx				inx
.c8a2	e8		inx				inx
.c8a3	e8		inx				inx
.c8a4	e8		inx				inx
.c8a5	e8		inx				inx
.c8a6	20 fd c8	jsr $c8fd			jsr 	CheckIntegerNegate
.c8a9	fa		plx				plx
.c8aa	5a		phy				phy 								; Y is the counter
.c8ab	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c8ad					_BFDLoop:
.c8ad	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c8b0	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c8b3	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c8b6	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c8b9	26 1a		rol $1a				rol 	zLTemp1
.c8bb	26 1b		rol $1b				rol 	zLTemp1+1
.c8bd	26 1c		rol $1c				rol 	zLTemp1+2
.c8bf	26 1d		rol $1d				rol 	zLTemp1+3
.c8c1	38		sec				sec
.c8c2	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c8c4	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c8c7	48		pha				pha
.c8c8	a5 1b		lda $1b				lda 	zLTemp1+1
.c8ca	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c8cd	48		pha				pha
.c8ce	a5 1c		lda $1c				lda 	zLTemp1+2
.c8d0	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c8d3	48		pha				pha
.c8d4	a5 1d		lda $1d				lda 	zLTemp1+3
.c8d6	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c8d9	90 15		bcc $c8f0			bcc 	_BFDNoAdd
.c8db	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c8dd	68		pla				pla
.c8de	85 1c		sta $1c				sta 	zLTemp1+2
.c8e0	68		pla				pla
.c8e1	85 1b		sta $1b				sta 	zLTemp1+1
.c8e3	68		pla				pla
.c8e4	85 1a		sta $1a				sta 	zLTemp1+0
.c8e6	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c8e9	09 01		ora #$01			ora 	#1
.c8eb	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c8ee	80 03		bra $c8f3			bra 	_BFDNext
.c8f0					_BFDNoAdd:
.c8f0	68		pla				pla 								; Throw away the intermediate calculations
.c8f1	68		pla				pla
.c8f2	68		pla				pla
.c8f3					_BFDNext:
.c8f3	88		dey				dey
.c8f4	d0 b7		bne $c8ad			bne 	_BFDLoop
.c8f6	7a		ply				ply 								; restore Y and exit
.c8f7	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.c8fa	b0 07		bcs $c903			bcs		IntegerNegateAlways 			; negate the result
.c8fc	60		rts				rts
.c8fd					CheckIntegerNegate:
.c8fd	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c900	30 01		bmi $c903			bmi 	IntegerNegateAlways
.c902	60		rts				rts
.c903					IntegerNegateAlways:
.c903	ee 25 04	inc $0425			inc 	SignCount
.c906	38		sec				sec
.c907	a9 00		lda #$00			lda 	#0
.c909	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c90c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c90f	a9 00		lda #$00			lda 	#0
.c911	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c914	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c917	a9 00		lda #$00			lda 	#0
.c919	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c91c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c91f	a9 00		lda #$00			lda 	#0
.c921	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c924	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c927	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c928					INTToString:
.c928	48		pha				pha
.c929	5a		phy				phy
.c92a	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.c92d	10 08		bpl $c937			bpl 		_ITSNotMinus
.c92f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c931	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter
.c934	20 03 c9	jsr $c903			jsr 		IntegerNegateAlways 	; negate the number.
.c937					_ITSNotMinus:
.c937	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.c939	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.c93c	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.c93e					_ITSNextSubtractor:
.c93e	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c940	8d 22 04	sta $0422			sta 		NumConvCount
.c943					_ITSSubtract:
.c943	38		sec				sec
.c944	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.c947	f9 a0 c9	sbc $c9a0,y			sbc 		_ITSSubtractors+0,y
.c94a	48		pha				pha
.c94b	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.c94e	f9 a1 c9	sbc $c9a1,y			sbc 		_ITSSubtractors+1,y
.c951	48		pha				pha
.c952	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.c955	f9 a2 c9	sbc $c9a2,y			sbc 		_ITSSubtractors+2,y
.c958	48		pha				pha
.c959	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.c95c	f9 a3 c9	sbc $c9a3,y			sbc 		_ITSSubtractors+3,y
.c95f	90 14		bcc $c975			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c961	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.c964	68		pla				pla
.c965	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.c968	68		pla				pla
.c969	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.c96c	68		pla				pla
.c96d	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.c970	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.c973	80 ce		bra $c943			bra 		_ITSSubtract 			; go round again.
.c975					_ITSCantSubtract:
.c975	68		pla				pla 								; throw away interim answers
.c976	68		pla				pla
.c977	68		pla				pla
.c978	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.c97b	c9 30		cmp #$30			cmp 		#"0"
.c97d	d0 05		bne $c984			bne 		_ITSOutputDigit
.c97f	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c982	10 09		bpl $c98d			bpl 		_ITSGoNextSubtractor
.c984					_ITSOutputDigit:
.c984	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.c987	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.c98a	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter 		; output it.
.c98d					_ITSGoNextSubtractor:
.c98d	c8		iny				iny 								; next dword
.c98e	c8		iny				iny
.c98f	c8		iny				iny
.c990	c8		iny				iny
.c991	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.c993	d0 a9		bne $c93e			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c995	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c998	09 30		ora #$30			ora 		#"0"
.c99a	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter
.c99d	7a		ply				ply 								; and exit
.c99e	68		pla				pla
.c99f	60		rts				rts
.c9a0					_ITSSubtractors:
>c9a0	00 ca 9a 3b					.dword 		1000000000
>c9a4	00 e1 f5 05					.dword 		100000000
>c9a8	80 96 98 00					.dword 		10000000
>c9ac	40 42 0f 00					.dword 		1000000
>c9b0	a0 86 01 00					.dword 		100000
>c9b4	10 27 00 00					.dword 		10000
>c9b8	e8 03 00 00					.dword 		1000
>c9bc	64 00 00 00					.dword 		100
>c9c0	0a 00 00 00					.dword 		10
.c9c4					_ITSSubtractorsEnd:
.c9c4					ITSOutputCharacter:
.c9c4	48		pha				pha
.c9c5	da		phx				phx
.c9c6	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.c9c9	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c9cc	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c9ce	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.c9d1	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.c9d4	fa		plx				plx
.c9d5	68		pla				pla
.c9d6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c9d7					IntFromString:
.c9d7	a0 00		ldy #$00			ldy 	#0
.c9d9	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.c9dc					IntFromStringY:
.c9dc	48		pha				pha
.c9dd	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c9df	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c9e2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c9e5	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c9e8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c9eb	a9 01		lda #$01			lda 	#1
.c9ed	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9f0					_IFSLoop:
.c9f0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c9f2	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c9f4	90 60		bcc $ca56			bcc 	_IFSExit
.c9f6	c9 3a		cmp #$3a			cmp 	#"9"+1
.c9f8	b0 5c		bcs $ca56			bcs 	_IFSExit
.c9fa	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c9fd	c9 0c		cmp #$0c			cmp 	#12
.c9ff	b0 5f		bcs $ca60			bcs 	_IFSOverflow
.ca01	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.ca04	48		pha				pha
.ca05	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ca08	48		pha				pha
.ca09	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ca0c	48		pha				pha
.ca0d	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ca10	48		pha				pha
.ca11	20 75 ca	jsr $ca75			jsr 	IFSX1ShiftLeft 				; double
.ca14	20 75 ca	jsr $ca75			jsr 	IFSX1ShiftLeft 				; x 4
.ca17	18		clc				clc 								; add saved value x 5
.ca18	68		pla				pla
.ca19	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ca1c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca1f	68		pla				pla
.ca20	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.ca23	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca26	68		pla				pla
.ca27	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.ca2a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca2d	68		pla				pla
.ca2e	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.ca31	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca34	20 75 ca	jsr $ca75			jsr 	IFSX1ShiftLeft 				; x 10
.ca37	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.ca3a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.ca3c	29 0f		and #$0f			and 	#15
.ca3e	c8		iny				iny
.ca3f	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ca42	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca45	90 a9		bcc $c9f0			bcc 	_IFSLoop
.ca47	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.ca4a	d0 a4		bne $c9f0			bne 	_IFSLoop
.ca4c	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.ca4f	d0 9f		bne $c9f0			bne 	_IFSLoop
.ca51	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.ca54	80 9a		bra $c9f0			bra 	_IFSLoop
.ca56					_IFSExit:
.ca56	98		tya				tya 								; get offset
.ca57					_IFSOkay:
.ca57	38		sec				sec
.ca58	ad 23 04	lda $0423			lda 	ExpTemp
.ca5b	f0 01		beq $ca5e			beq 	_IFSSkipFail
.ca5d	18		clc				clc
.ca5e					_IFSSkipFail:
.ca5e	68		pla				pla 								; and exit.
.ca5f	60		rts				rts
.ca60					_IFSOverflow:
.ca60	20 16 c4	jsr $c416			jsr 	ERR_Handler
>ca63	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>ca6b	20 6f 76 65 72 66 6c 6f 77 00
.ca75					IFSX1ShiftLeft:
.ca75	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.ca78	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.ca7b	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.ca7e	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.ca81	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.ca82					FPSubtract:
.ca82	48		pha				pha
.ca83	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.ca86	49 80		eor #$80			eor 	#$80
.ca88	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.ca8b	68		pla				pla 								; --- and fall through ---
.ca8c					FPAdd:
.ca8c	48		pha				pha
.ca8d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.ca90	d0 05		bne $ca97			bne 	_FPA_NegativeLHS
.ca92	20 b4 ca	jsr $cab4			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.ca95	68		pla				pla
.ca96	60		rts				rts
.ca97					_FPA_NegativeLHS:
.ca97	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ca9a	49 80		eor #$80			eor 	#$80
.ca9c	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca9f	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.caa2	49 80		eor #$80			eor 	#$80
.caa4	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.caa7	20 b4 ca	jsr $cab4			jsr 	FPAdd_Worker 				; do the add calculation.
.caaa	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.caad	49 80		eor #$80			eor 	#$80
.caaf	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cab2	68		pla				pla
.cab3	60		rts				rts
.cab4					FPAdd_Worker:
.cab4	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cab7	70 08		bvs $cac1			bvs 	_FPAWExit 					; no change.
.cab9	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.cabc	50 07		bvc $cac5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.cabe	20 58 cd	jsr $cd58			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.cac1					_FPAWExit:
.cac1	20 e0 cd	jsr $cde0			jsr 	FPUNormalise 				; normalise the result.
.cac4	60		rts				rts
.cac5					_FPAWMakeSame:
.cac5	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.cac8	38		sec				sec
.cac9	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cacc	f0 1b		beq $cae9			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cace	da		phx				phx 								; save X
.cacf	90 06		bcc $cad7			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cad1	e8		inx				inx
.cad2	e8		inx				inx
.cad3	e8		inx				inx
.cad4	e8		inx				inx
.cad5	e8		inx				inx
.cad6	e8		inx				inx
.cad7					_FPAWShiftA:
.cad7	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cada	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cadd	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cae0	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cae3	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cae6	fa		plx				plx 								; restore original X
.cae7	80 dc		bra $cac5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cae9					_FPAW_DoArithmetic:
.cae9	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.caec	30 39		bmi $cb27			bmi 	_FPAW_BNegative
.caee	18		clc				clc
.caef	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.caf2	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.caf5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.caf8	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cafb	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cafe	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb01	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb04	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cb07	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb0a	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb0d	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cb10	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb13	90 ac		bcc $cac1			bcc 	_FPAWExit 					; no carry.
.cb15	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cb18	38		sec				sec
.cb19	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cb1c	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cb1f	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cb22	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cb25	80 9a		bra $cac1			bra 	_FPAWExit
.cb27					_FPAW_BNegative:
.cb27	38		sec				sec
.cb28	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cb2b	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.cb2e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb31	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cb34	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cb37	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb3a	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb3d	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cb40	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb43	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb46	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cb49	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb4c	b0 0b		bcs $cb59			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.cb4e	20 85 cd	jsr $cd85			jsr 	FPUNegateInteger			; negate the mantissa
.cb51	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.cb54	49 80		eor #$80			eor 	#$80
.cb56	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb59					_FPAWGoExit:
.cb59	4c c1 ca	jmp $cac1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cb5c					FPD_IsDivZero:
.cb5c	80 fe		bra $cb5c		_error: bra _error
>cb5e	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>cb66	20 62 79 20 7a 65 72 6f 00
.cb6f					FPDivide:
.cb6f	48		pha				pha
.cb70	5a		phy				phy
.cb71	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.cb74	70 e6		bvs $cb5c			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cb76	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cb79	f0 03		beq $cb7e			beq 	_FPDCalculateExp
.cb7b					_FPD_Exit:
.cb7b	7a		ply				ply
.cb7c	68		pla				pla
.cb7d	60		rts				rts
.cb7e					_FPDCalculateExp:
.cb7e	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cb81	49 ff		eor #$ff			eor 	#$FF
.cb83	1a		inc a				inc 	a
.cb84	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.cb87	20 7b cc	jsr $cc7b			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cb8a	18		clc				clc 	 							; add 1 to the resulting exponent
.cb8b	69 01		adc #$01			adc 	#1
.cb8d	b0 65		bcs $cbf4			bcs 	_FPD_Overflow 				; which can overflow.
.cb8f	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cb92	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cb94	85 1a		sta $1a				sta 	zLTemp1+0
.cb96	85 1b		sta $1b				sta 	zLTemp1+1
.cb98	85 1c		sta $1c				sta 	zLTemp1+2
.cb9a	85 1d		sta $1d				sta 	zLTemp1+3
.cb9c	a0 20		ldy #$20			ldy 	#32 						; times round.
.cb9e					_FPD_Loop:
.cb9e	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cb9f	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.cba2	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.cba5	48		pha				pha
.cba6	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cba9	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cbac	48		pha				pha
.cbad	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cbb0	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cbb3	48		pha				pha
.cbb4	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cbb7	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cbba	90 17		bcc $cbd3			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cbbc	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cbbf	68		pla				pla
.cbc0	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cbc3	68		pla				pla
.cbc4	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cbc7	68		pla				pla
.cbc8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cbcb	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.cbcd	09 80		ora #$80			ora 	#$80
.cbcf	85 1d		sta $1d				sta 	zLTemp1+3
.cbd1	80 03		bra $cbd6			bra 	_FPD_Rotates
.cbd3					_FPD_NoSubtract:
.cbd3	68		pla				pla 								; throw away unwanted results
.cbd4	68		pla				pla
.cbd5	68		pla				pla
.cbd6					_FPD_Rotates:
.cbd6	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.cbd9	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.cbdc	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.cbdf	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.cbe2	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.cbe4	26 1b		rol $1b				rol 	zLTemp1+1
.cbe6	26 1c		rol $1c				rol 	zLTemp1+2
.cbe8	26 1d		rol $1d				rol 	zLTemp1+3
.cbea	90 02		bcc $cbee			bcc 	_FPD_NoCarry
.cbec	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.cbee					_FPD_NoCarry:
.cbee	88		dey				dey 								; do 32 times
.cbef	d0 ad		bne $cb9e			bne 	_FPD_Loop
.cbf1	4c 58 cc	jmp $cc58			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cbf4					_FPD_Overflow:
.cbf4	4c 55 ce	jmp $ce55			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cbf7					FPMultiply:
.cbf7	48		pha				pha
.cbf8	5a		phy				phy
.cbf9	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cbfc	70 08		bvs $cc06			bvs 	_FPM_Exit
.cbfe	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cc01	50 06		bvc $cc09			bvc 	_FPM_CalcExponent
.cc03	20 58 cd	jsr $cd58			jsr 	FPUCopyX2ToX1
.cc06					_FPM_Exit:
.cc06	7a		ply				ply
.cc07	68		pla				pla
.cc08	60		rts				rts
.cc09					_FPM_CalcExponent:
.cc09	18		clc				clc
.cc0a	20 7b cc	jsr $cc7b			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cc0d	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.cc10	a9 00		lda #$00			lda 	#0
.cc12	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cc14	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cc16	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cc18	85 1d		sta $1d				sta 	zLTemp1+3
.cc1a	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cc1c					_FPM_Loop:
.cc1c	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.cc1f	29 01		and #$01			and 	#1
.cc21	18		clc				clc 								; clear carry for the long rotate.
.cc22	f0 1d		beq $cc41			beq 	_FPM_NoAddition
.cc24	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cc25	a5 1a		lda $1a				lda 	zLTemp1+0
.cc27	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cc2a	85 1a		sta $1a				sta 	zLTemp1+0
.cc2c	a5 1b		lda $1b				lda 	zLTemp1+1
.cc2e	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cc31	85 1b		sta $1b				sta 	zLTemp1+1
.cc33	a5 1c		lda $1c				lda 	zLTemp1+2
.cc35	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cc38	85 1c		sta $1c				sta 	zLTemp1+2
.cc3a	a5 1d		lda $1d				lda 	zLTemp1+3
.cc3c	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cc3f	85 1d		sta $1d				sta 	zLTemp1+3
.cc41					_FPM_NoAddition:
.cc41	66 1d		ror $1d				ror 	3+zLTemp1
.cc43	66 1c		ror $1c				ror 	2+zLTemp1
.cc45	66 1b		ror $1b				ror 	1+zLTemp1
.cc47	66 1a		ror $1a				ror 	0+zLTemp1
.cc49	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cc4c	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cc4f	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cc52	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cc55	88		dey				dey
.cc56	d0 c4		bne $cc1c			bne 	_FPM_Loop 					; do this 32 times.
.cc58					FPM_CopySignNormalize:
.cc58	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.cc5a	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.cc5d	a5 1b		lda $1b				lda 	zLTemp1+1
.cc5f	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cc62	a5 1c		lda $1c				lda 	zLTemp1+2
.cc64	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cc67	a5 1d		lda $1d				lda 	zLTemp1+3
.cc69	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cc6c	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.cc6f	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.cc72	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc75	20 e0 cd	jsr $cde0			jsr 	FPUNormalise 				; normalise and exit.
.cc78	7a		ply				ply
.cc79	68		pla				pla
.cc7a	60		rts				rts
.cc7b					FPCalculateExponent:
.cc7b	18		clc				clc
.cc7c	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.cc7f	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.cc82	b0 08		bcs $cc8c			bcs 	_FPCECarry 					; carry out ?
.cc84	10 03		bpl $cc89			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.cc86	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.cc88	60		rts				rts
.cc89					_FPCEExpZero:
.cc89	a9 00		lda #$00			lda 	#0
.cc8b	60		rts				rts
.cc8c					_FPCECarry:
.cc8c	30 03		bmi $cc91			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.cc8e	09 80		ora #$80			ora 	#$80 						; put in right range
.cc90	60		rts				rts
.cc91					_FPCEOverflow:
.cc91	4c 55 ce	jmp $ce55			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.cc94					FPFractionalPart:
.cc94	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.cc97	38		sec				sec 								; this flag tells us to keep the fractional part
.cc98	30 0f		bmi $cca9			bmi 	FPGetPart
.cc9a	60		rts				rts
.cc9b					FPIntegerPart:
.cc9b	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.cc9e	18		clc				clc 								; this flag says keep the integer part.
.cc9f	30 08		bmi $cca9			bmi 	FPGetPart 					; -ve exponents are 0..127
.cca1	48		pha				pha
.cca2	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.cca4	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cca7	68		pla				pla
.cca8	60		rts				rts
.cca9					FPGetPart:
.cca9	48		pha				pha
.ccaa	5a		phy				phy 								; save Y
.ccab	08		php				php 								; save action
.ccac	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.ccaf	70 62		bvs $cd13			bvs 	_FPGP_Exit 					; then do nothing.
.ccb1	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.ccb3	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.ccb5	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.ccb7	85 1c		sta $1c				sta 	zLTemp1+2
.ccb9	85 1d		sta $1d				sta 	zLTemp1+3
.ccbb	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.ccbe	38		sec				sec
.ccbf	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.ccc1	f0 12		beq $ccd5			beq 	_FPGP_NoShift 				; ... if any
.ccc3	c9 20		cmp #$20			cmp 	#32
.ccc5	90 02		bcc $ccc9			bcc 	_FPGP_NotMax
.ccc7	a9 20		lda #$20			lda 	#32 						; max of 32.
.ccc9					_FPGP_NotMax:
.ccc9	a8		tay				tay 								; Y is the mask shift count.
.ccca					_FPGP_ShiftMask:
.ccca	46 1d		lsr $1d				lsr 	3+zLTemp1
.cccc	66 1c		ror $1c				ror 	2+zLTemp1
.ccce	66 1b		ror $1b				ror 	1+zLTemp1
.ccd0	66 1a		ror $1a				ror 	0+zLTemp1
.ccd2	88		dey				dey
.ccd3	d0 f5		bne $ccca			bne 	_FPGP_ShiftMask
.ccd5					_FPGP_NoShift:
.ccd5	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.ccd7	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.ccda					_FPGP_MaskLoop:
.ccda	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.ccdd	28		plp				plp 								; if CC we keep the top part, so we
.ccde	08		php				php		 							; flip the mask.
.ccdf	b0 02		bcs $cce3			bcs		_FPGP_NoFlip
.cce1	49 ff		eor #$ff			eor 	#$FF
.cce3					_FPGP_NoFlip:
.cce3	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.cce6	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cce9	e8		inx				inx
.ccea	c8		iny				iny
.cceb	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.cced	d0 eb		bne $ccda			bne 	_FPGP_MaskLoop
.ccef	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.ccf2	28		plp				plp
.ccf3	08		php				php 								; get action flag on the stack
.ccf4	90 05		bcc $ccfb			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.ccf6	a9 00		lda #$00			lda 	#0
.ccf8	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ccfb					_FPGP_NotFractional:
.ccfb	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.ccfe	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cd01	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cd04	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cd07	f0 05		beq $cd0e			beq 	_FPGP_Zero 					; if zero, return zero
.cd09	20 e0 cd	jsr $cde0			jsr 	FPUNormalise
.cd0c	80 05		bra $cd13			bra 	_FPGP_Exit 					; and exit
.cd0e					_FPGP_Zero:
.cd0e	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cd10	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd13					_FPGP_Exit:
.cd13	68		pla				pla 								; throw saved action flag.
.cd14	7a		ply				ply
.cd15	68		pla				pla
.cd16	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.cd17					FPCompare:
.cd17	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.cd1a	48		pha				pha
.cd1b	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.cd1e	48		pha				pha
.cd1f	20 82 ca	jsr $ca82			jsr 	FPSubtract 					; calculate X1-X2
.cd22	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.cd25	70 2c		bvs $cd53			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.cd27	68		pla				pla
.cd28	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.cd2b	68		pla				pla
.cd2c	38		sec				sec
.cd2d	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.cd30	70 15		bvs $cd47			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cd32	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cd33	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cd35	b0 10		bcs $cd47			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cd37	38		sec				sec
.cd38	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.cd3b	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.cd3d	b0 02		bcs $cd41			bcs 	_FPCNotRange 				; keep in range.
.cd3f	a9 01		lda #$01			lda 	#1
.cd41					_FPCNotRange:
.cd41	38		sec				sec
.cd42	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cd45	b0 0e		bcs $cd55			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cd47					_FPCNotEqual:
.cd47	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cd4a	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cd4c	f0 02		beq $cd50			beq 	_FPCNE2
.cd4e	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cd50	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cd51	80 04		bra $cd57			bra 	_FPCExit
.cd53					_FPCPullZero:
.cd53	68		pla				pla 								; throw saved exponents
.cd54	68		pla				pla
.cd55					_FPCZero:
.cd55	a9 00		lda #$00			lda 	#0 							; and return zero
.cd57					_FPCExit:
.cd57	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cd58					FPUCopyX2ToX1:
.cd58	48		pha				pha
.cd59	da		phx				phx
.cd5a	5a		phy				phy
.cd5b	a0 08		ldy #$08			ldy 	#8
.cd5d	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.cd60	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cd63	e8		inx				inx
.cd64	88		dey				dey
.cd65	10 f6		bpl $cd5d			bpl 	_FPUC21
.cd67	7a		ply				ply
.cd68	fa		plx				plx
.cd69	68		pla				pla
.cd6a	60		rts				rts
.cd6b					FPUSetInteger:
.cd6b	48		pha				pha
.cd6c	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cd6f	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cd71	10 02		bpl $cd75			bpl 	_FPUSIExtend
.cd73	a9 ff		lda #$ff			lda 	#$FF
.cd75					_FPUSIExtend:
.cd75	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cd78	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd7b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd7e	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cd80	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd83	68		pla				pla
.cd84	60		rts				rts
.cd85					FPUNegateInteger:
.cd85	48		pha				pha
.cd86	38		sec				sec
.cd87	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cd89	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cd8c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd8f	a9 00		lda #$00			lda 	#0
.cd91	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cd94	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd97	a9 00		lda #$00			lda 	#0
.cd99	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cd9c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd9f	a9 00		lda #$00			lda 	#0
.cda1	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cda4	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cda7	68		pla				pla
.cda8	60		rts				rts
.cda9					FPUToFloat:
.cda9	48		pha				pha
.cdaa	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.cdad	29 0f		and #$0f			and 	#$0F
.cdaf	f0 2d		beq $cdde			beq 	_FPUFExit
.cdb1	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cdb3	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cdb6	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cdb8	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.cdbb	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cdbe	10 08		bpl $cdc8			bpl		_FPUFPositive
.cdc0	20 85 cd	jsr $cd85			jsr 	FPUNegateInteger 			; negate the mantissa
.cdc3	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cdc5	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cdc8					_FPUFPositive:
.cdc8	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cdcb	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cdce	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cdd1	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cdd4	d0 05		bne $cddb			bne 	_FPUFNonZero
.cdd6	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cdd8	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cddb					_FPUFNonZero:
.cddb	20 e0 cd	jsr $cde0			jsr 	FPUNormalise 				; normalise the floating point.
.cdde					_FPUFExit:
.cdde	68		pla				pla
.cddf	60		rts				rts
.cde0					FPUNormalise:
.cde0	48		pha				pha
.cde1	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cde4	70 20		bvs $ce06			bvs 	_FPUNExit
.cde6	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cde9	f0 16		beq $ce01			beq 	_FPUNSetZero
.cdeb					_FPUNLoop:
.cdeb	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cdee	30 16		bmi $ce06			bmi 	_FPUNExit 					; if so, we are normalised.
.cdf0	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.cdf3	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.cdf6	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.cdf9	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.cdfc	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.cdff	d0 ea		bne $cdeb			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.ce01					_FPUNSetZero:
.ce01	a9 40		lda #$40			lda 	#$40
.ce03	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.ce06					_FPUNExit:
.ce06	68		pla				pla
.ce07	60		rts				rts
.ce08					FPUToInteger:
.ce08	48		pha				pha
.ce09	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.ce0c	29 01		and #$01			and 	#1
.ce0e	d0 3e		bne $ce4e			bne 	_FPUTOI_Exit
.ce10	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.ce13	70 2b		bvs $ce40			bvs 	_FPUTOI_Zero
.ce15	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.ce18	10 26		bpl $ce40			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.ce1a	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.ce1c	b0 37		bcs $ce55			bcs 	FP_Overflow
.ce1e					_FPUToIToInteger:
.ce1e	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.ce21	c9 a0		cmp #$a0			cmp 	#128+32
.ce23	f0 11		beq $ce36			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.ce25	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.ce28	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.ce2b	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ce2e	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ce31	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ce34	80 e8		bra $ce1e			bra 	_FPUToIToInteger 			; keep going.
.ce36					_FPUToICheckSign:
.ce36	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.ce39	10 13		bpl $ce4e			bpl 	_FPUToI_Exit 				; exit if unsigned.
.ce3b	20 85 cd	jsr $cd85			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.ce3e	80 0e		bra $ce4e			bra 	_FPUTOI_Exit
.ce40					_FPUTOI_Zero:
.ce40	a9 00		lda #$00			lda 	#0 							; return zero integer.
.ce42	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce45	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce48	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce4b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce4e					_FPUToI_Exit:
.ce4e	a9 01		lda #$01			lda 	#1 							; set type to integer
.ce50	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce53	68		pla				pla
.ce54	60		rts				rts
.ce55					FP_Overflow:
.ce55	80 fe		bra $ce55		_error: bra _error
>ce57	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>ce5f	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.ce6f					FPUTimes10:
.ce6f	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.ce72	85 1a		sta $1a				sta 	ZLTemp1+0
.ce74	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ce77	85 1b		sta $1b				sta 	ZLTemp1+1
.ce79	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce7c	85 1c		sta $1c				sta 	ZLTemp1+2
.ce7e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ce81	85 1d		sta $1d				sta 	ZLTemp1+3
.ce83	20 c7 ce	jsr $cec7			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.ce86	20 c7 ce	jsr $cec7			jsr 	_FPUT_LSR_ZLTemp1
.ce89	18		clc				clc
.ce8a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.ce8d	65 1a		adc $1a				adc 	ZLTemp1+0
.ce8f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce92	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ce95	65 1b		adc $1b				adc 	ZLTemp1+1
.ce97	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce9a	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce9d	65 1c		adc $1c				adc 	ZLTemp1+2
.ce9f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cea2	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cea5	65 1d		adc $1d				adc 	ZLTemp1+3
.cea7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ceaa	90 0f		bcc $cebb			bcc 	_FPUTimes10
.ceac	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.ceaf	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ceb2	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ceb5	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ceb8	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.cebb					_FPUTimes10:
.cebb	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.cebe	18		clc				clc
.cebf	69 03		adc #$03			adc 	#3
.cec1	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cec4	b0 8f		bcs $ce55			bcs 	FP_Overflow 				; error
.cec6	60		rts				rts
.cec7					_FPUT_LSR_ZLTemp1:
.cec7	46 1d		lsr $1d				lsr 	ZLTemp1+3
.cec9	66 1c		ror $1c				ror 	ZLTemp1+2
.cecb	66 1b		ror $1b				ror 	ZLTemp1+1
.cecd	66 1a		ror $1a				ror 	ZLTemp1+0
.cecf	60		rts				rts
.ced0					FPUScale10A:
.ced0	5a		phy				phy
.ced1	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.ced3	f0 3d		beq $cf12			beq 	_FPUScaleExit
.ced5	da		phx				phx 								; save X
.ced6	e8		inx				inx
.ced7	e8		inx				inx
.ced8	e8		inx				inx
.ced9	e8		inx				inx
.ceda	e8		inx				inx
.cedb	e8		inx				inx
.cedc	a8		tay				tay 								; save power scalar in Y.
.cedd	a9 00		lda #$00			lda 	#0
.cedf	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.cee2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cee5	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cee8	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ceeb	a9 80		lda #$80			lda 	#$80
.ceed	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cef0	a9 81		lda #$81			lda 	#$81
.cef2	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cef5	5a		phy				phy 								; save 10^n on stack.
.cef6	c0 00		cpy #$00			cpy 	#0
.cef8	10 05		bpl $ceff			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.cefa	98		tya				tya
.cefb	49 ff		eor #$ff			eor 	#$FF
.cefd	1a		inc a				inc 	a
.cefe	a8		tay				tay
.ceff					_FPUSAbs:
.ceff	20 6f ce	jsr $ce6f			jsr 	FPUTimes10
.cf02	88		dey				dey
.cf03	d0 fa		bne $ceff			bne 	_FPUSAbs 					; tos is now 10^|AC|
.cf05	68		pla				pla 								; restore count in A
.cf06	fa		plx				plx 								; restore X pointing to number to scale.
.cf07	0a		asl a				asl 	a
.cf08	b0 05		bcs $cf0f			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.cf0a	20 f7 cb	jsr $cbf7			jsr 	FPMultiply 					; if clear multiply.
.cf0d	80 03		bra $cf12			bra		_FPUScaleExit
.cf0f					_FPUSDivide:
.cf0f	20 6f cb	jsr $cb6f			jsr 	FPDivide
.cf12					_FPUScaleExit:
.cf12	7a		ply				ply
.cf13	60		rts				rts
.cf14					FPUCopyToNext:
.cf14	a0 06		ldy #$06			ldy 		#6
.cf16	da		phx				phx
.cf17					_FPUCopy1:
.cf17	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.cf1a	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.cf1d	e8		inx				inx
.cf1e	88		dey				dey
.cf1f	d0 f6		bne $cf17			bne 	_FPUCopy1
.cf21	fa		plx				plx
.cf22	60		rts				rts
.cf23					FPUCopyFromNext:
.cf23	a0 06		ldy #$06			ldy 		#6
.cf25	da		phx				phx
.cf26					_FPUCopy1:
.cf26	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.cf29	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cf2c	e8		inx				inx
.cf2d	88		dey				dey
.cf2e	d0 f6		bne $cf26			bne 	_FPUCopy1
.cf30	fa		plx				plx
.cf31	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.cf32					FPToString:
.cf32	48		pha				pha
.cf33	5a		phy				phy
.cf34	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.cf37	50 0a		bvc $cf43			bvc 		_FPTSIsFloat 			; if zero,
.cf39					_FPTSZero:
.cf39	a9 30		lda #$30			lda 		#"0"
.cf3b	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter
.cf3e					_FPTSExit:
.cf3e	7a		ply				ply
.cf3f	68		pla				pla
.cf40	60		rts				rts
.cf41	80 fb		bra $cf3e			bra 		_FPTSExit
.cf43					_FPTSIsFloat:
.cf43	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.cf46	10 0a		bpl $cf52			bpl 		_FPTSNotSigned
.cf48	a9 00		lda #$00			lda 		#0 						; clear sign flag
.cf4a	9d 05 03	sta $0305,x			sta 		XS_Type,x
.cf4d	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cf4f	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter
.cf52					_FPTSNotSigned:
.cf52	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.cf55	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.cf57	b0 09		bcs $cf62			bcs 		_FPTSExponent
.cf59	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.cf5b	90 05		bcc $cf62			bcc 		_FPTSExponent 			;
.cf5d					_FPTSStandard:
.cf5d	20 a6 cf	jsr $cfa6			jsr 		FPTOutputBody 			; output the body.
.cf60	80 dc		bra $cf3e			bra 		_FPTSExit
.cf62					_FPTSExponent:
.cf62	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.cf64	8d 24 04	sta $0424			sta 		ExpCount
.cf67					_FPTSExponentLoop:
.cf67	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.cf6a	10 0e		bpl $cf7a			bpl 		_FPTSTimes
.cf6c	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.cf6e	90 14		bcc $cf84			bcc 		_FPTSScaledToExp
.cf70	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.cf72	20 d0 ce	jsr $ced0			jsr 		FPUScale10A
.cf75	ee 24 04	inc $0424			inc 		ExpCount
.cf78	80 ed		bra $cf67			bra 		_FPTSExponentLoop
.cf7a					_FPTSTimes:
.cf7a	a9 01		lda #$01			lda 		#1
.cf7c	20 d0 ce	jsr $ced0			jsr 		FPUScale10A
.cf7f	ce 24 04	dec $0424			dec 		ExpCount
.cf82	80 e3		bra $cf67			bra 		_FPTSExponentLoop
.cf84					_FPTSScaledToExp:
.cf84	20 a6 cf	jsr $cfa6			jsr 		FPTOutputBody 			; output the body.
.cf87	a9 65		lda #$65			lda 		#"e"					; output E
.cf89	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter
.cf8c	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.cf8f	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.cf92	29 80		and #$80			and 		#$80 					; sign extend it
.cf94	f0 02		beq $cf98			beq 		_FPTSSExt
.cf96	a9 ff		lda #$ff			lda 		#$FF
.cf98					_FPTSSExt:
.cf98	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cf9b	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cf9e	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.cfa1	20 28 c9	jsr $c928			jsr 		INTToString 			; output the exponent.
.cfa4	80 98		bra $cf3e			bra			_FPTSExit 				; and exit.
.cfa6					FPTOutputBody:
.cfa6	20 14 cf	jsr $cf14			jsr 		FPUCopyToNext 			; copy to next slot.
.cfa9	20 08 ce	jsr $ce08			jsr 		FPUToInteger 			; convert to an integer
.cfac	20 28 c9	jsr $c928			jsr 		INTToString 			; output the main integer part.
.cfaf	20 23 cf	jsr $cf23			jsr 		FPUCopyFromNext 		; get the fractional part back.
.cfb2	20 94 cc	jsr $cc94			jsr 		FPFractionalPart 		; get the decimal part.
.cfb5	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.cfb8	70 3e		bvs $cff8			bvs 		_FPTOExit 				; if not, exit now.
.cfba	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.cfbc	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter
.cfbf					_FPOutLoop:
.cfbf	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.cfc2	70 1e		bvs $cfe2			bvs 		_FPStripZeros 			; strip trailing zeros
.cfc4	20 6f ce	jsr $ce6f			jsr 		FPUTimes10 				; multiply by 10
.cfc7	20 14 cf	jsr $cf14			jsr 		FPUCopyToNext			; copy to next slot.
.cfca	20 08 ce	jsr $ce08			jsr 		FPUToInteger 			; convert to integer
.cfcd	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.cfd0	09 30		ora #$30			ora 		#"0"
.cfd2	20 c4 c9	jsr $c9c4			jsr 		ITSOutputCharacter
.cfd5	20 23 cf	jsr $cf23			jsr 		FPUCopyFromNext 		; get it back
.cfd8	20 94 cc	jsr $cc94			jsr 		FPFractionalPart 		; get fractional part
.cfdb	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.cfde	c9 0b		cmp #$0b			cmp 	 	#11
.cfe0	90 dd		bcc $cfbf			bcc 		_FPOutLoop 				; if so, keep going till zero.
.cfe2					_FPStripZeros:
.cfe2	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.cfe5					_FPStripLoop:
.cfe5	88		dey				dey 								; back one, if at start then no strip
.cfe6	f0 10		beq $cff8			beq 		_FPToExit
.cfe8	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.cfeb	c9 30		cmp #$30			cmp 		#"0"
.cfed	f0 f6		beq $cfe5			beq 		_FPStripLoop
.cfef	c8		iny				iny
.cff0	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.cff2	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.cff5	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.cff8					_FPTOExit:
.cff8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.cff9					FPFromString:
.cff9	48		pha				pha 								; push A
.cffa	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.cffc	c9 2e		cmp #$2e			cmp 	#"."
.cffe	f0 03		beq $d003			beq	 	_FPFIsDecimal
.d000	4c 66 d0	jmp $d066			jmp 	_FPFNotDecimal
.d003					_FPFIsDecimal:
.d003	c8		iny				iny 								; consume the decimal.
.d004	20 a9 cd	jsr $cda9			jsr 	FPUToFloat 					; convert the integer to float.
.d007	da		phx				phx 								; save X.
.d008	5a		phy				phy 								; save decimal start position
.d009	e8		inx				inx
.d00a	e8		inx				inx
.d00b	e8		inx				inx
.d00c	e8		inx				inx
.d00d	e8		inx				inx
.d00e	e8		inx				inx
.d00f	20 dc c9	jsr $c9dc			jsr 	INTFromStringY 				; get the part after the DP.
.d012	20 a9 cd	jsr $cda9			jsr 	FPUToFloat 					; convert that to a float.
.d015	68		pla				pla 								; calculate - chars consumed.
.d016	8c 23 04	sty $0423			sty 	ExpTemp
.d019	38		sec				sec
.d01a	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.d01d	20 d0 ce	jsr $ced0			jsr 	FPUScale10A 				; scale it by 10^AC
.d020	fa		plx				plx 								; restore original X
.d021	20 8c ca	jsr $ca8c			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d024	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.d026	c9 45		cmp #$45			cmp 	#"E"
.d028	f0 04		beq $d02e			beq 	_FPFExponent
.d02a	c9 65		cmp #$65			cmp 	#"e"
.d02c	d0 38		bne $d066			bne 	_FPFNotDecimal 				; no, then exit normally.
.d02e					_FPFExponent:
.d02e	c8		iny				iny 								; skip over E symbol.
.d02f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.d031	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d033	d0 01		bne $d036			bne 	_FPFGotSign
.d035	c8		iny				iny 								; if it was - skip over it.
.d036					_FPFGotSign:
.d036	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d037	da		phx				phx
.d038	e8		inx				inx
.d039	e8		inx				inx
.d03a	e8		inx				inx
.d03b	e8		inx				inx
.d03c	e8		inx				inx
.d03d	e8		inx				inx
.d03e	20 dc c9	jsr $c9dc			jsr 	INTFromStringY 				; get the exponent
.d041	fa		plx				plx 								; restore X.
.d042	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d045	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.d048	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.d04b	d0 1b		bne $d068			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d04d	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d050	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d052	b0 14		bcs $d068			bcs 	_FPFXOverflow
.d054	68		pla				pla 								; get direction
.d055	d0 09		bne $d060			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d057	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d05a	49 ff		eor #$ff			eor 	#$FF
.d05c	1a		inc a				inc 	a
.d05d	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.d060					_FPFXScale:
.d060	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d063	20 d0 ce	jsr $ced0			jsr 	FPUScale10A 				; scale by the exponent.
.d066					_FPFNotDecimal:
.d066	68		pla				pla
.d067	60		rts				rts
.d068					_FPFXOverflow:
.d068	20 16 c4	jsr $c416			jsr 	ERR_Handler
>d06b	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d073	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.d07a					TIM_Error:
.d07a	20 37 c2	jsr $c237			jsr 	IFT_UpLine 					; go up one line.
.d07d	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.d07f	80 02		bra $d083			bra 	TIM_ShowPrompt
.d081					TIM_NewCommand:
.d081	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.d083					TIM_ShowPrompt:
.d083	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.d086	20 fb c2	jsr $c2fb			jsr 	IFT_ReadLine	 			; get character, go to next line
.d089	20 5d c2	jsr $c25d			jsr 	IFT_NewLine					; go to next line.
.d08c	86 10		stx $10				stx 	zTemp1 						; save line read address
.d08e	84 11		sty $11				sty 	zTemp1+1
.d090	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.d092	b1 10		lda ($10),y			lda 	(zTemp1),y
.d094	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.d096	d0 01		bne $d099			bne 	TIM_NotDot
.d098	c8		iny				iny
.d099					TIM_NotDot:
.d099	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.d09b	c9 52		cmp #$52			cmp 	#"R"						; show registers
.d09d	f0 6b		beq $d10a			beq 	TIM_ShowRegisters
.d09f	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.d0a1	f0 12		beq $d0b5			beq 	TIM_ShowMemory
.d0a3	c9 47		cmp #$47			cmp 	#"G"						; execute
.d0a5	f0 49		beq $d0f0			beq 	TIM_Execute
.d0a7	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.d0a9	f0 07		beq $d0b2			beq 	TIM_GoLoadMemory
.d0ab	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.d0ad	d0 cb		bne $d07a			bne 	TIM_Error
.d0af	4c 2d d2	jmp $d22d			jmp 	TIM_UpdateRegisters
.d0b2					TIM_GoLoadMemory:
.d0b2	4c 5d d2	jmp $d25d			jmp 	TIM_LoadMemory
.d0b5					TIM_ShowMemory:
.d0b5	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d0b8	b0 c0		bcs $d07a			bcs 	TIM_Error
.d0ba	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.d0bc	85 12		sta $12				sta 	zTemp2
.d0be	a5 15		lda $15				lda 	zTemp3+1
.d0c0	85 13		sta $13				sta 	zTemp2+1
.d0c2	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d0c5	90 08		bcc $d0cf			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.d0c7	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.d0c9	85 14		sta $14				sta 	zTemp3
.d0cb	a5 13		lda $13				lda 	zTemp2+1
.d0cd	85 15		sta $15				sta 	zTemp3+1
.d0cf					_TIMSM_Start:
.d0cf	20 81 d1	jsr $d181			jsr 	TIM_WriteLine 				; write one line of hex out
.d0d2	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.d0d4	18		clc				clc
.d0d5	69 10		adc #$10			adc 	#16
.d0d7	85 12		sta $12				sta 	zTemp2
.d0d9	90 02		bcc $d0dd			bcc 	_TIMSM_NoCarry
.d0db	e6 13		inc $13				inc 	zTemp2+1
.d0dd					_TIMSM_NoCarry:
.d0dd	20 e2 c3	jsr $c3e2			jsr 	IF_CheckBreak 				; check CTL+C
.d0e0	d0 0b		bne $d0ed			bne 	_TIMSM_Ends 				; if pressed break out.
.d0e2	38		sec				sec 								; check past the end address in zTemp3
.d0e3	a5 14		lda $14				lda 	zTemp3
.d0e5	e5 12		sbc $12				sbc 	zTemp2
.d0e7	a5 15		lda $15				lda 	zTemp3+1
.d0e9	e5 13		sbc $13				sbc 	zTemp2+1
.d0eb	10 e2		bpl $d0cf			bpl 	_TIMSM_Start
.d0ed					_TIMSM_Ends:
.d0ed	4c 81 d0	jmp $d081			jmp 	TIM_NewCommand
.d0f0					TIM_Execute:
.d0f0	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; get the execute address
.d0f3	b0 85		bcs $d07a			bcs 	TIM_Error 					; not legitimate
.d0f5	ae 31 04	ldx $0431			ldx 	TIM_SP 						; set up SP
.d0f8	9a		txs				txs
.d0f9	ad 2c 04	lda $042c			lda 	TIM_SR 						; Status for PLP
.d0fc	48		pha				pha
.d0fd	ad 2d 04	lda $042d			lda 	TIM_A 						; restore AXYZ
.d100	ae 2e 04	ldx $042e			ldx 	TIM_X
.d103	ac 2f 04	ldy $042f			ldy 	TIM_Y
.d106	28		plp				plp 								; and PS Byte.
.d107	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.d10a					TIM_Start:
.d10a					TIM_ShowRegisters:
.d10a	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.d10d	8d 2b 04	sta $042b			sta 	TIM_IRQ+1
.d110	ad ff ff	lda $ffff			lda 	$FFFF
.d113	8d 2a 04	sta $042a			sta 	TIM_IRQ
.d116	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.d118					_TIMSR_Text:
.d118	bd 48 d1	lda $d148,x			lda 	_TIMSR_Label,x
.d11b	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d11e	e8		inx				inx
.d11f	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.d121	d0 f5		bne $d118			bne 	_TIMSR_Text
.d123	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.d125					_TIMSR_Skip:
.d125	e8		inx				inx
.d126					_TIMSR_LoopSpace:
.d126	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.d128	b0 04		bcs $d12e			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.d12a	8a		txa				txa
.d12b	4a		lsr a				lsr 	a
.d12c	b0 05		bcs $d133			bcs 	_TIMSR_NoSpace
.d12e					_TIMSR_Space:
.d12e	a9 20		lda #$20			lda 	#" "
.d130	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d133					_TIMSR_NoSpace:
.d133	bd 28 04	lda $0428,x			lda 	TIM_PC,x 					; output hex value.
.d136	20 68 d1	jsr $d168			jsr 	TIM_WriteHex
.d139	e8		inx				inx
.d13a	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.d13c	f0 e7		beq $d125			beq 	_TIMSR_Skip
.d13e	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.d140	d0 e4		bne $d126			bne 	_TimSR_LoopSpace
.d142	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; new line
.d145	4c 81 d0	jmp $d081			jmp	 	TIM_NewCommand 				; new command.
.d148					_TIMSR_Label:
>d148	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>d150	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>d160	52
>d161	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.d168					_TIMSR_LabelEnd:
.d168					TIM_WriteHex:
.d168	48		pha				pha 								; save A
.d169	4a		lsr a				lsr 	a 							; shift MSB->LSB
.d16a	4a		lsr a				lsr 	a
.d16b	4a		lsr a				lsr 	a
.d16c	4a		lsr a				lsr 	a
.d16d	20 71 d1	jsr $d171			jsr 	_TIMWH_Nibble 				; print MSB
.d170	68		pla				pla 								; restore and print LSB
.d171					_TIMWH_Nibble:
.d171	48		pha				pha
.d172	29 0f		and #$0f			and 	#15 						; mask out
.d174	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.d176	90 02		bcc $d17a			bcc 	_TIMWHNoLetter
.d178	69 06		adc #$06			adc 	#6
.d17a					_TIMWHNoLetter:
.d17a	69 30		adc #$30			adc 	#48
.d17c	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter 			; print it out.
.d17f	68		pla				pla
.d180	60		rts				rts
.d181					TIM_WriteLine:
.d181	a9 2e		lda #$2e			lda 	#"." 						; prompt
.d183	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d186	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.d188	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d18b	a5 13		lda $13				lda 	zTemp2+1 					; write address
.d18d	20 68 d1	jsr $d168			jsr 	TIM_WriteHex
.d190	a5 12		lda $12				lda 	zTemp2
.d192	20 68 d1	jsr $d168			jsr 	TIM_WriteHex
.d195	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.d197					_TIMWL_Loop:
.d197	a9 20		lda #$20			lda 	#" "
.d199	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d19c	b1 12		lda ($12),y			lda 	(zTemp2),y
.d19e	20 68 d1	jsr $d168			jsr 	TIM_WriteHex
.d1a1	c8		iny				iny
.d1a2	c0 10		cpy #$10			cpy 	#16
.d1a4	d0 f1		bne $d197			bne 	_TIMWL_Loop
.d1a6	4c 5d c2	jmp $c25d			jmp 	IFT_NewLine 				; new line and exit
.d1a9					TIM_GetHex:
.d1a9	c8		iny				iny
.d1aa	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.d1ac	c9 20		cmp #$20			cmp 	#32
.d1ae	f0 f9		beq $d1a9			beq 	TIM_GetHex
.d1b0	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.d1b2	f0 f5		beq $d1a9			beq 	TIM_GetHex
.d1b4	20 dd d1	jsr $d1dd			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.d1b7	b0 23		bcs $d1dc			bcs 	_TIMGH_Exit					; if first bad then exit now.
.d1b9	a9 00		lda #$00			lda 	#0 							; zero result
.d1bb	85 14		sta $14				sta 	zTemp3
.d1bd	85 15		sta $15				sta 	zTemp3+1
.d1bf					_TIM_GHLoop:
.d1bf	20 dd d1	jsr $d1dd			jsr 	TIM_GetHexCharacter 		; get next character
.d1c2	b0 17		bcs $d1db			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.d1c4	c8		iny				iny 								; skip over it.
.d1c5	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.d1c7	26 15		rol $15				rol 	zTemp3+1
.d1c9	06 14		asl $14				asl 	zTemp3 						; now x 2
.d1cb	26 15		rol $15				rol 	zTemp3+1
.d1cd	06 14		asl $14				asl 	zTemp3						; now x 4
.d1cf	26 15		rol $15				rol 	zTemp3+1
.d1d1	06 14		asl $14				asl 	zTemp3 						; now x 8
.d1d3	26 15		rol $15				rol 	zTemp3+1
.d1d5	05 14		ora $14				ora 	zTemp3 						; OR result in
.d1d7	85 14		sta $14				sta 	zTemp3
.d1d9	80 e4		bra $d1bf			bra 	_TIM_GHLoop 				; loop round again.
.d1db					_TIMGH_Okay:
.d1db	18		clc				clc
.d1dc					_TIMGH_Exit:
.d1dc	60		rts				rts
.d1dd					TIM_GetHexCharacter:
.d1dd	b1 10		lda ($10),y			lda 	(zTemp1),y
.d1df	38		sec				sec
.d1e0	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d1e2	90 0e		bcc $d1f2			bcc 	_TIM_GHCFail
.d1e4	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d1e6	90 0b		bcc $d1f3			bcc 	_TIM_GHCExit
.d1e8	c9 11		cmp #$11			cmp 	#65-48						; < A
.d1ea	90 06		bcc $d1f2			bcc		_TIM_GHCFail
.d1ec	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d1ee	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d1f0	90 01		bcc $d1f3			bcc		_TIM_GHCExit
.d1f2					_TIM_GHCFail:
.d1f2	38		sec				sec
.d1f3					_TIM_GHCExit:
.d1f3	60		rts				rts
.d1f4					TIM_BreakVector:
.d1f4	da		phx				phx									; save X/A on stack
.d1f5	48		pha				pha
.d1f6	ba		tsx				tsx 								; X points to S
.d1f7	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d1fa	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d1fc	d0 03		bne $d201			bne 	_TIMBreak					; if set, it's BRK
.d1fe	68		pla				pla 								; abandon routine.
.d1ff	fa		plx				plx
.d200	40		rti				rti
.d201					_TIMBreak:
.d201	68		pla				pla 								; save A X Y and maybe Z
.d202	8d 2d 04	sta $042d			sta 	TIM_A
.d205	fa		plx				plx
.d206	8e 2e 04	stx $042e			stx 	TIM_X
.d209	8c 2f 04	sty $042f			sty 	TIM_Y
.d20c	68		pla				pla 								; get Status Register
.d20d	8d 2c 04	sta $042c			sta 	TIM_SR
.d210	68		pla				pla
.d211	8d 29 04	sta $0429			sta 	TIM_PC+1 					; save calling address
.d214	68		pla				pla
.d215	8d 28 04	sta $0428			sta 	TIM_PC 						; high byte
.d218	ad 29 04	lda $0429			lda 	TIM_PC+1 					; dec PC to point right.
.d21b	d0 03		bne $d220			bne 	_TIMDecrement 				; brk bumps it.
.d21d	ce 28 04	dec $0428			dec 	TIM_PC
.d220					_TIMDecrement:
.d220	ce 29 04	dec $0429			dec 	TIM_PC+1
.d223	ba		tsx				tsx 								; and copy SP
.d224	8e 31 04	stx $0431			stx 	TIM_SP
.d227	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d229	9a		txs				txs
.d22a	4c 0a d1	jmp $d10a			jmp 	TIM_Start 					; and start up TIM monitor.
.d22d					TIM_UpdateRegisters:
.d22d	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; PC
.d230	b0 28		bcs $d25a			bcs 	_TIMURFail
.d232	a5 14		lda $14				lda 	zTemp3
.d234	8d 29 04	sta $0429			sta 	Tim_PC+1
.d237	a5 15		lda $15				lda 	zTemp3+1
.d239	8d 28 04	sta $0428			sta 	Tim_PC
.d23c	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; ignore IRQ
.d23f	b0 19		bcs $d25a			bcs 	_TIMURFail
.d241	a2 00		ldx #$00			ldx 	#0
.d243					_TIM_URLoop:
.d243	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d245	d0 01		bne $d248			bne 	_TIM_1
.d247	e8		inx				inx
.d248					_TIM_1:
.d248	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; registers
.d24b	b0 0d		bcs $d25a			bcs 	_TIMURFail
.d24d	a5 14		lda $14				lda 	zTemp3
.d24f	9d 2c 04	sta $042c,x			sta 	Tim_SR,x
.d252	e8		inx				inx
.d253	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d255	d0 ec		bne $d243			bne 	_TIM_URLoop
.d257	4c 81 d0	jmp $d081			jmp 	TIM_NewCommand
.d25a					_TIMURFail:
.d25a	4c 7a d0	jmp $d07a			jmp 	TIM_Error
.d25d					TIM_LoadMemory:
.d25d	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; target address => zTemp2
.d260	a5 14		lda $14				lda 	zTemp3
.d262	85 12		sta $12				sta 	zTemp2
.d264	a5 15		lda $15				lda 	zTemp3+1
.d266	85 13		sta $13				sta 	zTemp2+1
.d268					_TIM_LMLoop:
.d268	20 a9 d1	jsr $d1a9			jsr 	TIM_GetHex 					; next byte ?
.d26b	b0 0e		bcs $d27b			bcs 	_TIMLMDone 					; no more
.d26d	a2 00		ldx #$00			ldx 	#0							; write out.
.d26f	a5 14		lda $14				lda 	zTemp3
.d271	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d273	e6 12		inc $12				inc 	zTemp2 						; bump address
.d275	d0 f1		bne $d268			bne 	_TIM_LMLoop
.d277	e6 13		inc $13				inc 	zTemp2+1
.d279	80 ed		bra $d268			bra 	_TIM_LMLoop
.d27b					_TIMLMDone:
.d27b	4c 81 d0	jmp $d081			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d27e	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	f2 c1						.word 	StartROM
>fffe	f4 d1					.word TIM_BreakVector

;******  End of listing
