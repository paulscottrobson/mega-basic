
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 29 21:54:42 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN.
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.
=2					SMark_While 	= 	2 							; 2 is WHILE/WEND.
=3					SMark_If 		= 	3 							; 3 is IF/ENDIF

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a8					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b0					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b8					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b9					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bb					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bd					Tim_SR:		.byte ? 						; Processor Status
>03be					Tim_A:		.byte ? 						; Processor Registers
>03bf					Tim_X:		.byte ?
>03c0					Tim_Y:		.byte ?
>03c1					Tim_Z:		.byte ?
>03c2					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	18 0a 00 ff 14 74 68 69			.byte	$18,$0a,$00,$ff,$14,$74,$68,$69
>8008	73 20 69 73 20 61 20 63			.byte	$73,$20,$69,$73,$20,$61,$20,$63
>8010	6f 6d 6d 65 6e 74 2e 00			.byte	$6f,$6d,$6d,$65,$6e,$74,$2e,$00
>8018	11 14 00 ff 0d 77 61 69			.byte	$11,$14,$00,$ff,$0d,$77,$61,$69
>8020	74 20 36 35 30 32 2c 31			.byte	$74,$20,$36,$35,$30,$32,$2c,$31
>8028	00 0d 1e 00 ca 4f 68 c0			.byte	$00,$0d,$1e,$00,$ca,$4f,$68,$c0
>8030	ca 4f 68 c0 c4 00 0e e8			.byte	$ca,$4f,$68,$c0,$c4,$00,$0e,$e8
>8038	03 d6 fe 09 48 65 6c 6c			.byte	$03,$d6,$fe,$09,$48,$65,$6c,$6c
>8040	6f 20 21 00 07 f2 03 18			.byte	$6f,$20,$21,$00,$07,$f2,$03,$18
>8048	84 42 00 08 fc 03 90 18			.byte	$84,$42,$00,$08,$fc,$03,$90,$18
>8050	88 40 00 07 06 04 19 84			.byte	$88,$40,$00,$07,$06,$04,$19,$84
>8058	40 00 05 10 04 91 00 08			.byte	$40,$00,$05,$10,$04,$91,$00,$08
>8060	1a 04 8f 18 84 42 00 14			.byte	$1a,$04,$8f,$18,$84,$42,$00,$14
>8068	24 04 d6 fe 0e 49 74 73			.byte	$24,$04,$d6,$fe,$0e,$49,$74,$73
>8070	20 32 20 21 20 20 20 20			.byte	$20,$32,$20,$21,$20,$20,$20,$20
>8078	20 c1 00 05 2e 04 de 00			.byte	$20,$c1,$00,$05,$2e,$04,$de,$00
>8080	14 38 04 d6 fe 0e 49 74			.byte	$14,$38,$04,$d6,$fe,$0e,$49,$74
>8088	73 20 6e 6f 74 20 32 20			.byte	$73,$20,$6e,$6f,$74,$20,$32,$20
>8090	21 20 c1 00 05 42 04 94			.byte	$21,$20,$c1,$00,$05,$42,$04,$94
>8098	00 0e 4c 04 d6 18 c1 19			.byte	$00,$0e,$4c,$04,$d6,$18,$c1,$19
>80a0	c0 19 84 19 8a 41 00 0e			.byte	$c0,$19,$84,$19,$8a,$41,$00,$0e
>80a8	56 04 96 19 84 43 c0 18			.byte	$56,$04,$96,$19,$84,$43,$c0,$18
>80b0	84 18 8b 41 00 05 60 04			.byte	$84,$18,$8b,$41,$00,$05,$60,$04
>80b8	95 00 0b 6a 04 d6 fe 06			.byte	$95,$00,$0b,$6a,$04,$d6,$fe,$06
>80c0	45 6e 64 2e 00 05 74 04			.byte	$45,$6e,$64,$2e,$00,$05,$74,$04
>80c8	cb 00 00				.byte	$cb,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c ff b0	jmp $b0ff		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 05	sta $0500			sta 	IFT_XCursor
.a071	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a074	ad 01 05	lda $0501			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 05	sta $0500			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 05	inc $0500			inc 	IFT_XCursor
.a150	ad 00 05	lda $0500			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 05	dec $0501			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 05	sta $0501			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 05	inc $0501			inc 	IFT_YCursor
.a168	ad 01 05	lda $0501			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 05	lda $0501			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 05	inc $0500			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae c2 03	ldx $03c2			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad bd 03	lda $03bd			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad be 03	lda $03be			lda 	TIM_A 						; restore AXYZ
.ab9f	ae bf 03	ldx $03bf			ldx 	TIM_X
.aba2	ac c0 03	ldy $03c0			ldy 	TIM_Y
.aba5	ab c1 03	ldz $03c1			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d bc 03	sta $03bc			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d bb 03	sta $03bb			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd b9 03	lda $03b9,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d be 03	sta $03be			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e bf 03	stx $03bf			stx 	TIM_X
.acaa	8c c0 03	sty $03c0			sty 	TIM_Y
.acad	9c c1 03	stz $03c1			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d bd 03	sta $03bd			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d ba 03	sta $03ba			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d b9 03	sta $03b9			sta 	TIM_PC 						; high byte
.acbc	ad ba 03	lda $03ba			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce b9 03	dec $03b9			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce ba 03	dec $03ba			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e c2 03	stx $03c2			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d ba 03	sta $03ba			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d b9 03	sta $03b9			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d bd 03	sta $03bd,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.ad1d					StructureSearchSingle:
.ad1d	a2 00		ldx #$00			ldx 	#0
.ad1f					StructureSearchDouble:
.ad1f	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.ad21	86 11		stx $11				stx 	zTemp1+1
.ad23	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.ad25	85 12		sta $12				sta 	zTemp2
.ad27	80 1a		bra $ad43			bra 	_SSWLoop 					; jump in, start scanning from here.
.ad29					_SSWNextLine:
.ad29	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ad2b	ea		nop				nop
.ad2c	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ad2e	18		clc				clc
.ad2f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ad31	85 16		sta $16				sta 	zCodePtr
.ad33	90 02		bcc $ad37			bcc 	_SNLNoCarry
.ad35	e6 17		inc $17				inc 	zCodePtr+1
.ad37					_SNLNoCarry:
.ad37	a3 00		ldz #$00			ldz 	#0
.ad39	ea		nop				nop
.ad3a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad3c	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.ad3e	f0 57		beq $ad97			beq 	_SSWFail
.ad40	1b		inz				inz
.ad41	1b		inz				inz
.ad42					_SSWNextSimple:
.ad42	1b		inz				inz
.ad43					_SSWLoop:
.ad43	ea		nop				nop
.ad44	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad46	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.ad48	f0 df		beq $ad29			beq 	_SSWNextLine 				; if so, then next line
.ad4a	10 f6		bpl $ad42			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.ad4c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.ad4e	d0 08		bne $ad58			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.ad50	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.ad52	f0 2f		beq $ad83			beq 	_SSWFound 					; so exit.
.ad54	c5 11		cmp $11				cmp 	zTemp1+1
.ad56	f0 2b		beq $ad83			beq 	_SSWFound
.ad58					_SSWCheckUpDown:
.ad58	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.ad5a	90 10		bcc $ad6c			bcc 	_SSWNext
.ad5c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.ad5e	90 08		bcc $ad68			bcc 	_SSWPlus
.ad60	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.ad62	b0 08		bcs $ad6c			bcs 	_SSWNext
.ad64	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.ad66	c6 12		dec $12				dec 	zTemp2
.ad68					_SSWPlus:
.ad68	e6 12		inc $12				inc 	zTemp2
.ad6a	30 18		bmi $ad84			bmi 	_SSWUnder					; error if driven -ve
.ad6c					_SSWNext:
.ad6c	ea		nop				nop
.ad6d	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.ad6f	1b		inz				inz 								; skip
.ad70	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ad72	90 0d		bcc $ad81			bcc 	_SEDone 					; so just skip over it.
.ad74	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ad76	90 08		bcc $ad80			bcc 	_SEDouble
.ad78	6b		tza				tza 								; this is Y + 1
.ad79	18		clc				clc
.ad7a	ea		nop				nop
.ad7b	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.ad7d	4b		taz				taz 								; back in Y.
.ad7e	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ad7f	3b		dez				dez
.ad80					_SEDouble:
.ad80	1b		inz				inz
.ad81					_SEDone:
.ad81	80 c0		bra $ad43			bra 	_SSWLoop
.ad83					_SSWFound:
.ad83	60		rts				rts
.ad84					_SSWUnder:
.ad84	20 79 ae	jsr $ae79			jsr ERR_Handler
>ad87	53 74 72 75 63 74 75 72			.text "Structure order",0
>ad8f	65 20 6f 72 64 65 72 00
.ad97					_SSWFail:
.ad97	20 79 ae	jsr $ae79			jsr ERR_Handler
>ad9a	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>ada2	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.adaf					StackReset:
.adaf	48		pha				pha
.adb0	5a		phy				phy
.adb1	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.adb3	85 26		sta $26				sta 	zBasicSP
.adb5	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.adb7	85 27		sta $27				sta 	zBasicSP+1
.adb9	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.adbb	98		tya				tya 								; be a legal token.
.adbc	91 26		sta ($26),y			sta 	(zBasicSP),y
.adbe	7a		ply				ply
.adbf	68		pla				pla
.adc0	60		rts				rts
.adc1					StackPushFrame:
.adc1	48		pha				pha
.adc2	5a		phy				phy
.adc3	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.adc4	48		pha				pha 								; save it.
.adc5	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.adc7	18		clc				clc 								; add to Basic Stack
.adc8	65 26		adc $26				adc 	zBasicSP
.adca	85 26		sta $26				sta 	zBasicSP
.adcc	90 02		bcc $add0			bcc 	_SPFNoBump
.adce	e6 27		inc $27				inc 	zBasicSP+1
.add0					_SPFNoBump:
.add0	a0 00		ldy #$00			ldy 	#0
.add2	68		pla				pla
.add3	91 26		sta ($26),y			sta 	(zBasicSP),y
.add5	7a		ply				ply
.add6	68		pla				pla
.add7	60		rts				rts
.add8					StackPopFrame:
.add8	48		pha				pha
.add9	5a		phy				phy
.adda	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.addc	51 26		eor ($26),y			eor 	(zBasicSP),y
.adde	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ade0	d0 12		bne $adf4			bne 	_SPFError 					; mixed structures
.ade2	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.ade4	29 0f		and #$0f			and 	#$0F
.ade6	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ade8	38		sec				sec
.ade9	65 26		adc $26				adc 	zBasicSP
.adeb	85 26		sta $26				sta 	zBasicSP
.aded	b0 02		bcs $adf1			bcs 	_SPFNoBump
.adef	c6 27		dec $27				dec 	zBasicSP+1
.adf1					_SPFNoBump:
.adf1	7a		ply				ply
.adf2	68		pla				pla
.adf3	60		rts				rts
.adf4					_SPFError:
.adf4	20 79 ae	jsr $ae79			jsr ERR_Handler
>adf7	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>adff	72 75 63 74 75 72 65 73 00
.ae08					StackSavePosition:
.ae08	6b		tza				tza
.ae09	5a		phy				phy
.ae0a	a0 05		ldy #$05			ldy 	#5
.ae0c	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae0e	a0 01		ldy #$01			ldy 	#1
.ae10	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ae12	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae14	c8		iny				iny
.ae15	a5 17		lda $17				lda 	zCodePtr+1
.ae17	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae19	c8		iny				iny
.ae1a	a5 18		lda $18				lda 	zCodePtr+2
.ae1c	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae1e	c8		iny				iny
.ae1f	a5 19		lda $19				lda 	zCodePtr+3
.ae21	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae23	7a		ply				ply
.ae24	60		rts				rts
.ae25					StackRestorePosition:
.ae25	5a		phy				phy
.ae26	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ae28	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae2a	85 16		sta $16				sta 	zCodePtr+0
.ae2c	c8		iny				iny
.ae2d	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae2f	85 17		sta $17				sta 	zCodePtr+1
.ae31	c8		iny				iny
.ae32	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae34	85 18		sta $18				sta 	zCodePtr+2
.ae36	c8		iny				iny
.ae37	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae39	85 19		sta $19				sta 	zCodePtr+3
.ae3b	c8		iny				iny
.ae3c	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.ae3e	7a		ply				ply 								; restore Y
.ae3f	4b		taz				taz
.ae40	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.ae41					CharPrint:
.ae41	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.ae44					CharGet:
.ae44	4c 06 a2	jmp $a206			jmp 	IF_GetKey
.ae47					CheckBreak:
.ae47	4c f1 a1	jmp $a1f1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ae4a					SyntaxError:
.ae4a	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ae4d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ae55	72 72 6f 72 00
.ae5a					TypeError:
.ae5a	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ae5d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ae65	70 65 00
.ae68					BadParamError:
.ae68	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ae6b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ae73	6d 65 74 65 72 00
.ae79					ERR_Handler:
.ae79	a3 00		ldz #$00			ldz 	#0
.ae7b	1b		inz				inz
.ae7c	ea		nop				nop
.ae7d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae7f	85 80		sta $80				sta 	XS_Mantissa
.ae81	1b		inz				inz
.ae82	ea		nop				nop
.ae83	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae85	85 81		sta $81				sta 	XS_Mantissa+1
.ae87	fa		plx				plx 								; address in XY
.ae88	7a		ply				ply
.ae89	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ae8a	d0 01		bne $ae8d			bne 	_EHNoSkip
.ae8c	c8		iny				iny
.ae8d					_EHNoSkip:
.ae8d	20 ac ae	jsr $aeac			jsr 	PrintROMMessage 			; print message from ROM.
.ae90	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.ae92	05 81		ora $81				ora 	XS_Mantissa+1
.ae94	f0 0c		beq $aea2			beq 	_EHNoLine
.ae96	a2 a7		ldx #$a7			ldx 	#_EHAt & $FF 				; print " at "
.ae98	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.ae9a	20 ac ae	jsr $aeac			jsr 	PrintROMMessage
.ae9d	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ae9f	20 bd ae	jsr $aebd			jsr 	Print16BitInteger
.aea2					_EHNoLine:
.aea2	80 fe		bra $aea2			bra 	_EHNoLine
.aea4	4c 28 b1	jmp $b128			jmp 	WarmStart
>aea7	20 61 74 20 00			_EHAt:	.text 	" at ",0
.aeac					PrintROMMessage:
.aeac	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.aeae	84 1b		sty $1b				sty 	zLTemp1+1
.aeb0	a0 00		ldy #$00			ldy 	#0
.aeb2					_PRMLoop:
.aeb2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.aeb4	f0 06		beq $aebc			beq		_PRMExit
.aeb6	c8		iny				iny
.aeb7	20 41 ae	jsr $ae41			jsr 	CharPrint
.aeba	80 f6		bra $aeb2			bra 	_PRMLoop
.aebc					_PRMExit:
.aebc	60		rts				rts
.aebd					Print16BitInteger:
.aebd	a9 00		lda #$00			lda 	#0 							; make 32 bit
.aebf	85 82		sta $82				sta 	XS_Mantissa+2
.aec1	85 83		sta $83				sta 	XS_Mantissa+3
.aec3					Print32BitInteger:
.aec3	a9 00		lda #$00			lda 	#0
.aec5	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.aec8	aa		tax				tax 								; convert bottom level.
.aec9	20 2d c4	jsr $c42d			jsr 	INTToString 				; make string
.aecc	a2 00		ldx #$00			ldx 	#0 							; print buffer
.aece	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.aed1	f0 06		beq $aed9			beq 	_P1Exit
.aed3	20 41 ae	jsr $ae41			jsr 	CharPrint
.aed6	e8		inx				inx
.aed7	80 f5		bra $aece			bra 	_P1Loop
.aed9	8a		txa		_P1Exit:txa 								; return chars printed.
.aeda	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.aedb					VectorTable:
>aedb	90 b8					.word BinaryOp_And         & $FFFF ; $80 and
>aedd	ac b8					.word BinaryOp_Or          & $FFFF ; $81 or
>aedf	c8 b8					.word BinaryOp_Xor         & $FFFF ; $82 xor
>aee1	c8 b8					.word BinaryOp_Eor         & $FFFF ; $83 eor
>aee3	ff b8					.word Binary_Equal         & $FFFF ; $84 =
>aee5	19 b9					.word Binary_NotEqual      & $FFFF ; $85 <>
>aee7	22 b9					.word Binary_Less          & $FFFF ; $86 <
>aee9	2b b9					.word Binary_LessEqual     & $FFFF ; $87 <=
>aeeb	3d b9					.word Binary_Greater       & $FFFF ; $88 >
>aeed	34 b9					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>aeef	c2 b9					.word BinaryOp_Add         & $FFFF ; $8a +
>aef1	de b9					.word BinaryOp_Subtract    & $FFFF ; $8b -
>aef3	ef b9					.word BinaryOp_Multiply    & $FFFF ; $8c *
>aef5	00 ba					.word BinaryOp_Divide      & $FFFF ; $8d /
>aef7	99 af					.word NotImplemented       & $FFFF ; $8e ^
>aef9	c9 b2					.word Command_IF           & $FFFF ; $8f if
>aefb	85 b6					.word Command_WHILE        & $FFFF ; $90 while
>aefd	ad b6					.word Command_REPEAT       & $FFFF ; $91 repeat
>aeff	99 af					.word NotImplemented       & $FFFF ; $92 for
>af01	99 af					.word NotImplemented       & $FFFF ; $93 then
>af03	2c b3					.word Command_ENDIF        & $FFFF ; $94 endif
>af05	a2 b6					.word Command_WEND         & $FFFF ; $95 wend
>af07	b6 b6					.word Command_UNTIL        & $FFFF ; $96 until
>af09	99 af					.word NotImplemented       & $FFFF ; $97 next
>af0b	99 af					.word NotImplemented       & $FFFF ; $98 not
>af0d	99 af					.word NotImplemented       & $FFFF ; $99 fn(
>af0f	05 bb					.word Unary_Abs            & $FFFF ; $9a abs(
>af11	45 bc					.word Unary_Asc            & $FFFF ; $9b asc(
>af13	18 cb					.word Unary_Int            & $FFFF ; $9c int(
>af15	1f bb					.word Unary_Peek           & $FFFF ; $9d peek(
>af17	99 ca					.word Unary_Rnd            & $FFFF ; $9e rnd(
>af19	86 bb					.word Unary_Usr            & $FFFF ; $9f usr(
>af1b	84 bc					.word Unary_Left           & $FFFF ; $a0 left$(
>af1d	99 bc					.word Unary_Right          & $FFFF ; $a1 right$(
>af1f	6b bc					.word Unary_Mid            & $FFFF ; $a2 mid$(
>af21	e2 bd					.word Unary_Spc            & $FFFF ; $a3 spc(
>af23	13 bc					.word Unary_Str            & $FFFF ; $a4 str$(
>af25	a7 bb					.word Unary_Val            & $FFFF ; $a5 val(
>af27	5c bc					.word Unary_Len            & $FFFF ; $a6 len(
>af29	11 bd					.word Unary_Hex            & $FFFF ; $a7 hex$(
>af2b	99 af					.word NotImplemented       & $FFFF ; $a8 sin(
>af2d	99 af					.word NotImplemented       & $FFFF ; $a9 cos(
>af2f	99 af					.word NotImplemented       & $FFFF ; $aa tan(
>af31	99 af					.word NotImplemented       & $FFFF ; $ab atn(
>af33	99 af					.word NotImplemented       & $FFFF ; $ac exp(
>af35	99 af					.word NotImplemented       & $FFFF ; $ad log(
>af37	99 af					.word NotImplemented       & $FFFF ; $ae sqr(
>af39	67 bd					.word Unary_Dec            & $FFFF ; $af dec(
>af3b	23 bb					.word Unary_Deek           & $FFFF ; $b0 deek(
>af3d	27 bb					.word Unary_Leek           & $FFFF ; $b1 leek(
>af3f	53 bb					.word Unary_Mod            & $FFFF ; $b2 mod(
>af41	bf ba					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>af43	c4 bd					.word Unary_Chr            & $FFFF ; $b4 chr$(
>af45	99 af					.word NotImplemented       & $FFFF ; $b5 pos(
>af47	99 af					.word NotImplemented       & $FFFF ; $b6 tab(
>af49	99 af					.word NotImplemented       & $FFFF ; $b7 $
>af4b	99 af					.word NotImplemented       & $FFFF ; $b8 $(
>af4d	99 af					.word NotImplemented       & $FFFF ; $b9 #
>af4f	99 af					.word NotImplemented       & $FFFF ; $ba #(
>af51	99 af					.word NotImplemented       & $FFFF ; $bb %
>af53	99 af					.word NotImplemented       & $FFFF ; $bc %(
>af55	99 af					.word NotImplemented       & $FFFF ; $bd (
>af57	99 af					.word NotImplemented       & $FFFF ; $be )
>af59	99 af					.word NotImplemented       & $FFFF ; $bf ,
>af5b	89 b2					.word Command_COLON        & $FFFF ; $c0 :
>af5d	99 af					.word NotImplemented       & $FFFF ; $c1 ;
>af5f	99 af					.word NotImplemented       & $FFFF ; $c2 def
>af61	69 b6					.word Command_CLR          & $FFFF ; $c3 clr
>af63	7d b6					.word Command_STOP         & $FFFF ; $c4 stop
>af65	99 af					.word NotImplemented       & $FFFF ; $c5 data
>af67	99 af					.word NotImplemented       & $FFFF ; $c6 read
>af69	2d b1					.word Command_DIM          & $FFFF ; $c7 dim
>af6b	99 af					.word NotImplemented       & $FFFF ; $c8 to
>af6d	99 af					.word NotImplemented       & $FFFF ; $c9 step
>af6f	df b5					.word Command_GOSUB        & $FFFF ; $ca gosub
>af71	ed b5					.word Command_RETURN       & $FFFF ; $cb return
>af73	d9 b5					.word Command_GOTO         & $FFFF ; $cc goto
>af75	c4 b2					.word Command_END          & $FFFF ; $cd end
>af77	99 af					.word NotImplemented       & $FFFF ; $ce input
>af79	8a b2					.word Command_LET          & $FFFF ; $cf let
>af7b	32 b3					.word Command_LIST         & $FFFF ; $d0 list
>af7d	7b b5					.word Command_NEW          & $FFFF ; $d1 new
>af7f	9a b5					.word Command_OLD          & $FFFF ; $d2 old
>af81	99 af					.word NotImplemented       & $FFFF ; $d3 on
>af83	99 af					.word NotImplemented       & $FFFF ; $d4 restore
>af85	4a b5					.word Command_POKE         & $FFFF ; $d5 poke
>af87	c1 b4					.word Command_PRINT        & $FFFF ; $d6 print
>af89	f6 b1					.word Command_RUN          & $FFFF ; $d7 run
>af8b	b7 b1					.word Command_WAIT         & $FFFF ; $d8 wait
>af8d	ab b2					.word Command_SYS          & $FFFF ; $d9 sys
>af8f	4e b5					.word Command_DOKE         & $FFFF ; $da doke
>af91	52 b5					.word Command_LOKE         & $FFFF ; $db loke
>af93	32 b5					.word Command_ASSERT       & $FFFF ; $dc assert
>af95	99 af					.word NotImplemented       & $FFFF ; $dd get
>af97	26 b3					.word Command_ELSE         & $FFFF ; $de else
.af99					NotImplemented:
.af99	20 79 ae	jsr $ae79			jsr ERR_Handler
>af9c	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>afa4	65 6d 65 6e 74 65 64 00
.afac					BinaryPrecedence:
>afac	01					.byte 1    ; $80 and
>afad	01					.byte 1    ; $81 or
>afae	01					.byte 1    ; $82 xor
>afaf	01					.byte 1    ; $83 eor
>afb0	02					.byte 2    ; $84 =
>afb1	02					.byte 2    ; $85 <>
>afb2	02					.byte 2    ; $86 <
>afb3	02					.byte 2    ; $87 <=
>afb4	02					.byte 2    ; $88 >
>afb5	02					.byte 2    ; $89 >=
>afb6	03					.byte 3    ; $8a +
>afb7	03					.byte 3    ; $8b -
>afb8	04					.byte 4    ; $8c *
>afb9	04					.byte 4    ; $8d /
>afba	05					.byte 5    ; $8e ^
.afbb					KeywordText:
>afbb	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>afbe	4f d2					.byte $4f,$d2                          ; $81 or
>afc0	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>afc3	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>afc6	bd					.byte $bd                              ; $84 =
>afc7	3c be					.byte $3c,$be                          ; $85 <>
>afc9	bc					.byte $bc                              ; $86 <
>afca	3c bd					.byte $3c,$bd                          ; $87 <=
>afcc	be					.byte $be                              ; $88 >
>afcd	3e bd					.byte $3e,$bd                          ; $89 >=
>afcf	ab					.byte $ab                              ; $8a +
>afd0	ad					.byte $ad                              ; $8b -
>afd1	aa					.byte $aa                              ; $8c *
>afd2	af					.byte $af                              ; $8d /
>afd3	de					.byte $de                              ; $8e ^
>afd4	49 c6					.byte $49,$c6                          ; $8f if
>afd6	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>afdb	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>afe1	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>afe4	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>afe8	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>afed	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>aff1	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>aff6	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>affa	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>affd	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>b000	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>b004	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>b008	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>b00c	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>b011	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>b015	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>b019	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>b01f	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>b026	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>b02b	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>b02f	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>b034	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>b038	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>b03c	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>b041	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>b045	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>b049	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>b04d	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>b051	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>b055	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>b059	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>b05d	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>b061	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>b066	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>b06b	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>b06f	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>b073	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>b078	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>b07c	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>b080	a4					.byte $a4                              ; $b7 $
>b081	24 a8					.byte $24,$a8                          ; $b8 $(
>b083	a3					.byte $a3                              ; $b9 #
>b084	23 a8					.byte $23,$a8                          ; $ba #(
>b086	a5					.byte $a5                              ; $bb %
>b087	25 a8					.byte $25,$a8                          ; $bc %(
>b089	a8					.byte $a8                              ; $bd (
>b08a	a9					.byte $a9                              ; $be )
>b08b	ac					.byte $ac                              ; $bf ,
>b08c	ba					.byte $ba                              ; $c0 :
>b08d	bb					.byte $bb                              ; $c1 ;
>b08e	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>b091	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>b094	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b098	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b09c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b0a0	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b0a3	54 cf					.byte $54,$cf                          ; $c8 to
>b0a5	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b0a9	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b0ae	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b0b4	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b0b8	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b0bb	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b0c0	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b0c3	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b0c7	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b0ca	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b0cd	4f ce					.byte $4f,$ce                          ; $d3 on
>b0cf	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b0d6	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b0da	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b0df	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b0e2	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b0e6	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b0e9	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b0ed	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b0f1	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b0f7	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b0fa	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>b0fe	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.b0ff					BASIC_Start:
.b0ff	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.b102	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b105	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b107	8d 10 03	sta $0310			sta 	LocalVector
.b10a	8d 0c 03	sta $030c			sta 	UserVector
.b10d	a9 95		lda #$95			lda 	#USRDefault & $FF 			; reset USR vector
.b10f	8d 0d 03	sta $030d			sta 	UserVector+1
.b112	a9 bb		lda #$bb			lda 	#(USRDefault >> 8) & $FF
.b114	8d 0e 03	sta $030e			sta 	UserVector+2
.b117	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b119	8d 0f 03	sta $030f			sta 	UserVector+3
.b11c	20 42 be	jsr $be42			jsr 	UpdateProgramEnd 			; update the program end.
.b11f	20 69 b6	jsr $b669			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b122	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b124	9a		txs				txs
.b125	4c f6 b1	jmp $b1f6			jmp 	COMMAND_Run
.b128					WarmStart:
.b128	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b12a	9a		txs				txs
.b12b	80 fb		bra $b128			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b12d					Command_DIM:
.b12d	6b		tza				tza
.b12e	48		pha				pha 								; push on stack.
.b12f	20 b4 bf	jsr $bfb4			jsr 	VariableExtract 			; get the identifier
.b132	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b135	29 01		and #$01			and 	#1
.b137	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b139	d0 6e		bne $b1a9			bne 	_CDIError
.b13b	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b13d	8d b8 03	sta $03b8			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b140					_CDIGetDimension:
.b140	ad b8 03	lda $03b8			lda 	UsrArrayIdx 				; done too many ?
.b143	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b145	f0 62		beq $b1a9			beq 	_CDIError
.b147	20 71 b8	jsr $b871			jsr 	EvaluateInteger 			; evaluate an index size
.b14a	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b14c	29 80		and #$80			and 	#$80
.b14e	05 82		ora $82				ora 	XS_Mantissa+2
.b150	05 83		ora $83				ora 	XS_Mantissa+3
.b152	d0 55		bne $b1a9			bne 	_CDIError
.b154	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy into the array table.
.b157	18		clc				clc 								; add 1 - max index => size.
.b158	a5 80		lda $80				lda 	XS_Mantissa+0
.b15a	69 01		adc #$01			adc 	#1
.b15c	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+0,x
.b15f	a5 81		lda $81				lda 	XS_Mantissa+1
.b161	69 00		adc #$00			adc 	#0
.b163	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+1,x
.b166	30 41		bmi $b1a9			bmi 	_CDIError 					; could be dim a(32767)
.b168	e8		inx				inx 								; bump index.
.b169	e8		inx				inx
.b16a	8e b8 03	stx $03b8			stx 	UsrArrayIdx
.b16d	ea		nop				nop
.b16e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b170	1b		inz				inz
.b171	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b173	f0 cb		beq $b140			beq 	_CDIGetDimension
.b175	3b		dez				dez
.b176	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; closing ) present ?
.b179	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy USR array to default
.b17c	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b17e	9d a9 03	sta $03a9,x			sta 	ArrayDef+1,x
.b181					_CDICopy:
.b181	bd b0 03	lda $03b0,x			lda 	UsrArrayDef,x
.b184	9d a8 03	sta $03a8,x			sta 	ArrayDef,x
.b187	ca		dex				dex
.b188	10 f7		bpl $b181			bpl 	_CDICopy
.b18a	68		pla				pla									; position of array identifier
.b18b	85 10		sta $10				sta 	zTemp1
.b18d	6b		tza				tza
.b18e	48		pha				pha
.b18f	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b191	4b		taz				taz
.b192	20 b4 bf	jsr $bfb4			jsr 	VariableExtract 			; get the identifier
.b195	20 4f c2	jsr $c24f			jsr 	VariableLocate 				; check if it exists already.
.b198	b0 0f		bcs $b1a9			bcs 	_CDIError
.b19a	20 42 c0	jsr $c042			jsr 	VariableCreate 				; create it using the current ArrayDef
.b19d	68		pla				pla 								; restore code position
.b19e	4b		taz				taz
.b19f	ea		nop				nop
.b1a0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1a2	1b		inz				inz
.b1a3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b1a5	f0 86		beq $b12d			beq 	Command_DIM
.b1a7	3b		dez				dez
.b1a8	60		rts				rts
.b1a9					_CDIError:
.b1a9	20 79 ae	jsr $ae79			jsr ERR_Handler
>b1ac	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b1b4					_CDISyntax:
.b1b4	4c 4a ae	jmp $ae4a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.b1b7					Command_WAIT:
.b1b7	20 71 b8	jsr $b871			jsr		EvaluateInteger 			; address
.b1ba	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.b1bc	20 ac be	jsr $beac			jsr 	CheckNextComma
.b1bf	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX
.b1c2	a9 00		lda #$00			lda 	#0							; set default xor.
.b1c4	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.b1c6	ea		nop				nop
.b1c7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1c9	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.b1cb	d0 06		bne $b1d3			bne 	_CWAXorDefault
.b1cd	1b		inz				inz
.b1ce	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.b1d0	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX
.b1d3					_CWAXorDefault:
.b1d3	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.b1d5	85 1a		sta $1a				sta 	zLTemp1
.b1d7	a5 81		lda $81				lda 	XS_Mantissa+1
.b1d9	85 1b		sta $1b				sta 	zLTemp1+1
.b1db	a5 82		lda $82				lda 	XS_Mantissa+2
.b1dd	85 1c		sta $1c				sta 	zLTemp1+2
.b1df					_CWAWaitLoop:
.b1df	20 47 ae	jsr $ae47			jsr 	CheckBreak 					; exit on break.
.b1e2	c9 00		cmp #$00			cmp 	#0
.b1e4	d0 0f		bne $b1f5			bne 	_CWAWaitExit
.b1e6	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.b1e8	a2 00		ldx #$00			ldx 	#0
.b1ea	5a		phy				phy 								; this is the same routine as PEEK.
.b1eb	20 1a be	jsr $be1a			jsr 	MemRead
.b1ee	7a		ply				ply
.b1ef	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.b1f1	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.b1f3	f0 ea		beq $b1df			beq 	_CWAWaitLoop
.b1f5					_CWAWaitExit:
.b1f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b1f6					Command_RUN:
.b1f6	20 69 b6	jsr $b669			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b1f9	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b1fb	85 16		sta $16				sta 	zCodePtr+0
.b1fd	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b1ff	85 17		sta $17				sta 	zCodePtr+1
.b201	a9 02		lda #$02			lda 	#2
.b203	85 18		sta $18				sta 	zCodePtr+2
.b205	a9 00		lda #$00			lda 	#0
.b207	85 19		sta $19				sta 	zCodePtr+3
.b209	a3 03		ldz #$03			ldz 	#3
.b20b					RUN_NewLine:
.b20b	a3 00		ldz #$00			ldz 	#0
.b20d	ea		nop				nop
.b20e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b210	1b		inz				inz
.b211	1b		inz				inz
.b212	1b		inz				inz
.b213	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b215	d0 18		bne $b22f			bne 	RUN_NextCommand
.b217	4c c4 b2	jmp $b2c4			jmp 	Command_END 				; go do the command code.
.b21a					RUN_Skip:
.b21a	ea		nop				nop
.b21b	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b21d	1b		inz				inz 								; skip
.b21e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b220	90 0d		bcc $b22f			bcc 	_SEDone 					; so just skip over it.
.b222	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b224	90 08		bcc $b22e			bcc 	_SEDouble
.b226	6b		tza				tza 								; this is Y + 1
.b227	18		clc				clc
.b228	ea		nop				nop
.b229	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b22b	4b		taz				taz 								; back in Y.
.b22c	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b22d	3b		dez				dez
.b22e					_SEDouble:
.b22e	1b		inz				inz
.b22f					_SEDone:
.b22f					RUN_NextCommand:
.b22f	ad a7 03	lda $03a7			lda 	BreakCount 					; break counter
.b232	69 10		adc #$10			adc 	#16 						; one time in 16
.b234	8d a7 03	sta $03a7			sta 	BreakCount
.b237	90 0a		bcc $b243			bcc 	RUN_NoCheckBreak
.b239	20 47 ae	jsr $ae47			jsr 	CheckBreak 					; check for break
.b23c	c9 00		cmp #$00			cmp 	#0
.b23e	f0 03		beq $b243			beq 	RUN_NoCheckBreak
.b240	4c 7d b6	jmp $b67d			jmp 	Command_STOP 				; stop on BREAK.
.b243					RUN_NoCheckBreak:
.b243	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b245	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b247	ea		nop				nop
.b248	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b24a	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b24c	f0 cc		beq $b21a			beq 	RUN_Skip
.b24e	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b250	d0 10		bne $b262			bne 	RUN_Execute
.b252					RUN_NextLine:
.b252	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b254	ea		nop				nop
.b255	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b257	18		clc				clc
.b258	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b25a	85 16		sta $16				sta 	zCodePtr
.b25c	90 02		bcc $b260			bcc 	_SNLNoCarry
.b25e	e6 17		inc $17				inc 	zCodePtr+1
.b260					_SNLNoCarry:
.b260	80 a9		bra $b20b			bra 	RUN_NewLine 				; go do the new line code
.b262					RUN_Execute:
.b262	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b264	b0 1c		bcs $b282			bcs 	RUN_Extension
.b266	1b		inz				inz
.b267	0a		asl a				asl 	a 							; double the character read.
.b268	90 12		bcc $b27c			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b26a	aa		tax				tax 								; ready to look up.
.b26b	bd db ae	lda $aedb,x			lda 	VectorTable,x 				; copy address into LocalVector
.b26e	8d 11 03	sta $0311			sta 	LocalVector+1
.b271	bd dc ae	lda $aedc,x			lda 	VectorTable+1,x
.b274	8d 12 03	sta $0312			sta 	LocalVector+2
.b277	20 ba b7	jsr $b7ba			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b27a	80 b3		bra $b22f			bra 	RUN_NextCommand 			; do the next command.
.b27c					RUN_Default:
.b27c	3b		dez				dez
.b27d	20 8a b2	jsr $b28a			jsr 	Command_LET 				; and try LET.
.b280	80 ad		bra $b22f			bra 	RUN_NextCommand
.b282					RUN_Extension:
.b282	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b284	f0 94		beq $b21a			beq 	RUN_Skip 					; skip over it.
.b286	4c 4a ae	jmp $ae4a			jmp 	SyntaxError
.b289					Command_COLON:
.b289	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b28a					Command_LET:
.b28a	20 49 bf	jsr $bf49			jsr 	VariableFind 				; get reference to one variable.
.b28d	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b28f	20 8b be	jsr $be8b			jsr 	CheckNextToken
.b292	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b294	48		pha				pha
.b295	a5 23		lda $23				lda 	zVarDataPtr+1
.b297	48		pha				pha
.b298	a5 24		lda $24				lda 	zVarType
.b29a	48		pha				pha
.b29b	20 d4 b6	jsr $b6d4			jsr 	EvaluateExpression 			; evaluate the RHS.
.b29e	68		pla				pla 								; restore target variable information.
.b29f	85 24		sta $24				sta 	zVarType
.b2a1	68		pla				pla
.b2a2	85 23		sta $23				sta 	zVarDataPtr+1
.b2a4	68		pla				pla
.b2a5	85 22		sta $22				sta 	zVarDataPtr
.b2a7	20 e4 c2	jsr $c2e4			jsr 	VariableSet 				; set the value out.
.b2aa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.b2ab					Command_SYS:
.b2ab	20 71 b8	jsr $b871			jsr 	EvaluateInteger 			; address
.b2ae	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.b2b0	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.b2b3	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.b2b5	8d 11 03	sta $0311			sta 	LocalVector+1
.b2b8	a5 82		lda $82				lda 	XS_Mantissa+2
.b2ba	8d 12 03	sta $0312			sta 	LocalVector+2
.b2bd	20 c1 b2	jsr $b2c1			jsr 	_CSYLocalCall
.b2c0	60		rts				rts
.b2c1					_CSYLocalCall:
.b2c1	6c 10 03	jmp ($0310)			jmp 	(LocalVector)

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b2c4					Command_END:
.b2c4	80 fe		bra $b2c4	_halt:	bra 		_halt
.b2c6	4c 28 b1	jmp $b128			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.b2c9					Command_IF:
.b2c9	20 71 b8	jsr $b871			jsr 	EvaluateInteger 			; check success.
.b2cc	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b2ce	05 81		ora $81				ora 	XS_Mantissa+1
.b2d0	05 82		ora $82				ora 	XS_Mantissa+2
.b2d2	05 83		ora $83				ora 	XS_Mantissa+3
.b2d4	aa		tax				tax 								; put into X.
.b2d5	ea		nop				nop
.b2d6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2d8	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.b2da	d0 30		bne $b30c			bne 	_FIFExtended
.b2dc	1b		inz				inz
.b2dd	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.b2df	f0 0c		beq $b2ed			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.b2e1	ea		nop				nop
.b2e2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2e4	29 c0		and #$c0			and 	#$C0 						; is it a number
.b2e6	c9 40		cmp #$40			cmp 	#$40
.b2e8	d0 21		bne $b30b			bne 	_FIFContinue 				; if not, do what ever follows.
.b2ea	4c d9 b5	jmp $b5d9			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.b2ed					_FIFEndOfLine:
.b2ed	ea		nop				nop
.b2ee	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2f0	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.b2f2	f0 17		beq $b30b			beq 	_FIFContinue
.b2f4	ea		nop				nop
.b2f5	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b2f7	1b		inz				inz 								; skip
.b2f8	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b2fa	90 0d		bcc $b309			bcc 	_SEDone 					; so just skip over it.
.b2fc	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b2fe	90 08		bcc $b308			bcc 	_SEDouble
.b300	6b		tza				tza 								; this is Y + 1
.b301	18		clc				clc
.b302	ea		nop				nop
.b303	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b305	4b		taz				taz 								; back in Y.
.b306	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b307	3b		dez				dez
.b308					_SEDouble:
.b308	1b		inz				inz
.b309					_SEDone:
.b309	80 e2		bra $b2ed			bra 	_FIFEndOfLine
.b30b					_FIFContinue:
.b30b	60		rts				rts
.b30c					_FIFExtended:
.b30c	da		phx				phx 								; save result
.b30d	a9 30		lda #$30			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.b30f	20 c1 ad	jsr $adc1			jsr 	StackPushFrame
.b312	68		pla				pla 								; restore result
.b313	f0 01		beq $b316			beq 	_FIXSkip 					; if zero then it has failed.
.b315	60		rts				rts 								; test passed, so continue executing
.b316					_FIXSkip:
.b316	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.b318	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.b31a	20 1f ad	jsr $ad1f			jsr 	StructureSearchDouble
.b31d	ea		nop				nop
.b31e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b320	1b		inz				inz
.b321	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.b323	f0 07		beq $b32c			beq 	Command_ENDIF
.b325	60		rts				rts
.b326					Command_ELSE:
.b326	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.b328	20 1d ad	jsr $ad1d			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.b32b	1b		inz				inz
.b32c					Command_ENDIF:
.b32c	a9 30		lda #$30			lda 	#(SMark_If << 4)
.b32e	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b331	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b332					Command_LIST:
.b332	20 55 b4	jsr $b455			jsr 	ListGetRange				; get any parameters
.b335	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b337	85 16		sta $16				sta 	zCodePtr+0
.b339	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b33b	85 17		sta $17				sta 	zCodePtr+1
.b33d	a9 02		lda #$02			lda 	#2
.b33f	85 18		sta $18				sta 	zCodePtr+2
.b341	a9 00		lda #$00			lda 	#0
.b343	85 19		sta $19				sta 	zCodePtr+3
.b345	a3 03		ldz #$03			ldz 	#3
.b347					_CILLoop:
.b347	a3 00		ldz #$00			ldz 	#0
.b349	ea		nop				nop
.b34a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b34c	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b34e	f0 24		beq $b374			beq 	_CILExit
.b350	20 47 ae	jsr $ae47			jsr 	CheckBreak 					; check break
.b353	c9 00		cmp #$00			cmp 	#0
.b355	d0 1d		bne $b374			bne 	_CILExit
.b357	20 9f b4	jsr $b49f			jsr 	ListCheckRange 				; check current line in range.
.b35a	b0 08		bcs $b364			bcs		_CILNext
.b35c	a3 00		ldz #$00			ldz 	#0
.b35e	1b		inz				inz
.b35f	1b		inz				inz
.b360	1b		inz				inz
.b361	20 77 b3	jsr $b377			jsr 	ListLine 					; list one line.
.b364					_CILNext:
.b364	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b366	ea		nop				nop
.b367	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b369	18		clc				clc
.b36a	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b36c	85 16		sta $16				sta 	zCodePtr
.b36e	90 02		bcc $b372			bcc 	_SNLNoCarry
.b370	e6 17		inc $17				inc 	zCodePtr+1
.b372					_SNLNoCarry:
.b372	80 d3		bra $b347			bra 	_CILLoop
.b374					_CILExit:
.b374	4c 28 b1	jmp $b128			jmp 	WarmStart
.b377					ListLine:
.b377	a3 00		ldz #$00			ldz 	#0
.b379	1b		inz				inz
.b37a	ea		nop				nop
.b37b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b37d	85 80		sta $80				sta 	XS_Mantissa
.b37f	1b		inz				inz
.b380	ea		nop				nop
.b381	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b383	85 81		sta $81				sta 	XS_Mantissa+1
.b385	20 bd ae	jsr $aebd			jsr 	Print16BitInteger 			; print integer.
.b388	aa		tax				tax 								; print spaces to column 6
.b389					_LISpace:
.b389	a9 20		lda #$20			lda 	#" "
.b38b	20 41 ae	jsr $ae41			jsr 	CharPrint
.b38e	e8		inx				inx
.b38f	e0 06		cpx #$06			cpx 	#6
.b391	d0 f6		bne $b389			bne 	_LISpace
.b393					_LIDecode:
.b393	1b		inz				inz
.b394	ea		nop				nop
.b395	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b397	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b399	f0 0f		beq $b3aa			beq 	_LIExit
.b39b	30 12		bmi $b3af			bmi 	_LIToken
.b39d	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b39f	b0 52		bcs $b3f3			bcs 	_LIInteger
.b3a1	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b3a3	69 20		adc #$20			adc 	#$20
.b3a5	20 48 b4	jsr $b448			jsr 	ListPrintLC 				; print in LC
.b3a8	80 e9		bra $b393			bra 	_LIDecode
.b3aa					_LIExit:
.b3aa	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b3ac	4c 41 ae	jmp $ae41			jmp 	CharPrint
.b3af					_LIToken:
.b3af	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b3b1	90 4b		bcc $b3fe			bcc		_LICommandToken
.b3b3	48		pha				pha 								; save in case end
.b3b4	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b3b6	c9 fe		cmp #$fe			cmp 	#$FE
.b3b8	f0 17		beq $b3d1			beq 	_LIPrint
.b3ba	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b3bc	c9 fd		cmp #$fd			cmp 	#$FD
.b3be	f0 11		beq $b3d1			beq 	_LIPrint
.b3c0	a9 52		lda #$52			lda 	#'R'						; must be REM
.b3c2	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b3c5	a9 45		lda #$45			lda 	#'E'
.b3c7	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b3ca	a9 4d		lda #$4d			lda 	#'M'
.b3cc	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b3cf	a2 20		ldx #$20			ldx 	#' '
.b3d1					_LIPrint:
.b3d1	8a		txa				txa
.b3d2	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b3d5	1b		inz				inz
.b3d6	ea		nop				nop
.b3d7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3d9	aa		tax				tax 								; put in X
.b3da	ca		dex				dex
.b3db					_LILoop:
.b3db	ca		dex				dex 								; exit when count reached zero.
.b3dc	f0 09		beq $b3e7			beq 	_LIEnd
.b3de	1b		inz				inz
.b3df	ea		nop				nop
.b3e0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3e2	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b3e5	80 f4		bra $b3db			bra 	_LILoop
.b3e7	68		pla		_LIEnd:	pla 								; get A back
.b3e8	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b3ea	d0 a7		bne $b393			bne 	_LIDecode
.b3ec	a9 22		lda #$22			lda 	#'"'
.b3ee	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b3f1	80 a0		bra $b393			bra 	_LIDecode
.b3f3					_LIInteger:
.b3f3	a2 00		ldx #$00			ldx 	#0
.b3f5	20 df b7	jsr $b7df			jsr 	EvaluateGetInteger 			; get an atom
.b3f8	3b		dez				dez
.b3f9	20 c3 ae	jsr $aec3			jsr 	Print32BitInteger 			; print integer.
.b3fc	80 95		bra $b393			bra 	_LIDecode
.b3fe					_LICommandToken:
.b3fe	5a		phy				phy 								; save Y
.b3ff	48		pha				pha 								; save token
.b400	a2 bb		ldx #$bb			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b402	a9 af		lda #$af			lda 	(#KeywordText >> 8) & $FF
.b404	86 1a		stx $1a				stx 	zLTemp1
.b406	85 1b		sta $1b				sta 	zLTemp1+1
.b408	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b40a	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b40c	68		pla				pla 								; get token, chuck bit 7.
.b40d	29 7f		and #$7f			and 	#127
.b40f	f0 16		beq $b427			beq 	_LIFoundToken
.b411	aa		tax				tax
.b412					_LITokenLoop:
.b412	a0 00		ldy #$00			ldy 	#0
.b414					_LIFindEnd:
.b414	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b416	c8		iny				iny
.b417	0a		asl a				asl 	a
.b418	90 fa		bcc $b414			bcc 	_LIFindEnd
.b41a	98		tya				tya 								; that is step to the next
.b41b	18		clc				clc 								; we don't bother bumping the 3rd byte
.b41c	65 1a		adc $1a				adc 	zLTemp1 					; here.
.b41e	85 1a		sta $1a				sta 	zLTemp1
.b420	90 02		bcc $b424			bcc 	_LINoBump
.b422	e6 1b		inc $1b				inc 	zLTemp1+1
.b424					_LINoBump:
.b424	ca		dex				dex 								; no go round again.
.b425	d0 eb		bne $b412			bne 	_LITokenLoop
.b427					_LIFoundToken:
.b427	a0 00		ldy #$00			ldy 	#0
.b429					_LIPrintToken:
.b429	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b42b	c8		iny				iny
.b42c	48		pha				pha 								; save it
.b42d	29 7f		and #$7f			and 	#$7F
.b42f	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b432	68		pla				pla
.b433	10 f4		bpl $b429			bpl 	_LIPrintToken 				; go back if not end
.b435	7a		ply				ply 								; restore Y
.b436	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b438	c9 41		cmp #$41			cmp 	#"A"
.b43a	90 09		bcc $b445			bcc 	_LINotLetter
.b43c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b43e	b0 05		bcs $b445			bcs 	_LINotLetter
.b440	a9 20		lda #$20			lda 	#" " 						; add spacing
.b442	20 48 b4	jsr $b448			jsr 	ListPrintLC
.b445					_LINotLetter:
.b445	4c 93 b3	jmp $b393			jmp 	_LIDecode
.b448					ListPrintLC:
.b448	c9 41		cmp #$41			cmp 	#"A"
.b44a	90 06		bcc $b452			bcc 	_LPLC0
.b44c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b44e	b0 02		bcs $b452			bcs 	_LPLC0
.b450	69 20		adc #$20			adc 	#$20
.b452	4c 41 ae	jmp $ae41	_LPLC0:	jmp 	CharPrint
.b455					ListGetRange:
.b455	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.b457					_LGRClear:
.b457	a9 00		lda #$00			lda 	#0
.b459	95 80		sta $80,x			sta 	XS_Mantissa,x
.b45b	ca		dex				dex
.b45c	10 f9		bpl $b457			bpl 	_LGRClear
.b45e	ea		nop				nop
.b45f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b461	c9 00		cmp #$00			cmp 	#0 							; nothing
.b463	f0 22		beq $b487			beq 	_LGRBlank
.b465	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.b467	f0 1e		beq $b487			beq 	_LGRBlank
.b469	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.b46b	f0 19		beq $b486			beq 	_LGREnd 					; then it's LIST ,x
.b46d	20 71 b8	jsr $b871			jsr 	EvaluateInteger 			; get the first number into bottom
.b470	ea		nop				nop
.b471	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b473	c9 bf		cmp #$bf			cmp 	#token_Comma
.b475	f0 0f		beq $b486			beq 	_LGREnd 					; then it is LIST a,b
.b477	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.b479	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.b47b	a5 81		lda $81				lda 	XS_Mantissa+1
.b47d	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b47f					_LGRBumpExit:
.b47f	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.b481	d0 02		bne $b485			bne 	_LGRBump2
.b483	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.b485					_LGRBump2:
.b485	60		rts				rts
.b486					_LGREnd:
.b486	1b		inz				inz
.b487					_LGRBlank:
.b487	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.b489	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.b48b	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b48d	ea		nop				nop
.b48e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b490	c9 00		cmp #$00			cmp 	#0
.b492	f0 f1		beq $b485			beq 	_LGRBump2
.b494	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.b495	b0 ee		bcs $b485			bcs 	_LGRBump2
.b497	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.b499	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX
.b49c	80 e1		bra $b47f			bra 	_LGRBumpExit
.b49e	60		rts				rts
.b49f					ListCheckRange:
.b49f	1b		inz				inz
.b4a0	a2 00		ldx #$00			ldx 	#0 							; test low
.b4a2	20 af b4	jsr $b4af			jsr 	_LCRCompare
.b4a5	90 06		bcc $b4ad			bcc 	_LCRFail
.b4a7	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.b4a9	20 af b4	jsr $b4af			jsr 	_LCRCompare
.b4ac	60		rts				rts
.b4ad					_LCRFail:
.b4ad	38		sec				sec
.b4ae	60		rts				rts
.b4af					_LCRCompare:
.b4af	ea		nop				nop
.b4b0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4b2	38		sec				sec
.b4b3	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.b4b5	08		php				php
.b4b6	1b		inz				inz
.b4b7	ea		nop				nop
.b4b8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4ba	28		plp				plp
.b4bb	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.b4bd	08		php				php
.b4be	3b		dez				dez
.b4bf	28		plp				plp
.b4c0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b4c1					Command_PRINT:
.b4c1	ea		nop				nop
.b4c2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4c4	c9 00		cmp #$00			cmp 	#0 							; end
.b4c6	f0 66		beq $b52e			beq 	_CPR_NewLine
.b4c8	c9 c0		cmp #$c0			cmp 	#token_Colon
.b4ca	f0 62		beq $b52e			beq 	_CPR_NewLine
.b4cc	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b4ce	f0 50		beq $b520			beq 	_CPR_Skip
.b4d0	c9 bf		cmp #$bf			cmp 	#token_Comma
.b4d2	f0 49		beq $b51d			beq 	_CPR_Tab
.b4d4	20 d4 b6	jsr $b6d4			jsr 	EvaluateExpression 			; get expression.
.b4d7	a5 85		lda $85				lda 	XS_Type 					; get type.
.b4d9	29 02		and #$02			and 	#2
.b4db	d0 24		bne $b501			bne 	_CPR_String 				; if type = 2 output as string.
.b4dd					_CPR_Number:
.b4dd	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b4df	8d 14 03	sta $0314			sta 	NumBufX
.b4e2	a5 85		lda $85				lda 	XS_Type 					; get type
.b4e4	4a		lsr a				lsr 	a
.b4e5	b0 05		bcs $b4ec			bcs 	_CPRInt 					; if msb set do as integer
.b4e7	20 64 c9	jsr $c964			jsr 	FPToString 					; call fp to str otherwise
.b4ea	80 03		bra $b4ef			bra 	_CPRNPrint
.b4ec	20 2d c4	jsr $c42d	_CPRInt:jsr 	IntToString
.b4ef					_CPRNPrint:
.b4ef	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b4f2	c9 2d		cmp #$2d			cmp 	#"-"
.b4f4	f0 05		beq $b4fb			beq 	_CPRNoSpace
.b4f6	a9 20		lda #$20			lda 	#" "						; print the leading space
.b4f8	20 41 ae	jsr $ae41			jsr 	CharPrint 					; so beloved of MS Basics.
.b4fb					_CPRNoSpace:
.b4fb	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b4fd	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b4ff	80 04		bra $b505			bra 	_CPRPrint
.b501					_CPR_String:
.b501	a6 80		ldx $80				ldx 	XS_Mantissa
.b503	a5 81		lda $81				lda 	XS_Mantissa+1
.b505					_CPRPrint:
.b505	86 1e		stx $1e				stx 	zGenPtr
.b507	85 1f		sta $1f				sta 	zGenPtr+1
.b509	5a		phy				phy
.b50a	a0 00		ldy #$00			ldy 	#0							; get length into X
.b50c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b50e	aa		tax				tax
.b50f	f0 09		beq $b51a			beq 	_CPREndPrint 				; nothing to print
.b511					_CPRLoop:
.b511	c8		iny				iny
.b512	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b514	20 41 ae	jsr $ae41			jsr 	CharPrint
.b517	ca		dex				dex
.b518	d0 f7		bne $b511			bne 	_CPRLoop
.b51a					_CPREndPrint:
.b51a	7a		ply				ply
.b51b	80 a4		bra $b4c1			bra 	Command_Print
.b51d					_CPR_Tab:
.b51d	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b520					_CPR_Skip:
.b520	1b		inz				inz
.b521	ea		nop				nop
.b522	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b524	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b526	f0 09		beq $b531			beq 	_CPR_Exit
.b528	c9 00		cmp #$00			cmp 	#0
.b52a	d0 95		bne $b4c1			bne 	Command_PRINT 				; if not go round again.
.b52c	80 03		bra $b531			bra 	_CPR_Exit
.b52e					_CPR_NewLine:
.b52e	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b531					_CPR_Exit:
.b531	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b532					Command_ASSERT:
.b532	20 71 b8	jsr $b871			jsr 	EvaluateInteger 			; calculate thing being asserted
.b535	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b537	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b539	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b53b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b53d	f0 01		beq $b540			beq 	_ASFail
.b53f	60		rts				rts
.b540					_ASFail:
.b540	20 79 ae	jsr $ae79			jsr ERR_Handler
>b543	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.b54a					Command_POKE:
.b54a	a9 01		lda #$01			lda 	#1
.b54c	80 06		bra $b554			bra 	CmdPoke_Main
.b54e					Command_DOKE:
.b54e	a9 02		lda #$02			lda 	#2
.b550	80 02		bra $b554			bra 	CmdPoke_Main
.b552					Command_LOKE:
.b552	a9 04		lda #$04			lda 	#4
.b554					CmdPoke_Main:
.b554	48		pha				pha
.b555	20 71 b8	jsr $b871			jsr 	EvaluateInteger 			; get two parameters.
.b558	e8		inx				inx
.b559	e8		inx				inx
.b55a	e8		inx				inx
.b55b	e8		inx				inx
.b55c	e8		inx				inx
.b55d	e8		inx				inx
.b55e	20 ac be	jsr $beac			jsr 	CheckNextComma
.b561	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX
.b564	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.b566	85 1a		sta $1a				sta 	zLTemp1
.b568	a5 81		lda $81				lda 	XS_Mantissa+1
.b56a	85 1b		sta $1b				sta 	zLTemp1+1
.b56c	a5 82		lda $82				lda 	XS_Mantissa+2
.b56e	85 1c		sta $1c				sta 	zLTemp1+2
.b570	a5 83		lda $83				lda 	XS_Mantissa+3
.b572	85 1d		sta $1d				sta 	zLTemp1+3
.b574	68		pla				pla 								; get count
.b575	5a		phy				phy 								; save Y
.b576	20 2e be	jsr $be2e			jsr 	MemWrite 					; write it out
.b579	7a		ply				ply 								; restore Y and done.
.b57a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.b57b					Command_NEW:
.b57b	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b57d	85 16		sta $16				sta 	zCodePtr+0
.b57f	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b581	85 17		sta $17				sta 	zCodePtr+1
.b583	a9 02		lda #$02			lda 	#2
.b585	85 18		sta $18				sta 	zCodePtr+2
.b587	a9 00		lda #$00			lda 	#0
.b589	85 19		sta $19				sta 	zCodePtr+3
.b58b	a3 03		ldz #$03			ldz 	#3
.b58d	a3 00		ldz #$00			ldz 	#0
.b58f	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.b591	ea		nop				nop
.b592	92 16		sta ($16),z			sta 	(zCodePtr),z
.b594	20 42 be	jsr $be42			jsr 	UpdateProgramEnd 			; update program end.
.b597	4c 28 b1	jmp $b128			jmp 	WarmStart
.b59a					Command_OLD:
.b59a	ea		nop				nop
.b59b	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b59d	85 16		sta $16				sta 	zCodePtr+0
.b59f	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b5a1	85 17		sta $17				sta 	zCodePtr+1
.b5a3	a9 02		lda #$02			lda 	#2
.b5a5	85 18		sta $18				sta 	zCodePtr+2
.b5a7	a9 00		lda #$00			lda 	#0
.b5a9	85 19		sta $19				sta 	zCodePtr+3
.b5ab	a3 03		ldz #$03			ldz 	#3
.b5ad					_COL_Find:
.b5ad	ea		nop				nop
.b5ae	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5b0	1b		inz				inz
.b5b1	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.b5b3	f0 18		beq $b5cd			beq 	_COL_Found
.b5b5	6b		tza				tza
.b5b6	c9 00		cmp #$00			cmp 	#0
.b5b8	d0 f3		bne $b5ad			bne 	_COL_Find 					; can't find old EOL, give up.
.b5ba	20 79 ae	jsr $ae79			jsr ERR_Handler
>b5bd	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>b5c5	43 6f 72 72 75 70 74 00
.b5cd					_COL_Found:
.b5cd	6b		tza				tza
.b5ce	48		pha				pha
.b5cf	a3 00		ldz #$00			ldz 	#0
.b5d1	68		pla				pla
.b5d2	ea		nop				nop
.b5d3	92 16		sta ($16),z			sta 	(zCodePtr),z
.b5d5	20 42 be	jsr $be42			jsr 	UpdateProgramEnd 			; reset variable pointer
.b5d8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b5d9					Command_GOTO:
.b5d9	20 f6 b5	jsr $b5f6			jsr 	GotoGetLineNumber
.b5dc	4c 13 b6	jmp $b613			jmp 	GotoChangeToLineNumber
.b5df					Command_GOSUB:
.b5df	20 f6 b5	jsr $b5f6			jsr 	GotoGetLineNumber
.b5e2	20 08 ae	jsr $ae08			jsr 	StackSavePosition
.b5e5	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.b5e7	20 c1 ad	jsr $adc1			jsr 	StackPushFrame
.b5ea	4c 13 b6	jmp $b613			jmp 	GotoChangeToLineNumber
.b5ed					Command_RETURN:
.b5ed	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.b5ef	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b5f2	20 25 ae	jsr $ae25			jsr 	StackRestorePosition
.b5f5	60		rts				rts
.b5f6					GotoGetLineNumber:
.b5f6	20 71 b8	jsr $b871			jsr 	EvaluateInteger
.b5f9	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b5fb	05 83		ora $83				ora 	XS_Mantissa+3
.b5fd	d0 01		bne $b600			bne 	_GLINError
.b5ff	60		rts				rts
.b600					_GLINError:
.b600	20 79 ae	jsr $ae79			jsr ERR_Handler
>b603	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b60b	20 4e 75 6d 62 65 72 00
.b613					GotoChangeToLineNumber:
.b613	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.b615	05 81		ora $81				ora 	XS_Mantissa+1
.b617	f0 3d		beq $b656			beq 	_GCTLFail
.b619	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b61b	85 16		sta $16				sta 	zCodePtr+0
.b61d	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b61f	85 17		sta $17				sta 	zCodePtr+1
.b621	a9 02		lda #$02			lda 	#2
.b623	85 18		sta $18				sta 	zCodePtr+2
.b625	a9 00		lda #$00			lda 	#0
.b627	85 19		sta $19				sta 	zCodePtr+3
.b629	a3 03		ldz #$03			ldz 	#3
.b62b					_GCTLLoop:
.b62b	a3 00		ldz #$00			ldz 	#0
.b62d	ea		nop				nop
.b62e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b630	c9 00		cmp #$00			cmp 	#0
.b632	f0 22		beq $b656			beq 	_GCTLFail
.b634	1b		inz				inz
.b635	ea		nop				nop
.b636	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b638	c5 80		cmp $80				cmp 	XS_Mantissa+0
.b63a	d0 08		bne $b644			bne 	_GCTLNext
.b63c	1b		inz				inz
.b63d	ea		nop				nop
.b63e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b640	c5 81		cmp $81				cmp 	XS_Mantissa+1
.b642	f0 10		beq $b654			beq 	_GCTLExit
.b644					_GCTLNext:
.b644	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b646	ea		nop				nop
.b647	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b649	18		clc				clc
.b64a	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b64c	85 16		sta $16				sta 	zCodePtr
.b64e	90 02		bcc $b652			bcc 	_SNLNoCarry
.b650	e6 17		inc $17				inc 	zCodePtr+1
.b652					_SNLNoCarry:
.b652	80 d7		bra $b62b			bra 	_GCTLLoop 					; try next line.
.b654					_GCTLExit:
.b654	1b		inz				inz
.b655	60		rts				rts
.b656					_GCTLFail:
.b656	20 79 ae	jsr $ae79			jsr ERR_Handler
>b659	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b661	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b669					Command_CLR:
.b669					ResetRunStatus:
.b669	20 85 bf	jsr $bf85			jsr 	VariableClear
.b66c	20 af ad	jsr $adaf			jsr 	StackReset
.b66f	a9 00		lda #$00			lda 	#HighMemory & $FF
.b671	8d 00 03	sta $0300			sta 	StringPtr
.b674	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.b676	8d 01 03	sta $0301			sta 	StringPtr+1
.b679	20 51 c1	jsr $c151			jsr 	ArrayResetDefault
.b67c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b67d					Command_STOP:
.b67d	20 79 ae	jsr $ae79			jsr ERR_Handler
>b680	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.b685					Command_WHILE:
.b685	20 08 ae	jsr $ae08			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.b688	20 71 b8	jsr $b871			jsr 	EvaluateInteger 			; calculate the while loop value.
.b68b	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b68d	05 81		ora $81				ora 	XS_Mantissa+1
.b68f	05 82		ora $82				ora 	XS_Mantissa+2
.b691	05 83		ora $83				ora 	XS_Mantissa+3
.b693	f0 06		beq $b69b			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.b695	a9 25		lda #$25			lda 	#(SMark_While << 4)+SourcePosSize
.b697	20 c1 ad	jsr $adc1			jsr 	StackPushFrame 				; push on stack
.b69a	60		rts				rts
.b69b					_CWHSkip:
.b69b	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.b69d	20 1d ad	jsr $ad1d			jsr 	StructureSearchSingle
.b6a0	1b		inz				inz
.b6a1	60		rts				rts
.b6a2					Command_WEND:
.b6a2	a9 20		lda #$20			lda 	#(SMark_While << 4)			; remove the frame
.b6a4	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b6a7	20 25 ae	jsr $ae25			jsr 	StackRestorePosition
.b6aa	80 d9		bra $b685			bra 	Command_WHILE 				; and do the while again.
.b6ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.b6ad					Command_REPEAT:
.b6ad	20 08 ae	jsr $ae08			jsr 	StackSavePosition			; save position into stack
.b6b0	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b6b2	20 c1 ad	jsr $adc1			jsr 	StackPushFrame 				; push on stack
.b6b5	60		rts				rts
.b6b6					Command_UNTIL:
.b6b6	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.b6b8	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b6bb	20 71 b8	jsr $b871			jsr 	EvaluateInteger				; work out UNTIL
.b6be	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.b6c0	05 81		ora $81				ora 	XS_Mantissa+1
.b6c2	05 82		ora $82				ora 	XS_Mantissa+2
.b6c4	05 83		ora $83				ora 	XS_Mantissa+3
.b6c6	d0 08		bne $b6d0			bne 	_CUTExit 					; if not, just exit
.b6c8	20 25 ae	jsr $ae25			jsr 	StackRestorePosition 		; otherwise loop round again.
.b6cb	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b6cd	20 c1 ad	jsr $adc1			jsr 	StackPushFrame 				; fix the stack back.
.b6d0					_CUTExit:
.b6d0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b6d1					EVESyntax:
.b6d1	4c 4a ae	jmp $ae4a			jmp 	SyntaxError
.b6d4					EvaluateExpression:
.b6d4	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b6d6					EvaluateExpressionX:
.b6d6	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b6d8					EvaluateExpressionXA:
.b6d8	48		pha				pha 								; save precedence on stack.
.b6d9	ea		nop				nop
.b6da	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6dc	f0 f3		beq $b6d1			beq 	EVESyntax 					; end of line, syntax error.
.b6de	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b6e0	b0 03		bcs $b6e5			bcs 	_EVNotVariable
.b6e2	4c b1 b7	jmp $b7b1			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b6e5					_EVNotVariable:
.b6e5	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b6e7	90 e8		bcc $b6d1			bcc 	EVESyntax
.b6e9	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b6eb	b0 59		bcs $b746			bcs 	_EVNotInteger
.b6ed	20 df b7	jsr $b7df			jsr 	EvaluateGetInteger
.b6f0					_EVCheckDecimal:
.b6f0	ea		nop				nop
.b6f1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6f3	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b6f5	d0 05		bne $b6fc			bne 	_EVGotAtom 					; no, get atom.
.b6f7					_EVIsDecimal:
.b6f7	20 07 b8	jsr $b807			jsr 	EVGetDecimal 				; extend to the decimal part.
.b6fa	80 00		bra $b6fc			bra 	_EVGotAtom 					; and continue to got atom.
.b6fc					_EVGotAtom:
.b6fc	ea		nop				nop
.b6fd	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6ff	10 43		bpl $b744			bpl 	_EVExitDrop 				; must be a token.
.b701	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b703	b0 3f		bcs $b744			bcs 	_EVExitDrop
.b705	68		pla				pla 								; get current precedence
.b706	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b708	da		phx				phx 								; save X
.b709	ea		nop				nop
.b70a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b70c	aa		tax				tax 								; put in X
.b70d	bd 2c af	lda $af2c,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b710	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b712	fa		plx				plx 								; restore X
.b713	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b715	90 2e		bcc $b745			bcc 	_EVExit 					; exit if too low.
.b717	f0 2c		beq $b745			beq 	_EVExit 					; exit if equals
.b719	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b71b	48		pha				pha
.b71c	ea		nop				nop
.b71d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b71f	48		pha				pha
.b720	1b		inz				inz
.b721	da		phx				phx 								; save current position
.b722	e8		inx				inx
.b723	e8		inx				inx
.b724	e8		inx				inx
.b725	e8		inx				inx
.b726	e8		inx				inx
.b727	e8		inx				inx
.b728	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b72a	20 d8 b6	jsr $b6d8			jsr 	EvaluateExpressionXA 		; do the RHS.
.b72d	fa		plx				plx 								; restore X
.b72e	68		pla				pla 								; get the binary operator in A.
.b72f					_EVCallA:
.b72f	da		phx				phx 								; save X again
.b730	0a		asl a				asl 	a 							; double, lose the MSB.
.b731	aa		tax				tax									; put in X
.b732	bd db ae	lda $aedb,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b735	8d 11 03	sta $0311			sta 	LocalVector+1
.b738	bd dc ae	lda $aedc,x			lda 	VectorTable+1,x
.b73b	8d 12 03	sta $0312			sta 	LocalVector+2
.b73e	fa		plx				plx 								; restore X
.b73f	20 ba b7	jsr $b7ba			jsr 	EVCallLocalVector
.b742	80 b8		bra $b6fc			bra 	_EVGotAtom 					; and loop back.
.b744					_EVExitDrop:
.b744	68		pla				pla
.b745					_EVExit:
.b745	60		rts				rts
.b746					_EVNotInteger:
.b746	1b		inz				inz
.b747	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b749	d0 16		bne $b761			bne 	_EVNotMinus
.b74b	20 52 b8	jsr $b852			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b74e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b750	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b752	f0 05		beq $b759			beq 	_EVMinusFloat
.b754	20 10 c4	jsr $c410			jsr 	IntegerNegateAlways 		; negation
.b757	80 a3		bra $b6fc			bra 	_EVGotAtom 					; and go back.
.b759					_EVMinusFloat:
.b759	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.b75b	49 80		eor #$80			eor 	#$80
.b75d	95 85		sta $85,x			sta 	XS_Type,x
.b75f	80 9b		bra $b6fc			bra 	_EVGotAtom
.b761					_EVNotMinus:
.b761	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b763	d0 18		bne $b77d			bne 	_EVNotParenthesis
.b765	20 d6 b6	jsr $b6d6			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b768	ea		nop				nop
.b769	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b76b	1b		inz				inz
.b76c	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b76e	f0 8c		beq $b6fc			beq 	_EVGotAtom
.b770	20 79 ae	jsr $ae79			jsr ERR_Handler
>b773	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b77b	29 00
.b77d					_EVNotParenthesis:
.b77d	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b77f	d0 0c		bne $b78d			bne 	_EVNotNot
.b781	20 52 b8	jsr $b852			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b784	20 65 c8	jsr $c865			jsr 	FPUToInteger 				; make it an integer - if possible.
.b787	20 37 b8	jsr $b837			jsr 	NotInteger 					; do the not calculation
.b78a	4c fc b6	jmp $b6fc			jmp 	_EVGotAtom
.b78d					_EVNotNot:
.b78d	c9 fe		cmp #$fe			cmp 	#$FE
.b78f	d0 12		bne $b7a3			bne 	_EVNotString
.b791	20 20 bf	jsr $bf20			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b794	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b796	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b798	a5 21		lda $21				lda 	zTempStr+1
.b79a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b79c	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b79e	95 85		sta $85,x			sta 	XS_Type,x
.b7a0	4c fc b6	jmp $b6fc			jmp 	_EVGotAtom
.b7a3					_EVNotString:
.b7a3	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b7a5	90 04		bcc $b7ab			bcc 	_EVBadElement
.b7a7	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b7a9	90 03		bcc $b7ae			bcc 	_EVUnaryFunction
.b7ab					_EVBadElement:
.b7ab	4c 4a ae	jmp $ae4a			jmp 	SyntaxError
.b7ae					_EVUnaryFunction:
.b7ae	4c 2f b7	jmp $b72f			jmp 	_EVCallA
.b7b1					_EVVariableHandler:
.b7b1	20 49 bf	jsr $bf49			jsr 	VariableFind 				; locate a variable
.b7b4	20 93 c2	jsr $c293			jsr 	VariableGet 				; copy into memory.
.b7b7	4c fc b6	jmp $b6fc			jmp 	_EVGotAtom 					; and go round.
.b7ba					EVCallLocalVector:
.b7ba	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.b7bd					EVShiftMantissaLeft6:
.b7bd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b7bf	95 84		sta $84,x			sta 	XS_Exponent,x
.b7c1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b7c3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7c5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7c7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7c9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b7cb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7cd	a9 00		lda #$00			lda 	#0
.b7cf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7d1	20 d4 b7	jsr $b7d4			jsr 	_EVSMLShift 					; call it here to do it twice
.b7d4					_EVSMLShift:
.b7d4	56 84		lsr $84,x			lsr 	XS_Exponent,x
.b7d6	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.b7d8	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.b7da	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.b7dc	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.b7de	60		rts				rts
.b7df					EvaluateGetInteger:
.b7df	ea		nop				nop
.b7e0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7e2	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b7e4	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b7e6	a9 00		lda #$00			lda 	#0
.b7e8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7ea	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7ec	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7ee	1a		inc a				inc 	a 							; set to type 1 (integer)
.b7ef	95 85		sta $85,x			sta 	XS_Type,x
.b7f1					_EVCheckNextInteger:
.b7f1	1b		inz				inz
.b7f2	ea		nop				nop
.b7f3	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7f5	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b7f7	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b7f9	b0 0b		bcs $b806			bcs 	_EVEndInteger
.b7fb	48		pha				pha 								; save it.
.b7fc	20 bd b7	jsr $b7bd			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b7ff	68		pla				pla
.b800	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b802	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b804	80 eb		bra $b7f1			bra 	_EVCheckNextInteger
.b806					_EVEndInteger:
.b806	60		rts				rts
.b807					EVGetDecimal:
.b807	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b809	8d 15 03	sta $0315			sta 	Num_Buffer
.b80c	da		phx				phx
.b80d	1b		inz				inz
.b80e	ea		nop				nop
.b80f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b811	1b		inz				inz
.b812	3a		dec a				dec 	a								; convert to a string length.
.b813	3a		dec a				dec 	a
.b814	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b816					_EVGDCopy:
.b816	48		pha				pha 									; save count
.b817	ea		nop				nop
.b818	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b81a	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.b81d	e8		inx				inx 									; forward ....
.b81e	1b		inz				inz
.b81f	68		pla				pla 									; get count
.b820	3a		dec a				dec 	a 								; until zero
.b821	d0 f3		bne $b816			bne 	_EVGDCopy
.b823	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b826	fa		plx				plx 									; restore X
.b827	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b829	85 1e		sta $1e				sta 	zGenPtr
.b82b	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.b82d	85 1f		sta $1f				sta 	zGenPtr+1
.b82f	5a		phy				phy 									; save Y
.b830	a0 00		ldy #$00			ldy 	#0 								; start position
.b832	20 1f ca	jsr $ca1f			jsr 	FPFromString 					; convert current
.b835	7a		ply				ply 									; restore Y
.b836	60		rts				rts
.b837					NotInteger:
.b837	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b839	49 ff		eor #$ff			eor 	#$FF
.b83b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b83d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b83f	49 ff		eor #$ff			eor 	#$FF
.b841	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b843	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b845	49 ff		eor #$ff			eor 	#$FF
.b847	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b849	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b84b	49 ff		eor #$ff			eor 	#$FF
.b84d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b84f	60		rts				rts
.b850					EvaluateGetAtom:
.b850	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b852					EvaluateGetAtomX:
.b852	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b854	20 d8 b6	jsr $b6d8			jsr 	EvaluateExpressionXA
.b857	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b859	29 0f		and #$0f			and 	#15
.b85b	c9 02		cmp #$02			cmp 	#2
.b85d	b0 01		bcs $b860			bcs 	EvaluateType
.b85f	60		rts				rts
.b860					EvaluateType:
.b860	4c 5a ae	jmp $ae5a			jmp 	TypeError
.b863					EvaluateNumber:
.b863	a2 00		ldx #$00			ldx 	#0
.b865					EvaluateNumberX:
.b865	20 d6 b6	jsr $b6d6			jsr 	EvaluateExpressionX
.b868	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.b86a	29 0f		and #$0f			and 	#15
.b86c	c9 02		cmp #$02			cmp 	#2
.b86e	b0 f0		bcs $b860			bcs 	EvaluateType
.b870	60		rts				rts
.b871					EvaluateInteger:
.b871	a2 00		ldx #$00			ldx 	#0
.b873					EvaluateIntegerX:
.b873	20 65 b8	jsr $b865			jsr 	EvaluateNumberX
.b876	20 65 c8	jsr $c865			jsr 	FPUToInteger
.b879	60		rts				rts
.b87a					EvaluateString:
.b87a	a2 00		ldx #$00			ldx 	#0
.b87c					EvaluateStringX:
.b87c	20 d6 b6	jsr $b6d6			jsr 	EvaluateExpressionX
.b87f	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.b881	29 0f		and #$0f			and 	#15
.b883	c9 02		cmp #$02			cmp 	#2
.b885	d0 d9		bne $b860			bne 	EvaluateType
.b887	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b889	85 1e		sta $1e				sta 	zGenPtr
.b88b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b88d	85 1f		sta $1f				sta 	zGenPtr+1
.b88f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b890					BinaryOp_And:
.b890	20 e4 b8	jsr $b8e4			jsr 	BinaryMakeBothInteger
.b893	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b895	35 86		and $86,x			and 	XS2_Mantissa+0,x
.b897	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b899	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b89b	35 87		and $87,x			and 	XS2_Mantissa+1,x
.b89d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b89f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b8a1	35 88		and $88,x			and 	XS2_Mantissa+2,x
.b8a3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b8a5	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b8a7	35 89		and $89,x			and 	XS2_Mantissa+3,x
.b8a9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b8ab	60		rts				rts
.b8ac					BinaryOp_Or:
.b8ac	20 e4 b8	jsr $b8e4			jsr 	BinaryMakeBothInteger
.b8af	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b8b1	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.b8b3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b8b5	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b8b7	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.b8b9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b8bb	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b8bd	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.b8bf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b8c1	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b8c3	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.b8c5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b8c7	60		rts				rts
.b8c8					BinaryOp_Eor:
.b8c8					BinaryOp_Xor:
.b8c8	20 e4 b8	jsr $b8e4			jsr 	BinaryMakeBothInteger
.b8cb	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b8cd	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.b8cf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b8d1	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b8d3	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.b8d5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b8d7	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b8d9	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.b8db	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b8dd	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b8df	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.b8e1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b8e3	60		rts				rts
.b8e4					BinaryMakeBothInteger:
.b8e4	da		phx				phx 								; save X
.b8e5	e8		inx				inx
.b8e6	e8		inx				inx
.b8e7	e8		inx				inx
.b8e8	e8		inx				inx
.b8e9	e8		inx				inx
.b8ea	e8		inx				inx
.b8eb	20 ef b8	jsr $b8ef			jsr 	BinaryMakeInteger 			; convert to integer.
.b8ee	fa		plx				plx 								; restore X and fall through.
.b8ef					BinaryMakeInteger:
.b8ef	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b8f1	29 0f		and #$0f			and 	#15 						; check type zero
.b8f3	f0 04		beq $b8f9			beq 	_BMIConvert 				; if float convert to integer.
.b8f5	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b8f6	90 04		bcc $b8fc			bcc 	_BMIError
.b8f8	60		rts				rts
.b8f9					_BMIConvert:
.b8f9	4c 65 c8	jmp $c865			jmp 	FPUToInteger 				; convert to integer
.b8fc					_BMIError:
.b8fc	4c 5a ae	jmp $ae5a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b8ff					Binary_Equal:
.b8ff	20 46 b9	jsr $b946			jsr 	CompareValues
.b902	09 00		ora #$00			ora 	#0
.b904	f0 04		beq $b90a			beq 	CCTrue
.b906	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b908	80 02		bra $b90c			bra 	CCWrite
.b90a	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b90c	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b90e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b910	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b912	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b914	a9 01		lda #$01			lda 	#1
.b916	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.b918	60		rts				rts
.b919					Binary_NotEqual:
.b919	20 46 b9	jsr $b946			jsr 	CompareValues
.b91c	09 00		ora #$00			ora 	#0
.b91e	f0 e6		beq $b906			beq 	CCFalse
.b920	80 e8		bra $b90a			bra 	CCTrue
.b922					Binary_Less:
.b922	20 46 b9	jsr $b946			jsr 	CompareValues
.b925	09 00		ora #$00			ora 	#0
.b927	30 e1		bmi $b90a			bmi 	CCTrue
.b929	80 db		bra $b906			bra 	CCFalse
.b92b					Binary_LessEqual:
.b92b	20 46 b9	jsr $b946			jsr 	CompareValues
.b92e	c9 01		cmp #$01			cmp 	#1
.b930	d0 d8		bne $b90a			bne 	CCTrue
.b932	80 d2		bra $b906			bra 	CCFalse
.b934					Binary_GreaterEqual:
.b934	20 46 b9	jsr $b946			jsr 	CompareValues
.b937	09 00		ora #$00			ora 	#0
.b939	10 cf		bpl $b90a			bpl 	CCTrue
.b93b	80 c9		bra $b906			bra 	CCFalse
.b93d					Binary_Greater:
.b93d	20 46 b9	jsr $b946			jsr 	CompareValues
.b940	c9 01		cmp #$01			cmp 	#1
.b942	f0 c6		beq $b90a			beq 	CCTrue
.b944	80 c0		bra $b906			bra 	CCFalse
.b946					CompareValues:
.b946	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.b948	35 8b		and $8b,x			and 	XS2_Type,x
.b94a	c9 02		cmp #$02			cmp 	#2
.b94c	f0 11		beq $b95f			beq 	_CVString
.b94e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b950	35 8b		and $8b,x			and 	XS2_Type,x
.b952	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b953	90 03		bcc $b958			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b955	4c a1 b9	jmp $b9a1			jmp 	CompareInteger32 							; so execute code at \1
.b958					_BCFloat:
.b958	20 45 ba	jsr $ba45			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b95b	4c 9b c7	jmp $c79b			jmp 	FPCompare 							; and execute code at \2
.b95e	60		rts				rts
.b95f					_CVString:
.b95f	da		phx				phx 								; save XY
.b960	5a		phy				phy
.b961	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b963	85 1a		sta $1a				sta		zLTemp1+0
.b965	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b967	85 1b		sta $1b				sta 	zLTemp1+1
.b969	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b96b	85 1c		sta $1c				sta 	zLTemp1+2
.b96d	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b96f	85 1d		sta $1d				sta 	zLTemp1+3
.b971	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b973	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b975	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b977	90 02		bcc $b97b			bcc 	_CVCommon
.b979	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b97b					_CVCommon:
.b97b	aa		tax				tax 								; put shorter string length in zero.
.b97c	f0 0c		beq $b98a			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b97e					_CVCompare:
.b97e	c8		iny				iny 								; next character
.b97f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b981	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b983	90 13		bcc $b998			bcc 	_CVReturnLess 				; <
.b985	d0 15		bne $b99c			bne 	_CVReturnGreater 			; >
.b987	ca		dex				dex 								; until common length matched.
.b988	d0 f4		bne $b97e			bne 	_CVCompare
.b98a					_CVMatch:
.b98a	a0 00		ldy #$00			ldy 	#0
.b98c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b98e	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b990	90 06		bcc $b998			bcc 	_CVReturnLess 				; <
.b992	d0 08		bne $b99c			bne 	_CVReturnGreater 			; >
.b994	a9 00		lda #$00			lda 	#0
.b996	80 06		bra $b99e			bra 	_CVExit 					; same common, same length, same string
.b998					_CVReturnLess:
.b998	a9 ff		lda #$ff			lda 	#$FF
.b99a	80 02		bra $b99e			bra 	_CVExit
.b99c					_CVReturnGreater:
.b99c	a9 01		lda #$01			lda 	#$01
.b99e					_CVExit:
.b99e	7a		ply				ply
.b99f	fa		plx				plx
.b9a0	60		rts				rts
.b9a1					CompareInteger32:
.b9a1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b9a3	49 80		eor #$80			eor 	#$80
.b9a5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b9a7	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.b9a9	49 80		eor #$80			eor 	#$80
.b9ab	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.b9ad	20 2b ba	jsr $ba2b			jsr 	SubInteger32 				; subtraction
.b9b0	90 0d		bcc $b9bf			bcc 	_CI32Less 					; cc return -1
.b9b2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.b9b4	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b9b6	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b9b8	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b9ba	f0 02		beq $b9be			beq 	_CI32Exit
.b9bc	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b9be					_CI32Exit:
.b9be	60		rts				rts
.b9bf					_CI32Less:
.b9bf	a9 ff		lda #$ff			lda 	#$FF
.b9c1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b9c2					BinaryOp_Add:
.b9c2	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.b9c4	35 8b		and $8b,x			and 	XS2_Type,x
.b9c6	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b9c8	d0 11		bne $b9db			bne 	_BOAString
.b9ca	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b9cc	35 8b		and $8b,x			and 	XS2_Type,x
.b9ce	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b9cf	90 03		bcc $b9d4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b9d1	4c 11 ba	jmp $ba11			jmp 	AddInteger32 							; so execute code at \1
.b9d4					_BCFloat:
.b9d4	20 45 ba	jsr $ba45			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b9d7	4c 76 c5	jmp $c576			jmp 	FPAdd 							; and execute code at \2
.b9da	60		rts				rts
.b9db					_BOAString:
.b9db	4c 5f ba	jmp $ba5f			jmp 	ConcatenateString 			; concatenate two strings.
.b9de					BinaryOp_Subtract:
.b9de	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b9e0	35 8b		and $8b,x			and 	XS2_Type,x
.b9e2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b9e3	90 03		bcc $b9e8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b9e5	4c 2b ba	jmp $ba2b			jmp 	SubInteger32 							; so execute code at \1
.b9e8					_BCFloat:
.b9e8	20 45 ba	jsr $ba45			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b9eb	4c 6e c5	jmp $c56e			jmp 	FPSubtract 							; and execute code at \2
.b9ee	60		rts				rts
.b9ef					BinaryOp_Multiply:
.b9ef	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b9f1	35 8b		and $8b,x			and 	XS2_Type,x
.b9f3	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b9f4	90 03		bcc $b9f9			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b9f6	4c 4b c3	jmp $c34b			jmp 	MulInteger32 							; so execute code at \1
.b9f9					_BCFloat:
.b9f9	20 45 ba	jsr $ba45			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b9fc	4c 9d c6	jmp $c69d			jmp 	FPMultiply 							; and execute code at \2
.b9ff	60		rts				rts
.ba00					BinaryOp_Divide:
.ba00	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.ba02	35 8b		and $8b,x			and 	XS2_Type,x
.ba04	4a		lsr a				lsr 	a 							; shift bit 0 into C
.ba05	90 03		bcc $ba0a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.ba07	4c 89 c3	jmp $c389			jmp 	DivInteger32 							; so execute code at \1
.ba0a					_BCFloat:
.ba0a	20 45 ba	jsr $ba45			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.ba0d	4c 2a c6	jmp $c62a			jmp 	FPDivide 							; and execute code at \2
.ba10	60		rts				rts
.ba11					AddInteger32:
.ba11	18		clc				clc
.ba12	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ba14	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.ba16	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba18	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba1a	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.ba1c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba1e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ba20	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.ba22	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ba24	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ba26	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.ba28	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ba2a	60		rts				rts
.ba2b					SubInteger32:
.ba2b	38		sec				sec
.ba2c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ba2e	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.ba30	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba32	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba34	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.ba36	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba38	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ba3a	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.ba3c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ba3e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ba40	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.ba42	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ba44	60		rts				rts
.ba45					BinaryMakeBothFloat:
.ba45	da		phx				phx 								; save X
.ba46	e8		inx				inx
.ba47	e8		inx				inx
.ba48	e8		inx				inx
.ba49	e8		inx				inx
.ba4a	e8		inx				inx
.ba4b	e8		inx				inx
.ba4c	20 50 ba	jsr $ba50			jsr 	BinaryMakeFloat 			; convert to float.
.ba4f	fa		plx				plx 								; restore X and fall through.
.ba50					BinaryMakeFloat:
.ba50	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.ba52	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.ba53	b0 04		bcs $ba59			bcs 	_BMFConvert
.ba55	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.ba56	b0 04		bcs $ba5c			bcs 	_BMFError
.ba58	60		rts				rts
.ba59					_BMFConvert:
.ba59	4c 19 c8	jmp $c819			jmp 	FPUToFloat 					; convert to float
.ba5c					_BMFError:
.ba5c	4c 5a ae	jmp $ae5a			jmp 	TypeError
.ba5f					ConcatenateString:
.ba5f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.ba61	85 1a		sta $1a				sta		zLTemp1+0
.ba63	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba65	85 1b		sta $1b				sta 	zLTemp1+1
.ba67	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.ba69	85 1c		sta $1c				sta 	zLTemp1+2
.ba6b	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.ba6d	85 1d		sta $1d				sta 	zLTemp1+3
.ba6f	5a		phy				phy
.ba70	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.ba72	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.ba74	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.ba76	7a		ply				ply
.ba77	b0 33		bcs $baac			bcs 	_CSError					; check in range.
.ba79	c9 fe		cmp #$fe			cmp 	#maxString+1
.ba7b	b0 2f		bcs $baac			bcs 	_CSError
.ba7d	20 e5 be	jsr $bee5			jsr 	AllocateTempString 			; store the result
.ba80	20 97 ba	jsr $ba97			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.ba83	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.ba85	85 1a		sta $1a				sta 	zLTemp1
.ba87	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.ba89	85 1b		sta $1b				sta 	zLTemp1+1
.ba8b	20 97 ba	jsr $ba97			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.ba8e	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.ba90	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba92	a5 21		lda $21				lda 	zTempStr+1
.ba94	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba96	60		rts				rts
.ba97					_CSCopyString:
.ba97	da		phx				phx
.ba98	5a		phy				phy
.ba99	a0 00		ldy #$00			ldy 	#0 							; get length
.ba9b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ba9d	f0 0a		beq $baa9			beq 	_CSCSExit 					; if zero, exit
.ba9f	aa		tax				tax 								; put in X
.baa0					_CSCSLoop:
.baa0	c8		iny				iny 								; get next char
.baa1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.baa3	20 10 bf	jsr $bf10			jsr		WriteTempString 			; copy out
.baa6	ca		dex				dex 								; do whole string
.baa7	d0 f7		bne $baa0			bne 	_CSCSLoop
.baa9					_CSCSExit:
.baa9	7a		ply				ply
.baaa	fa		plx				plx
.baab	60		rts				rts
.baac					_CSError:
.baac	20 79 ae	jsr $ae79			jsr ERR_Handler
>baaf	53 74 72 69 6e 67 20 74			.text "String too long",0
>bab7	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.babf					Unary_Sgn:
.babf	20 65 b8	jsr $b865			jsr 	EvaluateNumberX 			; get value
.bac2	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; check right bracket.
.bac5	20 e3 ba	jsr $bae3			jsr 	GetSignCurrent 				; get sign.
.bac8	09 00		ora #$00			ora 	#0
.baca	10 08		bpl $bad4			bpl		UnarySetAInteger			; if 0,1 return that.
.bacc	80 00		bra $bace			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.bace					UnarySetAMinus1:
.bace	a9 ff		lda #$ff			lda 	#$FF
.bad0	95 80		sta $80,x			sta 	XS_Mantissa,x
.bad2	80 04		bra $bad8			bra 	UnarySetAFill
.bad4					UnarySetAInteger:
.bad4	95 80		sta $80,x			sta 	XS_Mantissa,x
.bad6	a9 00		lda #$00			lda 	#0
.bad8					UnarySetAFill:
.bad8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bada	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.badc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bade	a9 01		lda #$01			lda 	#1
.bae0	95 85		sta $85,x			sta 	XS_Type,x
.bae2	60		rts				rts
.bae3					GetSignCurrent:
.bae3	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.bae5	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.bae6	90 15		bcc $bafd			bcc 	_GSCFloat
.bae8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.baea	30 0e		bmi $bafa			bmi 	_GSCMinus1
.baec	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.baee	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.baf0	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.baf2	d0 03		bne $baf7			bne 	_GSCPlus1
.baf4					_GSCZero:
.baf4	a9 00		lda #$00			lda 	#0
.baf6	60		rts				rts
.baf7					_GSCPlus1:
.baf7	a9 01		lda #$01			lda 	#$01
.baf9	60		rts				rts
.bafa					_GSCMinus1:
.bafa	a9 ff		lda #$ff			lda 	#$FF
.bafc	60		rts				rts
.bafd					_GSCFloat:
.bafd	34 85		bit $85,x			bit 	XS_Type,x
.baff	70 f3		bvs $baf4			bvs 	_GSCZero
.bb01	30 f7		bmi $bafa			bmi 	_GSCMinus1
.bb03	80 f2		bra $baf7			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.bb05					Unary_Abs:
.bb05	20 65 b8	jsr $b865			jsr 	EvaluateNumberX 			; get value
.bb08	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; check right bracket.
.bb0b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bb0d	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bb0f	f0 07		beq $bb18			beq 	_UAMinusFloat
.bb11	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.bb13	10 09		bpl $bb1e			bpl 	_UAExit
.bb15	4c 10 c4	jmp $c410			jmp 	IntegerNegateAlways 		; negation
.bb18					_UAMinusFloat:
.bb18	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.bb1a	29 7f		and #$7f			and		#$7F
.bb1c	95 85		sta $85,x			sta 	XS_Type,x
.bb1e					_UAExit:
.bb1e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.bb1f					Unary_Peek:
.bb1f	a9 01		lda #$01			lda 	#1
.bb21	80 06		bra $bb29			bra 	UPMain
.bb23					Unary_Deek:
.bb23	a9 02		lda #$02			lda 	#2
.bb25	80 02		bra $bb29			bra 	UPMain
.bb27					Unary_Leek:
.bb27	a9 04		lda #$04			lda 	#4
.bb29					UPMain:
.bb29	48		pha				pha 								; set bytes to copy.
.bb2a	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX 			; numeric parameter
.bb2d	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bb30	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.bb32	85 1a		sta $1a				sta 	zLTemp1
.bb34	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bb36	85 1b		sta $1b				sta 	zLTemp1+1
.bb38	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bb3a	85 1c		sta $1c				sta 	zLTemp1+2
.bb3c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bb3e	85 1d		sta $1d				sta 	zLTemp1+3
.bb40	a9 00		lda #$00			lda 	#0 							; clear target area
.bb42	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bb44	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bb46	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bb48	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bb4a	68		pla				pla 								; restore bytes to copy
.bb4b	da		phx				phx 								; save XY
.bb4c	5a		phy				phy
.bb4d	20 1a be	jsr $be1a			jsr 	MemRead 					; read the bytes in
.bb50	7a		ply				ply 								; restore and exit
.bb51	fa		plx				plx
.bb52	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.bb53					Unary_Mod:
.bb53	20 7b bb	jsr $bb7b			jsr 	_UMParameter 				; first parameter
.bb56	20 ac be	jsr $beac			jsr 	CheckNextComma
.bb59	da		phx				phx 								; second parameter
.bb5a	e8		inx				inx
.bb5b	e8		inx				inx
.bb5c	e8		inx				inx
.bb5d	e8		inx				inx
.bb5e	e8		inx				inx
.bb5f	e8		inx				inx
.bb60	20 7b bb	jsr $bb7b			jsr 	_UMParameter
.bb63	fa		plx				plx
.bb64	20 a3 be	jsr $bea3			jsr 	CheckNextRParen
.bb67	20 89 c3	jsr $c389			jsr 	DivInteger32 				; divide
.bb6a	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.bb6c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bb6e	a5 1b		lda $1b				lda 	zLTemp1+1
.bb70	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bb72	a5 1c		lda $1c				lda 	zLTemp1+2
.bb74	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bb76	a5 1d		lda $1d				lda 	zLTemp1+3
.bb78	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bb7a	60		rts				rts
.bb7b					_UMParameter:
.bb7b	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX 			; get value
.bb7e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.bb80	10 03		bpl $bb85			bpl 	_UMNotSigned
.bb82	20 10 c4	jsr $c410			jsr 	IntegerNegateAlways
.bb85					_UMNotSigned:
.bb85	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.bb86					Unary_Usr:
.bb86	20 65 b8	jsr $b865			jsr 	EvaluateNumberX 			; numeric parameter
.bb89	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bb8c	da		phx				phx 								; save XY
.bb8d	5a		phy				phy
.bb8e	ea		nop				nop
.bb8f	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.bb92	7a		ply				ply 								; and exit
.bb93	fa		plx				plx
.bb94	60		rts				rts
.bb95					USRDefault:
.bb95	20 79 ae	jsr $ae79			jsr ERR_Handler
>bb98	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>bba0	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.bba7					Unary_Val:
.bba7	20 7c b8	jsr $b87c			jsr 	EvaluateStringX 			; get string
.bbaa	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; check right bracket.
.bbad	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.bbaf	85 1e		sta $1e				sta 	zGenPtr
.bbb1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bbb3	85 1f		sta $1f				sta 	zGenPtr+1
.bbb5	5a		phy				phy
.bbb6	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.bbb8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.bbba	f0 54		beq $bc10			beq 	_UVBadNumber
.bbbc	48		pha				pha 								; save length.
.bbbd	1a		inc a				inc 	a 							; one for the length, one for the terminator
.bbbe	1a		inc a				inc 	a
.bbbf	20 e5 be	jsr $bee5			jsr 	AllocateTempString
.bbc2	c8		iny				iny 								; move to the next.
.bbc3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.bbc5	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.bbc7	8d a0 03	sta $03a0			sta 	ValSign
.bbca	d0 04		bne $bbd0			bne 	_UVNotMinus
.bbcc	c8		iny				iny 								; skip over it.
.bbcd	68		pla				pla 								; decrement character count.
.bbce	3a		dec a				dec 	a
.bbcf	48		pha				pha
.bbd0					_UVNotMinus:
.bbd0	68		pla				pla 								; this is the count.
.bbd1	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.bbd2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bbd4	c8		iny				iny
.bbd5	20 10 bf	jsr $bf10			jsr 	WriteTempString
.bbd8	68		pla				pla
.bbd9	3a		dec a				dec 	a
.bbda	d0 f5		bne $bbd1			bne 	_UVCopy
.bbdc	20 10 bf	jsr $bf10			jsr 	WriteTempString 			; make it ASCIIZ
.bbdf	18		clc				clc
.bbe0	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.bbe2	69 01		adc #$01			adc 	#1
.bbe4	85 1e		sta $1e				sta 	zGenPtr
.bbe6	a5 21		lda $21				lda 	zTempStr+1
.bbe8	69 00		adc #$00			adc 	#0
.bbea	85 1f		sta $1f				sta 	zGenPtr+1
.bbec	18		clc				clc
.bbed	20 de c4	jsr $c4de			jsr 	IntFromString 				; first bit.
.bbf0	b0 1e		bcs $bc10			bcs 	_UVBadNumber
.bbf2	20 1f ca	jsr $ca1f			jsr 	FPFromString				; try for a float part.
.bbf5	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.bbf8	d0 10		bne $bc0a			bne 	_UVNotNegative
.bbfa	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.bbfc	4a		lsr a				lsr 	a
.bbfd	b0 08		bcs $bc07			bcs 	_UVInteger
.bbff	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.bc01	09 80		ora #$80			ora 	#$80
.bc03	95 85		sta $85,x			sta 	XS_Type,x
.bc05	80 03		bra $bc0a			bra 	_UVNotNegative
.bc07					_UVInteger:
.bc07	20 10 c4	jsr $c410			jsr 	IntegerNegateAlways 		; sign it.
.bc0a					_UVNotNegative:
.bc0a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.bc0c	d0 02		bne $bc10			bne 	_UVBadNumber
.bc0e	7a		ply				ply
.bc0f	60		rts				rts
.bc10					_UVBadNumber:
.bc10	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.bc13					Unary_Str:
.bc13	20 65 b8	jsr $b865			jsr 	EvaluateNumberX 			; numeric parameter
.bc16	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bc19	a9 00		lda #$00			lda 	#0 							; reset buffer index
.bc1b	8d 14 03	sta $0314			sta 	NumBufX
.bc1e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bc20	4a		lsr a				lsr 	a
.bc21	b0 05		bcs $bc28			bcs 	_USInt 						; if msb set do as integer
.bc23	20 64 c9	jsr $c964			jsr 	FPToString 					; call fp to str otherwise
.bc26	80 03		bra $bc2b			bra 	_USDuplicate
.bc28	20 2d c4	jsr $c42d	_USInt:	jsr 	IntToString
.bc2b					_USDuplicate:
.bc2b	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.bc2e	1a		inc a				inc 	a 							; one more for length
.bc2f	20 e5 be	jsr $bee5			jsr 	AllocateTempString 			; allocate space for it.
.bc32	5a		phy				phy 								; save Y
.bc33	a0 00		ldy #$00			ldy 	#0 							; start copying
.bc35	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.bc38	20 10 bf	jsr $bf10			jsr 	WriteTempString
.bc3b	c8		iny				iny
.bc3c	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.bc3f	d0 f4		bne $bc35			bne 	_USCopy
.bc41	7a		ply				ply 								; restore Y
.bc42	4c 0d be	jmp $be0d			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.bc45					Unary_Asc:
.bc45	20 7c b8	jsr $b87c			jsr 	EvaluateStringX 			; string parameter
.bc48	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bc4b	5a		phy				phy 								; get the string length
.bc4c	a0 00		ldy #$00			ldy 	#0
.bc4e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bc50	f0 07		beq $bc59			beq 	_UAIllegal 					; must be at least one character
.bc52	c8		iny				iny
.bc53	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.bc55	7a		ply				ply
.bc56	4c d4 ba	jmp $bad4			jmp 	UnarySetAInteger
.bc59					_UAIllegal:
.bc59	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.bc5c					Unary_Len:
.bc5c	20 7c b8	jsr $b87c			jsr 	EvaluateStringX 			; string parameter
.bc5f	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bc62	5a		phy				phy 								; get the string length
.bc63	a0 00		ldy #$00			ldy 	#0
.bc65	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bc67	7a		ply				ply
.bc68	4c d4 ba	jmp $bad4			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.bc6b					Unary_Mid:
.bc6b	20 7c b8	jsr $b87c			jsr 	EvaluateStringX 				; get string.
.bc6e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bc70	48		pha				pha
.bc71	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc73	48		pha				pha
.bc74	20 ac be	jsr $beac			jsr 	CheckNextComma 					; skip comma
.bc77	20 00 bd	jsr $bd00			jsr 	SLIByteParameter 				; get a byte parameter (start)
.bc7a	48		pha				pha 									; and push it.
.bc7b	20 ac be	jsr $beac			jsr 	CheckNextComma 					; skip comma
.bc7e	20 00 bd	jsr $bd00			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.bc81	48		pha				pha 									; and push it.
.bc82	80 41		bra $bcc5			bra 	SLIProcess
.bc84					Unary_Left:
.bc84	20 7c b8	jsr $b87c			jsr 	EvaluateStringX 				; get string.
.bc87	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bc89	48		pha				pha
.bc8a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc8c	48		pha				pha
.bc8d	a9 01		lda #$01			lda 	#1 								; push start position (1)
.bc8f	48		pha				pha
.bc90	20 ac be	jsr $beac			jsr 	CheckNextComma 					; skip comma
.bc93	20 00 bd	jsr $bd00			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.bc96	48		pha				pha 									; and push it.
.bc97	80 2c		bra $bcc5			bra 	SLIProcess
.bc99					Unary_Right:
.bc99	20 7c b8	jsr $b87c			jsr 	EvaluateStringX 				; get string.
.bc9c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bc9e	48		pha				pha
.bc9f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bca1	48		pha				pha
.bca2	da		phx				phx 									; get the string length and push on stack.
.bca3	a2 00		ldx #$00			ldx 	#0
.bca5	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.bca7	fa		plx				plx
.bca8	48		pha				pha
.bca9	20 ac be	jsr $beac			jsr 	CheckNextComma 					; skip comma
.bcac	20 00 bd	jsr $bd00			jsr 	SLIByteParameter 				; get a byte parameter.
.bcaf	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.bcb2	68		pla				pla 									; restore string length.
.bcb3	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.bcb4	38		sec				sec
.bcb5	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.bcb8	f0 02		beq $bcbc			beq 	_URStart 						; if <= 0 start from 1.
.bcba	10 02		bpl $bcbe			bpl 	_UROkay
.bcbc					_URStart:
.bcbc	a9 01		lda #$01			lda 	#1
.bcbe					_UROkay:
.bcbe	48		pha				pha 									; push start
.bcbf	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.bcc2	48		pha				pha
.bcc3	80 00		bra $bcc5			bra 	SLIProcess
.bcc5					SLIProcess:
.bcc5	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 				; closing right bracket.
.bcc8	68		pla				pla
.bcc9	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.bccc	1a		inc a				inc 	a 								; allocate +1 for it.
.bccd	20 e5 be	jsr $bee5			jsr 	AllocateTempString
.bcd0	68		pla				pla 									; pop start number off stack.
.bcd1	f0 3b		beq $bd0e			beq 	SLIError 						; exit if start = 0
.bcd3	8d a1 03	sta $03a1			sta 	SliceStart
.bcd6	68		pla				pla  									; pop string address.
.bcd7	85 1f		sta $1f				sta 	zGenPtr+1
.bcd9	68		pla				pla
.bcda	85 1e		sta $1e				sta 	zGenPtr
.bcdc	da		phx				phx
.bcdd	5a		phy				phy
.bcde	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.bce0	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.bce3					_SLICopy:
.bce3	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.bce6	f0 12		beq $bcfa			beq 	_SLIExit
.bce8	ce a2 03	dec $03a2			dec 	SliceCount
.bceb	98		tya				tya 									; index of character
.bcec	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.bcee	f0 02		beq $bcf2			beq 	_SLIOk 							; if equal, okay.
.bcf0	b0 08		bcs $bcfa			bcs 	_SLIExit 						; if past end, then exit.
.bcf2	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.bcf4	c8		iny				iny
.bcf5	20 10 bf	jsr $bf10			jsr 	WriteTempString
.bcf8	80 e9		bra $bce3			bra 	_SLICopy 						; go round till copied characters
.bcfa					_SLIExit:
.bcfa	7a		ply				ply 									; restore YX
.bcfb	fa		plx				plx
.bcfc	4c 0d be	jmp $be0d			jmp 	UnaryReturnTempStr 				; return new temporary string.
.bcff	ea		nop				nop
.bd00					SLIByteParameter:
.bd00	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX 				; get integer
.bd03	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.bd05	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bd07	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bd09	d0 03		bne $bd0e			bne 	SLIError
.bd0b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bd0d	60		rts				rts
.bd0e					SLIError:
.bd0e	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.bd11					Unary_Hex:
.bd11	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX 			; numeric parameter
.bd14	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bd17	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.bd19	20 e5 be	jsr $bee5			jsr 	AllocateTempString			; allocate string space
.bd1c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.bd1e	20 42 bd	jsr $bd42			jsr 	_UHConvert
.bd21	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bd23	20 42 bd	jsr $bd42			jsr 	_UHConvert
.bd26	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd28	20 42 bd	jsr $bd42			jsr 	_UHConvert
.bd2b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bd2d	20 42 bd	jsr $bd42			jsr 	_UHConvert
.bd30	5a		phy				phy 								; get length of new string
.bd31	a0 00		ldy #$00			ldy 	#0
.bd33	b1 20		lda ($20),y			lda 	(zTempStr),y
.bd35	7a		ply				ply
.bd36	c9 00		cmp #$00			cmp 	#0
.bd38	d0 05		bne $bd3f			bne 	_UHExit 					; if it was non zero okay
.bd3a	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.bd3c	20 10 bf	jsr $bf10			jsr 	WriteTempString
.bd3f					_UHExit:
.bd3f	4c 0d be	jmp $be0d			jmp 	UnaryReturnTempStr 			; return new temporary string.
.bd42					_UHConvert:
.bd42	48		pha				pha
.bd43	4a		lsr a				lsr 	a 							; do MSB
.bd44	4a		lsr a				lsr 	a
.bd45	4a		lsr a				lsr 	a
.bd46	4a		lsr a				lsr 	a
.bd47	20 4b bd	jsr $bd4b			jsr 	_UHNibble
.bd4a	68		pla				pla 								; do LSB
.bd4b					_UHNibble:
.bd4b	29 0f		and #$0f			and 	#15 						; get nibble
.bd4d	d0 0c		bne $bd5b			bne 	_UHNonZero
.bd4f	5a		phy				phy									; get the length
.bd50	a0 00		ldy #$00			ldy 	#0
.bd52	b1 20		lda ($20),y			lda 	(zTempStr),y
.bd54	7a		ply				ply
.bd55	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.bd57	f0 0d		beq $bd66			beq 	_UHExit2
.bd59	a9 00		lda #$00			lda 	#0
.bd5b					_UHNonZero:
.bd5b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.bd5d	90 02		bcc $bd61			bcc 	_UHDigit
.bd5f	69 06		adc #$06			adc 	#7-1
.bd61					_UHDigit:
.bd61	69 30		adc #$30			adc 	#48
.bd63	20 10 bf	jsr $bf10			jsr 	WriteTempString				; output.
.bd66					_UHExit2:
.bd66	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.bd67					Unary_Dec:
.bd67	20 7c b8	jsr $b87c			jsr 	EvaluateStringX 			; string parameter
.bd6a	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bd6d	5a		phy				phy
.bd6e	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.bd70	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bd72	f0 41		beq $bdb5			beq 	_UDFail 					; must fail if zero.
.bd74	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.bd77	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.bd79	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd7b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd7d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd7f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd81	a9 01		lda #$01			lda 	#1
.bd83	95 85		sta $85,x			sta 	XS_Type,x
.bd85					_UDConvertLoop:
.bd85	5a		phy				phy 								; shift mantissa left 4
.bd86	a0 04		ldy #$04			ldy 	#4
.bd88					_UDShift:
.bd88	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.bd8a	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.bd8c	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.bd8e	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.bd90	88		dey				dey
.bd91	d0 f5		bne $bd88			bne 	_UDShift
.bd93	7a		ply				ply
.bd94	c8		iny				iny 								; next character
.bd95	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.bd97	20 b8 bd	jsr $bdb8			jsr 	ConvertUpper 				; convert to U/C
.bd9a	c9 30		cmp #$30			cmp 	#"0"
.bd9c	90 17		bcc $bdb5			bcc 	_UDFail
.bd9e	c9 3a		cmp #$3a			cmp 	#"9"+1
.bda0	90 06		bcc $bda8			bcc 	_UDOkay
.bda2	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.bda4	c9 10		cmp #$10			cmp 	#16
.bda6	b0 0d		bcs $bdb5			bcs 	_UDFail
.bda8					_UDOkay:
.bda8	29 0f		and #$0f			and 	#15 						; nibble only
.bdaa	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.bdac	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bdae	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.bdb1	d0 d2		bne $bd85			bne 	_UDConvertLoop
.bdb3	7a		ply				ply
.bdb4	60		rts				rts
.bdb5					_UDFail:
.bdb5	4c 68 ae	jmp $ae68			jmp 	BadParamError
.bdb8					ConvertUpper:
.bdb8	c9 61		cmp #$61			cmp 	#"a"
.bdba	90 07		bcc $bdc3			bcc 	_CUExit
.bdbc	c9 7b		cmp #$7b			cmp 	#"z"+1
.bdbe	b0 03		bcs $bdc3			bcs 	_CUExit
.bdc0	38		sec				sec
.bdc1	e9 20		sbc #$20			sbc 	#32
.bdc3	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.bdc4					Unary_Chr:
.bdc4	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX			; numeric parameter
.bdc7	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bdca	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bdcc	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bdce	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bdd0	d0 0d		bne $bddf			bne 	_UCChar
.bdd2	a9 01		lda #$01			lda 	#1 							; one character string
.bdd4	20 e5 be	jsr $bee5			jsr 	AllocateTempString
.bdd7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.bdd9	20 10 bf	jsr $bf10			jsr 	WriteTempString
.bddc	4c 0d be	jmp $be0d			jmp 	UnaryReturnTempStr
.bddf					_UCChar:
.bddf	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.bde2					Unary_Spc:
.bde2	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX 			; numeric parameter
.bde5	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; right bracket.
.bde8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bdea	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bdec	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bdee	d0 1a		bne $be0a			bne 	_USSize
.bdf0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bdf2	c9 fe		cmp #$fe			cmp 	#maxString+1
.bdf4	b0 14		bcs $be0a			bcs 	_USSize
.bdf6	48		pha				pha 								; save length
.bdf7	1a		inc a				inc 	a 							; allocate one more.
.bdf8	20 e5 be	jsr $bee5			jsr 	AllocateTempString
.bdfb	68		pla				pla 								; get length
.bdfc	f0 0f		beq $be0d			beq 	UnaryReturnTempStr 			; return the current temp string
.bdfe					_USLoop:
.bdfe	48		pha				pha
.bdff	a9 20		lda #$20			lda 	#" "
.be01	20 10 bf	jsr $bf10			jsr 	WriteTempString
.be04	68		pla				pla
.be05	3a		dec a				dec 	a
.be06	d0 f6		bne $bdfe			bne 	_USLoop
.be08	80 03		bra $be0d			bra 	UnaryReturnTempStr
.be0a					_USSize:
.be0a	4c 68 ae	jmp $ae68			jmp 	BadParamError
.be0d					UnaryReturnTempStr:
.be0d	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.be0f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.be11	a5 21		lda $21				lda 	zTempStr+1
.be13	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.be15	a9 02		lda #$02			lda 	#2 							; set type to string
.be17	95 85		sta $85,x			sta 	XS_Type,x
.be19	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.be1a	db		phz		MemRead:phz
.be1b	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.be1e	a3 00		ldz #$00			ldz 	#0 							; start from here
.be20	ea		nop		_MLoop1:nop
.be21	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.be23	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.be25	1b		inz				inz 								; next to copy
.be26	e8		inx				inx
.be27	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.be2a	d0 f4		bne $be20			bne 	_MLoop1
.be2c	fb		plz				plz
.be2d	60		rts				rts
.be2e					MemWrite:
.be2e	db		phz				phz
.be2f	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.be32	a3 00		ldz #$00			ldz 	#0 							; start from here
.be34	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.be36	ea		nop				nop
.be37	92 1a		sta ($1a),z			sta 	(zlTemp1),z 				; write it out
.be39	1b		inz				inz 								; next to copy
.be3a	e8		inx				inx
.be3b	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.be3e	d0 f4		bne $be34			bne 	_MLoop1
.be40	fb		plz				plz
.be41	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.be42					UpdateProgramEnd:
.be42	a9 00		lda #$00			lda 	#BasicProgram & $FF
.be44	85 16		sta $16				sta 	zCodePtr+0
.be46	a9 80		lda #$80			lda 	#BasicProgram >> 8
.be48	85 17		sta $17				sta 	zCodePtr+1
.be4a	a9 02		lda #$02			lda 	#2
.be4c	85 18		sta $18				sta 	zCodePtr+2
.be4e	a9 00		lda #$00			lda 	#0
.be50	85 19		sta $19				sta 	zCodePtr+3
.be52	a3 03		ldz #$03			ldz 	#3
.be54					_UPDLoop:
.be54	a3 00		ldz #$00			ldz 	#0
.be56	ea		nop				nop
.be57	b2 16		lda ($16),z			lda 	(zCodePtr),z
.be59	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.be5b	f0 10		beq $be6d			beq 	_UPDFoundEnd
.be5d	a3 00		ldz #$00			ldz 	#0 							; point to offset
.be5f	ea		nop				nop
.be60	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.be62	18		clc				clc
.be63	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.be65	85 16		sta $16				sta 	zCodePtr
.be67	90 02		bcc $be6b			bcc 	_SNLNoCarry
.be69	e6 17		inc $17				inc 	zCodePtr+1
.be6b					_SNLNoCarry:
.be6b	80 e7		bra $be54			bra 	_UPDLoop
.be6d					_UPDFoundEnd:
.be6d	18		clc				clc 								; end of program 2 on.
.be6e	a5 16		lda $16				lda 	zCodePtr
.be70	69 02		adc #$02			adc 	#2
.be72	8d 04 03	sta $0304			sta 	endOfProgram
.be75	a5 17		lda $17				lda 	zCodePtr+1
.be77	69 00		adc #$00			adc 	#0
.be79	8d 05 03	sta $0305			sta 	endOfProgram+1
.be7c	a5 18		lda $18				lda 	zCodePtr+2
.be7e	69 00		adc #$00			adc		#0
.be80	8d 06 03	sta $0306			sta 	endOfProgram+2
.be83	a5 19		lda $19				lda 	zCodePtr+3
.be85	69 00		adc #$00			adc 	#0
.be87	8d 07 03	sta $0307			sta 	endOfProgram+3
.be8a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.be8b					CheckNextToken:
.be8b	ea		nop				nop
.be8c	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.be8e	d0 02		bne $be92			bne 	CTFail 						; no, then fail
.be90	1b		inz				inz
.be91	60		rts				rts
.be92					CTFail:
.be92	20 79 ae	jsr $ae79			jsr ERR_Handler
>be95	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>be9d	74 6f 6b 65 6e 00
.bea3					CheckNextRParen:
.bea3	ea		nop				nop
.bea4	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bea6	c9 be		cmp #$be			cmp 	#token_rparen
.bea8	d0 e8		bne $be92			bne 	CTFail
.beaa	1b		inz				inz
.beab	60		rts				rts
.beac					CheckNextComma:
.beac	ea		nop				nop
.bead	b2 16		lda ($16),z			lda 	(zCodePtr),z
.beaf	c9 bf		cmp #$bf			cmp 	#token_comma
.beb1	d0 df		bne $be92			bne 	CTFail
.beb3	1b		inz				inz
.beb4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.beb5					StringConcrete:
.beb5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.beb7	85 10		sta $10				sta 	zTemp1
.beb9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bebb	85 11		sta $11				sta 	zTemp1+1
.bebd	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.bebf	18		clc				clc 								; from the string pointer
.bec0	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.bec3	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.bec5	8d 00 03	sta $0300			sta 	StringPtr
.bec8	85 12		sta $12				sta 	zTemp2
.beca	ad 01 03	lda $0301			lda 	StringPtr+1
.becd	e9 00		sbc #$00			sbc 	#0
.becf	8d 01 03	sta $0301			sta 	StringPtr+1
.bed2	85 13		sta $13				sta 	zTemp2+1
.bed4	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.bed6	1a		inc a				inc 	a
.bed7	aa		tax				tax
.bed8	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.beda	91 12		sta ($12),y			sta 	(zTemp2),y
.bedc	c8		iny				iny
.bedd	ca		dex				dex
.bede	d0 f8		bne $bed8			bne 	_SCCopy
.bee0	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.bee2	a6 12		ldx $12				ldx 	zTemp2
.bee4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.bee5					AllocateTempString:
.bee5	48		pha				pha 								; save required count.
.bee6	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.bee8	d0 0b		bne $bef5			bne 	_ATSInitialised
.beea	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.beed	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.beef	ad 01 03	lda $0301			lda 	StringPtr+1
.bef2	3a		dec a				dec 	a
.bef3	85 21		sta $21				sta 	zTempStr+1
.bef5					_ATSInitialised:
.bef5	68		pla				pla 								; get required count back.
.bef6	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.bef8	1a		inc a				inc 	a
.bef9	18		clc				clc
.befa	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.befc	85 20		sta $20				sta 	zTempStr
.befe	a9 ff		lda #$ff			lda 	#$FF
.bf00	65 21		adc $21				adc 	zTempStr+1
.bf02	85 21		sta $21				sta 	zTempStr+1
.bf04	a9 00		lda #$00			lda 	#0 							; clear temp string.
.bf06	5a		phy				phy
.bf07	a8		tay				tay
.bf08	91 20		sta ($20),y			sta 	(zTempStr),y
.bf0a	7a		ply				ply
.bf0b	1a		inc a				inc 	a 							; reset the write index.
.bf0c	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.bf0f	60		rts				rts
.bf10					WriteTempString:
.bf10	5a		phy				phy 								; save Y
.bf11	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.bf14	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.bf16	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.bf19	98		tya				tya 								; unchanged Y is now length
.bf1a	a0 00		ldy #$00			ldy 	#0
.bf1c	91 20		sta ($20),y			sta 	(zTempStr),y
.bf1e	7a		ply				ply 								; restore Y and exit
.bf1f	60		rts				rts
.bf20					CreateTempStringCopy:
.bf20	da		phx				phx 								; save X
.bf21	ea		nop				nop
.bf22	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bf24	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.bf25	20 e5 be	jsr $bee5			jsr 	AllocateTempString 			; allocate memory for temporary string.
.bf28	ea		nop				nop
.bf29	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bf2b	1b		inz				inz
.bf2c	3a		dec a				dec 	a 							; make the actual length in charactes
.bf2d	3a		dec a				dec 	a
.bf2e	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.bf30	81 20		sta ($20,x)			sta 	(zTempStr,x)
.bf32	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.bf34	09 00		ora #$00			ora 	#0 							; if zero already, exit
.bf36	f0 0f		beq $bf47			beq 	_CTSCExit
.bf38					_CTSCLoop:
.bf38	ea		nop				nop
.bf39	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bf3b	1b		inz				inz
.bf3c	5a		phy				phy 								; save in Y
.bf3d	e8		inx				inx 								; bump index
.bf3e	da		phx				phx 								; index into Y
.bf3f	7a		ply				ply
.bf40	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.bf42	7a		ply				ply 								; restore Y
.bf43	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.bf45	d0 f1		bne $bf38			bne 	_CTSCLoop
.bf47					_CTSCExit:
.bf47	fa		plx				plx 								; restore X
.bf48	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.bf49					VariableFind:
.bf49	20 b4 bf	jsr $bfb4			jsr 	VariableExtract 		; find out all about it ....
.bf4c	20 4f c2	jsr $c24f			jsr 	VariableLocate 			; does it already exist ?
.bf4f	b0 03		bcs $bf54			bcs 	_VFExists 				; if so, use that.
.bf51	20 42 c0	jsr $c042			jsr 	VariableCreate 			; otherwise create it.
.bf54					_VFExists:
.bf54	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.bf56	29 01		and #$01			and 	#1
.bf58	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bf5a	d0 28		bne $bf84			bne 	_VFSingleElement
.bf5c					_VFNextIndex:
.bf5c	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.bf5e	48		pha				pha
.bf5f	a5 23		lda $23				lda 	zVarDataPtr+1
.bf61	48		pha				pha
.bf62	a5 24		lda $24				lda 	zVarType
.bf64	48		pha				pha
.bf65	20 73 b8	jsr $b873			jsr 	EvaluateIntegerX 		; calculate the index.
.bf68	68		pla				pla 							; restore and index.
.bf69	85 24		sta $24				sta 	zVarType
.bf6b	68		pla				pla
.bf6c	85 23		sta $23				sta 	zVarDataPtr+1
.bf6e	68		pla				pla
.bf6f	85 22		sta $22				sta 	zVarDataPtr
.bf71	20 cd c0	jsr $c0cd			jsr 	ArrayIndexFollow 		; do the index.
.bf74	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bf76	29 01		and #$01			and 	#1
.bf78	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bf7a	d0 05		bne $bf81			bne 	_VFArrayDone 			; if so then exit.
.bf7c	20 ac be	jsr $beac			jsr 	CheckNextComma 			; comma should follow
.bf7f	80 db		bra $bf5c			bra 	_VFNextIndex
.bf81					_VFArrayDone:
.bf81	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 		; check closing right bracket.
.bf84					_VFSingleElement:
.bf84	60		rts				rts
.bf85					VariableClear:
.bf85	48		pha				pha 							; save registers
.bf86	da		phx				phx
.bf87	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.bf89	8a		txa				txa
.bf8a	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.bf8d	e8		inx				inx
.bf8e	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bf90	d0 f8		bne $bf8a			bne 	_VCLoop
.bf92	a9 00		lda #$00			lda 	#VariableMemory & $FF
.bf94	8d 02 03	sta $0302			sta 	VarMemPtr
.bf97	a9 20		lda #$20			lda 	#VariableMemory >> 8
.bf99	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bf9c	fa		plx				plx 							; restore registers
.bf9d	68		pla				pla
.bf9e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bf9f					VariableNameError:
.bf9f	20 79 ae	jsr $ae79			jsr ERR_Handler
>bfa2	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>bfaa	61 62 6c 65 20 4e 61 6d 65 00
.bfb4					VariableExtract:
.bfb4	da		phx				phx 							; save X.
.bfb5	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bfb7	8d 95 03	sta $0395			sta 	Var_Type
.bfba	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.bfbd	ea		nop				nop
.bfbe	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bfc0	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bfc2	f0 db		beq $bf9f			beq 	VariableNameError
.bfc4	c9 1b		cmp #$1b			cmp 	#26+1
.bfc6	b0 d7		bcs $bf9f			bcs 	VariableNameError
.bfc8	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.bfca					_VECopyBuffer:
.bfca	e8		inx				inx
.bfcb	e0 1f		cpx #$1f			cpx 	#31 					; too long
.bfcd	f0 d0		beq $bf9f			beq 	VariableNameError
.bfcf	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.bfd2	18		clc				clc  							; update the hash value for it.
.bfd3	6d 96 03	adc $0396			adc 	Var_Hash
.bfd6	8d 96 03	sta $0396			sta 	Var_Hash
.bfd9	1b		inz				inz
.bfda	ea		nop				nop
.bfdb	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bfdd	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bfdf	f0 0e		beq $bfef			beq 	_VECopyEnd
.bfe1	30 0c		bmi $bfef			bmi 	_VECopyEnd
.bfe3	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bfe5	90 e3		bcc $bfca			bcc 	_VECopyBuffer
.bfe7	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bfe9	90 04		bcc $bfef			bcc 	_VECopyEnd
.bfeb	c9 3a		cmp #$3a			cmp 	#"9"+1
.bfed	90 db		bcc $bfca			bcc 	_VECopyBuffer
.bfef					_VECopyEnd:
.bfef	1b		inz				inz
.bff0	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bff2	90 04		bcc $bff8			bcc 	_VEDefaultRequired
.bff4	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bff6	90 0b		bcc $c003			bcc 	_VEHaveType
.bff8					_VEDefaultRequired:
.bff8	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bffa	f0 04		beq $c000			beq 	_VESetType 				; default set above.
.bffc	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.bfff	3b		dez				dez
.c000					_VESetType:
.c000	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.c003					_VEHaveType:
.c003	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.c006	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.c009	09 80		ora #$80			ora 	#$80
.c00b	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.c00e	e8		inx				inx 							; offset 3 => length 4.
.c00f	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.c012	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.c015	38		sec				sec
.c016	e9 b7		sbc #$b7			sbc 	#token_Dollar
.c018	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.c019	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.c01a	0a		asl a				asl 	a
.c01b	0a		asl a				asl 	a
.c01c	8d 98 03	sta $0398			sta 	Var_HashAddress
.c01f	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.c022	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.c024	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.c025	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.c028	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.c02a	8d 98 03	sta $0398			sta 	Var_HashAddress
.c02d	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.c02f	ad 95 03	lda $0395			lda 	Var_Type
.c032	c9 b9		cmp #$b9			cmp 	#token_Hash
.c034	f0 07		beq $c03d			beq 	_VEHaveSize
.c036	ca		dex				dex
.c037	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.c039	f0 02		beq $c03d			beq 	_VEHaveSize
.c03b	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.c03d					_VEHaveSize:
.c03d	8e 99 03	stx $0399			stx 	Var_DataSize
.c040	fa		plx				plx
.c041	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.c042					VariableCreate:
.c042	da		phx				phx
.c043	5a		phy				phy
.c044	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.c047	85 10		sta $10				sta 	zTemp1
.c049	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c04c	85 11		sta $11				sta 	zTemp1+1
.c04e	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.c051	18		clc				clc
.c052	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.c055	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.c057	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.c05a	8d 02 03	sta $0302			sta 	VarMemPtr
.c05d	90 03		bcc $c062			bcc 	_VCNoCarry
.c05f	ee 03 03	inc $0303			inc 	VarMemPtr+1
.c062					_VCNoCarry:
.c062	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c065	85 12		sta $12				sta 	zTemp2
.c067	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c069	85 13		sta $13				sta 	zTemp2+1
.c06b	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.c06d	b1 12		lda ($12),y			lda 	(zTemp2),y
.c06f	91 10		sta ($10),y			sta 	(zTemp1),y
.c071	c8		iny				iny
.c072	b1 12		lda ($12),y			lda 	(zTemp2),y
.c074	91 10		sta ($10),y			sta 	(zTemp1),y
.c076	c8		iny				iny
.c077	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.c07a	91 10		sta ($10),y			sta 	(zTemp1),y
.c07c	c8		iny				iny
.c07d	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.c07f					_VCCopyName:
.c07f	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.c082	91 10		sta ($10),y			sta 	(zTemp1),y
.c084	e8		inx				inx
.c085	c8		iny				iny
.c086	ec 97 03	cpx $0397			cpx 	Var_Length
.c089	d0 f4		bne $c07f			bne 	_VCCopyName
.c08b	5a		phy				phy 								; save the data offset.
.c08c	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.c08f	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.c091					_VCClearData:
.c091	91 10		sta ($10),y			sta 	(zTemp1),y
.c093	c8		iny				iny
.c094	ca		dex				dex
.c095	d0 fa		bne $c091			bne 	_VCClearData
.c097	68		pla				pla 								; offset to the data
.c098	18		clc				clc
.c099	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.c09b	85 22		sta $22				sta 	zVarDataPtr
.c09d	a5 11		lda $11				lda 	zTemp1+1
.c09f	69 00		adc #$00			adc 	#0
.c0a1	85 23		sta $23				sta 	zVarDataPtr+1
.c0a3	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c0a6	85 24		sta $24				sta 	zVarType
.c0a8	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.c0aa	a0 00		ldy #$00			ldy 	#0
.c0ac	91 12		sta ($12),y			sta 	(zTemp2),y
.c0ae	c8		iny				iny
.c0af	a5 11		lda $11				lda 	zTemp1+1
.c0b1	91 12		sta ($12),y			sta 	(zTemp2),y
.c0b3	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.c0b6	29 01		and #$01			and 	#1
.c0b8	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.c0ba	d0 0e		bne $c0ca			bne 	_VCNotArray
.c0bc	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.c0be	20 64 c1	jsr $c164			jsr 	ArrayCreate
.c0c1	5a		phy				phy 								; save YA at zVarDataPtr
.c0c2	a0 00		ldy #$00			ldy 	#0
.c0c4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0c6	c8		iny				iny
.c0c7	68		pla				pla
.c0c8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c0ca					_VCNotArray:
.c0ca	7a		ply				ply
.c0cb	fa		plx				plx
.c0cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.c0cd					ArrayIndexFollow:
.c0cd	5a		phy				phy
.c0ce	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.c0d0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.c0d2	48		pha				pha
.c0d3	c8		iny				iny
.c0d4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c0d6	85 23		sta $23				sta 	zVarDataPtr+1
.c0d8	68		pla				pla
.c0d9	85 22		sta $22				sta 	zVarDataPtr
.c0db	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.c0dd	29 80		and #$80			and 	#$80 						; must be zero.
.c0df	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c0e1	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c0e3	d0 59		bne $c13e			bne 	_AIFError
.c0e5	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.c0e7	18		clc				clc
.c0e8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c0ea	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c0ec	c8		iny				iny
.c0ed	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c0ef	08		php				php 								; clear bit 7 retaining borrow.
.c0f0	29 7f		and #$7f			and 	#$7F
.c0f2	28		plp				plp
.c0f3	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c0f5	90 47		bcc $c13e			bcc 	_AIFError 					; eror if size-current < 0
.c0f7	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.c0f9	0a		asl a				asl 	a 							; (e.g. index * 2)
.c0fa	85 10		sta $10				sta 	zTemp1
.c0fc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c0fe	2a		rol a				rol 	a
.c0ff	85 11		sta $11				sta 	zTemp1+1
.c101	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.c103	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.c105	30 1d		bmi $c124			bmi 	_AIFCalculate
.c107	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.c109	a5 24		lda $24				lda 	zVarType 					; check that type
.c10b	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.c10d	f0 15		beq $c124			beq 	_AIFCalculate
.c10f	06 10		asl $10				asl 	zTemp1			 			; double the index
.c111	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.c113	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.c115	f0 0d		beq $c124			beq 	_AIFCalculate
.c117	18		clc				clc 								; add the original mantissa in again
.c118	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.c11a	65 10		adc $10				adc 	zTemp1
.c11c	85 10		sta $10				sta 	zTemp1
.c11e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c120	65 11		adc $11				adc 	zTemp1+1
.c122	85 11		sta $11				sta 	zTemp1+1
.c124					_AIFCalculate:
.c124	18		clc				clc 								; add index x 2,4 or 5 to base
.c125	a5 22		lda $22				lda 	zVarDataPtr
.c127	65 10		adc $10				adc 	zTemp1
.c129	85 22		sta $22				sta 	zVarDataPtr
.c12b	a5 23		lda $23				lda 	zVarDataPtr+1
.c12d	65 11		adc $11				adc 	zTemp1+1
.c12f	85 23		sta $23				sta 	zVarDataPtr+1
.c131	18		clc				clc 								; add 2 more for the length prefix.
.c132	a5 22		lda $22				lda 	zVarDataPtr
.c134	69 02		adc #$02			adc 	#2
.c136	85 22		sta $22				sta 	zVarDataPtr
.c138	90 02		bcc $c13c			bcc 	_AIFNoBump
.c13a	e6 23		inc $23				inc 	zVarDataPtr+1
.c13c					_AIFNoBump:
.c13c	7a		ply				ply
.c13d	60		rts				rts
.c13e					_AIFError:
.c13e	20 79 ae	jsr $ae79			jsr ERR_Handler
>c141	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c149	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.c151					ArrayResetDefault:
.c151	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.c153	8d a8 03	sta $03a8			sta 	ArrayDef+0
.c156	a9 00		lda #$00			lda 	#0
.c158	8d a9 03	sta $03a9			sta 	ArrayDef+1
.c15b	a9 ff		lda #$ff			lda 	#$FF
.c15d	8d aa 03	sta $03aa			sta 	ArrayDef+2 					; $FFFF implies no second element.
.c160	8d ab 03	sta $03ab			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.c163	60		rts				rts
.c164					ArrayCreate:
.c164	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.c167	0a		asl a				asl 	a
.c168	85 10		sta $10				sta 	zTemp1
.c16a	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.c16d	2a		rol a				rol 	a
.c16e	85 11		sta $11				sta 	zTemp1+1
.c170	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.c173	10 22		bpl $c197			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.c175	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.c178	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.c17a	f0 1b		beq $c197			beq 	_ACSized
.c17c	06 10		asl $10				asl 	zTemp1 						; double again
.c17e	26 11		rol $11				rol 	zTemp1+1
.c180	b0 6f		bcs $c1f1			bcs 	ArrayIndexError 			; too large.
.c182	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.c184	f0 11		beq $c197			beq 	_ACSized
.c186	18		clc				clc 								; add original value x 5 for reals.
.c187	a5 10		lda $10				lda 	zTemp1
.c189	7d a8 03	adc $03a8,x			adc 	ArrayDef+0,x
.c18c	85 10		sta $10				sta 	zTemp1
.c18e	a5 11		lda $11				lda 	zTemp1+1
.c190	7d a9 03	adc $03a9,x			adc 	ArrayDef+1,x
.c193	85 11		sta $11				sta 	zTemp1+1
.c195	b0 5a		bcs $c1f1			bcs 	ArrayIndexError
.c197					_ACSized:
.c197	18		clc				clc
.c198	a5 10		lda $10				lda 	zTemp1
.c19a	69 02		adc #$02			adc 	#2
.c19c	85 10		sta $10				sta 	zTemp1
.c19e	90 04		bcc $c1a4			bcc 	_ACNoBump
.c1a0	e6 10		inc $10				inc 	zTemp1
.c1a2	f0 4d		beq $c1f1			beq 	ArrayIndexError
.c1a4					_ACNoBump:
.c1a4	18		clc				clc
.c1a5	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.c1a8	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.c1aa	85 14		sta $14				sta 	zTemp3
.c1ac	65 10		adc $10				adc 	zTemp1
.c1ae	8d 02 03	sta $0302			sta 	VarMemPtr
.c1b1	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c1b4	85 13		sta $13				sta 	zTemp2+1
.c1b6	85 15		sta $15				sta 	zTemp3+1
.c1b8	65 11		adc $11				adc 	zTemp1+1
.c1ba	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c1bd	85 11		sta $11				sta 	zTemp1+1
.c1bf	b0 30		bcs $c1f1			bcs 	ArrayIndexError
.c1c1	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.c1c3					_ACClear:
.c1c3	98		tya				tya
.c1c4	91 12		sta ($12),y			sta 	(zTemp2),y
.c1c6	e6 12		inc $12				inc 	zTemp2
.c1c8	d0 02		bne $c1cc			bne 	_ACCBump
.c1ca	e6 13		inc $13				inc 	zTemp2+1
.c1cc					_ACCBump:
.c1cc	a5 12		lda $12				lda 	zTemp2
.c1ce	cd 02 03	cmp $0302			cmp 	VarMemPtr
.c1d1	d0 f0		bne $c1c3			bne 	_ACClear
.c1d3	a5 13		lda $13				lda 	zTemp2+1
.c1d5	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.c1d8	d0 e9		bne $c1c3			bne 	_ACClear
.c1da	a0 00		ldy #$00			ldy 	#0
.c1dc	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; copy the size into the start
.c1df	91 14		sta ($14),y			sta 	(zTemp3),y
.c1e1	c8		iny				iny
.c1e2	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.c1e5	91 14		sta ($14),y			sta 	(zTemp3),y
.c1e7	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; have we reached the end
.c1ea	10 18		bpl $c204			bpl 	ACCFillRecursive
.c1ec	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.c1ee	a5 14		lda $14				lda 	zTemp3
.c1f0	60		rts				rts
.c1f1					ArrayIndexError:
.c1f1	20 79 ae	jsr $ae79			jsr ERR_Handler
>c1f4	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c1fc	79 20 69 6e 64 65 78 00
.c204					ACCFillRecursive:
.c204	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.c206	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.c208	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.c20a	c8		iny				iny
.c20b	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.c20d	09 80		ora #$80			ora 	#$80 						; an array of pointers
.c20f	91 14		sta ($14),y			sta 	(zTemp3),y
.c211	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.c213	48		pha				pha
.c214	a5 15		lda $15				lda 	zTemp3+1
.c216	48		pha				pha
.c217					_ACCFillLoop:
.c217	18		clc				clc
.c218	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.c21a	69 02		adc #$02			adc 	#2
.c21c	85 14		sta $14				sta 	zTemp3
.c21e	90 02		bcc $c222			bcc 	_ACCSkip2
.c220	e6 15		inc $15				inc 	zTemp3+1
.c222					_ACCSkip2:
.c222	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.c224	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.c226	c8		iny				iny
.c227	11 14		ora ($14),y			ora 	(zTemp3),y
.c229	d0 21		bne $c24c			bne 	_ACCExit
.c22b	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.c22d	48		pha				pha
.c22e	a5 15		lda $15				lda 	zTemp3+1
.c230	48		pha				pha
.c231	e8		inx				inx
.c232	e8		inx				inx
.c233	20 64 c1	jsr $c164			jsr 	ArrayCreate 				; create array recursively.
.c236	ca		dex				dex
.c237	ca		dex				dex
.c238	85 12		sta $12				sta 	zTemp2 						; save A
.c23a	68		pla				pla
.c23b	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.c23d	68		pla				pla
.c23e	85 14		sta $14				sta 	zTemp3
.c240	98		tya				tya 								; write high bye from Y
.c241	a0 01		ldy #$01			ldy 	#1
.c243	91 14		sta ($14),y			sta 	(zTemp3),y
.c245	88		dey				dey 								; write low byte out.
.c246	a5 12		lda $12				lda 	zTemp2
.c248	91 14		sta ($14),y			sta 	(zTemp3),y
.c24a	80 cb		bra $c217			bra 	_ACCFillLoop 				; and try again.
.c24c					_ACCExit:
.c24c	7a		ply				ply 								; restore the original address
.c24d	68		pla				pla
.c24e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.c24f					VariableLocate:
.c24f	da		phx				phx
.c250	5a		phy				phy
.c251	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c254	85 12		sta $12				sta 	zTemp2 						; points to first address.
.c256	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c258	85 13		sta $13				sta 	zTemp2+1
.c25a	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.c25c	b1 12		lda ($12),y			lda 	(zTemp2),y
.c25e	aa		tax				tax
.c25f	c8		iny				iny
.c260	b1 12		lda ($12),y			lda 	(zTemp2),y
.c262	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c264	86 12		stx $12				stx 	zTemp2
.c266	05 12		ora $12				ora 	zTemp2 						; got zero
.c268	18		clc				clc
.c269	f0 25		beq $c290			beq 	_VLExit 					; if so, then fail as end of chain.
.c26b	c8		iny				iny 								; point to hash (offset + 2)
.c26c	b1 12		lda ($12),y			lda 	(zTemp2),y
.c26e	cd 96 03	cmp $0396			cmp 	Var_Hash
.c271	d0 e7		bne $c25a			bne 	_VLNext 					; try next if different.
.c273					_VLCompare:
.c273	c8		iny				iny 								; next character
.c274	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c276	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c279	d0 df		bne $c25a			bne 	_VLNext 					; fail if different, try next.
.c27b	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c27c	90 f5		bcc $c273			bcc 	_VLCompare
.c27e	98		tya				tya
.c27f	38		sec				sec 								; add 1 as Y points to last character
.c280	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c282	85 22		sta $22				sta 	zVarDataPtr
.c284	a5 13		lda $13				lda 	zTemp2+1
.c286	69 00		adc #$00			adc 	#0
.c288	85 23		sta $23				sta 	zVarDataPtr+1
.c28a	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c28d	85 24		sta $24				sta 	zVarType
.c28f	38		sec				sec 								; return CS
.c290	7a		ply		_VLExit:ply
.c291	fa		plx				plx
.c292	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c293					VariableGet:
.c293	5a		phy				phy
.c294	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c296	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c298	95 80		sta $80,x			sta 	XS_Mantissa,x
.c29a	c8		iny				iny
.c29b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c29d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c29f	c8		iny				iny
.c2a0	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.c2a2	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c2a4	f0 2c		beq $c2d2			beq 	_VGString
.c2a6	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c2a8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c2aa	c8		iny				iny
.c2ab	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c2ad	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c2af	c8		iny				iny
.c2b0	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c2b2	95 85		sta $85,x			sta 	XS_Type,x
.c2b4	a5 24		lda $24				lda 	zVarType
.c2b6	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.c2b8	f0 28		beq $c2e2			beq 	_VGExit
.c2ba	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.c2bc	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.c2be	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.c2c0	95 84		sta $84,x			sta 	XS_Exponent,x
.c2c2	f0 1e		beq $c2e2			beq 	_VGExit 					; if exponent is zero ... it's zero.
.c2c4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.c2c6	48		pha				pha
.c2c7	29 80		and #$80			and 	#$80
.c2c9	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.c2cb	68		pla				pla
.c2cc	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.c2ce	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.c2d0	80 10		bra $c2e2			bra 	_VGExit
.c2d2					_VGString:
.c2d2	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.c2d4	95 85		sta $85,x			sta 	XS_Type,x
.c2d6	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.c2d8	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c2da	d0 06		bne $c2e2			bne 	_VGExit 					; if not, exit.
.c2dc	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.c2de	a9 25		lda #$25			lda 	#zNullString
.c2e0	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.c2e2					_VGExit:
.c2e2	7a		ply				ply
.c2e3	60		rts				rts
.c2e4					VariableSet:
.c2e4	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.c2e6	29 02		and #$02			and 	#2 							; if so, it has to be
.c2e8	d0 4b		bne $c335			bne 	_VSString
.c2ea	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.c2ec	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c2ee	f0 42		beq $c332			beq 	_VSBadType
.c2f0	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.c2f2	f0 05		beq $c2f9			beq 	_VSMakeInt
.c2f4	20 19 c8	jsr $c819			jsr 	FPUToFloat
.c2f7	80 03		bra $c2fc			bra 	_VSCopy
.c2f9					_VSMakeInt:
.c2f9	20 65 c8	jsr $c865			jsr 	FPUToInteger
.c2fc					_VSCopy:
.c2fc	5a		phy				phy
.c2fd	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.c2ff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c301	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c303	c8		iny				iny
.c304	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c306	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c308	c8		iny				iny
.c309	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c30b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c30d	c8		iny				iny
.c30e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c310	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c312	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.c314	c9 bb		cmp #$bb			cmp 	#token_Percent
.c316	f0 18		beq $c330			beq 	_VSExit
.c318	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.c31a	0a		asl a				asl 	a
.c31b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.c31d	08		php				php
.c31e	0a		asl a				asl 	a
.c31f	28		plp				plp
.c320	6a		ror a				ror 	a
.c321	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c323	c8		iny				iny
.c324	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.c326	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c328	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.c32a	50 04		bvc $c330			bvc 	_VSExit
.c32c	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.c32e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c330					_VSExit:
.c330	7a		ply				ply
.c331	60		rts				rts
.c332					_VSBadType:
.c332	4c 5a ae	jmp $ae5a			jmp 	TypeError
.c335					_VSString:
.c335	a5 24		lda $24				lda 	zVarType 					; type must be $
.c337	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c339	d0 f7		bne $c332			bne 	_VSBadType
.c33b	da		phx				phx
.c33c	5a		phy				phy
.c33d	20 b5 be	jsr $beb5			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.c340	a0 01		ldy #$01			ldy 	#1 							; save high byte
.c342	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c344	88		dey				dey 								; save low byte
.c345	8a		txa				txa
.c346	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c348	7a		ply				ply 								; and exit.
.c349	fa		plx				plx
.c34a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c34b					MulInteger32:
.c34b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c34d	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.c34f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c351	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.c353	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c355	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.c357	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c359	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.c35b	a9 00		lda #$00			lda 	#0
.c35d	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.c35f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c361	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c363	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c365					_BFMMultiply:
.c365	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c367	29 01		and #$01			and 	#1
.c369	f0 03		beq $c36e			beq 	_BFMNoAdd
.c36b	20 11 ba	jsr $ba11			jsr 	AddInteger32
.c36e					_BFMNoAdd:
.c36e	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c370	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.c372	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.c374	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.c376	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c378	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.c37a	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.c37c	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.c37e	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c380	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.c382	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.c384	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.c386	d0 dd		bne $c365			bne 	_BFMMultiply
.c388	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c389					DivInteger32:
.c389	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c38b	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.c38d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c38f	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c391	d0 14		bne $c3a7			bne 	_BFDOkay
.c393	20 79 ae	jsr $ae79			jsr ERR_Handler
>c396	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>c39e	20 62 79 20 5a 65 72 6f 00
.c3a7					_BFDOkay:
.c3a7	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c3a9	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c3ab	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c3ad	85 1c		sta $1c				sta 	zLTemp1+2
.c3af	85 1d		sta $1d				sta 	zLTemp1+3
.c3b1	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.c3b4	20 0b c4	jsr $c40b			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c3b7	da		phx				phx
.c3b8	e8		inx				inx
.c3b9	e8		inx				inx
.c3ba	e8		inx				inx
.c3bb	e8		inx				inx
.c3bc	e8		inx				inx
.c3bd	e8		inx				inx
.c3be	20 0b c4	jsr $c40b			jsr 	CheckIntegerNegate
.c3c1	fa		plx				plx
.c3c2	5a		phy				phy 								; Y is the counter
.c3c3	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c3c5					_BFDLoop:
.c3c5	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c3c7	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c3c9	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c3cb	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c3cd	26 1a		rol $1a				rol 	zLTemp1
.c3cf	26 1b		rol $1b				rol 	zLTemp1+1
.c3d1	26 1c		rol $1c				rol 	zLTemp1+2
.c3d3	26 1d		rol $1d				rol 	zLTemp1+3
.c3d5	38		sec				sec
.c3d6	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c3d8	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c3da	48		pha				pha
.c3db	a5 1b		lda $1b				lda 	zLTemp1+1
.c3dd	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c3df	48		pha				pha
.c3e0	a5 1c		lda $1c				lda 	zLTemp1+2
.c3e2	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c3e4	48		pha				pha
.c3e5	a5 1d		lda $1d				lda 	zLTemp1+3
.c3e7	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c3e9	90 13		bcc $c3fe			bcc 	_BFDNoAdd
.c3eb	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c3ed	68		pla				pla
.c3ee	85 1c		sta $1c				sta 	zLTemp1+2
.c3f0	68		pla				pla
.c3f1	85 1b		sta $1b				sta 	zLTemp1+1
.c3f3	68		pla				pla
.c3f4	85 1a		sta $1a				sta 	zLTemp1+0
.c3f6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c3f8	09 01		ora #$01			ora 	#1
.c3fa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c3fc	80 03		bra $c401			bra 	_BFDNext
.c3fe					_BFDNoAdd:
.c3fe	68		pla				pla 								; Throw away the intermediate calculations
.c3ff	68		pla				pla
.c400	68		pla				pla
.c401					_BFDNext:
.c401	88		dey				dey
.c402	d0 c1		bne $c3c5			bne 	_BFDLoop
.c404	7a		ply				ply 								; restore Y and exit
.c405	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.c408	b0 06		bcs $c410			bcs		IntegerNegateAlways 			; negate the result
.c40a	60		rts				rts
.c40b					CheckIntegerNegate:
.c40b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c40d	30 01		bmi $c410			bmi 	IntegerNegateAlways
.c40f	60		rts				rts
.c410					IntegerNegateAlways:
.c410	ee 9e 03	inc $039e			inc 	SignCount
.c413	38		sec				sec
.c414	a9 00		lda #$00			lda 	#0
.c416	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c418	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c41a	a9 00		lda #$00			lda 	#0
.c41c	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c41e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c420	a9 00		lda #$00			lda 	#0
.c422	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c424	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c426	a9 00		lda #$00			lda 	#0
.c428	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c42a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c42c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c42d					INTToString:
.c42d	48		pha				pha
.c42e	5a		phy				phy
.c42f	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.c431	10 08		bpl $c43b			bpl 		_ITSNotMinus
.c433	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c435	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter
.c438	20 10 c4	jsr $c410			jsr 		IntegerNegateAlways 	; negate the number.
.c43b					_ITSNotMinus:
.c43b	a9 00		lda #$00			lda 		#0
.c43d	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.c440	8a		txa				txa 								; use Y for the mantissa index.
.c441	a8		tay				tay
.c442	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c444					_ITSNextSubtractor:
.c444	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c446	8d 9b 03	sta $039b			sta 		NumConvCount
.c449					_ITSSubtract:
.c449	38		sec				sec
.c44a	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c44d	fd a7 c4	sbc $c4a7,x			sbc 		_ITSSubtractors+0,x
.c450	48		pha				pha
.c451	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.c454	fd a8 c4	sbc $c4a8,x			sbc 		_ITSSubtractors+1,x
.c457	48		pha				pha
.c458	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.c45b	fd a9 c4	sbc $c4a9,x			sbc 		_ITSSubtractors+2,x
.c45e	48		pha				pha
.c45f	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.c462	fd aa c4	sbc $c4aa,x			sbc 		_ITSSubtractors+3,x
.c465	90 14		bcc $c47b			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c467	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c46a	68		pla				pla
.c46b	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.c46e	68		pla				pla
.c46f	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.c472	68		pla				pla
.c473	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.c476	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.c479	80 ce		bra $c449			bra 		_ITSSubtract 			; go round again.
.c47b					_ITSCantSubtract:
.c47b	68		pla				pla 								; throw away interim answers
.c47c	68		pla				pla
.c47d	68		pla				pla
.c47e	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.c481	c9 30		cmp #$30			cmp 		#"0"
.c483	d0 05		bne $c48a			bne 		_ITSOutputDigit
.c485	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c488	10 09		bpl $c493			bpl	 		_ITSGoNextSubtractor
.c48a					_ITSOutputDigit:
.c48a	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.c48d	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.c490	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter 		; output it.
.c493					_ITSGoNextSubtractor:
.c493	e8		inx				inx 								; next dword
.c494	e8		inx				inx
.c495	e8		inx				inx
.c496	e8		inx				inx
.c497	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c499	d0 a9		bne $c444			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c49b	98		tya				tya 								; X is back as the mantissa index
.c49c	aa		tax				tax
.c49d	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c49f	09 30		ora #$30			ora 		#"0"
.c4a1	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter
.c4a4	7a		ply				ply 								; and exit
.c4a5	68		pla				pla
.c4a6	60		rts				rts
.c4a7					_ITSSubtractors:
>c4a7	00 ca 9a 3b					.dword 		1000000000
>c4ab	00 e1 f5 05					.dword 		100000000
>c4af	80 96 98 00					.dword 		10000000
>c4b3	40 42 0f 00					.dword 		1000000
>c4b7	a0 86 01 00					.dword 		100000
>c4bb	10 27 00 00					.dword 		10000
>c4bf	e8 03 00 00					.dword 		1000
>c4c3	64 00 00 00					.dword 		100
>c4c7	0a 00 00 00					.dword 		10
.c4cb					_ITSSubtractorsEnd:
.c4cb					ITSOutputCharacter:
.c4cb	48		pha				pha
.c4cc	da		phx				phx
.c4cd	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.c4d0	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.c4d3	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c4d5	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.c4d8	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.c4db	fa		plx				plx
.c4dc	68		pla				pla
.c4dd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c4de					IntFromString:
.c4de	a0 00		ldy #$00			ldy 	#0
.c4e0	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.c4e3					IntFromStringY:
.c4e3	48		pha				pha
.c4e4	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c4e6	95 80		sta $80,x			sta 	XS_Mantissa,x
.c4e8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c4ea	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c4ec	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c4ee	a9 01		lda #$01			lda 	#1
.c4f0	95 85		sta $85,x			sta 	XS_Type,x
.c4f2					_IFSLoop:
.c4f2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c4f4	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c4f6	90 4e		bcc $c546			bcc 	_IFSExit
.c4f8	c9 3a		cmp #$3a			cmp 	#"9"+1
.c4fa	b0 4a		bcs $c546			bcs 	_IFSExit
.c4fc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c4fe	c9 0c		cmp #$0c			cmp 	#12
.c500	b0 4e		bcs $c550			bcs 	_IFSOverflow
.c502	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c504	48		pha				pha
.c505	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c507	48		pha				pha
.c508	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c50a	48		pha				pha
.c50b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c50d	48		pha				pha
.c50e	20 65 c5	jsr $c565			jsr 	IFSX1ShiftLeft 				; double
.c511	20 65 c5	jsr $c565			jsr 	IFSX1ShiftLeft 				; x 4
.c514	18		clc				clc 								; add saved value x 5
.c515	68		pla				pla
.c516	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c518	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c51a	68		pla				pla
.c51b	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c51d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c51f	68		pla				pla
.c520	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c522	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c524	68		pla				pla
.c525	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c527	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c529	20 65 c5	jsr $c565			jsr 	IFSX1ShiftLeft 				; x 10
.c52c	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.c52f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c531	29 0f		and #$0f			and 	#15
.c533	c8		iny				iny
.c534	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c536	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c538	90 b8		bcc $c4f2			bcc 	_IFSLoop
.c53a	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c53c	d0 b4		bne $c4f2			bne 	_IFSLoop
.c53e	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c540	d0 b0		bne $c4f2			bne 	_IFSLoop
.c542	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c544	80 ac		bra $c4f2			bra 	_IFSLoop
.c546					_IFSExit:
.c546	98		tya				tya 								; get offset
.c547					_IFSOkay:
.c547	38		sec				sec
.c548	ad 9c 03	lda $039c			lda 	ExpTemp
.c54b	f0 01		beq $c54e			beq 	_IFSSkipFail
.c54d	18		clc				clc
.c54e					_IFSSkipFail:
.c54e	68		pla				pla 								; and exit.
.c54f	60		rts				rts
.c550					_IFSOverflow:
.c550	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>c553	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c55b	20 6f 76 65 72 66 6c 6f 77 00
.c565					IFSX1ShiftLeft:
.c565	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c567	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c569	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c56b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c56d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c56e					FPSubtract:
.c56e	48		pha				pha
.c56f	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c571	49 80		eor #$80			eor 	#$80
.c573	95 8b		sta $8b,x			sta 	XS2_Type,x
.c575	68		pla				pla 								; --- and fall through ---
.c576					FPAdd:
.c576	48		pha				pha
.c577	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c579	d0 05		bne $c580			bne 	_FPA_NegativeLHS
.c57b	20 97 c5	jsr $c597			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c57e	68		pla				pla
.c57f	60		rts				rts
.c580					_FPA_NegativeLHS:
.c580	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c582	49 80		eor #$80			eor 	#$80
.c584	95 85		sta $85,x			sta 	XS_Type,x
.c586	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c588	49 80		eor #$80			eor 	#$80
.c58a	95 8b		sta $8b,x			sta 	XS2_Type,x
.c58c	20 97 c5	jsr $c597			jsr 	FPAdd_Worker 				; do the add calculation.
.c58f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c591	49 80		eor #$80			eor 	#$80
.c593	95 85		sta $85,x			sta 	XS_Type,x
.c595	68		pla				pla
.c596	60		rts				rts
.c597					FPAdd_Worker:
.c597	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c599	70 07		bvs $c5a2			bvs 	_FPAWExit 					; no change.
.c59b	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c59d	50 07		bvc $c5a6			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c59f	20 d7 c7	jsr $c7d7			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c5a2					_FPAWExit:
.c5a2	20 46 c8	jsr $c846			jsr 	FPUNormalise 				; normalise the result.
.c5a5	60		rts				rts
.c5a6					_FPAWMakeSame:
.c5a6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c5a8	38		sec				sec
.c5a9	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c5ab	f0 16		beq $c5c3			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c5ad	da		phx				phx 								; save X
.c5ae	90 06		bcc $c5b6			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c5b0	e8		inx				inx
.c5b1	e8		inx				inx
.c5b2	e8		inx				inx
.c5b3	e8		inx				inx
.c5b4	e8		inx				inx
.c5b5	e8		inx				inx
.c5b6					_FPAWShiftA:
.c5b6	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c5b8	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c5ba	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c5bc	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c5be	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c5c0	fa		plx				plx 								; restore original X
.c5c1	80 e3		bra $c5a6			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c5c3					_FPAW_DoArithmetic:
.c5c3	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c5c5	30 28		bmi $c5ef			bmi 	_FPAW_BNegative
.c5c7	18		clc				clc
.c5c8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c5ca	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c5cc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c5ce	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c5d0	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c5d2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c5d4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c5d6	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c5d8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c5da	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c5dc	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c5de	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c5e0	90 c0		bcc $c5a2			bcc 	_FPAWExit 					; no carry.
.c5e2	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c5e4	38		sec				sec
.c5e5	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c5e7	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c5e9	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c5eb	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c5ed	80 b3		bra $c5a2			bra 	_FPAWExit
.c5ef					_FPAW_BNegative:
.c5ef	38		sec				sec
.c5f0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c5f2	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c5f4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c5f6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c5f8	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c5fa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c5fc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c5fe	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c600	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c602	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c604	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c606	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c608	b0 09		bcs $c613			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c60a	20 fd c7	jsr $c7fd			jsr 	FPUNegateInteger			; negate the mantissa
.c60d	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.c60f	49 80		eor #$80			eor 	#$80
.c611	95 85		sta $85,x			sta 	XS_Type,x
.c613					_FPAWGoExit:
.c613	4c a2 c5	jmp $c5a2			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c616					FPD_IsDivZero:
.c616	20 79 ae	jsr $ae79			jsr ERR_Handler
>c619	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c621	20 62 79 20 7a 65 72 6f 00
.c62a					FPDivide:
.c62a	48		pha				pha
.c62b	5a		phy				phy
.c62c	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.c62e	70 e6		bvs $c616			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c630	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c632	f0 03		beq $c637			beq 	_FPDCalculateExp
.c634					_FPD_Exit:
.c634	7a		ply				ply
.c635	68		pla				pla
.c636	60		rts				rts
.c637					_FPDCalculateExp:
.c637	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c639	49 ff		eor #$ff			eor 	#$FF
.c63b	1a		inc a				inc 	a
.c63c	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.c63e	20 0e c7	jsr $c70e			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c641	18		clc				clc 	 							; add 1 to the resulting exponent
.c642	69 01		adc #$01			adc 	#1
.c644	b0 54		bcs $c69a			bcs 	_FPD_Overflow 				; which can overflow.
.c646	95 84		sta $84,x			sta 	XS_Exponent,x
.c648	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c64a	85 1a		sta $1a				sta 	zLTemp1+0
.c64c	85 1b		sta $1b				sta 	zLTemp1+1
.c64e	85 1c		sta $1c				sta 	zLTemp1+2
.c650	85 1d		sta $1d				sta 	zLTemp1+3
.c652	a0 20		ldy #$20			ldy 	#32 						; times round.
.c654					_FPD_Loop:
.c654	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c655	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.c657	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.c659	48		pha				pha
.c65a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c65c	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c65e	48		pha				pha
.c65f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c661	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c663	48		pha				pha
.c664	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c666	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c668	90 13		bcc $c67d			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c66a	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c66c	68		pla				pla
.c66d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c66f	68		pla				pla
.c670	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c672	68		pla				pla
.c673	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c675	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c677	09 80		ora #$80			ora 	#$80
.c679	85 1d		sta $1d				sta 	zLTemp1+3
.c67b	80 03		bra $c680			bra 	_FPD_Rotates
.c67d					_FPD_NoSubtract:
.c67d	68		pla				pla 								; throw away unwanted results
.c67e	68		pla				pla
.c67f	68		pla				pla
.c680					_FPD_Rotates:
.c680	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.c682	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.c684	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.c686	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.c688	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c68a	26 1b		rol $1b				rol 	zLTemp1+1
.c68c	26 1c		rol $1c				rol 	zLTemp1+2
.c68e	26 1d		rol $1d				rol 	zLTemp1+3
.c690	90 02		bcc $c694			bcc 	_FPD_NoCarry
.c692	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c694					_FPD_NoCarry:
.c694	88		dey				dey 								; do 32 times
.c695	d0 bd		bne $c654			bne 	_FPD_Loop
.c697	4c f2 c6	jmp $c6f2			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c69a					_FPD_Overflow:
.c69a	4c a3 c8	jmp $c8a3			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c69d					FPMultiply:
.c69d	48		pha				pha
.c69e	5a		phy				phy
.c69f	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c6a1	70 07		bvs $c6aa			bvs 	_FPM_Exit
.c6a3	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c6a5	50 06		bvc $c6ad			bvc 	_FPM_CalcExponent
.c6a7	20 d7 c7	jsr $c7d7			jsr 	FPUCopyX2ToX1
.c6aa					_FPM_Exit:
.c6aa	7a		ply				ply
.c6ab	68		pla				pla
.c6ac	60		rts				rts
.c6ad					_FPM_CalcExponent:
.c6ad	18		clc				clc
.c6ae	20 0e c7	jsr $c70e			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c6b1	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.c6b3	a9 00		lda #$00			lda 	#0
.c6b5	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c6b7	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c6b9	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c6bb	85 1d		sta $1d				sta 	zLTemp1+3
.c6bd	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c6bf					_FPM_Loop:
.c6bf	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.c6c1	29 01		and #$01			and 	#1
.c6c3	18		clc				clc 								; clear carry for the long rotate.
.c6c4	f0 19		beq $c6df			beq 	_FPM_NoAddition
.c6c6	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c6c7	a5 1a		lda $1a				lda 	zLTemp1+0
.c6c9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c6cb	85 1a		sta $1a				sta 	zLTemp1+0
.c6cd	a5 1b		lda $1b				lda 	zLTemp1+1
.c6cf	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c6d1	85 1b		sta $1b				sta 	zLTemp1+1
.c6d3	a5 1c		lda $1c				lda 	zLTemp1+2
.c6d5	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c6d7	85 1c		sta $1c				sta 	zLTemp1+2
.c6d9	a5 1d		lda $1d				lda 	zLTemp1+3
.c6db	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c6dd	85 1d		sta $1d				sta 	zLTemp1+3
.c6df					_FPM_NoAddition:
.c6df	66 1d		ror $1d				ror 	3+zLTemp1
.c6e1	66 1c		ror $1c				ror 	2+zLTemp1
.c6e3	66 1b		ror $1b				ror 	1+zLTemp1
.c6e5	66 1a		ror $1a				ror 	0+zLTemp1
.c6e7	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c6e9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c6eb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c6ed	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c6ef	88		dey				dey
.c6f0	d0 cd		bne $c6bf			bne 	_FPM_Loop 					; do this 32 times.
.c6f2					FPM_CopySignNormalize:
.c6f2	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c6f4	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c6f6	a5 1b		lda $1b				lda 	zLTemp1+1
.c6f8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c6fa	a5 1c		lda $1c				lda 	zLTemp1+2
.c6fc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c6fe	a5 1d		lda $1d				lda 	zLTemp1+3
.c700	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c702	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.c704	55 8b		eor $8b,x			eor 	XS2_Type,x
.c706	95 85		sta $85,x			sta 	XS_Type,x
.c708	20 46 c8	jsr $c846			jsr 	FPUNormalise 				; normalise and exit.
.c70b	7a		ply				ply
.c70c	68		pla				pla
.c70d	60		rts				rts
.c70e					FPCalculateExponent:
.c70e	18		clc				clc
.c70f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c711	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.c713	b0 08		bcs $c71d			bcs 	_FPCECarry 					; carry out ?
.c715	10 03		bpl $c71a			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c717	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c719	60		rts				rts
.c71a					_FPCEExpZero:
.c71a	a9 00		lda #$00			lda 	#0
.c71c	60		rts				rts
.c71d					_FPCECarry:
.c71d	30 03		bmi $c722			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c71f	09 80		ora #$80			ora 	#$80 						; put in right range
.c721	60		rts				rts
.c722					_FPCEOverflow:
.c722	4c a3 c8	jmp $c8a3			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c725					FPFractionalPart:
.c725	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c727	38		sec				sec 								; this flag tells us to keep the fractional part
.c728	30 0d		bmi $c737			bmi 	FPGetPart
.c72a	60		rts				rts
.c72b					FPIntegerPart:
.c72b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c72d	18		clc				clc 								; this flag says keep the integer part.
.c72e	30 07		bmi $c737			bmi 	FPGetPart 					; -ve exponents are 0..127
.c730	48		pha				pha
.c731	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c733	95 85		sta $85,x			sta 	XS_Type,x
.c735	68		pla				pla
.c736	60		rts				rts
.c737					FPGetPart:
.c737	48		pha				pha
.c738	5a		phy				phy 								; save Y
.c739	08		php				php 								; save action
.c73a	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c73c	70 59		bvs $c797			bvs 	_FPGP_Exit 					; then do nothing.
.c73e	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c740	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c742	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c744	85 1c		sta $1c				sta 	zLTemp1+2
.c746	85 1d		sta $1d				sta 	zLTemp1+3
.c748	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.c74a	38		sec				sec
.c74b	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c74d	f0 12		beq $c761			beq 	_FPGP_NoShift 				; ... if any
.c74f	c9 20		cmp #$20			cmp 	#32
.c751	90 02		bcc $c755			bcc 	_FPGP_NotMax
.c753	a9 20		lda #$20			lda 	#32 						; max of 32.
.c755					_FPGP_NotMax:
.c755	a8		tay				tay 								; Y is the mask shift count.
.c756					_FPGP_ShiftMask:
.c756	46 1d		lsr $1d				lsr 	3+zLTemp1
.c758	66 1c		ror $1c				ror 	2+zLTemp1
.c75a	66 1b		ror $1b				ror 	1+zLTemp1
.c75c	66 1a		ror $1a				ror 	0+zLTemp1
.c75e	88		dey				dey
.c75f	d0 f5		bne $c756			bne 	_FPGP_ShiftMask
.c761					_FPGP_NoShift:
.c761	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c763	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.c766					_FPGP_MaskLoop:
.c766	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c769	28		plp				plp 								; if CC we keep the top part, so we
.c76a	08		php				php		 							; flip the mask.
.c76b	b0 02		bcs $c76f			bcs		_FPGP_NoFlip
.c76d	49 ff		eor #$ff			eor 	#$FF
.c76f					_FPGP_NoFlip:
.c76f	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c771	95 80		sta $80,x			sta 	XS_Mantissa,x
.c773	e8		inx				inx
.c774	c8		iny				iny
.c775	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c777	d0 ed		bne $c766			bne 	_FPGP_MaskLoop
.c779	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.c77c	28		plp				plp
.c77d	08		php				php 								; get action flag on the stack
.c77e	90 04		bcc $c784			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c780	a9 00		lda #$00			lda 	#0
.c782	95 85		sta $85,x			sta 	XS_Type,x
.c784					_FPGP_NotFractional:
.c784	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c786	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c788	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c78a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c78c	f0 05		beq $c793			beq 	_FPGP_Zero 					; if zero, return zero
.c78e	20 46 c8	jsr $c846			jsr 	FPUNormalise
.c791	80 04		bra $c797			bra 	_FPGP_Exit 					; and exit
.c793					_FPGP_Zero:
.c793	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c795	95 85		sta $85,x			sta 	XS_Type,x
.c797					_FPGP_Exit:
.c797	68		pla				pla 								; throw saved action flag.
.c798	7a		ply				ply
.c799	68		pla				pla
.c79a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c79b					FPCompare:
.c79b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c79d	48		pha				pha
.c79e	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.c7a0	48		pha				pha
.c7a1	20 6e c5	jsr $c56e			jsr 	FPSubtract 					; calculate X1-X2
.c7a4	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c7a6	70 2a		bvs $c7d2			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c7a8	68		pla				pla
.c7a9	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.c7ac	68		pla				pla
.c7ad	38		sec				sec
.c7ae	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.c7b1	70 14		bvs $c7c7			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c7b3	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c7b4	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c7b6	b0 0f		bcs $c7c7			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c7b8	38		sec				sec
.c7b9	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.c7bc	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c7be	b0 02		bcs $c7c2			bcs 	_FPCNotRange 				; keep in range.
.c7c0	a9 01		lda #$01			lda 	#1
.c7c2					_FPCNotRange:
.c7c2	38		sec				sec
.c7c3	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c7c5	b0 0d		bcs $c7d4			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c7c7					_FPCNotEqual:
.c7c7	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c7c9	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c7cb	f0 02		beq $c7cf			beq 	_FPCNE2
.c7cd	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c7cf	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c7d0	80 04		bra $c7d6			bra 	_FPCExit
.c7d2					_FPCPullZero:
.c7d2	68		pla				pla 								; throw saved exponents
.c7d3	68		pla				pla
.c7d4					_FPCZero:
.c7d4	a9 00		lda #$00			lda 	#0 							; and return zero
.c7d6					_FPCExit:
.c7d6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c7d7					FPUCopyX2ToX1:
.c7d7	48		pha				pha
.c7d8	da		phx				phx
.c7d9	5a		phy				phy
.c7da	a0 08		ldy #$08			ldy 	#8
.c7dc	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.c7de	95 80		sta $80,x			sta 	XS_Mantissa,x
.c7e0	e8		inx				inx
.c7e1	88		dey				dey
.c7e2	10 f8		bpl $c7dc			bpl 	_FPUC21
.c7e4	7a		ply				ply
.c7e5	fa		plx				plx
.c7e6	68		pla				pla
.c7e7	60		rts				rts
.c7e8					FPUSetInteger:
.c7e8	48		pha				pha
.c7e9	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c7eb	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c7ed	10 02		bpl $c7f1			bpl 	_FPUSIExtend
.c7ef	a9 ff		lda #$ff			lda 	#$FF
.c7f1					_FPUSIExtend:
.c7f1	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c7f3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c7f5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c7f7	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c7f9	95 85		sta $85,x			sta 	XS_Type,x
.c7fb	68		pla				pla
.c7fc	60		rts				rts
.c7fd					FPUNegateInteger:
.c7fd	48		pha				pha
.c7fe	38		sec				sec
.c7ff	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c801	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c803	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c805	a9 00		lda #$00			lda 	#0
.c807	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c809	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c80b	a9 00		lda #$00			lda 	#0
.c80d	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c80f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c811	a9 00		lda #$00			lda 	#0
.c813	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c815	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c817	68		pla				pla
.c818	60		rts				rts
.c819					FPUToFloat:
.c819	48		pha				pha
.c81a	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.c81c	29 0f		and #$0f			and 	#$0F
.c81e	f0 24		beq $c844			beq 	_FPUFExit
.c820	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c822	95 85		sta $85,x			sta 	XS_Type,x
.c824	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c826	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.c828	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c82a	10 07		bpl $c833			bpl		_FPUFPositive
.c82c	20 fd c7	jsr $c7fd			jsr 	FPUNegateInteger 			; negate the mantissa
.c82f	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c831	95 85		sta $85,x			sta 	XS_Type,x
.c833					_FPUFPositive:
.c833	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c835	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c837	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c839	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c83b	d0 04		bne $c841			bne 	_FPUFNonZero
.c83d	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c83f	95 85		sta $85,x			sta 	XS_Type,x
.c841					_FPUFNonZero:
.c841	20 46 c8	jsr $c846			jsr 	FPUNormalise 				; normalise the floating point.
.c844					_FPUFExit:
.c844	68		pla				pla
.c845	60		rts				rts
.c846					FPUNormalise:
.c846	48		pha				pha
.c847	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c849	70 18		bvs $c863			bvs 	_FPUNExit
.c84b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c84d	f0 10		beq $c85f			beq 	_FPUNSetZero
.c84f					_FPUNLoop:
.c84f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c851	30 10		bmi $c863			bmi 	_FPUNExit 					; if so, we are normalised.
.c853	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.c855	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.c857	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.c859	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.c85b	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.c85d	d0 f0		bne $c84f			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c85f					_FPUNSetZero:
.c85f	a9 40		lda #$40			lda 	#$40
.c861	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.c863					_FPUNExit:
.c863	68		pla				pla
.c864	60		rts				rts
.c865					FPUToInteger:
.c865	48		pha				pha
.c866	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.c868	29 01		and #$01			and 	#1
.c86a	d0 31		bne $c89d			bne 	_FPUTOI_Exit
.c86c	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.c86e	70 23		bvs $c893			bvs 	_FPUTOI_Zero
.c870	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c872	10 1f		bpl $c893			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c874	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c876	b0 2b		bcs $c8a3			bcs 	FP_Overflow
.c878					_FPUToIToInteger:
.c878	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c87a	c9 a0		cmp #$a0			cmp 	#128+32
.c87c	f0 0c		beq $c88a			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c87e	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.c880	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c882	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c884	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c886	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c888	80 ee		bra $c878			bra 	_FPUToIToInteger 			; keep going.
.c88a					_FPUToICheckSign:
.c88a	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.c88c	10 0f		bpl $c89d			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c88e	20 fd c7	jsr $c7fd			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c891	80 0a		bra $c89d			bra 	_FPUTOI_Exit
.c893					_FPUTOI_Zero:
.c893	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c895	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c897	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c899	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c89b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c89d					_FPUToI_Exit:
.c89d	a9 01		lda #$01			lda 	#1 							; set type to integer
.c89f	95 85		sta $85,x			sta 	XS_Type,x
.c8a1	68		pla				pla
.c8a2	60		rts				rts
.c8a3					FP_Overflow:
.c8a3	20 79 ae	jsr $ae79			jsr ERR_Handler
>c8a6	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c8ae	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c8be					FPUTimes10:
.c8be	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c8c0	85 1a		sta $1a				sta 	ZLTemp1+0
.c8c2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c8c4	85 1b		sta $1b				sta 	ZLTemp1+1
.c8c6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c8c8	85 1c		sta $1c				sta 	ZLTemp1+2
.c8ca	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c8cc	85 1d		sta $1d				sta 	ZLTemp1+3
.c8ce	20 03 c9	jsr $c903			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c8d1	20 03 c9	jsr $c903			jsr 	_FPUT_LSR_ZLTemp1
.c8d4	18		clc				clc
.c8d5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c8d7	65 1a		adc $1a				adc 	ZLTemp1+0
.c8d9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c8db	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c8dd	65 1b		adc $1b				adc 	ZLTemp1+1
.c8df	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c8e1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c8e3	65 1c		adc $1c				adc 	ZLTemp1+2
.c8e5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c8e7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c8e9	65 1d		adc $1d				adc 	ZLTemp1+3
.c8eb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c8ed	90 0a		bcc $c8f9			bcc 	_FPUTimes10
.c8ef	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c8f1	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c8f3	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c8f5	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c8f7	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.c8f9					_FPUTimes10:
.c8f9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c8fb	18		clc				clc
.c8fc	69 03		adc #$03			adc 	#3
.c8fe	95 84		sta $84,x			sta 	XS_Exponent,x
.c900	b0 a1		bcs $c8a3			bcs 	FP_Overflow 				; error
.c902	60		rts				rts
.c903					_FPUT_LSR_ZLTemp1:
.c903	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c905	66 1c		ror $1c				ror 	ZLTemp1+2
.c907	66 1b		ror $1b				ror 	ZLTemp1+1
.c909	66 1a		ror $1a				ror 	ZLTemp1+0
.c90b	60		rts				rts
.c90c					FPUScale10A:
.c90c	5a		phy				phy
.c90d	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c90f	f0 37		beq $c948			beq 	_FPUScaleExit
.c911	da		phx				phx 								; save X
.c912	e8		inx				inx
.c913	e8		inx				inx
.c914	e8		inx				inx
.c915	e8		inx				inx
.c916	e8		inx				inx
.c917	e8		inx				inx
.c918	a8		tay				tay 								; save power scalar in Y.
.c919	a9 00		lda #$00			lda 	#0
.c91b	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c91d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c91f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c921	95 85		sta $85,x			sta 	XS_Type,x
.c923	a9 80		lda #$80			lda 	#$80
.c925	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c927	a9 81		lda #$81			lda 	#$81
.c929	95 84		sta $84,x			sta 	XS_Exponent,x
.c92b	5a		phy				phy 								; save 10^n on stack.
.c92c	c0 00		cpy #$00			cpy 	#0
.c92e	10 05		bpl $c935			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c930	98		tya				tya
.c931	49 ff		eor #$ff			eor 	#$FF
.c933	1a		inc a				inc 	a
.c934	a8		tay				tay
.c935					_FPUSAbs:
.c935	20 be c8	jsr $c8be			jsr 	FPUTimes10
.c938	88		dey				dey
.c939	d0 fa		bne $c935			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c93b	68		pla				pla 								; restore count in A
.c93c	fa		plx				plx 								; restore X pointing to number to scale.
.c93d	0a		asl a				asl 	a
.c93e	b0 05		bcs $c945			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c940	20 9d c6	jsr $c69d			jsr 	FPMultiply 					; if clear multiply.
.c943	80 03		bra $c948			bra		_FPUScaleExit
.c945					_FPUSDivide:
.c945	20 2a c6	jsr $c62a			jsr 	FPDivide
.c948					_FPUScaleExit:
.c948	7a		ply				ply
.c949	60		rts				rts
.c94a					FPUCopyToNext:
.c94a	a0 06		ldy #$06			ldy 		#6
.c94c	da		phx				phx
.c94d					_FPUCopy1:
.c94d	b5 80		lda $80,x			lda 	XS_Mantissa,x
.c94f	95 86		sta $86,x			sta 	XS2_Mantissa,x
.c951	e8		inx				inx
.c952	88		dey				dey
.c953	d0 f8		bne $c94d			bne 	_FPUCopy1
.c955	fa		plx				plx
.c956	60		rts				rts
.c957					FPUCopyFromNext:
.c957	a0 06		ldy #$06			ldy 		#6
.c959	da		phx				phx
.c95a					_FPUCopy1:
.c95a	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.c95c	95 80		sta $80,x			sta 	XS_Mantissa,x
.c95e	e8		inx				inx
.c95f	88		dey				dey
.c960	d0 f8		bne $c95a			bne 	_FPUCopy1
.c962	fa		plx				plx
.c963	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c964					FPToString:
.c964	48		pha				pha
.c965	5a		phy				phy
.c966	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.c968	50 0a		bvc $c974			bvc 		_FPTSIsFloat 			; if zero,
.c96a					_FPTSZero:
.c96a	a9 30		lda #$30			lda 		#"0"
.c96c	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter
.c96f					_FPTSExit:
.c96f	7a		ply				ply
.c970	68		pla				pla
.c971	60		rts				rts
.c972	80 fb		bra $c96f			bra 		_FPTSExit
.c974					_FPTSIsFloat:
.c974	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.c976	10 09		bpl $c981			bpl 		_FPTSNotSigned
.c978	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c97a	95 85		sta $85,x			sta 		XS_Type,x
.c97c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c97e	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter
.c981					_FPTSNotSigned:
.c981	b5 84		lda $84,x			lda 		XS_Exponent,x
.c983	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c985	b0 09		bcs $c990			bcs 		_FPTSExponent
.c987	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c989	90 05		bcc $c990			bcc 		_FPTSExponent 			;
.c98b					_FPTSStandard:
.c98b	20 cf c9	jsr $c9cf			jsr 		FPTOutputBody 			; output the body.
.c98e	80 df		bra $c96f			bra 		_FPTSExit
.c990					_FPTSExponent:
.c990	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c992	8d 9d 03	sta $039d			sta 		ExpCount
.c995					_FPTSExponentLoop:
.c995	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c997	10 0e		bpl $c9a7			bpl 		_FPTSTimes
.c999	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c99b	90 14		bcc $c9b1			bcc 		_FPTSScaledToExp
.c99d	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c99f	20 0c c9	jsr $c90c			jsr 		FPUScale10A
.c9a2	ee 9d 03	inc $039d			inc 		ExpCount
.c9a5	80 ee		bra $c995			bra 		_FPTSExponentLoop
.c9a7					_FPTSTimes:
.c9a7	a9 01		lda #$01			lda 		#1
.c9a9	20 0c c9	jsr $c90c			jsr 		FPUScale10A
.c9ac	ce 9d 03	dec $039d			dec 		ExpCount
.c9af	80 e4		bra $c995			bra 		_FPTSExponentLoop
.c9b1					_FPTSScaledToExp:
.c9b1	20 cf c9	jsr $c9cf			jsr 		FPTOutputBody 			; output the body.
.c9b4	a9 65		lda #$65			lda 		#"e"					; output E
.c9b6	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter
.c9b9	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.c9bc	95 80		sta $80,x			sta 		XS_Mantissa,x
.c9be	29 80		and #$80			and 		#$80 					; sign extend it
.c9c0	f0 02		beq $c9c4			beq 		_FPTSSExt
.c9c2	a9 ff		lda #$ff			lda 		#$FF
.c9c4					_FPTSSExt:
.c9c4	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.c9c6	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.c9c8	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.c9ca	20 2d c4	jsr $c42d			jsr 		INTToString 			; output the exponent.
.c9cd	80 a0		bra $c96f			bra			_FPTSExit 				; and exit.
.c9cf					FPTOutputBody:
.c9cf	20 4a c9	jsr $c94a			jsr 		FPUCopyToNext 			; copy to next slot.
.c9d2	20 65 c8	jsr $c865			jsr 		FPUToInteger 			; convert to an integer
.c9d5	20 2d c4	jsr $c42d			jsr 		INTToString 			; output the main integer part.
.c9d8	20 57 c9	jsr $c957			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c9db	20 25 c7	jsr $c725			jsr 		FPFractionalPart 		; get the decimal part.
.c9de	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.c9e0	70 3c		bvs $ca1e			bvs 		_FPTOExit 				; if not, exit now.
.c9e2	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c9e4	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter
.c9e7					_FPOutLoop:
.c9e7	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.c9e9	70 1d		bvs $ca08			bvs 		_FPStripZeros 			; strip trailing zeros
.c9eb	20 be c8	jsr $c8be			jsr 		FPUTimes10 				; multiply by 10
.c9ee	20 4a c9	jsr $c94a			jsr 		FPUCopyToNext			; copy to next slot.
.c9f1	20 65 c8	jsr $c865			jsr 		FPUToInteger 			; convert to integer
.c9f4	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.c9f6	09 30		ora #$30			ora 		#"0"
.c9f8	20 cb c4	jsr $c4cb			jsr 		ITSOutputCharacter
.c9fb	20 57 c9	jsr $c957			jsr 		FPUCopyFromNext 		; get it back
.c9fe	20 25 c7	jsr $c725			jsr 		FPFractionalPart 		; get fractional part
.ca01	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.ca04	c9 0b		cmp #$0b			cmp 	 	#11
.ca06	90 df		bcc $c9e7			bcc 		_FPOutLoop 				; if so, keep going till zero.
.ca08					_FPStripZeros:
.ca08	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.ca0b					_FPStripLoop:
.ca0b	88		dey				dey 								; back one, if at start then no strip
.ca0c	f0 10		beq $ca1e			beq 		_FPToExit
.ca0e	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.ca11	c9 30		cmp #$30			cmp 		#"0"
.ca13	f0 f6		beq $ca0b			beq 		_FPStripLoop
.ca15	c8		iny				iny
.ca16	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.ca18	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.ca1b	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.ca1e					_FPTOExit:
.ca1e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.ca1f					FPFromString:
.ca1f	48		pha				pha 								; push A
.ca20	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.ca22	c9 2e		cmp #$2e			cmp 	#"."
.ca24	f0 03		beq $ca29			beq	 	_FPFIsDecimal
.ca26	4c 85 ca	jmp $ca85			jmp 	_FPFNotDecimal
.ca29					_FPFIsDecimal:
.ca29	c8		iny				iny 								; consume the decimal.
.ca2a	20 19 c8	jsr $c819			jsr 	FPUToFloat 					; convert the integer to float.
.ca2d	da		phx				phx 								; save X.
.ca2e	5a		phy				phy 								; save decimal start position
.ca2f	e8		inx				inx
.ca30	e8		inx				inx
.ca31	e8		inx				inx
.ca32	e8		inx				inx
.ca33	e8		inx				inx
.ca34	e8		inx				inx
.ca35	20 e3 c4	jsr $c4e3			jsr 	INTFromStringY 				; get the part after the DP.
.ca38	20 19 c8	jsr $c819			jsr 	FPUToFloat 					; convert that to a float.
.ca3b	68		pla				pla 								; calculate - chars consumed.
.ca3c	8c 9c 03	sty $039c			sty 	ExpTemp
.ca3f	38		sec				sec
.ca40	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.ca43	20 0c c9	jsr $c90c			jsr 	FPUScale10A 				; scale it by 10^AC
.ca46	fa		plx				plx 								; restore original X
.ca47	20 76 c5	jsr $c576			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.ca4a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.ca4c	c9 45		cmp #$45			cmp 	#"E"
.ca4e	f0 04		beq $ca54			beq 	_FPFExponent
.ca50	c9 65		cmp #$65			cmp 	#"e"
.ca52	d0 31		bne $ca85			bne 	_FPFNotDecimal 				; no, then exit normally.
.ca54					_FPFExponent:
.ca54	c8		iny				iny 								; skip over E symbol.
.ca55	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.ca57	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.ca59	d0 01		bne $ca5c			bne 	_FPFGotSign
.ca5b	c8		iny				iny 								; if it was - skip over it.
.ca5c					_FPFGotSign:
.ca5c	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.ca5d	da		phx				phx
.ca5e	e8		inx				inx
.ca5f	e8		inx				inx
.ca60	e8		inx				inx
.ca61	e8		inx				inx
.ca62	e8		inx				inx
.ca63	e8		inx				inx
.ca64	20 e3 c4	jsr $c4e3			jsr 	INTFromStringY 				; get the exponent
.ca67	fa		plx				plx 								; restore X.
.ca68	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.ca6a	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.ca6c	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.ca6e	d0 17		bne $ca87			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.ca70	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.ca72	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.ca74	b0 11		bcs $ca87			bcs 	_FPFXOverflow
.ca76	68		pla				pla 								; get direction
.ca77	d0 07		bne $ca80			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.ca79	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.ca7b	49 ff		eor #$ff			eor 	#$FF
.ca7d	1a		inc a				inc 	a
.ca7e	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.ca80					_FPFXScale:
.ca80	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.ca82	20 0c c9	jsr $c90c			jsr 	FPUScale10A 				; scale by the exponent.
.ca85					_FPFNotDecimal:
.ca85	68		pla				pla
.ca86	60		rts				rts
.ca87					_FPFXOverflow:
.ca87	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ca8a	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>ca92	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.ca99					Unary_Rnd:
.ca99	20 65 b8	jsr $b865			jsr 	EvaluateNumberX 			; get value
.ca9c	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; check right bracket.
.ca9f	20 e3 ba	jsr $bae3			jsr 	GetSignCurrent 				; get sign -1,0,1.
.caa2	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.caa4	30 10		bmi $cab6			bmi 	_URSetSeed
.caa6	f0 28		beq $cad0			beq 	_URMakeRandom 				; if zero return same number.
.caa8	da		phx				phx
.caa9	a2 00		ldx #$00			ldx 	#0
.caab	20 07 cb	jsr $cb07			jsr 	Random16
.caae	a2 02		ldx #$02			ldx 	#2
.cab0	20 07 cb	jsr $cb07			jsr 	Random16
.cab3	fa		plx				plx
.cab4	80 1a		bra $cad0			bra 	_URMakeRandom
.cab6					_URSetSeed:
.cab6	20 19 c8	jsr $c819			jsr 	FPUToFloat 					; make it a float to twiddle it.
.cab9	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.cabb	8d a3 03	sta $03a3			sta 	RandomSeed+0
.cabe	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.cac0	8d a4 03	sta $03a4			sta 	RandomSeed+1
.cac3	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.cac5	8d a5 03	sta $03a5			sta 	RandomSeed+2
.cac8	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.caca	0a		asl a				asl 	a
.cacb	49 db		eor #$db			eor 	#$DB
.cacd	8d a6 03	sta $03a6			sta 	RandomSeed+3
.cad0					_URMakeRandom:
.cad0	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.cad3	0d a4 03	ora $03a4			ora 	RandomSeed+1
.cad6	0d a5 03	ora $03a5			ora 	RandomSeed+2
.cad9	0d a6 03	ora $03a6			ora 	RandomSeed+3
.cadc	d0 0a		bne $cae8			bne 	_URNotZero
.cade	a9 47		lda #$47			lda 	#$47
.cae0	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.cae3	a9 3d		lda #$3d			lda 	#$3D
.cae5	8d a6 03	sta $03a6			sta 	RandomSeed+3
.cae8					_URNotZero:
.cae8	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.caeb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.caed	ad a4 03	lda $03a4			lda 	RandomSeed+1
.caf0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.caf2	ad a5 03	lda $03a5			lda 	RandomSeed+2
.caf5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.caf7	ad a6 03	lda $03a6			lda 	RandomSeed+3
.cafa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cafc	a9 00		lda #$00			lda 	#$00 						; set type to float.
.cafe	95 85		sta $85,x			sta 	XS_Type,x
.cb00	a9 80		lda #$80			lda 	#$80
.cb02	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.cb04	4c 46 c8	jmp $c846			jmp 	FPUNormalise
.cb07					Random16:
.cb07	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.cb0a	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.cb0d	90 08		bcc $cb17			bcc 	_R16_NoXor
.cb0f	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.cb12	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.cb14	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.cb17					_R16_NoXor:
.cb17	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.cb18					Unary_Int:
.cb18	20 65 b8	jsr $b865			jsr 	EvaluateNumberX 			; get value
.cb1b	20 a3 be	jsr $bea3			jsr 	CheckNextRParen 			; check right bracket.
.cb1e	4c 65 c8	jmp $c865			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.cb21	80 fe		bra $cb21	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
