
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 29 01:21:33 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a7					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03af					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b7					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b8					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03ba					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bc					Tim_SR:		.byte ? 						; Processor Status
>03bd					Tim_A:		.byte ? 						; Processor Registers
>03be					Tim_X:		.byte ?
>03bf					Tim_Y:		.byte ?
>03c0					Tim_Z:		.byte ?
>03c1					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	12 02 00 18 bb 84 40 c0			.byte	$12,$02,$00,$18,$bb,$84,$40,$c0
>8008	d6 fe 08 53 74 61 72 74			.byte	$d6,$fe,$08,$53,$74,$61,$72,$74
>8010	2e 00 0a 03 00 91 c0 19			.byte	$2e,$00,$0a,$03,$00,$91,$c0,$19
>8018	bb 84 40 00 1b 04 00 91			.byte	$bb,$84,$40,$00,$1b,$04,$00,$91
>8020	c0 19 bb 84 19 bb 8a 41			.byte	$c0,$19,$bb,$84,$19,$bb,$8a,$41
>8028	c0 d6 18 bb c1 19 bb c1			.byte	$c0,$d6,$18,$bb,$c1,$19,$bb,$c1
>8030	c0 96 19 bb 84 43 00 14			.byte	$c0,$96,$19,$bb,$84,$43,$00,$14
>8038	05 00 d6 c0 18 bb 84 18			.byte	$05,$00,$d6,$c0,$18,$bb,$84,$18
>8040	bb 8a 41 c0 96 18 bb 84			.byte	$bb,$8a,$41,$c0,$96,$18,$bb,$84
>8048	4f 68 00 0b 06 00 d6 fe			.byte	$4f,$68,$00,$0b,$06,$00,$d6,$fe
>8050	06 45 6e 64 2e 00 05 07			.byte	$06,$45,$6e,$64,$2e,$00,$05,$07
>8058	00 c4 00 00				.byte	$00,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c 61 b0	jmp $b061		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 05	sta $0500			sta 	IFT_XCursor
.a071	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a074	ad 01 05	lda $0501			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 05	sta $0500			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 05	inc $0500			inc 	IFT_XCursor
.a150	ad 00 05	lda $0500			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 05	dec $0501			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 05	sta $0501			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 05	inc $0501			inc 	IFT_YCursor
.a168	ad 01 05	lda $0501			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 05	lda $0501			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 05	inc $0500			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae c1 03	ldx $03c1			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad bc 03	lda $03bc			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad bd 03	lda $03bd			lda 	TIM_A 						; restore AXYZ
.ab9f	ae be 03	ldx $03be			ldx 	TIM_X
.aba2	ac bf 03	ldy $03bf			ldy 	TIM_Y
.aba5	ab c0 03	ldz $03c0			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d bb 03	sta $03bb			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d ba 03	sta $03ba			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd b8 03	lda $03b8,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d bd 03	sta $03bd			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e be 03	stx $03be			stx 	TIM_X
.acaa	8c bf 03	sty $03bf			sty 	TIM_Y
.acad	9c c0 03	stz $03c0			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d bc 03	sta $03bc			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d b9 03	sta $03b9			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d b8 03	sta $03b8			sta 	TIM_PC 						; high byte
.acbc	ad b9 03	lda $03b9			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce b8 03	dec $03b8			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce b9 03	dec $03b9			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e c1 03	stx $03c1			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d b9 03	sta $03b9			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d b8 03	sta $03b8			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d bc 03	sta $03bc,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.ad1d					StackReset:
.ad1d	48		pha				pha
.ad1e	5a		phy				phy
.ad1f	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.ad21	85 26		sta $26				sta 	zBasicSP
.ad23	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.ad25	85 27		sta $27				sta 	zBasicSP+1
.ad27	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.ad29	98		tya				tya 								; be a legal token.
.ad2a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad2c	7a		ply				ply
.ad2d	68		pla				pla
.ad2e	60		rts				rts
.ad2f					StackPushFrame:
.ad2f	48		pha				pha
.ad30	5a		phy				phy
.ad31	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.ad32	48		pha				pha 								; save it.
.ad33	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.ad35	18		clc				clc 								; add to Basic Stack
.ad36	65 26		adc $26				adc 	zBasicSP
.ad38	85 26		sta $26				sta 	zBasicSP
.ad3a	90 02		bcc $ad3e			bcc 	_SPFNoBump
.ad3c	e6 27		inc $27				inc 	zBasicSP+1
.ad3e					_SPFNoBump:
.ad3e	a0 00		ldy #$00			ldy 	#0
.ad40	68		pla				pla
.ad41	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad43	7a		ply				ply
.ad44	68		pla				pla
.ad45	60		rts				rts
.ad46					StackPopFrame:
.ad46	48		pha				pha
.ad47	5a		phy				phy
.ad48	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.ad4a	51 26		eor ($26),y			eor 	(zBasicSP),y
.ad4c	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ad4e	d0 12		bne $ad62			bne 	_SPFError 					; mixed structures
.ad50	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.ad52	29 0f		and #$0f			and 	#$0F
.ad54	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ad56	38		sec				sec
.ad57	65 26		adc $26				adc 	zBasicSP
.ad59	85 26		sta $26				sta 	zBasicSP
.ad5b	b0 02		bcs $ad5f			bcs 	_SPFNoBump
.ad5d	c6 27		dec $27				dec 	zBasicSP+1
.ad5f					_SPFNoBump:
.ad5f	7a		ply				ply
.ad60	68		pla				pla
.ad61	60		rts				rts
.ad62					_SPFError:
.ad62	20 e4 ad	jsr $ade4			jsr ERR_Handler
>ad65	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ad6d	72 75 63 74 75 72 65 73 00
.ad76					StackSavePosition:
.ad76	6b		tza				tza
.ad77	5a		phy				phy
.ad78	a0 05		ldy #$05			ldy 	#5
.ad7a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad7c	a0 01		ldy #$01			ldy 	#1
.ad7e	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ad80	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad82	c8		iny				iny
.ad83	a5 17		lda $17				lda 	zCodePtr+1
.ad85	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad87	c8		iny				iny
.ad88	a5 18		lda $18				lda 	zCodePtr+2
.ad8a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad8c	c8		iny				iny
.ad8d	a5 19		lda $19				lda 	zCodePtr+3
.ad8f	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad91	7a		ply				ply
.ad92	60		rts				rts
.ad93					StackRestorePosition:
.ad93	5a		phy				phy
.ad94	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ad96	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad98	85 16		sta $16				sta 	zCodePtr+0
.ad9a	c8		iny				iny
.ad9b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad9d	85 17		sta $17				sta 	zCodePtr+1
.ad9f	c8		iny				iny
.ada0	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada2	85 18		sta $18				sta 	zCodePtr+2
.ada4	c8		iny				iny
.ada5	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada7	85 19		sta $19				sta 	zCodePtr+3
.ada9	c8		iny				iny
.adaa	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.adac	7a		ply				ply 								; restore Y
.adad	4b		taz				taz
.adae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.adaf					CharPrint:
.adaf	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.adb2					CharGet:
.adb2	4c 06 a2	jmp $a206			jmp 	IF_GetKey

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.adb5					SyntaxError:
.adb5	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>adb8	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>adc0	72 72 6f 72 00
.adc5					TypeError:
.adc5	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>adc8	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>add0	70 65 00
.add3					BadParamError:
.add3	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>add6	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>adde	6d 65 74 65 72 00
.ade4					ERR_Handler:
.ade4	a3 00		ldz #$00			ldz 	#0
.ade6	1b		inz				inz
.ade7	ea		nop				nop
.ade8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adea	85 80		sta $80				sta 	XS_Mantissa
.adec	1b		inz				inz
.aded	ea		nop				nop
.adee	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adf0	85 81		sta $81				sta 	XS_Mantissa+1
.adf2	fa		plx				plx 								; address in XY
.adf3	7a		ply				ply
.adf4	e8		inx				inx 								; bump, because of RTS/JSR address -1
.adf5	d0 01		bne $adf8			bne 	_EHNoSkip
.adf7	c8		iny				iny
.adf8					_EHNoSkip:
.adf8	20 17 ae	jsr $ae17			jsr 	PrintROMMessage 			; print message from ROM.
.adfb	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.adfd	05 81		ora $81				ora 	XS_Mantissa+1
.adff	f0 0c		beq $ae0d			beq 	_EHNoLine
.ae01	a2 12		ldx #$12			ldx 	#_EHAt & $FF 				; print " at "
.ae03	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.ae05	20 17 ae	jsr $ae17			jsr 	PrintROMMessage
.ae08	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ae0a	20 28 ae	jsr $ae28			jsr 	Print16BitInteger
.ae0d					_EHNoLine:
.ae0d	80 fe		bra $ae0d			bra 	_EHNoLine
.ae0f	4c 84 b0	jmp $b084			jmp 	WarmStart
>ae12	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ae17					PrintROMMessage:
.ae17	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ae19	84 1b		sty $1b				sty 	zLTemp1+1
.ae1b	a0 00		ldy #$00			ldy 	#0
.ae1d					_PRMLoop:
.ae1d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ae1f	f0 06		beq $ae27			beq		_PRMExit
.ae21	c8		iny				iny
.ae22	20 af ad	jsr $adaf			jsr 	CharPrint
.ae25	80 f6		bra $ae1d			bra 	_PRMLoop
.ae27					_PRMExit:
.ae27	60		rts				rts
.ae28					Print16BitInteger:
.ae28	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ae2a	85 82		sta $82				sta 	XS_Mantissa+2
.ae2c	85 83		sta $83				sta 	XS_Mantissa+3
.ae2e	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.ae31	aa		tax				tax 								; convert bottom level.
.ae32	20 b2 c0	jsr $c0b2			jsr 	INTToString 				; make string
.ae35	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ae37	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.ae3a	f0 06		beq $ae42			beq 	_P1Exit
.ae3c	20 af ad	jsr $adaf			jsr 	CharPrint
.ae3f	e8		inx				inx
.ae40	80 f5		bra $ae37			bra 	_P1Loop
.ae42	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.ae43					VectorTable:
>ae43	29 b5					.word BinaryOp_And         & $FFFF ; $80 and
>ae45	45 b5					.word BinaryOp_Or          & $FFFF ; $81 or
>ae47	61 b5					.word BinaryOp_Xor         & $FFFF ; $82 xor
>ae49	61 b5					.word BinaryOp_Eor         & $FFFF ; $83 eor
>ae4b	98 b5					.word Binary_Equal         & $FFFF ; $84 =
>ae4d	b2 b5					.word Binary_NotEqual      & $FFFF ; $85 <>
>ae4f	bb b5					.word Binary_Less          & $FFFF ; $86 <
>ae51	c4 b5					.word Binary_LessEqual     & $FFFF ; $87 <=
>ae53	d6 b5					.word Binary_Greater       & $FFFF ; $88 >
>ae55	cd b5					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>ae57	5b b6					.word BinaryOp_Add         & $FFFF ; $8a +
>ae59	77 b6					.word BinaryOp_Subtract    & $FFFF ; $8b -
>ae5b	88 b6					.word BinaryOp_Multiply    & $FFFF ; $8c *
>ae5d	99 b6					.word BinaryOp_Divide      & $FFFF ; $8d /
>ae5f	ff ae					.word NotImplemented       & $FFFF ; $8e ^
>ae61	ff ae					.word NotImplemented       & $FFFF ; $8f if
>ae63	ff ae					.word NotImplemented       & $FFFF ; $90 while
>ae65	4d b3					.word Command_REPEAT       & $FFFF ; $91 repeat
>ae67	ff ae					.word NotImplemented       & $FFFF ; $92 for
>ae69	ff ae					.word NotImplemented       & $FFFF ; $93 then
>ae6b	ff ae					.word NotImplemented       & $FFFF ; $94 endif
>ae6d	ff ae					.word NotImplemented       & $FFFF ; $95 wend
>ae6f	56 b3					.word Command_UNTIL        & $FFFF ; $96 until
>ae71	ff ae					.word NotImplemented       & $FFFF ; $97 next
>ae73	ff ae					.word NotImplemented       & $FFFF ; $98 not
>ae75	ff ae					.word NotImplemented       & $FFFF ; $99 fn(
>ae77	9e b7					.word Unary_Abs            & $FFFF ; $9a abs(
>ae79	de b8					.word Unary_Asc            & $FFFF ; $9b asc(
>ae7b	9d c7					.word Unary_Int            & $FFFF ; $9c int(
>ae7d	b8 b7					.word Unary_Peek           & $FFFF ; $9d peek(
>ae7f	1e c7					.word Unary_Rnd            & $FFFF ; $9e rnd(
>ae81	1f b8					.word Unary_Usr            & $FFFF ; $9f usr(
>ae83	1d b9					.word Unary_Left           & $FFFF ; $a0 left$(
>ae85	32 b9					.word Unary_Right          & $FFFF ; $a1 right$(
>ae87	04 b9					.word Unary_Mid            & $FFFF ; $a2 mid$(
>ae89	7b ba					.word Unary_Spc            & $FFFF ; $a3 spc(
>ae8b	ac b8					.word Unary_Str            & $FFFF ; $a4 str$(
>ae8d	40 b8					.word Unary_Val            & $FFFF ; $a5 val(
>ae8f	f5 b8					.word Unary_Len            & $FFFF ; $a6 len(
>ae91	aa b9					.word Unary_Hex            & $FFFF ; $a7 hex$(
>ae93	ff ae					.word NotImplemented       & $FFFF ; $a8 sin(
>ae95	ff ae					.word NotImplemented       & $FFFF ; $a9 cos(
>ae97	ff ae					.word NotImplemented       & $FFFF ; $aa tan(
>ae99	ff ae					.word NotImplemented       & $FFFF ; $ab atn(
>ae9b	ff ae					.word NotImplemented       & $FFFF ; $ac exp(
>ae9d	ff ae					.word NotImplemented       & $FFFF ; $ad log(
>ae9f	ff ae					.word NotImplemented       & $FFFF ; $ae sqr(
>aea1	00 ba					.word Unary_Dec            & $FFFF ; $af dec(
>aea3	bc b7					.word Unary_Deek           & $FFFF ; $b0 deek(
>aea5	c0 b7					.word Unary_Leek           & $FFFF ; $b1 leek(
>aea7	ec b7					.word Unary_Mod            & $FFFF ; $b2 mod(
>aea9	58 b7					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>aeab	5d ba					.word Unary_Chr            & $FFFF ; $b4 chr$(
>aead	ff ae					.word NotImplemented       & $FFFF ; $b5 pos(
>aeaf	ff ae					.word NotImplemented       & $FFFF ; $b6 tab(
>aeb1	ff ae					.word NotImplemented       & $FFFF ; $b7 $
>aeb3	ff ae					.word NotImplemented       & $FFFF ; $b8 $(
>aeb5	ff ae					.word NotImplemented       & $FFFF ; $b9 #
>aeb7	ff ae					.word NotImplemented       & $FFFF ; $ba #(
>aeb9	ff ae					.word NotImplemented       & $FFFF ; $bb %
>aebb	ff ae					.word NotImplemented       & $FFFF ; $bc %(
>aebd	ff ae					.word NotImplemented       & $FFFF ; $bd (
>aebf	ff ae					.word NotImplemented       & $FFFF ; $be )
>aec1	ff ae					.word NotImplemented       & $FFFF ; $bf ,
>aec3	93 b1					.word Command_COLON        & $FFFF ; $c0 :
>aec5	ff ae					.word NotImplemented       & $FFFF ; $c1 ;
>aec7	ff ae					.word NotImplemented       & $FFFF ; $c2 def
>aec9	31 b3					.word Command_CLR          & $FFFF ; $c3 clr
>aecb	45 b3					.word Command_STOP         & $FFFF ; $c4 stop
>aecd	ff ae					.word NotImplemented       & $FFFF ; $c5 data
>aecf	ff ae					.word NotImplemented       & $FFFF ; $c6 read
>aed1	8a b0					.word Command_DIM          & $FFFF ; $c7 dim
>aed3	ff ae					.word NotImplemented       & $FFFF ; $c8 to
>aed5	ff ae					.word NotImplemented       & $FFFF ; $c9 step
>aed7	a7 b2					.word Command_GOSUB        & $FFFF ; $ca gosub
>aed9	b5 b2					.word Command_RETURN       & $FFFF ; $cb return
>aedb	a1 b2					.word Command_GOTO         & $FFFF ; $cc goto
>aedd	b5 b1					.word Command_END          & $FFFF ; $cd end
>aedf	ff ae					.word NotImplemented       & $FFFF ; $ce input
>aee1	94 b1					.word Command_LET          & $FFFF ; $cf let
>aee3	ff ae					.word NotImplemented       & $FFFF ; $d0 list
>aee5	43 b2					.word Command_NEW          & $FFFF ; $d1 new
>aee7	62 b2					.word Command_OLD          & $FFFF ; $d2 old
>aee9	ff ae					.word NotImplemented       & $FFFF ; $d3 on
>aeeb	ff ae					.word NotImplemented       & $FFFF ; $d4 restore
>aeed	ff ae					.word NotImplemented       & $FFFF ; $d5 poke
>aeef	ba b1					.word Command_PRINT        & $FFFF ; $d6 print
>aef1	14 b1					.word Command_RUN          & $FFFF ; $d7 run
>aef3	ff ae					.word NotImplemented       & $FFFF ; $d8 wait
>aef5	ff ae					.word NotImplemented       & $FFFF ; $d9 sys
>aef7	ff ae					.word NotImplemented       & $FFFF ; $da doke
>aef9	ff ae					.word NotImplemented       & $FFFF ; $db loke
>aefb	2b b2					.word Command_ASSERT       & $FFFF ; $dc assert
>aefd	ff ae					.word NotImplemented       & $FFFF ; $dd get
.aeff					NotImplemented:
.aeff	20 e4 ad	jsr $ade4			jsr ERR_Handler
>af02	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>af0a	65 6d 65 6e 74 65 64 00
.af12					BinaryPrecedence:
>af12	01					.byte 1    ; $80 and
>af13	01					.byte 1    ; $81 or
>af14	01					.byte 1    ; $82 xor
>af15	01					.byte 1    ; $83 eor
>af16	02					.byte 2    ; $84 =
>af17	02					.byte 2    ; $85 <>
>af18	02					.byte 2    ; $86 <
>af19	02					.byte 2    ; $87 <=
>af1a	02					.byte 2    ; $88 >
>af1b	02					.byte 2    ; $89 >=
>af1c	03					.byte 3    ; $8a +
>af1d	03					.byte 3    ; $8b -
>af1e	04					.byte 4    ; $8c *
>af1f	04					.byte 4    ; $8d /
>af20	05					.byte 5    ; $8e ^
.af21					KeywordText:
>af21	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>af24	4f d2					.byte $4f,$d2                          ; $81 or
>af26	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>af29	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>af2c	bd					.byte $bd                              ; $84 =
>af2d	3c be					.byte $3c,$be                          ; $85 <>
>af2f	bc					.byte $bc                              ; $86 <
>af30	3c bd					.byte $3c,$bd                          ; $87 <=
>af32	be					.byte $be                              ; $88 >
>af33	3e bd					.byte $3e,$bd                          ; $89 >=
>af35	ab					.byte $ab                              ; $8a +
>af36	ad					.byte $ad                              ; $8b -
>af37	aa					.byte $aa                              ; $8c *
>af38	af					.byte $af                              ; $8d /
>af39	de					.byte $de                              ; $8e ^
>af3a	49 c6					.byte $49,$c6                          ; $8f if
>af3c	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>af41	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>af47	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>af4a	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>af4e	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>af53	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>af57	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>af5c	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>af60	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>af63	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>af66	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>af6a	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>af6e	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>af72	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>af77	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>af7b	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>af7f	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>af85	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>af8c	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>af91	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>af95	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>af9a	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>af9e	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>afa2	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>afa7	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>afab	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>afaf	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>afb3	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>afb7	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>afbb	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>afbf	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>afc3	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>afc7	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>afcc	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>afd1	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>afd5	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>afd9	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>afde	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>afe2	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>afe6	a4					.byte $a4                              ; $b7 $
>afe7	24 a8					.byte $24,$a8                          ; $b8 $(
>afe9	a3					.byte $a3                              ; $b9 #
>afea	23 a8					.byte $23,$a8                          ; $ba #(
>afec	a5					.byte $a5                              ; $bb %
>afed	25 a8					.byte $25,$a8                          ; $bc %(
>afef	a8					.byte $a8                              ; $bd (
>aff0	a9					.byte $a9                              ; $be )
>aff1	ac					.byte $ac                              ; $bf ,
>aff2	ba					.byte $ba                              ; $c0 :
>aff3	bb					.byte $bb                              ; $c1 ;
>aff4	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>aff7	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>affa	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>affe	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b002	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b006	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b009	54 cf					.byte $54,$cf                          ; $c8 to
>b00b	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b00f	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b014	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b01a	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b01e	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b021	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b026	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b029	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b02d	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b030	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b033	4f ce					.byte $4f,$ce                          ; $d3 on
>b035	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b03c	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b040	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b045	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b048	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b04c	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b04f	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b053	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b057	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b05d	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b060	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.b061					BASIC_Start:
.b061	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.b064	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b067	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b069	8d 10 03	sta $0310			sta 	LocalVector
.b06c	8d 0c 03	sta $030c			sta 	UserVector
.b06f	a9 2e		lda #$2e			lda 	#USRDefault & $FF 			; reset USR vector
.b071	8d 0d 03	sta $030d			sta 	UserVector+1
.b074	a9 b8		lda #$b8			lda 	#(USRDefault >> 8) & $FF
.b076	8d 0e 03	sta $030e			sta 	UserVector+2
.b079	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b07b	8d 0f 03	sta $030f			sta 	UserVector+3
.b07e	20 c7 ba	jsr $bac7			jsr 	UpdateProgramEnd 			; update the program end.
.b081	20 31 b3	jsr $b331			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b084					WarmStart:
.b084	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b086	9a		txs				txs
.b087	4c 14 b1	jmp $b114			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b08a					Command_DIM:
.b08a	6b		tza				tza
.b08b	48		pha				pha 								; push on stack.
.b08c	20 39 bc	jsr $bc39			jsr 	VariableExtract 			; get the identifier
.b08f	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b092	29 01		and #$01			and 	#1
.b094	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b096	d0 6e		bne $b106			bne 	_CDIError
.b098	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b09a	8d b7 03	sta $03b7			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b09d					_CDIGetDimension:
.b09d	ad b7 03	lda $03b7			lda 	UsrArrayIdx 				; done too many ?
.b0a0	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b0a2	f0 62		beq $b106			beq 	_CDIError
.b0a4	20 0a b5	jsr $b50a			jsr 	EvaluateInteger 			; evaluate an index size
.b0a7	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b0a9	29 80		and #$80			and 	#$80
.b0ab	05 82		ora $82				ora 	XS_Mantissa+2
.b0ad	05 83		ora $83				ora 	XS_Mantissa+3
.b0af	d0 55		bne $b106			bne 	_CDIError
.b0b1	ae b7 03	ldx $03b7			ldx 	UsrArrayIdx 				; copy into the array table.
.b0b4	18		clc				clc 								; add 1 - max index => size.
.b0b5	a5 80		lda $80				lda 	XS_Mantissa+0
.b0b7	69 01		adc #$01			adc 	#1
.b0b9	9d af 03	sta $03af,x			sta 	UsrArrayDef+0,x
.b0bc	a5 81		lda $81				lda 	XS_Mantissa+1
.b0be	69 00		adc #$00			adc 	#0
.b0c0	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+1,x
.b0c3	30 41		bmi $b106			bmi 	_CDIError 					; could be dim a(32767)
.b0c5	e8		inx				inx 								; bump index.
.b0c6	e8		inx				inx
.b0c7	8e b7 03	stx $03b7			stx 	UsrArrayIdx
.b0ca	ea		nop				nop
.b0cb	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0cd	1b		inz				inz
.b0ce	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b0d0	f0 cb		beq $b09d			beq 	_CDIGetDimension
.b0d2	3b		dez				dez
.b0d3	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; closing ) present ?
.b0d6	ae b7 03	ldx $03b7			ldx 	UsrArrayIdx 				; copy USR array to default
.b0d9	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b0db	9d a8 03	sta $03a8,x			sta 	ArrayDef+1,x
.b0de					_CDICopy:
.b0de	bd af 03	lda $03af,x			lda 	UsrArrayDef,x
.b0e1	9d a7 03	sta $03a7,x			sta 	ArrayDef,x
.b0e4	ca		dex				dex
.b0e5	10 f7		bpl $b0de			bpl 	_CDICopy
.b0e7	68		pla				pla									; position of array identifier
.b0e8	85 10		sta $10				sta 	zTemp1
.b0ea	6b		tza				tza
.b0eb	48		pha				pha
.b0ec	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b0ee	4b		taz				taz
.b0ef	20 39 bc	jsr $bc39			jsr 	VariableExtract 			; get the identifier
.b0f2	20 d4 be	jsr $bed4			jsr 	VariableLocate 				; check if it exists already.
.b0f5	b0 0f		bcs $b106			bcs 	_CDIError
.b0f7	20 c7 bc	jsr $bcc7			jsr 	VariableCreate 				; create it using the current ArrayDef
.b0fa	68		pla				pla 								; restore code position
.b0fb	4b		taz				taz
.b0fc	ea		nop				nop
.b0fd	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0ff	1b		inz				inz
.b100	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b102	f0 86		beq $b08a			beq 	Command_DIM
.b104	3b		dez				dez
.b105	60		rts				rts
.b106					_CDIError:
.b106	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b109	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b111					_CDISyntax:
.b111	4c b5 ad	jmp $adb5			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b114					Command_RUN:
.b114	20 31 b3	jsr $b331			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b117	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b119	85 16		sta $16				sta 	zCodePtr+0
.b11b	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b11d	85 17		sta $17				sta 	zCodePtr+1
.b11f	a9 02		lda #$02			lda 	#2
.b121	85 18		sta $18				sta 	zCodePtr+2
.b123	a9 00		lda #$00			lda 	#0
.b125	85 19		sta $19				sta 	zCodePtr+3
.b127	a3 03		ldz #$03			ldz 	#3
.b129					RUN_NewLine:
.b129	a3 00		ldz #$00			ldz 	#0
.b12b	ea		nop				nop
.b12c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b12e	1b		inz				inz
.b12f	1b		inz				inz
.b130	1b		inz				inz
.b131	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b133	d0 18		bne $b14d			bne 	RUN_NextCommand
.b135	4c b5 b1	jmp $b1b5			jmp 	Command_END 				; go do the command code.
.b138					RUN_Skip:
.b138	ea		nop				nop
.b139	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b13b	1b		inz				inz 								; skip
.b13c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b13e	90 0d		bcc $b14d			bcc 	_SEDone 					; so just skip over it.
.b140	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b142	90 08		bcc $b14c			bcc 	_SEDouble
.b144	6b		tza				tza 								; this is Y + 1
.b145	18		clc				clc
.b146	ea		nop				nop
.b147	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b149	4b		taz				taz 								; back in Y.
.b14a	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b14b	3b		dez				dez
.b14c					_SEDouble:
.b14c	1b		inz				inz
.b14d					_SEDone:
.b14d					RUN_NextCommand:
.b14d	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b14f	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b151	ea		nop				nop
.b152	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b154	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b156	f0 e0		beq $b138			beq 	RUN_Skip
.b158	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b15a	d0 10		bne $b16c			bne 	RUN_Execute
.b15c					RUN_NextLine:
.b15c	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b15e	ea		nop				nop
.b15f	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b161	18		clc				clc
.b162	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b164	85 16		sta $16				sta 	zCodePtr
.b166	90 02		bcc $b16a			bcc 	_SNLNoCarry
.b168	e6 17		inc $17				inc 	zCodePtr+1
.b16a					_SNLNoCarry:
.b16a	80 bd		bra $b129			bra 	RUN_NewLine 				; go do the new line code
.b16c					RUN_Execute:
.b16c	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b16e	b0 1c		bcs $b18c			bcs 	RUN_Extension
.b170	1b		inz				inz
.b171	0a		asl a				asl 	a 							; double the character read.
.b172	90 12		bcc $b186			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b174	aa		tax				tax 								; ready to look up.
.b175	bd 43 ae	lda $ae43,x			lda 	VectorTable,x 				; copy address into LocalVector
.b178	8d 11 03	sta $0311			sta 	LocalVector+1
.b17b	bd 44 ae	lda $ae44,x			lda 	VectorTable+1,x
.b17e	8d 12 03	sta $0312			sta 	LocalVector+2
.b181	20 7b b4	jsr $b47b			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b184	80 c7		bra $b14d			bra 	RUN_NextCommand 			; do the next command.
.b186					RUN_Default:
.b186	3b		dez				dez
.b187	20 94 b1	jsr $b194			jsr 	Command_LET 				; and try LET.
.b18a	80 c1		bra $b14d			bra 	RUN_NextCommand
.b18c					RUN_Extension:
.b18c	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b18e	f0 a8		beq $b138			beq 	RUN_Skip 					; skip over it.
.b190	4c b5 ad	jmp $adb5			jmp 	SyntaxError
.b193					Command_COLON:
.b193	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b194					Command_LET:
.b194	20 ce bb	jsr $bbce			jsr 	VariableFind 				; get reference to one variable.
.b197	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b199	20 10 bb	jsr $bb10			jsr 	CheckNextToken
.b19c	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b19e	48		pha				pha
.b19f	a5 23		lda $23				lda 	zVarDataPtr+1
.b1a1	48		pha				pha
.b1a2	a5 24		lda $24				lda 	zVarType
.b1a4	48		pha				pha
.b1a5	20 74 b3	jsr $b374			jsr 	EvaluateExpression 			; evaluate the RHS.
.b1a8	68		pla				pla 								; restore target variable information.
.b1a9	85 24		sta $24				sta 	zVarType
.b1ab	68		pla				pla
.b1ac	85 23		sta $23				sta 	zVarDataPtr+1
.b1ae	68		pla				pla
.b1af	85 22		sta $22				sta 	zVarDataPtr
.b1b1	20 69 bf	jsr $bf69			jsr 	VariableSet 				; set the value out.
.b1b4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b1b5					Command_END:
.b1b5	80 fe		bra $b1b5	_halt:	bra 		_halt
.b1b7	4c 84 b0	jmp $b084			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b1ba					Command_PRINT:
.b1ba	ea		nop				nop
.b1bb	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1bd	c9 00		cmp #$00			cmp 	#0 							; end
.b1bf	f0 66		beq $b227			beq 	_CPR_NewLine
.b1c1	c9 c0		cmp #$c0			cmp 	#token_Colon
.b1c3	f0 62		beq $b227			beq 	_CPR_NewLine
.b1c5	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b1c7	f0 50		beq $b219			beq 	_CPR_Skip
.b1c9	c9 bf		cmp #$bf			cmp 	#token_Comma
.b1cb	f0 49		beq $b216			beq 	_CPR_Tab
.b1cd	20 74 b3	jsr $b374			jsr 	EvaluateExpression 			; get expression.
.b1d0	a5 85		lda $85				lda 	XS_Type 					; get type.
.b1d2	29 02		and #$02			and 	#2
.b1d4	d0 24		bne $b1fa			bne 	_CPR_String 				; if type = 2 output as string.
.b1d6					_CPR_Number:
.b1d6	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b1d8	8d 14 03	sta $0314			sta 	NumBufX
.b1db	a5 85		lda $85				lda 	XS_Type 					; get type
.b1dd	4a		lsr a				lsr 	a
.b1de	b0 05		bcs $b1e5			bcs 	_CPRInt 					; if msb set do as integer
.b1e0	20 e9 c5	jsr $c5e9			jsr 	FPToString 					; call fp to str otherwise
.b1e3	80 03		bra $b1e8			bra 	_CPRNPrint
.b1e5	20 b2 c0	jsr $c0b2	_CPRInt:jsr 	IntToString
.b1e8					_CPRNPrint:
.b1e8	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b1eb	c9 2d		cmp #$2d			cmp 	#"-"
.b1ed	f0 05		beq $b1f4			beq 	_CPRNoSpace
.b1ef	a9 20		lda #$20			lda 	#" "						; print the leading space
.b1f1	20 af ad	jsr $adaf			jsr 	CharPrint 					; so beloved of MS Basics.
.b1f4					_CPRNoSpace:
.b1f4	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b1f6	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b1f8	80 04		bra $b1fe			bra 	_CPRPrint
.b1fa					_CPR_String:
.b1fa	a6 80		ldx $80				ldx 	XS_Mantissa
.b1fc	a5 81		lda $81				lda 	XS_Mantissa+1
.b1fe					_CPRPrint:
.b1fe	86 1e		stx $1e				stx 	zGenPtr
.b200	85 1f		sta $1f				sta 	zGenPtr+1
.b202	5a		phy				phy
.b203	a0 00		ldy #$00			ldy 	#0							; get length into X
.b205	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b207	aa		tax				tax
.b208	f0 09		beq $b213			beq 	_CPREndPrint 				; nothing to print
.b20a					_CPRLoop:
.b20a	c8		iny				iny
.b20b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b20d	20 af ad	jsr $adaf			jsr 	CharPrint
.b210	ca		dex				dex
.b211	d0 f7		bne $b20a			bne 	_CPRLoop
.b213					_CPREndPrint:
.b213	7a		ply				ply
.b214	80 a4		bra $b1ba			bra 	Command_Print
.b216					_CPR_Tab:
.b216	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b219					_CPR_Skip:
.b219	1b		inz				inz
.b21a	ea		nop				nop
.b21b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b21d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b21f	f0 09		beq $b22a			beq 	_CPR_Exit
.b221	c9 00		cmp #$00			cmp 	#0
.b223	d0 95		bne $b1ba			bne 	Command_PRINT 				; if not go round again.
.b225	80 03		bra $b22a			bra 	_CPR_Exit
.b227					_CPR_NewLine:
.b227	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b22a					_CPR_Exit:
.b22a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b22b					Command_ASSERT:
.b22b	20 0a b5	jsr $b50a			jsr 	EvaluateInteger 			; calculate thing being asserted
.b22e	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b230	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b232	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b234	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b236	f0 01		beq $b239			beq 	_ASFail
.b238	60		rts				rts
.b239					_ASFail:
.b239	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b23c	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.b243					Command_NEW:
.b243	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b245	85 16		sta $16				sta 	zCodePtr+0
.b247	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b249	85 17		sta $17				sta 	zCodePtr+1
.b24b	a9 02		lda #$02			lda 	#2
.b24d	85 18		sta $18				sta 	zCodePtr+2
.b24f	a9 00		lda #$00			lda 	#0
.b251	85 19		sta $19				sta 	zCodePtr+3
.b253	a3 03		ldz #$03			ldz 	#3
.b255	a3 00		ldz #$00			ldz 	#0
.b257	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.b259	ea		nop				nop
.b25a	92 16		sta ($16),z			sta 	(zCodePtr),z
.b25c	20 c7 ba	jsr $bac7			jsr 	UpdateProgramEnd 			; update program end.
.b25f	4c 84 b0	jmp $b084			jmp 	WarmStart
.b262					Command_OLD:
.b262	ea		nop				nop
.b263	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b265	85 16		sta $16				sta 	zCodePtr+0
.b267	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b269	85 17		sta $17				sta 	zCodePtr+1
.b26b	a9 02		lda #$02			lda 	#2
.b26d	85 18		sta $18				sta 	zCodePtr+2
.b26f	a9 00		lda #$00			lda 	#0
.b271	85 19		sta $19				sta 	zCodePtr+3
.b273	a3 03		ldz #$03			ldz 	#3
.b275					_COL_Find:
.b275	ea		nop				nop
.b276	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b278	1b		inz				inz
.b279	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.b27b	f0 18		beq $b295			beq 	_COL_Found
.b27d	6b		tza				tza
.b27e	c9 00		cmp #$00			cmp 	#0
.b280	d0 f3		bne $b275			bne 	_COL_Find 					; can't find old EOL, give up.
.b282	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b285	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>b28d	43 6f 72 72 75 70 74 00
.b295					_COL_Found:
.b295	6b		tza				tza
.b296	48		pha				pha
.b297	a3 00		ldz #$00			ldz 	#0
.b299	68		pla				pla
.b29a	ea		nop				nop
.b29b	92 16		sta ($16),z			sta 	(zCodePtr),z
.b29d	20 c7 ba	jsr $bac7			jsr 	UpdateProgramEnd 			; reset variable pointer
.b2a0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b2a1					Command_GOTO:
.b2a1	20 be b2	jsr $b2be			jsr 	GotoGetLineNumber
.b2a4	4c db b2	jmp $b2db			jmp 	GotoChangeToLineNumber
.b2a7					Command_GOSUB:
.b2a7	20 be b2	jsr $b2be			jsr 	GotoGetLineNumber
.b2aa	20 76 ad	jsr $ad76			jsr 	StackSavePosition
.b2ad	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.b2af	20 2f ad	jsr $ad2f			jsr 	StackPushFrame
.b2b2	4c db b2	jmp $b2db			jmp 	GotoChangeToLineNumber
.b2b5					Command_RETURN:
.b2b5	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.b2b7	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b2ba	20 93 ad	jsr $ad93			jsr 	StackRestorePosition
.b2bd	60		rts				rts
.b2be					GotoGetLineNumber:
.b2be	20 0a b5	jsr $b50a			jsr 	EvaluateInteger
.b2c1	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b2c3	05 83		ora $83				ora 	XS_Mantissa+3
.b2c5	d0 01		bne $b2c8			bne 	_GLINError
.b2c7	60		rts				rts
.b2c8					_GLINError:
.b2c8	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b2cb	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b2d3	20 4e 75 6d 62 65 72 00
.b2db					GotoChangeToLineNumber:
.b2db	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.b2dd	05 81		ora $81				ora 	XS_Mantissa+1
.b2df	f0 3d		beq $b31e			beq 	_GCTLFail
.b2e1	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b2e3	85 16		sta $16				sta 	zCodePtr+0
.b2e5	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b2e7	85 17		sta $17				sta 	zCodePtr+1
.b2e9	a9 02		lda #$02			lda 	#2
.b2eb	85 18		sta $18				sta 	zCodePtr+2
.b2ed	a9 00		lda #$00			lda 	#0
.b2ef	85 19		sta $19				sta 	zCodePtr+3
.b2f1	a3 03		ldz #$03			ldz 	#3
.b2f3					_GCTLLoop:
.b2f3	a3 00		ldz #$00			ldz 	#0
.b2f5	ea		nop				nop
.b2f6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2f8	c9 00		cmp #$00			cmp 	#0
.b2fa	f0 22		beq $b31e			beq 	_GCTLFail
.b2fc	1b		inz				inz
.b2fd	ea		nop				nop
.b2fe	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b300	c5 80		cmp $80				cmp 	XS_Mantissa+0
.b302	d0 08		bne $b30c			bne 	_GCTLNext
.b304	1b		inz				inz
.b305	ea		nop				nop
.b306	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b308	c5 81		cmp $81				cmp 	XS_Mantissa+1
.b30a	f0 10		beq $b31c			beq 	_GCTLExit
.b30c					_GCTLNext:
.b30c	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b30e	ea		nop				nop
.b30f	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b311	18		clc				clc
.b312	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b314	85 16		sta $16				sta 	zCodePtr
.b316	90 02		bcc $b31a			bcc 	_SNLNoCarry
.b318	e6 17		inc $17				inc 	zCodePtr+1
.b31a					_SNLNoCarry:
.b31a	80 d7		bra $b2f3			bra 	_GCTLLoop 					; try next line.
.b31c					_GCTLExit:
.b31c	1b		inz				inz
.b31d	60		rts				rts
.b31e					_GCTLFail:
.b31e	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b321	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b329	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b331					Command_CLR:
.b331					ResetRunStatus:
.b331	20 0a bc	jsr $bc0a			jsr 	VariableClear
.b334	20 1d ad	jsr $ad1d			jsr 	StackReset
.b337	a9 00		lda #$00			lda 	#HighMemory & $FF
.b339	8d 00 03	sta $0300			sta 	StringPtr
.b33c	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.b33e	8d 01 03	sta $0301			sta 	StringPtr+1
.b341	20 d6 bd	jsr $bdd6			jsr 	ArrayResetDefault
.b344	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b345					Command_STOP:
.b345	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b348	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.b34d					Command_REPEAT:
.b34d	20 76 ad	jsr $ad76			jsr 	StackSavePosition			; save position into stack
.b350	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b352	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; push on stack
.b355	60		rts				rts
.b356					Command_UNTIL:
.b356	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.b358	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b35b	20 0a b5	jsr $b50a			jsr 	EvaluateInteger				; work out UNTIL
.b35e	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.b360	05 81		ora $81				ora 	XS_Mantissa+1
.b362	05 82		ora $82				ora 	XS_Mantissa+2
.b364	05 83		ora $83				ora 	XS_Mantissa+3
.b366	d0 08		bne $b370			bne 	_CUTExit 					; if not, just exit
.b368	20 93 ad	jsr $ad93			jsr 	StackRestorePosition 		; otherwise loop round again.
.b36b	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b36d	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; fix the stack back.
.b370					_CUTExit:
.b370	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b371					EVESyntax:
.b371	4c b5 ad	jmp $adb5			jmp 	SyntaxError
.b374					EvaluateExpression:
.b374	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b376					EvaluateExpressionX:
.b376	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b378					EvaluateExpressionXA:
.b378	48		pha				pha 								; save precedence on stack.
.b379	ea		nop				nop
.b37a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b37c	f0 f3		beq $b371			beq 	EVESyntax 					; end of line, syntax error.
.b37e	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b380	b0 03		bcs $b385			bcs 	_EVNotVariable
.b382	4c 72 b4	jmp $b472			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b385					_EVNotVariable:
.b385	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b387	90 e8		bcc $b371			bcc 	EVESyntax
.b389	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b38b	b0 7a		bcs $b407			bcs 	_EVNotInteger
.b38d	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b38f	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b391	a9 00		lda #$00			lda 	#0
.b393	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b395	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b397	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b399	1a		inc a				inc 	a 							; set to type 1 (integer)
.b39a	95 85		sta $85,x			sta 	XS_Type,x
.b39c					_EVCheckNextInteger:
.b39c	1b		inz				inz
.b39d	ea		nop				nop
.b39e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3a0	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b3a2	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b3a4	b0 0b		bcs $b3b1			bcs 	_EVCheckDecimal
.b3a6	48		pha				pha 								; save it.
.b3a7	20 7e b4	jsr $b47e			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b3aa	68		pla				pla
.b3ab	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b3ad	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b3af	80 eb		bra $b39c			bra 	_EVCheckNextInteger
.b3b1					_EVCheckDecimal:
.b3b1	ea		nop				nop
.b3b2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3b4	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b3b6	d0 05		bne $b3bd			bne 	_EVGotAtom 					; no, get atom.
.b3b8					_EVIsDecimal:
.b3b8	20 a0 b4	jsr $b4a0			jsr 	EVGetDecimal 				; extend to the decimal part.
.b3bb	80 00		bra $b3bd			bra 	_EVGotAtom 					; and continue to got atom.
.b3bd					_EVGotAtom:
.b3bd	ea		nop				nop
.b3be	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3c0	10 43		bpl $b405			bpl 	_EVExitDrop 				; must be a token.
.b3c2	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b3c4	b0 3f		bcs $b405			bcs 	_EVExitDrop
.b3c6	68		pla				pla 								; get current precedence
.b3c7	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b3c9	da		phx				phx 								; save X
.b3ca	ea		nop				nop
.b3cb	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3cd	aa		tax				tax 								; put in X
.b3ce	bd 92 ae	lda $ae92,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b3d1	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b3d3	fa		plx				plx 								; restore X
.b3d4	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b3d6	90 2e		bcc $b406			bcc 	_EVExit 					; exit if too low.
.b3d8	f0 2c		beq $b406			beq 	_EVExit 					; exit if equals
.b3da	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b3dc	48		pha				pha
.b3dd	ea		nop				nop
.b3de	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3e0	48		pha				pha
.b3e1	1b		inz				inz
.b3e2	da		phx				phx 								; save current position
.b3e3	e8		inx				inx
.b3e4	e8		inx				inx
.b3e5	e8		inx				inx
.b3e6	e8		inx				inx
.b3e7	e8		inx				inx
.b3e8	e8		inx				inx
.b3e9	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b3eb	20 78 b3	jsr $b378			jsr 	EvaluateExpressionXA 		; do the RHS.
.b3ee	fa		plx				plx 								; restore X
.b3ef	68		pla				pla 								; get the binary operator in A.
.b3f0					_EVCallA:
.b3f0	da		phx				phx 								; save X again
.b3f1	0a		asl a				asl 	a 							; double, lose the MSB.
.b3f2	aa		tax				tax									; put in X
.b3f3	bd 43 ae	lda $ae43,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b3f6	8d 11 03	sta $0311			sta 	LocalVector+1
.b3f9	bd 44 ae	lda $ae44,x			lda 	VectorTable+1,x
.b3fc	8d 12 03	sta $0312			sta 	LocalVector+2
.b3ff	fa		plx				plx 								; restore X
.b400	20 7b b4	jsr $b47b			jsr 	EVCallLocalVector
.b403	80 b8		bra $b3bd			bra 	_EVGotAtom 					; and loop back.
.b405					_EVExitDrop:
.b405	68		pla				pla
.b406					_EVExit:
.b406	60		rts				rts
.b407					_EVNotInteger:
.b407	1b		inz				inz
.b408	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b40a	d0 16		bne $b422			bne 	_EVNotMinus
.b40c	20 eb b4	jsr $b4eb			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b40f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b411	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b413	f0 05		beq $b41a			beq 	_EVMinusFloat
.b415	20 95 c0	jsr $c095			jsr 	IntegerNegateAlways 		; negation
.b418	80 a3		bra $b3bd			bra 	_EVGotAtom 					; and go back.
.b41a					_EVMinusFloat:
.b41a	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.b41c	49 80		eor #$80			eor 	#$80
.b41e	95 85		sta $85,x			sta 	XS_Type,x
.b420	80 9b		bra $b3bd			bra 	_EVGotAtom
.b422					_EVNotMinus:
.b422	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b424	d0 18		bne $b43e			bne 	_EVNotParenthesis
.b426	20 76 b3	jsr $b376			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b429	ea		nop				nop
.b42a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b42c	1b		inz				inz
.b42d	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b42f	f0 8c		beq $b3bd			beq 	_EVGotAtom
.b431	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b434	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b43c	29 00
.b43e					_EVNotParenthesis:
.b43e	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b440	d0 0c		bne $b44e			bne 	_EVNotNot
.b442	20 eb b4	jsr $b4eb			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b445	20 ea c4	jsr $c4ea			jsr 	FPUToInteger 				; make it an integer - if possible.
.b448	20 d0 b4	jsr $b4d0			jsr 	NotInteger 					; do the not calculation
.b44b	4c bd b3	jmp $b3bd			jmp 	_EVGotAtom
.b44e					_EVNotNot:
.b44e	c9 fe		cmp #$fe			cmp 	#$FE
.b450	d0 12		bne $b464			bne 	_EVNotString
.b452	20 a5 bb	jsr $bba5			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b455	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b457	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b459	a5 21		lda $21				lda 	zTempStr+1
.b45b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b45d	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b45f	95 85		sta $85,x			sta 	XS_Type,x
.b461	4c bd b3	jmp $b3bd			jmp 	_EVGotAtom
.b464					_EVNotString:
.b464	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b466	90 04		bcc $b46c			bcc 	_EVBadElement
.b468	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b46a	90 03		bcc $b46f			bcc 	_EVUnaryFunction
.b46c					_EVBadElement:
.b46c	4c b5 ad	jmp $adb5			jmp 	SyntaxError
.b46f					_EVUnaryFunction:
.b46f	4c f0 b3	jmp $b3f0			jmp 	_EVCallA
.b472					_EVVariableHandler:
.b472	20 ce bb	jsr $bbce			jsr 	VariableFind 				; locate a variable
.b475	20 18 bf	jsr $bf18			jsr 	VariableGet 				; copy into memory.
.b478	4c bd b3	jmp $b3bd			jmp 	_EVGotAtom 					; and go round.
.b47b					EVCallLocalVector:
.b47b	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.b47e					EVShiftMantissaLeft6:
.b47e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b480	95 84		sta $84,x			sta 	XS_Exponent,x
.b482	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b484	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b486	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b488	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b48a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b48c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b48e	a9 00		lda #$00			lda 	#0
.b490	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b492	20 95 b4	jsr $b495			jsr 	_EVSMLShift 					; call it here to do it twice
.b495					_EVSMLShift:
.b495	56 84		lsr $84,x			lsr 	XS_Exponent,x
.b497	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.b499	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.b49b	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.b49d	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.b49f	60		rts				rts
.b4a0					EVGetDecimal:
.b4a0	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b4a2	8d 15 03	sta $0315			sta 	Num_Buffer
.b4a5	da		phx				phx
.b4a6	1b		inz				inz
.b4a7	ea		nop				nop
.b4a8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4aa	1b		inz				inz
.b4ab	3a		dec a				dec 	a								; convert to a string length.
.b4ac	3a		dec a				dec 	a
.b4ad	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b4af					_EVGDCopy:
.b4af	48		pha				pha 									; save count
.b4b0	ea		nop				nop
.b4b1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4b3	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.b4b6	e8		inx				inx 									; forward ....
.b4b7	1b		inz				inz
.b4b8	68		pla				pla 									; get count
.b4b9	3a		dec a				dec 	a 								; until zero
.b4ba	d0 f3		bne $b4af			bne 	_EVGDCopy
.b4bc	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b4bf	fa		plx				plx 									; restore X
.b4c0	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b4c2	85 1e		sta $1e				sta 	zGenPtr
.b4c4	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.b4c6	85 1f		sta $1f				sta 	zGenPtr+1
.b4c8	5a		phy				phy 									; save Y
.b4c9	a0 00		ldy #$00			ldy 	#0 								; start position
.b4cb	20 a4 c6	jsr $c6a4			jsr 	FPFromString 					; convert current
.b4ce	7a		ply				ply 									; restore Y
.b4cf	60		rts				rts
.b4d0					NotInteger:
.b4d0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b4d2	49 ff		eor #$ff			eor 	#$FF
.b4d4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b4d6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b4d8	49 ff		eor #$ff			eor 	#$FF
.b4da	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b4dc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b4de	49 ff		eor #$ff			eor 	#$FF
.b4e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b4e2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b4e4	49 ff		eor #$ff			eor 	#$FF
.b4e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b4e8	60		rts				rts
.b4e9					EvaluateGetAtom:
.b4e9	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b4eb					EvaluateGetAtomX:
.b4eb	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b4ed	20 78 b3	jsr $b378			jsr 	EvaluateExpressionXA
.b4f0	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b4f2	29 0f		and #$0f			and 	#15
.b4f4	c9 02		cmp #$02			cmp 	#2
.b4f6	b0 01		bcs $b4f9			bcs 	EvaluateType
.b4f8	60		rts				rts
.b4f9					EvaluateType:
.b4f9	4c c5 ad	jmp $adc5			jmp 	TypeError
.b4fc					EvaluateNumber:
.b4fc	a2 00		ldx #$00			ldx 	#0
.b4fe					EvaluateNumberX:
.b4fe	20 76 b3	jsr $b376			jsr 	EvaluateExpressionX
.b501	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.b503	29 0f		and #$0f			and 	#15
.b505	c9 02		cmp #$02			cmp 	#2
.b507	b0 f0		bcs $b4f9			bcs 	EvaluateType
.b509	60		rts				rts
.b50a					EvaluateInteger:
.b50a	a2 00		ldx #$00			ldx 	#0
.b50c					EvaluateIntegerX:
.b50c	20 fe b4	jsr $b4fe			jsr 	EvaluateNumberX
.b50f	20 ea c4	jsr $c4ea			jsr 	FPUToInteger
.b512	60		rts				rts
.b513					EvaluateString:
.b513	a2 00		ldx #$00			ldx 	#0
.b515					EvaluateStringX:
.b515	20 76 b3	jsr $b376			jsr 	EvaluateExpressionX
.b518	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.b51a	29 0f		and #$0f			and 	#15
.b51c	c9 02		cmp #$02			cmp 	#2
.b51e	d0 d9		bne $b4f9			bne 	EvaluateType
.b520	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b522	85 1e		sta $1e				sta 	zGenPtr
.b524	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b526	85 1f		sta $1f				sta 	zGenPtr+1
.b528	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b529					BinaryOp_And:
.b529	20 7d b5	jsr $b57d			jsr 	BinaryMakeBothInteger
.b52c	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b52e	35 86		and $86,x			and 	XS2_Mantissa+0,x
.b530	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b532	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b534	35 87		and $87,x			and 	XS2_Mantissa+1,x
.b536	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b538	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b53a	35 88		and $88,x			and 	XS2_Mantissa+2,x
.b53c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b53e	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b540	35 89		and $89,x			and 	XS2_Mantissa+3,x
.b542	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b544	60		rts				rts
.b545					BinaryOp_Or:
.b545	20 7d b5	jsr $b57d			jsr 	BinaryMakeBothInteger
.b548	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b54a	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.b54c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b54e	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b550	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.b552	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b554	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b556	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.b558	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b55a	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b55c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.b55e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b560	60		rts				rts
.b561					BinaryOp_Eor:
.b561					BinaryOp_Xor:
.b561	20 7d b5	jsr $b57d			jsr 	BinaryMakeBothInteger
.b564	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b566	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.b568	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b56a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b56c	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.b56e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b570	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b572	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.b574	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b576	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b578	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.b57a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b57c	60		rts				rts
.b57d					BinaryMakeBothInteger:
.b57d	da		phx				phx 								; save X
.b57e	e8		inx				inx
.b57f	e8		inx				inx
.b580	e8		inx				inx
.b581	e8		inx				inx
.b582	e8		inx				inx
.b583	e8		inx				inx
.b584	20 88 b5	jsr $b588			jsr 	BinaryMakeInteger 			; convert to integer.
.b587	fa		plx				plx 								; restore X and fall through.
.b588					BinaryMakeInteger:
.b588	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b58a	29 0f		and #$0f			and 	#15 						; check type zero
.b58c	f0 04		beq $b592			beq 	_BMIConvert 				; if float convert to integer.
.b58e	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b58f	90 04		bcc $b595			bcc 	_BMIError
.b591	60		rts				rts
.b592					_BMIConvert:
.b592	4c ea c4	jmp $c4ea			jmp 	FPUToInteger 				; convert to integer
.b595					_BMIError:
.b595	4c c5 ad	jmp $adc5			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b598					Binary_Equal:
.b598	20 df b5	jsr $b5df			jsr 	CompareValues
.b59b	09 00		ora #$00			ora 	#0
.b59d	f0 04		beq $b5a3			beq 	CCTrue
.b59f	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b5a1	80 02		bra $b5a5			bra 	CCWrite
.b5a3	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b5a5	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b5a7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b5a9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b5ab	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b5ad	a9 01		lda #$01			lda 	#1
.b5af	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.b5b1	60		rts				rts
.b5b2					Binary_NotEqual:
.b5b2	20 df b5	jsr $b5df			jsr 	CompareValues
.b5b5	09 00		ora #$00			ora 	#0
.b5b7	f0 e6		beq $b59f			beq 	CCFalse
.b5b9	80 e8		bra $b5a3			bra 	CCTrue
.b5bb					Binary_Less:
.b5bb	20 df b5	jsr $b5df			jsr 	CompareValues
.b5be	09 00		ora #$00			ora 	#0
.b5c0	30 e1		bmi $b5a3			bmi 	CCTrue
.b5c2	80 db		bra $b59f			bra 	CCFalse
.b5c4					Binary_LessEqual:
.b5c4	20 df b5	jsr $b5df			jsr 	CompareValues
.b5c7	c9 01		cmp #$01			cmp 	#1
.b5c9	d0 d8		bne $b5a3			bne 	CCTrue
.b5cb	80 d2		bra $b59f			bra 	CCFalse
.b5cd					Binary_GreaterEqual:
.b5cd	20 df b5	jsr $b5df			jsr 	CompareValues
.b5d0	09 00		ora #$00			ora 	#0
.b5d2	10 cf		bpl $b5a3			bpl 	CCTrue
.b5d4	80 c9		bra $b59f			bra 	CCFalse
.b5d6					Binary_Greater:
.b5d6	20 df b5	jsr $b5df			jsr 	CompareValues
.b5d9	c9 01		cmp #$01			cmp 	#1
.b5db	f0 c6		beq $b5a3			beq 	CCTrue
.b5dd	80 c0		bra $b59f			bra 	CCFalse
.b5df					CompareValues:
.b5df	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.b5e1	35 8b		and $8b,x			and 	XS2_Type,x
.b5e3	c9 02		cmp #$02			cmp 	#2
.b5e5	f0 11		beq $b5f8			beq 	_CVString
.b5e7	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b5e9	35 8b		and $8b,x			and 	XS2_Type,x
.b5eb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b5ec	90 03		bcc $b5f1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b5ee	4c 3a b6	jmp $b63a			jmp 	CompareInteger32 							; so execute code at \1
.b5f1					_BCFloat:
.b5f1	20 de b6	jsr $b6de			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b5f4	4c 20 c4	jmp $c420			jmp 	FPCompare 							; and execute code at \2
.b5f7	60		rts				rts
.b5f8					_CVString:
.b5f8	da		phx				phx 								; save XY
.b5f9	5a		phy				phy
.b5fa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b5fc	85 1a		sta $1a				sta		zLTemp1+0
.b5fe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b600	85 1b		sta $1b				sta 	zLTemp1+1
.b602	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b604	85 1c		sta $1c				sta 	zLTemp1+2
.b606	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b608	85 1d		sta $1d				sta 	zLTemp1+3
.b60a	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b60c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b60e	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b610	90 02		bcc $b614			bcc 	_CVCommon
.b612	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b614					_CVCommon:
.b614	aa		tax				tax 								; put shorter string length in zero.
.b615	f0 0c		beq $b623			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b617					_CVCompare:
.b617	c8		iny				iny 								; next character
.b618	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b61a	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b61c	90 13		bcc $b631			bcc 	_CVReturnLess 				; <
.b61e	d0 15		bne $b635			bne 	_CVReturnGreater 			; >
.b620	ca		dex				dex 								; until common length matched.
.b621	d0 f4		bne $b617			bne 	_CVCompare
.b623					_CVMatch:
.b623	a0 00		ldy #$00			ldy 	#0
.b625	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b627	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b629	90 06		bcc $b631			bcc 	_CVReturnLess 				; <
.b62b	d0 08		bne $b635			bne 	_CVReturnGreater 			; >
.b62d	a9 00		lda #$00			lda 	#0
.b62f	80 06		bra $b637			bra 	_CVExit 					; same common, same length, same string
.b631					_CVReturnLess:
.b631	a9 ff		lda #$ff			lda 	#$FF
.b633	80 02		bra $b637			bra 	_CVExit
.b635					_CVReturnGreater:
.b635	a9 01		lda #$01			lda 	#$01
.b637					_CVExit:
.b637	7a		ply				ply
.b638	fa		plx				plx
.b639	60		rts				rts
.b63a					CompareInteger32:
.b63a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b63c	49 80		eor #$80			eor 	#$80
.b63e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b640	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.b642	49 80		eor #$80			eor 	#$80
.b644	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.b646	20 c4 b6	jsr $b6c4			jsr 	SubInteger32 				; subtraction
.b649	90 0d		bcc $b658			bcc 	_CI32Less 					; cc return -1
.b64b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.b64d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b64f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b651	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b653	f0 02		beq $b657			beq 	_CI32Exit
.b655	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b657					_CI32Exit:
.b657	60		rts				rts
.b658					_CI32Less:
.b658	a9 ff		lda #$ff			lda 	#$FF
.b65a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b65b					BinaryOp_Add:
.b65b	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.b65d	35 8b		and $8b,x			and 	XS2_Type,x
.b65f	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b661	d0 11		bne $b674			bne 	_BOAString
.b663	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b665	35 8b		and $8b,x			and 	XS2_Type,x
.b667	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b668	90 03		bcc $b66d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b66a	4c aa b6	jmp $b6aa			jmp 	AddInteger32 							; so execute code at \1
.b66d					_BCFloat:
.b66d	20 de b6	jsr $b6de			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b670	4c fb c1	jmp $c1fb			jmp 	FPAdd 							; and execute code at \2
.b673	60		rts				rts
.b674					_BOAString:
.b674	4c f8 b6	jmp $b6f8			jmp 	ConcatenateString 			; concatenate two strings.
.b677					BinaryOp_Subtract:
.b677	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b679	35 8b		and $8b,x			and 	XS2_Type,x
.b67b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b67c	90 03		bcc $b681			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b67e	4c c4 b6	jmp $b6c4			jmp 	SubInteger32 							; so execute code at \1
.b681					_BCFloat:
.b681	20 de b6	jsr $b6de			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b684	4c f3 c1	jmp $c1f3			jmp 	FPSubtract 							; and execute code at \2
.b687	60		rts				rts
.b688					BinaryOp_Multiply:
.b688	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b68a	35 8b		and $8b,x			and 	XS2_Type,x
.b68c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b68d	90 03		bcc $b692			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b68f	4c d0 bf	jmp $bfd0			jmp 	MulInteger32 							; so execute code at \1
.b692					_BCFloat:
.b692	20 de b6	jsr $b6de			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b695	4c 22 c3	jmp $c322			jmp 	FPMultiply 							; and execute code at \2
.b698	60		rts				rts
.b699					BinaryOp_Divide:
.b699	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b69b	35 8b		and $8b,x			and 	XS2_Type,x
.b69d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b69e	90 03		bcc $b6a3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b6a0	4c 0e c0	jmp $c00e			jmp 	DivInteger32 							; so execute code at \1
.b6a3					_BCFloat:
.b6a3	20 de b6	jsr $b6de			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b6a6	4c af c2	jmp $c2af			jmp 	FPDivide 							; and execute code at \2
.b6a9	60		rts				rts
.b6aa					AddInteger32:
.b6aa	18		clc				clc
.b6ab	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b6ad	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.b6af	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b6b1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b6b3	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.b6b5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6b7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b6b9	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.b6bb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b6bd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b6bf	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.b6c1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b6c3	60		rts				rts
.b6c4					SubInteger32:
.b6c4	38		sec				sec
.b6c5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b6c7	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.b6c9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b6cb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b6cd	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.b6cf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6d1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b6d3	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.b6d5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b6d7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b6d9	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.b6db	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b6dd	60		rts				rts
.b6de					BinaryMakeBothFloat:
.b6de	da		phx				phx 								; save X
.b6df	e8		inx				inx
.b6e0	e8		inx				inx
.b6e1	e8		inx				inx
.b6e2	e8		inx				inx
.b6e3	e8		inx				inx
.b6e4	e8		inx				inx
.b6e5	20 e9 b6	jsr $b6e9			jsr 	BinaryMakeFloat 			; convert to float.
.b6e8	fa		plx				plx 								; restore X and fall through.
.b6e9					BinaryMakeFloat:
.b6e9	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b6eb	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b6ec	b0 04		bcs $b6f2			bcs 	_BMFConvert
.b6ee	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b6ef	b0 04		bcs $b6f5			bcs 	_BMFError
.b6f1	60		rts				rts
.b6f2					_BMFConvert:
.b6f2	4c 9e c4	jmp $c49e			jmp 	FPUToFloat 					; convert to float
.b6f5					_BMFError:
.b6f5	4c c5 ad	jmp $adc5			jmp 	TypeError
.b6f8					ConcatenateString:
.b6f8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b6fa	85 1a		sta $1a				sta		zLTemp1+0
.b6fc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b6fe	85 1b		sta $1b				sta 	zLTemp1+1
.b700	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b702	85 1c		sta $1c				sta 	zLTemp1+2
.b704	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b706	85 1d		sta $1d				sta 	zLTemp1+3
.b708	5a		phy				phy
.b709	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b70b	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b70d	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b70f	7a		ply				ply
.b710	b0 33		bcs $b745			bcs 	_CSError					; check in range.
.b712	c9 fe		cmp #$fe			cmp 	#maxString+1
.b714	b0 2f		bcs $b745			bcs 	_CSError
.b716	20 6a bb	jsr $bb6a			jsr 	AllocateTempString 			; store the result
.b719	20 30 b7	jsr $b730			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b71c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b71e	85 1a		sta $1a				sta 	zLTemp1
.b720	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b722	85 1b		sta $1b				sta 	zLTemp1+1
.b724	20 30 b7	jsr $b730			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b727	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b729	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b72b	a5 21		lda $21				lda 	zTempStr+1
.b72d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b72f	60		rts				rts
.b730					_CSCopyString:
.b730	da		phx				phx
.b731	5a		phy				phy
.b732	a0 00		ldy #$00			ldy 	#0 							; get length
.b734	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b736	f0 0a		beq $b742			beq 	_CSCSExit 					; if zero, exit
.b738	aa		tax				tax 								; put in X
.b739					_CSCSLoop:
.b739	c8		iny				iny 								; get next char
.b73a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b73c	20 95 bb	jsr $bb95			jsr		WriteTempString 			; copy out
.b73f	ca		dex				dex 								; do whole string
.b740	d0 f7		bne $b739			bne 	_CSCSLoop
.b742					_CSCSExit:
.b742	7a		ply				ply
.b743	fa		plx				plx
.b744	60		rts				rts
.b745					_CSError:
.b745	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b748	53 74 72 69 6e 67 20 74			.text "String too long",0
>b750	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b758					Unary_Sgn:
.b758	20 fe b4	jsr $b4fe			jsr 	EvaluateNumberX 			; get value
.b75b	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; check right bracket.
.b75e	20 7c b7	jsr $b77c			jsr 	GetSignCurrent 				; get sign.
.b761	09 00		ora #$00			ora 	#0
.b763	10 08		bpl $b76d			bpl		UnarySetAInteger			; if 0,1 return that.
.b765	80 00		bra $b767			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b767					UnarySetAMinus1:
.b767	a9 ff		lda #$ff			lda 	#$FF
.b769	95 80		sta $80,x			sta 	XS_Mantissa,x
.b76b	80 04		bra $b771			bra 	UnarySetAFill
.b76d					UnarySetAInteger:
.b76d	95 80		sta $80,x			sta 	XS_Mantissa,x
.b76f	a9 00		lda #$00			lda 	#0
.b771					UnarySetAFill:
.b771	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b773	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b775	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b777	a9 01		lda #$01			lda 	#1
.b779	95 85		sta $85,x			sta 	XS_Type,x
.b77b	60		rts				rts
.b77c					GetSignCurrent:
.b77c	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.b77e	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b77f	90 15		bcc $b796			bcc 	_GSCFloat
.b781	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b783	30 0e		bmi $b793			bmi 	_GSCMinus1
.b785	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.b787	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b789	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b78b	d0 03		bne $b790			bne 	_GSCPlus1
.b78d					_GSCZero:
.b78d	a9 00		lda #$00			lda 	#0
.b78f	60		rts				rts
.b790					_GSCPlus1:
.b790	a9 01		lda #$01			lda 	#$01
.b792	60		rts				rts
.b793					_GSCMinus1:
.b793	a9 ff		lda #$ff			lda 	#$FF
.b795	60		rts				rts
.b796					_GSCFloat:
.b796	34 85		bit $85,x			bit 	XS_Type,x
.b798	70 f3		bvs $b78d			bvs 	_GSCZero
.b79a	30 f7		bmi $b793			bmi 	_GSCMinus1
.b79c	80 f2		bra $b790			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b79e					Unary_Abs:
.b79e	20 fe b4	jsr $b4fe			jsr 	EvaluateNumberX 			; get value
.b7a1	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; check right bracket.
.b7a4	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b7a6	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b7a8	f0 07		beq $b7b1			beq 	_UAMinusFloat
.b7aa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.b7ac	10 09		bpl $b7b7			bpl 	_UAExit
.b7ae	4c 95 c0	jmp $c095			jmp 	IntegerNegateAlways 		; negation
.b7b1					_UAMinusFloat:
.b7b1	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.b7b3	29 7f		and #$7f			and		#$7F
.b7b5	95 85		sta $85,x			sta 	XS_Type,x
.b7b7					_UAExit:
.b7b7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b7b8					Unary_Peek:
.b7b8	a9 01		lda #$01			lda 	#1
.b7ba	80 06		bra $b7c2			bra 	UPMain
.b7bc					Unary_Deek:
.b7bc	a9 02		lda #$02			lda 	#2
.b7be	80 02		bra $b7c2			bra 	UPMain
.b7c0					Unary_Leek:
.b7c0	a9 04		lda #$04			lda 	#4
.b7c2					UPMain:
.b7c2	48		pha				pha 								; set bytes to copy.
.b7c3	20 0c b5	jsr $b50c			jsr 	EvaluateIntegerX 			; numeric parameter
.b7c6	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.b7c9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b7cb	85 1a		sta $1a				sta 	zLTemp1
.b7cd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7cf	85 1b		sta $1b				sta 	zLTemp1+1
.b7d1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b7d3	85 1c		sta $1c				sta 	zLTemp1+2
.b7d5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b7d7	85 1d		sta $1d				sta 	zLTemp1+3
.b7d9	a9 00		lda #$00			lda 	#0 							; clear target area
.b7db	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7dd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7df	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7e1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7e3	68		pla				pla 								; restore bytes to copy
.b7e4	da		phx				phx 								; save XY
.b7e5	5a		phy				phy
.b7e6	20 b3 ba	jsr $bab3			jsr 	MemRead 					; read the bytes in
.b7e9	7a		ply				ply 								; restore and exit
.b7ea	fa		plx				plx
.b7eb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b7ec					Unary_Mod:
.b7ec	20 14 b8	jsr $b814			jsr 	_UMParameter 				; first parameter
.b7ef	20 31 bb	jsr $bb31			jsr 	CheckNextComma
.b7f2	da		phx				phx 								; second parameter
.b7f3	e8		inx				inx
.b7f4	e8		inx				inx
.b7f5	e8		inx				inx
.b7f6	e8		inx				inx
.b7f7	e8		inx				inx
.b7f8	e8		inx				inx
.b7f9	20 14 b8	jsr $b814			jsr 	_UMParameter
.b7fc	fa		plx				plx
.b7fd	20 28 bb	jsr $bb28			jsr 	CheckNextRParen
.b800	20 0e c0	jsr $c00e			jsr 	DivInteger32 				; divide
.b803	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b805	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b807	a5 1b		lda $1b				lda 	zLTemp1+1
.b809	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b80b	a5 1c		lda $1c				lda 	zLTemp1+2
.b80d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b80f	a5 1d		lda $1d				lda 	zLTemp1+3
.b811	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b813	60		rts				rts
.b814					_UMParameter:
.b814	20 0c b5	jsr $b50c			jsr 	EvaluateIntegerX 			; get value
.b817	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.b819	10 03		bpl $b81e			bpl 	_UMNotSigned
.b81b	20 95 c0	jsr $c095			jsr 	IntegerNegateAlways
.b81e					_UMNotSigned:
.b81e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b81f					Unary_Usr:
.b81f	20 fe b4	jsr $b4fe			jsr 	EvaluateNumberX 			; numeric parameter
.b822	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.b825	da		phx				phx 								; save XY
.b826	5a		phy				phy
.b827	ea		nop				nop
.b828	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.b82b	7a		ply				ply 								; and exit
.b82c	fa		plx				plx
.b82d	60		rts				rts
.b82e					USRDefault:
.b82e	20 e4 ad	jsr $ade4			jsr ERR_Handler
>b831	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b839	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b840					Unary_Val:
.b840	20 15 b5	jsr $b515			jsr 	EvaluateStringX 			; get string
.b843	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; check right bracket.
.b846	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b848	85 1e		sta $1e				sta 	zGenPtr
.b84a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b84c	85 1f		sta $1f				sta 	zGenPtr+1
.b84e	5a		phy				phy
.b84f	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b851	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b853	f0 54		beq $b8a9			beq 	_UVBadNumber
.b855	48		pha				pha 								; save length.
.b856	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b857	1a		inc a				inc 	a
.b858	20 6a bb	jsr $bb6a			jsr 	AllocateTempString
.b85b	c8		iny				iny 								; move to the next.
.b85c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b85e	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b860	8d a0 03	sta $03a0			sta 	ValSign
.b863	d0 04		bne $b869			bne 	_UVNotMinus
.b865	c8		iny				iny 								; skip over it.
.b866	68		pla				pla 								; decrement character count.
.b867	3a		dec a				dec 	a
.b868	48		pha				pha
.b869					_UVNotMinus:
.b869	68		pla				pla 								; this is the count.
.b86a	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b86b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b86d	c8		iny				iny
.b86e	20 95 bb	jsr $bb95			jsr 	WriteTempString
.b871	68		pla				pla
.b872	3a		dec a				dec 	a
.b873	d0 f5		bne $b86a			bne 	_UVCopy
.b875	20 95 bb	jsr $bb95			jsr 	WriteTempString 			; make it ASCIIZ
.b878	18		clc				clc
.b879	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b87b	69 01		adc #$01			adc 	#1
.b87d	85 1e		sta $1e				sta 	zGenPtr
.b87f	a5 21		lda $21				lda 	zTempStr+1
.b881	69 00		adc #$00			adc 	#0
.b883	85 1f		sta $1f				sta 	zGenPtr+1
.b885	18		clc				clc
.b886	20 63 c1	jsr $c163			jsr 	IntFromString 				; first bit.
.b889	b0 1e		bcs $b8a9			bcs 	_UVBadNumber
.b88b	20 a4 c6	jsr $c6a4			jsr 	FPFromString				; try for a float part.
.b88e	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.b891	d0 10		bne $b8a3			bne 	_UVNotNegative
.b893	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.b895	4a		lsr a				lsr 	a
.b896	b0 08		bcs $b8a0			bcs 	_UVInteger
.b898	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.b89a	09 80		ora #$80			ora 	#$80
.b89c	95 85		sta $85,x			sta 	XS_Type,x
.b89e	80 03		bra $b8a3			bra 	_UVNotNegative
.b8a0					_UVInteger:
.b8a0	20 95 c0	jsr $c095			jsr 	IntegerNegateAlways 		; sign it.
.b8a3					_UVNotNegative:
.b8a3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b8a5	d0 02		bne $b8a9			bne 	_UVBadNumber
.b8a7	7a		ply				ply
.b8a8	60		rts				rts
.b8a9					_UVBadNumber:
.b8a9	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b8ac					Unary_Str:
.b8ac	20 fe b4	jsr $b4fe			jsr 	EvaluateNumberX 			; numeric parameter
.b8af	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.b8b2	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b8b4	8d 14 03	sta $0314			sta 	NumBufX
.b8b7	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b8b9	4a		lsr a				lsr 	a
.b8ba	b0 05		bcs $b8c1			bcs 	_USInt 						; if msb set do as integer
.b8bc	20 e9 c5	jsr $c5e9			jsr 	FPToString 					; call fp to str otherwise
.b8bf	80 03		bra $b8c4			bra 	_USDuplicate
.b8c1	20 b2 c0	jsr $c0b2	_USInt:	jsr 	IntToString
.b8c4					_USDuplicate:
.b8c4	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.b8c7	1a		inc a				inc 	a 							; one more for length
.b8c8	20 6a bb	jsr $bb6a			jsr 	AllocateTempString 			; allocate space for it.
.b8cb	5a		phy				phy 								; save Y
.b8cc	a0 00		ldy #$00			ldy 	#0 							; start copying
.b8ce	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b8d1	20 95 bb	jsr $bb95			jsr 	WriteTempString
.b8d4	c8		iny				iny
.b8d5	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.b8d8	d0 f4		bne $b8ce			bne 	_USCopy
.b8da	7a		ply				ply 								; restore Y
.b8db	4c a6 ba	jmp $baa6			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b8de					Unary_Asc:
.b8de	20 15 b5	jsr $b515			jsr 	EvaluateStringX 			; string parameter
.b8e1	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.b8e4	5a		phy				phy 								; get the string length
.b8e5	a0 00		ldy #$00			ldy 	#0
.b8e7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b8e9	f0 07		beq $b8f2			beq 	_UAIllegal 					; must be at least one character
.b8eb	c8		iny				iny
.b8ec	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b8ee	7a		ply				ply
.b8ef	4c 6d b7	jmp $b76d			jmp 	UnarySetAInteger
.b8f2					_UAIllegal:
.b8f2	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b8f5					Unary_Len:
.b8f5	20 15 b5	jsr $b515			jsr 	EvaluateStringX 			; string parameter
.b8f8	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.b8fb	5a		phy				phy 								; get the string length
.b8fc	a0 00		ldy #$00			ldy 	#0
.b8fe	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b900	7a		ply				ply
.b901	4c 6d b7	jmp $b76d			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b904					Unary_Mid:
.b904	20 15 b5	jsr $b515			jsr 	EvaluateStringX 				; get string.
.b907	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b909	48		pha				pha
.b90a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b90c	48		pha				pha
.b90d	20 31 bb	jsr $bb31			jsr 	CheckNextComma 					; skip comma
.b910	20 99 b9	jsr $b999			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b913	48		pha				pha 									; and push it.
.b914	20 31 bb	jsr $bb31			jsr 	CheckNextComma 					; skip comma
.b917	20 99 b9	jsr $b999			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b91a	48		pha				pha 									; and push it.
.b91b	80 41		bra $b95e			bra 	SLIProcess
.b91d					Unary_Left:
.b91d	20 15 b5	jsr $b515			jsr 	EvaluateStringX 				; get string.
.b920	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b922	48		pha				pha
.b923	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b925	48		pha				pha
.b926	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b928	48		pha				pha
.b929	20 31 bb	jsr $bb31			jsr 	CheckNextComma 					; skip comma
.b92c	20 99 b9	jsr $b999			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b92f	48		pha				pha 									; and push it.
.b930	80 2c		bra $b95e			bra 	SLIProcess
.b932					Unary_Right:
.b932	20 15 b5	jsr $b515			jsr 	EvaluateStringX 				; get string.
.b935	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b937	48		pha				pha
.b938	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b93a	48		pha				pha
.b93b	da		phx				phx 									; get the string length and push on stack.
.b93c	a2 00		ldx #$00			ldx 	#0
.b93e	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b940	fa		plx				plx
.b941	48		pha				pha
.b942	20 31 bb	jsr $bb31			jsr 	CheckNextComma 					; skip comma
.b945	20 99 b9	jsr $b999			jsr 	SLIByteParameter 				; get a byte parameter.
.b948	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.b94b	68		pla				pla 									; restore string length.
.b94c	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b94d	38		sec				sec
.b94e	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.b951	f0 02		beq $b955			beq 	_URStart 						; if <= 0 start from 1.
.b953	10 02		bpl $b957			bpl 	_UROkay
.b955					_URStart:
.b955	a9 01		lda #$01			lda 	#1
.b957					_UROkay:
.b957	48		pha				pha 									; push start
.b958	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.b95b	48		pha				pha
.b95c	80 00		bra $b95e			bra 	SLIProcess
.b95e					SLIProcess:
.b95e	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 				; closing right bracket.
.b961	68		pla				pla
.b962	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.b965	1a		inc a				inc 	a 								; allocate +1 for it.
.b966	20 6a bb	jsr $bb6a			jsr 	AllocateTempString
.b969	68		pla				pla 									; pop start number off stack.
.b96a	f0 3b		beq $b9a7			beq 	SLIError 						; exit if start = 0
.b96c	8d a1 03	sta $03a1			sta 	SliceStart
.b96f	68		pla				pla  									; pop string address.
.b970	85 1f		sta $1f				sta 	zGenPtr+1
.b972	68		pla				pla
.b973	85 1e		sta $1e				sta 	zGenPtr
.b975	da		phx				phx
.b976	5a		phy				phy
.b977	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b979	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.b97c					_SLICopy:
.b97c	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.b97f	f0 12		beq $b993			beq 	_SLIExit
.b981	ce a2 03	dec $03a2			dec 	SliceCount
.b984	98		tya				tya 									; index of character
.b985	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b987	f0 02		beq $b98b			beq 	_SLIOk 							; if equal, okay.
.b989	b0 08		bcs $b993			bcs 	_SLIExit 						; if past end, then exit.
.b98b	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b98d	c8		iny				iny
.b98e	20 95 bb	jsr $bb95			jsr 	WriteTempString
.b991	80 e9		bra $b97c			bra 	_SLICopy 						; go round till copied characters
.b993					_SLIExit:
.b993	7a		ply				ply 									; restore YX
.b994	fa		plx				plx
.b995	4c a6 ba	jmp $baa6			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b998	ea		nop				nop
.b999					SLIByteParameter:
.b999	20 0c b5	jsr $b50c			jsr 	EvaluateIntegerX 				; get integer
.b99c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b99e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b9a0	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b9a2	d0 03		bne $b9a7			bne 	SLIError
.b9a4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b9a6	60		rts				rts
.b9a7					SLIError:
.b9a7	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b9aa					Unary_Hex:
.b9aa	20 0c b5	jsr $b50c			jsr 	EvaluateIntegerX 			; numeric parameter
.b9ad	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.b9b0	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b9b2	20 6a bb	jsr $bb6a			jsr 	AllocateTempString			; allocate string space
.b9b5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b9b7	20 db b9	jsr $b9db			jsr 	_UHConvert
.b9ba	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b9bc	20 db b9	jsr $b9db			jsr 	_UHConvert
.b9bf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b9c1	20 db b9	jsr $b9db			jsr 	_UHConvert
.b9c4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b9c6	20 db b9	jsr $b9db			jsr 	_UHConvert
.b9c9	5a		phy				phy 								; get length of new string
.b9ca	a0 00		ldy #$00			ldy 	#0
.b9cc	b1 20		lda ($20),y			lda 	(zTempStr),y
.b9ce	7a		ply				ply
.b9cf	c9 00		cmp #$00			cmp 	#0
.b9d1	d0 05		bne $b9d8			bne 	_UHExit 					; if it was non zero okay
.b9d3	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b9d5	20 95 bb	jsr $bb95			jsr 	WriteTempString
.b9d8					_UHExit:
.b9d8	4c a6 ba	jmp $baa6			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b9db					_UHConvert:
.b9db	48		pha				pha
.b9dc	4a		lsr a				lsr 	a 							; do MSB
.b9dd	4a		lsr a				lsr 	a
.b9de	4a		lsr a				lsr 	a
.b9df	4a		lsr a				lsr 	a
.b9e0	20 e4 b9	jsr $b9e4			jsr 	_UHNibble
.b9e3	68		pla				pla 								; do LSB
.b9e4					_UHNibble:
.b9e4	29 0f		and #$0f			and 	#15 						; get nibble
.b9e6	d0 0c		bne $b9f4			bne 	_UHNonZero
.b9e8	5a		phy				phy									; get the length
.b9e9	a0 00		ldy #$00			ldy 	#0
.b9eb	b1 20		lda ($20),y			lda 	(zTempStr),y
.b9ed	7a		ply				ply
.b9ee	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b9f0	f0 0d		beq $b9ff			beq 	_UHExit2
.b9f2	a9 00		lda #$00			lda 	#0
.b9f4					_UHNonZero:
.b9f4	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b9f6	90 02		bcc $b9fa			bcc 	_UHDigit
.b9f8	69 06		adc #$06			adc 	#7-1
.b9fa					_UHDigit:
.b9fa	69 30		adc #$30			adc 	#48
.b9fc	20 95 bb	jsr $bb95			jsr 	WriteTempString				; output.
.b9ff					_UHExit2:
.b9ff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.ba00					Unary_Dec:
.ba00	20 15 b5	jsr $b515			jsr 	EvaluateStringX 			; string parameter
.ba03	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.ba06	5a		phy				phy
.ba07	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.ba09	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ba0b	f0 41		beq $ba4e			beq 	_UDFail 					; must fail if zero.
.ba0d	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.ba10	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.ba12	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba14	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba16	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ba18	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ba1a	a9 01		lda #$01			lda 	#1
.ba1c	95 85		sta $85,x			sta 	XS_Type,x
.ba1e					_UDConvertLoop:
.ba1e	5a		phy				phy 								; shift mantissa left 4
.ba1f	a0 04		ldy #$04			ldy 	#4
.ba21					_UDShift:
.ba21	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.ba23	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.ba25	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.ba27	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.ba29	88		dey				dey
.ba2a	d0 f5		bne $ba21			bne 	_UDShift
.ba2c	7a		ply				ply
.ba2d	c8		iny				iny 								; next character
.ba2e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.ba30	20 51 ba	jsr $ba51			jsr 	ConvertUpper 				; convert to U/C
.ba33	c9 30		cmp #$30			cmp 	#"0"
.ba35	90 17		bcc $ba4e			bcc 	_UDFail
.ba37	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba39	90 06		bcc $ba41			bcc 	_UDOkay
.ba3b	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.ba3d	c9 10		cmp #$10			cmp 	#16
.ba3f	b0 0d		bcs $ba4e			bcs 	_UDFail
.ba41					_UDOkay:
.ba41	29 0f		and #$0f			and 	#15 						; nibble only
.ba43	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.ba45	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba47	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.ba4a	d0 d2		bne $ba1e			bne 	_UDConvertLoop
.ba4c	7a		ply				ply
.ba4d	60		rts				rts
.ba4e					_UDFail:
.ba4e	4c d3 ad	jmp $add3			jmp 	BadParamError
.ba51					ConvertUpper:
.ba51	c9 61		cmp #$61			cmp 	#"a"
.ba53	90 07		bcc $ba5c			bcc 	_CUExit
.ba55	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba57	b0 03		bcs $ba5c			bcs 	_CUExit
.ba59	38		sec				sec
.ba5a	e9 20		sbc #$20			sbc 	#32
.ba5c	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.ba5d					Unary_Chr:
.ba5d	20 0c b5	jsr $b50c			jsr 	EvaluateIntegerX			; numeric parameter
.ba60	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.ba63	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.ba65	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ba67	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.ba69	d0 0d		bne $ba78			bne 	_UCChar
.ba6b	a9 01		lda #$01			lda 	#1 							; one character string
.ba6d	20 6a bb	jsr $bb6a			jsr 	AllocateTempString
.ba70	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.ba72	20 95 bb	jsr $bb95			jsr 	WriteTempString
.ba75	4c a6 ba	jmp $baa6			jmp 	UnaryReturnTempStr
.ba78					_UCChar:
.ba78	4c d3 ad	jmp $add3			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.ba7b					Unary_Spc:
.ba7b	20 0c b5	jsr $b50c			jsr 	EvaluateIntegerX 			; numeric parameter
.ba7e	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; right bracket.
.ba81	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.ba83	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ba85	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.ba87	d0 1a		bne $baa3			bne 	_USSize
.ba89	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ba8b	c9 fe		cmp #$fe			cmp 	#maxString+1
.ba8d	b0 14		bcs $baa3			bcs 	_USSize
.ba8f	48		pha				pha 								; save length
.ba90	1a		inc a				inc 	a 							; allocate one more.
.ba91	20 6a bb	jsr $bb6a			jsr 	AllocateTempString
.ba94	68		pla				pla 								; get length
.ba95	f0 0f		beq $baa6			beq 	UnaryReturnTempStr 			; return the current temp string
.ba97					_USLoop:
.ba97	48		pha				pha
.ba98	a9 20		lda #$20			lda 	#" "
.ba9a	20 95 bb	jsr $bb95			jsr 	WriteTempString
.ba9d	68		pla				pla
.ba9e	3a		dec a				dec 	a
.ba9f	d0 f6		bne $ba97			bne 	_USLoop
.baa1	80 03		bra $baa6			bra 	UnaryReturnTempStr
.baa3					_USSize:
.baa3	4c d3 ad	jmp $add3			jmp 	BadParamError
.baa6					UnaryReturnTempStr:
.baa6	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.baa8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.baaa	a5 21		lda $21				lda 	zTempStr+1
.baac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.baae	a9 02		lda #$02			lda 	#2 							; set type to string
.bab0	95 85		sta $85,x			sta 	XS_Type,x
.bab2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.bab3	db		phz		MemRead:phz
.bab4	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.bab7	a3 00		ldz #$00			ldz 	#0 							; start from here
.bab9	ea		nop		_MLoop1:nop
.baba	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.babc	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.babe	1b		inz				inz 								; next to copy
.babf	e8		inx				inx
.bac0	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.bac3	d0 f4		bne $bab9			bne 	_MLoop1
.bac5	fb		plz				plz
.bac6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.bac7					UpdateProgramEnd:
.bac7	a9 00		lda #$00			lda 	#BasicProgram & $FF
.bac9	85 16		sta $16				sta 	zCodePtr+0
.bacb	a9 80		lda #$80			lda 	#BasicProgram >> 8
.bacd	85 17		sta $17				sta 	zCodePtr+1
.bacf	a9 02		lda #$02			lda 	#2
.bad1	85 18		sta $18				sta 	zCodePtr+2
.bad3	a9 00		lda #$00			lda 	#0
.bad5	85 19		sta $19				sta 	zCodePtr+3
.bad7	a3 03		ldz #$03			ldz 	#3
.bad9					_UPDLoop:
.bad9	a3 00		ldz #$00			ldz 	#0
.badb	ea		nop				nop
.badc	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bade	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.bae0	f0 10		beq $baf2			beq 	_UPDFoundEnd
.bae2	a3 00		ldz #$00			ldz 	#0 							; point to offset
.bae4	ea		nop				nop
.bae5	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.bae7	18		clc				clc
.bae8	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.baea	85 16		sta $16				sta 	zCodePtr
.baec	90 02		bcc $baf0			bcc 	_SNLNoCarry
.baee	e6 17		inc $17				inc 	zCodePtr+1
.baf0					_SNLNoCarry:
.baf0	80 e7		bra $bad9			bra 	_UPDLoop
.baf2					_UPDFoundEnd:
.baf2	18		clc				clc 								; end of program 2 on.
.baf3	a5 16		lda $16				lda 	zCodePtr
.baf5	69 02		adc #$02			adc 	#2
.baf7	8d 04 03	sta $0304			sta 	endOfProgram
.bafa	a5 17		lda $17				lda 	zCodePtr+1
.bafc	69 00		adc #$00			adc 	#0
.bafe	8d 05 03	sta $0305			sta 	endOfProgram+1
.bb01	a5 18		lda $18				lda 	zCodePtr+2
.bb03	69 00		adc #$00			adc		#0
.bb05	8d 06 03	sta $0306			sta 	endOfProgram+2
.bb08	a5 19		lda $19				lda 	zCodePtr+3
.bb0a	69 00		adc #$00			adc 	#0
.bb0c	8d 07 03	sta $0307			sta 	endOfProgram+3
.bb0f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.bb10					CheckNextToken:
.bb10	ea		nop				nop
.bb11	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.bb13	d0 02		bne $bb17			bne 	CTFail 						; no, then fail
.bb15	1b		inz				inz
.bb16	60		rts				rts
.bb17					CTFail:
.bb17	20 e4 ad	jsr $ade4			jsr ERR_Handler
>bb1a	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>bb22	74 6f 6b 65 6e 00
.bb28					CheckNextRParen:
.bb28	ea		nop				nop
.bb29	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb2b	c9 be		cmp #$be			cmp 	#token_rparen
.bb2d	d0 e8		bne $bb17			bne 	CTFail
.bb2f	1b		inz				inz
.bb30	60		rts				rts
.bb31					CheckNextComma:
.bb31	ea		nop				nop
.bb32	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb34	c9 bf		cmp #$bf			cmp 	#token_comma
.bb36	d0 df		bne $bb17			bne 	CTFail
.bb38	1b		inz				inz
.bb39	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.bb3a					StringConcrete:
.bb3a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.bb3c	85 10		sta $10				sta 	zTemp1
.bb3e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bb40	85 11		sta $11				sta 	zTemp1+1
.bb42	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.bb44	18		clc				clc 								; from the string pointer
.bb45	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.bb48	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.bb4a	8d 00 03	sta $0300			sta 	StringPtr
.bb4d	85 12		sta $12				sta 	zTemp2
.bb4f	ad 01 03	lda $0301			lda 	StringPtr+1
.bb52	e9 00		sbc #$00			sbc 	#0
.bb54	8d 01 03	sta $0301			sta 	StringPtr+1
.bb57	85 13		sta $13				sta 	zTemp2+1
.bb59	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.bb5b	1a		inc a				inc 	a
.bb5c	aa		tax				tax
.bb5d	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.bb5f	91 12		sta ($12),y			sta 	(zTemp2),y
.bb61	c8		iny				iny
.bb62	ca		dex				dex
.bb63	d0 f8		bne $bb5d			bne 	_SCCopy
.bb65	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.bb67	a6 12		ldx $12				ldx 	zTemp2
.bb69	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.bb6a					AllocateTempString:
.bb6a	48		pha				pha 								; save required count.
.bb6b	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.bb6d	d0 0b		bne $bb7a			bne 	_ATSInitialised
.bb6f	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.bb72	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.bb74	ad 01 03	lda $0301			lda 	StringPtr+1
.bb77	3a		dec a				dec 	a
.bb78	85 21		sta $21				sta 	zTempStr+1
.bb7a					_ATSInitialised:
.bb7a	68		pla				pla 								; get required count back.
.bb7b	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.bb7d	1a		inc a				inc 	a
.bb7e	18		clc				clc
.bb7f	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.bb81	85 20		sta $20				sta 	zTempStr
.bb83	a9 ff		lda #$ff			lda 	#$FF
.bb85	65 21		adc $21				adc 	zTempStr+1
.bb87	85 21		sta $21				sta 	zTempStr+1
.bb89	a9 00		lda #$00			lda 	#0 							; clear temp string.
.bb8b	5a		phy				phy
.bb8c	a8		tay				tay
.bb8d	91 20		sta ($20),y			sta 	(zTempStr),y
.bb8f	7a		ply				ply
.bb90	1a		inc a				inc 	a 							; reset the write index.
.bb91	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.bb94	60		rts				rts
.bb95					WriteTempString:
.bb95	5a		phy				phy 								; save Y
.bb96	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.bb99	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.bb9b	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.bb9e	98		tya				tya 								; unchanged Y is now length
.bb9f	a0 00		ldy #$00			ldy 	#0
.bba1	91 20		sta ($20),y			sta 	(zTempStr),y
.bba3	7a		ply				ply 								; restore Y and exit
.bba4	60		rts				rts
.bba5					CreateTempStringCopy:
.bba5	da		phx				phx 								; save X
.bba6	ea		nop				nop
.bba7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bba9	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.bbaa	20 6a bb	jsr $bb6a			jsr 	AllocateTempString 			; allocate memory for temporary string.
.bbad	ea		nop				nop
.bbae	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbb0	1b		inz				inz
.bbb1	3a		dec a				dec 	a 							; make the actual length in charactes
.bbb2	3a		dec a				dec 	a
.bbb3	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.bbb5	81 20		sta ($20,x)			sta 	(zTempStr,x)
.bbb7	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.bbb9	09 00		ora #$00			ora 	#0 							; if zero already, exit
.bbbb	f0 0f		beq $bbcc			beq 	_CTSCExit
.bbbd					_CTSCLoop:
.bbbd	ea		nop				nop
.bbbe	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbc0	1b		inz				inz
.bbc1	5a		phy				phy 								; save in Y
.bbc2	e8		inx				inx 								; bump index
.bbc3	da		phx				phx 								; index into Y
.bbc4	7a		ply				ply
.bbc5	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.bbc7	7a		ply				ply 								; restore Y
.bbc8	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.bbca	d0 f1		bne $bbbd			bne 	_CTSCLoop
.bbcc					_CTSCExit:
.bbcc	fa		plx				plx 								; restore X
.bbcd	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.bbce					VariableFind:
.bbce	20 39 bc	jsr $bc39			jsr 	VariableExtract 		; find out all about it ....
.bbd1	20 d4 be	jsr $bed4			jsr 	VariableLocate 			; does it already exist ?
.bbd4	b0 03		bcs $bbd9			bcs 	_VFExists 				; if so, use that.
.bbd6	20 c7 bc	jsr $bcc7			jsr 	VariableCreate 			; otherwise create it.
.bbd9					_VFExists:
.bbd9	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.bbdb	29 01		and #$01			and 	#1
.bbdd	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bbdf	d0 28		bne $bc09			bne 	_VFSingleElement
.bbe1					_VFNextIndex:
.bbe1	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.bbe3	48		pha				pha
.bbe4	a5 23		lda $23				lda 	zVarDataPtr+1
.bbe6	48		pha				pha
.bbe7	a5 24		lda $24				lda 	zVarType
.bbe9	48		pha				pha
.bbea	20 0c b5	jsr $b50c			jsr 	EvaluateIntegerX 		; calculate the index.
.bbed	68		pla				pla 							; restore and index.
.bbee	85 24		sta $24				sta 	zVarType
.bbf0	68		pla				pla
.bbf1	85 23		sta $23				sta 	zVarDataPtr+1
.bbf3	68		pla				pla
.bbf4	85 22		sta $22				sta 	zVarDataPtr
.bbf6	20 52 bd	jsr $bd52			jsr 	ArrayIndexFollow 		; do the index.
.bbf9	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bbfb	29 01		and #$01			and 	#1
.bbfd	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bbff	d0 05		bne $bc06			bne 	_VFArrayDone 			; if so then exit.
.bc01	20 31 bb	jsr $bb31			jsr 	CheckNextComma 			; comma should follow
.bc04	80 db		bra $bbe1			bra 	_VFNextIndex
.bc06					_VFArrayDone:
.bc06	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 		; check closing right bracket.
.bc09					_VFSingleElement:
.bc09	60		rts				rts
.bc0a					VariableClear:
.bc0a	48		pha				pha 							; save registers
.bc0b	da		phx				phx
.bc0c	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.bc0e	8a		txa				txa
.bc0f	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.bc12	e8		inx				inx
.bc13	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bc15	d0 f8		bne $bc0f			bne 	_VCLoop
.bc17	a9 00		lda #$00			lda 	#VariableMemory & $FF
.bc19	8d 02 03	sta $0302			sta 	VarMemPtr
.bc1c	a9 20		lda #$20			lda 	#VariableMemory >> 8
.bc1e	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bc21	fa		plx				plx 							; restore registers
.bc22	68		pla				pla
.bc23	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bc24					VariableNameError:
.bc24	20 e4 ad	jsr $ade4			jsr ERR_Handler
>bc27	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>bc2f	61 62 6c 65 20 4e 61 6d 65 00
.bc39					VariableExtract:
.bc39	da		phx				phx 							; save X.
.bc3a	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bc3c	8d 95 03	sta $0395			sta 	Var_Type
.bc3f	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.bc42	ea		nop				nop
.bc43	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bc45	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bc47	f0 db		beq $bc24			beq 	VariableNameError
.bc49	c9 1b		cmp #$1b			cmp 	#26+1
.bc4b	b0 d7		bcs $bc24			bcs 	VariableNameError
.bc4d	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.bc4f					_VECopyBuffer:
.bc4f	e8		inx				inx
.bc50	e0 1f		cpx #$1f			cpx 	#31 					; too long
.bc52	f0 d0		beq $bc24			beq 	VariableNameError
.bc54	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.bc57	18		clc				clc  							; update the hash value for it.
.bc58	6d 96 03	adc $0396			adc 	Var_Hash
.bc5b	8d 96 03	sta $0396			sta 	Var_Hash
.bc5e	1b		inz				inz
.bc5f	ea		nop				nop
.bc60	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bc62	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bc64	f0 0e		beq $bc74			beq 	_VECopyEnd
.bc66	30 0c		bmi $bc74			bmi 	_VECopyEnd
.bc68	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bc6a	90 e3		bcc $bc4f			bcc 	_VECopyBuffer
.bc6c	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bc6e	90 04		bcc $bc74			bcc 	_VECopyEnd
.bc70	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc72	90 db		bcc $bc4f			bcc 	_VECopyBuffer
.bc74					_VECopyEnd:
.bc74	1b		inz				inz
.bc75	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bc77	90 04		bcc $bc7d			bcc 	_VEDefaultRequired
.bc79	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bc7b	90 0b		bcc $bc88			bcc 	_VEHaveType
.bc7d					_VEDefaultRequired:
.bc7d	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bc7f	f0 04		beq $bc85			beq 	_VESetType 				; default set above.
.bc81	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.bc84	3b		dez				dez
.bc85					_VESetType:
.bc85	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.bc88					_VEHaveType:
.bc88	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.bc8b	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.bc8e	09 80		ora #$80			ora 	#$80
.bc90	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.bc93	e8		inx				inx 							; offset 3 => length 4.
.bc94	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.bc97	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.bc9a	38		sec				sec
.bc9b	e9 b7		sbc #$b7			sbc 	#token_Dollar
.bc9d	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.bc9e	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.bc9f	0a		asl a				asl 	a
.bca0	0a		asl a				asl 	a
.bca1	8d 98 03	sta $0398			sta 	Var_HashAddress
.bca4	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.bca7	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.bca9	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.bcaa	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.bcad	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.bcaf	8d 98 03	sta $0398			sta 	Var_HashAddress
.bcb2	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.bcb4	ad 95 03	lda $0395			lda 	Var_Type
.bcb7	c9 b9		cmp #$b9			cmp 	#token_Hash
.bcb9	f0 07		beq $bcc2			beq 	_VEHaveSize
.bcbb	ca		dex				dex
.bcbc	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.bcbe	f0 02		beq $bcc2			beq 	_VEHaveSize
.bcc0	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.bcc2					_VEHaveSize:
.bcc2	8e 99 03	stx $0399			stx 	Var_DataSize
.bcc5	fa		plx				plx
.bcc6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.bcc7					VariableCreate:
.bcc7	da		phx				phx
.bcc8	5a		phy				phy
.bcc9	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.bccc	85 10		sta $10				sta 	zTemp1
.bcce	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bcd1	85 11		sta $11				sta 	zTemp1+1
.bcd3	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.bcd6	18		clc				clc
.bcd7	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.bcda	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.bcdc	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.bcdf	8d 02 03	sta $0302			sta 	VarMemPtr
.bce2	90 03		bcc $bce7			bcc 	_VCNoCarry
.bce4	ee 03 03	inc $0303			inc 	VarMemPtr+1
.bce7					_VCNoCarry:
.bce7	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bcea	85 12		sta $12				sta 	zTemp2
.bcec	a9 03		lda #$03			lda 	#HashTableBase >> 8
.bcee	85 13		sta $13				sta 	zTemp2+1
.bcf0	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.bcf2	b1 12		lda ($12),y			lda 	(zTemp2),y
.bcf4	91 10		sta ($10),y			sta 	(zTemp1),y
.bcf6	c8		iny				iny
.bcf7	b1 12		lda ($12),y			lda 	(zTemp2),y
.bcf9	91 10		sta ($10),y			sta 	(zTemp1),y
.bcfb	c8		iny				iny
.bcfc	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.bcff	91 10		sta ($10),y			sta 	(zTemp1),y
.bd01	c8		iny				iny
.bd02	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.bd04					_VCCopyName:
.bd04	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.bd07	91 10		sta ($10),y			sta 	(zTemp1),y
.bd09	e8		inx				inx
.bd0a	c8		iny				iny
.bd0b	ec 97 03	cpx $0397			cpx 	Var_Length
.bd0e	d0 f4		bne $bd04			bne 	_VCCopyName
.bd10	5a		phy				phy 								; save the data offset.
.bd11	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.bd14	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.bd16					_VCClearData:
.bd16	91 10		sta ($10),y			sta 	(zTemp1),y
.bd18	c8		iny				iny
.bd19	ca		dex				dex
.bd1a	d0 fa		bne $bd16			bne 	_VCClearData
.bd1c	68		pla				pla 								; offset to the data
.bd1d	18		clc				clc
.bd1e	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.bd20	85 22		sta $22				sta 	zVarDataPtr
.bd22	a5 11		lda $11				lda 	zTemp1+1
.bd24	69 00		adc #$00			adc 	#0
.bd26	85 23		sta $23				sta 	zVarDataPtr+1
.bd28	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.bd2b	85 24		sta $24				sta 	zVarType
.bd2d	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.bd2f	a0 00		ldy #$00			ldy 	#0
.bd31	91 12		sta ($12),y			sta 	(zTemp2),y
.bd33	c8		iny				iny
.bd34	a5 11		lda $11				lda 	zTemp1+1
.bd36	91 12		sta ($12),y			sta 	(zTemp2),y
.bd38	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.bd3b	29 01		and #$01			and 	#1
.bd3d	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.bd3f	d0 0e		bne $bd4f			bne 	_VCNotArray
.bd41	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.bd43	20 e9 bd	jsr $bde9			jsr 	ArrayCreate
.bd46	5a		phy				phy 								; save YA at zVarDataPtr
.bd47	a0 00		ldy #$00			ldy 	#0
.bd49	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bd4b	c8		iny				iny
.bd4c	68		pla				pla
.bd4d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bd4f					_VCNotArray:
.bd4f	7a		ply				ply
.bd50	fa		plx				plx
.bd51	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.bd52					ArrayIndexFollow:
.bd52	5a		phy				phy
.bd53	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.bd55	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.bd57	48		pha				pha
.bd58	c8		iny				iny
.bd59	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bd5b	85 23		sta $23				sta 	zVarDataPtr+1
.bd5d	68		pla				pla
.bd5e	85 22		sta $22				sta 	zVarDataPtr
.bd60	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.bd62	29 80		and #$80			and 	#$80 						; must be zero.
.bd64	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bd66	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bd68	d0 59		bne $bdc3			bne 	_AIFError
.bd6a	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.bd6c	18		clc				clc
.bd6d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bd6f	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.bd71	c8		iny				iny
.bd72	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bd74	08		php				php 								; clear bit 7 retaining borrow.
.bd75	29 7f		and #$7f			and 	#$7F
.bd77	28		plp				plp
.bd78	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.bd7a	90 47		bcc $bdc3			bcc 	_AIFError 					; eror if size-current < 0
.bd7c	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.bd7e	0a		asl a				asl 	a 							; (e.g. index * 2)
.bd7f	85 10		sta $10				sta 	zTemp1
.bd81	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd83	2a		rol a				rol 	a
.bd84	85 11		sta $11				sta 	zTemp1+1
.bd86	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.bd88	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.bd8a	30 1d		bmi $bda9			bmi 	_AIFCalculate
.bd8c	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.bd8e	a5 24		lda $24				lda 	zVarType 					; check that type
.bd90	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.bd92	f0 15		beq $bda9			beq 	_AIFCalculate
.bd94	06 10		asl $10				asl 	zTemp1			 			; double the index
.bd96	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.bd98	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.bd9a	f0 0d		beq $bda9			beq 	_AIFCalculate
.bd9c	18		clc				clc 								; add the original mantissa in again
.bd9d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.bd9f	65 10		adc $10				adc 	zTemp1
.bda1	85 10		sta $10				sta 	zTemp1
.bda3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bda5	65 11		adc $11				adc 	zTemp1+1
.bda7	85 11		sta $11				sta 	zTemp1+1
.bda9					_AIFCalculate:
.bda9	18		clc				clc 								; add index x 2,4 or 5 to base
.bdaa	a5 22		lda $22				lda 	zVarDataPtr
.bdac	65 10		adc $10				adc 	zTemp1
.bdae	85 22		sta $22				sta 	zVarDataPtr
.bdb0	a5 23		lda $23				lda 	zVarDataPtr+1
.bdb2	65 11		adc $11				adc 	zTemp1+1
.bdb4	85 23		sta $23				sta 	zVarDataPtr+1
.bdb6	18		clc				clc 								; add 2 more for the length prefix.
.bdb7	a5 22		lda $22				lda 	zVarDataPtr
.bdb9	69 02		adc #$02			adc 	#2
.bdbb	85 22		sta $22				sta 	zVarDataPtr
.bdbd	90 02		bcc $bdc1			bcc 	_AIFNoBump
.bdbf	e6 23		inc $23				inc 	zVarDataPtr+1
.bdc1					_AIFNoBump:
.bdc1	7a		ply				ply
.bdc2	60		rts				rts
.bdc3					_AIFError:
.bdc3	20 e4 ad	jsr $ade4			jsr ERR_Handler
>bdc6	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bdce	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.bdd6					ArrayResetDefault:
.bdd6	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.bdd8	8d a7 03	sta $03a7			sta 	ArrayDef+0
.bddb	a9 00		lda #$00			lda 	#0
.bddd	8d a8 03	sta $03a8			sta 	ArrayDef+1
.bde0	a9 ff		lda #$ff			lda 	#$FF
.bde2	8d a9 03	sta $03a9			sta 	ArrayDef+2 					; $FFFF implies no second element.
.bde5	8d aa 03	sta $03aa			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.bde8	60		rts				rts
.bde9					ArrayCreate:
.bde9	bd a7 03	lda $03a7,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.bdec	0a		asl a				asl 	a
.bded	85 10		sta $10				sta 	zTemp1
.bdef	bd a8 03	lda $03a8,x			lda 	ArrayDef+1,x
.bdf2	2a		rol a				rol 	a
.bdf3	85 11		sta $11				sta 	zTemp1+1
.bdf5	bd aa 03	lda $03aa,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.bdf8	10 22		bpl $be1c			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.bdfa	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.bdfd	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.bdff	f0 1b		beq $be1c			beq 	_ACSized
.be01	06 10		asl $10				asl 	zTemp1 						; double again
.be03	26 11		rol $11				rol 	zTemp1+1
.be05	b0 6f		bcs $be76			bcs 	ArrayIndexError 			; too large.
.be07	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.be09	f0 11		beq $be1c			beq 	_ACSized
.be0b	18		clc				clc 								; add original value x 5 for reals.
.be0c	a5 10		lda $10				lda 	zTemp1
.be0e	7d a7 03	adc $03a7,x			adc 	ArrayDef+0,x
.be11	85 10		sta $10				sta 	zTemp1
.be13	a5 11		lda $11				lda 	zTemp1+1
.be15	7d a8 03	adc $03a8,x			adc 	ArrayDef+1,x
.be18	85 11		sta $11				sta 	zTemp1+1
.be1a	b0 5a		bcs $be76			bcs 	ArrayIndexError
.be1c					_ACSized:
.be1c	18		clc				clc
.be1d	a5 10		lda $10				lda 	zTemp1
.be1f	69 02		adc #$02			adc 	#2
.be21	85 10		sta $10				sta 	zTemp1
.be23	90 04		bcc $be29			bcc 	_ACNoBump
.be25	e6 10		inc $10				inc 	zTemp1
.be27	f0 4d		beq $be76			beq 	ArrayIndexError
.be29					_ACNoBump:
.be29	18		clc				clc
.be2a	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.be2d	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.be2f	85 14		sta $14				sta 	zTemp3
.be31	65 10		adc $10				adc 	zTemp1
.be33	8d 02 03	sta $0302			sta 	VarMemPtr
.be36	ad 03 03	lda $0303			lda 	VarMemPtr+1
.be39	85 13		sta $13				sta 	zTemp2+1
.be3b	85 15		sta $15				sta 	zTemp3+1
.be3d	65 11		adc $11				adc 	zTemp1+1
.be3f	8d 03 03	sta $0303			sta 	VarMemPtr+1
.be42	85 11		sta $11				sta 	zTemp1+1
.be44	b0 30		bcs $be76			bcs 	ArrayIndexError
.be46	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.be48					_ACClear:
.be48	98		tya				tya
.be49	91 12		sta ($12),y			sta 	(zTemp2),y
.be4b	e6 12		inc $12				inc 	zTemp2
.be4d	d0 02		bne $be51			bne 	_ACCBump
.be4f	e6 13		inc $13				inc 	zTemp2+1
.be51					_ACCBump:
.be51	a5 12		lda $12				lda 	zTemp2
.be53	cd 02 03	cmp $0302			cmp 	VarMemPtr
.be56	d0 f0		bne $be48			bne 	_ACClear
.be58	a5 13		lda $13				lda 	zTemp2+1
.be5a	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.be5d	d0 e9		bne $be48			bne 	_ACClear
.be5f	a0 00		ldy #$00			ldy 	#0
.be61	bd a7 03	lda $03a7,x			lda 	ArrayDef+0,x 				; copy the size into the start
.be64	91 14		sta ($14),y			sta 	(zTemp3),y
.be66	c8		iny				iny
.be67	bd a8 03	lda $03a8,x			lda 	ArrayDef+1,x
.be6a	91 14		sta ($14),y			sta 	(zTemp3),y
.be6c	bd aa 03	lda $03aa,x			lda 	ArrayDef+3,x 				; have we reached the end
.be6f	10 18		bpl $be89			bpl 	ACCFillRecursive
.be71	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.be73	a5 14		lda $14				lda 	zTemp3
.be75	60		rts				rts
.be76					ArrayIndexError:
.be76	20 e4 ad	jsr $ade4			jsr ERR_Handler
>be79	42 61 64 20 61 72 72 61			.text "Bad array index",0
>be81	79 20 69 6e 64 65 78 00
.be89					ACCFillRecursive:
.be89	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.be8b	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.be8d	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.be8f	c8		iny				iny
.be90	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.be92	09 80		ora #$80			ora 	#$80 						; an array of pointers
.be94	91 14		sta ($14),y			sta 	(zTemp3),y
.be96	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.be98	48		pha				pha
.be99	a5 15		lda $15				lda 	zTemp3+1
.be9b	48		pha				pha
.be9c					_ACCFillLoop:
.be9c	18		clc				clc
.be9d	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.be9f	69 02		adc #$02			adc 	#2
.bea1	85 14		sta $14				sta 	zTemp3
.bea3	90 02		bcc $bea7			bcc 	_ACCSkip2
.bea5	e6 15		inc $15				inc 	zTemp3+1
.bea7					_ACCSkip2:
.bea7	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.bea9	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.beab	c8		iny				iny
.beac	11 14		ora ($14),y			ora 	(zTemp3),y
.beae	d0 21		bne $bed1			bne 	_ACCExit
.beb0	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.beb2	48		pha				pha
.beb3	a5 15		lda $15				lda 	zTemp3+1
.beb5	48		pha				pha
.beb6	e8		inx				inx
.beb7	e8		inx				inx
.beb8	20 e9 bd	jsr $bde9			jsr 	ArrayCreate 				; create array recursively.
.bebb	ca		dex				dex
.bebc	ca		dex				dex
.bebd	85 12		sta $12				sta 	zTemp2 						; save A
.bebf	68		pla				pla
.bec0	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.bec2	68		pla				pla
.bec3	85 14		sta $14				sta 	zTemp3
.bec5	98		tya				tya 								; write high bye from Y
.bec6	a0 01		ldy #$01			ldy 	#1
.bec8	91 14		sta ($14),y			sta 	(zTemp3),y
.beca	88		dey				dey 								; write low byte out.
.becb	a5 12		lda $12				lda 	zTemp2
.becd	91 14		sta ($14),y			sta 	(zTemp3),y
.becf	80 cb		bra $be9c			bra 	_ACCFillLoop 				; and try again.
.bed1					_ACCExit:
.bed1	7a		ply				ply 								; restore the original address
.bed2	68		pla				pla
.bed3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.bed4					VariableLocate:
.bed4	da		phx				phx
.bed5	5a		phy				phy
.bed6	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bed9	85 12		sta $12				sta 	zTemp2 						; points to first address.
.bedb	a9 03		lda #$03			lda 	#HashTableBase >> 8
.bedd	85 13		sta $13				sta 	zTemp2+1
.bedf	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.bee1	b1 12		lda ($12),y			lda 	(zTemp2),y
.bee3	aa		tax				tax
.bee4	c8		iny				iny
.bee5	b1 12		lda ($12),y			lda 	(zTemp2),y
.bee7	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.bee9	86 12		stx $12				stx 	zTemp2
.beeb	05 12		ora $12				ora 	zTemp2 						; got zero
.beed	18		clc				clc
.beee	f0 25		beq $bf15			beq 	_VLExit 					; if so, then fail as end of chain.
.bef0	c8		iny				iny 								; point to hash (offset + 2)
.bef1	b1 12		lda ($12),y			lda 	(zTemp2),y
.bef3	cd 96 03	cmp $0396			cmp 	Var_Hash
.bef6	d0 e7		bne $bedf			bne 	_VLNext 					; try next if different.
.bef8					_VLCompare:
.bef8	c8		iny				iny 								; next character
.bef9	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.befb	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.befe	d0 df		bne $bedf			bne 	_VLNext 					; fail if different, try next.
.bf00	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.bf01	90 f5		bcc $bef8			bcc 	_VLCompare
.bf03	98		tya				tya
.bf04	38		sec				sec 								; add 1 as Y points to last character
.bf05	65 12		adc $12				adc 	zTemp2 						; add to the current address
.bf07	85 22		sta $22				sta 	zVarDataPtr
.bf09	a5 13		lda $13				lda 	zTemp2+1
.bf0b	69 00		adc #$00			adc 	#0
.bf0d	85 23		sta $23				sta 	zVarDataPtr+1
.bf0f	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.bf12	85 24		sta $24				sta 	zVarType
.bf14	38		sec				sec 								; return CS
.bf15	7a		ply		_VLExit:ply
.bf16	fa		plx				plx
.bf17	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.bf18					VariableGet:
.bf18	5a		phy				phy
.bf19	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.bf1b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bf1d	95 80		sta $80,x			sta 	XS_Mantissa,x
.bf1f	c8		iny				iny
.bf20	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bf22	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf24	c8		iny				iny
.bf25	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.bf27	c9 b7		cmp #$b7			cmp 	#token_Dollar
.bf29	f0 2c		beq $bf57			beq 	_VGString
.bf2b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.bf2d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf2f	c8		iny				iny
.bf30	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bf32	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf34	c8		iny				iny
.bf35	a9 01		lda #$01			lda 	#1 							; set type to 1.
.bf37	95 85		sta $85,x			sta 	XS_Type,x
.bf39	a5 24		lda $24				lda 	zVarType
.bf3b	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.bf3d	f0 28		beq $bf67			beq 	_VGExit
.bf3f	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.bf41	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.bf43	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.bf45	95 84		sta $84,x			sta 	XS_Exponent,x
.bf47	f0 1e		beq $bf67			beq 	_VGExit 					; if exponent is zero ... it's zero.
.bf49	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.bf4b	48		pha				pha
.bf4c	29 80		and #$80			and 	#$80
.bf4e	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.bf50	68		pla				pla
.bf51	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.bf53	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.bf55	80 10		bra $bf67			bra 	_VGExit
.bf57					_VGString:
.bf57	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.bf59	95 85		sta $85,x			sta 	XS_Type,x
.bf5b	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.bf5d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.bf5f	d0 06		bne $bf67			bne 	_VGExit 					; if not, exit.
.bf61	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.bf63	a9 25		lda #$25			lda 	#zNullString
.bf65	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.bf67					_VGExit:
.bf67	7a		ply				ply
.bf68	60		rts				rts
.bf69					VariableSet:
.bf69	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.bf6b	29 02		and #$02			and 	#2 							; if so, it has to be
.bf6d	d0 4b		bne $bfba			bne 	_VSString
.bf6f	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.bf71	c9 b7		cmp #$b7			cmp 	#token_Dollar
.bf73	f0 42		beq $bfb7			beq 	_VSBadType
.bf75	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.bf77	f0 05		beq $bf7e			beq 	_VSMakeInt
.bf79	20 9e c4	jsr $c49e			jsr 	FPUToFloat
.bf7c	80 03		bra $bf81			bra 	_VSCopy
.bf7e					_VSMakeInt:
.bf7e	20 ea c4	jsr $c4ea			jsr 	FPUToInteger
.bf81					_VSCopy:
.bf81	5a		phy				phy
.bf82	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.bf84	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bf86	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf88	c8		iny				iny
.bf89	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf8b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf8d	c8		iny				iny
.bf8e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bf90	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf92	c8		iny				iny
.bf93	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf95	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf97	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.bf99	c9 bb		cmp #$bb			cmp 	#token_Percent
.bf9b	f0 18		beq $bfb5			beq 	_VSExit
.bf9d	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.bf9f	0a		asl a				asl 	a
.bfa0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.bfa2	08		php				php
.bfa3	0a		asl a				asl 	a
.bfa4	28		plp				plp
.bfa5	6a		ror a				ror 	a
.bfa6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bfa8	c8		iny				iny
.bfa9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.bfab	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bfad	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.bfaf	50 04		bvc $bfb5			bvc 	_VSExit
.bfb1	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.bfb3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bfb5					_VSExit:
.bfb5	7a		ply				ply
.bfb6	60		rts				rts
.bfb7					_VSBadType:
.bfb7	4c c5 ad	jmp $adc5			jmp 	TypeError
.bfba					_VSString:
.bfba	a5 24		lda $24				lda 	zVarType 					; type must be $
.bfbc	c9 b7		cmp #$b7			cmp 	#token_Dollar
.bfbe	d0 f7		bne $bfb7			bne 	_VSBadType
.bfc0	da		phx				phx
.bfc1	5a		phy				phy
.bfc2	20 3a bb	jsr $bb3a			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.bfc5	a0 01		ldy #$01			ldy 	#1 							; save high byte
.bfc7	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bfc9	88		dey				dey 								; save low byte
.bfca	8a		txa				txa
.bfcb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bfcd	7a		ply				ply 								; and exit.
.bfce	fa		plx				plx
.bfcf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.bfd0					MulInteger32:
.bfd0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.bfd2	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.bfd4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bfd6	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.bfd8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bfda	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.bfdc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bfde	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.bfe0	a9 00		lda #$00			lda 	#0
.bfe2	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.bfe4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bfe6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bfe8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bfea					_BFMMultiply:
.bfea	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.bfec	29 01		and #$01			and 	#1
.bfee	f0 03		beq $bff3			beq 	_BFMNoAdd
.bff0	20 aa b6	jsr $b6aa			jsr 	AddInteger32
.bff3					_BFMNoAdd:
.bff3	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.bff5	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.bff7	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.bff9	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.bffb	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.bffd	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.bfff	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.c001	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.c003	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c005	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.c007	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.c009	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.c00b	d0 dd		bne $bfea			bne 	_BFMMultiply
.c00d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c00e					DivInteger32:
.c00e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c010	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.c012	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c014	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c016	d0 14		bne $c02c			bne 	_BFDOkay
.c018	20 e4 ad	jsr $ade4			jsr ERR_Handler
>c01b	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>c023	20 62 79 20 5a 65 72 6f 00
.c02c					_BFDOkay:
.c02c	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c02e	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c030	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c032	85 1c		sta $1c				sta 	zLTemp1+2
.c034	85 1d		sta $1d				sta 	zLTemp1+3
.c036	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.c039	20 90 c0	jsr $c090			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c03c	da		phx				phx
.c03d	e8		inx				inx
.c03e	e8		inx				inx
.c03f	e8		inx				inx
.c040	e8		inx				inx
.c041	e8		inx				inx
.c042	e8		inx				inx
.c043	20 90 c0	jsr $c090			jsr 	CheckIntegerNegate
.c046	fa		plx				plx
.c047	5a		phy				phy 								; Y is the counter
.c048	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c04a					_BFDLoop:
.c04a	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c04c	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c04e	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c050	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c052	26 1a		rol $1a				rol 	zLTemp1
.c054	26 1b		rol $1b				rol 	zLTemp1+1
.c056	26 1c		rol $1c				rol 	zLTemp1+2
.c058	26 1d		rol $1d				rol 	zLTemp1+3
.c05a	38		sec				sec
.c05b	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c05d	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c05f	48		pha				pha
.c060	a5 1b		lda $1b				lda 	zLTemp1+1
.c062	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c064	48		pha				pha
.c065	a5 1c		lda $1c				lda 	zLTemp1+2
.c067	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c069	48		pha				pha
.c06a	a5 1d		lda $1d				lda 	zLTemp1+3
.c06c	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c06e	90 13		bcc $c083			bcc 	_BFDNoAdd
.c070	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c072	68		pla				pla
.c073	85 1c		sta $1c				sta 	zLTemp1+2
.c075	68		pla				pla
.c076	85 1b		sta $1b				sta 	zLTemp1+1
.c078	68		pla				pla
.c079	85 1a		sta $1a				sta 	zLTemp1+0
.c07b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c07d	09 01		ora #$01			ora 	#1
.c07f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c081	80 03		bra $c086			bra 	_BFDNext
.c083					_BFDNoAdd:
.c083	68		pla				pla 								; Throw away the intermediate calculations
.c084	68		pla				pla
.c085	68		pla				pla
.c086					_BFDNext:
.c086	88		dey				dey
.c087	d0 c1		bne $c04a			bne 	_BFDLoop
.c089	7a		ply				ply 								; restore Y and exit
.c08a	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.c08d	b0 06		bcs $c095			bcs		IntegerNegateAlways 			; negate the result
.c08f	60		rts				rts
.c090					CheckIntegerNegate:
.c090	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c092	30 01		bmi $c095			bmi 	IntegerNegateAlways
.c094	60		rts				rts
.c095					IntegerNegateAlways:
.c095	ee 9e 03	inc $039e			inc 	SignCount
.c098	38		sec				sec
.c099	a9 00		lda #$00			lda 	#0
.c09b	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c09d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c09f	a9 00		lda #$00			lda 	#0
.c0a1	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c0a3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c0a5	a9 00		lda #$00			lda 	#0
.c0a7	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c0a9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c0ab	a9 00		lda #$00			lda 	#0
.c0ad	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c0af	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c0b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c0b2					INTToString:
.c0b2	48		pha				pha
.c0b3	5a		phy				phy
.c0b4	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.c0b6	10 08		bpl $c0c0			bpl 		_ITSNotMinus
.c0b8	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c0ba	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter
.c0bd	20 95 c0	jsr $c095			jsr 		IntegerNegateAlways 	; negate the number.
.c0c0					_ITSNotMinus:
.c0c0	a9 00		lda #$00			lda 		#0
.c0c2	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.c0c5	8a		txa				txa 								; use Y for the mantissa index.
.c0c6	a8		tay				tay
.c0c7	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c0c9					_ITSNextSubtractor:
.c0c9	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c0cb	8d 9b 03	sta $039b			sta 		NumConvCount
.c0ce					_ITSSubtract:
.c0ce	38		sec				sec
.c0cf	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c0d2	fd 2c c1	sbc $c12c,x			sbc 		_ITSSubtractors+0,x
.c0d5	48		pha				pha
.c0d6	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.c0d9	fd 2d c1	sbc $c12d,x			sbc 		_ITSSubtractors+1,x
.c0dc	48		pha				pha
.c0dd	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.c0e0	fd 2e c1	sbc $c12e,x			sbc 		_ITSSubtractors+2,x
.c0e3	48		pha				pha
.c0e4	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.c0e7	fd 2f c1	sbc $c12f,x			sbc 		_ITSSubtractors+3,x
.c0ea	90 14		bcc $c100			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c0ec	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c0ef	68		pla				pla
.c0f0	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.c0f3	68		pla				pla
.c0f4	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.c0f7	68		pla				pla
.c0f8	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.c0fb	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.c0fe	80 ce		bra $c0ce			bra 		_ITSSubtract 			; go round again.
.c100					_ITSCantSubtract:
.c100	68		pla				pla 								; throw away interim answers
.c101	68		pla				pla
.c102	68		pla				pla
.c103	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.c106	c9 30		cmp #$30			cmp 		#"0"
.c108	d0 05		bne $c10f			bne 		_ITSOutputDigit
.c10a	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c10d	10 09		bpl $c118			bpl	 		_ITSGoNextSubtractor
.c10f					_ITSOutputDigit:
.c10f	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.c112	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.c115	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter 		; output it.
.c118					_ITSGoNextSubtractor:
.c118	e8		inx				inx 								; next dword
.c119	e8		inx				inx
.c11a	e8		inx				inx
.c11b	e8		inx				inx
.c11c	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c11e	d0 a9		bne $c0c9			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c120	98		tya				tya 								; X is back as the mantissa index
.c121	aa		tax				tax
.c122	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c124	09 30		ora #$30			ora 		#"0"
.c126	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter
.c129	7a		ply				ply 								; and exit
.c12a	68		pla				pla
.c12b	60		rts				rts
.c12c					_ITSSubtractors:
>c12c	00 ca 9a 3b					.dword 		1000000000
>c130	00 e1 f5 05					.dword 		100000000
>c134	80 96 98 00					.dword 		10000000
>c138	40 42 0f 00					.dword 		1000000
>c13c	a0 86 01 00					.dword 		100000
>c140	10 27 00 00					.dword 		10000
>c144	e8 03 00 00					.dword 		1000
>c148	64 00 00 00					.dword 		100
>c14c	0a 00 00 00					.dword 		10
.c150					_ITSSubtractorsEnd:
.c150					ITSOutputCharacter:
.c150	48		pha				pha
.c151	da		phx				phx
.c152	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.c155	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.c158	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c15a	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.c15d	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.c160	fa		plx				plx
.c161	68		pla				pla
.c162	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c163					IntFromString:
.c163	a0 00		ldy #$00			ldy 	#0
.c165	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.c168					IntFromStringY:
.c168	48		pha				pha
.c169	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c16b	95 80		sta $80,x			sta 	XS_Mantissa,x
.c16d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c16f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c171	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c173	a9 01		lda #$01			lda 	#1
.c175	95 85		sta $85,x			sta 	XS_Type,x
.c177					_IFSLoop:
.c177	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c179	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c17b	90 4e		bcc $c1cb			bcc 	_IFSExit
.c17d	c9 3a		cmp #$3a			cmp 	#"9"+1
.c17f	b0 4a		bcs $c1cb			bcs 	_IFSExit
.c181	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c183	c9 0c		cmp #$0c			cmp 	#12
.c185	b0 4e		bcs $c1d5			bcs 	_IFSOverflow
.c187	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c189	48		pha				pha
.c18a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c18c	48		pha				pha
.c18d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c18f	48		pha				pha
.c190	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c192	48		pha				pha
.c193	20 ea c1	jsr $c1ea			jsr 	IFSX1ShiftLeft 				; double
.c196	20 ea c1	jsr $c1ea			jsr 	IFSX1ShiftLeft 				; x 4
.c199	18		clc				clc 								; add saved value x 5
.c19a	68		pla				pla
.c19b	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c19d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c19f	68		pla				pla
.c1a0	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c1a2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c1a4	68		pla				pla
.c1a5	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c1a7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c1a9	68		pla				pla
.c1aa	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c1ac	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c1ae	20 ea c1	jsr $c1ea			jsr 	IFSX1ShiftLeft 				; x 10
.c1b1	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.c1b4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c1b6	29 0f		and #$0f			and 	#15
.c1b8	c8		iny				iny
.c1b9	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c1bb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c1bd	90 b8		bcc $c177			bcc 	_IFSLoop
.c1bf	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c1c1	d0 b4		bne $c177			bne 	_IFSLoop
.c1c3	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c1c5	d0 b0		bne $c177			bne 	_IFSLoop
.c1c7	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c1c9	80 ac		bra $c177			bra 	_IFSLoop
.c1cb					_IFSExit:
.c1cb	98		tya				tya 								; get offset
.c1cc					_IFSOkay:
.c1cc	38		sec				sec
.c1cd	ad 9c 03	lda $039c			lda 	ExpTemp
.c1d0	f0 01		beq $c1d3			beq 	_IFSSkipFail
.c1d2	18		clc				clc
.c1d3					_IFSSkipFail:
.c1d3	68		pla				pla 								; and exit.
.c1d4	60		rts				rts
.c1d5					_IFSOverflow:
.c1d5	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>c1d8	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c1e0	20 6f 76 65 72 66 6c 6f 77 00
.c1ea					IFSX1ShiftLeft:
.c1ea	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c1ec	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c1ee	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c1f0	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c1f2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c1f3					FPSubtract:
.c1f3	48		pha				pha
.c1f4	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c1f6	49 80		eor #$80			eor 	#$80
.c1f8	95 8b		sta $8b,x			sta 	XS2_Type,x
.c1fa	68		pla				pla 								; --- and fall through ---
.c1fb					FPAdd:
.c1fb	48		pha				pha
.c1fc	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c1fe	d0 05		bne $c205			bne 	_FPA_NegativeLHS
.c200	20 1c c2	jsr $c21c			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c203	68		pla				pla
.c204	60		rts				rts
.c205					_FPA_NegativeLHS:
.c205	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c207	49 80		eor #$80			eor 	#$80
.c209	95 85		sta $85,x			sta 	XS_Type,x
.c20b	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c20d	49 80		eor #$80			eor 	#$80
.c20f	95 8b		sta $8b,x			sta 	XS2_Type,x
.c211	20 1c c2	jsr $c21c			jsr 	FPAdd_Worker 				; do the add calculation.
.c214	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c216	49 80		eor #$80			eor 	#$80
.c218	95 85		sta $85,x			sta 	XS_Type,x
.c21a	68		pla				pla
.c21b	60		rts				rts
.c21c					FPAdd_Worker:
.c21c	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c21e	70 07		bvs $c227			bvs 	_FPAWExit 					; no change.
.c220	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c222	50 07		bvc $c22b			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c224	20 5c c4	jsr $c45c			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c227					_FPAWExit:
.c227	20 cb c4	jsr $c4cb			jsr 	FPUNormalise 				; normalise the result.
.c22a	60		rts				rts
.c22b					_FPAWMakeSame:
.c22b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c22d	38		sec				sec
.c22e	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c230	f0 16		beq $c248			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c232	da		phx				phx 								; save X
.c233	90 06		bcc $c23b			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c235	e8		inx				inx
.c236	e8		inx				inx
.c237	e8		inx				inx
.c238	e8		inx				inx
.c239	e8		inx				inx
.c23a	e8		inx				inx
.c23b					_FPAWShiftA:
.c23b	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c23d	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c23f	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c241	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c243	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c245	fa		plx				plx 								; restore original X
.c246	80 e3		bra $c22b			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c248					_FPAW_DoArithmetic:
.c248	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c24a	30 28		bmi $c274			bmi 	_FPAW_BNegative
.c24c	18		clc				clc
.c24d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c24f	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c251	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c253	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c255	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c257	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c259	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c25b	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c25d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c25f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c261	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c263	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c265	90 c0		bcc $c227			bcc 	_FPAWExit 					; no carry.
.c267	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c269	38		sec				sec
.c26a	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c26c	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c26e	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c270	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c272	80 b3		bra $c227			bra 	_FPAWExit
.c274					_FPAW_BNegative:
.c274	38		sec				sec
.c275	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c277	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c279	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c27b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c27d	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c27f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c281	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c283	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c285	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c287	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c289	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c28b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c28d	b0 09		bcs $c298			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c28f	20 82 c4	jsr $c482			jsr 	FPUNegateInteger			; negate the mantissa
.c292	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.c294	49 80		eor #$80			eor 	#$80
.c296	95 85		sta $85,x			sta 	XS_Type,x
.c298					_FPAWGoExit:
.c298	4c 27 c2	jmp $c227			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c29b					FPD_IsDivZero:
.c29b	20 e4 ad	jsr $ade4			jsr ERR_Handler
>c29e	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c2a6	20 62 79 20 7a 65 72 6f 00
.c2af					FPDivide:
.c2af	48		pha				pha
.c2b0	5a		phy				phy
.c2b1	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.c2b3	70 e6		bvs $c29b			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c2b5	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c2b7	f0 03		beq $c2bc			beq 	_FPDCalculateExp
.c2b9					_FPD_Exit:
.c2b9	7a		ply				ply
.c2ba	68		pla				pla
.c2bb	60		rts				rts
.c2bc					_FPDCalculateExp:
.c2bc	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c2be	49 ff		eor #$ff			eor 	#$FF
.c2c0	1a		inc a				inc 	a
.c2c1	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.c2c3	20 93 c3	jsr $c393			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c2c6	18		clc				clc 	 							; add 1 to the resulting exponent
.c2c7	69 01		adc #$01			adc 	#1
.c2c9	b0 54		bcs $c31f			bcs 	_FPD_Overflow 				; which can overflow.
.c2cb	95 84		sta $84,x			sta 	XS_Exponent,x
.c2cd	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c2cf	85 1a		sta $1a				sta 	zLTemp1+0
.c2d1	85 1b		sta $1b				sta 	zLTemp1+1
.c2d3	85 1c		sta $1c				sta 	zLTemp1+2
.c2d5	85 1d		sta $1d				sta 	zLTemp1+3
.c2d7	a0 20		ldy #$20			ldy 	#32 						; times round.
.c2d9					_FPD_Loop:
.c2d9	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c2da	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.c2dc	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.c2de	48		pha				pha
.c2df	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c2e1	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c2e3	48		pha				pha
.c2e4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c2e6	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c2e8	48		pha				pha
.c2e9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c2eb	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c2ed	90 13		bcc $c302			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c2ef	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c2f1	68		pla				pla
.c2f2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c2f4	68		pla				pla
.c2f5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c2f7	68		pla				pla
.c2f8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c2fa	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c2fc	09 80		ora #$80			ora 	#$80
.c2fe	85 1d		sta $1d				sta 	zLTemp1+3
.c300	80 03		bra $c305			bra 	_FPD_Rotates
.c302					_FPD_NoSubtract:
.c302	68		pla				pla 								; throw away unwanted results
.c303	68		pla				pla
.c304	68		pla				pla
.c305					_FPD_Rotates:
.c305	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.c307	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.c309	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.c30b	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.c30d	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c30f	26 1b		rol $1b				rol 	zLTemp1+1
.c311	26 1c		rol $1c				rol 	zLTemp1+2
.c313	26 1d		rol $1d				rol 	zLTemp1+3
.c315	90 02		bcc $c319			bcc 	_FPD_NoCarry
.c317	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c319					_FPD_NoCarry:
.c319	88		dey				dey 								; do 32 times
.c31a	d0 bd		bne $c2d9			bne 	_FPD_Loop
.c31c	4c 77 c3	jmp $c377			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c31f					_FPD_Overflow:
.c31f	4c 28 c5	jmp $c528			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c322					FPMultiply:
.c322	48		pha				pha
.c323	5a		phy				phy
.c324	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c326	70 07		bvs $c32f			bvs 	_FPM_Exit
.c328	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c32a	50 06		bvc $c332			bvc 	_FPM_CalcExponent
.c32c	20 5c c4	jsr $c45c			jsr 	FPUCopyX2ToX1
.c32f					_FPM_Exit:
.c32f	7a		ply				ply
.c330	68		pla				pla
.c331	60		rts				rts
.c332					_FPM_CalcExponent:
.c332	18		clc				clc
.c333	20 93 c3	jsr $c393			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c336	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.c338	a9 00		lda #$00			lda 	#0
.c33a	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c33c	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c33e	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c340	85 1d		sta $1d				sta 	zLTemp1+3
.c342	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c344					_FPM_Loop:
.c344	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.c346	29 01		and #$01			and 	#1
.c348	18		clc				clc 								; clear carry for the long rotate.
.c349	f0 19		beq $c364			beq 	_FPM_NoAddition
.c34b	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c34c	a5 1a		lda $1a				lda 	zLTemp1+0
.c34e	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c350	85 1a		sta $1a				sta 	zLTemp1+0
.c352	a5 1b		lda $1b				lda 	zLTemp1+1
.c354	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c356	85 1b		sta $1b				sta 	zLTemp1+1
.c358	a5 1c		lda $1c				lda 	zLTemp1+2
.c35a	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c35c	85 1c		sta $1c				sta 	zLTemp1+2
.c35e	a5 1d		lda $1d				lda 	zLTemp1+3
.c360	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c362	85 1d		sta $1d				sta 	zLTemp1+3
.c364					_FPM_NoAddition:
.c364	66 1d		ror $1d				ror 	3+zLTemp1
.c366	66 1c		ror $1c				ror 	2+zLTemp1
.c368	66 1b		ror $1b				ror 	1+zLTemp1
.c36a	66 1a		ror $1a				ror 	0+zLTemp1
.c36c	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c36e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c370	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c372	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c374	88		dey				dey
.c375	d0 cd		bne $c344			bne 	_FPM_Loop 					; do this 32 times.
.c377					FPM_CopySignNormalize:
.c377	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c379	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c37b	a5 1b		lda $1b				lda 	zLTemp1+1
.c37d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c37f	a5 1c		lda $1c				lda 	zLTemp1+2
.c381	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c383	a5 1d		lda $1d				lda 	zLTemp1+3
.c385	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c387	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.c389	55 8b		eor $8b,x			eor 	XS2_Type,x
.c38b	95 85		sta $85,x			sta 	XS_Type,x
.c38d	20 cb c4	jsr $c4cb			jsr 	FPUNormalise 				; normalise and exit.
.c390	7a		ply				ply
.c391	68		pla				pla
.c392	60		rts				rts
.c393					FPCalculateExponent:
.c393	18		clc				clc
.c394	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c396	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.c398	b0 08		bcs $c3a2			bcs 	_FPCECarry 					; carry out ?
.c39a	10 03		bpl $c39f			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c39c	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c39e	60		rts				rts
.c39f					_FPCEExpZero:
.c39f	a9 00		lda #$00			lda 	#0
.c3a1	60		rts				rts
.c3a2					_FPCECarry:
.c3a2	30 03		bmi $c3a7			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c3a4	09 80		ora #$80			ora 	#$80 						; put in right range
.c3a6	60		rts				rts
.c3a7					_FPCEOverflow:
.c3a7	4c 28 c5	jmp $c528			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c3aa					FPFractionalPart:
.c3aa	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c3ac	38		sec				sec 								; this flag tells us to keep the fractional part
.c3ad	30 0d		bmi $c3bc			bmi 	FPGetPart
.c3af	60		rts				rts
.c3b0					FPIntegerPart:
.c3b0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c3b2	18		clc				clc 								; this flag says keep the integer part.
.c3b3	30 07		bmi $c3bc			bmi 	FPGetPart 					; -ve exponents are 0..127
.c3b5	48		pha				pha
.c3b6	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c3b8	95 85		sta $85,x			sta 	XS_Type,x
.c3ba	68		pla				pla
.c3bb	60		rts				rts
.c3bc					FPGetPart:
.c3bc	48		pha				pha
.c3bd	5a		phy				phy 								; save Y
.c3be	08		php				php 								; save action
.c3bf	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c3c1	70 59		bvs $c41c			bvs 	_FPGP_Exit 					; then do nothing.
.c3c3	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c3c5	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c3c7	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c3c9	85 1c		sta $1c				sta 	zLTemp1+2
.c3cb	85 1d		sta $1d				sta 	zLTemp1+3
.c3cd	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.c3cf	38		sec				sec
.c3d0	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c3d2	f0 12		beq $c3e6			beq 	_FPGP_NoShift 				; ... if any
.c3d4	c9 20		cmp #$20			cmp 	#32
.c3d6	90 02		bcc $c3da			bcc 	_FPGP_NotMax
.c3d8	a9 20		lda #$20			lda 	#32 						; max of 32.
.c3da					_FPGP_NotMax:
.c3da	a8		tay				tay 								; Y is the mask shift count.
.c3db					_FPGP_ShiftMask:
.c3db	46 1d		lsr $1d				lsr 	3+zLTemp1
.c3dd	66 1c		ror $1c				ror 	2+zLTemp1
.c3df	66 1b		ror $1b				ror 	1+zLTemp1
.c3e1	66 1a		ror $1a				ror 	0+zLTemp1
.c3e3	88		dey				dey
.c3e4	d0 f5		bne $c3db			bne 	_FPGP_ShiftMask
.c3e6					_FPGP_NoShift:
.c3e6	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c3e8	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.c3eb					_FPGP_MaskLoop:
.c3eb	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c3ee	28		plp				plp 								; if CC we keep the top part, so we
.c3ef	08		php				php		 							; flip the mask.
.c3f0	b0 02		bcs $c3f4			bcs		_FPGP_NoFlip
.c3f2	49 ff		eor #$ff			eor 	#$FF
.c3f4					_FPGP_NoFlip:
.c3f4	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c3f6	95 80		sta $80,x			sta 	XS_Mantissa,x
.c3f8	e8		inx				inx
.c3f9	c8		iny				iny
.c3fa	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c3fc	d0 ed		bne $c3eb			bne 	_FPGP_MaskLoop
.c3fe	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.c401	28		plp				plp
.c402	08		php				php 								; get action flag on the stack
.c403	90 04		bcc $c409			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c405	a9 00		lda #$00			lda 	#0
.c407	95 85		sta $85,x			sta 	XS_Type,x
.c409					_FPGP_NotFractional:
.c409	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c40b	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c40d	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c40f	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c411	f0 05		beq $c418			beq 	_FPGP_Zero 					; if zero, return zero
.c413	20 cb c4	jsr $c4cb			jsr 	FPUNormalise
.c416	80 04		bra $c41c			bra 	_FPGP_Exit 					; and exit
.c418					_FPGP_Zero:
.c418	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c41a	95 85		sta $85,x			sta 	XS_Type,x
.c41c					_FPGP_Exit:
.c41c	68		pla				pla 								; throw saved action flag.
.c41d	7a		ply				ply
.c41e	68		pla				pla
.c41f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c420					FPCompare:
.c420	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c422	48		pha				pha
.c423	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.c425	48		pha				pha
.c426	20 f3 c1	jsr $c1f3			jsr 	FPSubtract 					; calculate X1-X2
.c429	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c42b	70 2a		bvs $c457			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c42d	68		pla				pla
.c42e	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.c431	68		pla				pla
.c432	38		sec				sec
.c433	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.c436	70 14		bvs $c44c			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c438	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c439	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c43b	b0 0f		bcs $c44c			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c43d	38		sec				sec
.c43e	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.c441	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c443	b0 02		bcs $c447			bcs 	_FPCNotRange 				; keep in range.
.c445	a9 01		lda #$01			lda 	#1
.c447					_FPCNotRange:
.c447	38		sec				sec
.c448	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c44a	b0 0d		bcs $c459			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c44c					_FPCNotEqual:
.c44c	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c44e	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c450	f0 02		beq $c454			beq 	_FPCNE2
.c452	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c454	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c455	80 04		bra $c45b			bra 	_FPCExit
.c457					_FPCPullZero:
.c457	68		pla				pla 								; throw saved exponents
.c458	68		pla				pla
.c459					_FPCZero:
.c459	a9 00		lda #$00			lda 	#0 							; and return zero
.c45b					_FPCExit:
.c45b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c45c					FPUCopyX2ToX1:
.c45c	48		pha				pha
.c45d	da		phx				phx
.c45e	5a		phy				phy
.c45f	a0 08		ldy #$08			ldy 	#8
.c461	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.c463	95 80		sta $80,x			sta 	XS_Mantissa,x
.c465	e8		inx				inx
.c466	88		dey				dey
.c467	10 f8		bpl $c461			bpl 	_FPUC21
.c469	7a		ply				ply
.c46a	fa		plx				plx
.c46b	68		pla				pla
.c46c	60		rts				rts
.c46d					FPUSetInteger:
.c46d	48		pha				pha
.c46e	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c470	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c472	10 02		bpl $c476			bpl 	_FPUSIExtend
.c474	a9 ff		lda #$ff			lda 	#$FF
.c476					_FPUSIExtend:
.c476	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c478	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c47a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c47c	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c47e	95 85		sta $85,x			sta 	XS_Type,x
.c480	68		pla				pla
.c481	60		rts				rts
.c482					FPUNegateInteger:
.c482	48		pha				pha
.c483	38		sec				sec
.c484	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c486	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c488	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c48a	a9 00		lda #$00			lda 	#0
.c48c	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c48e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c490	a9 00		lda #$00			lda 	#0
.c492	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c494	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c496	a9 00		lda #$00			lda 	#0
.c498	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c49a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c49c	68		pla				pla
.c49d	60		rts				rts
.c49e					FPUToFloat:
.c49e	48		pha				pha
.c49f	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.c4a1	29 0f		and #$0f			and 	#$0F
.c4a3	f0 24		beq $c4c9			beq 	_FPUFExit
.c4a5	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c4a7	95 85		sta $85,x			sta 	XS_Type,x
.c4a9	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c4ab	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.c4ad	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c4af	10 07		bpl $c4b8			bpl		_FPUFPositive
.c4b1	20 82 c4	jsr $c482			jsr 	FPUNegateInteger 			; negate the mantissa
.c4b4	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c4b6	95 85		sta $85,x			sta 	XS_Type,x
.c4b8					_FPUFPositive:
.c4b8	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c4ba	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c4bc	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c4be	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c4c0	d0 04		bne $c4c6			bne 	_FPUFNonZero
.c4c2	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c4c4	95 85		sta $85,x			sta 	XS_Type,x
.c4c6					_FPUFNonZero:
.c4c6	20 cb c4	jsr $c4cb			jsr 	FPUNormalise 				; normalise the floating point.
.c4c9					_FPUFExit:
.c4c9	68		pla				pla
.c4ca	60		rts				rts
.c4cb					FPUNormalise:
.c4cb	48		pha				pha
.c4cc	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c4ce	70 18		bvs $c4e8			bvs 	_FPUNExit
.c4d0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c4d2	f0 10		beq $c4e4			beq 	_FPUNSetZero
.c4d4					_FPUNLoop:
.c4d4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c4d6	30 10		bmi $c4e8			bmi 	_FPUNExit 					; if so, we are normalised.
.c4d8	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.c4da	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.c4dc	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.c4de	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.c4e0	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.c4e2	d0 f0		bne $c4d4			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c4e4					_FPUNSetZero:
.c4e4	a9 40		lda #$40			lda 	#$40
.c4e6	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.c4e8					_FPUNExit:
.c4e8	68		pla				pla
.c4e9	60		rts				rts
.c4ea					FPUToInteger:
.c4ea	48		pha				pha
.c4eb	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.c4ed	29 01		and #$01			and 	#1
.c4ef	d0 31		bne $c522			bne 	_FPUTOI_Exit
.c4f1	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.c4f3	70 23		bvs $c518			bvs 	_FPUTOI_Zero
.c4f5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c4f7	10 1f		bpl $c518			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c4f9	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c4fb	b0 2b		bcs $c528			bcs 	FP_Overflow
.c4fd					_FPUToIToInteger:
.c4fd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c4ff	c9 a0		cmp #$a0			cmp 	#128+32
.c501	f0 0c		beq $c50f			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c503	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.c505	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c507	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c509	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c50b	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c50d	80 ee		bra $c4fd			bra 	_FPUToIToInteger 			; keep going.
.c50f					_FPUToICheckSign:
.c50f	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.c511	10 0f		bpl $c522			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c513	20 82 c4	jsr $c482			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c516	80 0a		bra $c522			bra 	_FPUTOI_Exit
.c518					_FPUTOI_Zero:
.c518	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c51a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c51c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c51e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c520	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c522					_FPUToI_Exit:
.c522	a9 01		lda #$01			lda 	#1 							; set type to integer
.c524	95 85		sta $85,x			sta 	XS_Type,x
.c526	68		pla				pla
.c527	60		rts				rts
.c528					FP_Overflow:
.c528	20 e4 ad	jsr $ade4			jsr ERR_Handler
>c52b	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c533	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c543					FPUTimes10:
.c543	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c545	85 1a		sta $1a				sta 	ZLTemp1+0
.c547	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c549	85 1b		sta $1b				sta 	ZLTemp1+1
.c54b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c54d	85 1c		sta $1c				sta 	ZLTemp1+2
.c54f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c551	85 1d		sta $1d				sta 	ZLTemp1+3
.c553	20 88 c5	jsr $c588			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c556	20 88 c5	jsr $c588			jsr 	_FPUT_LSR_ZLTemp1
.c559	18		clc				clc
.c55a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c55c	65 1a		adc $1a				adc 	ZLTemp1+0
.c55e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c560	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c562	65 1b		adc $1b				adc 	ZLTemp1+1
.c564	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c566	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c568	65 1c		adc $1c				adc 	ZLTemp1+2
.c56a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c56c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c56e	65 1d		adc $1d				adc 	ZLTemp1+3
.c570	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c572	90 0a		bcc $c57e			bcc 	_FPUTimes10
.c574	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c576	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c578	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c57a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c57c	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.c57e					_FPUTimes10:
.c57e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c580	18		clc				clc
.c581	69 03		adc #$03			adc 	#3
.c583	95 84		sta $84,x			sta 	XS_Exponent,x
.c585	b0 a1		bcs $c528			bcs 	FP_Overflow 				; error
.c587	60		rts				rts
.c588					_FPUT_LSR_ZLTemp1:
.c588	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c58a	66 1c		ror $1c				ror 	ZLTemp1+2
.c58c	66 1b		ror $1b				ror 	ZLTemp1+1
.c58e	66 1a		ror $1a				ror 	ZLTemp1+0
.c590	60		rts				rts
.c591					FPUScale10A:
.c591	5a		phy				phy
.c592	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c594	f0 37		beq $c5cd			beq 	_FPUScaleExit
.c596	da		phx				phx 								; save X
.c597	e8		inx				inx
.c598	e8		inx				inx
.c599	e8		inx				inx
.c59a	e8		inx				inx
.c59b	e8		inx				inx
.c59c	e8		inx				inx
.c59d	a8		tay				tay 								; save power scalar in Y.
.c59e	a9 00		lda #$00			lda 	#0
.c5a0	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c5a2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c5a4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c5a6	95 85		sta $85,x			sta 	XS_Type,x
.c5a8	a9 80		lda #$80			lda 	#$80
.c5aa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c5ac	a9 81		lda #$81			lda 	#$81
.c5ae	95 84		sta $84,x			sta 	XS_Exponent,x
.c5b0	5a		phy				phy 								; save 10^n on stack.
.c5b1	c0 00		cpy #$00			cpy 	#0
.c5b3	10 05		bpl $c5ba			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c5b5	98		tya				tya
.c5b6	49 ff		eor #$ff			eor 	#$FF
.c5b8	1a		inc a				inc 	a
.c5b9	a8		tay				tay
.c5ba					_FPUSAbs:
.c5ba	20 43 c5	jsr $c543			jsr 	FPUTimes10
.c5bd	88		dey				dey
.c5be	d0 fa		bne $c5ba			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c5c0	68		pla				pla 								; restore count in A
.c5c1	fa		plx				plx 								; restore X pointing to number to scale.
.c5c2	0a		asl a				asl 	a
.c5c3	b0 05		bcs $c5ca			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c5c5	20 22 c3	jsr $c322			jsr 	FPMultiply 					; if clear multiply.
.c5c8	80 03		bra $c5cd			bra		_FPUScaleExit
.c5ca					_FPUSDivide:
.c5ca	20 af c2	jsr $c2af			jsr 	FPDivide
.c5cd					_FPUScaleExit:
.c5cd	7a		ply				ply
.c5ce	60		rts				rts
.c5cf					FPUCopyToNext:
.c5cf	a0 06		ldy #$06			ldy 		#6
.c5d1	da		phx				phx
.c5d2					_FPUCopy1:
.c5d2	b5 80		lda $80,x			lda 	XS_Mantissa,x
.c5d4	95 86		sta $86,x			sta 	XS2_Mantissa,x
.c5d6	e8		inx				inx
.c5d7	88		dey				dey
.c5d8	d0 f8		bne $c5d2			bne 	_FPUCopy1
.c5da	fa		plx				plx
.c5db	60		rts				rts
.c5dc					FPUCopyFromNext:
.c5dc	a0 06		ldy #$06			ldy 		#6
.c5de	da		phx				phx
.c5df					_FPUCopy1:
.c5df	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.c5e1	95 80		sta $80,x			sta 	XS_Mantissa,x
.c5e3	e8		inx				inx
.c5e4	88		dey				dey
.c5e5	d0 f8		bne $c5df			bne 	_FPUCopy1
.c5e7	fa		plx				plx
.c5e8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c5e9					FPToString:
.c5e9	48		pha				pha
.c5ea	5a		phy				phy
.c5eb	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.c5ed	50 0a		bvc $c5f9			bvc 		_FPTSIsFloat 			; if zero,
.c5ef					_FPTSZero:
.c5ef	a9 30		lda #$30			lda 		#"0"
.c5f1	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter
.c5f4					_FPTSExit:
.c5f4	7a		ply				ply
.c5f5	68		pla				pla
.c5f6	60		rts				rts
.c5f7	80 fb		bra $c5f4			bra 		_FPTSExit
.c5f9					_FPTSIsFloat:
.c5f9	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.c5fb	10 09		bpl $c606			bpl 		_FPTSNotSigned
.c5fd	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c5ff	95 85		sta $85,x			sta 		XS_Type,x
.c601	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c603	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter
.c606					_FPTSNotSigned:
.c606	b5 84		lda $84,x			lda 		XS_Exponent,x
.c608	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c60a	b0 09		bcs $c615			bcs 		_FPTSExponent
.c60c	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c60e	90 05		bcc $c615			bcc 		_FPTSExponent 			;
.c610					_FPTSStandard:
.c610	20 54 c6	jsr $c654			jsr 		FPTOutputBody 			; output the body.
.c613	80 df		bra $c5f4			bra 		_FPTSExit
.c615					_FPTSExponent:
.c615	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c617	8d 9d 03	sta $039d			sta 		ExpCount
.c61a					_FPTSExponentLoop:
.c61a	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c61c	10 0e		bpl $c62c			bpl 		_FPTSTimes
.c61e	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c620	90 14		bcc $c636			bcc 		_FPTSScaledToExp
.c622	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c624	20 91 c5	jsr $c591			jsr 		FPUScale10A
.c627	ee 9d 03	inc $039d			inc 		ExpCount
.c62a	80 ee		bra $c61a			bra 		_FPTSExponentLoop
.c62c					_FPTSTimes:
.c62c	a9 01		lda #$01			lda 		#1
.c62e	20 91 c5	jsr $c591			jsr 		FPUScale10A
.c631	ce 9d 03	dec $039d			dec 		ExpCount
.c634	80 e4		bra $c61a			bra 		_FPTSExponentLoop
.c636					_FPTSScaledToExp:
.c636	20 54 c6	jsr $c654			jsr 		FPTOutputBody 			; output the body.
.c639	a9 65		lda #$65			lda 		#"e"					; output E
.c63b	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter
.c63e	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.c641	95 80		sta $80,x			sta 		XS_Mantissa,x
.c643	29 80		and #$80			and 		#$80 					; sign extend it
.c645	f0 02		beq $c649			beq 		_FPTSSExt
.c647	a9 ff		lda #$ff			lda 		#$FF
.c649					_FPTSSExt:
.c649	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.c64b	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.c64d	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.c64f	20 b2 c0	jsr $c0b2			jsr 		INTToString 			; output the exponent.
.c652	80 a0		bra $c5f4			bra			_FPTSExit 				; and exit.
.c654					FPTOutputBody:
.c654	20 cf c5	jsr $c5cf			jsr 		FPUCopyToNext 			; copy to next slot.
.c657	20 ea c4	jsr $c4ea			jsr 		FPUToInteger 			; convert to an integer
.c65a	20 b2 c0	jsr $c0b2			jsr 		INTToString 			; output the main integer part.
.c65d	20 dc c5	jsr $c5dc			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c660	20 aa c3	jsr $c3aa			jsr 		FPFractionalPart 		; get the decimal part.
.c663	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.c665	70 3c		bvs $c6a3			bvs 		_FPTOExit 				; if not, exit now.
.c667	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c669	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter
.c66c					_FPOutLoop:
.c66c	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.c66e	70 1d		bvs $c68d			bvs 		_FPStripZeros 			; strip trailing zeros
.c670	20 43 c5	jsr $c543			jsr 		FPUTimes10 				; multiply by 10
.c673	20 cf c5	jsr $c5cf			jsr 		FPUCopyToNext			; copy to next slot.
.c676	20 ea c4	jsr $c4ea			jsr 		FPUToInteger 			; convert to integer
.c679	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.c67b	09 30		ora #$30			ora 		#"0"
.c67d	20 50 c1	jsr $c150			jsr 		ITSOutputCharacter
.c680	20 dc c5	jsr $c5dc			jsr 		FPUCopyFromNext 		; get it back
.c683	20 aa c3	jsr $c3aa			jsr 		FPFractionalPart 		; get fractional part
.c686	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.c689	c9 0b		cmp #$0b			cmp 	 	#11
.c68b	90 df		bcc $c66c			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c68d					_FPStripZeros:
.c68d	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.c690					_FPStripLoop:
.c690	88		dey				dey 								; back one, if at start then no strip
.c691	f0 10		beq $c6a3			beq 		_FPToExit
.c693	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.c696	c9 30		cmp #$30			cmp 		#"0"
.c698	f0 f6		beq $c690			beq 		_FPStripLoop
.c69a	c8		iny				iny
.c69b	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c69d	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.c6a0	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.c6a3					_FPTOExit:
.c6a3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c6a4					FPFromString:
.c6a4	48		pha				pha 								; push A
.c6a5	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c6a7	c9 2e		cmp #$2e			cmp 	#"."
.c6a9	f0 03		beq $c6ae			beq	 	_FPFIsDecimal
.c6ab	4c 0a c7	jmp $c70a			jmp 	_FPFNotDecimal
.c6ae					_FPFIsDecimal:
.c6ae	c8		iny				iny 								; consume the decimal.
.c6af	20 9e c4	jsr $c49e			jsr 	FPUToFloat 					; convert the integer to float.
.c6b2	da		phx				phx 								; save X.
.c6b3	5a		phy				phy 								; save decimal start position
.c6b4	e8		inx				inx
.c6b5	e8		inx				inx
.c6b6	e8		inx				inx
.c6b7	e8		inx				inx
.c6b8	e8		inx				inx
.c6b9	e8		inx				inx
.c6ba	20 68 c1	jsr $c168			jsr 	INTFromStringY 				; get the part after the DP.
.c6bd	20 9e c4	jsr $c49e			jsr 	FPUToFloat 					; convert that to a float.
.c6c0	68		pla				pla 								; calculate - chars consumed.
.c6c1	8c 9c 03	sty $039c			sty 	ExpTemp
.c6c4	38		sec				sec
.c6c5	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.c6c8	20 91 c5	jsr $c591			jsr 	FPUScale10A 				; scale it by 10^AC
.c6cb	fa		plx				plx 								; restore original X
.c6cc	20 fb c1	jsr $c1fb			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c6cf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c6d1	c9 45		cmp #$45			cmp 	#"E"
.c6d3	f0 04		beq $c6d9			beq 	_FPFExponent
.c6d5	c9 65		cmp #$65			cmp 	#"e"
.c6d7	d0 31		bne $c70a			bne 	_FPFNotDecimal 				; no, then exit normally.
.c6d9					_FPFExponent:
.c6d9	c8		iny				iny 								; skip over E symbol.
.c6da	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c6dc	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c6de	d0 01		bne $c6e1			bne 	_FPFGotSign
.c6e0	c8		iny				iny 								; if it was - skip over it.
.c6e1					_FPFGotSign:
.c6e1	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c6e2	da		phx				phx
.c6e3	e8		inx				inx
.c6e4	e8		inx				inx
.c6e5	e8		inx				inx
.c6e6	e8		inx				inx
.c6e7	e8		inx				inx
.c6e8	e8		inx				inx
.c6e9	20 68 c1	jsr $c168			jsr 	INTFromStringY 				; get the exponent
.c6ec	fa		plx				plx 								; restore X.
.c6ed	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c6ef	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c6f1	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c6f3	d0 17		bne $c70c			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c6f5	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c6f7	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c6f9	b0 11		bcs $c70c			bcs 	_FPFXOverflow
.c6fb	68		pla				pla 								; get direction
.c6fc	d0 07		bne $c705			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c6fe	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c700	49 ff		eor #$ff			eor 	#$FF
.c702	1a		inc a				inc 	a
.c703	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.c705					_FPFXScale:
.c705	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c707	20 91 c5	jsr $c591			jsr 	FPUScale10A 				; scale by the exponent.
.c70a					_FPFNotDecimal:
.c70a	68		pla				pla
.c70b	60		rts				rts
.c70c					_FPFXOverflow:
.c70c	20 e4 ad	jsr $ade4			jsr 	ERR_Handler
>c70f	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c717	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c71e					Unary_Rnd:
.c71e	20 fe b4	jsr $b4fe			jsr 	EvaluateNumberX 			; get value
.c721	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; check right bracket.
.c724	20 7c b7	jsr $b77c			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c727	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c729	30 10		bmi $c73b			bmi 	_URSetSeed
.c72b	f0 28		beq $c755			beq 	_URMakeRandom 				; if zero return same number.
.c72d	da		phx				phx
.c72e	a2 00		ldx #$00			ldx 	#0
.c730	20 8c c7	jsr $c78c			jsr 	Random16
.c733	a2 02		ldx #$02			ldx 	#2
.c735	20 8c c7	jsr $c78c			jsr 	Random16
.c738	fa		plx				plx
.c739	80 1a		bra $c755			bra 	_URMakeRandom
.c73b					_URSetSeed:
.c73b	20 9e c4	jsr $c49e			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c73e	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c740	8d a3 03	sta $03a3			sta 	RandomSeed+0
.c743	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.c745	8d a4 03	sta $03a4			sta 	RandomSeed+1
.c748	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.c74a	8d a5 03	sta $03a5			sta 	RandomSeed+2
.c74d	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.c74f	0a		asl a				asl 	a
.c750	49 db		eor #$db			eor 	#$DB
.c752	8d a6 03	sta $03a6			sta 	RandomSeed+3
.c755					_URMakeRandom:
.c755	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.c758	0d a4 03	ora $03a4			ora 	RandomSeed+1
.c75b	0d a5 03	ora $03a5			ora 	RandomSeed+2
.c75e	0d a6 03	ora $03a6			ora 	RandomSeed+3
.c761	d0 0a		bne $c76d			bne 	_URNotZero
.c763	a9 47		lda #$47			lda 	#$47
.c765	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.c768	a9 3d		lda #$3d			lda 	#$3D
.c76a	8d a6 03	sta $03a6			sta 	RandomSeed+3
.c76d					_URNotZero:
.c76d	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.c770	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c772	ad a4 03	lda $03a4			lda 	RandomSeed+1
.c775	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c777	ad a5 03	lda $03a5			lda 	RandomSeed+2
.c77a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c77c	ad a6 03	lda $03a6			lda 	RandomSeed+3
.c77f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c781	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c783	95 85		sta $85,x			sta 	XS_Type,x
.c785	a9 80		lda #$80			lda 	#$80
.c787	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c789	4c cb c4	jmp $c4cb			jmp 	FPUNormalise
.c78c					Random16:
.c78c	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.c78f	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.c792	90 08		bcc $c79c			bcc 	_R16_NoXor
.c794	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c797	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c799	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.c79c					_R16_NoXor:
.c79c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c79d					Unary_Int:
.c79d	20 fe b4	jsr $b4fe			jsr 	EvaluateNumberX 			; get value
.c7a0	20 28 bb	jsr $bb28			jsr 	CheckNextRParen 			; check right bracket.
.c7a3	4c ea c4	jmp $c4ea			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c7a6	80 fe		bra $c7a6	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
