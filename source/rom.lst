
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 22 18:12:10 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					RandomSeed:	.dword ? 						; Random seed.
>042c					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042e					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0430					Tim_SR:		.byte ? 						; Processor Status
>0431					Tim_A:		.byte ? 						; Processor Registers
>0432					Tim_X:		.byte ?
>0433					Tim_Y:		.byte ?
>0434					Tim_Z:		.byte ?
>0435					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	18 0a 00 d9 fe 03 3c 8a			.byte	$18,$0a,$00,$d9,$fe,$03,$3c,$8a
>1008	b4 41 41 bc 8a fe 03 3e			.byte	$b4,$41,$41,$bc,$8a,$fe,$03,$3e
>1010	be ff 06 68 69 20 21 00			.byte	$be,$ff,$06,$68,$69,$20,$21,$00
>1018	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.c000					VectorTable:
>c000	dc c5					.word BinaryOp_And         ; $80 and
>c002	04 c6					.word BinaryOp_Or          ; $81 or
>c004	2c c6					.word BinaryOp_Xor         ; $82 xor
>c006	2c c6					.word BinaryOp_Eor         ; $83 eor
>c008	6f c6					.word Binary_Equal         ; $84 =
>c00a	8e c6					.word Binary_NotEqual      ; $85 <>
>c00c	97 c6					.word Binary_Less          ; $86 <
>c00e	a0 c6					.word Binary_LessEqual     ; $87 <=
>c010	b2 c6					.word Binary_Greater       ; $88 >
>c012	a9 c6					.word Binary_GreaterEqual  ; $89 >=
>c014	47 c7					.word BinaryOp_Add         ; $8a +
>c016	67 c7					.word BinaryOp_Subtract    ; $8b -
>c018	7a c7					.word BinaryOp_Multiply    ; $8c *
>c01a	8d c7					.word BinaryOp_Divide      ; $8d /
>c01c	b2 c0					.word NotImplemented       ; $8e ^
>c01e	b2 c0					.word NotImplemented       ; $8f if
>c020	b2 c0					.word NotImplemented       ; $90 while
>c022	b2 c0					.word NotImplemented       ; $91 repeat
>c024	b2 c0					.word NotImplemented       ; $92 for
>c026	b2 c0					.word NotImplemented       ; $93 then
>c028	b2 c0					.word NotImplemented       ; $94 endif
>c02a	b2 c0					.word NotImplemented       ; $95 wend
>c02c	b2 c0					.word NotImplemented       ; $96 until
>c02e	b2 c0					.word NotImplemented       ; $97 next
>c030	b2 c0					.word NotImplemented       ; $98 not
>c032	b2 c0					.word NotImplemented       ; $99 fn(
>c034	af c8					.word Unary_Abs            ; $9a abs(
>c036	cd c8					.word Unary_Asc            ; $9b asc(
>c038	81 d2					.word Unary_Int            ; $9c int(
>c03a	b2 c0					.word NotImplemented       ; $9d peek(
>c03c	f8 d1					.word Unary_Rnd            ; $9e rnd(
>c03e	b2 c0					.word NotImplemented       ; $9f usr(
>c040	b2 c0					.word NotImplemented       ; $a0 left$(
>c042	b2 c0					.word NotImplemented       ; $a1 right$(
>c044	b2 c0					.word NotImplemented       ; $a2 mid$(
>c046	16 c9					.word Unary_Spc            ; $a3 spc(
>c048	b2 c0					.word NotImplemented       ; $a4 str$(
>c04a	b2 c0					.word NotImplemented       ; $a5 val(
>c04c	e3 c8					.word Unary_Len            ; $a6 len(
>c04e	b2 c0					.word NotImplemented       ; $a7 hex$(
>c050	b2 c0					.word NotImplemented       ; $a8 sin(
>c052	b2 c0					.word NotImplemented       ; $a9 cos(
>c054	b2 c0					.word NotImplemented       ; $aa tan(
>c056	b2 c0					.word NotImplemented       ; $ab atn(
>c058	b2 c0					.word NotImplemented       ; $ac exp(
>c05a	b2 c0					.word NotImplemented       ; $ad log(
>c05c	b2 c0					.word NotImplemented       ; $ae sqr(
>c05e	b2 c0					.word NotImplemented       ; $af dec(
>c060	b2 c0					.word NotImplemented       ; $b0 deek(
>c062	b2 c0					.word NotImplemented       ; $b1 leek(
>c064	b2 c0					.word NotImplemented       ; $b2 mod(
>c066	5d c8					.word Unary_Sgn            ; $b3 sgn(
>c068	f2 c8					.word Unary_Chr            ; $b4 chr$(
>c06a	b2 c0					.word NotImplemented       ; $b5 $(
>c06c	b2 c0					.word NotImplemented       ; $b6 $
>c06e	b2 c0					.word NotImplemented       ; $b7 #(
>c070	b2 c0					.word NotImplemented       ; $b8 #
>c072	b2 c0					.word NotImplemented       ; $b9 %(
>c074	b2 c0					.word NotImplemented       ; $ba %
>c076	b2 c0					.word NotImplemented       ; $bb (
>c078	b2 c0					.word NotImplemented       ; $bc )
>c07a	b2 c0					.word NotImplemented       ; $bd ,
>c07c	b2 c0					.word NotImplemented       ; $be :
>c07e	b2 c0					.word NotImplemented       ; $bf ;
>c080	b2 c0					.word NotImplemented       ; $c0 def
>c082	18 c4					.word CLR_Command          ; $c1 clr
>c084	b2 c0					.word NotImplemented       ; $c3 data
>c086	b2 c0					.word NotImplemented       ; $c4 read
>c088	b2 c0					.word NotImplemented       ; $c5 dim
>c08a	b2 c0					.word NotImplemented       ; $c6 to
>c08c	b2 c0					.word NotImplemented       ; $c7 step
>c08e	b2 c0					.word NotImplemented       ; $c8 gosub
>c090	b2 c0					.word NotImplemented       ; $c9 return
>c092	b2 c0					.word NotImplemented       ; $ca goto
>c094	b2 c0					.word NotImplemented       ; $cb input
>c096	b2 c0					.word NotImplemented       ; $cc let
>c098	b2 c0					.word NotImplemented       ; $cd list
>c09a	b2 c0					.word NotImplemented       ; $ce new
>c09c	b2 c0					.word NotImplemented       ; $cf old
>c09e	b2 c0					.word NotImplemented       ; $d0 on
>c0a0	b2 c0					.word NotImplemented       ; $d1 restore
>c0a2	b2 c0					.word NotImplemented       ; $d2 poke
>c0a4	b2 c0					.word NotImplemented       ; $d3 print
>c0a6	b2 c0					.word NotImplemented       ; $d4 run
>c0a8	b2 c0					.word NotImplemented       ; $d5 stop
>c0aa	b2 c0					.word NotImplemented       ; $d6 wait
>c0ac	b2 c0					.word NotImplemented       ; $d7 doke
>c0ae	b2 c0					.word NotImplemented       ; $d8 loke
>c0b0	b2 c0					.word NotImplemented       ; $d9 assert
.c0b2					NotImplemented:
.c0b2	80 fe		bra $c0b2		_error: bra _error
.c0b4					BinaryPrecedence:
>c0b4	01					.byte 1    ; $80 and
>c0b5	01					.byte 1    ; $81 or
>c0b6	01					.byte 1    ; $82 xor
>c0b7	01					.byte 1    ; $83 eor
>c0b8	02					.byte 2    ; $84 =
>c0b9	02					.byte 2    ; $85 <>
>c0ba	02					.byte 2    ; $86 <
>c0bb	02					.byte 2    ; $87 <=
>c0bc	02					.byte 2    ; $88 >
>c0bd	02					.byte 2    ; $89 >=
>c0be	03					.byte 3    ; $8a +
>c0bf	03					.byte 3    ; $8b -
>c0c0	04					.byte 4    ; $8c *
>c0c1	04					.byte 4    ; $8d /
>c0c2	05					.byte 5    ; $8e ^
.c0c3					KeywordText:
>c0c3	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0c6	4f d2					.byte $4f,$d2                          ; $81 or
>c0c8	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0cb	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0ce	bd					.byte $bd                              ; $84 =
>c0cf	3c be					.byte $3c,$be                          ; $85 <>
>c0d1	bc					.byte $bc                              ; $86 <
>c0d2	3c bd					.byte $3c,$bd                          ; $87 <=
>c0d4	be					.byte $be                              ; $88 >
>c0d5	3e bd					.byte $3e,$bd                          ; $89 >=
>c0d7	ab					.byte $ab                              ; $8a +
>c0d8	ad					.byte $ad                              ; $8b -
>c0d9	aa					.byte $aa                              ; $8c *
>c0da	af					.byte $af                              ; $8d /
>c0db	de					.byte $de                              ; $8e ^
>c0dc	49 c6					.byte $49,$c6                          ; $8f if
>c0de	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0e3	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0e9	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0ec	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0f0	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0f5	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c0f9	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c0fe	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c102	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c105	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c108	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c10c	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c110	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c114	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c119	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c11d	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c121	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c127	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c12e	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c133	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c137	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c13c	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c140	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c144	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c149	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c14d	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c151	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c155	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c159	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c15d	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c161	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c165	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c169	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c16e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c173	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c177	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>c17b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>c180	24 a8					.byte $24,$a8                          ; $b5 $(
>c182	a4					.byte $a4                              ; $b6 $
>c183	23 a8					.byte $23,$a8                          ; $b7 #(
>c185	a3					.byte $a3                              ; $b8 #
>c186	25 a8					.byte $25,$a8                          ; $b9 %(
>c188	a5					.byte $a5                              ; $ba %
>c189	a8					.byte $a8                              ; $bb (
>c18a	a9					.byte $a9                              ; $bc )
>c18b	ac					.byte $ac                              ; $bd ,
>c18c	ba					.byte $ba                              ; $be :
>c18d	bb					.byte $bb                              ; $bf ;
>c18e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>c191	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>c194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>c198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>c19c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>c19f	54 cf					.byte $54,$cf                          ; $c6 to
>c1a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>c1a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>c1aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>c1b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>c1b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cb input
>c1b9	4c 45 d4				.byte $4c,$45,$d4                      ; $cc let
>c1bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cd list
>c1c0	4e 45 d7				.byte $4e,$45,$d7                      ; $ce new
>c1c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cf old
>c1c6	4f ce					.byte $4f,$ce                          ; $d0 on
>c1c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d1 restore
>c1cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d2 poke
>c1d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d3 print
>c1d8	52 55 ce				.byte $52,$55,$ce                      ; $d4 run
>c1db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d5 stop
>c1df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>c1e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>c1e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>c1eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>c1f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_input = $cb
=$cc					token_let = $cc
=$cd					token_list = $cd
=$ce					token_new = $ce
=$cf					token_old = $cf
=$d0					token_on = $d0
=$d1					token_restore = $d1
=$d2					token_poke = $d2
=$d3					token_print = $d3
=$d4					token_run = $d4
=$d5					token_stop = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/hardware/em65816.asm

.c1f2					StartROM:
.c1f2	18		clc				clc
.c1f3	fb		xce				xce
.c1f4	c2 30		rep #$30			rep 	#$30
.c1f6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f9	1b		tcs				tcs
.c1fa	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1fc	c2 30		rep #$30			rep 	#$30
.c1fe	a9 00 00	lda #$0000			lda 	#$0000
.c201	aa		tax				tax
.c202	a8		tay				tay
.c203	e2 30		sep #$30			sep 	#$30
.c205	20 a9 c3	jsr $c3a9			jsr 	IF_Reset 					; reset external interface
.c208	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen
.c20b	4c f8 c3	jmp $c3f8		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c20e					IFT_ClearScreen:
.c20e	48		pha				pha
.c20f	da		phx				phx
.c210	5a		phy				phy
.c211	20 aa c3	jsr $c3aa			jsr 	IF_Home 					; home cursor
.c214	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c216					_IFT_CS0:
.c216	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c218					_IFT_CS1:
.c218	a9 20		lda #$20			lda 	#' '						; clear line.
.c21a	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c21d	88		dey				dey
.c21e	d0 f8		bne $c218			bne 	_IFT_CS1
.c220	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; next line down
.c223	ca		dex				dex
.c224	d0 f0		bne $c216			bne 	_IFT_CS0
.c226	7a		ply				ply
.c227	fa		plx				plx
.c228	68		pla				pla
.c229					IFT_HomeCursor:
.c229	48		pha				pha
.c22a	20 aa c3	jsr $c3aa			jsr 	IF_Home
.c22d	a9 00		lda #$00			lda 	#0
.c22f	8d 00 02	sta $0200			sta 	IFT_XCursor
.c232	8d 01 02	sta $0201			sta 	IFT_YCursor
.c235	68		pla				pla
.c236	60		rts				rts
.c237					IFT_UpLine:
.c237	48		pha				pha
.c238	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c23b	3a		dec a				dec 	a 							; line above
.c23c	30 03		bmi $c241			bmi 	_IFTULExit 					; too far, abort
.c23e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos					; set to that line.
.c241					_IFTULExit:
.c241	68		pla				pla
.c242	60		rts				rts
.c243					IFT_PrintCharacter:
.c243	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c245	f0 16		beq $c25d			beq 	IFT_NewLine
.c247	48		pha				pha
.c248	20 75 c2	jsr $c275			jsr 	IFT_UpperCase 				; make upper case
.c24b	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write out.
.c24e	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c251	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c254	c9 40		cmp #$40			cmp 	#IF_Width
.c256	d0 03		bne $c25b			bne 	_IFT_PCNotEOL
.c258	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; if so do new line.
.c25b					_IFT_PCNotEOL:
.c25b	68		pla				pla
.c25c	60		rts				rts
.c25d					IFT_NewLine:
.c25d	48		pha				pha
.c25e	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; new line on actual screen.
.c261	a9 00		lda #$00			lda 	#0 							; reset x position
.c263	8d 00 02	sta $0200			sta 	IFT_XCursor
.c266	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c269	ad 01 02	lda $0201			lda 	IFT_YCursor
.c26c	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c26e	d0 03		bne $c273			bne 	_IFT_NL_NotEOS
.c270	20 80 c2	jsr $c280			jsr 	IFT_Scroll 					; scroll screen up.
.c273					_IFT_NL_NotEOS:
.c273	68		pla				pla
.c274	60		rts				rts
.c275					IFT_UpperCase:
.c275	c9 61		cmp #$61			cmp 	#"a"
.c277	90 06		bcc $c27f			bcc 	_IFT_UCExit
.c279	c9 7b		cmp #$7b			cmp 	#"z"+1
.c27b	b0 02		bcs $c27f			bcs 	_IFT_UCExit
.c27d	49 20		eor #$20			eor 	#$20
.c27f					_IFT_UCExit:
.c27f	60		rts				rts
.c280					IFT_Scroll:
.c280	48		pha				pha 								; save AXY
.c281	da		phx				phx
.c282	5a		phy				phy
.c283	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c285					_IFT_SLoop:
.c285	20 a5 c2	jsr $c2a5			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c288	e8		inx				inx
.c289	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c28b	d0 f8		bne $c285			bne 	_IFT_SLoop
.c28d	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c28f	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c292	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c294					_IFT_SBlank:
.c294	a9 20		lda #$20			lda 	#32
.c296	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c299	ca		dex				dex
.c29a	d0 f8		bne $c294			bne 	_IFT_SBlank
.c29c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c29e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2a1	7a		ply				ply
.c2a2	fa		plx				plx
.c2a3	68		pla				pla
.c2a4	60		rts				rts
.c2a5					_IFT_ScrollLine:
.c2a5	da		phx				phx
.c2a6	da		phx				phx
.c2a7	8a		txa				txa 								; copy line into buffer.
.c2a8	1a		inc a				inc 	a 							; next line down.
.c2a9	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2ac	a2 00		ldx #$00			ldx 	#0
.c2ae					_IFTScrollCopy1:
.c2ae	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c2b1	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2b4	e8		inx				inx
.c2b5	e0 40		cpx #$40			cpx 	#IF_Width
.c2b7	d0 f5		bne $c2ae			bne 	_IFTScrollCopy1
.c2b9	68		pla				pla
.c2ba	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2bd	a2 00		ldx #$00			ldx 	#0
.c2bf					_IFTScrollCopy2:
.c2bf	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2c2	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c2c5	e8		inx				inx
.c2c6	e0 40		cpx #$40			cpx 	#IF_Width
.c2c8	d0 f5		bne $c2bf			bne 	_IFTScrollCopy2
.c2ca	fa		plx				plx
.c2cb	60		rts				rts
.c2cc					IFT_SetYPos:
.c2cc	48		pha				pha
.c2cd	da		phx				phx
.c2ce	aa		tax				tax
.c2cf	20 29 c2	jsr $c229			jsr 	IFT_HomeCursor
.c2d2	e0 00		cpx #$00			cpx 	#0
.c2d4	f0 09		beq $c2df			beq 	_IFT_MOAExit
.c2d6					_IFT_MOALoop:
.c2d6	20 bd c3	jsr $c3bd			jsr 	IF_NewLine
.c2d9	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2dc	ca		dex				dex
.c2dd	d0 f7		bne $c2d6			bne		_IFT_MOALoop
.c2df					_IFT_MOAExit:
.c2df	fa		plx				plx
.c2e0	68		pla				pla
.c2e1	60		rts				rts
.c2e2					IFT_GetKeyCursor:
.c2e2	20 ea c2	jsr $c2ea			jsr 	_IFT_FlipCursor 			; reverse current
.c2e5					_IFT_GKCWait:
.c2e5	20 e7 c3	jsr $c3e7			jsr 	IF_GetKey 					; get key
.c2e8	f0 fb		beq $c2e5			beq 	_IFT_GKCWait
.c2ea					_IFT_FlipCursor:
.c2ea	48		pha				pha 								; save
.c2eb	20 cd c3	jsr $c3cd			jsr 	IF_Read 					; read
.c2ee	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f1	49 80		eor #$80			eor 	#$80 						; reverse
.c2f3	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write
.c2f6	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f9	68		pla				pla
.c2fa	60		rts				rts
.c2fb					IFT_ReadLine:
.c2fb	48		pha				pha
.c2fc					_IFT_RLLoop:
.c2fc	20 e2 c2	jsr $c2e2			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2ff	c9 0d		cmp #$0d			cmp 	#13							; return
.c301	f0 7d		beq $c380			beq 	_IFT_RLExit
.c303	c9 20		cmp #$20			cmp 	#32 						; control character
.c305	90 05		bcc $c30c			bcc 	_IFT_Control
.c307	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.c30a	80 f0		bra $c2fc			bra 	_IFT_RLLoop
.c30c					_IFT_Control:
.c30c	c9 01		cmp #$01			cmp 	#"A"-64
.c30e	f0 26		beq $c336			beq 	_IFT_Left
.c310	c9 04		cmp #$04			cmp 	#"D"-64
.c312	f0 2e		beq $c342			beq 	_IFT_Right
.c314	c9 17		cmp #$17			cmp 	#"W"-64
.c316	f0 36		beq $c34e			beq 	_IFT_Up
.c318	c9 13		cmp #$13			cmp 	#"S"-64
.c31a	f0 3e		beq $c35a			beq 	_IFT_Down
.c31c	c9 08		cmp #$08			cmp 	#"H"-64
.c31e	f0 09		beq $c329			beq 	_IFT_Backspace
.c320	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c322	d0 d8		bne $c2fc			bne 	_IFT_RLLoop
.c324	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen				; clear CTL-Z
.c327	80 d3		bra $c2fc			bra 	_IFT_RLLoop
.c329					_IFT_Backspace:
.c329	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c32c	f0 ce		beq $c2fc			beq 	_IFT_RLLoop
.c32e	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c331	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c333	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c336					_IFT_Left:
.c336	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c339	10 29		bpl $c364			bpl 	_IFT_Reposition
.c33b	a9 3f		lda #$3f			lda 	#IF_Width-1
.c33d					_IFT_SetX:
.c33d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c340	80 22		bra $c364			bra 	_IFT_Reposition
.c342					_IFT_Right:
.c342	ee 00 02	inc $0200			inc 	IFT_XCursor
.c345	ad 00 02	lda $0200			lda 	IFT_XCursor
.c348	49 40		eor #$40			eor 	#IF_Width
.c34a	f0 f1		beq $c33d			beq 	_IFT_SetX
.c34c	80 16		bra $c364			bra 	_IFT_Reposition
.c34e					_IFT_Up:
.c34e	ce 01 02	dec $0201			dec 	IFT_YCursor
.c351	10 11		bpl $c364			bpl 	_IFT_Reposition
.c353	a9 1f		lda #$1f			lda 	#IF_Height-1
.c355					_IFT_SetY:
.c355	8d 01 02	sta $0201			sta 	IFT_YCursor
.c358	80 0a		bra $c364			bra 	_IFT_Reposition
.c35a					_IFT_Down:
.c35a	ee 01 02	inc $0201			inc 	IFT_YCursor
.c35d	ad 01 02	lda $0201			lda 	IFT_YCursor
.c360	49 20		eor #$20			eor 	#IF_Height
.c362	f0 f1		beq $c355			beq 	_IFT_SetY
.c364					_IFT_Reposition:
.c364	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c367	48		pha				pha
.c368	ad 01 02	lda $0201			lda 	IFT_YCursor
.c36b	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c36e	68		pla				pla
.c36f	aa		tax				tax
.c370	e0 00		cpx #$00			cpx 	#0
.c372	f0 88		beq $c2fc			beq 	_IFT_RLLoop
.c374					_IFT_MoveRight:
.c374	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c377	ee 00 02	inc $0200			inc 	IFT_XCursor
.c37a	ca		dex				dex
.c37b	d0 f7		bne $c374			bne 	_IFT_MoveRight
.c37d	4c fc c2	jmp $c2fc			jmp 	_IFT_RLLoop
.c380					_IFT_RLExit:
.c380	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c383	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c386	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c388					_IFT_RLRead:
.c388	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c38b	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c38e	e8		inx				inx
.c38f	e0 40		cpx #$40			cpx 	#IF_Width
.c391	d0 f5		bne $c388			bne 	_IFT_RLRead
.c393					_IFT_RL_Trim:
.c393	ca		dex				dex 	 							; previous char
.c394	30 07		bmi $c39d			bmi 	_IFT_Found 					; gone too far
.c396	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c399	c9 20		cmp #$20			cmp 	#" "
.c39b	f0 f6		beq $c393			beq 	_IFT_RL_Trim
.c39d					_IFT_Found:
.c39d	e8		inx				inx 								; forward to non-space
.c39e	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c3a0	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c3a3	68		pla				pla
.c3a4	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a6	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a9					IF_Reset:
.c3a9	60		rts				rts
.c3aa					IF_Home:
.c3aa	48		pha				pha
.c3ab	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3ad	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3af	85 04		sta $04				sta 	IF_Pos
.c3b1	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3b3	85 05		sta $05				sta 	IF_Pos+1
.c3b5	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b7	85 06		sta $06				sta 	IF_Pos+2
.c3b9	64 07		stz $07				stz 	IF_Pos+3
.c3bb	68		pla				pla
.c3bc	60		rts				rts
.c3bd					IF_NewLine:
.c3bd	48		pha				pha
.c3be	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3c0	18		clc				clc 								; down one line
.c3c1	a5 04		lda $04				lda 	IF_Pos
.c3c3	69 40		adc #$40			adc 	#64
.c3c5	85 04		sta $04				sta 	IF_Pos
.c3c7	90 02		bcc $c3cb			bcc 	_IF_NoCarry 				; carry through.
.c3c9	e6 05		inc $05				inc 	IF_Pos+1
.c3cb					_IF_NoCarry:
.c3cb	68		pla				pla
.c3cc	60		rts				rts
.c3cd					IF_Read:
.c3cd	5a		phy				phy 								; save current Y
.c3ce	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3d0	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3d2	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d4	7a		ply				ply									; restore Y
.c3d5	60		rts				rts
.c3d6					IF_Write:
.c3d6	5a		phy				phy 								; save current Y
.c3d7	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d9	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3db	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3dd	7a		ply				ply									; restore Y
.c3de	60		rts				rts
.c3df					IF_LeftOne:
.c3df	c6 08		dec $08				dec 	IF_XPos
.c3e1	60		rts				rts
.c3e2					IF_CheckBreak:
.c3e2	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e6	60		rts				rts
.c3e7					IF_GetKey:
.c3e7	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3eb	f0 08		beq $c3f5			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3ed	48		pha				pha 								; key pressed, clear queue.
.c3ee	a9 00		lda #$00			lda 	#0
.c3f0	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3f4	68		pla				pla
.c3f5					_IFGK_NoKey:
.c3f5	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f8					BASIC_Start:
.c3f8	20 18 c4	jsr $c418			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c3fb	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c3fd	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c3ff	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c401	85 16		sta $16				sta 	zCodePtr+0
.c403	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c405	85 17		sta $17				sta 	zCodePtr+1
.c407	a9 00		lda #$00			lda 	#0
.c409	85 18		sta $18				sta 	zCodePtr+2
.c40b	85 19		sta $19				sta 	zCodePtr+3
.c40d	a0 03		ldy #$03			ldy 	#3
.c40f	c8		iny				iny
.c410	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c412	20 26 c4	jsr $c426			jsr 	EvaluateExpression
>c415	02						.byte 	2
.c416					SyntaxError:
.c416					ERR_Handler:
.c416	80 fe		bra $c416			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c418					CLR_Command:
.c418					ResetRunStatus:
.c418	a9 00		lda #$00			lda 	#HighMemory & $FF
.c41a	8d 26 04	sta $0426			sta 	StringPtr
.c41d	a9 80		lda #$80			lda 	#HighMemory >> 8
.c41f	8d 27 04	sta $0427			sta 	StringPtr+1
.c422	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c423					EVESyntax:
.c423	4c 16 c4	jmp $c416			jmp 	SyntaxError
.c426					EvaluateExpression:
.c426	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c428					EvaluateExpressionX:
.c428	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c42a					EvaluateExpressionXA:
.c42a	48		pha				pha 								; save precedence on stack.
.c42b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c42d	f0 f4		beq $c423			beq 	EVESyntax 					; end of line, syntax error.
.c42f	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c431	b0 03		bcs $c436			bcs 	_EVNotVariable
.c433	4c 1e c5	jmp $c51e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c436					_EVNotVariable:
.c436	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c438	90 e9		bcc $c423			bcc 	EVESyntax
.c43a	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c43c	b0 7b		bcs $c4b9			bcs 	_EVNotInteger
.c43e	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c440	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c443	a9 00		lda #$00			lda 	#0
.c445	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c448	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c44b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c44e	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c450	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c453					_EVCheckNextInteger:
.c453	c8		iny				iny
.c454	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c456	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c458	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c45a	b0 0d		bcs $c469			bcs 	_EVCheckDecimal
.c45c	48		pha				pha 								; save it.
.c45d	20 22 c5	jsr $c522			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c460	68		pla				pla
.c461	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c464	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c467	80 ea		bra $c453			bra 	_EVCheckNextInteger
.c469					_EVCheckDecimal:
.c469	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c46d	d0 05		bne $c474			bne 	_EVGotAtom 					; no, get atom.
.c46f					_EVIsDecimal:
.c46f	20 52 c5	jsr $c552			jsr 	EVGetDecimal 				; extend to the decimal part.
.c472	80 00		bra $c474			bra 	_EVGotAtom 					; and continue to got atom.
.c474					_EVGotAtom:
.c474	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c476	10 3f		bpl $c4b7			bpl 	_EVExitDrop 				; must be a token.
.c478	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c47a	b0 3b		bcs $c4b7			bcs 	_EVExitDrop
.c47c	68		pla				pla 								; get current precedence
.c47d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c47f	da		phx				phx 								; save X
.c480	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c482	aa		tax				tax 								; put in X
.c483	bd 34 c0	lda $c034,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c486	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c488	fa		plx				plx 								; restore X
.c489	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c48b	90 2b		bcc $c4b8			bcc 	_EVExit 					; exit if too low.
.c48d	f0 29		beq $c4b8			beq 	_EVExit 					; exit if equals
.c48f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c491	48		pha				pha
.c492	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c494	48		pha				pha
.c495	c8		iny				iny
.c496	da		phx				phx 								; save current position
.c497	e8		inx				inx
.c498	e8		inx				inx
.c499	e8		inx				inx
.c49a	e8		inx				inx
.c49b	e8		inx				inx
.c49c	e8		inx				inx
.c49d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c49f	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA 		; do the RHS.
.c4a2	fa		plx				plx 								; restore X
.c4a3	68		pla				pla 								; get the binary operator in A.
.c4a4					_EVCallA:
.c4a4	da		phx				phx 								; save X again
.c4a5	0a		asl a				asl 	a 							; double, lose the MSB.
.c4a6	aa		tax				tax									; put in X
.c4a7	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c4aa	85 1e		sta $1e				sta 	zGenPtr
.c4ac	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c4af	85 1f		sta $1f				sta 	zGenPtr+1
.c4b1	fa		plx				plx 								; restore X
.c4b2	20 1f c5	jsr $c51f			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4b5	80 bd		bra $c474			bra 	_EVGotAtom 					; and loop back.
.c4b7					_EVExitDrop:
.c4b7	68		pla				pla
.c4b8					_EVExit:
.c4b8	60		rts				rts
.c4b9					_EVNotInteger:
.c4b9	c8		iny				iny
.c4ba	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4bc	d0 19		bne $c4d7			bne 	_EVNotMinus
.c4be	20 a3 c5	jsr $c5a3			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4c1	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4c4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4c6	f0 05		beq $c4cd			beq 	_EVMinusFloat
.c4c8	20 aa ca	jsr $caaa			jsr 	IntegerNegateAlways 		; negation
.c4cb	80 a7		bra $c474			bra 	_EVGotAtom 					; and go back.
.c4cd					_EVMinusFloat:
.c4cd	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4d0	49 80		eor #$80			eor 	#$80
.c4d2	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4d5	80 9d		bra $c474			bra 	_EVGotAtom
.c4d7					_EVNotMinus:
.c4d7	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.c4d9	d0 0c		bne $c4e7			bne 	_EVNotParenthesis
.c4db	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4de	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e0	c8		iny				iny
.c4e1	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.c4e3	f0 8f		beq $c474			beq 	_EVGotAtom
.c4e5	80 fe		bra $c4e5		_error: bra _error
.c4e7					_EVNotParenthesis:
.c4e7	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4e9	d0 0c		bne $c4f7			bne 	_EVNotNot
.c4eb	20 a3 c5	jsr $c5a3			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c4ee	20 9e cf	jsr $cf9e			jsr 	FPUToInteger 				; make it an integer - if possible.
.c4f1	20 80 c5	jsr $c580			jsr 	NotInteger 					; do the not calculation
.c4f4	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c4f7					_EVNotNot:
.c4f7	c9 fe		cmp #$fe			cmp 	#$FE
.c4f9	d0 15		bne $c510			bne 	_EVNotString
.c4fb	20 aa c9	jsr $c9aa			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c4fe	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c500	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c503	a5 21		lda $21				lda 	zTempStr+1
.c505	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c508	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c50a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c50d	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c510					_EVNotString:
.c510	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.c512	90 04		bcc $c518			bcc 	_EVBadElement
.c514	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.c516	90 03		bcc $c51b			bcc 	_EVUnaryFunction
.c518					_EVBadElement:
.c518	4c 16 c4	jmp $c416			jmp 	SyntaxError
.c51b					_EVUnaryFunction:
.c51b	4c a4 c4	jmp $c4a4			jmp 	_EVCallA
.c51e					_EVVariableHandler:
.c51e	ea		nop				nop
.c51f					EVGoZGenPtr:
.c51f	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c522					EVShiftMantissaLeft6:
.c522	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c525	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c528	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c52b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c52e	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c531	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c534	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c537	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c53a	a9 00		lda #$00			lda 	#0
.c53c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c53f	20 42 c5	jsr $c542			jsr 	_EVSMLShift 					; call it here to do it twice
.c542					_EVSMLShift:
.c542	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c545	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c548	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c54b	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c54e	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c551	60		rts				rts
.c552					EVGetDecimal:
.c552	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c554	8d 00 04	sta $0400			sta 	Num_Buffer
.c557	da		phx				phx
.c558	c8		iny				iny
.c559	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c55b	c8		iny				iny
.c55c	3a		dec a				dec 	a								; convert to a string length.
.c55d	3a		dec a				dec 	a
.c55e	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c560					_EVGDCopy:
.c560	48		pha				pha 									; save count
.c561	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c563	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c566	e8		inx				inx 									; forward ....
.c567	c8		iny				iny
.c568	68		pla				pla 									; get count
.c569	3a		dec a				dec 	a 								; until zero
.c56a	d0 f4		bne $c560			bne 	_EVGDCopy
.c56c	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c56f	fa		plx				plx 									; restore X
.c570	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c572	85 1e		sta $1e				sta 	zGenPtr
.c574	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c576	85 1f		sta $1f				sta 	zGenPtr+1
.c578	5a		phy				phy 									; save Y
.c579	a0 00		ldy #$00			ldy 	#0 								; start position
.c57b	20 77 d1	jsr $d177			jsr 	FPFromString 					; convert current
.c57e	7a		ply				ply 									; restore Y
.c57f	60		rts				rts
.c580					NotInteger:
.c580	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c583	49 ff		eor #$ff			eor 	#$FF
.c585	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c588	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c58b	49 ff		eor #$ff			eor 	#$FF
.c58d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c590	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c593	49 ff		eor #$ff			eor 	#$FF
.c595	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c598	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c59b	49 ff		eor #$ff			eor 	#$FF
.c59d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5a0	60		rts				rts
.c5a1					EvaluateGetAtom:
.c5a1	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c5a3					EvaluateGetAtomX:
.c5a3	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c5a5	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA
.c5a8	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c5ab	29 0f		and #$0f			and 	#15
.c5ad	c9 02		cmp #$02			cmp 	#2
.c5af	b0 01		bcs $c5b2			bcs 	EvaluateType
.c5b1	60		rts				rts
.c5b2					EvaluateType:
.c5b2	80 fe		bra $c5b2		_error: bra _error
.c5b4					EvaluateNumber:
.c5b4	a2 00		ldx #$00			ldx 	#0
.c5b6					EvaluateNumberX:
.c5b6	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX
.c5b9	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0/1
.c5bc	29 0f		and #$0f			and 	#15
.c5be	c9 02		cmp #$02			cmp 	#2
.c5c0	b0 f0		bcs $c5b2			bcs 	EvaluateType
.c5c2	60		rts				rts
.c5c3					EvaluateString:
.c5c3	a2 00		ldx #$00			ldx 	#0
.c5c5					EvaluateStringX:
.c5c5	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX
.c5c8	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 2
.c5cb	29 0f		and #$0f			and 	#15
.c5cd	c9 02		cmp #$02			cmp 	#2
.c5cf	d0 e1		bne $c5b2			bne 	EvaluateType
.c5d1	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.c5d4	85 1e		sta $1e				sta 	zGenPtr
.c5d6	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c5d9	85 1f		sta $1f				sta 	zGenPtr+1
.c5db	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5dc					BinaryOp_And:
.c5dc	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c5df	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5e2	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5e5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5e8	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5eb	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5ee	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5f1	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5f4	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5f7	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5fa	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5fd	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c600	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c603	60		rts				rts
.c604					BinaryOp_Or:
.c604	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c607	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c60a	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c60d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c610	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c613	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c616	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c619	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c61c	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c61f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c622	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c625	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c628	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c62b	60		rts				rts
.c62c					BinaryOp_Eor:
.c62c					BinaryOp_Xor:
.c62c	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c62f	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c632	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c635	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c638	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c63b	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c63e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c641	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c644	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c647	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c64a	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c64d	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c650	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c653	60		rts				rts
.c654					BinaryMakeBothInteger:
.c654	da		phx				phx 								; save X
.c655	e8		inx				inx
.c656	e8		inx				inx
.c657	e8		inx				inx
.c658	e8		inx				inx
.c659	e8		inx				inx
.c65a	e8		inx				inx
.c65b	20 5f c6	jsr $c65f			jsr 	BinaryMakeInteger 			; convert to integer.
.c65e	fa		plx				plx 								; restore X and fall through.
.c65f					BinaryMakeInteger:
.c65f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c662	29 0f		and #$0f			and 	#15 						; check type zero
.c664	f0 04		beq $c66a			beq 	_BMIConvert 				; if float convert to integer.
.c666	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c667	90 04		bcc $c66d			bcc 	_BMIError
.c669	60		rts				rts
.c66a					_BMIConvert:
.c66a	4c 9e cf	jmp $cf9e			jmp 	FPUToInteger 				; convert to integer
.c66d					_BMIError:
.c66d	80 fe		bra $c66d		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.c66f					Binary_Equal:
.c66f	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c672	09 00		ora #$00			ora 	#0
.c674	f0 04		beq $c67a			beq 	CCTrue
.c676	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.c678	80 02		bra $c67c			bra 	CCWrite
.c67a	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.c67c	9d 00 03	sta $0300,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.c67f	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c682	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c685	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c688	a9 01		lda #$01			lda 	#1
.c68a	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; set type to integer whatever.
.c68d	60		rts				rts
.c68e					Binary_NotEqual:
.c68e	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c691	09 00		ora #$00			ora 	#0
.c693	d0 e1		bne $c676			bne 	CCFalse
.c695	80 e3		bra $c67a			bra 	CCTrue
.c697					Binary_Less:
.c697	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c69a	09 00		ora #$00			ora 	#0
.c69c	30 dc		bmi $c67a			bmi 	CCTrue
.c69e	80 d6		bra $c676			bra 	CCFalse
.c6a0					Binary_LessEqual:
.c6a0	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6a3	c9 01		cmp #$01			cmp 	#1
.c6a5	d0 d3		bne $c67a			bne 	CCTrue
.c6a7	80 cd		bra $c676			bra 	CCFalse
.c6a9					Binary_GreaterEqual:
.c6a9	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6ac	09 00		ora #$00			ora 	#0
.c6ae	10 ca		bpl $c67a			bpl 	CCTrue
.c6b0	80 c4		bra $c676			bra 	CCFalse
.c6b2					Binary_Greater:
.c6b2	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6b5	c9 01		cmp #$01			cmp 	#1
.c6b7	d0 c1		bne $c67a			bne 	CCTrue
.c6b9	80 bb		bra $c676			bra 	CCFalse
.c6bb					CompareValues:
.c6bb	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and the types together
.c6be	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6c1	c9 02		cmp #$02			cmp 	#2
.c6c3	f0 13		beq $c6d8			beq 	_CVString
.c6c5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6c8	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6cb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6cc	90 03		bcc $c6d1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6ce	4c 1e c7	jmp $c71e			jmp 	CompareInteger32 							; so execute code at \1
.c6d1					_BCFloat:
.c6d1	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6d4	4c ad ce	jmp $cead			jmp 	FPCompare 							; and execute code at \2
.c6d7	60		rts				rts
.c6d8					_CVString:
.c6d8	da		phx				phx 								; save XY
.c6d9	5a		phy				phy
.c6da	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c6dd	85 1a		sta $1a				sta		zLTemp1+0
.c6df	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6e2	85 1b		sta $1b				sta 	zLTemp1+1
.c6e4	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c6e7	85 1c		sta $1c				sta 	zLTemp1+2
.c6e9	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c6ec	85 1d		sta $1d				sta 	zLTemp1+3
.c6ee	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.c6f0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c6f2	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6f4	90 02		bcc $c6f8			bcc 	_CVCommon
.c6f6	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.c6f8					_CVCommon:
.c6f8	aa		tax				tax 								; put shorter string length in zero.
.c6f9	f0 0c		beq $c707			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.c6fb					_CVCompare:
.c6fb	c8		iny				iny 								; next character
.c6fc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.c6fe	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c700	90 13		bcc $c715			bcc 	_CVReturnLess 				; <
.c702	d0 15		bne $c719			bne 	_CVReturnGreater 			; >
.c704	ca		dex				dex 								; until common length matched.
.c705	d0 f4		bne $c6fb			bne 	_CVCompare
.c707					_CVMatch:
.c707	a0 00		ldy #$00			ldy 	#0
.c709	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c70b	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c70d	90 06		bcc $c715			bcc 	_CVReturnLess 				; <
.c70f	d0 08		bne $c719			bne 	_CVReturnGreater 			; >
.c711	a9 00		lda #$00			lda 	#0
.c713	80 06		bra $c71b			bra 	_CVExit 					; same common, same length, same string
.c715					_CVReturnLess:
.c715	a9 ff		lda #$ff			lda 	#$FF
.c717	80 02		bra $c71b			bra 	_CVExit
.c719					_CVReturnGreater:
.c719	a9 01		lda #$01			lda 	#$01
.c71b					_CVExit:
.c71b	7a		ply				ply
.c71c	fa		plx				plx
.c71d	60		rts				rts
.c71e					CompareInteger32:
.c71e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.c721	49 80		eor #$80			eor 	#$80
.c723	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c726	bd 09 03	lda $0309,x			lda 	XS2_Mantissa+3,x
.c729	49 80		eor #$80			eor 	#$80
.c72b	9d 09 03	sta $0309,x			sta 	XS2_Mantissa+3,x
.c72e	20 c6 c7	jsr $c7c6			jsr 	SubInteger32 				; subtraction
.c731	90 11		bcc $c744			bcc 	_CI32Less 					; cc return -1
.c733	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; check if zero
.c736	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c739	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c73c	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c73f	f0 02		beq $c743			beq 	_CI32Exit
.c741	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.c743					_CI32Exit:
.c743	60		rts				rts
.c744					_CI32Less:
.c744	a9 ff		lda #$ff			lda 	#$FF
.c746	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c747					BinaryOp_Add:
.c747	bd 05 03	lda $0305,x			lda 	XS_Type,x  					; and types together
.c74a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c74d	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c74f	d0 13		bne $c764			bne 	_BOAString
.c751	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c754	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c757	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c758	90 03		bcc $c75d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c75a	4c a0 c7	jmp $c7a0			jmp 	AddInteger32 							; so execute code at \1
.c75d					_BCFloat:
.c75d	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c760	4c 33 cc	jmp $cc33			jmp 	FPAdd 							; and execute code at \2
.c763	60		rts				rts
.c764					_BOAString:
.c764	4c 06 c8	jmp $c806			jmp 	ConcatenateString 			; concatenate two strings.
.c767					BinaryOp_Subtract:
.c767	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c76a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c76d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c76e	90 03		bcc $c773			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c770	4c c6 c7	jmp $c7c6			jmp 	SubInteger32 							; so execute code at \1
.c773					_BCFloat:
.c773	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c776	4c 29 cc	jmp $cc29			jmp 	FPSubtract 							; and execute code at \2
.c779	60		rts				rts
.c77a					BinaryOp_Multiply:
.c77a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c77d	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c780	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c781	90 03		bcc $c786			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c783	4c cf c9	jmp $c9cf			jmp 	MulInteger32 							; so execute code at \1
.c786					_BCFloat:
.c786	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c789	4c 8d cd	jmp $cd8d			jmp 	FPMultiply 							; and execute code at \2
.c78c	60		rts				rts
.c78d					BinaryOp_Divide:
.c78d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c790	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c793	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c794	90 03		bcc $c799			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c796	4c 26 ca	jmp $ca26			jmp 	DivInteger32 							; so execute code at \1
.c799					_BCFloat:
.c799	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c79c	4c 05 cd	jmp $cd05			jmp 	FPDivide 							; and execute code at \2
.c79f	60		rts				rts
.c7a0					AddInteger32:
.c7a0	18		clc				clc
.c7a1	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7a4	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c7a7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7aa	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7ad	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c7b0	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7b3	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7b6	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c7b9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7bc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7bf	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c7c2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7c5	60		rts				rts
.c7c6					SubInteger32:
.c7c6	38		sec				sec
.c7c7	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7ca	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c7cd	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7d0	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7d3	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c7d6	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7d9	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7dc	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c7df	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7e2	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7e5	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c7e8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7eb	60		rts				rts
.c7ec					BinaryMakeBothFloat:
.c7ec	da		phx				phx 								; save X
.c7ed	e8		inx				inx
.c7ee	e8		inx				inx
.c7ef	e8		inx				inx
.c7f0	e8		inx				inx
.c7f1	e8		inx				inx
.c7f2	e8		inx				inx
.c7f3	20 f7 c7	jsr $c7f7			jsr 	BinaryMakeFloat 			; convert to float.
.c7f6	fa		plx				plx 								; restore X and fall through.
.c7f7					BinaryMakeFloat:
.c7f7	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c7fa	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c7fb	b0 04		bcs $c801			bcs 	_BMFConvert
.c7fd	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c7fe	b0 04		bcs $c804			bcs 	_BMFError
.c800	60		rts				rts
.c801					_BMFConvert:
.c801	4c 3f cf	jmp $cf3f			jmp 	FPUToFloat 					; convert to float
.c804					_BMFError:
.c804	80 fe		bra $c804		_error: bra _error
.c806					ConcatenateString:
.c806	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c809	85 1a		sta $1a				sta		zLTemp1+0
.c80b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c80e	85 1b		sta $1b				sta 	zLTemp1+1
.c810	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c813	85 1c		sta $1c				sta 	zLTemp1+2
.c815	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c818	85 1d		sta $1d				sta 	zLTemp1+3
.c81a	5a		phy				phy
.c81b	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c81d	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c81f	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c821	7a		ply				ply
.c822	b0 37		bcs $c85b			bcs 	_CSError					; check in range.
.c824	c9 fe		cmp #$fe			cmp 	#maxString+1
.c826	b0 33		bcs $c85b			bcs 	_CSError
.c828	20 6f c9	jsr $c96f			jsr 	AllocateTempString 			; store the result
.c82b	20 46 c8	jsr $c846			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c82e	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c831	85 1a		sta $1a				sta 	zLTemp1
.c833	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c836	85 1b		sta $1b				sta 	zLTemp1+1
.c838	20 46 c8	jsr $c846			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c83b	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c83d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c840	a5 21		lda $21				lda 	zTempStr+1
.c842	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c845	60		rts				rts
.c846					_CSCopyString:
.c846	da		phx				phx
.c847	5a		phy				phy
.c848	a0 00		ldy #$00			ldy 	#0 							; get length
.c84a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c84c	f0 0a		beq $c858			beq 	_CSCSExit 					; if zero, exit
.c84e	aa		tax				tax 								; put in X
.c84f					_CSCSLoop:
.c84f	c8		iny				iny 								; get next char
.c850	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c852	20 9a c9	jsr $c99a			jsr		WriteTempString 			; copy out
.c855	ca		dex				dex 								; do whole string
.c856	d0 f7		bne $c84f			bne 	_CSCSLoop
.c858					_CSCSExit:
.c858	7a		ply				ply
.c859	fa		plx				plx
.c85a	60		rts				rts
.c85b					_CSError:
.c85b	80 fe		bra $c85b		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.c85d					Unary_Sgn:
.c85d	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.c860	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; check right bracket.
.c863	20 87 c8	jsr $c887			jsr 	GetSignCurrent 				; get sign.
.c866	09 00		ora #$00			ora 	#0
.c868	10 09		bpl $c873			bpl		UnarySetAInteger			; if 0,1 return that.
.c86a	80 00		bra $c86c			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.c86c					UnarySetAMinus1:
.c86c	a9 ff		lda #$ff			lda 	#$FF
.c86e	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c871	80 05		bra $c878			bra 	UnarySetAFill
.c873					UnarySetAInteger:
.c873	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c876	a9 00		lda #$00			lda 	#0
.c878					UnarySetAFill:
.c878	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c87b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c87e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c881	a9 01		lda #$01			lda 	#1
.c883	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c886	60		rts				rts
.c887					GetSignCurrent:
.c887	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; identify type.
.c88a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.c88b	90 19		bcc $c8a6			bcc 	_GSCFloat
.c88d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c890	30 11		bmi $c8a3			bmi 	_GSCMinus1
.c892	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x
.c895	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c898	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c89b	d0 03		bne $c8a0			bne 	_GSCPlus1
.c89d					_GSCZero:
.c89d	a9 00		lda #$00			lda 	#0
.c89f	60		rts				rts
.c8a0					_GSCPlus1:
.c8a0	a9 01		lda #$01			lda 	#$01
.c8a2	60		rts				rts
.c8a3					_GSCMinus1:
.c8a3	a9 ff		lda #$ff			lda 	#$FF
.c8a5	60		rts				rts
.c8a6					_GSCFloat:
.c8a6	3c 05 03	bit $0305,x			bit 	XS_Type,x
.c8a9	70 f2		bvs $c89d			bvs 	_GSCZero
.c8ab	30 f6		bmi $c8a3			bmi 	_GSCMinus1
.c8ad	80 f1		bra $c8a0			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.c8af					Unary_Abs:
.c8af	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.c8b2	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; check right bracket.
.c8b5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c8b8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c8ba	f0 08		beq $c8c4			beq 	_UAMinusFloat
.c8bc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; check MSB
.c8bf	10 0b		bpl $c8cc			bpl 	_UAExit
.c8c1	4c aa ca	jmp $caaa			jmp 	IntegerNegateAlways 		; negation
.c8c4					_UAMinusFloat:
.c8c4	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; clear the sign bit.
.c8c7	29 7f		and #$7f			and		#$7F
.c8c9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c8cc					_UAExit:
.c8cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c8cd					Unary_Asc:
.c8cd	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; string parameter
.c8d0	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; right bracket.
.c8d3	5a		phy				phy 								; get the string length
.c8d4	a0 00		ldy #$00			ldy 	#0
.c8d6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c8d8	f0 07		beq $c8e1			beq 	_UAIllegal 					; must be at least one character
.c8da	c8		iny				iny
.c8db	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.c8dd	7a		ply				ply
.c8de	4c 73 c8	jmp $c873			jmp 	UnarySetAInteger
.c8e1					_UAIllegal:
.c8e1	80 fe		bra $c8e1		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c8e3					Unary_Len:
.c8e3	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; string parameter
.c8e6	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; right bracket.
.c8e9	5a		phy				phy 								; get the string length
.c8ea	a0 00		ldy #$00			ldy 	#0
.c8ec	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c8ee	7a		ply				ply
.c8ef	4c 73 c8	jmp $c873			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.c8f2					Unary_Chr:
.c8f2	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.c8f5	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; right bracket.
.c8f8	20 9e cf	jsr $cf9e			jsr 	FPUToInteger 				; make integer.
.c8fb	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c8fe	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c901	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c904	d0 0e		bne $c914			bne 	_UCChar
.c906	a9 01		lda #$01			lda 	#1 							; one character string
.c908	20 6f c9	jsr $c96f			jsr 	AllocateTempString
.c90b	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.c90e	20 9a c9	jsr $c99a			jsr 	WriteTempString
.c911	4c 47 c9	jmp $c947			jmp 	UnaryReturnTempStr
.c914					_UCChar:
.c914	80 fe		bra $c914		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.c916					Unary_Spc:
.c916	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.c919	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; right bracket.
.c91c	20 9e cf	jsr $cf9e			jsr 	FPUToInteger 				; make integer.
.c91f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c922	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c925	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c928	d0 1b		bne $c945			bne 	_USSize
.c92a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c92d	c9 fe		cmp #$fe			cmp 	#maxString+1
.c92f	b0 14		bcs $c945			bcs 	_USSize
.c931	48		pha				pha 								; save length
.c932	1a		inc a				inc 	a 							; allocate one more.
.c933	20 6f c9	jsr $c96f			jsr 	AllocateTempString
.c936	68		pla				pla 								; get length
.c937	f0 0e		beq $c947			beq 	UnaryReturnTempStr 			; return the current temp string
.c939					_USLoop:
.c939	48		pha				pha
.c93a	a9 20		lda #$20			lda 	#" "
.c93c	20 9a c9	jsr $c99a			jsr 	WriteTempString
.c93f	68		pla				pla
.c940	3a		dec a				dec 	a
.c941	d0 f6		bne $c939			bne 	_USLoop
.c943	80 02		bra $c947			bra 	UnaryReturnTempStr
.c945					_USSize:
.c945	80 fe		bra $c945		_error: bra _error
.c947					UnaryReturnTempStr:
.c947	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.c949	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c94c	a5 21		lda $21				lda 	zTempStr+1
.c94e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c951	a9 02		lda #$02			lda 	#2 							; set type to string
.c953	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c956	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.c957					CheckNextToken:
.c957	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.c959	d0 02		bne $c95d			bne 	CTFail 						; no, then fail
.c95b	c8		iny				iny
.c95c	60		rts				rts
.c95d					CTFail:
.c95d	80 fe		bra $c95d		_error: bra _error
.c95f					CheckNextRParen:
.c95f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c961	c9 bc		cmp #$bc			cmp 	#token_rparen
.c963	d0 f8		bne $c95d			bne 	CTFail
.c965	c8		iny				iny
.c966	60		rts				rts
.c967					CheckNextComma:
.c967	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c969	c9 bd		cmp #$bd			cmp 	#token_comma
.c96b	d0 f0		bne $c95d			bne 	CTFail
.c96d	c8		iny				iny
.c96e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c96f					AllocateTempString:
.c96f	48		pha				pha 								; save required count.
.c970	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.c972	d0 0b		bne $c97f			bne 	_ATSInitialised
.c974	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c977	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.c979	ad 27 04	lda $0427			lda 	StringPtr+1
.c97c	3a		dec a				dec 	a
.c97d	85 21		sta $21				sta 	zTempStr+1
.c97f					_ATSInitialised:
.c97f	68		pla				pla 								; get required count back.
.c980	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.c982	1a		inc a				inc 	a
.c983	18		clc				clc
.c984	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.c986	85 20		sta $20				sta 	zTempStr
.c988	a9 ff		lda #$ff			lda 	#$FF
.c98a	65 21		adc $21				adc 	zTempStr+1
.c98c	85 21		sta $21				sta 	zTempStr+1
.c98e	a9 00		lda #$00			lda 	#0 							; clear temp string.
.c990	5a		phy				phy
.c991	a8		tay				tay
.c992	91 20		sta ($20),y			sta 	(zTempStr),y
.c994	7a		ply				ply
.c995	1a		inc a				inc 	a 							; reset the write index.
.c996	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.c999	60		rts				rts
.c99a					WriteTempString:
.c99a	5a		phy				phy 								; save Y
.c99b	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.c99e	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.c9a0	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.c9a3	98		tya				tya 								; unchanged Y is now length
.c9a4	a0 00		ldy #$00			ldy 	#0
.c9a6	91 20		sta ($20),y			sta 	(zTempStr),y
.c9a8	7a		ply				ply 								; restore Y and exit
.c9a9	60		rts				rts
.c9aa					CreateTempStringCopy:
.c9aa	da		phx				phx 								; save X
.c9ab	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c9ad	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c9ae	20 6f c9	jsr $c96f			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c9b1	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c9b3	c8		iny				iny
.c9b4	3a		dec a				dec 	a 							; make the actual length in charactes
.c9b5	3a		dec a				dec 	a
.c9b6	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c9b8	81 20		sta ($20,x)			sta 	(zTempStr,x)
.c9ba	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.c9bc	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c9be	f0 0d		beq $c9cd			beq 	_CTSCExit
.c9c0					_CTSCLoop:
.c9c0	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c9c2	c8		iny				iny
.c9c3	5a		phy				phy 								; save in Y
.c9c4	e8		inx				inx 								; bump index
.c9c5	9b		txy				txy 								; index into Y
.c9c6	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.c9c8	7a		ply				ply 								; restore Y
.c9c9	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.c9cb	d0 f3		bne $c9c0			bne 	_CTSCLoop
.c9cd					_CTSCExit:
.c9cd	fa		plx				plx 								; restore X
.c9ce	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c9cf					MulInteger32:
.c9cf	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c9d2	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c9d5	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c9d8	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c9db	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c9de	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c9e1	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c9e4	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c9e7	a9 00		lda #$00			lda 	#0
.c9e9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c9ec	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c9ef	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c9f2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c9f5					_BFMMultiply:
.c9f5	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c9f8	29 01		and #$01			and 	#1
.c9fa	f0 03		beq $c9ff			beq 	_BFMNoAdd
.c9fc	20 a0 c7	jsr $c7a0			jsr 	AddInteger32
.c9ff					_BFMNoAdd:
.c9ff	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.ca02	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.ca05	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.ca08	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.ca0b	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.ca0e	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.ca11	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.ca14	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.ca17	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.ca1a	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.ca1d	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.ca20	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.ca23	d0 d0		bne $c9f5			bne 	_BFMMultiply
.ca25	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.ca26					DivInteger32:
.ca26	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.ca29	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.ca2c	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.ca2f	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.ca32	d0 02		bne $ca36			bne 	_BFDOkay
.ca34	80 fe		bra $ca34		_error: bra _error
.ca36					_BFDOkay:
.ca36	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.ca38	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.ca3a	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.ca3c	85 1c		sta $1c				sta 	zLTemp1+2
.ca3e	85 1d		sta $1d				sta 	zLTemp1+3
.ca40	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.ca43	20 a4 ca	jsr $caa4			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ca46	da		phx				phx
.ca47	e8		inx				inx
.ca48	e8		inx				inx
.ca49	e8		inx				inx
.ca4a	e8		inx				inx
.ca4b	e8		inx				inx
.ca4c	e8		inx				inx
.ca4d	20 a4 ca	jsr $caa4			jsr 	CheckIntegerNegate
.ca50	fa		plx				plx
.ca51	5a		phy				phy 								; Y is the counter
.ca52	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ca54					_BFDLoop:
.ca54	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.ca57	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.ca5a	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.ca5d	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.ca60	26 1a		rol $1a				rol 	zLTemp1
.ca62	26 1b		rol $1b				rol 	zLTemp1+1
.ca64	26 1c		rol $1c				rol 	zLTemp1+2
.ca66	26 1d		rol $1d				rol 	zLTemp1+3
.ca68	38		sec				sec
.ca69	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ca6b	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.ca6e	48		pha				pha
.ca6f	a5 1b		lda $1b				lda 	zLTemp1+1
.ca71	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.ca74	48		pha				pha
.ca75	a5 1c		lda $1c				lda 	zLTemp1+2
.ca77	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.ca7a	48		pha				pha
.ca7b	a5 1d		lda $1d				lda 	zLTemp1+3
.ca7d	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.ca80	90 15		bcc $ca97			bcc 	_BFDNoAdd
.ca82	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.ca84	68		pla				pla
.ca85	85 1c		sta $1c				sta 	zLTemp1+2
.ca87	68		pla				pla
.ca88	85 1b		sta $1b				sta 	zLTemp1+1
.ca8a	68		pla				pla
.ca8b	85 1a		sta $1a				sta 	zLTemp1+0
.ca8d	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.ca90	09 01		ora #$01			ora 	#1
.ca92	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca95	80 03		bra $ca9a			bra 	_BFDNext
.ca97					_BFDNoAdd:
.ca97	68		pla				pla 								; Throw away the intermediate calculations
.ca98	68		pla				pla
.ca99	68		pla				pla
.ca9a					_BFDNext:
.ca9a	88		dey				dey
.ca9b	d0 b7		bne $ca54			bne 	_BFDLoop
.ca9d	7a		ply				ply 								; restore Y and exit
.ca9e	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.caa1	b0 07		bcs $caaa			bcs		IntegerNegateAlways 			; negate the result
.caa3	60		rts				rts
.caa4					CheckIntegerNegate:
.caa4	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.caa7	30 01		bmi $caaa			bmi 	IntegerNegateAlways
.caa9	60		rts				rts
.caaa					IntegerNegateAlways:
.caaa	ee 25 04	inc $0425			inc 	SignCount
.caad	38		sec				sec
.caae	a9 00		lda #$00			lda 	#0
.cab0	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cab3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cab6	a9 00		lda #$00			lda 	#0
.cab8	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cabb	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cabe	a9 00		lda #$00			lda 	#0
.cac0	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cac3	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cac6	a9 00		lda #$00			lda 	#0
.cac8	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cacb	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cace	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cacf					INTToString:
.cacf	48		pha				pha
.cad0	5a		phy				phy
.cad1	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.cad4	10 08		bpl $cade			bpl 		_ITSNotMinus
.cad6	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cad8	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter
.cadb	20 aa ca	jsr $caaa			jsr 		IntegerNegateAlways 	; negate the number.
.cade					_ITSNotMinus:
.cade	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.cae0	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.cae3	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.cae5					_ITSNextSubtractor:
.cae5	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cae7	8d 22 04	sta $0422			sta 		NumConvCount
.caea					_ITSSubtract:
.caea	38		sec				sec
.caeb	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.caee	f9 47 cb	sbc $cb47,y			sbc 		_ITSSubtractors+0,y
.caf1	48		pha				pha
.caf2	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.caf5	f9 48 cb	sbc $cb48,y			sbc 		_ITSSubtractors+1,y
.caf8	48		pha				pha
.caf9	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.cafc	f9 49 cb	sbc $cb49,y			sbc 		_ITSSubtractors+2,y
.caff	48		pha				pha
.cb00	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.cb03	f9 4a cb	sbc $cb4a,y			sbc 		_ITSSubtractors+3,y
.cb06	90 14		bcc $cb1c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cb08	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.cb0b	68		pla				pla
.cb0c	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cb0f	68		pla				pla
.cb10	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cb13	68		pla				pla
.cb14	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.cb17	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.cb1a	80 ce		bra $caea			bra 		_ITSSubtract 			; go round again.
.cb1c					_ITSCantSubtract:
.cb1c	68		pla				pla 								; throw away interim answers
.cb1d	68		pla				pla
.cb1e	68		pla				pla
.cb1f	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.cb22	c9 30		cmp #$30			cmp 		#"0"
.cb24	d0 05		bne $cb2b			bne 		_ITSOutputDigit
.cb26	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cb29	10 09		bpl $cb34			bpl 		_ITSGoNextSubtractor
.cb2b					_ITSOutputDigit:
.cb2b	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.cb2e	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.cb31	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter 		; output it.
.cb34					_ITSGoNextSubtractor:
.cb34	c8		iny				iny 								; next dword
.cb35	c8		iny				iny
.cb36	c8		iny				iny
.cb37	c8		iny				iny
.cb38	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.cb3a	d0 a9		bne $cae5			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cb3c	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cb3f	09 30		ora #$30			ora 		#"0"
.cb41	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter
.cb44	7a		ply				ply 								; and exit
.cb45	68		pla				pla
.cb46	60		rts				rts
.cb47					_ITSSubtractors:
>cb47	00 ca 9a 3b					.dword 		1000000000
>cb4b	00 e1 f5 05					.dword 		100000000
>cb4f	80 96 98 00					.dword 		10000000
>cb53	40 42 0f 00					.dword 		1000000
>cb57	a0 86 01 00					.dword 		100000
>cb5b	10 27 00 00					.dword 		10000
>cb5f	e8 03 00 00					.dword 		1000
>cb63	64 00 00 00					.dword 		100
>cb67	0a 00 00 00					.dword 		10
.cb6b					_ITSSubtractorsEnd:
.cb6b					ITSOutputCharacter:
.cb6b	48		pha				pha
.cb6c	da		phx				phx
.cb6d	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.cb70	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.cb73	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cb75	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.cb78	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.cb7b	fa		plx				plx
.cb7c	68		pla				pla
.cb7d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cb7e					IntFromString:
.cb7e	a0 00		ldy #$00			ldy 	#0
.cb80	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.cb83					IntFromStringY:
.cb83	48		pha				pha
.cb84	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.cb86	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cb89	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb8c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb8f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb92	a9 01		lda #$01			lda 	#1
.cb94	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb97					_IFSLoop:
.cb97	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.cb99	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.cb9b	90 60		bcc $cbfd			bcc 	_IFSExit
.cb9d	c9 3a		cmp #$3a			cmp 	#"9"+1
.cb9f	b0 5c		bcs $cbfd			bcs 	_IFSExit
.cba1	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cba4	c9 0c		cmp #$0c			cmp 	#12
.cba6	b0 5f		bcs $cc07			bcs 	_IFSOverflow
.cba8	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cbab	48		pha				pha
.cbac	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cbaf	48		pha				pha
.cbb0	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cbb3	48		pha				pha
.cbb4	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cbb7	48		pha				pha
.cbb8	20 1c cc	jsr $cc1c			jsr 	IFSX1ShiftLeft 				; double
.cbbb	20 1c cc	jsr $cc1c			jsr 	IFSX1ShiftLeft 				; x 4
.cbbe	18		clc				clc 								; add saved value x 5
.cbbf	68		pla				pla
.cbc0	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cbc3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cbc6	68		pla				pla
.cbc7	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.cbca	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cbcd	68		pla				pla
.cbce	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.cbd1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cbd4	68		pla				pla
.cbd5	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.cbd8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cbdb	20 1c cc	jsr $cc1c			jsr 	IFSX1ShiftLeft 				; x 10
.cbde	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.cbe1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.cbe3	29 0f		and #$0f			and 	#15
.cbe5	c8		iny				iny
.cbe6	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cbe9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cbec	90 a9		bcc $cb97			bcc 	_IFSLoop
.cbee	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cbf1	d0 a4		bne $cb97			bne 	_IFSLoop
.cbf3	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.cbf6	d0 9f		bne $cb97			bne 	_IFSLoop
.cbf8	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.cbfb	80 9a		bra $cb97			bra 	_IFSLoop
.cbfd					_IFSExit:
.cbfd	98		tya				tya 								; get offset
.cbfe					_IFSOkay:
.cbfe	38		sec				sec
.cbff	ad 23 04	lda $0423			lda 	ExpTemp
.cc02	f0 01		beq $cc05			beq 	_IFSSkipFail
.cc04	18		clc				clc
.cc05					_IFSSkipFail:
.cc05	68		pla				pla 								; and exit.
.cc06	60		rts				rts
.cc07					_IFSOverflow:
.cc07	20 16 c4	jsr $c416			jsr 	ERR_Handler
>cc0a	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cc12	20 6f 76 65 72 66 6c 6f 77 00
.cc1c					IFSX1ShiftLeft:
.cc1c	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.cc1f	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.cc22	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.cc25	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.cc28	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.cc29					FPSubtract:
.cc29	48		pha				pha
.cc2a	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.cc2d	49 80		eor #$80			eor 	#$80
.cc2f	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.cc32	68		pla				pla 								; --- and fall through ---
.cc33					FPAdd:
.cc33	48		pha				pha
.cc34	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.cc37	d0 05		bne $cc3e			bne 	_FPA_NegativeLHS
.cc39	20 5b cc	jsr $cc5b			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cc3c	68		pla				pla
.cc3d	60		rts				rts
.cc3e					_FPA_NegativeLHS:
.cc3e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.cc41	49 80		eor #$80			eor 	#$80
.cc43	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc46	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.cc49	49 80		eor #$80			eor 	#$80
.cc4b	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.cc4e	20 5b cc	jsr $cc5b			jsr 	FPAdd_Worker 				; do the add calculation.
.cc51	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.cc54	49 80		eor #$80			eor 	#$80
.cc56	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc59	68		pla				pla
.cc5a	60		rts				rts
.cc5b					FPAdd_Worker:
.cc5b	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cc5e	70 08		bvs $cc68			bvs 	_FPAWExit 					; no change.
.cc60	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.cc63	50 07		bvc $cc6c			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.cc65	20 ee ce	jsr $ceee			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.cc68					_FPAWExit:
.cc68	20 76 cf	jsr $cf76			jsr 	FPUNormalise 				; normalise the result.
.cc6b	60		rts				rts
.cc6c					_FPAWMakeSame:
.cc6c	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.cc6f	38		sec				sec
.cc70	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cc73	f0 1b		beq $cc90			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cc75	da		phx				phx 								; save X
.cc76	90 06		bcc $cc7e			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cc78	e8		inx				inx
.cc79	e8		inx				inx
.cc7a	e8		inx				inx
.cc7b	e8		inx				inx
.cc7c	e8		inx				inx
.cc7d	e8		inx				inx
.cc7e					_FPAWShiftA:
.cc7e	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cc81	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cc84	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cc87	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cc8a	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cc8d	fa		plx				plx 								; restore original X
.cc8e	80 dc		bra $cc6c			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cc90					_FPAW_DoArithmetic:
.cc90	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cc93	30 39		bmi $ccce			bmi 	_FPAW_BNegative
.cc95	18		clc				clc
.cc96	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cc99	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cc9c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cc9f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cca2	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cca5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cca8	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ccab	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.ccae	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ccb1	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ccb4	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.ccb7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ccba	90 ac		bcc $cc68			bcc 	_FPAWExit 					; no carry.
.ccbc	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ccbf	38		sec				sec
.ccc0	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.ccc3	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ccc6	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ccc9	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cccc	80 9a		bra $cc68			bra 	_FPAWExit
.ccce					_FPAW_BNegative:
.ccce	38		sec				sec
.cccf	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ccd2	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.ccd5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ccd8	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ccdb	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.ccde	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cce1	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cce4	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cce7	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ccea	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cced	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.ccf0	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ccf3	b0 0b		bcs $cd00			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.ccf5	20 1b cf	jsr $cf1b			jsr 	FPUNegateInteger			; negate the mantissa
.ccf8	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.ccfb	49 80		eor #$80			eor 	#$80
.ccfd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd00					_FPAWGoExit:
.cd00	4c 68 cc	jmp $cc68			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cd03					FPD_IsDivZero:
.cd03	80 fe		bra $cd03		_error: bra _error
.cd05					FPDivide:
.cd05	48		pha				pha
.cd06	5a		phy				phy
.cd07	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.cd0a	70 f7		bvs $cd03			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cd0c	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cd0f	f0 03		beq $cd14			beq 	_FPDCalculateExp
.cd11					_FPD_Exit:
.cd11	7a		ply				ply
.cd12	68		pla				pla
.cd13	60		rts				rts
.cd14					_FPDCalculateExp:
.cd14	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cd17	49 ff		eor #$ff			eor 	#$FF
.cd19	1a		inc a				inc 	a
.cd1a	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.cd1d	20 11 ce	jsr $ce11			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cd20	18		clc				clc 	 							; add 1 to the resulting exponent
.cd21	69 01		adc #$01			adc 	#1
.cd23	b0 65		bcs $cd8a			bcs 	_FPD_Overflow 				; which can overflow.
.cd25	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cd28	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cd2a	85 1a		sta $1a				sta 	zLTemp1+0
.cd2c	85 1b		sta $1b				sta 	zLTemp1+1
.cd2e	85 1c		sta $1c				sta 	zLTemp1+2
.cd30	85 1d		sta $1d				sta 	zLTemp1+3
.cd32	a0 20		ldy #$20			ldy 	#32 						; times round.
.cd34					_FPD_Loop:
.cd34	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cd35	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.cd38	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.cd3b	48		pha				pha
.cd3c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cd3f	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cd42	48		pha				pha
.cd43	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cd46	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cd49	48		pha				pha
.cd4a	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cd4d	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cd50	90 17		bcc $cd69			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cd52	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cd55	68		pla				pla
.cd56	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd59	68		pla				pla
.cd5a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd5d	68		pla				pla
.cd5e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd61	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.cd63	09 80		ora #$80			ora 	#$80
.cd65	85 1d		sta $1d				sta 	zLTemp1+3
.cd67	80 03		bra $cd6c			bra 	_FPD_Rotates
.cd69					_FPD_NoSubtract:
.cd69	68		pla				pla 								; throw away unwanted results
.cd6a	68		pla				pla
.cd6b	68		pla				pla
.cd6c					_FPD_Rotates:
.cd6c	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.cd6f	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.cd72	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.cd75	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.cd78	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.cd7a	26 1b		rol $1b				rol 	zLTemp1+1
.cd7c	26 1c		rol $1c				rol 	zLTemp1+2
.cd7e	26 1d		rol $1d				rol 	zLTemp1+3
.cd80	90 02		bcc $cd84			bcc 	_FPD_NoCarry
.cd82	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.cd84					_FPD_NoCarry:
.cd84	88		dey				dey 								; do 32 times
.cd85	d0 ad		bne $cd34			bne 	_FPD_Loop
.cd87	4c ee cd	jmp $cdee			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cd8a					_FPD_Overflow:
.cd8a	4c eb cf	jmp $cfeb			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cd8d					FPMultiply:
.cd8d	48		pha				pha
.cd8e	5a		phy				phy
.cd8f	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cd92	70 08		bvs $cd9c			bvs 	_FPM_Exit
.cd94	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cd97	50 06		bvc $cd9f			bvc 	_FPM_CalcExponent
.cd99	20 ee ce	jsr $ceee			jsr 	FPUCopyX2ToX1
.cd9c					_FPM_Exit:
.cd9c	7a		ply				ply
.cd9d	68		pla				pla
.cd9e	60		rts				rts
.cd9f					_FPM_CalcExponent:
.cd9f	18		clc				clc
.cda0	20 11 ce	jsr $ce11			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cda3	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.cda6	a9 00		lda #$00			lda 	#0
.cda8	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cdaa	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cdac	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cdae	85 1d		sta $1d				sta 	zLTemp1+3
.cdb0	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cdb2					_FPM_Loop:
.cdb2	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.cdb5	29 01		and #$01			and 	#1
.cdb7	18		clc				clc 								; clear carry for the long rotate.
.cdb8	f0 1d		beq $cdd7			beq 	_FPM_NoAddition
.cdba	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cdbb	a5 1a		lda $1a				lda 	zLTemp1+0
.cdbd	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cdc0	85 1a		sta $1a				sta 	zLTemp1+0
.cdc2	a5 1b		lda $1b				lda 	zLTemp1+1
.cdc4	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cdc7	85 1b		sta $1b				sta 	zLTemp1+1
.cdc9	a5 1c		lda $1c				lda 	zLTemp1+2
.cdcb	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cdce	85 1c		sta $1c				sta 	zLTemp1+2
.cdd0	a5 1d		lda $1d				lda 	zLTemp1+3
.cdd2	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cdd5	85 1d		sta $1d				sta 	zLTemp1+3
.cdd7					_FPM_NoAddition:
.cdd7	66 1d		ror $1d				ror 	3+zLTemp1
.cdd9	66 1c		ror $1c				ror 	2+zLTemp1
.cddb	66 1b		ror $1b				ror 	1+zLTemp1
.cddd	66 1a		ror $1a				ror 	0+zLTemp1
.cddf	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cde2	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cde5	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cde8	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cdeb	88		dey				dey
.cdec	d0 c4		bne $cdb2			bne 	_FPM_Loop 					; do this 32 times.
.cdee					FPM_CopySignNormalize:
.cdee	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.cdf0	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.cdf3	a5 1b		lda $1b				lda 	zLTemp1+1
.cdf5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cdf8	a5 1c		lda $1c				lda 	zLTemp1+2
.cdfa	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cdfd	a5 1d		lda $1d				lda 	zLTemp1+3
.cdff	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce02	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.ce05	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.ce08	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce0b	20 76 cf	jsr $cf76			jsr 	FPUNormalise 				; normalise and exit.
.ce0e	7a		ply				ply
.ce0f	68		pla				pla
.ce10	60		rts				rts
.ce11					FPCalculateExponent:
.ce11	18		clc				clc
.ce12	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.ce15	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.ce18	b0 08		bcs $ce22			bcs 	_FPCECarry 					; carry out ?
.ce1a	10 03		bpl $ce1f			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.ce1c	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.ce1e	60		rts				rts
.ce1f					_FPCEExpZero:
.ce1f	a9 00		lda #$00			lda 	#0
.ce21	60		rts				rts
.ce22					_FPCECarry:
.ce22	30 03		bmi $ce27			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.ce24	09 80		ora #$80			ora 	#$80 						; put in right range
.ce26	60		rts				rts
.ce27					_FPCEOverflow:
.ce27	4c eb cf	jmp $cfeb			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.ce2a					FPFractionalPart:
.ce2a	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.ce2d	38		sec				sec 								; this flag tells us to keep the fractional part
.ce2e	30 0f		bmi $ce3f			bmi 	FPGetPart
.ce30	60		rts				rts
.ce31					FPIntegerPart:
.ce31	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.ce34	18		clc				clc 								; this flag says keep the integer part.
.ce35	30 08		bmi $ce3f			bmi 	FPGetPart 					; -ve exponents are 0..127
.ce37	48		pha				pha
.ce38	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.ce3a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce3d	68		pla				pla
.ce3e	60		rts				rts
.ce3f					FPGetPart:
.ce3f	48		pha				pha
.ce40	5a		phy				phy 								; save Y
.ce41	08		php				php 								; save action
.ce42	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.ce45	70 62		bvs $cea9			bvs 	_FPGP_Exit 					; then do nothing.
.ce47	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.ce49	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.ce4b	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.ce4d	85 1c		sta $1c				sta 	zLTemp1+2
.ce4f	85 1d		sta $1d				sta 	zLTemp1+3
.ce51	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.ce54	38		sec				sec
.ce55	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.ce57	f0 12		beq $ce6b			beq 	_FPGP_NoShift 				; ... if any
.ce59	c9 20		cmp #$20			cmp 	#32
.ce5b	90 02		bcc $ce5f			bcc 	_FPGP_NotMax
.ce5d	a9 20		lda #$20			lda 	#32 						; max of 32.
.ce5f					_FPGP_NotMax:
.ce5f	a8		tay				tay 								; Y is the mask shift count.
.ce60					_FPGP_ShiftMask:
.ce60	46 1d		lsr $1d				lsr 	3+zLTemp1
.ce62	66 1c		ror $1c				ror 	2+zLTemp1
.ce64	66 1b		ror $1b				ror 	1+zLTemp1
.ce66	66 1a		ror $1a				ror 	0+zLTemp1
.ce68	88		dey				dey
.ce69	d0 f5		bne $ce60			bne 	_FPGP_ShiftMask
.ce6b					_FPGP_NoShift:
.ce6b	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.ce6d	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.ce70					_FPGP_MaskLoop:
.ce70	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.ce73	28		plp				plp 								; if CC we keep the top part, so we
.ce74	08		php				php		 							; flip the mask.
.ce75	b0 02		bcs $ce79			bcs		_FPGP_NoFlip
.ce77	49 ff		eor #$ff			eor 	#$FF
.ce79					_FPGP_NoFlip:
.ce79	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.ce7c	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ce7f	e8		inx				inx
.ce80	c8		iny				iny
.ce81	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.ce83	d0 eb		bne $ce70			bne 	_FPGP_MaskLoop
.ce85	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.ce88	28		plp				plp
.ce89	08		php				php 								; get action flag on the stack
.ce8a	90 05		bcc $ce91			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.ce8c	a9 00		lda #$00			lda 	#0
.ce8e	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce91					_FPGP_NotFractional:
.ce91	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.ce94	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.ce97	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.ce9a	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.ce9d	f0 05		beq $cea4			beq 	_FPGP_Zero 					; if zero, return zero
.ce9f	20 76 cf	jsr $cf76			jsr 	FPUNormalise
.cea2	80 05		bra $cea9			bra 	_FPGP_Exit 					; and exit
.cea4					_FPGP_Zero:
.cea4	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cea6	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cea9					_FPGP_Exit:
.cea9	68		pla				pla 								; throw saved action flag.
.ceaa	7a		ply				ply
.ceab	68		pla				pla
.ceac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.cead					FPCompare:
.cead	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.ceb0	48		pha				pha
.ceb1	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.ceb4	48		pha				pha
.ceb5	20 29 cc	jsr $cc29			jsr 	FPSubtract 					; calculate X1-X2
.ceb8	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.cebb	70 2c		bvs $cee9			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.cebd	68		pla				pla
.cebe	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.cec1	68		pla				pla
.cec2	38		sec				sec
.cec3	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.cec6	70 15		bvs $cedd			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cec8	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cec9	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cecb	b0 10		bcs $cedd			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cecd	38		sec				sec
.cece	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.ced1	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.ced3	b0 02		bcs $ced7			bcs 	_FPCNotRange 				; keep in range.
.ced5	a9 01		lda #$01			lda 	#1
.ced7					_FPCNotRange:
.ced7	38		sec				sec
.ced8	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cedb	b0 0e		bcs $ceeb			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cedd					_FPCNotEqual:
.cedd	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cee0	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cee2	f0 02		beq $cee6			beq 	_FPCNE2
.cee4	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cee6	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cee7	80 04		bra $ceed			bra 	_FPCExit
.cee9					_FPCPullZero:
.cee9	68		pla				pla 								; throw saved exponents
.ceea	68		pla				pla
.ceeb					_FPCZero:
.ceeb	a9 00		lda #$00			lda 	#0 							; and return zero
.ceed					_FPCExit:
.ceed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.ceee					FPUCopyX2ToX1:
.ceee	48		pha				pha
.ceef	da		phx				phx
.cef0	5a		phy				phy
.cef1	a0 08		ldy #$08			ldy 	#8
.cef3	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.cef6	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cef9	e8		inx				inx
.cefa	88		dey				dey
.cefb	10 f6		bpl $cef3			bpl 	_FPUC21
.cefd	7a		ply				ply
.cefe	fa		plx				plx
.ceff	68		pla				pla
.cf00	60		rts				rts
.cf01					FPUSetInteger:
.cf01	48		pha				pha
.cf02	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cf05	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cf07	10 02		bpl $cf0b			bpl 	_FPUSIExtend
.cf09	a9 ff		lda #$ff			lda 	#$FF
.cf0b					_FPUSIExtend:
.cf0b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cf0e	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cf11	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cf14	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cf16	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf19	68		pla				pla
.cf1a	60		rts				rts
.cf1b					FPUNegateInteger:
.cf1b	48		pha				pha
.cf1c	38		sec				sec
.cf1d	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cf1f	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cf22	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cf25	a9 00		lda #$00			lda 	#0
.cf27	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cf2a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cf2d	a9 00		lda #$00			lda 	#0
.cf2f	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cf32	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cf35	a9 00		lda #$00			lda 	#0
.cf37	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cf3a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cf3d	68		pla				pla
.cf3e	60		rts				rts
.cf3f					FPUToFloat:
.cf3f	48		pha				pha
.cf40	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.cf43	29 0f		and #$0f			and 	#$0F
.cf45	f0 2d		beq $cf74			beq 	_FPUFExit
.cf47	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cf49	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf4c	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cf4e	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.cf51	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cf54	10 08		bpl $cf5e			bpl		_FPUFPositive
.cf56	20 1b cf	jsr $cf1b			jsr 	FPUNegateInteger 			; negate the mantissa
.cf59	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cf5b	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf5e					_FPUFPositive:
.cf5e	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cf61	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cf64	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cf67	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cf6a	d0 05		bne $cf71			bne 	_FPUFNonZero
.cf6c	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cf6e	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf71					_FPUFNonZero:
.cf71	20 76 cf	jsr $cf76			jsr 	FPUNormalise 				; normalise the floating point.
.cf74					_FPUFExit:
.cf74	68		pla				pla
.cf75	60		rts				rts
.cf76					FPUNormalise:
.cf76	48		pha				pha
.cf77	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cf7a	70 20		bvs $cf9c			bvs 	_FPUNExit
.cf7c	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cf7f	f0 16		beq $cf97			beq 	_FPUNSetZero
.cf81					_FPUNLoop:
.cf81	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cf84	30 16		bmi $cf9c			bmi 	_FPUNExit 					; if so, we are normalised.
.cf86	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.cf89	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.cf8c	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.cf8f	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.cf92	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.cf95	d0 ea		bne $cf81			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cf97					_FPUNSetZero:
.cf97	a9 40		lda #$40			lda 	#$40
.cf99	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.cf9c					_FPUNExit:
.cf9c	68		pla				pla
.cf9d	60		rts				rts
.cf9e					FPUToInteger:
.cf9e	48		pha				pha
.cf9f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.cfa2	29 01		and #$01			and 	#1
.cfa4	d0 3e		bne $cfe4			bne 	_FPUTOI_Exit
.cfa6	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.cfa9	70 2b		bvs $cfd6			bvs 	_FPUTOI_Zero
.cfab	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.cfae	10 26		bpl $cfd6			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.cfb0	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.cfb2	b0 37		bcs $cfeb			bcs 	FP_Overflow
.cfb4					_FPUToIToInteger:
.cfb4	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.cfb7	c9 a0		cmp #$a0			cmp 	#128+32
.cfb9	f0 11		beq $cfcc			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.cfbb	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.cfbe	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cfc1	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cfc4	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cfc7	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cfca	80 e8		bra $cfb4			bra 	_FPUToIToInteger 			; keep going.
.cfcc					_FPUToICheckSign:
.cfcc	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.cfcf	10 13		bpl $cfe4			bpl 	_FPUToI_Exit 				; exit if unsigned.
.cfd1	20 1b cf	jsr $cf1b			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.cfd4	80 0e		bra $cfe4			bra 	_FPUTOI_Exit
.cfd6					_FPUTOI_Zero:
.cfd6	a9 00		lda #$00			lda 	#0 							; return zero integer.
.cfd8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cfdb	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cfde	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cfe1	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cfe4					_FPUToI_Exit:
.cfe4	a9 01		lda #$01			lda 	#1 							; set type to integer
.cfe6	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cfe9	68		pla				pla
.cfea	60		rts				rts
.cfeb					FP_Overflow:
.cfeb	80 fe		bra $cfeb		_error: bra _error
.cfed					FPUTimes10:
.cfed	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.cff0	85 1a		sta $1a				sta 	ZLTemp1+0
.cff2	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cff5	85 1b		sta $1b				sta 	ZLTemp1+1
.cff7	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cffa	85 1c		sta $1c				sta 	ZLTemp1+2
.cffc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cfff	85 1d		sta $1d				sta 	ZLTemp1+3
.d001	20 45 d0	jsr $d045			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.d004	20 45 d0	jsr $d045			jsr 	_FPUT_LSR_ZLTemp1
.d007	18		clc				clc
.d008	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.d00b	65 1a		adc $1a				adc 	ZLTemp1+0
.d00d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d010	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.d013	65 1b		adc $1b				adc 	ZLTemp1+1
.d015	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d018	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.d01b	65 1c		adc $1c				adc 	ZLTemp1+2
.d01d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d020	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.d023	65 1d		adc $1d				adc 	ZLTemp1+3
.d025	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d028	90 0f		bcc $d039			bcc 	_FPUTimes10
.d02a	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.d02d	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.d030	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.d033	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.d036	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.d039					_FPUTimes10:
.d039	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.d03c	18		clc				clc
.d03d	69 03		adc #$03			adc 	#3
.d03f	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.d042	b0 a7		bcs $cfeb			bcs 	FP_Overflow 				; error
.d044	60		rts				rts
.d045					_FPUT_LSR_ZLTemp1:
.d045	46 1d		lsr $1d				lsr 	ZLTemp1+3
.d047	66 1c		ror $1c				ror 	ZLTemp1+2
.d049	66 1b		ror $1b				ror 	ZLTemp1+1
.d04b	66 1a		ror $1a				ror 	ZLTemp1+0
.d04d	60		rts				rts
.d04e					FPUScale10A:
.d04e	5a		phy				phy
.d04f	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.d051	f0 3d		beq $d090			beq 	_FPUScaleExit
.d053	da		phx				phx 								; save X
.d054	e8		inx				inx
.d055	e8		inx				inx
.d056	e8		inx				inx
.d057	e8		inx				inx
.d058	e8		inx				inx
.d059	e8		inx				inx
.d05a	a8		tay				tay 								; save power scalar in Y.
.d05b	a9 00		lda #$00			lda 	#0
.d05d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.d060	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d063	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d066	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d069	a9 80		lda #$80			lda 	#$80
.d06b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d06e	a9 81		lda #$81			lda 	#$81
.d070	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.d073	5a		phy				phy 								; save 10^n on stack.
.d074	c0 00		cpy #$00			cpy 	#0
.d076	10 05		bpl $d07d			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.d078	98		tya				tya
.d079	49 ff		eor #$ff			eor 	#$FF
.d07b	1a		inc a				inc 	a
.d07c	a8		tay				tay
.d07d					_FPUSAbs:
.d07d	20 ed cf	jsr $cfed			jsr 	FPUTimes10
.d080	88		dey				dey
.d081	d0 fa		bne $d07d			bne 	_FPUSAbs 					; tos is now 10^|AC|
.d083	68		pla				pla 								; restore count in A
.d084	fa		plx				plx 								; restore X pointing to number to scale.
.d085	0a		asl a				asl 	a
.d086	b0 05		bcs $d08d			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.d088	20 8d cd	jsr $cd8d			jsr 	FPMultiply 					; if clear multiply.
.d08b	80 03		bra $d090			bra		_FPUScaleExit
.d08d					_FPUSDivide:
.d08d	20 05 cd	jsr $cd05			jsr 	FPDivide
.d090					_FPUScaleExit:
.d090	7a		ply				ply
.d091	60		rts				rts
.d092					FPUCopyToNext:
.d092	a0 06		ldy #$06			ldy 		#6
.d094	da		phx				phx
.d095					_FPUCopy1:
.d095	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.d098	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.d09b	e8		inx				inx
.d09c	88		dey				dey
.d09d	d0 f6		bne $d095			bne 	_FPUCopy1
.d09f	fa		plx				plx
.d0a0	60		rts				rts
.d0a1					FPUCopyFromNext:
.d0a1	a0 06		ldy #$06			ldy 		#6
.d0a3	da		phx				phx
.d0a4					_FPUCopy1:
.d0a4	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.d0a7	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.d0aa	e8		inx				inx
.d0ab	88		dey				dey
.d0ac	d0 f6		bne $d0a4			bne 	_FPUCopy1
.d0ae	fa		plx				plx
.d0af	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.d0b0					FPToString:
.d0b0	48		pha				pha
.d0b1	5a		phy				phy
.d0b2	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.d0b5	50 0a		bvc $d0c1			bvc 		_FPTSIsFloat 			; if zero,
.d0b7					_FPTSZero:
.d0b7	a9 30		lda #$30			lda 		#"0"
.d0b9	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter
.d0bc					_FPTSExit:
.d0bc	7a		ply				ply
.d0bd	68		pla				pla
.d0be	60		rts				rts
.d0bf	80 fb		bra $d0bc			bra 		_FPTSExit
.d0c1					_FPTSIsFloat:
.d0c1	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.d0c4	10 0a		bpl $d0d0			bpl 		_FPTSNotSigned
.d0c6	a9 00		lda #$00			lda 		#0 						; clear sign flag
.d0c8	9d 05 03	sta $0305,x			sta 		XS_Type,x
.d0cb	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d0cd	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter
.d0d0					_FPTSNotSigned:
.d0d0	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.d0d3	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.d0d5	b0 09		bcs $d0e0			bcs 		_FPTSExponent
.d0d7	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.d0d9	90 05		bcc $d0e0			bcc 		_FPTSExponent 			;
.d0db					_FPTSStandard:
.d0db	20 24 d1	jsr $d124			jsr 		FPTOutputBody 			; output the body.
.d0de	80 dc		bra $d0bc			bra 		_FPTSExit
.d0e0					_FPTSExponent:
.d0e0	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.d0e2	8d 24 04	sta $0424			sta 		ExpCount
.d0e5					_FPTSExponentLoop:
.d0e5	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.d0e8	10 0e		bpl $d0f8			bpl 		_FPTSTimes
.d0ea	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.d0ec	90 14		bcc $d102			bcc 		_FPTSScaledToExp
.d0ee	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.d0f0	20 4e d0	jsr $d04e			jsr 		FPUScale10A
.d0f3	ee 24 04	inc $0424			inc 		ExpCount
.d0f6	80 ed		bra $d0e5			bra 		_FPTSExponentLoop
.d0f8					_FPTSTimes:
.d0f8	a9 01		lda #$01			lda 		#1
.d0fa	20 4e d0	jsr $d04e			jsr 		FPUScale10A
.d0fd	ce 24 04	dec $0424			dec 		ExpCount
.d100	80 e3		bra $d0e5			bra 		_FPTSExponentLoop
.d102					_FPTSScaledToExp:
.d102	20 24 d1	jsr $d124			jsr 		FPTOutputBody 			; output the body.
.d105	a9 65		lda #$65			lda 		#"e"					; output E
.d107	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter
.d10a	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.d10d	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.d110	29 80		and #$80			and 		#$80 					; sign extend it
.d112	f0 02		beq $d116			beq 		_FPTSSExt
.d114	a9 ff		lda #$ff			lda 		#$FF
.d116					_FPTSSExt:
.d116	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.d119	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.d11c	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.d11f	20 cf ca	jsr $cacf			jsr 		INTToString 			; output the exponent.
.d122	80 98		bra $d0bc			bra			_FPTSExit 				; and exit.
.d124					FPTOutputBody:
.d124	20 92 d0	jsr $d092			jsr 		FPUCopyToNext 			; copy to next slot.
.d127	20 9e cf	jsr $cf9e			jsr 		FPUToInteger 			; convert to an integer
.d12a	20 cf ca	jsr $cacf			jsr 		INTToString 			; output the main integer part.
.d12d	20 a1 d0	jsr $d0a1			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d130	20 2a ce	jsr $ce2a			jsr 		FPFractionalPart 		; get the decimal part.
.d133	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.d136	70 3e		bvs $d176			bvs 		_FPTOExit 				; if not, exit now.
.d138	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d13a	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter
.d13d					_FPOutLoop:
.d13d	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.d140	70 1e		bvs $d160			bvs 		_FPStripZeros 			; strip trailing zeros
.d142	20 ed cf	jsr $cfed			jsr 		FPUTimes10 				; multiply by 10
.d145	20 92 d0	jsr $d092			jsr 		FPUCopyToNext			; copy to next slot.
.d148	20 9e cf	jsr $cf9e			jsr 		FPUToInteger 			; convert to integer
.d14b	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.d14e	09 30		ora #$30			ora 		#"0"
.d150	20 6b cb	jsr $cb6b			jsr 		ITSOutputCharacter
.d153	20 a1 d0	jsr $d0a1			jsr 		FPUCopyFromNext 		; get it back
.d156	20 2a ce	jsr $ce2a			jsr 		FPFractionalPart 		; get fractional part
.d159	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.d15c	c9 0b		cmp #$0b			cmp 	 	#11
.d15e	90 dd		bcc $d13d			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d160					_FPStripZeros:
.d160	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.d163					_FPStripLoop:
.d163	88		dey				dey 								; back one, if at start then no strip
.d164	f0 10		beq $d176			beq 		_FPToExit
.d166	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.d169	c9 30		cmp #$30			cmp 		#"0"
.d16b	f0 f6		beq $d163			beq 		_FPStripLoop
.d16d	c8		iny				iny
.d16e	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d170	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.d173	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.d176					_FPTOExit:
.d176	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d177					FPFromString:
.d177	48		pha				pha 								; push A
.d178	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d17a	c9 2e		cmp #$2e			cmp 	#"."
.d17c	f0 03		beq $d181			beq	 	_FPFIsDecimal
.d17e	4c e4 d1	jmp $d1e4			jmp 	_FPFNotDecimal
.d181					_FPFIsDecimal:
.d181	c8		iny				iny 								; consume the decimal.
.d182	20 3f cf	jsr $cf3f			jsr 	FPUToFloat 					; convert the integer to float.
.d185	da		phx				phx 								; save X.
.d186	5a		phy				phy 								; save decimal start position
.d187	e8		inx				inx
.d188	e8		inx				inx
.d189	e8		inx				inx
.d18a	e8		inx				inx
.d18b	e8		inx				inx
.d18c	e8		inx				inx
.d18d	20 83 cb	jsr $cb83			jsr 	INTFromStringY 				; get the part after the DP.
.d190	20 3f cf	jsr $cf3f			jsr 	FPUToFloat 					; convert that to a float.
.d193	68		pla				pla 								; calculate - chars consumed.
.d194	8c 23 04	sty $0423			sty 	ExpTemp
.d197	38		sec				sec
.d198	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.d19b	20 4e d0	jsr $d04e			jsr 	FPUScale10A 				; scale it by 10^AC
.d19e	fa		plx				plx 								; restore original X
.d19f	20 33 cc	jsr $cc33			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d1a2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.d1a4	c9 45		cmp #$45			cmp 	#"E"
.d1a6	f0 04		beq $d1ac			beq 	_FPFExponent
.d1a8	c9 65		cmp #$65			cmp 	#"e"
.d1aa	d0 38		bne $d1e4			bne 	_FPFNotDecimal 				; no, then exit normally.
.d1ac					_FPFExponent:
.d1ac	c8		iny				iny 								; skip over E symbol.
.d1ad	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.d1af	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d1b1	d0 01		bne $d1b4			bne 	_FPFGotSign
.d1b3	c8		iny				iny 								; if it was - skip over it.
.d1b4					_FPFGotSign:
.d1b4	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d1b5	da		phx				phx
.d1b6	e8		inx				inx
.d1b7	e8		inx				inx
.d1b8	e8		inx				inx
.d1b9	e8		inx				inx
.d1ba	e8		inx				inx
.d1bb	e8		inx				inx
.d1bc	20 83 cb	jsr $cb83			jsr 	INTFromStringY 				; get the exponent
.d1bf	fa		plx				plx 								; restore X.
.d1c0	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d1c3	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.d1c6	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.d1c9	d0 1b		bne $d1e6			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d1cb	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d1ce	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d1d0	b0 14		bcs $d1e6			bcs 	_FPFXOverflow
.d1d2	68		pla				pla 								; get direction
.d1d3	d0 09		bne $d1de			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d1d5	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d1d8	49 ff		eor #$ff			eor 	#$FF
.d1da	1a		inc a				inc 	a
.d1db	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.d1de					_FPFXScale:
.d1de	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d1e1	20 4e d0	jsr $d04e			jsr 	FPUScale10A 				; scale by the exponent.
.d1e4					_FPFNotDecimal:
.d1e4	68		pla				pla
.d1e5	60		rts				rts
.d1e6					_FPFXOverflow:
.d1e6	20 16 c4	jsr $c416			jsr 	ERR_Handler
>d1e9	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d1f1	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.d1f8					Unary_Rnd:
.d1f8	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.d1fb	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; check right bracket.
.d1fe	20 87 c8	jsr $c887			jsr 	GetSignCurrent 				; get sign -1,0,1.
.d201	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.d203	30 10		bmi $d215			bmi 	_URSetSeed
.d205	f0 2c		beq $d233			beq 	_URMakeRandom 				; if zero return same number.
.d207	da		phx				phx
.d208	a2 00		ldx #$00			ldx 	#0
.d20a	20 70 d2	jsr $d270			jsr 	Random16
.d20d	a2 02		ldx #$02			ldx 	#2
.d20f	20 70 d2	jsr $d270			jsr 	Random16
.d212	fa		plx				plx
.d213	80 1e		bra $d233			bra 	_URMakeRandom
.d215					_URSetSeed:
.d215	20 3f cf	jsr $cf3f			jsr 	FPUToFloat 					; make it a float to twiddle it.
.d218	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.d21b	8d 28 04	sta $0428			sta 	RandomSeed+0
.d21e	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.d221	8d 29 04	sta $0429			sta 	RandomSeed+1
.d224	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.d227	8d 2a 04	sta $042a			sta 	RandomSeed+2
.d22a	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.d22d	0a		asl a				asl 	a
.d22e	49 db		eor #$db			eor 	#$DB
.d230	8d 2b 04	sta $042b			sta 	RandomSeed+3
.d233					_URMakeRandom:
.d233	ad 28 04	lda $0428			lda 	RandomSeed+0 				; check if seed is zero.
.d236	0d 29 04	ora $0429			ora 	RandomSeed+1
.d239	0d 2a 04	ora $042a			ora 	RandomSeed+2
.d23c	0d 2b 04	ora $042b			ora 	RandomSeed+3
.d23f	d0 0a		bne $d24b			bne 	_URNotZero
.d241	a9 47		lda #$47			lda 	#$47
.d243	8d 29 04	sta $0429			sta 	RandomSeed+1				; if it is, make it non zero.
.d246	a9 3d		lda #$3d			lda 	#$3D
.d248	8d 2b 04	sta $042b			sta 	RandomSeed+3
.d24b					_URNotZero:
.d24b	ad 28 04	lda $0428			lda 	RandomSeed+0 				; copy seed into mantissa.
.d24e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d251	ad 29 04	lda $0429			lda 	RandomSeed+1
.d254	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d257	ad 2a 04	lda $042a			lda 	RandomSeed+2
.d25a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d25d	ad 2b 04	lda $042b			lda 	RandomSeed+3
.d260	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d263	a9 00		lda #$00			lda 	#$00 						; set type to float.
.d265	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d268	a9 80		lda #$80			lda 	#$80
.d26a	9d 04 03	sta $0304,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.d26d	4c 76 cf	jmp $cf76			jmp 	FPUNormalise
.d270					Random16:
.d270	5e 29 04	lsr $0429,x			lsr 	RandomSeed+1,x				; shift seed right
.d273	7e 28 04	ror $0428,x			ror 	RandomSeed,x
.d276	90 08		bcc $d280			bcc 	_R16_NoXor
.d278	bd 29 04	lda $0429,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.d27b	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.d27d	9d 29 04	sta $0429,x			sta 	RandomSeed+1,x
.d280					_R16_NoXor:
.d280	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.d281					Unary_Int:
.d281	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.d284	20 5f c9	jsr $c95f			jsr 	CheckNextRParen 			; check right bracket.
.d287	4c 9e cf	jmp $cf9e			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.d28a					TIM_Error:
.d28a	20 37 c2	jsr $c237			jsr 	IFT_UpLine 					; go up one line.
.d28d	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.d28f	80 02		bra $d293			bra 	TIM_ShowPrompt
.d291					TIM_NewCommand:
.d291	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.d293					TIM_ShowPrompt:
.d293	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.d296	20 fb c2	jsr $c2fb			jsr 	IFT_ReadLine	 			; get character, go to next line
.d299	20 5d c2	jsr $c25d			jsr 	IFT_NewLine					; go to next line.
.d29c	86 10		stx $10				stx 	zTemp1 						; save line read address
.d29e	84 11		sty $11				sty 	zTemp1+1
.d2a0	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.d2a2	b1 10		lda ($10),y			lda 	(zTemp1),y
.d2a4	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.d2a6	d0 01		bne $d2a9			bne 	TIM_NotDot
.d2a8	c8		iny				iny
.d2a9					TIM_NotDot:
.d2a9	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.d2ab	c9 52		cmp #$52			cmp 	#"R"						; show registers
.d2ad	f0 6b		beq $d31a			beq 	TIM_ShowRegisters
.d2af	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.d2b1	f0 12		beq $d2c5			beq 	TIM_ShowMemory
.d2b3	c9 47		cmp #$47			cmp 	#"G"						; execute
.d2b5	f0 49		beq $d300			beq 	TIM_Execute
.d2b7	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.d2b9	f0 07		beq $d2c2			beq 	TIM_GoLoadMemory
.d2bb	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.d2bd	d0 cb		bne $d28a			bne 	TIM_Error
.d2bf	4c 3d d4	jmp $d43d			jmp 	TIM_UpdateRegisters
.d2c2					TIM_GoLoadMemory:
.d2c2	4c 6d d4	jmp $d46d			jmp 	TIM_LoadMemory
.d2c5					TIM_ShowMemory:
.d2c5	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d2c8	b0 c0		bcs $d28a			bcs 	TIM_Error
.d2ca	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.d2cc	85 12		sta $12				sta 	zTemp2
.d2ce	a5 15		lda $15				lda 	zTemp3+1
.d2d0	85 13		sta $13				sta 	zTemp2+1
.d2d2	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d2d5	90 08		bcc $d2df			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.d2d7	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.d2d9	85 14		sta $14				sta 	zTemp3
.d2db	a5 13		lda $13				lda 	zTemp2+1
.d2dd	85 15		sta $15				sta 	zTemp3+1
.d2df					_TIMSM_Start:
.d2df	20 91 d3	jsr $d391			jsr 	TIM_WriteLine 				; write one line of hex out
.d2e2	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.d2e4	18		clc				clc
.d2e5	69 10		adc #$10			adc 	#16
.d2e7	85 12		sta $12				sta 	zTemp2
.d2e9	90 02		bcc $d2ed			bcc 	_TIMSM_NoCarry
.d2eb	e6 13		inc $13				inc 	zTemp2+1
.d2ed					_TIMSM_NoCarry:
.d2ed	20 e2 c3	jsr $c3e2			jsr 	IF_CheckBreak 				; check CTL+C
.d2f0	d0 0b		bne $d2fd			bne 	_TIMSM_Ends 				; if pressed break out.
.d2f2	38		sec				sec 								; check past the end address in zTemp3
.d2f3	a5 14		lda $14				lda 	zTemp3
.d2f5	e5 12		sbc $12				sbc 	zTemp2
.d2f7	a5 15		lda $15				lda 	zTemp3+1
.d2f9	e5 13		sbc $13				sbc 	zTemp2+1
.d2fb	10 e2		bpl $d2df			bpl 	_TIMSM_Start
.d2fd					_TIMSM_Ends:
.d2fd	4c 91 d2	jmp $d291			jmp 	TIM_NewCommand
.d300					TIM_Execute:
.d300	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; get the execute address
.d303	b0 85		bcs $d28a			bcs 	TIM_Error 					; not legitimate
.d305	ae 35 04	ldx $0435			ldx 	TIM_SP 						; set up SP
.d308	9a		txs				txs
.d309	ad 30 04	lda $0430			lda 	TIM_SR 						; Status for PLP
.d30c	48		pha				pha
.d30d	ad 31 04	lda $0431			lda 	TIM_A 						; restore AXYZ
.d310	ae 32 04	ldx $0432			ldx 	TIM_X
.d313	ac 33 04	ldy $0433			ldy 	TIM_Y
.d316	28		plp				plp 								; and PS Byte.
.d317	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.d31a					TIM_Start:
.d31a					TIM_ShowRegisters:
.d31a	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.d31d	8d 2f 04	sta $042f			sta 	TIM_IRQ+1
.d320	ad ff ff	lda $ffff			lda 	$FFFF
.d323	8d 2e 04	sta $042e			sta 	TIM_IRQ
.d326	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.d328					_TIMSR_Text:
.d328	bd 58 d3	lda $d358,x			lda 	_TIMSR_Label,x
.d32b	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d32e	e8		inx				inx
.d32f	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.d331	d0 f5		bne $d328			bne 	_TIMSR_Text
.d333	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.d335					_TIMSR_Skip:
.d335	e8		inx				inx
.d336					_TIMSR_LoopSpace:
.d336	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.d338	b0 04		bcs $d33e			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.d33a	8a		txa				txa
.d33b	4a		lsr a				lsr 	a
.d33c	b0 05		bcs $d343			bcs 	_TIMSR_NoSpace
.d33e					_TIMSR_Space:
.d33e	a9 20		lda #$20			lda 	#" "
.d340	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d343					_TIMSR_NoSpace:
.d343	bd 2c 04	lda $042c,x			lda 	TIM_PC,x 					; output hex value.
.d346	20 78 d3	jsr $d378			jsr 	TIM_WriteHex
.d349	e8		inx				inx
.d34a	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.d34c	f0 e7		beq $d335			beq 	_TIMSR_Skip
.d34e	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.d350	d0 e4		bne $d336			bne 	_TimSR_LoopSpace
.d352	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; new line
.d355	4c 91 d2	jmp $d291			jmp	 	TIM_NewCommand 				; new command.
.d358					_TIMSR_Label:
>d358	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>d360	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>d370	52
>d371	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.d378					_TIMSR_LabelEnd:
.d378					TIM_WriteHex:
.d378	48		pha				pha 								; save A
.d379	4a		lsr a				lsr 	a 							; shift MSB->LSB
.d37a	4a		lsr a				lsr 	a
.d37b	4a		lsr a				lsr 	a
.d37c	4a		lsr a				lsr 	a
.d37d	20 81 d3	jsr $d381			jsr 	_TIMWH_Nibble 				; print MSB
.d380	68		pla				pla 								; restore and print LSB
.d381					_TIMWH_Nibble:
.d381	48		pha				pha
.d382	29 0f		and #$0f			and 	#15 						; mask out
.d384	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.d386	90 02		bcc $d38a			bcc 	_TIMWHNoLetter
.d388	69 06		adc #$06			adc 	#6
.d38a					_TIMWHNoLetter:
.d38a	69 30		adc #$30			adc 	#48
.d38c	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter 			; print it out.
.d38f	68		pla				pla
.d390	60		rts				rts
.d391					TIM_WriteLine:
.d391	a9 2e		lda #$2e			lda 	#"." 						; prompt
.d393	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d396	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.d398	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d39b	a5 13		lda $13				lda 	zTemp2+1 					; write address
.d39d	20 78 d3	jsr $d378			jsr 	TIM_WriteHex
.d3a0	a5 12		lda $12				lda 	zTemp2
.d3a2	20 78 d3	jsr $d378			jsr 	TIM_WriteHex
.d3a5	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.d3a7					_TIMWL_Loop:
.d3a7	a9 20		lda #$20			lda 	#" "
.d3a9	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d3ac	b1 12		lda ($12),y			lda 	(zTemp2),y
.d3ae	20 78 d3	jsr $d378			jsr 	TIM_WriteHex
.d3b1	c8		iny				iny
.d3b2	c0 10		cpy #$10			cpy 	#16
.d3b4	d0 f1		bne $d3a7			bne 	_TIMWL_Loop
.d3b6	4c 5d c2	jmp $c25d			jmp 	IFT_NewLine 				; new line and exit
.d3b9					TIM_GetHex:
.d3b9	c8		iny				iny
.d3ba	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.d3bc	c9 20		cmp #$20			cmp 	#32
.d3be	f0 f9		beq $d3b9			beq 	TIM_GetHex
.d3c0	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.d3c2	f0 f5		beq $d3b9			beq 	TIM_GetHex
.d3c4	20 ed d3	jsr $d3ed			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.d3c7	b0 23		bcs $d3ec			bcs 	_TIMGH_Exit					; if first bad then exit now.
.d3c9	a9 00		lda #$00			lda 	#0 							; zero result
.d3cb	85 14		sta $14				sta 	zTemp3
.d3cd	85 15		sta $15				sta 	zTemp3+1
.d3cf					_TIM_GHLoop:
.d3cf	20 ed d3	jsr $d3ed			jsr 	TIM_GetHexCharacter 		; get next character
.d3d2	b0 17		bcs $d3eb			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.d3d4	c8		iny				iny 								; skip over it.
.d3d5	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.d3d7	26 15		rol $15				rol 	zTemp3+1
.d3d9	06 14		asl $14				asl 	zTemp3 						; now x 2
.d3db	26 15		rol $15				rol 	zTemp3+1
.d3dd	06 14		asl $14				asl 	zTemp3						; now x 4
.d3df	26 15		rol $15				rol 	zTemp3+1
.d3e1	06 14		asl $14				asl 	zTemp3 						; now x 8
.d3e3	26 15		rol $15				rol 	zTemp3+1
.d3e5	05 14		ora $14				ora 	zTemp3 						; OR result in
.d3e7	85 14		sta $14				sta 	zTemp3
.d3e9	80 e4		bra $d3cf			bra 	_TIM_GHLoop 				; loop round again.
.d3eb					_TIMGH_Okay:
.d3eb	18		clc				clc
.d3ec					_TIMGH_Exit:
.d3ec	60		rts				rts
.d3ed					TIM_GetHexCharacter:
.d3ed	b1 10		lda ($10),y			lda 	(zTemp1),y
.d3ef	38		sec				sec
.d3f0	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d3f2	90 0e		bcc $d402			bcc 	_TIM_GHCFail
.d3f4	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d3f6	90 0b		bcc $d403			bcc 	_TIM_GHCExit
.d3f8	c9 11		cmp #$11			cmp 	#65-48						; < A
.d3fa	90 06		bcc $d402			bcc		_TIM_GHCFail
.d3fc	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d3fe	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d400	90 01		bcc $d403			bcc		_TIM_GHCExit
.d402					_TIM_GHCFail:
.d402	38		sec				sec
.d403					_TIM_GHCExit:
.d403	60		rts				rts
.d404					TIM_BreakVector:
.d404	da		phx				phx									; save X/A on stack
.d405	48		pha				pha
.d406	ba		tsx				tsx 								; X points to S
.d407	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d40a	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d40c	d0 03		bne $d411			bne 	_TIMBreak					; if set, it's BRK
.d40e	68		pla				pla 								; abandon routine.
.d40f	fa		plx				plx
.d410	40		rti				rti
.d411					_TIMBreak:
.d411	68		pla				pla 								; save A X Y and maybe Z
.d412	8d 31 04	sta $0431			sta 	TIM_A
.d415	fa		plx				plx
.d416	8e 32 04	stx $0432			stx 	TIM_X
.d419	8c 33 04	sty $0433			sty 	TIM_Y
.d41c	68		pla				pla 								; get Status Register
.d41d	8d 30 04	sta $0430			sta 	TIM_SR
.d420	68		pla				pla
.d421	8d 2d 04	sta $042d			sta 	TIM_PC+1 					; save calling address
.d424	68		pla				pla
.d425	8d 2c 04	sta $042c			sta 	TIM_PC 						; high byte
.d428	ad 2d 04	lda $042d			lda 	TIM_PC+1 					; dec PC to point right.
.d42b	d0 03		bne $d430			bne 	_TIMDecrement 				; brk bumps it.
.d42d	ce 2c 04	dec $042c			dec 	TIM_PC
.d430					_TIMDecrement:
.d430	ce 2d 04	dec $042d			dec 	TIM_PC+1
.d433	ba		tsx				tsx 								; and copy SP
.d434	8e 35 04	stx $0435			stx 	TIM_SP
.d437	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d439	9a		txs				txs
.d43a	4c 1a d3	jmp $d31a			jmp 	TIM_Start 					; and start up TIM monitor.
.d43d					TIM_UpdateRegisters:
.d43d	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; PC
.d440	b0 28		bcs $d46a			bcs 	_TIMURFail
.d442	a5 14		lda $14				lda 	zTemp3
.d444	8d 2d 04	sta $042d			sta 	Tim_PC+1
.d447	a5 15		lda $15				lda 	zTemp3+1
.d449	8d 2c 04	sta $042c			sta 	Tim_PC
.d44c	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; ignore IRQ
.d44f	b0 19		bcs $d46a			bcs 	_TIMURFail
.d451	a2 00		ldx #$00			ldx 	#0
.d453					_TIM_URLoop:
.d453	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d455	d0 01		bne $d458			bne 	_TIM_1
.d457	e8		inx				inx
.d458					_TIM_1:
.d458	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; registers
.d45b	b0 0d		bcs $d46a			bcs 	_TIMURFail
.d45d	a5 14		lda $14				lda 	zTemp3
.d45f	9d 30 04	sta $0430,x			sta 	Tim_SR,x
.d462	e8		inx				inx
.d463	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d465	d0 ec		bne $d453			bne 	_TIM_URLoop
.d467	4c 91 d2	jmp $d291			jmp 	TIM_NewCommand
.d46a					_TIMURFail:
.d46a	4c 8a d2	jmp $d28a			jmp 	TIM_Error
.d46d					TIM_LoadMemory:
.d46d	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; target address => zTemp2
.d470	a5 14		lda $14				lda 	zTemp3
.d472	85 12		sta $12				sta 	zTemp2
.d474	a5 15		lda $15				lda 	zTemp3+1
.d476	85 13		sta $13				sta 	zTemp2+1
.d478					_TIM_LMLoop:
.d478	20 b9 d3	jsr $d3b9			jsr 	TIM_GetHex 					; next byte ?
.d47b	b0 0e		bcs $d48b			bcs 	_TIMLMDone 					; no more
.d47d	a2 00		ldx #$00			ldx 	#0							; write out.
.d47f	a5 14		lda $14				lda 	zTemp3
.d481	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d483	e6 12		inc $12				inc 	zTemp2 						; bump address
.d485	d0 f1		bne $d478			bne 	_TIM_LMLoop
.d487	e6 13		inc $13				inc 	zTemp2+1
.d489	80 ed		bra $d478			bra 	_TIM_LMLoop
.d48b					_TIMLMDone:
.d48b	4c 91 d2	jmp $d291			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d48e	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	f2 c1						.word 	StartROM
>fffe	04 d4					.word TIM_BreakVector

;******  End of listing
