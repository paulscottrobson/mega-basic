
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 24 12:17:05 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					NumBufX 	.byte 	?						; buffer index position
>0401					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0428					TempStringWriteIndex: .byte ? 				; Write offset.
>0429					ValSign: 	.byte ? 						; sign flag for val()
>042a					SliceStart:	.byte ? 						; string slice parts
>042b					SliceCount:	.byte ?
>042c					RandomSeed:	.dword ? 						; Random seed.
>0430					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0432					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0434					Tim_SR:		.byte ? 						; Processor Status
>0435					Tim_A:		.byte ? 						; Processor Registers
>0436					Tim_X:		.byte ?
>0437					Tim_Y:		.byte ?
>0438					Tim_Z:		.byte ?
>0439					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7000					HighMemory = $7000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	20 02 00 d9 8b 6f 7e 64			.byte	$20,$02,$00,$d9,$8b,$6f,$7e,$64
>8008	fd 04 35 39 8b 8b 43 52			.byte	$fd,$04,$35,$39,$8b,$8b,$43,$52
>8010	62 76 fd 04 39 34 84 42			.byte	$62,$76,$fd,$04,$39,$34,$84,$42
>8018	62 64 52 fd 04 33 36 00			.byte	$62,$64,$52,$fd,$04,$33,$36,$00
>8020	22 03 00 d9 8b 42 79 52			.byte	$22,$03,$00,$d9,$8b,$42,$79,$52
>8028	fd 05 34 35 31 8b 8b 41			.byte	$fd,$05,$34,$35,$31,$8b,$8b,$41
>8030	5a 6e fd 05 31 38 34 84			.byte	$5a,$6e,$fd,$05,$31,$38,$34,$84
>8038	8b 41 5e 64 fd 05 32 36			.byte	$8b,$41,$5e,$64,$fd,$05,$32,$36
>8040	37 00 1d 04 00 d9 41 45			.byte	$37,$00,$1d,$04,$00,$d9,$41,$45
>8048	54 5a fd 04 37 34 8b 59			.byte	$54,$5a,$fd,$04,$37,$34,$8b,$59
>8050	49 7d fd 04 37 39 84 6c			.byte	$49,$7d,$fd,$04,$37,$39,$84,$6c
>8058	4a 5c fd 04 39 35 00 22			.byte	$4a,$5c,$fd,$04,$39,$35,$00,$22
>8060	05 00 d9 8b 43 70 41 6c			.byte	$05,$00,$d9,$8b,$43,$70,$41,$6c
>8068	fd 04 34 34 8b 8b 42 4f			.byte	$fd,$04,$34,$34,$8b,$8b,$42,$4f
>8070	6e 48 fd 04 39 33 84 8b			.byte	$6e,$48,$fd,$04,$39,$33,$84,$8b
>8078	41 60 53 63 fd 04 35 31			.byte	$41,$60,$53,$63,$fd,$04,$35,$31
>8080	00 21 06 00 d9 8b 41 5e			.byte	$00,$21,$06,$00,$d9,$8b,$41,$5e
>8088	5e 5a fd 04 35 32 8b 8b			.byte	$5e,$5a,$fd,$04,$35,$32,$8b,$8b
>8090	43 55 6c 5e fd 04 32 37			.byte	$43,$55,$6c,$5e,$fd,$04,$32,$37
>8098	84 41 77 4e 43 fd 04 37			.byte	$84,$41,$77,$4e,$43,$fd,$04,$37
>80a0	36 00 1f 07 00 d9 8b 74			.byte	$36,$00,$1f,$07,$00,$d9,$8b,$74
>80a8	6c 76 fd 04 33 39 8b 43			.byte	$6c,$76,$fd,$04,$33,$39,$8b,$43
>80b0	59 7d 7e fd 04 35 31 84			.byte	$59,$7d,$7e,$fd,$04,$35,$31,$84
>80b8	8b 44 4e 6a 74 fd 03 39			.byte	$8b,$44,$4e,$6a,$74,$fd,$03,$39
>80c0	00 21 08 00 d9 8b 41 5b			.byte	$00,$21,$08,$00,$d9,$8b,$41,$5b
>80c8	72 46 fd 04 30 39 8b 8b			.byte	$72,$46,$fd,$04,$30,$39,$8b,$8b
>80d0	41 65 62 4d fd 04 38 35			.byte	$41,$65,$62,$4d,$fd,$04,$38,$35
>80d8	84 49 70 47 fd 05 37 36			.byte	$84,$49,$70,$47,$fd,$05,$37,$36
>80e0	33 00 1d 09 00 d9 43 6b			.byte	$33,$00,$1d,$09,$00,$d9,$43,$6b
>80e8	5a 40 fd 04 36 32 8b 42			.byte	$5a,$40,$fd,$04,$36,$32,$8b,$42
>80f0	70 53 53 fd 03 36 84 7b			.byte	$70,$53,$53,$fd,$03,$36,$84,$7b
>80f8	46 6d fd 04 30 31 00 1e			.byte	$46,$6d,$fd,$04,$30,$31,$00,$1e
>8100	0a 00 d9 42 7f 55 4c fd			.byte	$0a,$00,$d9,$42,$7f,$55,$4c,$fd
>8108	04 34 37 8b 43 68 51 43			.byte	$04,$34,$37,$8b,$43,$68,$51,$43
>8110	fd 03 36 84 8b 68 7b 77			.byte	$fd,$03,$36,$84,$8b,$68,$7b,$77
>8118	fd 04 31 33 00 20 0b 00			.byte	$fd,$04,$31,$33,$00,$20,$0b,$00
>8120	d9 41 66 6c 5b fd 04 33			.byte	$d9,$41,$66,$6c,$5b,$fd,$04,$33
>8128	36 8b 8b 41 6c 7f 4c fd			.byte	$36,$8b,$8b,$41,$6c,$7f,$4c,$fd
>8130	04 37 35 84 43 53 6b 68			.byte	$04,$37,$35,$84,$43,$53,$6b,$68
>8138	fd 04 31 32 00 1f 0c 00			.byte	$fd,$04,$31,$32,$00,$1f,$0c,$00
>8140	d9 67 4b 52 fd 04 37 32			.byte	$d9,$67,$4b,$52,$fd,$04,$37,$32
>8148	8b 8b 41 53 67 40 fd 04			.byte	$8b,$8b,$41,$53,$67,$40,$fd,$04
>8150	39 32 84 41 7a 72 53 fd			.byte	$39,$32,$84,$41,$7a,$72,$53,$fd
>8158	04 36 33 00 21 0d 00 d9			.byte	$04,$36,$33,$00,$21,$0d,$00,$d9
>8160	8b 42 7f 6c 63 fd 04 32			.byte	$8b,$42,$7f,$6c,$63,$fd,$04,$32
>8168	38 8b 8b 79 52 68 fd 04			.byte	$38,$8b,$8b,$79,$52,$68,$fd,$04
>8170	37 39 84 8b 42 46 59 7a			.byte	$37,$39,$84,$8b,$42,$46,$59,$7a
>8178	fd 04 34 39 00 1e 0e 00			.byte	$fd,$04,$34,$39,$00,$1e,$0e,$00
>8180	d9 42 67 62 79 fd 04 37			.byte	$d9,$42,$67,$62,$79,$fd,$04,$37
>8188	38 8b 42 4f 72 5a fd 03			.byte	$38,$8b,$42,$4f,$72,$5a,$fd,$03
>8190	35 84 57 70 5f fd 05 32			.byte	$35,$84,$57,$70,$5f,$fd,$05,$32
>8198	37 32 00 1f 0f 00 d9 42			.byte	$37,$32,$00,$1f,$0f,$00,$d9,$42
>81a0	64 51 64 fd 04 39 34 8b			.byte	$64,$51,$64,$fd,$04,$39,$34,$8b
>81a8	8b 74 66 67 fd 04 39 35			.byte	$8b,$74,$66,$67,$fd,$04,$39,$35
>81b0	84 43 58 78 4c fd 04 38			.byte	$84,$43,$58,$78,$4c,$fd,$04,$38
>81b8	39 00 1f 10 00 d9 41 7d			.byte	$39,$00,$1f,$10,$00,$d9,$41,$7d
>81c0	56 67 fd 04 30 39 8b 41			.byte	$56,$67,$fd,$04,$30,$39,$8b,$41
>81c8	72 54 7e fd 04 37 39 84			.byte	$72,$54,$7e,$fd,$04,$37,$39,$84
>81d0	4b 41 68 fd 05 32 39 36			.byte	$4b,$41,$68,$fd,$05,$32,$39,$36
>81d8	00 20 11 00 d9 8b 42 74			.byte	$00,$20,$11,$00,$d9,$8b,$42,$74
>81e0	4f 5f fd 04 39 34 8b 6c			.byte	$4f,$5f,$fd,$04,$39,$34,$8b,$6c
>81e8	69 49 fd 04 31 35 84 8b			.byte	$69,$49,$fd,$04,$31,$35,$84,$8b
>81f0	43 60 78 69 fd 04 30 39			.byte	$43,$60,$78,$69,$fd,$04,$30,$39
>81f8	00 20 12 00 d9 8b 41 78			.byte	$00,$20,$12,$00,$d9,$8b,$41,$78
>8200	61 69 fd 04 38 39 8b 8b			.byte	$61,$69,$fd,$04,$38,$39,$8b,$8b
>8208	42 75 44 45 fd 04 33 38			.byte	$42,$75,$44,$45,$fd,$04,$33,$38
>8210	84 7c 62 5b fd 04 34 38			.byte	$84,$7c,$62,$5b,$fd,$04,$34,$38
>8218	00 22 13 00 d9 8b 43 4d			.byte	$00,$22,$13,$00,$d9,$8b,$43,$4d
>8220	41 64 fd 04 34 32 8b 8b			.byte	$41,$64,$fd,$04,$34,$32,$8b,$8b
>8228	42 7d 5c 61 fd 04 31 38			.byte	$42,$7d,$5c,$61,$fd,$04,$31,$38
>8230	84 8b 4f 65 43 fd 05 32			.byte	$84,$8b,$4f,$65,$43,$fd,$05,$32
>8238	33 34 00 20 14 00 d9 8b			.byte	$33,$34,$00,$20,$14,$00,$d9,$8b
>8240	7e 49 63 fd 04 33 34 8b			.byte	$7e,$49,$63,$fd,$04,$33,$34,$8b
>8248	8b 43 59 49 42 fd 04 31			.byte	$8b,$43,$59,$49,$42,$fd,$04,$31
>8250	39 84 42 5a 7f 5e fd 04			.byte	$39,$84,$42,$5a,$7f,$5e,$fd,$04
>8258	38 35 00 1f 15 00 d9 42			.byte	$38,$35,$00,$1f,$15,$00,$d9,$42
>8260	5a 41 58 fd 04 34 36 8b			.byte	$5a,$41,$58,$fd,$04,$34,$36,$8b
>8268	8b 79 77 5f fd 04 30 32			.byte	$8b,$79,$77,$5f,$fd,$04,$30,$32
>8270	84 43 53 78 77 fd 04 34			.byte	$84,$43,$53,$78,$77,$fd,$04,$34
>8278	37 00 1e 16 00 d9 43 42			.byte	$37,$00,$1e,$16,$00,$d9,$43,$42
>8280	59 6b fd 04 35 39 8b 8b			.byte	$59,$6b,$fd,$04,$35,$39,$8b,$8b
>8288	76 77 73 fd 04 31 38 84			.byte	$76,$77,$73,$fd,$04,$31,$38,$84
>8290	43 79 51 5e fd 03 38 00			.byte	$43,$79,$51,$5e,$fd,$03,$38,$00
>8298	1f 17 00 d9 42 75 75 78			.byte	$1f,$17,$00,$d9,$42,$75,$75,$78
>82a0	fd 04 36 32 8b 41 59 77			.byte	$fd,$04,$36,$32,$8b,$41,$59,$77
>82a8	4e fd 04 32 31 84 41 5b			.byte	$4e,$fd,$04,$32,$31,$84,$41,$5b
>82b0	7e 6a fd 04 34 31 00 1f			.byte	$7e,$6a,$fd,$04,$34,$31,$00,$1f
>82b8	18 00 d9 42 7b 5a 5b fd			.byte	$18,$00,$d9,$42,$7b,$5a,$5b,$fd
>82c0	04 37 39 8b 8b 42 7b 62			.byte	$04,$37,$39,$8b,$8b,$42,$7b,$62
>82c8	5c fd 04 35 37 84 45 76			.byte	$5c,$fd,$04,$35,$37,$84,$45,$76
>82d0	7c 78 fd 03 34 00 1f 19			.byte	$7c,$78,$fd,$03,$34,$00,$1f,$19
>82d8	00 d9 42 4d 77 46 fd 04			.byte	$00,$d9,$42,$4d,$77,$46,$fd,$04
>82e0	36 38 8b 41 78 7c 79 fd			.byte	$36,$38,$8b,$41,$78,$7c,$79,$fd
>82e8	04 32 39 84 54 7a 4d fd			.byte	$04,$32,$39,$84,$54,$7a,$4d,$fd
>82f0	05 33 38 33 00 1f 1a 00			.byte	$05,$33,$38,$33,$00,$1f,$1a,$00
>82f8	d9 42 7c 55 4d fd 04 35			.byte	$d9,$42,$7c,$55,$4d,$fd,$04,$35
>8300	31 8b 8b 42 5b 51 49 fd			.byte	$31,$8b,$8b,$42,$5b,$51,$49,$fd
>8308	04 32 36 84 45 57 66 56			.byte	$04,$32,$36,$84,$45,$57,$66,$56
>8310	fd 03 38 00 1f 1b 00 d9			.byte	$fd,$03,$38,$00,$1f,$1b,$00,$d9
>8318	42 45 4e 40 fd 04 35 32			.byte	$42,$45,$4e,$40,$fd,$04,$35,$32
>8320	8b 42 64 51 7f fd 04 31			.byte	$8b,$42,$64,$51,$7f,$fd,$04,$31
>8328	39 84 8b 5f 43 7e fd 04			.byte	$39,$84,$8b,$5f,$43,$7e,$fd,$04
>8330	36 36 00 21 1c 00 d9 8b			.byte	$36,$36,$00,$21,$1c,$00,$d9,$8b
>8338	43 53 60 62 fd 04 31 31			.byte	$43,$53,$60,$62,$fd,$04,$31,$31
>8340	8b 8b 6e 5e 4b fd 04 30			.byte	$8b,$8b,$6e,$5e,$4b,$fd,$04,$30
>8348	34 84 8b 42 65 42 57 fd			.byte	$34,$84,$8b,$42,$65,$42,$57,$fd
>8350	04 30 37 00 20 1d 00 d9			.byte	$04,$30,$37,$00,$20,$1d,$00,$d9
>8358	41 6e 57 7c fd 04 33 32			.byte	$41,$6e,$57,$7c,$fd,$04,$33,$32
>8360	8b 8b 41 61 5c 7b fd 04			.byte	$8b,$8b,$41,$61,$5c,$7b,$fd,$04
>8368	33 37 84 43 4f 74 77 fd			.byte	$33,$37,$84,$43,$4f,$74,$77,$fd
>8370	04 36 39 00 20 1e 00 d9			.byte	$04,$36,$39,$00,$20,$1e,$00,$d9
>8378	41 5d 70 4d fd 04 38 35			.byte	$41,$5d,$70,$4d,$fd,$04,$38,$35
>8380	8b 42 79 52 6b fd 04 34			.byte	$8b,$42,$79,$52,$6b,$fd,$04,$34
>8388	34 84 8b 41 5b 62 5d fd			.byte	$34,$84,$8b,$41,$5b,$62,$5d,$fd
>8390	04 35 39 00 21 1f 00 d9			.byte	$04,$35,$39,$00,$21,$1f,$00,$d9
>8398	8b 42 7a 68 4c fd 04 31			.byte	$8b,$42,$7a,$68,$4c,$fd,$04,$31
>83a0	36 8b 8b 41 45 67 5d fd			.byte	$36,$8b,$8b,$41,$45,$67,$5d,$fd
>83a8	04 39 37 84 8b 41 75 40			.byte	$04,$39,$37,$84,$8b,$41,$75,$40
>83b0	6e fd 03 32 00 21 20 00			.byte	$6e,$fd,$03,$32,$00,$21,$20,$00
>83b8	d9 8b 42 72 6c 74 fd 04			.byte	$d9,$8b,$42,$72,$6c,$74,$fd,$04
>83c0	37 35 8b 8b 5b 4f 5b fd			.byte	$37,$35,$8b,$8b,$5b,$4f,$5b,$fd
>83c8	04 38 31 84 8b 42 57 5d			.byte	$04,$38,$31,$84,$8b,$42,$57,$5d
>83d0	58 fd 04 39 34 00 20 21			.byte	$58,$fd,$04,$39,$34,$00,$20,$21
>83d8	00 d9 8b 65 7b 48 fd 04			.byte	$00,$d9,$8b,$65,$7b,$48,$fd,$04
>83e0	36 33 8b 8b 43 52 66 78			.byte	$36,$33,$8b,$8b,$43,$52,$66,$78
>83e8	fd 04 39 37 84 42 6c 6b			.byte	$fd,$04,$39,$37,$84,$42,$6c,$6b
>83f0	70 fd 04 33 34 00 20 22			.byte	$70,$fd,$04,$33,$34,$00,$20,$22
>83f8	00 d9 8b 42 65 6f 49 fd			.byte	$00,$d9,$8b,$42,$65,$6f,$49,$fd
>8400	04 34 33 8b 7b 48 6d fd			.byte	$04,$34,$33,$8b,$7b,$48,$6d,$fd
>8408	04 31 36 84 8b 43 60 77			.byte	$04,$31,$36,$84,$8b,$43,$60,$77
>8410	76 fd 04 35 39 00 1f 23			.byte	$76,$fd,$04,$35,$39,$00,$1f,$23
>8418	00 d9 42 66 66 57 fd 04			.byte	$00,$d9,$42,$66,$66,$57,$fd,$04
>8420	39 38 8b 42 54 60 51 fd			.byte	$39,$38,$8b,$42,$54,$60,$51,$fd
>8428	04 37 31 84 52 46 46 fd			.byte	$04,$37,$31,$84,$52,$46,$46,$fd
>8430	05 32 37 36 00 1f 24 00			.byte	$05,$32,$37,$36,$00,$1f,$24,$00
>8438	d9 42 78 73 57 fd 04 39			.byte	$d9,$42,$78,$73,$57,$fd,$04,$39
>8440	37 8b 8b 43 6c 52 51 fd			.byte	$37,$8b,$8b,$43,$6c,$52,$51,$fd
>8448	04 39 32 84 46 65 45 69			.byte	$04,$39,$32,$84,$46,$65,$45,$69
>8450	fd 03 39 00 1f 25 00 d9			.byte	$fd,$03,$39,$00,$1f,$25,$00,$d9
>8458	43 49 7b 40 fd 04 32 36			.byte	$43,$49,$7b,$40,$fd,$04,$32,$36
>8460	8b 41 67 5b 4b fd 04 30			.byte	$8b,$41,$67,$5b,$4b,$fd,$04,$30
>8468	37 84 41 62 5f 75 fd 04			.byte	$37,$84,$41,$62,$5f,$75,$fd,$04
>8470	31 39 00 1e 26 00 d9 41			.byte	$31,$39,$00,$1e,$26,$00,$d9,$41
>8478	64 59 72 fd 04 32 39 8b			.byte	$64,$59,$72,$fd,$04,$32,$39,$8b
>8480	43 67 5f 48 fd 03 33 84			.byte	$43,$67,$5f,$48,$fd,$03,$33,$84
>8488	8b 42 43 45 56 fd 03 30			.byte	$8b,$42,$43,$45,$56,$fd,$03,$30
>8490	00 1f 27 00 d9 8b 65 73			.byte	$00,$1f,$27,$00,$d9,$8b,$65,$73
>8498	69 fd 04 30 39 8b 8b 41			.byte	$69,$fd,$04,$30,$39,$8b,$8b,$41
>84a0	46 75 74 fd 04 33 33 84			.byte	$46,$75,$74,$fd,$04,$33,$33,$84
>84a8	61 42 4b fd 04 32 34 00			.byte	$61,$42,$4b,$fd,$04,$32,$34,$00
>84b0	1f 28 00 d9 43 6f 5d 75			.byte	$1f,$28,$00,$d9,$43,$6f,$5d,$75
>84b8	fd 04 34 38 8b 8b 43 68			.byte	$fd,$04,$34,$38,$8b,$8b,$43,$68
>84c0	57 40 fd 04 33 38 84 47			.byte	$57,$40,$fd,$04,$33,$38,$84,$47
>84c8	57 74 75 fd 03 39 00 20			.byte	$57,$74,$75,$fd,$03,$39,$00,$20
>84d0	29 00 d9 8b 42 65 71 56			.byte	$29,$00,$d9,$8b,$42,$65,$71,$56
>84d8	fd 04 36 39 8b 8b 42 6e			.byte	$fd,$04,$36,$39,$8b,$8b,$42,$6e
>84e0	63 54 fd 03 38 84 48 71			.byte	$63,$54,$fd,$03,$38,$84,$48,$71
>84e8	7e fd 05 31 31 36 00 1d			.byte	$7e,$fd,$05,$31,$31,$36,$00,$1d
>84f0	2a 00 d9 72 6a 45 fd 04			.byte	$2a,$00,$d9,$72,$6a,$45,$fd,$04
>84f8	38 39 8b 8b 43 4e 6a 58			.byte	$38,$39,$8b,$8b,$43,$4e,$6a,$58
>8500	fd 03 38 84 44 41 54 5e			.byte	$fd,$03,$38,$84,$44,$41,$54,$5e
>8508	fd 03 37 00 20 2b 00 d9			.byte	$fd,$03,$37,$00,$20,$2b,$00,$d9
>8510	8b 42 58 7b 72 fd 03 38			.byte	$8b,$42,$58,$7b,$72,$fd,$03,$38
>8518	8b 45 50 54 fd 05 35 38			.byte	$8b,$45,$50,$54,$fd,$05,$35,$38
>8520	31 84 8b 42 5e 4c 47 fd			.byte	$31,$84,$8b,$42,$5e,$4c,$47,$fd
>8528	04 33 38 00 22 2c 00 d9			.byte	$04,$33,$38,$00,$22,$2c,$00,$d9
>8530	8b 43 44 51 6a fd 04 36			.byte	$8b,$43,$44,$51,$6a,$fd,$04,$36
>8538	31 8b 8b 41 44 70 7c fd			.byte	$31,$8b,$8b,$41,$44,$70,$7c,$fd
>8540	04 30 33 84 8b 41 7f 60			.byte	$04,$30,$33,$84,$8b,$41,$7f,$60
>8548	6e fd 04 35 38 00 1f 2d			.byte	$6e,$fd,$04,$35,$38,$00,$1f,$2d
>8550	00 d9 41 68 52 72 fd 04			.byte	$00,$d9,$41,$68,$52,$72,$fd,$04
>8558	30 37 8b 8b 43 57 49 54			.byte	$30,$37,$8b,$8b,$43,$57,$49,$54
>8560	fd 04 33 32 84 44 7f 5c			.byte	$fd,$04,$33,$32,$84,$44,$7f,$5c
>8568	46 fd 03 34 00 21 2e 00			.byte	$46,$fd,$03,$34,$00,$21,$2e,$00
>8570	d9 8b 42 7c 59 56 fd 04			.byte	$d9,$8b,$42,$7c,$59,$56,$fd,$04
>8578	38 39 8b 8b 43 46 62 61			.byte	$38,$39,$8b,$8b,$43,$46,$62,$61
>8580	fd 04 33 36 84 4a 49 4a			.byte	$fd,$04,$33,$36,$84,$4a,$49,$4a
>8588	fd 05 34 37 35 00 1f 2f			.byte	$fd,$05,$34,$37,$35,$00,$1f,$2f
>8590	00 d9 43 6c 48 49 fd 04			.byte	$00,$d9,$43,$6c,$48,$49,$fd,$04
>8598	39 33 8b 8b 4d 64 5a fd			.byte	$39,$33,$8b,$8b,$4d,$64,$5a,$fd
>85a0	05 30 31 39 84 43 79 6c			.byte	$05,$30,$31,$39,$84,$43,$79,$6c
>85a8	64 fd 03 30 00 1f 30 00			.byte	$64,$fd,$03,$30,$00,$1f,$30,$00
>85b0	d9 42 5d 64 4b fd 04 39			.byte	$d9,$42,$5d,$64,$4b,$fd,$04,$39
>85b8	34 8b 42 7c 47 6c fd 04			.byte	$34,$8b,$42,$7c,$47,$6c,$fd,$04
>85c0	36 36 84 8b 5e 63 60 fd			.byte	$36,$36,$84,$8b,$5e,$63,$60,$fd
>85c8	04 37 31 00 1f 31 00 d9			.byte	$04,$37,$31,$00,$1f,$31,$00,$d9
>85d0	42 42 41 4e fd 04 34 38			.byte	$42,$42,$41,$4e,$fd,$04,$34,$38
>85d8	8b 42 4c 44 7c fd 03 36			.byte	$8b,$42,$4c,$44,$7c,$fd,$03,$36
>85e0	84 8b 4a 43 6e fd 05 31			.byte	$84,$8b,$4a,$43,$6e,$fd,$05,$31
>85e8	31 36 00 1e 32 00 d9 43			.byte	$31,$36,$00,$1e,$32,$00,$d9,$43
>85f0	67 51 60 fd 04 38 32 8b			.byte	$67,$51,$60,$fd,$04,$38,$32,$8b
>85f8	42 4d 40 4e fd 03 34 84			.byte	$42,$4d,$40,$4e,$fd,$03,$34,$84
>8600	41 5a 51 52 fd 04 34 32			.byte	$41,$5a,$51,$52,$fd,$04,$34,$32
>8608	00 20 33 00 d9 41 5c 79			.byte	$00,$20,$33,$00,$d9,$41,$5c,$79
>8610	4c fd 04 33 34 8b 43 53			.byte	$4c,$fd,$04,$33,$34,$8b,$43,$53
>8618	4b 7d fd 04 37 36 84 8b			.byte	$4b,$7d,$fd,$04,$37,$36,$84,$8b
>8620	41 76 52 71 fd 04 34 31			.byte	$41,$76,$52,$71,$fd,$04,$34,$31
>8628	00 1f 34 00 d9 59 5f 41			.byte	$00,$1f,$34,$00,$d9,$59,$5f,$41
>8630	fd 04 39 36 8b 42 7b 7e			.byte	$fd,$04,$39,$36,$8b,$42,$7b,$7e
>8638	54 fd 04 39 38 84 8b 42			.byte	$54,$fd,$04,$39,$38,$84,$8b,$42
>8640	62 5f 53 fd 04 30 32 00			.byte	$62,$5f,$53,$fd,$04,$30,$32,$00
>8648	20 35 00 d9 57 79 57 fd			.byte	$20,$35,$00,$d9,$57,$79,$57,$fd
>8650	05 31 31 36 8b 42 45 48			.byte	$05,$31,$31,$36,$8b,$42,$45,$48
>8658	42 fd 04 35 36 84 8b 41			.byte	$42,$fd,$04,$35,$36,$84,$8b,$41
>8660	6d 4e 6b fd 04 34 34 00			.byte	$6d,$4e,$6b,$fd,$04,$34,$34,$00
>8668	1f 36 00 d9 8b 6d 7c 6d			.byte	$1f,$36,$00,$d9,$8b,$6d,$7c,$6d
>8670	fd 04 35 37 8b 43 56 7c			.byte	$fd,$04,$35,$37,$8b,$43,$56,$7c
>8678	4d fd 04 31 34 84 8b 44			.byte	$4d,$fd,$04,$31,$34,$84,$8b,$44
>8680	44 78 7a fd 03 37 00 21			.byte	$44,$78,$7a,$fd,$03,$37,$00,$21
>8688	37 00 d9 8b 41 7e 70 4a			.byte	$37,$00,$d9,$8b,$41,$7e,$70,$4a
>8690	fd 04 38 35 8b 41 66 42			.byte	$fd,$04,$38,$35,$8b,$41,$66,$42
>8698	78 fd 04 35 34 84 8b 43			.byte	$78,$fd,$04,$35,$34,$84,$8b,$43
>86a0	64 73 43 fd 04 33 39 00			.byte	$64,$73,$43,$fd,$04,$33,$39,$00
>86a8	1f 38 00 d9 8b 43 5b 64			.byte	$1f,$38,$00,$d9,$8b,$43,$5b,$64
>86b0	41 fd 04 32 32 8b 5f 6c			.byte	$41,$fd,$04,$32,$32,$8b,$5f,$6c
>86b8	6e fd 04 32 36 84 8b 43			.byte	$6e,$fd,$04,$32,$36,$84,$8b,$43
>86c0	7b 50 6f fd 03 35 00 20			.byte	$7b,$50,$6f,$fd,$03,$35,$00,$20
>86c8	39 00 d9 8b 77 56 6a fd			.byte	$39,$00,$d9,$8b,$77,$56,$6a,$fd
>86d0	04 33 37 8b 8b 52 7a 6c			.byte	$04,$33,$37,$8b,$8b,$52,$7a,$6c
>86d8	fd 05 34 32 32 84 8b 64			.byte	$fd,$05,$34,$32,$32,$84,$8b,$64
>86e0	5b 7d fd 04 39 35 00 1e			.byte	$5b,$7d,$fd,$04,$39,$35,$00,$1e
>86e8	3a 00 d9 42 59 76 6a fd			.byte	$3a,$00,$d9,$42,$59,$76,$6a,$fd
>86f0	04 38 33 8b 8b 43 47 5b			.byte	$04,$38,$33,$8b,$8b,$43,$47,$5b
>86f8	57 fd 03 36 84 45 61 52			.byte	$57,$fd,$03,$36,$84,$45,$61,$52
>8700	42 fd 03 34 00 20 3b 00			.byte	$42,$fd,$03,$34,$00,$20,$3b,$00
>8708	d9 8b 42 4c 47 7d fd 04			.byte	$d9,$8b,$42,$4c,$47,$7d,$fd,$04
>8710	36 38 8b 8b 43 61 64 7d			.byte	$36,$38,$8b,$8b,$43,$61,$64,$7d
>8718	fd 03 34 84 41 55 5c 7f			.byte	$fd,$03,$34,$84,$41,$55,$5c,$7f
>8720	fd 04 37 32 00 1e 3c 00			.byte	$fd,$04,$37,$32,$00,$1e,$3c,$00
>8728	d9 43 61 7f 42 fd 04 39			.byte	$d9,$43,$61,$7f,$42,$fd,$04,$39
>8730	33 8b 6e 7a 58 fd 04 34			.byte	$33,$8b,$6e,$7a,$58,$fd,$04,$34
>8738	39 84 42 73 44 6a fd 04			.byte	$39,$84,$42,$73,$44,$6a,$fd,$04
>8740	34 34 00 20 3d 00 d9 8b			.byte	$34,$34,$00,$20,$3d,$00,$d9,$8b
>8748	42 68 42 56 fd 04 31 33			.byte	$42,$68,$42,$56,$fd,$04,$31,$33
>8750	8b 43 54 5b 7e fd 04 32			.byte	$8b,$43,$54,$5b,$7e,$fd,$04,$32
>8758	38 84 8b 45 7c 5e 54 fd			.byte	$38,$84,$8b,$45,$7c,$5e,$54,$fd
>8760	03 34 00 1f 3e 00 d9 41			.byte	$03,$34,$00,$1f,$3e,$00,$d9,$41
>8768	79 63 65 fd 04 36 31 8b			.byte	$79,$63,$65,$fd,$04,$36,$31,$8b
>8770	43 5d 6f 7a fd 04 32 31			.byte	$43,$5d,$6f,$7a,$fd,$04,$32,$31
>8778	84 8b 41 64 4c 54 fd 03			.byte	$84,$8b,$41,$64,$4c,$54,$fd,$03
>8780	36 00 20 3f 00 d9 8b 43			.byte	$36,$00,$20,$3f,$00,$d9,$8b,$43
>8788	61 49 7c fd 04 35 34 8b			.byte	$61,$49,$7c,$fd,$04,$35,$34,$8b
>8790	42 5c 54 4e fd 04 38 32			.byte	$42,$5c,$54,$4e,$fd,$04,$38,$32
>8798	84 8b 45 7d 5e 4b fd 03			.byte	$84,$8b,$45,$7d,$5e,$4b,$fd,$03
>87a0	34 00 20 40 00 d9 8b 43			.byte	$34,$00,$20,$40,$00,$d9,$8b,$43
>87a8	48 6b 77 fd 04 35 39 8b			.byte	$48,$6b,$77,$fd,$04,$35,$39,$8b
>87b0	43 63 6d 6e fd 04 30 36			.byte	$43,$63,$6d,$6e,$fd,$04,$30,$36
>87b8	84 8b 46 6c 59 65 fd 03			.byte	$84,$8b,$46,$6c,$59,$65,$fd,$03
>87c0	36 00 21 41 00 d9 8b 42			.byte	$36,$00,$21,$41,$00,$d9,$8b,$42
>87c8	4c 64 fd 05 36 34 39 8b			.byte	$4c,$64,$fd,$05,$36,$34,$39,$8b
>87d0	8b 42 42 5e 70 fd 04 38			.byte	$8b,$42,$42,$5e,$70,$fd,$04,$38
>87d8	33 84 42 40 52 4c fd 04			.byte	$33,$84,$42,$40,$52,$4c,$fd,$04
>87e0	31 38 00 20 42 00 d9 8b			.byte	$31,$38,$00,$20,$42,$00,$d9,$8b
>87e8	41 7e 70 fd 05 32 35 37			.byte	$41,$7e,$70,$fd,$05,$32,$35,$37
>87f0	8b 8b 42 52 71 60 fd 03			.byte	$8b,$8b,$42,$52,$71,$60,$fd,$03
>87f8	30 84 42 50 72 6f fd 04			.byte	$30,$84,$42,$50,$72,$6f,$fd,$04
>8800	37 34 00 1f 43 00 d9 43			.byte	$37,$34,$00,$1f,$43,$00,$d9,$43
>8808	62 7f 72 fd 04 35 36 8b			.byte	$62,$7f,$72,$fd,$04,$35,$36,$8b
>8810	8b 41 74 4d 54 fd 04 32			.byte	$8b,$41,$74,$4d,$54,$fd,$04,$32
>8818	31 84 45 57 4d 46 fd 03			.byte	$31,$84,$45,$57,$4d,$46,$fd,$03
>8820	38 00 1e 44 00 d9 5b 7a			.byte	$38,$00,$1e,$44,$00,$d9,$5b,$7a
>8828	79 fd 04 39 36 8b 41 49			.byte	$79,$fd,$04,$39,$36,$8b,$41,$49
>8830	6c 4f fd 04 33 31 84 8b			.byte	$6c,$4f,$fd,$04,$33,$31,$84,$8b
>8838	6d 71 55 fd 04 33 34 00			.byte	$6d,$71,$55,$fd,$04,$33,$34,$00
>8840	20 45 00 d9 46 6a 67 fd			.byte	$20,$45,$00,$d9,$46,$6a,$67,$fd
>8848	05 31 35 39 8b 8b 42 5a			.byte	$05,$31,$35,$39,$8b,$8b,$42,$5a
>8850	4d 73 fd 04 39 31 84 42			.byte	$4d,$73,$fd,$04,$39,$31,$84,$42
>8858	60 78 5b fd 04 30 37 00			.byte	$60,$78,$5b,$fd,$04,$30,$37,$00
>8860	1e 46 00 d9 42 7a 4a 5e			.byte	$1e,$46,$00,$d9,$42,$7a,$4a,$5e
>8868	fd 04 32 32 8b 4b 74 73			.byte	$fd,$04,$32,$32,$8b,$4b,$74,$73
>8870	fd 05 33 31 38 84 42 6e			.byte	$fd,$05,$33,$31,$38,$84,$42,$6e
>8878	55 6a fd 03 39 00 1e 47			.byte	$55,$6a,$fd,$03,$39,$00,$1e,$47
>8880	00 d9 43 69 7f 78 fd 04			.byte	$00,$d9,$43,$69,$7f,$78,$fd,$04
>8888	36 36 8b 8b 43 5d 4e 58			.byte	$36,$36,$8b,$8b,$43,$5d,$4e,$58
>8890	fd 03 31 84 47 47 4e 50			.byte	$fd,$03,$31,$84,$47,$47,$4e,$50
>8898	fd 03 38 00 1e 48 00 d9			.byte	$fd,$03,$38,$00,$1e,$48,$00,$d9
>88a0	42 40 4e 44 fd 03 39 8b			.byte	$42,$40,$4e,$44,$fd,$03,$39,$8b
>88a8	42 73 7a 69 fd 04 37 38			.byte	$42,$73,$7a,$69,$fd,$04,$37,$38
>88b0	84 8b 73 6c 64 fd 04 38			.byte	$84,$8b,$73,$6c,$64,$fd,$04,$38
>88b8	38 00 1f 49 00 d9 42 68			.byte	$38,$00,$1f,$49,$00,$d9,$42,$68
>88c0	74 52 fd 04 33 37 8b 8b			.byte	$74,$52,$fd,$04,$33,$37,$8b,$8b
>88c8	41 75 5f 72 fd 04 35 31			.byte	$41,$75,$5f,$72,$fd,$04,$35,$31
>88d0	84 44 5e 54 44 fd 03 39			.byte	$84,$44,$5e,$54,$44,$fd,$03,$39
>88d8	00 1f 4a 00 d9 42 6e 4e			.byte	$00,$1f,$4a,$00,$d9,$42,$6e,$4e
>88e0	5f fd 04 32 34 8b 41 61			.byte	$5f,$fd,$04,$32,$34,$8b,$41,$61
>88e8	71 40 fd 04 30 38 84 41			.byte	$71,$40,$fd,$04,$30,$38,$84,$41
>88f0	4c 5d 5f fd 04 31 36 00			.byte	$4c,$5d,$5f,$fd,$04,$31,$36,$00
>88f8	22 4b 00 d9 8b 43 68 73			.byte	$22,$4b,$00,$d9,$8b,$43,$68,$73
>8900	4d fd 04 38 39 8b 8b 41			.byte	$4d,$fd,$04,$38,$39,$8b,$8b,$41
>8908	42 4d 7b fd 04 31 31 84			.byte	$42,$4d,$7b,$fd,$04,$31,$31,$84
>8910	8b 42 66 65 52 fd 04 37			.byte	$8b,$42,$66,$65,$52,$fd,$04,$37
>8918	38 00 1e 4c 00 d9 42 79			.byte	$38,$00,$1e,$4c,$00,$d9,$42,$79
>8920	44 4b fd 04 38 31 8b 71			.byte	$44,$4b,$fd,$04,$38,$31,$8b,$71
>8928	64 63 fd 04 32 36 84 42			.byte	$64,$63,$fd,$04,$32,$36,$84,$42
>8930	47 5f 68 fd 04 35 35 00			.byte	$47,$5f,$68,$fd,$04,$35,$35,$00
>8938	20 4d 00 d9 8b 41 52 50			.byte	$20,$4d,$00,$d9,$8b,$41,$52,$50
>8940	7b fd 04 36 36 8b 43 52			.byte	$7b,$fd,$04,$36,$36,$8b,$43,$52
>8948	72 54 fd 04 32 38 84 8b			.byte	$72,$54,$fd,$04,$32,$38,$84,$8b
>8950	44 65 43 4f fd 03 39 00			.byte	$44,$65,$43,$4f,$fd,$03,$39,$00
>8958	1d 4e 00 d9 43 44 4b 7f			.byte	$1d,$4e,$00,$d9,$43,$44,$4b,$7f
>8960	fd 04 30 37 8b 42 5b 56			.byte	$fd,$04,$30,$37,$8b,$42,$5b,$56
>8968	79 fd 03 30 84 68 75 46			.byte	$79,$fd,$03,$30,$84,$68,$75,$46
>8970	fd 04 30 37 00 1f 4f 00			.byte	$fd,$04,$30,$37,$00,$1f,$4f,$00
>8978	d9 8b 41 77 5c 50 fd 04			.byte	$d9,$8b,$41,$77,$5c,$50,$fd,$04
>8980	30 34 8b 8b 42 59 64 6c			.byte	$30,$34,$8b,$8b,$42,$59,$64,$6c
>8988	fd 03 31 84 62 48 5c fd			.byte	$fd,$03,$31,$84,$62,$48,$5c,$fd
>8990	04 30 36 00 21 50 00 d9			.byte	$04,$30,$36,$00,$21,$50,$00,$d9
>8998	8b 42 4f 6f 46 fd 04 33			.byte	$8b,$42,$4f,$6f,$46,$fd,$04,$33
>89a0	34 8b 8b 41 78 56 5a fd			.byte	$34,$8b,$8b,$41,$78,$56,$5a,$fd
>89a8	03 33 84 8b 57 58 6c fd			.byte	$03,$33,$84,$8b,$57,$58,$6c,$fd
>89b0	05 30 33 38 00 21 51 00			.byte	$05,$30,$33,$38,$00,$21,$51,$00
>89b8	d9 8b 42 5c 6a 43 fd 04			.byte	$d9,$8b,$42,$5c,$6a,$43,$fd,$04
>89c0	31 32 8b 8b 6c 73 63 fd			.byte	$31,$32,$8b,$8b,$6c,$73,$63,$fd
>89c8	04 31 37 84 8b 41 6f 76			.byte	$04,$31,$37,$84,$8b,$41,$6f,$76
>89d0	5f fd 04 39 35 00 1f 52			.byte	$5f,$fd,$04,$39,$35,$00,$1f,$52
>89d8	00 d9 8b 42 55 57 51 fd			.byte	$00,$d9,$8b,$42,$55,$57,$51,$fd
>89e0	04 34 38 8b 76 51 56 fd			.byte	$04,$34,$38,$8b,$76,$51,$56,$fd
>89e8	03 39 84 8b 43 4b 68 68			.byte	$03,$39,$84,$8b,$43,$4b,$68,$68
>89f0	fd 04 33 39 00 1e 53 00			.byte	$fd,$04,$33,$39,$00,$1e,$53,$00
>89f8	d9 42 67 66 46 fd 04 38			.byte	$d9,$42,$67,$66,$46,$fd,$04,$38
>8a00	31 8b 41 78 6e 74 fd 04			.byte	$31,$8b,$41,$78,$6e,$74,$fd,$04
>8a08	37 32 84 6e 77 52 fd 04			.byte	$37,$32,$84,$6e,$77,$52,$fd,$04
>8a10	30 39 00 1f 54 00 d9 43			.byte	$30,$39,$00,$1f,$54,$00,$d9,$43
>8a18	42 7a 4b fd 04 37 33 8b			.byte	$42,$7a,$4b,$fd,$04,$37,$33,$8b
>8a20	4b 53 73 fd 05 30 33 39			.byte	$4b,$53,$73,$fd,$05,$30,$33,$39
>8a28	84 42 77 66 58 fd 04 36			.byte	$84,$42,$77,$66,$58,$fd,$04,$36
>8a30	39 00 1f 55 00 d9 43 58			.byte	$39,$00,$1f,$55,$00,$d9,$43,$58
>8a38	75 63 fd 04 39 39 8b 42			.byte	$75,$63,$fd,$04,$39,$39,$8b,$42
>8a40	53 64 fd 05 30 36 33 84			.byte	$53,$64,$fd,$05,$30,$36,$33,$84
>8a48	43 56 61 7f fd 04 39 33			.byte	$43,$56,$61,$7f,$fd,$04,$39,$33
>8a50	00 1f 56 00 d9 42 54 72			.byte	$00,$1f,$56,$00,$d9,$42,$54,$72
>8a58	7a fd 03 38 8b 8b 48 7c			.byte	$7a,$fd,$03,$38,$8b,$8b,$48,$7c
>8a60	7b fd 05 32 38 33 84 42			.byte	$7b,$fd,$05,$32,$38,$33,$84,$42
>8a68	5d 6f 76 fd 04 30 39 00			.byte	$5d,$6f,$76,$fd,$04,$30,$39,$00
>8a70	1e 57 00 d9 42 5d 48 6d			.byte	$1e,$57,$00,$d9,$42,$5d,$48,$6d
>8a78	fd 04 38 36 8b 41 5e 57			.byte	$fd,$04,$38,$36,$8b,$41,$5e,$57
>8a80	58 fd 04 39 36 84 7e 71			.byte	$58,$fd,$04,$39,$36,$84,$7e,$71
>8a88	54 fd 04 39 31 00 1e 58			.byte	$54,$fd,$04,$39,$31,$00,$1e,$58
>8a90	00 d9 8b 43 71 52 6c fd			.byte	$00,$d9,$8b,$43,$71,$52,$6c,$fd
>8a98	03 38 8b 7b 6c 7e fd 04			.byte	$03,$38,$8b,$7b,$6c,$7e,$fd,$04
>8aa0	32 37 84 8b 44 6c 7f 6b			.byte	$32,$37,$84,$8b,$44,$6c,$7f,$6b
>8aa8	fd 03 31 00 21 59 00 d9			.byte	$fd,$03,$31,$00,$21,$59,$00,$d9
>8ab0	8b 41 55 6a 51 fd 04 32			.byte	$8b,$41,$55,$6a,$51,$fd,$04,$32
>8ab8	32 8b 8b 43 41 7e 70 fd			.byte	$32,$8b,$8b,$43,$41,$7e,$70,$fd
>8ac0	04 39 39 84 41 6c 54 5f			.byte	$04,$39,$39,$84,$41,$6c,$54,$5f
>8ac8	fd 04 37 37 00 22 5a 00			.byte	$fd,$04,$37,$37,$00,$22,$5a,$00
>8ad0	d9 8b 42 62 48 64 fd 04			.byte	$d9,$8b,$42,$62,$48,$64,$fd,$04
>8ad8	33 38 8b 8b 41 4c 42 7a			.byte	$33,$38,$8b,$8b,$41,$4c,$42,$7a
>8ae0	fd 04 38 31 84 8b 41 56			.byte	$fd,$04,$38,$31,$84,$8b,$41,$56
>8ae8	45 69 fd 04 35 37 00 1f			.byte	$45,$69,$fd,$04,$35,$37,$00,$1f
>8af0	5b 00 d9 41 5d 55 72 fd			.byte	$5b,$00,$d9,$41,$5d,$55,$72,$fd
>8af8	04 39 34 8b 42 7b 4e 5b			.byte	$04,$39,$34,$8b,$42,$7b,$4e,$5b
>8b00	fd 03 39 84 8b 41 5d 78			.byte	$fd,$03,$39,$84,$8b,$41,$5d,$78
>8b08	68 fd 04 39 36 00 1f 5c			.byte	$68,$fd,$04,$39,$36,$00,$1f,$5c
>8b10	00 d9 8b 60 5e 53 fd 04			.byte	$00,$d9,$8b,$60,$5e,$53,$fd,$04
>8b18	36 31 8b 43 6f 5b 61 fd			.byte	$36,$31,$8b,$43,$6f,$5b,$61,$fd
>8b20	04 34 34 84 8b 44 4f 79			.byte	$04,$34,$34,$84,$8b,$44,$4f,$79
>8b28	75 fd 03 31 00 1f 5d 00			.byte	$75,$fd,$03,$31,$00,$1f,$5d,$00
>8b30	d9 7e 44 51 fd 04 38 33			.byte	$d9,$7e,$44,$51,$fd,$04,$38,$33
>8b38	8b 42 58 5e 6c fd 04 38			.byte	$8b,$42,$58,$5e,$6c,$fd,$04,$38
>8b40	37 84 8b 41 5a 5a 5b fd			.byte	$37,$84,$8b,$41,$5a,$5a,$5b,$fd
>8b48	04 30 35 00 1f 5e 00 d9			.byte	$04,$30,$35,$00,$1f,$5e,$00,$d9
>8b50	42 51 48 65 fd 04 39 38			.byte	$42,$51,$48,$65,$fd,$04,$39,$38
>8b58	8b 8b 43 66 78 61 fd 04			.byte	$8b,$8b,$43,$66,$78,$61,$fd,$04
>8b60	34 36 84 45 78 41 47 fd			.byte	$34,$36,$84,$45,$78,$41,$47,$fd
>8b68	03 34 00 1e 5f 00 d9 43			.byte	$03,$34,$00,$1e,$5f,$00,$d9,$43
>8b70	62 74 4c fd 04 32 38 8b			.byte	$62,$74,$4c,$fd,$04,$32,$38,$8b
>8b78	43 4d 50 71 fd 03 30 84			.byte	$43,$4d,$50,$71,$fd,$03,$30,$84
>8b80	55 63 5b fd 05 32 37 39			.byte	$55,$63,$5b,$fd,$05,$32,$37,$39
>8b88	00 1e 60 00 d9 8b 43 51			.byte	$00,$1e,$60,$00,$d9,$8b,$43,$51
>8b90	61 4d fd 03 38 8b 6d 7f			.byte	$61,$4d,$fd,$03,$38,$8b,$6d,$7f
>8b98	69 fd 04 33 34 84 8b 43			.byte	$69,$fd,$04,$33,$34,$84,$8b,$43
>8ba0	7f 60 77 fd 03 31 00 20			.byte	$7f,$60,$77,$fd,$03,$31,$00,$20
>8ba8	61 00 d9 4c 64 7a fd 05			.byte	$61,$00,$d9,$4c,$64,$7a,$fd,$05
>8bb0	38 30 35 8b 42 52 7b 7f			.byte	$38,$30,$35,$8b,$42,$52,$7b,$7f
>8bb8	fd 04 38 36 84 8b 42 46			.byte	$fd,$04,$38,$36,$84,$8b,$42,$46
>8bc0	57 45 fd 04 30 35 00 1f			.byte	$57,$45,$fd,$04,$30,$35,$00,$1f
>8bc8	62 00 d9 8b 6b 4d 6d fd			.byte	$62,$00,$d9,$8b,$6b,$4d,$6d,$fd
>8bd0	04 34 34 8b 43 63 42 42			.byte	$04,$34,$34,$8b,$43,$63,$42,$42
>8bd8	fd 04 38 31 84 8b 44 4e			.byte	$fd,$04,$38,$31,$84,$8b,$44,$4e
>8be0	4f 70 fd 03 32 00 22 63			.byte	$4f,$70,$fd,$03,$32,$00,$22,$63
>8be8	00 d9 8b 42 66 7e 55 fd			.byte	$00,$d9,$8b,$42,$66,$7e,$55,$fd
>8bf0	04 36 39 8b 8b 48 4d 59			.byte	$04,$36,$39,$8b,$8b,$48,$4d,$59
>8bf8	fd 05 35 39 38 84 8b 42			.byte	$fd,$05,$35,$39,$38,$84,$8b,$42
>8c00	5e 70 7c fd 04 30 39 00			.byte	$5e,$70,$7c,$fd,$04,$30,$39,$00
>8c08	1f 64 00 d9 43 55 47 57			.byte	$1f,$64,$00,$d9,$43,$55,$47,$57
>8c10	fd 04 33 33 8b 8b 42 58			.byte	$fd,$04,$33,$33,$8b,$8b,$42,$58
>8c18	41 57 fd 04 35 39 84 45			.byte	$41,$57,$fd,$04,$35,$39,$84,$45
>8c20	6d 48 6e fd 03 39 00 20			.byte	$6d,$48,$6e,$fd,$03,$39,$00,$20
>8c28	65 00 d9 8b 41 48 44 4c			.byte	$65,$00,$d9,$8b,$41,$48,$44,$4c
>8c30	fd 04 30 32 8b 43 48 6b			.byte	$fd,$04,$30,$32,$8b,$43,$48,$6b
>8c38	7d fd 04 34 36 84 8b 44			.byte	$7d,$fd,$04,$34,$36,$84,$8b,$44
>8c40	50 70 49 fd 03 35 00 20			.byte	$50,$70,$49,$fd,$03,$35,$00,$20
>8c48	66 00 d9 42 7b 5c fd 05			.byte	$66,$00,$d9,$42,$7b,$5c,$fd,$05
>8c50	35 39 35 8b 43 48 6b 69			.byte	$35,$39,$35,$8b,$43,$48,$6b,$69
>8c58	fd 04 38 37 84 8b 43 45			.byte	$fd,$04,$38,$37,$84,$8b,$43,$45
>8c60	70 4d fd 04 32 38 00 1f			.byte	$70,$4d,$fd,$04,$32,$38,$00,$1f
>8c68	67 00 d9 43 53 6a 42 fd			.byte	$67,$00,$d9,$43,$53,$6a,$42,$fd
>8c70	04 31 34 8b 8b 42 5b 59			.byte	$04,$31,$34,$8b,$8b,$42,$5b,$59
>8c78	47 fd 04 36 31 84 45 6f			.byte	$47,$fd,$04,$36,$31,$84,$45,$6f
>8c80	43 49 fd 03 37 00 1f 68			.byte	$43,$49,$fd,$03,$37,$00,$1f,$68
>8c88	00 d9 41 7a 6e 4f fd 04			.byte	$00,$d9,$41,$7a,$6e,$4f,$fd,$04
>8c90	36 38 8b 8b 43 64 7e 6e			.byte	$36,$38,$8b,$8b,$43,$64,$7e,$6e
>8c98	fd 04 37 38 84 45 5f 6c			.byte	$fd,$04,$37,$38,$84,$45,$5f,$6c
>8ca0	7e fd 03 35 00 1e 69 00			.byte	$7e,$fd,$03,$35,$00,$1e,$69,$00
>8ca8	d9 7f 6b 42 fd 04 35 34			.byte	$d9,$7f,$6b,$42,$fd,$04,$35,$34
>8cb0	8b 8b 41 7d 69 78 fd 03			.byte	$8b,$8b,$41,$7d,$69,$78,$fd,$03
>8cb8	32 84 42 7d 54 7a fd 04			.byte	$32,$84,$42,$7d,$54,$7a,$fd,$04
>8cc0	37 34 00 20 6a 00 d9 41			.byte	$37,$34,$00,$20,$6a,$00,$d9,$41
>8cc8	5b 6c 58 fd 04 39 34 8b			.byte	$5b,$6c,$58,$fd,$04,$39,$34,$8b
>8cd0	8b 50 5e 66 fd 05 31 31			.byte	$8b,$50,$5e,$66,$fd,$05,$31,$31
>8cd8	32 84 41 6c 4a 7f fd 04			.byte	$32,$84,$41,$6c,$4a,$7f,$fd,$04
>8ce0	30 35 00 1f 6b 00 d9 62			.byte	$30,$35,$00,$1f,$6b,$00,$d9,$62
>8ce8	65 48 fd 04 31 37 8b 43			.byte	$65,$48,$fd,$04,$31,$37,$8b,$43
>8cf0	5a 72 4c fd 04 31 36 84			.byte	$5a,$72,$4c,$fd,$04,$31,$36,$84
>8cf8	8b 42 78 4d 43 fd 04 39			.byte	$8b,$42,$78,$4d,$43,$fd,$04,$39
>8d00	38 00 1e 6c 00 d9 8b 42			.byte	$38,$00,$1e,$6c,$00,$d9,$8b,$42
>8d08	6e 56 40 fd 03 30 8b 41			.byte	$6e,$56,$40,$fd,$03,$30,$8b,$41
>8d10	43 4a 5e fd 03 36 84 8b			.byte	$43,$4a,$5e,$fd,$03,$36,$84,$8b
>8d18	43 71 60 5e fd 03 36 00			.byte	$43,$71,$60,$5e,$fd,$03,$36,$00
>8d20	1d 6d 00 d9 41 71 49 4d			.byte	$1d,$6d,$00,$d9,$41,$71,$49,$4d
>8d28	fd 03 34 8b 41 69 7d 59			.byte	$fd,$03,$34,$8b,$41,$69,$7d,$59
>8d30	fd 04 39 39 84 47 4b 73			.byte	$fd,$04,$39,$39,$84,$47,$4b,$73
>8d38	fd 04 34 31 00 1f 6e 00			.byte	$fd,$04,$34,$31,$00,$1f,$6e,$00
>8d40	d9 43 5e 41 77 fd 04 32			.byte	$d9,$43,$5e,$41,$77,$fd,$04,$32
>8d48	34 8b 8b 41 57 50 44 fd			.byte	$34,$8b,$8b,$41,$57,$50,$44,$fd
>8d50	04 30 39 84 44 75 51 7b			.byte	$04,$30,$39,$84,$44,$75,$51,$7b
>8d58	fd 03 33 00 20 6f 00 d9			.byte	$fd,$03,$33,$00,$20,$6f,$00,$d9
>8d60	41 63 64 45 fd 04 35 36			.byte	$41,$63,$64,$45,$fd,$04,$35,$36
>8d68	8b 8b 42 4d 64 71 fd 04			.byte	$8b,$8b,$42,$4d,$64,$71,$fd,$04
>8d70	30 37 84 43 71 48 76 fd			.byte	$30,$37,$84,$43,$71,$48,$76,$fd
>8d78	04 36 33 00 21 70 00 d9			.byte	$04,$36,$33,$00,$21,$70,$00,$d9
>8d80	8b 43 6e 57 49 fd 04 39			.byte	$8b,$43,$6e,$57,$49,$fd,$04,$39
>8d88	39 8b 8b 72 4f 44 fd 04			.byte	$39,$8b,$8b,$72,$4f,$44,$fd,$04
>8d90	30 32 84 8b 42 7c 48 45			.byte	$30,$32,$84,$8b,$42,$7c,$48,$45
>8d98	fd 04 39 37 00 20 71 00			.byte	$fd,$04,$39,$37,$00,$20,$71,$00
>8da0	d9 8b 48 6b 5e fd 05 34			.byte	$d9,$8b,$48,$6b,$5e,$fd,$05,$34
>8da8	33 37 8b 41 4b 55 50 fd			.byte	$33,$37,$8b,$41,$4b,$55,$50,$fd
>8db0	03 39 84 8b 41 54 40 6f			.byte	$03,$39,$84,$8b,$41,$54,$40,$6f
>8db8	fd 04 33 34 00 20 72 00			.byte	$fd,$04,$33,$34,$00,$20,$72,$00
>8dc0	d9 8b 43 48 47 78 fd 04			.byte	$d9,$8b,$43,$48,$47,$78,$fd,$04
>8dc8	38 34 8b 43 50 52 78 fd			.byte	$38,$34,$8b,$43,$50,$52,$78,$fd
>8dd0	04 39 38 84 8b 46 58 5a			.byte	$04,$39,$38,$84,$8b,$46,$58,$5a
>8dd8	71 fd 03 38 00 1f 73 00			.byte	$71,$fd,$03,$38,$00,$1f,$73,$00
>8de0	d9 42 56 7e 5b fd 04 34			.byte	$d9,$42,$56,$7e,$5b,$fd,$04,$34
>8de8	35 8b 8b 68 6a 7d fd 04			.byte	$35,$8b,$8b,$68,$6a,$7d,$fd,$04
>8df0	36 39 84 42 7f 69 59 fd			.byte	$36,$39,$84,$42,$7f,$69,$59,$fd
>8df8	04 31 34 00 1f 74 00 d9			.byte	$04,$31,$34,$00,$1f,$74,$00,$d9
>8e00	8b 41 51 55 43 fd 04 39			.byte	$8b,$41,$51,$55,$43,$fd,$04,$39
>8e08	31 8b 7c 72 41 fd 04 31			.byte	$31,$8b,$7c,$72,$41,$fd,$04,$31
>8e10	39 84 8b 42 4e 47 45 fd			.byte	$39,$84,$8b,$42,$4e,$47,$45,$fd
>8e18	03 31 00 1f 75 00 d9 8b			.byte	$03,$31,$00,$1f,$75,$00,$d9,$8b
>8e20	41 70 5d 68 fd 04 37 33			.byte	$41,$70,$5d,$68,$fd,$04,$37,$33
>8e28	8b 43 59 4c 7d fd 03 30			.byte	$8b,$43,$59,$4c,$7d,$fd,$03,$30
>8e30	84 8b 45 49 6a 65 fd 03			.byte	$84,$8b,$45,$49,$6a,$65,$fd,$03
>8e38	37 00 20 76 00 d9 8b 41			.byte	$37,$00,$20,$76,$00,$d9,$8b,$41
>8e40	78 46 55 fd 04 32 37 8b			.byte	$78,$46,$55,$fd,$04,$32,$37,$8b
>8e48	41 5c 7b 5c fd 03 35 84			.byte	$41,$5c,$7b,$5c,$fd,$03,$35,$84
>8e50	8b 43 55 41 71 fd 04 37			.byte	$8b,$43,$55,$41,$71,$fd,$04,$37
>8e58	37 00 20 77 00 d9 8b 42			.byte	$37,$00,$20,$77,$00,$d9,$8b,$42
>8e60	68 79 69 fd 04 36 33 8b			.byte	$68,$79,$69,$fd,$04,$36,$33,$8b
>8e68	41 58 73 40 fd 04 38 34			.byte	$41,$58,$73,$40,$fd,$04,$38,$34
>8e70	84 8b 44 41 6c 6a fd 03			.byte	$84,$8b,$44,$41,$6c,$6a,$fd,$03
>8e78	35 00 1f 78 00 d9 8b 43			.byte	$35,$00,$1f,$78,$00,$d9,$8b,$43
>8e80	45 53 6b fd 04 39 34 8b			.byte	$45,$53,$6b,$fd,$04,$39,$34,$8b
>8e88	73 5a 73 fd 04 31 32 84			.byte	$73,$5a,$73,$fd,$04,$31,$32,$84
>8e90	8b 43 78 6e 5f fd 03 31			.byte	$8b,$43,$78,$6e,$5f,$fd,$03,$31
>8e98	00 1f 79 00 d9 8b 42 5e			.byte	$00,$1f,$79,$00,$d9,$8b,$42,$5e
>8ea0	41 fd 05 36 32 38 8b 8b			.byte	$41,$fd,$05,$36,$32,$38,$8b,$8b
>8ea8	64 57 75 fd 04 30 35 84			.byte	$64,$57,$75,$fd,$04,$30,$35,$84
>8eb0	61 79 73 fd 04 34 32 00			.byte	$61,$79,$73,$fd,$04,$34,$32,$00
>8eb8	20 7a 00 d9 41 46 5c fd			.byte	$20,$7a,$00,$d9,$41,$46,$5c,$fd
>8ec0	05 35 35 38 8b 8b 41 41			.byte	$05,$35,$35,$38,$8b,$8b,$41,$41
>8ec8	67 79 fd 04 36 37 84 41			.byte	$67,$79,$fd,$04,$36,$37,$84,$41
>8ed0	42 6e 56 fd 04 32 33 00			.byte	$42,$6e,$56,$fd,$04,$32,$33,$00
>8ed8	1e 7b 00 d9 42 5f 61 6a			.byte	$1e,$7b,$00,$d9,$42,$5f,$61,$6a
>8ee0	fd 03 33 8b 4b 44 53 fd			.byte	$fd,$03,$33,$8b,$4b,$44,$53,$fd
>8ee8	05 33 35 38 84 42 54 5d			.byte	$05,$33,$35,$38,$84,$42,$54,$5d
>8ef0	56 fd 04 39 34 00 1f 7c			.byte	$56,$fd,$04,$39,$34,$00,$1f,$7c
>8ef8	00 d9 8b 42 53 48 61 fd			.byte	$00,$d9,$8b,$42,$53,$48,$61,$fd
>8f00	04 30 34 8b 7f 6d 6c fd			.byte	$04,$30,$34,$8b,$7f,$6d,$6c,$fd
>8f08	03 35 84 8b 43 52 76 4d			.byte	$03,$35,$84,$8b,$43,$52,$76,$4d
>8f10	fd 04 35 34 00 1f 7d 00			.byte	$fd,$04,$35,$34,$00,$1f,$7d,$00
>8f18	d9 8b 61 50 4e fd 04 38			.byte	$d9,$8b,$61,$50,$4e,$fd,$04,$38
>8f20	32 8b 8b 60 66 79 fd 04			.byte	$32,$8b,$8b,$60,$66,$79,$fd,$04
>8f28	34 35 84 8b 69 55 fd 05			.byte	$34,$35,$84,$8b,$69,$55,$fd,$05
>8f30	33 37 33 00 21 7e 00 d9			.byte	$33,$37,$33,$00,$21,$7e,$00,$d9
>8f38	8b 41 62 52 41 fd 04 30			.byte	$8b,$41,$62,$52,$41,$fd,$04,$30
>8f40	35 8b 8b 41 69 5e 69 fd			.byte	$35,$8b,$8b,$41,$69,$5e,$69,$fd
>8f48	04 31 33 84 47 4c 68 fd			.byte	$04,$31,$33,$84,$47,$4c,$68,$fd
>8f50	05 30 38 34 00 1f 7f 00			.byte	$05,$30,$38,$34,$00,$1f,$7f,$00
>8f58	d9 41 6d 69 7a fd 04 32			.byte	$d9,$41,$6d,$69,$7a,$fd,$04,$32
>8f60	39 8b 4b 4b 62 fd 05 30			.byte	$39,$8b,$4b,$4b,$62,$fd,$05,$30
>8f68	33 36 84 41 62 5e 58 fd			.byte	$33,$36,$84,$41,$62,$5e,$58,$fd
>8f70	04 32 36 00 21 80 00 d9			.byte	$04,$32,$36,$00,$21,$80,$00,$d9
>8f78	8b 46 5e 64 fd 05 39 30			.byte	$8b,$46,$5e,$64,$fd,$05,$39,$30
>8f80	39 8b 42 4c 50 50 fd 04			.byte	$39,$8b,$42,$4c,$50,$50,$fd,$04
>8f88	35 32 84 8b 42 52 6e 75			.byte	$35,$32,$84,$8b,$42,$52,$6e,$75
>8f90	fd 04 34 33 00 20 81 00			.byte	$fd,$04,$34,$33,$00,$20,$81,$00
>8f98	d9 42 41 58 53 fd 04 38			.byte	$d9,$42,$41,$58,$53,$fd,$04,$38
>8fa0	31 8b 43 4d 7b 4d fd 04			.byte	$31,$8b,$43,$4d,$7b,$4d,$fd,$04
>8fa8	31 37 84 8b 41 4c 62 79			.byte	$31,$37,$84,$8b,$41,$4c,$62,$79
>8fb0	fd 04 33 36 00 1f 82 00			.byte	$fd,$04,$33,$36,$00,$1f,$82,$00
>8fb8	d9 43 57 6d 57 fd 04 36			.byte	$d9,$43,$57,$6d,$57,$fd,$04,$36
>8fc0	38 8b 8b 42 71 4c 65 fd			.byte	$38,$8b,$8b,$42,$71,$4c,$65,$fd
>8fc8	04 31 39 84 46 48 79 7c			.byte	$04,$31,$39,$84,$46,$48,$79,$7c
>8fd0	fd 03 39 00 1f 83 00 d9			.byte	$fd,$03,$39,$00,$1f,$83,$00,$d9
>8fd8	42 75 76 7a fd 04 30 35			.byte	$42,$75,$76,$7a,$fd,$04,$30,$35
>8fe0	8b 41 44 58 65 fd 04 32			.byte	$8b,$41,$44,$58,$65,$fd,$04,$32
>8fe8	33 84 41 71 5e 54 fd 04			.byte	$33,$84,$41,$71,$5e,$54,$fd,$04
>8ff0	38 32 00 20 84 00 d9 8b			.byte	$38,$32,$00,$20,$84,$00,$d9,$8b
>8ff8	41 72 41 48 fd 04 30 34			.byte	$41,$72,$41,$48,$fd,$04,$30,$34
>9000	8b 42 5b 7e 76 fd 04 34			.byte	$8b,$42,$5b,$7e,$76,$fd,$04,$34
>9008	32 84 8b 44 4d 7f 7e fd			.byte	$32,$84,$8b,$44,$4d,$7f,$7e,$fd
>9010	03 35 00 20 85 00 d9 8b			.byte	$03,$35,$00,$20,$85,$00,$d9,$8b
>9018	42 49 7b 5e fd 04 35 37			.byte	$42,$49,$7b,$5e,$fd,$04,$35,$37
>9020	8b 8b 5c 45 70 fd 03 32			.byte	$8b,$8b,$5c,$45,$70,$fd,$03,$32
>9028	84 8b 41 6d 75 6e fd 04			.byte	$84,$8b,$41,$6d,$75,$6e,$fd,$04
>9030	33 37 00 1f 86 00 d9 43			.byte	$33,$37,$00,$1f,$86,$00,$d9,$43
>9038	56 67 4d fd 04 38 36 8b			.byte	$56,$67,$4d,$fd,$04,$38,$36,$8b
>9040	41 78 70 49 fd 04 32 33			.byte	$41,$78,$70,$49,$fd,$04,$32,$33
>9048	84 41 5d 77 44 fd 04 36			.byte	$84,$41,$5d,$77,$44,$fd,$04,$36
>9050	33 00 20 87 00 d9 8b 42			.byte	$33,$00,$20,$87,$00,$d9,$8b,$42
>9058	6c 63 49 fd 04 37 34 8b			.byte	$6c,$63,$49,$fd,$04,$37,$34,$8b
>9060	41 4b 51 5e fd 04 31 36			.byte	$41,$4b,$51,$5e,$fd,$04,$31,$36
>9068	84 8b 43 77 74 67 fd 03			.byte	$84,$8b,$43,$77,$74,$67,$fd,$03
>9070	39 00 1d 88 00 d9 4a 51			.byte	$39,$00,$1d,$88,$00,$d9,$4a,$51
>9078	48 fd 04 39 39 8b 49 5f			.byte	$48,$fd,$04,$39,$39,$8b,$49,$5f
>9080	7b fd 05 37 37 38 84 71			.byte	$7b,$fd,$05,$37,$37,$38,$84,$71
>9088	4d fd 05 32 31 32 00 1f			.byte	$4d,$fd,$05,$32,$31,$32,$00,$1f
>9090	89 00 d9 8b 64 51 55 fd			.byte	$89,$00,$d9,$8b,$64,$51,$55,$fd
>9098	04 31 31 8b 41 6d 53 5c			.byte	$04,$31,$31,$8b,$41,$6d,$53,$5c
>90a0	fd 04 38 39 84 8b 42 51			.byte	$fd,$04,$38,$39,$84,$8b,$42,$51
>90a8	64 72 fd 03 30 00 20 8a			.byte	$64,$72,$fd,$03,$30,$00,$20,$8a
>90b0	00 d9 8b 41 55 72 56 fd			.byte	$00,$d9,$8b,$41,$55,$72,$56,$fd
>90b8	04 36 36 8b 8b 42 6f 7c			.byte	$04,$36,$36,$8b,$8b,$42,$6f,$7c
>90c0	69 fd 04 34 36 84 41 5a			.byte	$69,$fd,$04,$34,$36,$84,$41,$5a
>90c8	4a 52 fd 03 38 00 1f 8b			.byte	$4a,$52,$fd,$03,$38,$00,$1f,$8b
>90d0	00 d9 4b 4c 4b fd 05 33			.byte	$00,$d9,$4b,$4c,$4b,$fd,$05,$33
>90d8	35 32 8b 41 45 70 7a fd			.byte	$35,$32,$8b,$41,$45,$70,$7a,$fd
>90e0	04 33 32 84 8b 7a 64 6e			.byte	$04,$33,$32,$84,$8b,$7a,$64,$6e
>90e8	fd 04 39 36 00 1f 8c 00			.byte	$fd,$04,$39,$36,$00,$1f,$8c,$00
>90f0	d9 43 4b 7c 70 fd 04 37			.byte	$d9,$43,$4b,$7c,$70,$fd,$04,$37
>90f8	38 8b 8b 52 79 46 fd 04			.byte	$38,$8b,$8b,$52,$79,$46,$fd,$04
>9100	33 37 84 43 5e 75 77 fd			.byte	$33,$37,$84,$43,$5e,$75,$77,$fd
>9108	04 31 35 00 1f 8d 00 d9			.byte	$04,$31,$35,$00,$1f,$8d,$00,$d9
>9110	42 5e 6d 43 fd 04 31 33			.byte	$42,$5e,$6d,$43,$fd,$04,$31,$33
>9118	8b 8b 43 56 75 41 fd 04			.byte	$8b,$8b,$43,$56,$75,$41,$fd,$04
>9120	35 37 84 45 75 62 44 fd			.byte	$35,$37,$84,$45,$75,$62,$44,$fd
>9128	03 37 00 21 8e 00 d9 8b			.byte	$03,$37,$00,$21,$8e,$00,$d9,$8b
>9130	54 69 76 fd 05 36 30 31			.byte	$54,$69,$76,$fd,$05,$36,$30,$31
>9138	8b 8b 42 70 4b fd 04 32			.byte	$8b,$8b,$42,$70,$4b,$fd,$04,$32
>9140	38 84 8b 51 79 6b fd 05			.byte	$38,$84,$8b,$51,$79,$6b,$fd,$05
>9148	33 32 31 00 1f 8f 00 d9			.byte	$33,$32,$31,$00,$1f,$8f,$00,$d9
>9150	41 69 67 53 fd 04 38 31			.byte	$41,$69,$67,$53,$fd,$04,$38,$31
>9158	8b 43 73 43 5e fd 03 33			.byte	$8b,$43,$73,$43,$5e,$fd,$03,$33
>9160	84 8b 42 49 5c 4a fd 04			.byte	$84,$8b,$42,$49,$5c,$4a,$fd,$04
>9168	34 39 00 1e 90 00 d9 8b			.byte	$34,$39,$00,$1e,$90,$00,$d9,$8b
>9170	41 47 5f 41 fd 03 37 8b			.byte	$41,$47,$5f,$41,$fd,$03,$37,$8b
>9178	43 46 77 55 fd 03 37 84			.byte	$43,$46,$77,$55,$fd,$03,$37,$84
>9180	8b 44 4e 56 57 fd 03 34			.byte	$8b,$44,$4e,$56,$57,$fd,$03,$34
>9188	00 1f 91 00 d9 43 47 6e			.byte	$00,$1f,$91,$00,$d9,$43,$47,$6e
>9190	71 fd 04 39 34 8b 8b 43			.byte	$71,$fd,$04,$39,$34,$8b,$8b,$43
>9198	55 7a 51 fd 04 33 37 84			.byte	$55,$7a,$51,$fd,$04,$33,$37,$84
>91a0	46 5d 69 43 fd 03 33 00			.byte	$46,$5d,$69,$43,$fd,$03,$33,$00
>91a8	20 92 00 d9 54 7c 44 fd			.byte	$20,$92,$00,$d9,$54,$7c,$44,$fd
>91b0	05 36 38 38 8b 8b 42 73			.byte	$05,$36,$38,$38,$8b,$8b,$42,$73
>91b8	75 4e fd 04 38 36 84 43			.byte	$75,$4e,$fd,$04,$38,$36,$84,$43
>91c0	48 71 53 fd 04 35 34 00			.byte	$48,$71,$53,$fd,$04,$35,$34,$00
>91c8	1f 93 00 d9 8b 41 7a 7a			.byte	$1f,$93,$00,$d9,$8b,$41,$7a,$7a
>91d0	64 fd 03 39 8b 8b 42 54			.byte	$64,$fd,$03,$39,$8b,$8b,$42,$54
>91d8	56 43 fd 04 36 38 84 59			.byte	$56,$43,$fd,$04,$36,$38,$84,$59
>91e0	5b 5e fd 04 37 38 00 1f			.byte	$5b,$5e,$fd,$04,$37,$38,$00,$1f
>91e8	94 00 d9 42 7d 61 5f fd			.byte	$94,$00,$d9,$42,$7d,$61,$5f,$fd
>91f0	04 33 34 8b 8b 42 73 66			.byte	$04,$33,$34,$8b,$8b,$42,$73,$66
>91f8	7d fd 04 33 33 84 45 71			.byte	$7d,$fd,$04,$33,$33,$84,$45,$71
>9200	48 5c fd 03 37 00 1f 95			.byte	$48,$5c,$fd,$03,$37,$00,$1f,$95
>9208	00 d9 8b 62 71 59 fd 04			.byte	$00,$d9,$8b,$62,$71,$59,$fd,$04
>9210	33 32 8b 7c 5f 55 fd 04			.byte	$33,$32,$8b,$7c,$5f,$55,$fd,$04
>9218	36 34 84 8b 41 5f 50 6e			.byte	$36,$34,$84,$8b,$41,$5f,$50,$6e
>9220	fd 04 39 36 00 1d 96 00			.byte	$fd,$04,$39,$36,$00,$1d,$96,$00
>9228	d9 42 74 66 60 fd 04 39			.byte	$d9,$42,$74,$66,$60,$fd,$04,$39
>9230	34 8b 68 69 7a fd 03 37			.byte	$34,$8b,$68,$69,$7a,$fd,$03,$37
>9238	84 42 4b 7c 66 fd 04 32			.byte	$84,$42,$4b,$7c,$66,$fd,$04,$32
>9240	33 00 20 97 00 d9 8b 42			.byte	$33,$00,$20,$97,$00,$d9,$8b,$42
>9248	7b 64 6b fd 04 33 37 8b			.byte	$7b,$64,$6b,$fd,$04,$33,$37,$8b
>9250	41 71 56 56 fd 04 37 31			.byte	$41,$71,$56,$56,$fd,$04,$37,$31
>9258	84 8b 44 6c 7b 42 fd 03			.byte	$84,$8b,$44,$6c,$7b,$42,$fd,$03
>9260	31 00 20 98 00 d9 41 46			.byte	$31,$00,$20,$98,$00,$d9,$41,$46
>9268	76 43 fd 04 33 35 8b 8b			.byte	$76,$43,$fd,$04,$33,$35,$8b,$8b
>9270	42 44 62 55 fd 04 39 39			.byte	$42,$44,$62,$55,$fd,$04,$39,$39
>9278	84 43 4b 58 59 fd 04 33			.byte	$84,$43,$4b,$58,$59,$fd,$04,$33
>9280	34 00 1f 99 00 d9 43 68			.byte	$34,$00,$1f,$99,$00,$d9,$43,$68
>9288	4f 6f fd 04 31 34 8b 8b			.byte	$4f,$6f,$fd,$04,$31,$34,$8b,$8b
>9290	42 76 7c 74 fd 04 37 37			.byte	$42,$76,$7c,$74,$fd,$04,$37,$37
>9298	84 46 5f 4c 63 fd 03 39			.byte	$84,$46,$5f,$4c,$63,$fd,$03,$39
>92a0	00 21 9a 00 d9 8b 41 7f			.byte	$00,$21,$9a,$00,$d9,$8b,$41,$7f
>92a8	7a 6f fd 04 32 33 8b 8b			.byte	$7a,$6f,$fd,$04,$32,$33,$8b,$8b
>92b0	41 42 4e 7c fd 04 32 36			.byte	$41,$42,$4e,$7c,$fd,$04,$32,$36
>92b8	84 8b 7d 6b 72 fd 04 39			.byte	$84,$8b,$7d,$6b,$72,$fd,$04,$39
>92c0	37 00 20 9b 00 d9 8b 42			.byte	$37,$00,$20,$9b,$00,$d9,$8b,$42
>92c8	52 59 44 fd 04 34 34 8b			.byte	$52,$59,$44,$fd,$04,$34,$34,$8b
>92d0	43 57 64 7f fd 04 38 35			.byte	$43,$57,$64,$7f,$fd,$04,$38,$35
>92d8	84 8b 45 69 7e 44 fd 03			.byte	$84,$8b,$45,$69,$7e,$44,$fd,$03
>92e0	33 00 1e 9c 00 d9 74 4d			.byte	$33,$00,$1e,$9c,$00,$d9,$74,$4d
>92e8	46 fd 04 39 36 8b 41 5f			.byte	$46,$fd,$04,$39,$36,$8b,$41,$5f
>92f0	42 5c fd 04 30 38 84 8b			.byte	$42,$5c,$fd,$04,$30,$38,$84,$8b
>92f8	6a 75 55 fd 04 31 32 00			.byte	$6a,$75,$55,$fd,$04,$31,$32,$00
>9300	21 9d 00 d9 8b 41 64 57			.byte	$21,$9d,$00,$d9,$8b,$41,$64,$57
>9308	7d fd 04 30 33 8b 8b 41			.byte	$7d,$fd,$04,$30,$33,$8b,$8b,$41
>9310	44 6d 45 fd 04 38 37 84			.byte	$44,$6d,$45,$fd,$04,$38,$37,$84
>9318	8b 5f 6a 77 fd 04 31 37			.byte	$8b,$5f,$6a,$77,$fd,$04,$31,$37
>9320	00 1e 9e 00 d9 8b 68 44			.byte	$00,$1e,$9e,$00,$d9,$8b,$68,$44
>9328	40 fd 03 32 8b 65 53 54			.byte	$40,$fd,$03,$32,$8b,$65,$53,$54
>9330	fd 04 34 39 84 8b 41 4d			.byte	$fd,$04,$34,$39,$84,$8b,$41,$4d
>9338	57 54 fd 04 36 39 00 1f			.byte	$57,$54,$fd,$04,$36,$39,$00,$1f
>9340	9f 00 d9 8b 7c 4f 53 fd			.byte	$9f,$00,$d9,$8b,$7c,$4f,$53,$fd
>9348	04 32 39 8b 8b 41 6f 7e			.byte	$04,$32,$39,$8b,$8b,$41,$6f,$7e
>9350	5e fd 04 31 34 84 73 6f			.byte	$5e,$fd,$04,$31,$34,$84,$73,$6f
>9358	4a fd 04 38 36 00 1f a0			.byte	$4a,$fd,$04,$38,$36,$00,$1f,$a0
>9360	00 d9 42 45 5d 65 fd 04			.byte	$00,$d9,$42,$45,$5d,$65,$fd,$04
>9368	33 38 8b 8b 42 6a 75 5a			.byte	$33,$38,$8b,$8b,$42,$6a,$75,$5a
>9370	fd 04 34 37 84 44 70 52			.byte	$fd,$04,$34,$37,$84,$44,$70,$52
>9378	7f fd 03 38 00 22 a1 00			.byte	$7f,$fd,$03,$38,$00,$22,$a1,$00
>9380	d9 8b 43 4b 51 45 fd 04			.byte	$d9,$8b,$43,$4b,$51,$45,$fd,$04
>9388	33 39 8b 8b 41 7f 4a 7c			.byte	$33,$39,$8b,$8b,$41,$7f,$4a,$7c
>9390	fd 04 32 38 84 8b 41 4c			.byte	$fd,$04,$32,$38,$84,$8b,$41,$4c
>9398	46 49 fd 04 31 31 00 22			.byte	$46,$49,$fd,$04,$31,$31,$00,$22
>93a0	a2 00 d9 8b 51 41 63 fd			.byte	$a2,$00,$d9,$8b,$51,$41,$63,$fd
>93a8	05 32 34 39 8b 8b 44 7d			.byte	$05,$32,$34,$39,$8b,$8b,$44,$7d
>93b0	60 fd 05 30 38 35 84 8b			.byte	$60,$fd,$05,$30,$38,$35,$84,$8b
>93b8	4c 44 43 fd 05 31 36 34			.byte	$4c,$44,$43,$fd,$05,$31,$36,$34
>93c0	00 1e a3 00 d9 42 78 77			.byte	$00,$1e,$a3,$00,$d9,$42,$78,$77
>93c8	73 fd 04 34 34 8b 41 52			.byte	$73,$fd,$04,$34,$34,$8b,$41,$52
>93d0	5c 62 fd 03 34 84 41 66			.byte	$5c,$62,$fd,$03,$34,$84,$41,$66
>93d8	5b 51 fd 04 30 35 00 1f			.byte	$5b,$51,$fd,$04,$30,$35,$00,$1f
>93e0	a4 00 d9 41 76 7e 5d fd			.byte	$a4,$00,$d9,$41,$76,$7e,$5d,$fd
>93e8	04 33 38 8b 8b 41 66 5a			.byte	$04,$33,$38,$8b,$8b,$41,$66,$5a
>93f0	7c fd 04 35 32 84 43 5d			.byte	$7c,$fd,$04,$35,$32,$84,$43,$5d
>93f8	59 59 fd 03 39 00 1e a5			.byte	$59,$59,$fd,$03,$39,$00,$1e,$a5
>9400	00 d9 8b 60 5b 7a fd 03			.byte	$00,$d9,$8b,$60,$5b,$7a,$fd,$03
>9408	38 8b 41 73 70 fd 05 37			.byte	$38,$8b,$41,$73,$70,$fd,$05,$37
>9410	38 35 84 8b 62 4f 6b fd			.byte	$38,$35,$84,$8b,$62,$4f,$6b,$fd
>9418	04 35 38 00 20 a6 00 d9			.byte	$04,$35,$38,$00,$20,$a6,$00,$d9
>9420	8b 43 6d 5f 7c fd 04 32			.byte	$8b,$43,$6d,$5f,$7c,$fd,$04,$32
>9428	38 8b 43 53 67 53 fd 04			.byte	$38,$8b,$43,$53,$67,$53,$fd,$04
>9430	39 36 84 8b 47 41 47 50			.byte	$39,$36,$84,$8b,$47,$41,$47,$50
>9438	fd 03 32 00 20 a7 00 d9			.byte	$fd,$03,$32,$00,$20,$a7,$00,$d9
>9440	8b 42 71 51 74 fd 04 30			.byte	$8b,$42,$71,$51,$74,$fd,$04,$30
>9448	38 8b 41 45 7f 65 fd 04			.byte	$38,$8b,$41,$45,$7f,$65,$fd,$04
>9450	37 33 84 8b 43 77 51 59			.byte	$37,$33,$84,$8b,$43,$77,$51,$59
>9458	fd 03 38 00 21 a8 00 d9			.byte	$fd,$03,$38,$00,$21,$a8,$00,$d9
>9460	8b 41 77 5f 5e fd 04 32			.byte	$8b,$41,$77,$5f,$5e,$fd,$04,$32
>9468	33 8b 8b 42 77 7a 60 fd			.byte	$33,$8b,$8b,$42,$77,$7a,$60,$fd
>9470	04 30 37 84 41 40 5b 41			.byte	$04,$30,$37,$84,$41,$40,$5b,$41
>9478	fd 04 38 34 00 21 a9 00			.byte	$fd,$04,$38,$34,$00,$21,$a9,$00
>9480	d9 8b 43 47 7b 75 fd 04			.byte	$d9,$8b,$43,$47,$7b,$75,$fd,$04
>9488	39 35 8b 8b 43 5a 64 72			.byte	$39,$35,$8b,$8b,$43,$5a,$64,$72
>9490	fd 04 31 38 84 52 68 7c			.byte	$fd,$04,$31,$38,$84,$52,$68,$7c
>9498	fd 05 32 33 31 00 1e aa			.byte	$fd,$05,$32,$33,$31,$00,$1e,$aa
>94a0	00 d9 8b 42 67 41 7a fd			.byte	$00,$d9,$8b,$42,$67,$41,$7a,$fd
>94a8	03 31 8b 42 5e 74 4a fd			.byte	$03,$31,$8b,$42,$5e,$74,$4a,$fd
>94b0	03 39 84 8b 45 45 76 45			.byte	$03,$39,$84,$8b,$45,$45,$76,$45
>94b8	fd 03 30 00 1f ab 00 d9			.byte	$fd,$03,$30,$00,$1f,$ab,$00,$d9
>94c0	8b 41 78 42 fd 05 32 33			.byte	$8b,$41,$78,$42,$fd,$05,$32,$33
>94c8	37 8b 79 45 41 fd 04 31			.byte	$37,$8b,$79,$45,$41,$fd,$04,$31
>94d0	39 84 8b 7a 7d 43 fd 04			.byte	$39,$84,$8b,$7a,$7d,$43,$fd,$04
>94d8	34 33 00 20 ac 00 d9 8b			.byte	$34,$33,$00,$20,$ac,$00,$d9,$8b
>94e0	41 5c 78 54 fd 04 37 37			.byte	$41,$5c,$78,$54,$fd,$04,$37,$37
>94e8	8b 8b 77 7c 52 fd 04 32			.byte	$8b,$8b,$77,$7c,$52,$fd,$04,$32
>94f0	36 84 8b 64 7c 42 fd 04			.byte	$36,$84,$8b,$64,$7c,$42,$fd,$04
>94f8	35 31 00 21 ad 00 d9 8b			.byte	$35,$31,$00,$21,$ad,$00,$d9,$8b
>9500	54 65 5f fd 05 39 32 35			.byte	$54,$65,$5f,$fd,$05,$39,$32,$35
>9508	8b 8b 41 6d 67 6a fd 04			.byte	$8b,$8b,$41,$6d,$67,$6a,$fd,$04
>9510	36 36 84 41 59 42 4a fd			.byte	$36,$36,$84,$41,$59,$42,$4a,$fd
>9518	04 37 34 00 1f ae 00 d9			.byte	$04,$37,$34,$00,$1f,$ae,$00,$d9
>9520	42 77 44 75 fd 04 38 39			.byte	$42,$77,$44,$75,$fd,$04,$38,$39
>9528	8b 8b 41 63 73 5d fd 04			.byte	$8b,$8b,$41,$63,$73,$5d,$fd,$04
>9530	39 34 84 44 5a 78 53 fd			.byte	$39,$34,$84,$44,$5a,$78,$53,$fd
>9538	03 38 00 1f af 00 d9 43			.byte	$03,$38,$00,$1f,$af,$00,$d9,$43
>9540	5c 65 42 fd 04 35 39 8b			.byte	$5c,$65,$42,$fd,$04,$35,$39,$8b
>9548	8b 42 6d 43 58 fd 04 35			.byte	$8b,$42,$6d,$43,$58,$fd,$04,$35
>9550	35 84 46 49 68 5b fd 03			.byte	$35,$84,$46,$49,$68,$5b,$fd,$03
>9558	31 00 1f b0 00 d9 8b 62			.byte	$31,$00,$1f,$b0,$00,$d9,$8b,$62
>9560	43 7e fd 04 35 34 8b 8b			.byte	$43,$7e,$fd,$04,$35,$34,$8b,$8b
>9568	41 74 72 7c fd 04 35 34			.byte	$41,$74,$72,$7c,$fd,$04,$35,$34
>9570	84 41 52 6e 7e fd 03 30			.byte	$84,$41,$52,$6e,$7e,$fd,$03,$30
>9578	00 21 b1 00 d9 8b 44 75			.byte	$00,$21,$b1,$00,$d9,$8b,$44,$75
>9580	58 fd 05 37 30 34 8b 8b			.byte	$58,$fd,$05,$37,$30,$34,$8b,$8b
>9588	43 44 61 64 fd 04 32 35			.byte	$43,$44,$61,$64,$fd,$04,$32,$35
>9590	84 42 7f 6c 4b fd 04 35			.byte	$84,$42,$7f,$6c,$4b,$fd,$04,$35
>9598	34 00 20 b2 00 d9 8b 51			.byte	$34,$00,$20,$b2,$00,$d9,$8b,$51
>95a0	62 48 fd 05 31 39 34 8b			.byte	$62,$48,$fd,$05,$31,$39,$34,$8b
>95a8	8b 54 62 46 fd 05 38 30			.byte	$8b,$54,$62,$46,$fd,$05,$38,$30
>95b0	34 84 42 7f 7e fd 04 36			.byte	$34,$84,$42,$7f,$7e,$fd,$04,$36
>95b8	31 00 1d b3 00 d9 77 7e			.byte	$31,$00,$1d,$b3,$00,$d9,$77,$7e
>95c0	61 fd 04 30 38 8b 55 59			.byte	$61,$fd,$04,$30,$38,$8b,$55,$59
>95c8	53 fd 05 37 39 32 84 62			.byte	$53,$fd,$05,$37,$39,$32,$84,$62
>95d0	65 4d fd 04 32 39 00 20			.byte	$65,$4d,$fd,$04,$32,$39,$00,$20
>95d8	b4 00 d9 8b 43 51 4f 44			.byte	$b4,$00,$d9,$8b,$43,$51,$4f,$44
>95e0	fd 04 38 32 8b 41 4c 53			.byte	$fd,$04,$38,$32,$8b,$41,$4c,$53
>95e8	69 fd 04 34 37 84 8b 44			.byte	$69,$fd,$04,$34,$37,$84,$8b,$44
>95f0	5d 62 6e fd 03 33 00 20			.byte	$5d,$62,$6e,$fd,$03,$33,$00,$20
>95f8	b5 00 d9 8b 43 51 57 46			.byte	$b5,$00,$d9,$8b,$43,$51,$57,$46
>9600	fd 04 30 37 8b 41 5d 61			.byte	$fd,$04,$30,$37,$8b,$41,$5d,$61
>9608	4d fd 04 32 38 84 8b 44			.byte	$4d,$fd,$04,$32,$38,$84,$8b,$44
>9610	6e 78 53 fd 03 34 00 20			.byte	$6e,$78,$53,$fd,$03,$34,$00,$20
>9618	b6 00 d9 8b 41 40 69 5b			.byte	$b6,$00,$d9,$8b,$41,$40,$69,$5b
>9620	fd 04 36 36 8b 43 54 60			.byte	$fd,$04,$36,$36,$8b,$43,$54,$60
>9628	54 fd 04 37 34 84 8b 44			.byte	$54,$fd,$04,$37,$34,$84,$8b,$44
>9630	55 49 70 fd 03 34 00 21			.byte	$55,$49,$70,$fd,$03,$34,$00,$21
>9638	b7 00 d9 8b 41 75 76 49			.byte	$b7,$00,$d9,$8b,$41,$75,$76,$49
>9640	fd 04 34 34 8b 41 59 6d			.byte	$fd,$04,$34,$34,$8b,$41,$59,$6d
>9648	5d fd 04 31 37 84 8b 43			.byte	$5d,$fd,$04,$31,$37,$84,$8b,$43
>9650	4f 63 66 fd 04 36 31 00			.byte	$4f,$63,$66,$fd,$04,$36,$31,$00
>9658	20 b8 00 d9 8b 41 6d 6f			.byte	$20,$b8,$00,$d9,$8b,$41,$6d,$6f
>9660	52 fd 04 32 37 8b 43 69			.byte	$52,$fd,$04,$32,$37,$8b,$43,$69
>9668	5d 48 fd 04 30 32 84 8b			.byte	$5d,$48,$fd,$04,$30,$32,$84,$8b
>9670	45 57 4c 5a fd 03 33 00			.byte	$45,$57,$4c,$5a,$fd,$03,$33,$00
>9678	20 b9 00 d9 8b 42 6f 55			.byte	$20,$b9,$00,$d9,$8b,$42,$6f,$55
>9680	75 fd 04 34 31 8b 8b 79			.byte	$75,$fd,$04,$34,$31,$8b,$8b,$79
>9688	60 53 fd 03 36 84 8b 41			.byte	$60,$53,$fd,$03,$36,$84,$8b,$41
>9690	75 75 61 fd 04 38 31 00			.byte	$75,$75,$61,$fd,$04,$38,$31,$00
>9698	1f ba 00 d9 42 68 60 5b			.byte	$1f,$ba,$00,$d9,$42,$68,$60,$5b
>96a0	fd 04 35 34 8b 43 4d 5c			.byte	$fd,$04,$35,$34,$8b,$43,$4d,$5c
>96a8	71 fd 04 38 33 84 8b 64			.byte	$71,$fd,$04,$38,$33,$84,$8b,$64
>96b0	7c 56 fd 04 32 39 00 1e			.byte	$7c,$56,$fd,$04,$32,$39,$00,$1e
>96b8	bb 00 d9 41 55 66 72 fd			.byte	$bb,$00,$d9,$41,$55,$66,$72,$fd
>96c0	03 38 8b 41 52 7f 5a fd			.byte	$03,$38,$8b,$41,$52,$7f,$5a,$fd
>96c8	04 35 37 84 42 67 58 fd			.byte	$04,$35,$37,$84,$42,$67,$58,$fd
>96d0	05 32 32 39 00 20 bc 00			.byte	$05,$32,$32,$39,$00,$20,$bc,$00
>96d8	d9 47 66 5d fd 05 35 30			.byte	$d9,$47,$66,$5d,$fd,$05,$35,$30
>96e0	32 8b 8b 43 5e 66 77 fd			.byte	$32,$8b,$8b,$43,$5e,$66,$77,$fd
>96e8	04 33 39 84 43 66 4d 54			.byte	$04,$33,$39,$84,$43,$66,$4d,$54
>96f0	fd 04 38 39 00 1f bd 00			.byte	$fd,$04,$38,$39,$00,$1f,$bd,$00
>96f8	d9 5c 61 68 fd 04 32 34			.byte	$d9,$5c,$61,$68,$fd,$04,$32,$34
>9700	8b 8b 42 41 75 65 fd 04			.byte	$8b,$8b,$42,$41,$75,$65,$fd,$04
>9708	38 39 84 42 5e 57 4e fd			.byte	$38,$39,$84,$42,$5e,$57,$4e,$fd
>9710	04 31 32 00 1f be 00 d9			.byte	$04,$31,$32,$00,$1f,$be,$00,$d9
>9718	42 5e 43 4f fd 04 35 34			.byte	$42,$5e,$43,$4f,$fd,$04,$35,$34
>9720	8b 42 7b 76 55 fd 04 33			.byte	$8b,$42,$7b,$76,$55,$fd,$04,$33
>9728	36 84 8b 5d 73 45 fd 04			.byte	$36,$84,$8b,$5d,$73,$45,$fd,$04
>9730	38 32 00 1e bf 00 d9 43			.byte	$38,$32,$00,$1e,$bf,$00,$d9,$43
>9738	71 6d 59 fd 04 34 36 8b			.byte	$71,$6d,$59,$fd,$04,$34,$36,$8b
>9740	43 56 7f 41 fd 04 39 33			.byte	$43,$56,$7f,$41,$fd,$04,$39,$33
>9748	84 5a 6e 57 fd 04 35 33			.byte	$84,$5a,$6e,$57,$fd,$04,$35,$33
>9750	00 22 c0 00 d9 8b 42 42			.byte	$00,$22,$c0,$00,$d9,$8b,$42,$42
>9758	68 59 fd 04 39 31 8b 8b			.byte	$68,$59,$fd,$04,$39,$31,$8b,$8b
>9760	57 7e 57 fd 05 34 33 38			.byte	$57,$7e,$57,$fd,$05,$34,$33,$38
>9768	84 8b 41 6a 6a 42 fd 04			.byte	$84,$8b,$41,$6a,$6a,$42,$fd,$04
>9770	34 38 00 1f c1 00 d9 43			.byte	$34,$38,$00,$1f,$c1,$00,$d9,$43
>9778	54 72 68 fd 04 39 37 8b			.byte	$54,$72,$68,$fd,$04,$39,$37,$8b
>9780	41 5d 54 4e fd 04 34 33			.byte	$41,$5d,$54,$4e,$fd,$04,$34,$33
>9788	84 41 77 5e 5a fd 04 35			.byte	$84,$41,$77,$5e,$5a,$fd,$04,$35
>9790	34 00 20 c2 00 d9 41 42			.byte	$34,$00,$20,$c2,$00,$d9,$41,$42
>9798	5b 56 fd 04 37 39 8b 43			.byte	$5b,$56,$fd,$04,$37,$39,$8b,$43
>97a0	62 7c 61 fd 04 31 34 84			.byte	$62,$7c,$61,$fd,$04,$31,$34,$84
>97a8	8b 42 60 61 4a fd 04 33			.byte	$8b,$42,$60,$61,$4a,$fd,$04,$33
>97b0	35 00 22 c3 00 d9 8b 42			.byte	$35,$00,$22,$c3,$00,$d9,$8b,$42
>97b8	67 56 49 fd 04 30 31 8b			.byte	$67,$56,$49,$fd,$04,$30,$31,$8b
>97c0	8b 41 4e 6b 57 fd 04 32			.byte	$8b,$41,$4e,$6b,$57,$fd,$04,$32
>97c8	36 84 8b 41 58 6a 71 fd			.byte	$36,$84,$8b,$41,$58,$6a,$71,$fd
>97d0	04 37 35 00 20 c4 00 d9			.byte	$04,$37,$35,$00,$20,$c4,$00,$d9
>97d8	42 6e 66 49 fd 04 37 38			.byte	$42,$6e,$66,$49,$fd,$04,$37,$38
>97e0	8b 8b 52 6b 63 fd 05 33			.byte	$8b,$8b,$52,$6b,$63,$fd,$05,$33
>97e8	39 35 84 43 41 51 6d fd			.byte	$39,$35,$84,$43,$41,$51,$6d,$fd
>97f0	04 31 37 00 20 c5 00 d9			.byte	$04,$31,$37,$00,$20,$c5,$00,$d9
>97f8	54 4d 6e fd 05 35 32 37			.byte	$54,$4d,$6e,$fd,$05,$35,$32,$37
>9800	8b 41 5c 6b 47 fd 04 32			.byte	$8b,$41,$5c,$6b,$47,$fd,$04,$32
>9808	39 84 8b 41 48 5d 58 fd			.byte	$39,$84,$8b,$41,$48,$5d,$58,$fd
>9810	04 37 37 00 1e c6 00 d9			.byte	$04,$37,$37,$00,$1e,$c6,$00,$d9
>9818	42 40 6a 40 fd 04 31 37			.byte	$42,$40,$6a,$40,$fd,$04,$31,$37
>9820	8b 42 7f 56 77 fd 03 31			.byte	$8b,$42,$7f,$56,$77,$fd,$03,$31
>9828	84 8b 7e 6c 76 fd 04 39			.byte	$84,$8b,$7e,$6c,$76,$fd,$04,$39
>9830	34 00 1f c7 00 d9 42 49			.byte	$34,$00,$1f,$c7,$00,$d9,$42,$49
>9838	66 7c fd 04 37 34 8b 8b			.byte	$66,$7c,$fd,$04,$37,$34,$8b,$8b
>9840	41 74 6d 58 fd 04 30 38			.byte	$41,$74,$6d,$58,$fd,$04,$30,$38
>9848	84 43 7e 54 54 fd 03 38			.byte	$84,$43,$7e,$54,$54,$fd,$03,$38
>9850	00 1d c8 00 d9 41 46 44			.byte	$00,$1d,$c8,$00,$d9,$41,$46,$44
>9858	76 fd 04 35 39 8b 62 75			.byte	$76,$fd,$04,$35,$39,$8b,$62,$75
>9860	79 fd 04 35 38 84 63 4e			.byte	$79,$fd,$04,$35,$38,$84,$63,$4e
>9868	7d fd 04 30 32 00 1e c9			.byte	$7d,$fd,$04,$30,$32,$00,$1e,$c9
>9870	00 d9 42 41 44 7a fd 04			.byte	$00,$d9,$42,$41,$44,$7a,$fd,$04
>9878	34 36 8b 6a 7d 6c fd 04			.byte	$34,$36,$8b,$6a,$7d,$6c,$fd,$04
>9880	36 39 84 41 56 47 4d fd			.byte	$36,$39,$84,$41,$56,$47,$4d,$fd
>9888	04 37 37 00 10 ca 00 d4			.byte	$04,$37,$37,$00,$10,$ca,$00,$d4
>9890	fe 09 50 61 73 73 65 64			.byte	$fe,$09,$50,$61,$73,$73,$65,$64
>9898	2e be c2 00 00				.byte	$2e,$be,$c2,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 40 a2	jsr $a240			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c a2 ad	jmp $ada2		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 a7 a1	jsr $a1a7			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 a7 a1	jsr $a1a7			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 16		beq $a05b			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 73 a0	jsr $a073			jsr 	IFT_UpperCase 				; make upper case
.a049	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_NewLine:
.a05b	48		pha				pha
.a05c	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine 					; new line on actual screen.
.a05f	a9 00		lda #$00			lda 	#0 							; reset x position
.a061	8d 00 02	sta $0200			sta 	IFT_XCursor
.a064	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a067	ad 01 02	lda $0201			lda 	IFT_YCursor
.a06a	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a06c	d0 03		bne $a071			bne 	_IFT_NL_NotEOS
.a06e	20 7e a0	jsr $a07e			jsr 	IFT_Scroll 					; scroll screen up.
.a071					_IFT_NL_NotEOS:
.a071	68		pla				pla
.a072	60		rts				rts
.a073					IFT_UpperCase:
.a073	c9 61		cmp #$61			cmp 	#"a"
.a075	90 06		bcc $a07d			bcc 	_IFT_UCExit
.a077	c9 7b		cmp #$7b			cmp 	#"z"+1
.a079	b0 02		bcs $a07d			bcs 	_IFT_UCExit
.a07b	49 20		eor #$20			eor 	#$20
.a07d					_IFT_UCExit:
.a07d	60		rts				rts
.a07e					IFT_Scroll:
.a07e	48		pha				pha 								; save AXY
.a07f	da		phx				phx
.a080	5a		phy				phy
.a081	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a083					_IFT_SLoop:
.a083	20 a3 a0	jsr $a0a3			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a086	e8		inx				inx
.a087	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a089	d0 f8		bne $a083			bne 	_IFT_SLoop
.a08b	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a08d	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a090	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a092					_IFT_SBlank:
.a092	a9 20		lda #$20			lda 	#32
.a094	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a097	ca		dex				dex
.a098	d0 f8		bne $a092			bne 	_IFT_SBlank
.a09a	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09c	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a09f	7a		ply				ply
.a0a0	fa		plx				plx
.a0a1	68		pla				pla
.a0a2	60		rts				rts
.a0a3					_IFT_ScrollLine:
.a0a3	da		phx				phx
.a0a4	da		phx				phx
.a0a5	8a		txa				txa 								; copy line into buffer.
.a0a6	1a		inc a				inc 	a 							; next line down.
.a0a7	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0aa	a2 00		ldx #$00			ldx 	#0
.a0ac					_IFTScrollCopy1:
.a0ac	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a0af	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0b2	e8		inx				inx
.a0b3	e0 50		cpx #$50			cpx 	#IF_Width
.a0b5	d0 f5		bne $a0ac			bne 	_IFTScrollCopy1
.a0b7	68		pla				pla
.a0b8	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a0bb	a2 00		ldx #$00			ldx 	#0
.a0bd					_IFTScrollCopy2:
.a0bd	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0c0	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a0c3	e8		inx				inx
.a0c4	e0 50		cpx #$50			cpx 	#IF_Width
.a0c6	d0 f5		bne $a0bd			bne 	_IFTScrollCopy2
.a0c8	fa		plx				plx
.a0c9	60		rts				rts
.a0ca					IFT_SetYPos:
.a0ca	48		pha				pha
.a0cb	da		phx				phx
.a0cc	aa		tax				tax
.a0cd	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0d0	e0 00		cpx #$00			cpx 	#0
.a0d2	f0 09		beq $a0dd			beq 	_IFT_MOAExit
.a0d4					_IFT_MOALoop:
.a0d4	20 b6 a1	jsr $a1b6			jsr 	IF_NewLine
.a0d7	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0da	ca		dex				dex
.a0db	d0 f7		bne $a0d4			bne		_IFT_MOALoop
.a0dd					_IFT_MOAExit:
.a0dd	fa		plx				plx
.a0de	68		pla				pla
.a0df	60		rts				rts
.a0e0					IFT_GetKeyCursor:
.a0e0	20 e8 a0	jsr $a0e8			jsr 	_IFT_FlipCursor 			; reverse current
.a0e3					_IFT_GKCWait:
.a0e3	20 f9 a1	jsr $a1f9			jsr 	IF_GetKey 					; get key
.a0e6	f0 fb		beq $a0e3			beq 	_IFT_GKCWait
.a0e8					_IFT_FlipCursor:
.a0e8	48		pha				pha 								; save
.a0e9	20 c8 a1	jsr $a1c8			jsr 	IF_Read 					; read
.a0ec	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0ef	49 80		eor #$80			eor 	#$80 						; reverse
.a0f1	20 d6 a1	jsr $a1d6			jsr 	IF_Write 					; write
.a0f4	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a0f7	68		pla				pla
.a0f8	60		rts				rts
.a0f9					IFT_ReadLine:
.a0f9	48		pha				pha
.a0fa					_IFT_RLLoop:
.a0fa	20 e0 a0	jsr $a0e0			jsr 	IFT_GetKeyCursor 			; get keystroke
.a0fd	c9 0d		cmp #$0d			cmp 	#13							; return
.a0ff	f0 7d		beq $a17e			beq 	_IFT_RLExit
.a101	c9 20		cmp #$20			cmp 	#32 						; control character
.a103	90 05		bcc $a10a			bcc 	_IFT_Control
.a105	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a108	80 f0		bra $a0fa			bra 	_IFT_RLLoop
.a10a					_IFT_Control:
.a10a	c9 01		cmp #$01			cmp 	#"A"-64
.a10c	f0 26		beq $a134			beq 	_IFT_Left
.a10e	c9 04		cmp #$04			cmp 	#"D"-64
.a110	f0 2e		beq $a140			beq 	_IFT_Right
.a112	c9 17		cmp #$17			cmp 	#"W"-64
.a114	f0 36		beq $a14c			beq 	_IFT_Up
.a116	c9 13		cmp #$13			cmp 	#"S"-64
.a118	f0 3e		beq $a158			beq 	_IFT_Down
.a11a	c9 08		cmp #$08			cmp 	#"H"-64
.a11c	f0 09		beq $a127			beq 	_IFT_Backspace
.a11e	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a120	d0 d8		bne $a0fa			bne 	_IFT_RLLoop
.a122	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a125	80 d3		bra $a0fa			bra 	_IFT_RLLoop
.a127					_IFT_Backspace:
.a127	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a12a	f0 ce		beq $a0fa			beq 	_IFT_RLLoop
.a12c	20 e1 a1	jsr $a1e1			jsr 	IF_LeftOne
.a12f	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a131	20 d6 a1	jsr $a1d6			jsr 	IF_Write
.a134					_IFT_Left:
.a134	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a137	10 29		bpl $a162			bpl 	_IFT_Reposition
.a139	a9 4f		lda #$4f			lda 	#IF_Width-1
.a13b					_IFT_SetX:
.a13b	8d 00 02	sta $0200			sta 	IFT_XCursor
.a13e	80 22		bra $a162			bra 	_IFT_Reposition
.a140					_IFT_Right:
.a140	ee 00 02	inc $0200			inc 	IFT_XCursor
.a143	ad 00 02	lda $0200			lda 	IFT_XCursor
.a146	49 50		eor #$50			eor 	#IF_Width
.a148	f0 f1		beq $a13b			beq 	_IFT_SetX
.a14a	80 16		bra $a162			bra 	_IFT_Reposition
.a14c					_IFT_Up:
.a14c	ce 01 02	dec $0201			dec 	IFT_YCursor
.a14f	10 11		bpl $a162			bpl 	_IFT_Reposition
.a151	a9 18		lda #$18			lda 	#IF_Height-1
.a153					_IFT_SetY:
.a153	8d 01 02	sta $0201			sta 	IFT_YCursor
.a156	80 0a		bra $a162			bra 	_IFT_Reposition
.a158					_IFT_Down:
.a158	ee 01 02	inc $0201			inc 	IFT_YCursor
.a15b	ad 01 02	lda $0201			lda 	IFT_YCursor
.a15e	49 19		eor #$19			eor 	#IF_Height
.a160	f0 f1		beq $a153			beq 	_IFT_SetY
.a162					_IFT_Reposition:
.a162	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a165	48		pha				pha
.a166	ad 01 02	lda $0201			lda 	IFT_YCursor
.a169	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a16c	68		pla				pla
.a16d	aa		tax				tax
.a16e	e0 00		cpx #$00			cpx 	#0
.a170	f0 88		beq $a0fa			beq 	_IFT_RLLoop
.a172					_IFT_MoveRight:
.a172	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a175	ee 00 02	inc $0200			inc 	IFT_XCursor
.a178	ca		dex				dex
.a179	d0 f7		bne $a172			bne 	_IFT_MoveRight
.a17b	4c fa a0	jmp $a0fa			jmp 	_IFT_RLLoop
.a17e					_IFT_RLExit:
.a17e	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a181	20 ca a0	jsr $a0ca			jsr 	IFT_SetYPos
.a184	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a186					_IFT_RLRead:
.a186	20 c8 a1	jsr $a1c8			jsr 	IF_Read
.a189	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a18c	e8		inx				inx
.a18d	e0 50		cpx #$50			cpx 	#IF_Width
.a18f	d0 f5		bne $a186			bne 	_IFT_RLRead
.a191					_IFT_RL_Trim:
.a191	ca		dex				dex 	 							; previous char
.a192	30 07		bmi $a19b			bmi 	_IFT_Found 					; gone too far
.a194	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a197	c9 20		cmp #$20			cmp 	#" "
.a199	f0 f6		beq $a191			beq 	_IFT_RL_Trim
.a19b					_IFT_Found:
.a19b	e8		inx				inx 								; forward to non-space
.a19c	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a19e	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1a1	68		pla				pla
.a1a2	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1a4	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1a7					IF_Home:
.a1a7	48		pha				pha 								; reset cursor position
.a1a8	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1aa	85 04		sta $04				sta 	IF_Pos
.a1ac	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1ae	85 05		sta $05				sta 	IF_Pos+1
.a1b0	a9 00		lda #$00			lda 	#0
.a1b2	85 06		sta $06				sta 	IF_XPos
.a1b4	68		pla				pla
.a1b5	60		rts				rts
.a1b6					IF_NewLine:
.a1b6	48		pha				pha
.a1b7	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1b9	85 06		sta $06				sta 	IF_XPos
.a1bb	18		clc				clc 								; down one line
.a1bc	a5 04		lda $04				lda 	IF_Pos
.a1be	69 50		adc #$50			adc 	#80
.a1c0	85 04		sta $04				sta 	IF_Pos
.a1c2	90 02		bcc $a1c6			bcc 	_IF_NoCarry 				; carry through.
.a1c4	e6 05		inc $05				inc 	IF_Pos+1
.a1c6					_IF_NoCarry:
.a1c6	68		pla				pla
.a1c7	60		rts				rts
.a1c8					IF_Read:
.a1c8	5a		phy				phy 								; save current Y
.a1c9	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1cb	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1cd	49 20		eor #$20			eor 	#$20
.a1cf	18		clc				clc
.a1d0	69 20		adc #$20			adc 	#$20
.a1d2	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1d4	7a		ply				ply									; restore Y
.a1d5	60		rts				rts
.a1d6					IF_Write:
.a1d6	5a		phy				phy 								; save current Y
.a1d7	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1d9	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1db	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1dd	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1df	7a		ply				ply									; restore Y
.a1e0	60		rts				rts
.a1e1					IF_LeftOne:
.a1e1	c6 06		dec $06				dec 	IF_XPos
.a1e3	60		rts				rts
.a1e4					IF_CheckBreak:
.a1e4	db		phz				phz
.a1e5	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1e8	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1ea	ea		nop				nop 								; read modifiers.
.a1eb	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1ed	fb		plz				plz 								; restore Z
.a1ee	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1f0	c9 05		cmp #$05			cmp 	#5
.a1f2	f0 02		beq $a1f6			beq 	_IF_CBExit
.a1f4	a9 00		lda #$00			lda 	#0
.a1f6					_IF_CBExit:
.a1f6	c9 00		cmp #$00			cmp 	#0
.a1f8	60		rts				rts
.a1f9					IF_GetKey:
.a1f9	db		phz				phz
.a1fa	20 2d a2	jsr $a22d			jsr 	IF_SetupKeyAddress
.a1fd	ea		nop				nop 								; read keyboard
.a1fe	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a200	c9 14		cmp #$14			cmp 	#20
.a202	d0 02		bne $a206			bne 	_KMNo
.a204	a9 08		lda #$08			lda 	#"H"-64
.a206					_KMNo:
.a206	c9 91		cmp #$91			cmp 	#145
.a208	d0 02		bne $a20c			bne 	_KMNo
.a20a	a9 17		lda #$17			lda 	#"W"-64
.a20c					_KMNo:
.a20c	c9 11		cmp #$11			cmp 	#17
.a20e	d0 02		bne $a212			bne 	_KMNo
.a210	a9 13		lda #$13			lda 	#"S"-64
.a212					_KMNo:
.a212	c9 9d		cmp #$9d			cmp 	#157
.a214	d0 02		bne $a218			bne 	_KMNo
.a216	a9 01		lda #$01			lda 	#"A"-64
.a218					_KMNo:
.a218	c9 1d		cmp #$1d			cmp 	#29
.a21a	d0 02		bne $a21e			bne 	_KMNo
.a21c	a9 04		lda #$04			lda 	#"D"-64
.a21e					_KMNo:
.a21e	c9 00		cmp #$00			cmp 	#0
.a220	f0 07		beq $a229			beq 	_IFGKEmpty
.a222	48		pha				pha
.a223	a9 00		lda #$00			lda 	#0
.a225	ea		nop				nop
.a226	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a228	68		pla				pla
.a229					_IFGKEmpty:
.a229	fb		plz				plz
.a22a	c9 00		cmp #$00			cmp 	#0 							; set Z
.a22c	60		rts				rts
.a22d					IF_SetupKeyAddress:
.a22d	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a22f	85 0b		sta $0b				sta 	IF_FarPtr+3
.a231	a9 fd		lda #$fd			lda 	#$FD
.a233	85 0a		sta $0a				sta 	IF_FarPtr+2
.a235	a9 36		lda #$36			lda 	#$36
.a237	85 09		sta $09				sta 	IF_FarPtr+1
.a239	a9 10		lda #$10			lda 	#$10
.a23b	85 08		sta $08				sta 	IF_FarPtr+0
.a23d	a3 00		ldz #$00			ldz 	#0
.a23f	60		rts				rts
.a240					IF_Reset:
.a240	48		pha				pha 								; save registers
.a241	da		phx				phx
.a242	5a		phy				phy
.a243	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a245	85 0b		sta $0b				sta 	IF_FarPtr+3
.a247	a9 fd		lda #$fd			lda 	#$FD
.a249	85 0a		sta $0a				sta 	IF_FarPtr+2
.a24b	a9 30		lda #$30			lda 	#$30
.a24d	85 09		sta $09				sta 	IF_FarPtr+1
.a24f	a9 00		lda #$00			lda 	#$00
.a251	85 08		sta $08				sta 	IF_FarPtr+0
.a253	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a255	a9 47		lda #$47			lda 	#$47
.a257	ea		nop				nop
.a258	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a25a	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a25c	a9 53		lda #$53			lda 	#$53
.a25e	ea		nop				nop
.a25f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a261	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a263	a9 40		lda #$40			lda 	#$40
.a265	ea		nop				nop
.a266	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a268	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a26a	a9 c0		lda #$c0			lda 	#$80+$40
.a26c	ea		nop				nop
.a26d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26f	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a271	a9 00		lda #$00			lda 	#0
.a273	ea		nop				nop
.a274	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a276	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a278	a9 00		lda #$00			lda 	#0
.a27a	ea		nop				nop
.a27b	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27d	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a27f	a9 40		lda #$40			lda 	#$40
.a281	ea		nop				nop
.a282	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a284	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a286	a9 ff		lda #$ff			lda 	#$FF
.a288	ea		nop				nop
.a289	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28b	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a28d	a9 ff		lda #$ff			lda 	#$FF
.a28f	ea		nop				nop
.a290	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a292	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a294	a9 cc		lda #$cc			lda 	#$CC
.a296	ea		nop				nop
.a297	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a299	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a29b	a9 42		lda #$42			lda 	#$42
.a29d	ea		nop				nop
.a29e	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a0	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2a2	a9 1b		lda #$1b			lda 	#$1B
.a2a4	ea		nop				nop
.a2a5	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a7	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2a9	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2ab	a9 01		lda #$01			lda 	#$01
.a2ad	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2af	a9 f8		lda #$f8			lda 	#$F8
.a2b1	85 09		sta $09				sta 	IF_FarPtr+1
.a2b3	a9 00		lda #$00			lda 	#$00
.a2b5	85 08		sta $08				sta 	IF_FarPtr+0
.a2b7	a3 00		ldz #$00			ldz 	#0
.a2b9					_EXTClearColorRam:
.a2b9	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2bb	ea		nop				nop
.a2bc	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2be	3b		dez				dez
.a2bf	d0 f8		bne $a2b9			bne 	_EXTClearColorRam
.a2c1	e6 09		inc $09				inc 	IF_FarPtr+1
.a2c3	d0 f4		bne $a2b9			bne 	_EXTClearColorRam
.a2c5	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2c7					_EXTCopyCBMFont:
.a2c7	bd 08 a3	lda $a308,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2ca	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2cd	49 ff		eor #$ff			eor 	#$FF
.a2cf	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2d2	bd 08 a4	lda $a408,x			lda 	IF_CBMFont+$100,x
.a2d5	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2d8	49 ff		eor #$ff			eor 	#$FF
.a2da	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2dd	bd 08 a5	lda $a508,x			lda 	IF_CBMFont+$200,x
.a2e0	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2e3	49 ff		eor #$ff			eor 	#$FF
.a2e5	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2e8	bd 08 a6	lda $a608,x			lda 	IF_CBMFont+$300,x
.a2eb	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2ee	49 ff		eor #$ff			eor 	#$FF
.a2f0	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a2f3	ca		dex				dex
.a2f4	d0 d1		bne $a2c7			bne 	_EXTCopyCBMFont
.a2f6	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a2f8	85 01		sta $01				sta 	$01
.a2fa	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a2fc	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a2fe	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a300	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a302	5c		map				map
.a303	ea		nop				eom
.a304	7a		ply				ply 								; restore and exit.
.a305	fa		plx				plx
.a306	68		pla				pla
.a307	60		rts				rts
.a308					IF_CBMFont:
>a308	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a310	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a320	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a330	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a340	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a350	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a360	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a370	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a380	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a390	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a400	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a410	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a420	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a430	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a440	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a450	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a460	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a470	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a480	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a490	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a500	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a510	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a520	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a530	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a540	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a550	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a560	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a570	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a580	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a590	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5a0	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5b0	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5c0	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5d0	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5f0	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a600	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a610	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a620	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a630	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a640	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a650	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a660	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a670	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a680	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a690	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6a0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6b0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6c0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6d0	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6e0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6f0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a700	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a710	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a720	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a730	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a740	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a750	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a760	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a770	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a780	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a790	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7a0	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7b0	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7c0	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7d0	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7e0	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7f0	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a800	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a810	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a820	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a830	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a840	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a850	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a860	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a870	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a880	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a890	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8a0	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8b0	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8c0	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8d0	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8e0	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8f0	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a900	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a910	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a920	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a930	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a940	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a950	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a960	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a970	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a980	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a990	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9a0	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9b0	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9c0	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9d0	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9e0	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9f0	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa00	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa10	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa20	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa30	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa40	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa50	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa60	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa70	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa80	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa90	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaa0	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aab0	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aac0	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aad0	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aae0	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aaf0	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab00	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ab08					SyntaxError:
.ab08	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab0b	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ab13	72 72 6f 72 00
.ab18					TypeError:
.ab18	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab1b	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ab23	70 65 00
.ab26					BadParamError:
.ab26	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>ab29	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ab31	6d 65 74 65 72 00
.ab37					ERR_Handler:
.ab37	a0 00		ldy #$00			ldy 	#0
.ab39	c8		iny				iny
.ab3a	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab3c	8d 08 03	sta $0308			sta 	XS_Mantissa
.ab3f	c8		iny				iny
.ab40	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ab42	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ab45	fa		plx				plx 								; address in XY
.ab46	7a		ply				ply
.ab47	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ab48	d0 01		bne $ab4b			bne 	_EHNoSkip
.ab4a	c8		iny				iny
.ab4b					_EHNoSkip:
.ab4b	20 6c ab	jsr $ab6c			jsr 	PrintROMMessage 			; print message from ROM.
.ab4e	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ab51	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ab54	f0 0c		beq $ab62			beq 	_EHNoLine
.ab56	a2 67		ldx #$67			ldx 	#_EHAt & $FF 				; print " at "
.ab58	a0 ab		ldy #$ab			ldy 	#(_EHAt >> 8) & $FF
.ab5a	20 6c ab	jsr $ab6c			jsr 	PrintROMMessage
.ab5d	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ab5f	20 7d ab	jsr $ab7d			jsr 	Print16BitInteger
.ab62					_EHNoLine:
.ab62	80 fe		bra $ab62			bra 	_EHNoLine
.ab64	4c c2 ad	jmp $adc2			jmp 	WarmStart
>ab67	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ab6c					PrintROMMessage:
.ab6c	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ab6e	84 1b		sty $1b				sty 	zLTemp1+1
.ab70	a0 00		ldy #$00			ldy 	#0
.ab72					_PRMLoop:
.ab72	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ab74	f0 06		beq $ab7c			beq		_PRMExit
.ab76	c8		iny				iny
.ab77	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab7a	80 f6		bra $ab72			bra 	_PRMLoop
.ab7c					_PRMExit:
.ab7c	60		rts				rts
.ab7d					Print16BitInteger:
.ab7d	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ab7f	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ab82	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ab85	8d 00 04	sta $0400			sta 	NumBufX 					; reset the conversion pointer
.ab88	aa		tax				tax 								; convert bottom level.
.ab89	20 8f b8	jsr $b88f			jsr 	INTToString 				; make string
.ab8c	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ab8e	bd 01 04	lda $0401,x	_P1Loop:lda 	Num_Buffer,x
.ab91	f0 06		beq $ab99			beq 	_P1Exit
.ab93	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab96	e8		inx				inx
.ab97	80 f5		bra $ab8e			bra 	_P1Loop
.ab99	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.ab9a					VectorTable:
>ab9a	b0 b0					.word BinaryOp_And         & $FFFF ; $80 and
>ab9c	d8 b0					.word BinaryOp_Or          & $FFFF ; $81 or
>ab9e	00 b1					.word BinaryOp_Xor         & $FFFF ; $82 xor
>aba0	00 b1					.word BinaryOp_Eor         & $FFFF ; $83 eor
>aba2	44 b1					.word Binary_Equal         & $FFFF ; $84 =
>aba4	63 b1					.word Binary_NotEqual      & $FFFF ; $85 <>
>aba6	6c b1					.word Binary_Less          & $FFFF ; $86 <
>aba8	75 b1					.word Binary_LessEqual     & $FFFF ; $87 <=
>abaa	87 b1					.word Binary_Greater       & $FFFF ; $88 >
>abac	7e b1					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>abae	1c b2					.word BinaryOp_Add         & $FFFF ; $8a +
>abb0	3c b2					.word BinaryOp_Subtract    & $FFFF ; $8b -
>abb2	4f b2					.word BinaryOp_Multiply    & $FFFF ; $8c *
>abb4	62 b2					.word BinaryOp_Divide      & $FFFF ; $8d /
>abb6	4e ac					.word NotImplemented       & $FFFF ; $8e ^
>abb8	4e ac					.word NotImplemented       & $FFFF ; $8f if
>abba	4e ac					.word NotImplemented       & $FFFF ; $90 while
>abbc	4e ac					.word NotImplemented       & $FFFF ; $91 repeat
>abbe	4e ac					.word NotImplemented       & $FFFF ; $92 for
>abc0	4e ac					.word NotImplemented       & $FFFF ; $93 then
>abc2	4e ac					.word NotImplemented       & $FFFF ; $94 endif
>abc4	4e ac					.word NotImplemented       & $FFFF ; $95 wend
>abc6	4e ac					.word NotImplemented       & $FFFF ; $96 until
>abc8	4e ac					.word NotImplemented       & $FFFF ; $97 next
>abca	4e ac					.word NotImplemented       & $FFFF ; $98 not
>abcc	4e ac					.word NotImplemented       & $FFFF ; $99 fn(
>abce	96 b3					.word Unary_Abs            & $FFFF ; $9a abs(
>abd0	ea b4					.word Unary_Asc            & $FFFF ; $9b asc(
>abd2	70 c0					.word Unary_Int            & $FFFF ; $9c int(
>abd4	b4 b3					.word Unary_Peek           & $FFFF ; $9d peek(
>abd6	e7 bf					.word Unary_Rnd            & $FFFF ; $9e rnd(
>abd8	28 b4					.word Unary_Usr            & $FFFF ; $9f usr(
>abda	2b b5					.word Unary_Left           & $FFFF ; $a0 left$(
>abdc	42 b5					.word Unary_Right          & $FFFF ; $a1 right$(
>abde	10 b5					.word Unary_Mid            & $FFFF ; $a2 mid$(
>abe0	a4 b6					.word Unary_Spc            & $FFFF ; $a3 spc(
>abe2	b7 b4					.word Unary_Str            & $FFFF ; $a4 str$(
>abe4	49 b4					.word Unary_Val            & $FFFF ; $a5 val(
>abe6	01 b5					.word Unary_Len            & $FFFF ; $a6 len(
>abe8	c0 b5					.word Unary_Hex            & $FFFF ; $a7 hex$(
>abea	4e ac					.word NotImplemented       & $FFFF ; $a8 sin(
>abec	4e ac					.word NotImplemented       & $FFFF ; $a9 cos(
>abee	4e ac					.word NotImplemented       & $FFFF ; $aa tan(
>abf0	4e ac					.word NotImplemented       & $FFFF ; $ab atn(
>abf2	4e ac					.word NotImplemented       & $FFFF ; $ac exp(
>abf4	4e ac					.word NotImplemented       & $FFFF ; $ad log(
>abf6	4e ac					.word NotImplemented       & $FFFF ; $ae sqr(
>abf8	1a b6					.word Unary_Dec            & $FFFF ; $af dec(
>abfa	b8 b3					.word Unary_Deek           & $FFFF ; $b0 deek(
>abfc	bc b3					.word Unary_Leek           & $FFFF ; $b1 leek(
>abfe	f0 b3					.word Unary_Mod            & $FFFF ; $b2 mod(
>ac00	44 b3					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ac02	82 b6					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ac04	4e ac					.word NotImplemented       & $FFFF ; $b5 $(
>ac06	4e ac					.word NotImplemented       & $FFFF ; $b6 $
>ac08	4e ac					.word NotImplemented       & $FFFF ; $b7 #(
>ac0a	4e ac					.word NotImplemented       & $FFFF ; $b8 #
>ac0c	4e ac					.word NotImplemented       & $FFFF ; $b9 %(
>ac0e	4e ac					.word NotImplemented       & $FFFF ; $ba %
>ac10	4e ac					.word NotImplemented       & $FFFF ; $bb (
>ac12	4e ac					.word NotImplemented       & $FFFF ; $bc )
>ac14	4e ac					.word NotImplemented       & $FFFF ; $bd ,
>ac16	3c ae					.word Command_COLON        & $FFFF ; $be :
>ac18	4e ac					.word NotImplemented       & $FFFF ; $bf ;
>ac1a	4e ac					.word NotImplemented       & $FFFF ; $c0 def
>ac1c	ce ae					.word Command_CLR          & $FFFF ; $c1 clr
>ac1e	d9 ae					.word Command_STOP         & $FFFF ; $c2 stop
>ac20	4e ac					.word NotImplemented       & $FFFF ; $c3 data
>ac22	4e ac					.word NotImplemented       & $FFFF ; $c4 read
>ac24	4e ac					.word NotImplemented       & $FFFF ; $c5 dim
>ac26	4e ac					.word NotImplemented       & $FFFF ; $c6 to
>ac28	4e ac					.word NotImplemented       & $FFFF ; $c7 step
>ac2a	4e ac					.word NotImplemented       & $FFFF ; $c8 gosub
>ac2c	4e ac					.word NotImplemented       & $FFFF ; $c9 return
>ac2e	4e ac					.word NotImplemented       & $FFFF ; $ca goto
>ac30	3d ae					.word Command_END          & $FFFF ; $cb end
>ac32	4e ac					.word NotImplemented       & $FFFF ; $cc input
>ac34	4e ac					.word NotImplemented       & $FFFF ; $cd let
>ac36	4e ac					.word NotImplemented       & $FFFF ; $ce list
>ac38	4e ac					.word NotImplemented       & $FFFF ; $cf new
>ac3a	4e ac					.word NotImplemented       & $FFFF ; $d0 old
>ac3c	4e ac					.word NotImplemented       & $FFFF ; $d1 on
>ac3e	4e ac					.word NotImplemented       & $FFFF ; $d2 restore
>ac40	4e ac					.word NotImplemented       & $FFFF ; $d3 poke
>ac42	42 ae					.word Command_PRINT        & $FFFF ; $d4 print
>ac44	c8 ad					.word Command_RUN          & $FFFF ; $d5 run
>ac46	4e ac					.word NotImplemented       & $FFFF ; $d6 wait
>ac48	4e ac					.word NotImplemented       & $FFFF ; $d7 doke
>ac4a	4e ac					.word NotImplemented       & $FFFF ; $d8 loke
>ac4c	b2 ae					.word Command_ASSERT       & $FFFF ; $d9 assert
.ac4e					NotImplemented:
.ac4e	20 37 ab	jsr $ab37			jsr ERR_Handler
>ac51	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ac59	65 6d 65 6e 74 65 64 00
.ac61					BinaryPrecedence:
>ac61	01					.byte 1    ; $80 and
>ac62	01					.byte 1    ; $81 or
>ac63	01					.byte 1    ; $82 xor
>ac64	01					.byte 1    ; $83 eor
>ac65	02					.byte 2    ; $84 =
>ac66	02					.byte 2    ; $85 <>
>ac67	02					.byte 2    ; $86 <
>ac68	02					.byte 2    ; $87 <=
>ac69	02					.byte 2    ; $88 >
>ac6a	02					.byte 2    ; $89 >=
>ac6b	03					.byte 3    ; $8a +
>ac6c	03					.byte 3    ; $8b -
>ac6d	04					.byte 4    ; $8c *
>ac6e	04					.byte 4    ; $8d /
>ac6f	05					.byte 5    ; $8e ^
.ac70					KeywordText:
>ac70	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ac73	4f d2					.byte $4f,$d2                          ; $81 or
>ac75	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ac78	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ac7b	bd					.byte $bd                              ; $84 =
>ac7c	3c be					.byte $3c,$be                          ; $85 <>
>ac7e	bc					.byte $bc                              ; $86 <
>ac7f	3c bd					.byte $3c,$bd                          ; $87 <=
>ac81	be					.byte $be                              ; $88 >
>ac82	3e bd					.byte $3e,$bd                          ; $89 >=
>ac84	ab					.byte $ab                              ; $8a +
>ac85	ad					.byte $ad                              ; $8b -
>ac86	aa					.byte $aa                              ; $8c *
>ac87	af					.byte $af                              ; $8d /
>ac88	de					.byte $de                              ; $8e ^
>ac89	49 c6					.byte $49,$c6                          ; $8f if
>ac8b	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>ac90	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>ac96	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>ac99	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>ac9d	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>aca2	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>aca6	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>acab	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>acaf	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>acb2	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>acb5	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>acb9	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>acbd	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>acc1	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>acc6	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>acca	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>acce	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>acd4	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>acdb	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>ace0	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>ace4	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>ace9	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>aced	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>acf1	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>acf6	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>acfa	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>acfe	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>ad02	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>ad06	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>ad0a	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>ad0e	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>ad12	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>ad16	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>ad1b	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>ad20	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>ad24	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>ad28	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>ad2d	24 a8					.byte $24,$a8                          ; $b5 $(
>ad2f	a4					.byte $a4                              ; $b6 $
>ad30	23 a8					.byte $23,$a8                          ; $b7 #(
>ad32	a3					.byte $a3                              ; $b8 #
>ad33	25 a8					.byte $25,$a8                          ; $b9 %(
>ad35	a5					.byte $a5                              ; $ba %
>ad36	a8					.byte $a8                              ; $bb (
>ad37	a9					.byte $a9                              ; $bc )
>ad38	ac					.byte $ac                              ; $bd ,
>ad39	ba					.byte $ba                              ; $be :
>ad3a	bb					.byte $bb                              ; $bf ;
>ad3b	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>ad3e	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>ad41	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>ad45	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>ad49	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>ad4d	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>ad50	54 cf					.byte $54,$cf                          ; $c6 to
>ad52	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>ad56	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>ad5b	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>ad61	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>ad65	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>ad68	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>ad6d	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>ad70	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>ad74	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>ad77	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>ad7a	4f ce					.byte $4f,$ce                          ; $d1 on
>ad7c	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>ad83	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>ad87	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>ad8c	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>ad8f	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>ad93	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>ad97	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>ad9b	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>ada1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.ada2					BASIC_Start:
.ada2	20 40 a2	jsr $a240			jsr 	IF_Reset 					; set up and clear screen.
.ada5	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.ada8	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.adaa	8d 04 03	sta $0304			sta 	LocalVector
.adad	8d 00 03	sta $0300			sta 	UserVector
.adb0	a9 37		lda #$37			lda 	#USRDefault & $FF 			; reset USR vector
.adb2	8d 01 03	sta $0301			sta 	UserVector+1
.adb5	a9 b4		lda #$b4			lda 	#(USRDefault >> 8) & $FF
.adb7	8d 02 03	sta $0302			sta 	UserVector+2
.adba	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.adbc	8d 03 03	sta $0303			sta 	UserVector+3
.adbf	20 ce ae	jsr $aece			jsr 	ResetRunStatus 				; clear everything (CLR command)
.adc2					WarmStart:
.adc2	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.adc4	9a		txs				txs
.adc5	4c c8 ad	jmp $adc8			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.adc8					Command_RUN:
.adc8	20 ce ae	jsr $aece			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.adcb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.adcd	85 16		sta $16				sta 	zCodePtr+0
.adcf	a9 80		lda #$80			lda 	#BasicProgram >> 8
.add1	85 17		sta $17				sta 	zCodePtr+1
.add3	a9 00		lda #$00			lda 	#0
.add5	85 18		sta $18				sta 	zCodePtr+2
.add7	85 19		sta $19				sta 	zCodePtr+3
.add9	a0 03		ldy #$03			ldy 	#3
.addb					RUN_NewLine:
.addb	a0 00		ldy #$00			ldy 	#0
.addd	b1 16		lda ($16),y			lda 	(zCodePtr),y
.addf	c8		iny				iny
.ade0	c8		iny				iny
.ade1	c8		iny				iny
.ade2	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.ade4	d0 16		bne $adfc			bne 	RUN_NextCommand
.ade6	4c d9 ae	jmp $aed9			jmp 	Command_STOP 				; go do the command code.
.ade9					RUN_Skip:
.ade9	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read element
.adeb	c8		iny				iny 								; skip
.adec	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adee	90 0c		bcc $adfc			bcc 	_SEDone 					; so just skip over it.
.adf0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adf2	90 07		bcc $adfb			bcc 	_SEDouble
.adf4	98		tya				tya 								; this is Y + 1
.adf5	18		clc				clc
.adf6	71 16		adc ($16),y			adc 	(zCodePtr),y 				; add total length of element
.adf8	a8		tay				tay 								; back in Y.
.adf9	88		dey				dey 								; fix up, one for the +1, one for the iny
.adfa	88		dey				dey
.adfb					_SEDouble:
.adfb	c8		iny				iny
.adfc					_SEDone:
.adfc					RUN_NextCommand:
.adfc	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.adfe	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.ae00	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae02	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.ae04	f0 e3		beq $ade9			beq 	RUN_Skip
.ae06	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.ae08	d0 0f		bne $ae19			bne 	RUN_Execute
.ae0a					RUN_NextLine:
.ae0a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.ae0c	b1 16		lda ($16),y			lda 	(zCodePtr),y 				; read it
.ae0e	18		clc				clc
.ae0f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ae11	85 16		sta $16				sta 	zCodePtr
.ae13	90 02		bcc $ae17			bcc 	_SNLNoCarry
.ae15	e6 17		inc $17				inc 	zCodePtr+1
.ae17					_SNLNoCarry:
.ae17	80 c2		bra $addb			bra 	RUN_NewLine 				; go do the new line code
.ae19					RUN_Execute:
.ae19	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.ae1b	b0 18		bcs $ae35			bcs 	RUN_Extension
.ae1d	c8		iny				iny
.ae1e	0a		asl a				asl 	a 							; double the character read.
.ae1f	90 12		bcc $ae33			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.ae21	aa		tax				tax 								; ready to look up.
.ae22	bd 9a ab	lda $ab9a,x			lda 	VectorTable,x 				; copy address into LocalVector
.ae25	8d 05 03	sta $0305			sta 	LocalVector+1
.ae28	bd 9b ab	lda $ab9b,x			lda 	VectorTable+1,x
.ae2b	8d 06 03	sta $0306			sta 	LocalVector+2
.ae2e	20 e9 af	jsr $afe9			jsr 	EVCallLocalVector 			; execute the appropriate code.
.ae31	80 c9		bra $adfc			bra 	RUN_NextCommand 			; do the next command.
.ae33					RUN_Default:
.ae33	80 fe		bra $ae33			bra 	RUN_Default
.ae35					RUN_Extension:
.ae35	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.ae37	f0 b0		beq $ade9			beq 	RUN_Skip 					; skip over it.
.ae39	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.ae3c					Command_COLON:
.ae3c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.ae3d					Command_END:
.ae3d	80 fe		bra $ae3d	_halt:	bra 		_halt
.ae3f	4c c2 ad	jmp $adc2			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.ae42					Command_PRINT:
.ae42	b1 16		lda ($16),y			lda 	(zCodePtr),y
.ae44	c9 00		cmp #$00			cmp 	#0 							; end
.ae46	f0 66		beq $aeae			beq 	_CPR_NewLine
.ae48	c9 be		cmp #$be			cmp 	#token_Colon
.ae4a	f0 62		beq $aeae			beq 	_CPR_NewLine
.ae4c	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.ae4e	f0 51		beq $aea1			beq 	_CPR_Skip
.ae50	c9 bd		cmp #$bd			cmp 	#token_Comma
.ae52	f0 4d		beq $aea1			beq 	_CPR_Tab
.ae54	20 e4 ae	jsr $aee4			jsr 	EvaluateExpression 			; get expression.
.ae57	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.ae5a	29 02		and #$02			and 	#2
.ae5c	d0 25		bne $ae83			bne 	_CPR_String 				; if type = 2 output as string.
.ae5e					_CPR_Number:
.ae5e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.ae60	8d 00 04	sta $0400			sta 	NumBufX
.ae63	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.ae66	4a		lsr a				lsr 	a
.ae67	b0 05		bcs $ae6e			bcs 	_CPRInt 					; if msb set do as integer
.ae69	20 9f be	jsr $be9f			jsr 	FPToString 					; call fp to str otherwise
.ae6c	80 03		bra $ae71			bra 	_CPRNPrint
.ae6e	20 8f b8	jsr $b88f	_CPRInt:jsr 	IntToString
.ae71					_CPRNPrint:
.ae71	ad 01 04	lda $0401			lda 	Num_Buffer 					; is first character -
.ae74	c9 2d		cmp #$2d			cmp 	#"-"
.ae76	f0 05		beq $ae7d			beq 	_CPRNoSpace
.ae78	a9 20		lda #$20			lda 	#" "						; print the leading space
.ae7a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.ae7d					_CPRNoSpace:
.ae7d	a2 00		ldx #$00			ldx 	#(Num_Buffer-1) & $FF
.ae7f	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.ae81	80 06		bra $ae89			bra 	_CPRPrint
.ae83					_CPR_String:
.ae83	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.ae86	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.ae89					_CPRPrint:
.ae89	86 1e		stx $1e				stx 	zGenPtr
.ae8b	85 1f		sta $1f				sta 	zGenPtr+1
.ae8d	5a		phy				phy
.ae8e	a0 00		ldy #$00			ldy 	#0							; get length into X
.ae90	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ae92	aa		tax				tax
.ae93	f0 09		beq $ae9e			beq 	_CPREndPrint 				; nothing to print
.ae95					_CPRLoop:
.ae95	c8		iny				iny
.ae96	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.ae98	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ae9b	ca		dex				dex
.ae9c	d0 f7		bne $ae95			bne 	_CPRLoop
.ae9e					_CPREndPrint:
.ae9e	7a		ply				ply
.ae9f	80 a1		bra $ae42			bra 	Command_Print
.aea1					_CPR_Tab:
.aea1					_CPR_Skip:
.aea1	c8		iny				iny
.aea2	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aea4	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.aea6	f0 09		beq $aeb1			beq 	_CPR_Exit
.aea8	c9 00		cmp #$00			cmp 	#0
.aeaa	d0 96		bne $ae42			bne 	Command_PRINT 				; if not go round again.
.aeac	80 03		bra $aeb1			bra 	_CPR_Exit
.aeae					_CPR_NewLine:
.aeae	20 5b a0	jsr $a05b			jsr 	IFT_NewLine
.aeb1					_CPR_Exit:
.aeb1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.aeb2					Command_ASSERT:
.aeb2	20 7f b0	jsr $b07f			jsr 	EvaluateNumber 				; calculate thing being asserted
.aeb5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.aeb8	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.aebb	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.aebe	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.aec1	f0 01		beq $aec4			beq 	_ASFail
.aec3	60		rts				rts
.aec4					_ASFail:
.aec4	20 37 ab	jsr $ab37			jsr ERR_Handler
>aec7	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.aece					Command_CLR:
.aece					ResetRunStatus:
.aece	a9 00		lda #$00			lda 	#HighMemory & $FF
.aed0	8d 26 04	sta $0426			sta 	StringPtr
.aed3	a9 70		lda #$70			lda 	#HighMemory >> 8
.aed5	8d 27 04	sta $0427			sta 	StringPtr+1
.aed8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.aed9					Command_STOP:
.aed9	20 37 ab	jsr $ab37			jsr ERR_Handler
>aedc	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.aee1					EVESyntax:
.aee1	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.aee4					EvaluateExpression:
.aee4	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.aee6					EvaluateExpressionX:
.aee6	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.aee8					EvaluateExpressionXA:
.aee8	48		pha				pha 								; save precedence on stack.
.aee9	b1 16		lda ($16),y			lda 	(zCodePtr),y
.aeeb	f0 f4		beq $aee1			beq 	EVESyntax 					; end of line, syntax error.
.aeed	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.aeef	b0 03		bcs $aef4			bcs 	_EVNotVariable
.aef1	4c e8 af	jmp $afe8			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.aef4					_EVNotVariable:
.aef4	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.aef6	90 e9		bcc $aee1			bcc 	EVESyntax
.aef8	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.aefa	b0 7c		bcs $af78			bcs 	_EVNotInteger
.aefc	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.aefe	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.af01	a9 00		lda #$00			lda 	#0
.af03	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af06	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.af09	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.af0c	1a		inc a				inc 	a 							; set to type 1 (integer)
.af0d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af10					_EVCheckNextInteger:
.af10	c8		iny				iny
.af11	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af13	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.af15	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.af17	b0 0d		bcs $af26			bcs 	_EVCheckDecimal
.af19	48		pha				pha 								; save it.
.af1a	20 ec af	jsr $afec			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.af1d	68		pla				pla
.af1e	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.af21	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af24	80 ea		bra $af10			bra 	_EVCheckNextInteger
.af26					_EVCheckDecimal:
.af26	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af28	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.af2a	d0 05		bne $af31			bne 	_EVGotAtom 					; no, get atom.
.af2c					_EVIsDecimal:
.af2c	20 1c b0	jsr $b01c			jsr 	EVGetDecimal 				; extend to the decimal part.
.af2f	80 00		bra $af31			bra 	_EVGotAtom 					; and continue to got atom.
.af31					_EVGotAtom:
.af31	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af33	10 41		bpl $af76			bpl 	_EVExitDrop 				; must be a token.
.af35	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.af37	b0 3d		bcs $af76			bcs 	_EVExitDrop
.af39	68		pla				pla 								; get current precedence
.af3a	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.af3c	da		phx				phx 								; save X
.af3d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af3f	aa		tax				tax 								; put in X
.af40	bd e1 ab	lda $abe1,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.af43	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.af45	fa		plx				plx 								; restore X
.af46	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.af48	90 2d		bcc $af77			bcc 	_EVExit 					; exit if too low.
.af4a	f0 2b		beq $af77			beq 	_EVExit 					; exit if equals
.af4c	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.af4e	48		pha				pha
.af4f	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af51	48		pha				pha
.af52	c8		iny				iny
.af53	da		phx				phx 								; save current position
.af54	e8		inx				inx
.af55	e8		inx				inx
.af56	e8		inx				inx
.af57	e8		inx				inx
.af58	e8		inx				inx
.af59	e8		inx				inx
.af5a	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.af5c	20 e8 ae	jsr $aee8			jsr 	EvaluateExpressionXA 		; do the RHS.
.af5f	fa		plx				plx 								; restore X
.af60	68		pla				pla 								; get the binary operator in A.
.af61					_EVCallA:
.af61	da		phx				phx 								; save X again
.af62	0a		asl a				asl 	a 							; double, lose the MSB.
.af63	aa		tax				tax									; put in X
.af64	bd 9a ab	lda $ab9a,x			lda 	VectorTable,x 				; copy address into zGenPtr
.af67	8d 05 03	sta $0305			sta 	LocalVector+1
.af6a	bd 9b ab	lda $ab9b,x			lda 	VectorTable+1,x
.af6d	8d 06 03	sta $0306			sta 	LocalVector+2
.af70	fa		plx				plx 								; restore X
.af71	20 e9 af	jsr $afe9			jsr 	EVCallLocalVector
.af74	80 bb		bra $af31			bra 	_EVGotAtom 					; and loop back.
.af76					_EVExitDrop:
.af76	68		pla				pla
.af77					_EVExit:
.af77	60		rts				rts
.af78					_EVNotInteger:
.af78	c8		iny				iny
.af79	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.af7b	d0 19		bne $af96			bne 	_EVNotMinus
.af7d	20 6d b0	jsr $b06d			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.af80	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.af83	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.af85	f0 05		beq $af8c			beq 	_EVMinusFloat
.af87	20 6a b8	jsr $b86a			jsr 	IntegerNegateAlways 		; negation
.af8a	80 a5		bra $af31			bra 	_EVGotAtom 					; and go back.
.af8c					_EVMinusFloat:
.af8c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.af8f	49 80		eor #$80			eor 	#$80
.af91	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af94	80 9b		bra $af31			bra 	_EVGotAtom
.af96					_EVNotMinus:
.af96	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.af98	d0 17		bne $afb1			bne 	_EVNotParenthesis
.af9a	20 e6 ae	jsr $aee6			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.af9d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.af9f	c8		iny				iny
.afa0	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.afa2	f0 8d		beq $af31			beq 	_EVGotAtom
.afa4	20 37 ab	jsr $ab37			jsr ERR_Handler
>afa7	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>afaf	29 00
.afb1					_EVNotParenthesis:
.afb1	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.afb3	d0 0c		bne $afc1			bne 	_EVNotNot
.afb5	20 6d b0	jsr $b06d			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.afb8	20 74 bd	jsr $bd74			jsr 	FPUToInteger 				; make it an integer - if possible.
.afbb	20 4a b0	jsr $b04a			jsr 	NotInteger 					; do the not calculation
.afbe	4c 31 af	jmp $af31			jmp 	_EVGotAtom
.afc1					_EVNotNot:
.afc1	c9 fe		cmp #$fe			cmp 	#$FE
.afc3	d0 15		bne $afda			bne 	_EVNotString
.afc5	20 57 b7	jsr $b757			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.afc8	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.afca	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.afcd	a5 21		lda $21				lda 	zTempStr+1
.afcf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.afd2	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.afd4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.afd7	4c 31 af	jmp $af31			jmp 	_EVGotAtom
.afda					_EVNotString:
.afda	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.afdc	90 04		bcc $afe2			bcc 	_EVBadElement
.afde	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.afe0	90 03		bcc $afe5			bcc 	_EVUnaryFunction
.afe2					_EVBadElement:
.afe2	4c 08 ab	jmp $ab08			jmp 	SyntaxError
.afe5					_EVUnaryFunction:
.afe5	4c 61 af	jmp $af61			jmp 	_EVCallA
.afe8					_EVVariableHandler:
.afe8	ea		nop				nop
.afe9					EVCallLocalVector:
.afe9	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.afec					EVShiftMantissaLeft6:
.afec	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.afef	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.aff2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.aff5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.aff8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.affb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.affe	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b001	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b004	a9 00		lda #$00			lda 	#0
.b006	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b009	20 0c b0	jsr $b00c			jsr 	_EVSMLShift 					; call it here to do it twice
.b00c					_EVSMLShift:
.b00c	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.b00f	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.b012	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.b015	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.b018	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.b01b	60		rts				rts
.b01c					EVGetDecimal:
.b01c	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b01e	8d 01 04	sta $0401			sta 	Num_Buffer
.b021	da		phx				phx
.b022	c8		iny				iny
.b023	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b025	c8		iny				iny
.b026	3a		dec a				dec 	a								; convert to a string length.
.b027	3a		dec a				dec 	a
.b028	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b02a					_EVGDCopy:
.b02a	48		pha				pha 									; save count
.b02b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b02d	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b030	e8		inx				inx 									; forward ....
.b031	c8		iny				iny
.b032	68		pla				pla 									; get count
.b033	3a		dec a				dec 	a 								; until zero
.b034	d0 f4		bne $b02a			bne 	_EVGDCopy
.b036	9d 01 04	sta $0401,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b039	fa		plx				plx 									; restore X
.b03a	a9 01		lda #$01			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b03c	85 1e		sta $1e				sta 	zGenPtr
.b03e	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.b040	85 1f		sta $1f				sta 	zGenPtr+1
.b042	5a		phy				phy 									; save Y
.b043	a0 00		ldy #$00			ldy 	#0 								; start position
.b045	20 66 bf	jsr $bf66			jsr 	FPFromString 					; convert current
.b048	7a		ply				ply 									; restore Y
.b049	60		rts				rts
.b04a					NotInteger:
.b04a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b04d	49 ff		eor #$ff			eor 	#$FF
.b04f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b052	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b055	49 ff		eor #$ff			eor 	#$FF
.b057	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b05a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b05d	49 ff		eor #$ff			eor 	#$FF
.b05f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b062	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b065	49 ff		eor #$ff			eor 	#$FF
.b067	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b06a	60		rts				rts
.b06b					EvaluateGetAtom:
.b06b	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b06d					EvaluateGetAtomX:
.b06d	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b06f	20 e8 ae	jsr $aee8			jsr 	EvaluateExpressionXA
.b072	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b075	29 0f		and #$0f			and 	#15
.b077	c9 02		cmp #$02			cmp 	#2
.b079	b0 01		bcs $b07c			bcs 	EvaluateType
.b07b	60		rts				rts
.b07c					EvaluateType:
.b07c	4c 18 ab	jmp $ab18			jmp 	TypeError
.b07f					EvaluateNumber:
.b07f	a2 00		ldx #$00			ldx 	#0
.b081					EvaluateNumberX:
.b081	20 e6 ae	jsr $aee6			jsr 	EvaluateExpressionX
.b084	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b087	29 0f		and #$0f			and 	#15
.b089	c9 02		cmp #$02			cmp 	#2
.b08b	b0 ef		bcs $b07c			bcs 	EvaluateType
.b08d	60		rts				rts
.b08e					EvaluateInteger:
.b08e	a2 00		ldx #$00			ldx 	#0
.b090					EvaluateIntegerX:
.b090	20 81 b0	jsr $b081			jsr 	EvaluateNumberX
.b093	20 74 bd	jsr $bd74			jsr 	FPUToInteger
.b096	60		rts				rts
.b097					EvaluateString:
.b097	a2 00		ldx #$00			ldx 	#0
.b099					EvaluateStringX:
.b099	20 e6 ae	jsr $aee6			jsr 	EvaluateExpressionX
.b09c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b09f	29 0f		and #$0f			and 	#15
.b0a1	c9 02		cmp #$02			cmp 	#2
.b0a3	d0 d7		bne $b07c			bne 	EvaluateType
.b0a5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b0a8	85 1e		sta $1e				sta 	zGenPtr
.b0aa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b0ad	85 1f		sta $1f				sta 	zGenPtr+1
.b0af	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b0b0					BinaryOp_And:
.b0b0	20 28 b1	jsr $b128			jsr 	BinaryMakeBothInteger
.b0b3	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0b6	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b0b9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0bc	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0bf	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b0c2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0c5	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0c8	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b0cb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0ce	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b0d1	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b0d4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0d7	60		rts				rts
.b0d8					BinaryOp_Or:
.b0d8	20 28 b1	jsr $b128			jsr 	BinaryMakeBothInteger
.b0db	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b0de	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b0e1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0e4	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b0e7	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b0ea	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0ed	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b0f0	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b0f3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0f6	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b0f9	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b0fc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0ff	60		rts				rts
.b100					BinaryOp_Eor:
.b100					BinaryOp_Xor:
.b100	20 28 b1	jsr $b128			jsr 	BinaryMakeBothInteger
.b103	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b106	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b109	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b10c	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b10f	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b112	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b115	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b118	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b11b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b11e	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b121	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b124	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b127	60		rts				rts
.b128					BinaryMakeBothInteger:
.b128	da		phx				phx 								; save X
.b129	e8		inx				inx
.b12a	e8		inx				inx
.b12b	e8		inx				inx
.b12c	e8		inx				inx
.b12d	e8		inx				inx
.b12e	e8		inx				inx
.b12f	20 33 b1	jsr $b133			jsr 	BinaryMakeInteger 			; convert to integer.
.b132	fa		plx				plx 								; restore X and fall through.
.b133					BinaryMakeInteger:
.b133	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b136	29 0f		and #$0f			and 	#15 						; check type zero
.b138	f0 04		beq $b13e			beq 	_BMIConvert 				; if float convert to integer.
.b13a	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b13b	90 04		bcc $b141			bcc 	_BMIError
.b13d	60		rts				rts
.b13e					_BMIConvert:
.b13e	4c 74 bd	jmp $bd74			jmp 	FPUToInteger 				; convert to integer
.b141					_BMIError:
.b141	4c 18 ab	jmp $ab18			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b144					Binary_Equal:
.b144	20 90 b1	jsr $b190			jsr 	CompareValues
.b147	09 00		ora #$00			ora 	#0
.b149	f0 04		beq $b14f			beq 	CCTrue
.b14b	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b14d	80 02		bra $b151			bra 	CCWrite
.b14f	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b151	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b154	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b157	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b15a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b15d	a9 01		lda #$01			lda 	#1
.b15f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b162	60		rts				rts
.b163					Binary_NotEqual:
.b163	20 90 b1	jsr $b190			jsr 	CompareValues
.b166	09 00		ora #$00			ora 	#0
.b168	d0 e1		bne $b14b			bne 	CCFalse
.b16a	80 e3		bra $b14f			bra 	CCTrue
.b16c					Binary_Less:
.b16c	20 90 b1	jsr $b190			jsr 	CompareValues
.b16f	09 00		ora #$00			ora 	#0
.b171	30 dc		bmi $b14f			bmi 	CCTrue
.b173	80 d6		bra $b14b			bra 	CCFalse
.b175					Binary_LessEqual:
.b175	20 90 b1	jsr $b190			jsr 	CompareValues
.b178	c9 01		cmp #$01			cmp 	#1
.b17a	d0 d3		bne $b14f			bne 	CCTrue
.b17c	80 cd		bra $b14b			bra 	CCFalse
.b17e					Binary_GreaterEqual:
.b17e	20 90 b1	jsr $b190			jsr 	CompareValues
.b181	09 00		ora #$00			ora 	#0
.b183	10 ca		bpl $b14f			bpl 	CCTrue
.b185	80 c4		bra $b14b			bra 	CCFalse
.b187					Binary_Greater:
.b187	20 90 b1	jsr $b190			jsr 	CompareValues
.b18a	c9 01		cmp #$01			cmp 	#1
.b18c	d0 c1		bne $b14f			bne 	CCTrue
.b18e	80 bb		bra $b14b			bra 	CCFalse
.b190					CompareValues:
.b190	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b193	3d 13 03	and $0313,x			and 	XS2_Type,x
.b196	c9 02		cmp #$02			cmp 	#2
.b198	f0 13		beq $b1ad			beq 	_CVString
.b19a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b19d	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1a0	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1a1	90 03		bcc $b1a6			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1a3	4c f3 b1	jmp $b1f3			jmp 	CompareInteger32 							; so execute code at \1
.b1a6					_BCFloat:
.b1a6	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1a9	4c 83 bc	jmp $bc83			jmp 	FPCompare 							; and execute code at \2
.b1ac	60		rts				rts
.b1ad					_CVString:
.b1ad	da		phx				phx 								; save XY
.b1ae	5a		phy				phy
.b1af	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b1b2	85 1a		sta $1a				sta		zLTemp1+0
.b1b4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b1b7	85 1b		sta $1b				sta 	zLTemp1+1
.b1b9	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b1bc	85 1c		sta $1c				sta 	zLTemp1+2
.b1be	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b1c1	85 1d		sta $1d				sta 	zLTemp1+3
.b1c3	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b1c5	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1c7	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1c9	90 02		bcc $b1cd			bcc 	_CVCommon
.b1cb	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b1cd					_CVCommon:
.b1cd	aa		tax				tax 								; put shorter string length in zero.
.b1ce	f0 0c		beq $b1dc			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b1d0					_CVCompare:
.b1d0	c8		iny				iny 								; next character
.b1d1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b1d3	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1d5	90 13		bcc $b1ea			bcc 	_CVReturnLess 				; <
.b1d7	d0 15		bne $b1ee			bne 	_CVReturnGreater 			; >
.b1d9	ca		dex				dex 								; until common length matched.
.b1da	d0 f4		bne $b1d0			bne 	_CVCompare
.b1dc					_CVMatch:
.b1dc	a0 00		ldy #$00			ldy 	#0
.b1de	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b1e0	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b1e2	90 06		bcc $b1ea			bcc 	_CVReturnLess 				; <
.b1e4	d0 08		bne $b1ee			bne 	_CVReturnGreater 			; >
.b1e6	a9 00		lda #$00			lda 	#0
.b1e8	80 06		bra $b1f0			bra 	_CVExit 					; same common, same length, same string
.b1ea					_CVReturnLess:
.b1ea	a9 ff		lda #$ff			lda 	#$FF
.b1ec	80 02		bra $b1f0			bra 	_CVExit
.b1ee					_CVReturnGreater:
.b1ee	a9 01		lda #$01			lda 	#$01
.b1f0					_CVExit:
.b1f0	7a		ply				ply
.b1f1	fa		plx				plx
.b1f2	60		rts				rts
.b1f3					CompareInteger32:
.b1f3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b1f6	49 80		eor #$80			eor 	#$80
.b1f8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b1fb	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b1fe	49 80		eor #$80			eor 	#$80
.b200	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b203	20 9b b2	jsr $b29b			jsr 	SubInteger32 				; subtraction
.b206	90 11		bcc $b219			bcc 	_CI32Less 					; cc return -1
.b208	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b20b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b20e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b211	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b214	f0 02		beq $b218			beq 	_CI32Exit
.b216	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b218					_CI32Exit:
.b218	60		rts				rts
.b219					_CI32Less:
.b219	a9 ff		lda #$ff			lda 	#$FF
.b21b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b21c					BinaryOp_Add:
.b21c	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b21f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b222	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b224	d0 13		bne $b239			bne 	_BOAString
.b226	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b229	3d 13 03	and $0313,x			and 	XS2_Type,x
.b22c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b22d	90 03		bcc $b232			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b22f	4c 75 b2	jmp $b275			jmp 	AddInteger32 							; so execute code at \1
.b232					_BCFloat:
.b232	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b235	4c f7 b9	jmp $b9f7			jmp 	FPAdd 							; and execute code at \2
.b238	60		rts				rts
.b239					_BOAString:
.b239	4c dc b2	jmp $b2dc			jmp 	ConcatenateString 			; concatenate two strings.
.b23c					BinaryOp_Subtract:
.b23c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b23f	3d 13 03	and $0313,x			and 	XS2_Type,x
.b242	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b243	90 03		bcc $b248			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b245	4c 9b b2	jmp $b29b			jmp 	SubInteger32 							; so execute code at \1
.b248					_BCFloat:
.b248	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b24b	4c ed b9	jmp $b9ed			jmp 	FPSubtract 							; and execute code at \2
.b24e	60		rts				rts
.b24f					BinaryOp_Multiply:
.b24f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b252	3d 13 03	and $0313,x			and 	XS2_Type,x
.b255	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b256	90 03		bcc $b25b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b258	4c 7d b7	jmp $b77d			jmp 	MulInteger32 							; so execute code at \1
.b25b					_BCFloat:
.b25b	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b25e	4c 63 bb	jmp $bb63			jmp 	FPMultiply 							; and execute code at \2
.b261	60		rts				rts
.b262					BinaryOp_Divide:
.b262	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b265	3d 13 03	and $0313,x			and 	XS2_Type,x
.b268	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b269	90 03		bcc $b26e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b26b	4c d4 b7	jmp $b7d4			jmp 	DivInteger32 							; so execute code at \1
.b26e					_BCFloat:
.b26e	20 c1 b2	jsr $b2c1			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b271	4c db ba	jmp $badb			jmp 	FPDivide 							; and execute code at \2
.b274	60		rts				rts
.b275					AddInteger32:
.b275	18		clc				clc
.b276	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b279	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b27c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b27f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b282	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b285	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b288	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b28b	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b28e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b291	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b294	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b297	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b29a	60		rts				rts
.b29b					SubInteger32:
.b29b	38		sec				sec
.b29c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b29f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b2a2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2a5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2a8	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b2ab	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2ae	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2b1	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b2b4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2b7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2ba	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b2bd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2c0	60		rts				rts
.b2c1					BinaryMakeBothFloat:
.b2c1	da		phx				phx 								; save X
.b2c2	e8		inx				inx
.b2c3	e8		inx				inx
.b2c4	e8		inx				inx
.b2c5	e8		inx				inx
.b2c6	e8		inx				inx
.b2c7	e8		inx				inx
.b2c8	20 cc b2	jsr $b2cc			jsr 	BinaryMakeFloat 			; convert to float.
.b2cb	fa		plx				plx 								; restore X and fall through.
.b2cc					BinaryMakeFloat:
.b2cc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b2cf	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b2d0	b0 04		bcs $b2d6			bcs 	_BMFConvert
.b2d2	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b2d3	b0 04		bcs $b2d9			bcs 	_BMFError
.b2d5	60		rts				rts
.b2d6					_BMFConvert:
.b2d6	4c 15 bd	jmp $bd15			jmp 	FPUToFloat 					; convert to float
.b2d9					_BMFError:
.b2d9	4c 18 ab	jmp $ab18			jmp 	TypeError
.b2dc					ConcatenateString:
.b2dc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b2df	85 1a		sta $1a				sta		zLTemp1+0
.b2e1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2e4	85 1b		sta $1b				sta 	zLTemp1+1
.b2e6	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b2e9	85 1c		sta $1c				sta 	zLTemp1+2
.b2eb	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b2ee	85 1d		sta $1d				sta 	zLTemp1+3
.b2f0	5a		phy				phy
.b2f1	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b2f3	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b2f5	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b2f7	7a		ply				ply
.b2f8	b0 37		bcs $b331			bcs 	_CSError					; check in range.
.b2fa	c9 fe		cmp #$fe			cmp 	#maxString+1
.b2fc	b0 33		bcs $b331			bcs 	_CSError
.b2fe	20 1c b7	jsr $b71c			jsr 	AllocateTempString 			; store the result
.b301	20 1c b3	jsr $b31c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b304	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b307	85 1a		sta $1a				sta 	zLTemp1
.b309	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b30c	85 1b		sta $1b				sta 	zLTemp1+1
.b30e	20 1c b3	jsr $b31c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b311	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b313	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b316	a5 21		lda $21				lda 	zTempStr+1
.b318	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b31b	60		rts				rts
.b31c					_CSCopyString:
.b31c	da		phx				phx
.b31d	5a		phy				phy
.b31e	a0 00		ldy #$00			ldy 	#0 							; get length
.b320	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b322	f0 0a		beq $b32e			beq 	_CSCSExit 					; if zero, exit
.b324	aa		tax				tax 								; put in X
.b325					_CSCSLoop:
.b325	c8		iny				iny 								; get next char
.b326	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b328	20 47 b7	jsr $b747			jsr		WriteTempString 			; copy out
.b32b	ca		dex				dex 								; do whole string
.b32c	d0 f7		bne $b325			bne 	_CSCSLoop
.b32e					_CSCSExit:
.b32e	7a		ply				ply
.b32f	fa		plx				plx
.b330	60		rts				rts
.b331					_CSError:
.b331	20 37 ab	jsr $ab37			jsr ERR_Handler
>b334	53 74 72 69 6e 67 20 74			.text "String too long",0
>b33c	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b344					Unary_Sgn:
.b344	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.b347	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; check right bracket.
.b34a	20 6e b3	jsr $b36e			jsr 	GetSignCurrent 				; get sign.
.b34d	09 00		ora #$00			ora 	#0
.b34f	10 09		bpl $b35a			bpl		UnarySetAInteger			; if 0,1 return that.
.b351	80 00		bra $b353			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b353					UnarySetAMinus1:
.b353	a9 ff		lda #$ff			lda 	#$FF
.b355	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b358	80 05		bra $b35f			bra 	UnarySetAFill
.b35a					UnarySetAInteger:
.b35a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b35d	a9 00		lda #$00			lda 	#0
.b35f					UnarySetAFill:
.b35f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b362	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b365	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b368	a9 01		lda #$01			lda 	#1
.b36a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b36d	60		rts				rts
.b36e					GetSignCurrent:
.b36e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b371	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b372	90 19		bcc $b38d			bcc 	_GSCFloat
.b374	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b377	30 11		bmi $b38a			bmi 	_GSCMinus1
.b379	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b37c	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b37f	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b382	d0 03		bne $b387			bne 	_GSCPlus1
.b384					_GSCZero:
.b384	a9 00		lda #$00			lda 	#0
.b386	60		rts				rts
.b387					_GSCPlus1:
.b387	a9 01		lda #$01			lda 	#$01
.b389	60		rts				rts
.b38a					_GSCMinus1:
.b38a	a9 ff		lda #$ff			lda 	#$FF
.b38c	60		rts				rts
.b38d					_GSCFloat:
.b38d	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b390	70 f2		bvs $b384			bvs 	_GSCZero
.b392	30 f6		bmi $b38a			bmi 	_GSCMinus1
.b394	80 f1		bra $b387			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b396					Unary_Abs:
.b396	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.b399	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; check right bracket.
.b39c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b39f	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b3a1	f0 08		beq $b3ab			beq 	_UAMinusFloat
.b3a3	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b3a6	10 0b		bpl $b3b3			bpl 	_UAExit
.b3a8	4c 6a b8	jmp $b86a			jmp 	IntegerNegateAlways 		; negation
.b3ab					_UAMinusFloat:
.b3ab	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b3ae	29 7f		and #$7f			and		#$7F
.b3b0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b3b3					_UAExit:
.b3b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b3b4					Unary_Peek:
.b3b4	a9 01		lda #$01			lda 	#1
.b3b6	80 06		bra $b3be			bra 	UPMain
.b3b8					Unary_Deek:
.b3b8	a9 02		lda #$02			lda 	#2
.b3ba	80 02		bra $b3be			bra 	UPMain
.b3bc					Unary_Leek:
.b3bc	a9 04		lda #$04			lda 	#4
.b3be					UPMain:
.b3be	48		pha				pha 								; set bytes to copy.
.b3bf	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; numeric parameter
.b3c2	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b3c5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b3c8	85 1a		sta $1a				sta 	zLTemp1
.b3ca	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b3cd	85 1b		sta $1b				sta 	zLTemp1+1
.b3cf	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b3d2	85 1c		sta $1c				sta 	zLTemp1+2
.b3d4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b3d7	85 1d		sta $1d				sta 	zLTemp1+3
.b3d9	a9 00		lda #$00			lda 	#0 							; clear target area
.b3db	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b3de	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b3e1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b3e4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b3e7	68		pla				pla 								; restore bytes to copy
.b3e8	da		phx				phx 								; save XY
.b3e9	5a		phy				phy
.b3ea	20 e3 b6	jsr $b6e3			jsr 	MemRead 					; read the bytes in
.b3ed	7a		ply				ply 								; restore and exit
.b3ee	fa		plx				plx
.b3ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b3f0					Unary_Mod:
.b3f0	20 1c b4	jsr $b41c			jsr 	_UMParameter 				; first parameter
.b3f3	20 14 b7	jsr $b714			jsr 	CheckNextComma
.b3f6	da		phx				phx 								; second parameter
.b3f7	e8		inx				inx
.b3f8	e8		inx				inx
.b3f9	e8		inx				inx
.b3fa	e8		inx				inx
.b3fb	e8		inx				inx
.b3fc	e8		inx				inx
.b3fd	20 1c b4	jsr $b41c			jsr 	_UMParameter
.b400	fa		plx				plx
.b401	20 0c b7	jsr $b70c			jsr 	CheckNextRParen
.b404	20 d4 b7	jsr $b7d4			jsr 	DivInteger32 				; divide
.b407	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b409	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b40c	a5 1b		lda $1b				lda 	zLTemp1+1
.b40e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b411	a5 1c		lda $1c				lda 	zLTemp1+2
.b413	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b416	a5 1d		lda $1d				lda 	zLTemp1+3
.b418	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b41b	60		rts				rts
.b41c					_UMParameter:
.b41c	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; get value
.b41f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b422	10 03		bpl $b427			bpl 	_UMNotSigned
.b424	20 6a b8	jsr $b86a			jsr 	IntegerNegateAlways
.b427					_UMNotSigned:
.b427	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b428					Unary_Usr:
.b428	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; numeric parameter
.b42b	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b42e	da		phx				phx 								; save XY
.b42f	5a		phy				phy
.b430	ea		nop				nop
.b431	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b434	7a		ply				ply 								; and exit
.b435	fa		plx				plx
.b436	60		rts				rts
.b437					USRDefault:
.b437	20 37 ab	jsr $ab37			jsr ERR_Handler
>b43a	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b442	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b449					Unary_Val:
.b449	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; get string
.b44c	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; check right bracket.
.b44f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b452	85 1e		sta $1e				sta 	zGenPtr
.b454	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b457	85 1f		sta $1f				sta 	zGenPtr+1
.b459	5a		phy				phy
.b45a	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b45c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b45e	f0 54		beq $b4b4			beq 	_UVBadNumber
.b460	48		pha				pha 								; save length.
.b461	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b462	1a		inc a				inc 	a
.b463	20 1c b7	jsr $b71c			jsr 	AllocateTempString
.b466	c8		iny				iny 								; move to the next.
.b467	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b469	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b46b	8d 29 04	sta $0429			sta 	ValSign
.b46e	d0 01		bne $b471			bne 	_UVNotMinus
.b470	c8		iny				iny 								; skip over it.
.b471					_UVNotMinus:
.b471	68		pla				pla 								; this is the count.
.b472	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b473	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b475	c8		iny				iny
.b476	20 47 b7	jsr $b747			jsr 	WriteTempString
.b479	68		pla				pla
.b47a	3a		dec a				dec 	a
.b47b	d0 f5		bne $b472			bne 	_UVCopy
.b47d	20 47 b7	jsr $b747			jsr 	WriteTempString 			; make it ASCIIZ
.b480	18		clc				clc
.b481	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b483	69 01		adc #$01			adc 	#1
.b485	85 1e		sta $1e				sta 	zGenPtr
.b487	a5 21		lda $21				lda 	zTempStr+1
.b489	69 00		adc #$00			adc 	#0
.b48b	85 1f		sta $1f				sta 	zGenPtr+1
.b48d	18		clc				clc
.b48e	20 42 b9	jsr $b942			jsr 	IntFromString 				; first bit.
.b491	b0 21		bcs $b4b4			bcs 	_UVBadNumber
.b493	20 66 bf	jsr $bf66			jsr 	FPFromString				; try for a float part.
.b496	ad 29 04	lda $0429			lda 	ValSign 					; was it negative
.b499	d0 13		bne $b4ae			bne 	_UVNotNegative
.b49b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b49e	4a		lsr a				lsr 	a
.b49f	b0 0a		bcs $b4ab			bcs 	_UVInteger
.b4a1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b4a4	09 80		ora #$80			ora 	#$80
.b4a6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b4a9	80 03		bra $b4ae			bra 	_UVNotNegative
.b4ab					_UVInteger:
.b4ab	20 6a b8	jsr $b86a			jsr 	IntegerNegateAlways 		; sign it.
.b4ae					_UVNotNegative:
.b4ae	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b4b0	d0 02		bne $b4b4			bne 	_UVBadNumber
.b4b2	7a		ply				ply
.b4b3	60		rts				rts
.b4b4					_UVBadNumber:
.b4b4	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b4b7					Unary_Str:
.b4b7	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; numeric parameter
.b4ba	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b4bd	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b4bf	8d 00 04	sta $0400			sta 	NumBufX
.b4c2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b4c5	4a		lsr a				lsr 	a
.b4c6	b0 05		bcs $b4cd			bcs 	_USInt 						; if msb set do as integer
.b4c8	20 9f be	jsr $be9f			jsr 	FPToString 					; call fp to str otherwise
.b4cb	80 03		bra $b4d0			bra 	_USDuplicate
.b4cd	20 8f b8	jsr $b88f	_USInt:	jsr 	IntToString
.b4d0					_USDuplicate:
.b4d0	ad 00 04	lda $0400			lda 	NumBufX 					; chars in buffer
.b4d3	1a		inc a				inc 	a 							; one more for length
.b4d4	20 1c b7	jsr $b71c			jsr 	AllocateTempString 			; allocate space for it.
.b4d7	5a		phy				phy 								; save Y
.b4d8	a0 00		ldy #$00			ldy 	#0 							; start copying
.b4da	b9 01 04	lda $0401,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b4dd	20 47 b7	jsr $b747			jsr 	WriteTempString
.b4e0	c8		iny				iny
.b4e1	cc 00 04	cpy $0400			cpy 	NumBufX 					; done the lot
.b4e4	d0 f4		bne $b4da			bne 	_USCopy
.b4e6	7a		ply				ply 								; restore Y
.b4e7	4c d3 b6	jmp $b6d3			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b4ea					Unary_Asc:
.b4ea	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; string parameter
.b4ed	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b4f0	5a		phy				phy 								; get the string length
.b4f1	a0 00		ldy #$00			ldy 	#0
.b4f3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b4f5	f0 07		beq $b4fe			beq 	_UAIllegal 					; must be at least one character
.b4f7	c8		iny				iny
.b4f8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b4fa	7a		ply				ply
.b4fb	4c 5a b3	jmp $b35a			jmp 	UnarySetAInteger
.b4fe					_UAIllegal:
.b4fe	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b501					Unary_Len:
.b501	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; string parameter
.b504	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b507	5a		phy				phy 								; get the string length
.b508	a0 00		ldy #$00			ldy 	#0
.b50a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b50c	7a		ply				ply
.b50d	4c 5a b3	jmp $b35a			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b510					Unary_Mid:
.b510	20 99 b0	jsr $b099			jsr 	EvaluateStringX 				; get string.
.b513	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b516	48		pha				pha
.b517	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b51a	48		pha				pha
.b51b	20 14 b7	jsr $b714			jsr 	CheckNextComma 					; skip comma
.b51e	20 ab b5	jsr $b5ab			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b521	48		pha				pha 									; and push it.
.b522	20 14 b7	jsr $b714			jsr 	CheckNextComma 					; skip comma
.b525	20 ab b5	jsr $b5ab			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b528	48		pha				pha 									; and push it.
.b529	80 45		bra $b570			bra 	SLIProcess
.b52b					Unary_Left:
.b52b	20 99 b0	jsr $b099			jsr 	EvaluateStringX 				; get string.
.b52e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b531	48		pha				pha
.b532	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b535	48		pha				pha
.b536	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b538	48		pha				pha
.b539	20 14 b7	jsr $b714			jsr 	CheckNextComma 					; skip comma
.b53c	20 ab b5	jsr $b5ab			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b53f	48		pha				pha 									; and push it.
.b540	80 2e		bra $b570			bra 	SLIProcess
.b542					Unary_Right:
.b542	20 99 b0	jsr $b099			jsr 	EvaluateStringX 				; get string.
.b545	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b548	48		pha				pha
.b549	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b54c	48		pha				pha
.b54d	da		phx				phx 									; get the string length and push on stack.
.b54e	a2 00		ldx #$00			ldx 	#0
.b550	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b552	fa		plx				plx
.b553	48		pha				pha
.b554	20 14 b7	jsr $b714			jsr 	CheckNextComma 					; skip comma
.b557	20 ab b5	jsr $b5ab			jsr 	SLIByteParameter 				; get a byte parameter.
.b55a	8d 25 04	sta $0425			sta 	SignCount 						; save in temporary.
.b55d	68		pla				pla 									; restore string length.
.b55e	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b55f	38		sec				sec
.b560	ed 25 04	sbc $0425			sbc 	SignCount 						; subtract characters needed, gives start position.
.b563	f0 02		beq $b567			beq 	_URStart 						; if <= 0 start from 1.
.b565	10 02		bpl $b569			bpl 	_UROkay
.b567					_URStart:
.b567	a9 01		lda #$01			lda 	#1
.b569					_UROkay:
.b569	48		pha				pha 									; push start
.b56a	ad 25 04	lda $0425			lda 	SignCount 						; push count of characters
.b56d	48		pha				pha
.b56e	80 00		bra $b570			bra 	SLIProcess
.b570					SLIProcess:
.b570	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 				; closing right bracket.
.b573	68		pla				pla
.b574	8d 2b 04	sta $042b			sta 	SliceCount 						; count in signcount
.b577	1a		inc a				inc 	a 								; allocate +1 for it.
.b578	20 1c b7	jsr $b71c			jsr 	AllocateTempString
.b57b	68		pla				pla 									; pop start number off stack.
.b57c	f0 3f		beq $b5bd			beq 	SLIError 						; exit if start = 0
.b57e	8d 2a 04	sta $042a			sta 	SliceStart
.b581	68		pla				pla  									; pop string address.
.b582	85 1f		sta $1f				sta 	zGenPtr+1
.b584	68		pla				pla
.b585	85 1e		sta $1e				sta 	zGenPtr
.b587	da		phx				phx
.b588	5a		phy				phy
.b589	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b58b	ac 2a 04	ldy $042a			ldy 	SliceStart 						; start of the string (+1 for count)
.b58e					_SLICopy:
.b58e	ad 2b 04	lda $042b			lda 	SliceCount 						; done count characters
.b591	f0 12		beq $b5a5			beq 	_SLIExit
.b593	ce 2b 04	dec $042b			dec 	SliceCount
.b596	98		tya				tya 									; index of character
.b597	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b599	f0 02		beq $b59d			beq 	_SLIOk 							; if equal, okay.
.b59b	b0 08		bcs $b5a5			bcs 	_SLIExit 						; if past end, then exit.
.b59d	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b59f	c8		iny				iny
.b5a0	20 47 b7	jsr $b747			jsr 	WriteTempString
.b5a3	80 e9		bra $b58e			bra 	_SLICopy 						; go round till copied characters
.b5a5					_SLIExit:
.b5a5	7a		ply				ply 									; restore YX
.b5a6	fa		plx				plx
.b5a7	4c d3 b6	jmp $b6d3			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b5aa	ea		nop				nop
.b5ab					SLIByteParameter:
.b5ab	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 				; get integer
.b5ae	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b5b1	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b5b4	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b5b7	d0 04		bne $b5bd			bne 	SLIError
.b5b9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5bc	60		rts				rts
.b5bd					SLIError:
.b5bd	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b5c0					Unary_Hex:
.b5c0	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; numeric parameter
.b5c3	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b5c6	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b5c8	20 1c b7	jsr $b71c			jsr 	AllocateTempString			; allocate string space
.b5cb	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b5ce	20 f5 b5	jsr $b5f5			jsr 	_UHConvert
.b5d1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b5d4	20 f5 b5	jsr $b5f5			jsr 	_UHConvert
.b5d7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b5da	20 f5 b5	jsr $b5f5			jsr 	_UHConvert
.b5dd	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b5e0	20 f5 b5	jsr $b5f5			jsr 	_UHConvert
.b5e3	5a		phy				phy 								; get length of new string
.b5e4	a0 00		ldy #$00			ldy 	#0
.b5e6	b1 20		lda ($20),y			lda 	(zTempStr),y
.b5e8	7a		ply				ply
.b5e9	c9 00		cmp #$00			cmp 	#0
.b5eb	d0 05		bne $b5f2			bne 	_UHExit 					; if it was non zero okay
.b5ed	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b5ef	20 47 b7	jsr $b747			jsr 	WriteTempString
.b5f2					_UHExit:
.b5f2	4c d3 b6	jmp $b6d3			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b5f5					_UHConvert:
.b5f5	48		pha				pha
.b5f6	4a		lsr a				lsr 	a 							; do MSB
.b5f7	4a		lsr a				lsr 	a
.b5f8	4a		lsr a				lsr 	a
.b5f9	4a		lsr a				lsr 	a
.b5fa	20 fe b5	jsr $b5fe			jsr 	_UHNibble
.b5fd	68		pla				pla 								; do LSB
.b5fe					_UHNibble:
.b5fe	29 0f		and #$0f			and 	#15 						; get nibble
.b600	d0 0c		bne $b60e			bne 	_UHNonZero
.b602	5a		phy				phy									; get the length
.b603	a0 00		ldy #$00			ldy 	#0
.b605	b1 20		lda ($20),y			lda 	(zTempStr),y
.b607	7a		ply				ply
.b608	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b60a	f0 0d		beq $b619			beq 	_UHExit2
.b60c	a9 00		lda #$00			lda 	#0
.b60e					_UHNonZero:
.b60e	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b610	90 02		bcc $b614			bcc 	_UHDigit
.b612	69 06		adc #$06			adc 	#7-1
.b614					_UHDigit:
.b614	69 30		adc #$30			adc 	#48
.b616	20 47 b7	jsr $b747			jsr 	WriteTempString				; output.
.b619					_UHExit2:
.b619	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b61a					Unary_Dec:
.b61a	20 99 b0	jsr $b099			jsr 	EvaluateStringX 			; string parameter
.b61d	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b620	5a		phy				phy
.b621	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b623	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b625	f0 4c		beq $b673			beq 	_UDFail 					; must fail if zero.
.b627	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.b62a	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b62c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b62f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b632	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b635	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b638	a9 01		lda #$01			lda 	#1
.b63a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b63d					_UDConvertLoop:
.b63d	5a		phy				phy 								; shift mantissa left 4
.b63e	a0 04		ldy #$04			ldy 	#4
.b640					_UDShift:
.b640	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b643	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b646	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b649	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b64c	88		dey				dey
.b64d	d0 f1		bne $b640			bne 	_UDShift
.b64f	7a		ply				ply
.b650	c8		iny				iny 								; next character
.b651	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b653	20 76 b6	jsr $b676			jsr 	ConvertUpper 				; convert to U/C
.b656	c9 30		cmp #$30			cmp 	#"0"
.b658	90 19		bcc $b673			bcc 	_UDFail
.b65a	c9 3a		cmp #$3a			cmp 	#"9"+1
.b65c	90 06		bcc $b664			bcc 	_UDOkay
.b65e	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b660	c9 10		cmp #$10			cmp 	#16
.b662	b0 0f		bcs $b673			bcs 	_UDFail
.b664					_UDOkay:
.b664	29 0f		and #$0f			and 	#15 						; nibble only
.b666	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b669	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b66c	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.b66f	d0 cc		bne $b63d			bne 	_UDConvertLoop
.b671	7a		ply				ply
.b672	60		rts				rts
.b673					_UDFail:
.b673	4c 26 ab	jmp $ab26			jmp 	BadParamError
.b676					ConvertUpper:
.b676	c9 61		cmp #$61			cmp 	#"a"
.b678	90 07		bcc $b681			bcc 	_CUExit
.b67a	c9 7b		cmp #$7b			cmp 	#"z"+1
.b67c	b0 03		bcs $b681			bcs 	_CUExit
.b67e	38		sec				sec
.b67f	e9 20		sbc #$20			sbc 	#32
.b681	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b682					Unary_Chr:
.b682	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX			; numeric parameter
.b685	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b688	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b68b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b68e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b691	d0 0e		bne $b6a1			bne 	_UCChar
.b693	a9 01		lda #$01			lda 	#1 							; one character string
.b695	20 1c b7	jsr $b71c			jsr 	AllocateTempString
.b698	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b69b	20 47 b7	jsr $b747			jsr 	WriteTempString
.b69e	4c d3 b6	jmp $b6d3			jmp 	UnaryReturnTempStr
.b6a1					_UCChar:
.b6a1	4c 26 ab	jmp $ab26			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b6a4					Unary_Spc:
.b6a4	20 90 b0	jsr $b090			jsr 	EvaluateIntegerX 			; numeric parameter
.b6a7	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; right bracket.
.b6aa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6ad	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6b0	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6b3	d0 1b		bne $b6d0			bne 	_USSize
.b6b5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b6b8	c9 fe		cmp #$fe			cmp 	#maxString+1
.b6ba	b0 14		bcs $b6d0			bcs 	_USSize
.b6bc	48		pha				pha 								; save length
.b6bd	1a		inc a				inc 	a 							; allocate one more.
.b6be	20 1c b7	jsr $b71c			jsr 	AllocateTempString
.b6c1	68		pla				pla 								; get length
.b6c2	f0 0f		beq $b6d3			beq 	UnaryReturnTempStr 			; return the current temp string
.b6c4					_USLoop:
.b6c4	48		pha				pha
.b6c5	a9 20		lda #$20			lda 	#" "
.b6c7	20 47 b7	jsr $b747			jsr 	WriteTempString
.b6ca	68		pla				pla
.b6cb	3a		dec a				dec 	a
.b6cc	d0 f6		bne $b6c4			bne 	_USLoop
.b6ce	80 03		bra $b6d3			bra 	UnaryReturnTempStr
.b6d0					_USSize:
.b6d0	4c 26 ab	jmp $ab26			jmp 	BadParamError
.b6d3					UnaryReturnTempStr:
.b6d3	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b6d5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b6d8	a5 21		lda $21				lda 	zTempStr+1
.b6da	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b6dd	a9 02		lda #$02			lda 	#2 							; set type to string
.b6df	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b6e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b6e3					MemRead:
.b6e3	8d 25 04	sta $0425			sta 	SignCount 					; save count
.b6e6	a0 00		ldy #$00			ldy 	#0 							; start from here
.b6e8	b1 1a		lda ($1a),y	_MLoop1:lda 	(zlTemp1),y 				; read the long address
.b6ea	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b6ed	c8		iny				iny 								; next to copy
.b6ee	e8		inx				inx
.b6ef	cc 25 04	cpy $0425			cpy 	SignCount 					; do required # of bytes.
.b6f2	d0 f4		bne $b6e8			bne 	_MLoop1
.b6f4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b6f5					CheckNextToken:
.b6f5	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.b6f7	d0 02		bne $b6fb			bne 	CTFail 						; no, then fail
.b6f9	c8		iny				iny
.b6fa	60		rts				rts
.b6fb					CTFail:
.b6fb	20 37 ab	jsr $ab37			jsr ERR_Handler
>b6fe	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b706	74 6f 6b 65 6e 00
.b70c					CheckNextRParen:
.b70c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b70e	c9 bc		cmp #$bc			cmp 	#token_rparen
.b710	d0 e9		bne $b6fb			bne 	CTFail
.b712	c8		iny				iny
.b713	60		rts				rts
.b714					CheckNextComma:
.b714	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b716	c9 bd		cmp #$bd			cmp 	#token_comma
.b718	d0 e1		bne $b6fb			bne 	CTFail
.b71a	c8		iny				iny
.b71b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.b71c					AllocateTempString:
.b71c	48		pha				pha 								; save required count.
.b71d	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.b71f	d0 0b		bne $b72c			bne 	_ATSInitialised
.b721	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.b724	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.b726	ad 27 04	lda $0427			lda 	StringPtr+1
.b729	3a		dec a				dec 	a
.b72a	85 21		sta $21				sta 	zTempStr+1
.b72c					_ATSInitialised:
.b72c	68		pla				pla 								; get required count back.
.b72d	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.b72f	1a		inc a				inc 	a
.b730	18		clc				clc
.b731	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.b733	85 20		sta $20				sta 	zTempStr
.b735	a9 ff		lda #$ff			lda 	#$FF
.b737	65 21		adc $21				adc 	zTempStr+1
.b739	85 21		sta $21				sta 	zTempStr+1
.b73b	a9 00		lda #$00			lda 	#0 							; clear temp string.
.b73d	5a		phy				phy
.b73e	a8		tay				tay
.b73f	91 20		sta ($20),y			sta 	(zTempStr),y
.b741	7a		ply				ply
.b742	1a		inc a				inc 	a 							; reset the write index.
.b743	8d 28 04	sta $0428			sta 	TempStringWriteIndex
.b746	60		rts				rts
.b747					WriteTempString:
.b747	5a		phy				phy 								; save Y
.b748	ac 28 04	ldy $0428			ldy 	TempStringWriteIndex	 	; write position.
.b74b	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.b74d	ee 28 04	inc $0428			inc 	TempStringWriteIndex 		; increment the write position.
.b750	98		tya				tya 								; unchanged Y is now length
.b751	a0 00		ldy #$00			ldy 	#0
.b753	91 20		sta ($20),y			sta 	(zTempStr),y
.b755	7a		ply				ply 								; restore Y and exit
.b756	60		rts				rts
.b757					CreateTempStringCopy:
.b757	da		phx				phx 								; save X
.b758	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b75a	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.b75b	20 1c b7	jsr $b71c			jsr 	AllocateTempString 			; allocate memory for temporary string.
.b75e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b760	c8		iny				iny
.b761	3a		dec a				dec 	a 							; make the actual length in charactes
.b762	3a		dec a				dec 	a
.b763	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.b765	81 20		sta ($20,x)			sta 	(zTempStr,x)
.b767	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.b769	09 00		ora #$00			ora 	#0 							; if zero already, exit
.b76b	f0 0e		beq $b77b			beq 	_CTSCExit
.b76d					_CTSCLoop:
.b76d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.b76f	c8		iny				iny
.b770	5a		phy				phy 								; save in Y
.b771	e8		inx				inx 								; bump index
.b772	da		phx				phx 								; index into Y
.b773	7a		ply				ply
.b774	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.b776	7a		ply				ply 								; restore Y
.b777	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.b779	d0 f2		bne $b76d			bne 	_CTSCLoop
.b77b					_CTSCExit:
.b77b	fa		plx				plx 								; restore X
.b77c	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.b77d					MulInteger32:
.b77d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.b780	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.b783	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b786	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.b789	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b78c	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.b78f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b792	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.b795	a9 00		lda #$00			lda 	#0
.b797	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.b79a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b79d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b7a0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b7a3					_BFMMultiply:
.b7a3	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.b7a6	29 01		and #$01			and 	#1
.b7a8	f0 03		beq $b7ad			beq 	_BFMNoAdd
.b7aa	20 75 b2	jsr $b275			jsr 	AddInteger32
.b7ad					_BFMNoAdd:
.b7ad	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.b7b0	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.b7b3	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.b7b6	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.b7b9	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.b7bc	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.b7bf	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.b7c2	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.b7c5	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.b7c8	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.b7cb	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.b7ce	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.b7d1	d0 d0		bne $b7a3			bne 	_BFMMultiply
.b7d3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.b7d4					DivInteger32:
.b7d4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.b7d7	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b7da	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b7dd	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b7e0	d0 14		bne $b7f6			bne 	_BFDOkay
.b7e2	20 37 ab	jsr $ab37			jsr ERR_Handler
>b7e5	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>b7ed	20 62 79 20 5a 65 72 6f 00
.b7f6					_BFDOkay:
.b7f6	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.b7f8	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.b7fa	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.b7fc	85 1c		sta $1c				sta 	zLTemp1+2
.b7fe	85 1d		sta $1d				sta 	zLTemp1+3
.b800	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.b803	20 64 b8	jsr $b864			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.b806	da		phx				phx
.b807	e8		inx				inx
.b808	e8		inx				inx
.b809	e8		inx				inx
.b80a	e8		inx				inx
.b80b	e8		inx				inx
.b80c	e8		inx				inx
.b80d	20 64 b8	jsr $b864			jsr 	CheckIntegerNegate
.b810	fa		plx				plx
.b811	5a		phy				phy 								; Y is the counter
.b812	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.b814					_BFDLoop:
.b814	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.b817	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b81a	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b81d	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b820	26 1a		rol $1a				rol 	zLTemp1
.b822	26 1b		rol $1b				rol 	zLTemp1+1
.b824	26 1c		rol $1c				rol 	zLTemp1+2
.b826	26 1d		rol $1d				rol 	zLTemp1+3
.b828	38		sec				sec
.b829	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.b82b	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b82e	48		pha				pha
.b82f	a5 1b		lda $1b				lda 	zLTemp1+1
.b831	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b834	48		pha				pha
.b835	a5 1c		lda $1c				lda 	zLTemp1+2
.b837	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b83a	48		pha				pha
.b83b	a5 1d		lda $1d				lda 	zLTemp1+3
.b83d	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b840	90 15		bcc $b857			bcc 	_BFDNoAdd
.b842	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.b844	68		pla				pla
.b845	85 1c		sta $1c				sta 	zLTemp1+2
.b847	68		pla				pla
.b848	85 1b		sta $1b				sta 	zLTemp1+1
.b84a	68		pla				pla
.b84b	85 1a		sta $1a				sta 	zLTemp1+0
.b84d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.b850	09 01		ora #$01			ora 	#1
.b852	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b855	80 03		bra $b85a			bra 	_BFDNext
.b857					_BFDNoAdd:
.b857	68		pla				pla 								; Throw away the intermediate calculations
.b858	68		pla				pla
.b859	68		pla				pla
.b85a					_BFDNext:
.b85a	88		dey				dey
.b85b	d0 b7		bne $b814			bne 	_BFDLoop
.b85d	7a		ply				ply 								; restore Y and exit
.b85e	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.b861	b0 07		bcs $b86a			bcs		IntegerNegateAlways 			; negate the result
.b863	60		rts				rts
.b864					CheckIntegerNegate:
.b864	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b867	30 01		bmi $b86a			bmi 	IntegerNegateAlways
.b869	60		rts				rts
.b86a					IntegerNegateAlways:
.b86a	ee 25 04	inc $0425			inc 	SignCount
.b86d	38		sec				sec
.b86e	a9 00		lda #$00			lda 	#0
.b870	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.b873	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b876	a9 00		lda #$00			lda 	#0
.b878	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.b87b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b87e	a9 00		lda #$00			lda 	#0
.b880	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.b883	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b886	a9 00		lda #$00			lda 	#0
.b888	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.b88b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b88e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.b88f					INTToString:
.b88f	48		pha				pha
.b890	5a		phy				phy
.b891	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.b894	10 08		bpl $b89e			bpl 		_ITSNotMinus
.b896	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.b898	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter
.b89b	20 6a b8	jsr $b86a			jsr 		IntegerNegateAlways 	; negate the number.
.b89e					_ITSNotMinus:
.b89e	a9 00		lda #$00			lda 		#0
.b8a0	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.b8a3	8a		txa				txa 								; use Y for the mantissa index.
.b8a4	a8		tay				tay
.b8a5	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.b8a7					_ITSNextSubtractor:
.b8a7	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.b8a9	8d 22 04	sta $0422			sta 		NumConvCount
.b8ac					_ITSSubtract:
.b8ac	38		sec				sec
.b8ad	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.b8b0	fd 0b b9	sbc $b90b,x			sbc 		_ITSSubtractors+0,x
.b8b3	48		pha				pha
.b8b4	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.b8b7	fd 0c b9	sbc $b90c,x			sbc 		_ITSSubtractors+1,x
.b8ba	48		pha				pha
.b8bb	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.b8be	fd 0d b9	sbc $b90d,x			sbc 		_ITSSubtractors+2,x
.b8c1	48		pha				pha
.b8c2	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.b8c5	fd 0e b9	sbc $b90e,x			sbc 		_ITSSubtractors+3,x
.b8c8	90 14		bcc $b8de			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.b8ca	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.b8cd	68		pla				pla
.b8ce	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.b8d1	68		pla				pla
.b8d2	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.b8d5	68		pla				pla
.b8d6	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.b8d9	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.b8dc	80 ce		bra $b8ac			bra 		_ITSSubtract 			; go round again.
.b8de					_ITSCantSubtract:
.b8de	68		pla				pla 								; throw away interim answers
.b8df	68		pla				pla
.b8e0	68		pla				pla
.b8e1	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.b8e4	c9 30		cmp #$30			cmp 		#"0"
.b8e6	d0 05		bne $b8ed			bne 		_ITSOutputDigit
.b8e8	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.b8eb	10 09		bpl $b8f6			bpl	 		_ITSGoNextSubtractor
.b8ed					_ITSOutputDigit:
.b8ed	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.b8f0	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.b8f3	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter 		; output it.
.b8f6					_ITSGoNextSubtractor:
.b8f6	e8		inx				inx 								; next dword
.b8f7	e8		inx				inx
.b8f8	e8		inx				inx
.b8f9	e8		inx				inx
.b8fa	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.b8fc	d0 a9		bne $b8a7			bne 		_ITSNextSubtractor 		; do all the subtractors.
.b8fe	98		tya				tya 								; X is back as the mantissa index
.b8ff	aa		tax				tax
.b900	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.b903	09 30		ora #$30			ora 		#"0"
.b905	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter
.b908	7a		ply				ply 								; and exit
.b909	68		pla				pla
.b90a	60		rts				rts
.b90b					_ITSSubtractors:
>b90b	00 ca 9a 3b					.dword 		1000000000
>b90f	00 e1 f5 05					.dword 		100000000
>b913	80 96 98 00					.dword 		10000000
>b917	40 42 0f 00					.dword 		1000000
>b91b	a0 86 01 00					.dword 		100000
>b91f	10 27 00 00					.dword 		10000
>b923	e8 03 00 00					.dword 		1000
>b927	64 00 00 00					.dword 		100
>b92b	0a 00 00 00					.dword 		10
.b92f					_ITSSubtractorsEnd:
.b92f					ITSOutputCharacter:
.b92f	48		pha				pha
.b930	da		phx				phx
.b931	ae 00 04	ldx $0400			ldx 	NumBufX 					; save digit
.b934	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.b937	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.b939	9d 02 04	sta $0402,x			sta 	Num_Buffer+1,x
.b93c	ee 00 04	inc $0400			inc 	NumBufX						; bump pointer.
.b93f	fa		plx				plx
.b940	68		pla				pla
.b941	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.b942					IntFromString:
.b942	a0 00		ldy #$00			ldy 	#0
.b944	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.b947					IntFromStringY:
.b947	48		pha				pha
.b948	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.b94a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b94d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b950	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b953	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b956	a9 01		lda #$01			lda 	#1
.b958	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b95b					_IFSLoop:
.b95b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.b95d	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.b95f	90 60		bcc $b9c1			bcc 	_IFSExit
.b961	c9 3a		cmp #$3a			cmp 	#"9"+1
.b963	b0 5c		bcs $b9c1			bcs 	_IFSExit
.b965	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.b968	c9 0c		cmp #$0c			cmp 	#12
.b96a	b0 5f		bcs $b9cb			bcs 	_IFSOverflow
.b96c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.b96f	48		pha				pha
.b970	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b973	48		pha				pha
.b974	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b977	48		pha				pha
.b978	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b97b	48		pha				pha
.b97c	20 e0 b9	jsr $b9e0			jsr 	IFSX1ShiftLeft 				; double
.b97f	20 e0 b9	jsr $b9e0			jsr 	IFSX1ShiftLeft 				; x 4
.b982	18		clc				clc 								; add saved value x 5
.b983	68		pla				pla
.b984	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b987	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b98a	68		pla				pla
.b98b	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.b98e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b991	68		pla				pla
.b992	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.b995	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b998	68		pla				pla
.b999	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.b99c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b99f	20 e0 b9	jsr $b9e0			jsr 	IFSX1ShiftLeft 				; x 10
.b9a2	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.b9a5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.b9a7	29 0f		and #$0f			and 	#15
.b9a9	c8		iny				iny
.b9aa	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.b9ad	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b9b0	90 a9		bcc $b95b			bcc 	_IFSLoop
.b9b2	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.b9b5	d0 a4		bne $b95b			bne 	_IFSLoop
.b9b7	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.b9ba	d0 9f		bne $b95b			bne 	_IFSLoop
.b9bc	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.b9bf	80 9a		bra $b95b			bra 	_IFSLoop
.b9c1					_IFSExit:
.b9c1	98		tya				tya 								; get offset
.b9c2					_IFSOkay:
.b9c2	38		sec				sec
.b9c3	ad 23 04	lda $0423			lda 	ExpTemp
.b9c6	f0 01		beq $b9c9			beq 	_IFSSkipFail
.b9c8	18		clc				clc
.b9c9					_IFSSkipFail:
.b9c9	68		pla				pla 								; and exit.
.b9ca	60		rts				rts
.b9cb					_IFSOverflow:
.b9cb	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>b9ce	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>b9d6	20 6f 76 65 72 66 6c 6f 77 00
.b9e0					IFSX1ShiftLeft:
.b9e0	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b9e3	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b9e6	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b9e9	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b9ec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.b9ed					FPSubtract:
.b9ed	48		pha				pha
.b9ee	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.b9f1	49 80		eor #$80			eor 	#$80
.b9f3	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.b9f6	68		pla				pla 								; --- and fall through ---
.b9f7					FPAdd:
.b9f7	48		pha				pha
.b9f8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.b9fb	d0 05		bne $ba02			bne 	_FPA_NegativeLHS
.b9fd	20 1f ba	jsr $ba1f			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.ba00	68		pla				pla
.ba01	60		rts				rts
.ba02					_FPA_NegativeLHS:
.ba02	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ba05	49 80		eor #$80			eor 	#$80
.ba07	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba0a	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ba0d	49 80		eor #$80			eor 	#$80
.ba0f	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.ba12	20 1f ba	jsr $ba1f			jsr 	FPAdd_Worker 				; do the add calculation.
.ba15	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.ba18	49 80		eor #$80			eor 	#$80
.ba1a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.ba1d	68		pla				pla
.ba1e	60		rts				rts
.ba1f					FPAdd_Worker:
.ba1f	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.ba22	70 08		bvs $ba2c			bvs 	_FPAWExit 					; no change.
.ba24	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.ba27	50 07		bvc $ba30			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.ba29	20 c4 bc	jsr $bcc4			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.ba2c					_FPAWExit:
.ba2c	20 4c bd	jsr $bd4c			jsr 	FPUNormalise 				; normalise the result.
.ba2f	60		rts				rts
.ba30					_FPAWMakeSame:
.ba30	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.ba33	38		sec				sec
.ba34	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.ba37	f0 1b		beq $ba54			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.ba39	da		phx				phx 								; save X
.ba3a	90 06		bcc $ba42			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.ba3c	e8		inx				inx
.ba3d	e8		inx				inx
.ba3e	e8		inx				inx
.ba3f	e8		inx				inx
.ba40	e8		inx				inx
.ba41	e8		inx				inx
.ba42					_FPAWShiftA:
.ba42	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba45	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.ba48	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba4b	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.ba4e	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.ba51	fa		plx				plx 								; restore original X
.ba52	80 dc		bra $ba30			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.ba54					_FPAW_DoArithmetic:
.ba54	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.ba57	30 39		bmi $ba92			bmi 	_FPAW_BNegative
.ba59	18		clc				clc
.ba5a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ba5d	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.ba60	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba63	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ba66	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.ba69	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.ba6c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.ba6f	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.ba72	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ba75	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.ba78	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.ba7b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ba7e	90 ac		bcc $ba2c			bcc 	_FPAWExit 					; no carry.
.ba80	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ba83	38		sec				sec
.ba84	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.ba87	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.ba8a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.ba8d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.ba90	80 9a		bra $ba2c			bra 	_FPAWExit
.ba92					_FPAW_BNegative:
.ba92	38		sec				sec
.ba93	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.ba96	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.ba99	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.ba9c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.ba9f	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.baa2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.baa5	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.baa8	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.baab	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.baae	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bab1	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bab4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bab7	b0 0b		bcs $bac4			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.bab9	20 f1 bc	jsr $bcf1			jsr 	FPUNegateInteger			; negate the mantissa
.babc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.babf	49 80		eor #$80			eor 	#$80
.bac1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bac4					_FPAWGoExit:
.bac4	4c 2c ba	jmp $ba2c			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.bac7					FPD_IsDivZero:
.bac7	20 37 ab	jsr $ab37			jsr ERR_Handler
>baca	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>bad2	20 62 79 20 7a 65 72 6f 00
.badb					FPDivide:
.badb	48		pha				pha
.badc	5a		phy				phy
.badd	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.bae0	70 e5		bvs $bac7			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.bae2	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.bae5	f0 03		beq $baea			beq 	_FPDCalculateExp
.bae7					_FPD_Exit:
.bae7	7a		ply				ply
.bae8	68		pla				pla
.bae9	60		rts				rts
.baea					_FPDCalculateExp:
.baea	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.baed	49 ff		eor #$ff			eor 	#$FF
.baef	1a		inc a				inc 	a
.baf0	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.baf3	20 e7 bb	jsr $bbe7			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.baf6	18		clc				clc 	 							; add 1 to the resulting exponent
.baf7	69 01		adc #$01			adc 	#1
.baf9	b0 65		bcs $bb60			bcs 	_FPD_Overflow 				; which can overflow.
.bafb	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bafe	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.bb00	85 1a		sta $1a				sta 	zLTemp1+0
.bb02	85 1b		sta $1b				sta 	zLTemp1+1
.bb04	85 1c		sta $1c				sta 	zLTemp1+2
.bb06	85 1d		sta $1d				sta 	zLTemp1+3
.bb08	a0 20		ldy #$20			ldy 	#32 						; times round.
.bb0a					_FPD_Loop:
.bb0a	38		sec				sec 								; calculate X1-X2 stacking result because we might
.bb0b	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.bb0e	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.bb11	48		pha				pha
.bb12	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bb15	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bb18	48		pha				pha
.bb19	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bb1c	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bb1f	48		pha				pha
.bb20	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bb23	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bb26	90 17		bcc $bb3f			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.bb28	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.bb2b	68		pla				pla
.bb2c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bb2f	68		pla				pla
.bb30	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bb33	68		pla				pla
.bb34	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bb37	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.bb39	09 80		ora #$80			ora 	#$80
.bb3b	85 1d		sta $1d				sta 	zLTemp1+3
.bb3d	80 03		bra $bb42			bra 	_FPD_Rotates
.bb3f					_FPD_NoSubtract:
.bb3f	68		pla				pla 								; throw away unwanted results
.bb40	68		pla				pla
.bb41	68		pla				pla
.bb42					_FPD_Rotates:
.bb42	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.bb45	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.bb48	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.bb4b	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.bb4e	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.bb50	26 1b		rol $1b				rol 	zLTemp1+1
.bb52	26 1c		rol $1c				rol 	zLTemp1+2
.bb54	26 1d		rol $1d				rol 	zLTemp1+3
.bb56	90 02		bcc $bb5a			bcc 	_FPD_NoCarry
.bb58	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.bb5a					_FPD_NoCarry:
.bb5a	88		dey				dey 								; do 32 times
.bb5b	d0 ad		bne $bb0a			bne 	_FPD_Loop
.bb5d	4c c4 bb	jmp $bbc4			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.bb60					_FPD_Overflow:
.bb60	4c c1 bd	jmp $bdc1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.bb63					FPMultiply:
.bb63	48		pha				pha
.bb64	5a		phy				phy
.bb65	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.bb68	70 08		bvs $bb72			bvs 	_FPM_Exit
.bb6a	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.bb6d	50 06		bvc $bb75			bvc 	_FPM_CalcExponent
.bb6f	20 c4 bc	jsr $bcc4			jsr 	FPUCopyX2ToX1
.bb72					_FPM_Exit:
.bb72	7a		ply				ply
.bb73	68		pla				pla
.bb74	60		rts				rts
.bb75					_FPM_CalcExponent:
.bb75	18		clc				clc
.bb76	20 e7 bb	jsr $bbe7			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.bb79	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.bb7c	a9 00		lda #$00			lda 	#0
.bb7e	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.bb80	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.bb82	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.bb84	85 1d		sta $1d				sta 	zLTemp1+3
.bb86	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.bb88					_FPM_Loop:
.bb88	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.bb8b	29 01		and #$01			and 	#1
.bb8d	18		clc				clc 								; clear carry for the long rotate.
.bb8e	f0 1d		beq $bbad			beq 	_FPM_NoAddition
.bb90	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.bb91	a5 1a		lda $1a				lda 	zLTemp1+0
.bb93	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bb96	85 1a		sta $1a				sta 	zLTemp1+0
.bb98	a5 1b		lda $1b				lda 	zLTemp1+1
.bb9a	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bb9d	85 1b		sta $1b				sta 	zLTemp1+1
.bb9f	a5 1c		lda $1c				lda 	zLTemp1+2
.bba1	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bba4	85 1c		sta $1c				sta 	zLTemp1+2
.bba6	a5 1d		lda $1d				lda 	zLTemp1+3
.bba8	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bbab	85 1d		sta $1d				sta 	zLTemp1+3
.bbad					_FPM_NoAddition:
.bbad	66 1d		ror $1d				ror 	3+zLTemp1
.bbaf	66 1c		ror $1c				ror 	2+zLTemp1
.bbb1	66 1b		ror $1b				ror 	1+zLTemp1
.bbb3	66 1a		ror $1a				ror 	0+zLTemp1
.bbb5	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bbb8	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bbbb	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bbbe	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bbc1	88		dey				dey
.bbc2	d0 c4		bne $bb88			bne 	_FPM_Loop 					; do this 32 times.
.bbc4					FPM_CopySignNormalize:
.bbc4	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.bbc6	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.bbc9	a5 1b		lda $1b				lda 	zLTemp1+1
.bbcb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bbce	a5 1c		lda $1c				lda 	zLTemp1+2
.bbd0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bbd3	a5 1d		lda $1d				lda 	zLTemp1+3
.bbd5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bbd8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.bbdb	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.bbde	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bbe1	20 4c bd	jsr $bd4c			jsr 	FPUNormalise 				; normalise and exit.
.bbe4	7a		ply				ply
.bbe5	68		pla				pla
.bbe6	60		rts				rts
.bbe7					FPCalculateExponent:
.bbe7	18		clc				clc
.bbe8	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.bbeb	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.bbee	b0 08		bcs $bbf8			bcs 	_FPCECarry 					; carry out ?
.bbf0	10 03		bpl $bbf5			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.bbf2	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.bbf4	60		rts				rts
.bbf5					_FPCEExpZero:
.bbf5	a9 00		lda #$00			lda 	#0
.bbf7	60		rts				rts
.bbf8					_FPCECarry:
.bbf8	30 03		bmi $bbfd			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.bbfa	09 80		ora #$80			ora 	#$80 						; put in right range
.bbfc	60		rts				rts
.bbfd					_FPCEOverflow:
.bbfd	4c c1 bd	jmp $bdc1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.bc00					FPFractionalPart:
.bc00	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.bc03	38		sec				sec 								; this flag tells us to keep the fractional part
.bc04	30 0f		bmi $bc15			bmi 	FPGetPart
.bc06	60		rts				rts
.bc07					FPIntegerPart:
.bc07	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.bc0a	18		clc				clc 								; this flag says keep the integer part.
.bc0b	30 08		bmi $bc15			bmi 	FPGetPart 					; -ve exponents are 0..127
.bc0d	48		pha				pha
.bc0e	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.bc10	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc13	68		pla				pla
.bc14	60		rts				rts
.bc15					FPGetPart:
.bc15	48		pha				pha
.bc16	5a		phy				phy 								; save Y
.bc17	08		php				php 								; save action
.bc18	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.bc1b	70 62		bvs $bc7f			bvs 	_FPGP_Exit 					; then do nothing.
.bc1d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.bc1f	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.bc21	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.bc23	85 1c		sta $1c				sta 	zLTemp1+2
.bc25	85 1d		sta $1d				sta 	zLTemp1+3
.bc27	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.bc2a	38		sec				sec
.bc2b	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.bc2d	f0 12		beq $bc41			beq 	_FPGP_NoShift 				; ... if any
.bc2f	c9 20		cmp #$20			cmp 	#32
.bc31	90 02		bcc $bc35			bcc 	_FPGP_NotMax
.bc33	a9 20		lda #$20			lda 	#32 						; max of 32.
.bc35					_FPGP_NotMax:
.bc35	a8		tay				tay 								; Y is the mask shift count.
.bc36					_FPGP_ShiftMask:
.bc36	46 1d		lsr $1d				lsr 	3+zLTemp1
.bc38	66 1c		ror $1c				ror 	2+zLTemp1
.bc3a	66 1b		ror $1b				ror 	1+zLTemp1
.bc3c	66 1a		ror $1a				ror 	0+zLTemp1
.bc3e	88		dey				dey
.bc3f	d0 f5		bne $bc36			bne 	_FPGP_ShiftMask
.bc41					_FPGP_NoShift:
.bc41	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.bc43	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.bc46					_FPGP_MaskLoop:
.bc46	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.bc49	28		plp				plp 								; if CC we keep the top part, so we
.bc4a	08		php				php		 							; flip the mask.
.bc4b	b0 02		bcs $bc4f			bcs		_FPGP_NoFlip
.bc4d	49 ff		eor #$ff			eor 	#$FF
.bc4f					_FPGP_NoFlip:
.bc4f	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.bc52	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bc55	e8		inx				inx
.bc56	c8		iny				iny
.bc57	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.bc59	d0 eb		bne $bc46			bne 	_FPGP_MaskLoop
.bc5b	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.bc5e	28		plp				plp
.bc5f	08		php				php 								; get action flag on the stack
.bc60	90 05		bcc $bc67			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.bc62	a9 00		lda #$00			lda 	#0
.bc64	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc67					_FPGP_NotFractional:
.bc67	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.bc6a	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bc6d	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bc70	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bc73	f0 05		beq $bc7a			beq 	_FPGP_Zero 					; if zero, return zero
.bc75	20 4c bd	jsr $bd4c			jsr 	FPUNormalise
.bc78	80 05		bra $bc7f			bra 	_FPGP_Exit 					; and exit
.bc7a					_FPGP_Zero:
.bc7a	a9 40		lda #$40			lda 	#$40 						; set zero flag
.bc7c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc7f					_FPGP_Exit:
.bc7f	68		pla				pla 								; throw saved action flag.
.bc80	7a		ply				ply
.bc81	68		pla				pla
.bc82	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.bc83					FPCompare:
.bc83	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.bc86	48		pha				pha
.bc87	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.bc8a	48		pha				pha
.bc8b	20 ed b9	jsr $b9ed			jsr 	FPSubtract 					; calculate X1-X2
.bc8e	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.bc91	70 2c		bvs $bcbf			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.bc93	68		pla				pla
.bc94	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.bc97	68		pla				pla
.bc98	38		sec				sec
.bc99	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.bc9c	70 15		bvs $bcb3			bvs 	_FPCNotEqual				; overflow, can't be equal.
.bc9e	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.bc9f	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.bca1	b0 10		bcs $bcb3			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.bca3	38		sec				sec
.bca4	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.bca7	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.bca9	b0 02		bcs $bcad			bcs 	_FPCNotRange 				; keep in range.
.bcab	a9 01		lda #$01			lda 	#1
.bcad					_FPCNotRange:
.bcad	38		sec				sec
.bcae	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.bcb1	b0 0e		bcs $bcc1			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.bcb3					_FPCNotEqual:
.bcb3	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.bcb6	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.bcb8	f0 02		beq $bcbc			beq 	_FPCNE2
.bcba	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.bcbc	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.bcbd	80 04		bra $bcc3			bra 	_FPCExit
.bcbf					_FPCPullZero:
.bcbf	68		pla				pla 								; throw saved exponents
.bcc0	68		pla				pla
.bcc1					_FPCZero:
.bcc1	a9 00		lda #$00			lda 	#0 							; and return zero
.bcc3					_FPCExit:
.bcc3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.bcc4					FPUCopyX2ToX1:
.bcc4	48		pha				pha
.bcc5	da		phx				phx
.bcc6	5a		phy				phy
.bcc7	a0 08		ldy #$08			ldy 	#8
.bcc9	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.bccc	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bccf	e8		inx				inx
.bcd0	88		dey				dey
.bcd1	10 f6		bpl $bcc9			bpl 	_FPUC21
.bcd3	7a		ply				ply
.bcd4	fa		plx				plx
.bcd5	68		pla				pla
.bcd6	60		rts				rts
.bcd7					FPUSetInteger:
.bcd7	48		pha				pha
.bcd8	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.bcdb	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.bcdd	10 02		bpl $bce1			bpl 	_FPUSIExtend
.bcdf	a9 ff		lda #$ff			lda 	#$FF
.bce1					_FPUSIExtend:
.bce1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.bce4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bce7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bcea	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.bcec	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bcef	68		pla				pla
.bcf0	60		rts				rts
.bcf1					FPUNegateInteger:
.bcf1	48		pha				pha
.bcf2	38		sec				sec
.bcf3	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.bcf5	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bcf8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bcfb	a9 00		lda #$00			lda 	#0
.bcfd	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bd00	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd03	a9 00		lda #$00			lda 	#0
.bd05	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bd08	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd0b	a9 00		lda #$00			lda 	#0
.bd0d	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.bd10	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bd13	68		pla				pla
.bd14	60		rts				rts
.bd15					FPUToFloat:
.bd15	48		pha				pha
.bd16	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.bd19	29 0f		and #$0f			and 	#$0F
.bd1b	f0 2d		beq $bd4a			beq 	_FPUFExit
.bd1d	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.bd1f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd22	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.bd24	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.bd27	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.bd2a	10 08		bpl $bd34			bpl		_FPUFPositive
.bd2c	20 f1 bc	jsr $bcf1			jsr 	FPUNegateInteger 			; negate the mantissa
.bd2f	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.bd31	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd34					_FPUFPositive:
.bd34	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.bd37	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bd3a	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bd3d	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bd40	d0 05		bne $bd47			bne 	_FPUFNonZero
.bd42	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.bd44	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd47					_FPUFNonZero:
.bd47	20 4c bd	jsr $bd4c			jsr 	FPUNormalise 				; normalise the floating point.
.bd4a					_FPUFExit:
.bd4a	68		pla				pla
.bd4b	60		rts				rts
.bd4c					FPUNormalise:
.bd4c	48		pha				pha
.bd4d	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.bd50	70 20		bvs $bd72			bvs 	_FPUNExit
.bd52	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.bd55	f0 16		beq $bd6d			beq 	_FPUNSetZero
.bd57					_FPUNLoop:
.bd57	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.bd5a	30 16		bmi $bd72			bmi 	_FPUNExit 					; if so, we are normalised.
.bd5c	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.bd5f	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.bd62	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.bd65	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.bd68	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.bd6b	d0 ea		bne $bd57			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.bd6d					_FPUNSetZero:
.bd6d	a9 40		lda #$40			lda 	#$40
.bd6f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.bd72					_FPUNExit:
.bd72	68		pla				pla
.bd73	60		rts				rts
.bd74					FPUToInteger:
.bd74	48		pha				pha
.bd75	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.bd78	29 01		and #$01			and 	#1
.bd7a	d0 3e		bne $bdba			bne 	_FPUTOI_Exit
.bd7c	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.bd7f	70 2b		bvs $bdac			bvs 	_FPUTOI_Zero
.bd81	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.bd84	10 26		bpl $bdac			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.bd86	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.bd88	b0 37		bcs $bdc1			bcs 	FP_Overflow
.bd8a					_FPUToIToInteger:
.bd8a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.bd8d	c9 a0		cmp #$a0			cmp 	#128+32
.bd8f	f0 11		beq $bda2			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.bd91	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.bd94	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bd97	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bd9a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bd9d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bda0	80 e8		bra $bd8a			bra 	_FPUToIToInteger 			; keep going.
.bda2					_FPUToICheckSign:
.bda2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.bda5	10 13		bpl $bdba			bpl 	_FPUToI_Exit 				; exit if unsigned.
.bda7	20 f1 bc	jsr $bcf1			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.bdaa	80 0e		bra $bdba			bra 	_FPUTOI_Exit
.bdac					_FPUTOI_Zero:
.bdac	a9 00		lda #$00			lda 	#0 							; return zero integer.
.bdae	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bdb1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bdb4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bdb7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bdba					_FPUToI_Exit:
.bdba	a9 01		lda #$01			lda 	#1 							; set type to integer
.bdbc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bdbf	68		pla				pla
.bdc0	60		rts				rts
.bdc1					FP_Overflow:
.bdc1	20 37 ab	jsr $ab37			jsr ERR_Handler
>bdc4	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>bdcc	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.bddc					FPUTimes10:
.bddc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.bddf	85 1a		sta $1a				sta 	ZLTemp1+0
.bde1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bde4	85 1b		sta $1b				sta 	ZLTemp1+1
.bde6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bde9	85 1c		sta $1c				sta 	ZLTemp1+2
.bdeb	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bdee	85 1d		sta $1d				sta 	ZLTemp1+3
.bdf0	20 34 be	jsr $be34			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.bdf3	20 34 be	jsr $be34			jsr 	_FPUT_LSR_ZLTemp1
.bdf6	18		clc				clc
.bdf7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.bdfa	65 1a		adc $1a				adc 	ZLTemp1+0
.bdfc	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bdff	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.be02	65 1b		adc $1b				adc 	ZLTemp1+1
.be04	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be07	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.be0a	65 1c		adc $1c				adc 	ZLTemp1+2
.be0c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be0f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.be12	65 1d		adc $1d				adc 	ZLTemp1+3
.be14	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be17	90 0f		bcc $be28			bcc 	_FPUTimes10
.be19	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.be1c	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.be1f	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.be22	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.be25	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.be28					_FPUTimes10:
.be28	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.be2b	18		clc				clc
.be2c	69 03		adc #$03			adc 	#3
.be2e	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be31	b0 8e		bcs $bdc1			bcs 	FP_Overflow 				; error
.be33	60		rts				rts
.be34					_FPUT_LSR_ZLTemp1:
.be34	46 1d		lsr $1d				lsr 	ZLTemp1+3
.be36	66 1c		ror $1c				ror 	ZLTemp1+2
.be38	66 1b		ror $1b				ror 	ZLTemp1+1
.be3a	66 1a		ror $1a				ror 	ZLTemp1+0
.be3c	60		rts				rts
.be3d					FPUScale10A:
.be3d	5a		phy				phy
.be3e	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.be40	f0 3d		beq $be7f			beq 	_FPUScaleExit
.be42	da		phx				phx 								; save X
.be43	e8		inx				inx
.be44	e8		inx				inx
.be45	e8		inx				inx
.be46	e8		inx				inx
.be47	e8		inx				inx
.be48	e8		inx				inx
.be49	a8		tay				tay 								; save power scalar in Y.
.be4a	a9 00		lda #$00			lda 	#0
.be4c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.be4f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be52	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be55	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be58	a9 80		lda #$80			lda 	#$80
.be5a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be5d	a9 81		lda #$81			lda 	#$81
.be5f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.be62	5a		phy				phy 								; save 10^n on stack.
.be63	c0 00		cpy #$00			cpy 	#0
.be65	10 05		bpl $be6c			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.be67	98		tya				tya
.be68	49 ff		eor #$ff			eor 	#$FF
.be6a	1a		inc a				inc 	a
.be6b	a8		tay				tay
.be6c					_FPUSAbs:
.be6c	20 dc bd	jsr $bddc			jsr 	FPUTimes10
.be6f	88		dey				dey
.be70	d0 fa		bne $be6c			bne 	_FPUSAbs 					; tos is now 10^|AC|
.be72	68		pla				pla 								; restore count in A
.be73	fa		plx				plx 								; restore X pointing to number to scale.
.be74	0a		asl a				asl 	a
.be75	b0 05		bcs $be7c			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.be77	20 63 bb	jsr $bb63			jsr 	FPMultiply 					; if clear multiply.
.be7a	80 03		bra $be7f			bra		_FPUScaleExit
.be7c					_FPUSDivide:
.be7c	20 db ba	jsr $badb			jsr 	FPDivide
.be7f					_FPUScaleExit:
.be7f	7a		ply				ply
.be80	60		rts				rts
.be81					FPUCopyToNext:
.be81	a0 06		ldy #$06			ldy 		#6
.be83	da		phx				phx
.be84					_FPUCopy1:
.be84	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.be87	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.be8a	e8		inx				inx
.be8b	88		dey				dey
.be8c	d0 f6		bne $be84			bne 	_FPUCopy1
.be8e	fa		plx				plx
.be8f	60		rts				rts
.be90					FPUCopyFromNext:
.be90	a0 06		ldy #$06			ldy 		#6
.be92	da		phx				phx
.be93					_FPUCopy1:
.be93	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.be96	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.be99	e8		inx				inx
.be9a	88		dey				dey
.be9b	d0 f6		bne $be93			bne 	_FPUCopy1
.be9d	fa		plx				plx
.be9e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.be9f					FPToString:
.be9f	48		pha				pha
.bea0	5a		phy				phy
.bea1	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.bea4	50 0a		bvc $beb0			bvc 		_FPTSIsFloat 			; if zero,
.bea6					_FPTSZero:
.bea6	a9 30		lda #$30			lda 		#"0"
.bea8	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter
.beab					_FPTSExit:
.beab	7a		ply				ply
.beac	68		pla				pla
.bead	60		rts				rts
.beae	80 fb		bra $beab			bra 		_FPTSExit
.beb0					_FPTSIsFloat:
.beb0	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.beb3	10 0a		bpl $bebf			bpl 		_FPTSNotSigned
.beb5	a9 00		lda #$00			lda 		#0 						; clear sign flag
.beb7	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.beba	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.bebc	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter
.bebf					_FPTSNotSigned:
.bebf	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.bec2	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.bec4	b0 09		bcs $becf			bcs 		_FPTSExponent
.bec6	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.bec8	90 05		bcc $becf			bcc 		_FPTSExponent 			;
.beca					_FPTSStandard:
.beca	20 13 bf	jsr $bf13			jsr 		FPTOutputBody 			; output the body.
.becd	80 dc		bra $beab			bra 		_FPTSExit
.becf					_FPTSExponent:
.becf	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.bed1	8d 24 04	sta $0424			sta 		ExpCount
.bed4					_FPTSExponentLoop:
.bed4	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.bed7	10 0e		bpl $bee7			bpl 		_FPTSTimes
.bed9	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.bedb	90 14		bcc $bef1			bcc 		_FPTSScaledToExp
.bedd	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.bedf	20 3d be	jsr $be3d			jsr 		FPUScale10A
.bee2	ee 24 04	inc $0424			inc 		ExpCount
.bee5	80 ed		bra $bed4			bra 		_FPTSExponentLoop
.bee7					_FPTSTimes:
.bee7	a9 01		lda #$01			lda 		#1
.bee9	20 3d be	jsr $be3d			jsr 		FPUScale10A
.beec	ce 24 04	dec $0424			dec 		ExpCount
.beef	80 e3		bra $bed4			bra 		_FPTSExponentLoop
.bef1					_FPTSScaledToExp:
.bef1	20 13 bf	jsr $bf13			jsr 		FPTOutputBody 			; output the body.
.bef4	a9 65		lda #$65			lda 		#"e"					; output E
.bef6	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter
.bef9	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.befc	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.beff	29 80		and #$80			and 		#$80 					; sign extend it
.bf01	f0 02		beq $bf05			beq 		_FPTSSExt
.bf03	a9 ff		lda #$ff			lda 		#$FF
.bf05					_FPTSSExt:
.bf05	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.bf08	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.bf0b	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.bf0e	20 8f b8	jsr $b88f			jsr 		INTToString 			; output the exponent.
.bf11	80 98		bra $beab			bra			_FPTSExit 				; and exit.
.bf13					FPTOutputBody:
.bf13	20 81 be	jsr $be81			jsr 		FPUCopyToNext 			; copy to next slot.
.bf16	20 74 bd	jsr $bd74			jsr 		FPUToInteger 			; convert to an integer
.bf19	20 8f b8	jsr $b88f			jsr 		INTToString 			; output the main integer part.
.bf1c	20 90 be	jsr $be90			jsr 		FPUCopyFromNext 		; get the fractional part back.
.bf1f	20 00 bc	jsr $bc00			jsr 		FPFractionalPart 		; get the decimal part.
.bf22	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.bf25	70 3e		bvs $bf65			bvs 		_FPTOExit 				; if not, exit now.
.bf27	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.bf29	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter
.bf2c					_FPOutLoop:
.bf2c	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.bf2f	70 1e		bvs $bf4f			bvs 		_FPStripZeros 			; strip trailing zeros
.bf31	20 dc bd	jsr $bddc			jsr 		FPUTimes10 				; multiply by 10
.bf34	20 81 be	jsr $be81			jsr 		FPUCopyToNext			; copy to next slot.
.bf37	20 74 bd	jsr $bd74			jsr 		FPUToInteger 			; convert to integer
.bf3a	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.bf3d	09 30		ora #$30			ora 		#"0"
.bf3f	20 2f b9	jsr $b92f			jsr 		ITSOutputCharacter
.bf42	20 90 be	jsr $be90			jsr 		FPUCopyFromNext 		; get it back
.bf45	20 00 bc	jsr $bc00			jsr 		FPFractionalPart 		; get fractional part
.bf48	ad 00 04	lda $0400			lda 		NumBufX 				; done 11 characters yet ?
.bf4b	c9 0b		cmp #$0b			cmp 	 	#11
.bf4d	90 dd		bcc $bf2c			bcc 		_FPOutLoop 				; if so, keep going till zero.
.bf4f					_FPStripZeros:
.bf4f	ac 00 04	ldy $0400			ldy 		NumBufX 				; strip trailing zeros.
.bf52					_FPStripLoop:
.bf52	88		dey				dey 								; back one, if at start then no strip
.bf53	f0 10		beq $bf65			beq 		_FPToExit
.bf55	b9 01 04	lda $0401,y			lda 		Num_Buffer,y 			; keep going if "0"
.bf58	c9 30		cmp #$30			cmp 		#"0"
.bf5a	f0 f6		beq $bf52			beq 		_FPStripLoop
.bf5c	c8		iny				iny
.bf5d	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.bf5f	99 01 04	sta $0401,y			sta 		Num_Buffer,y
.bf62	8c 00 04	sty $0400			sty 		NumBufX 				; update position.
.bf65					_FPTOExit:
.bf65	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.bf66					FPFromString:
.bf66	48		pha				pha 								; push A
.bf67	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.bf69	c9 2e		cmp #$2e			cmp 	#"."
.bf6b	f0 03		beq $bf70			beq	 	_FPFIsDecimal
.bf6d	4c d3 bf	jmp $bfd3			jmp 	_FPFNotDecimal
.bf70					_FPFIsDecimal:
.bf70	c8		iny				iny 								; consume the decimal.
.bf71	20 15 bd	jsr $bd15			jsr 	FPUToFloat 					; convert the integer to float.
.bf74	da		phx				phx 								; save X.
.bf75	5a		phy				phy 								; save decimal start position
.bf76	e8		inx				inx
.bf77	e8		inx				inx
.bf78	e8		inx				inx
.bf79	e8		inx				inx
.bf7a	e8		inx				inx
.bf7b	e8		inx				inx
.bf7c	20 47 b9	jsr $b947			jsr 	INTFromStringY 				; get the part after the DP.
.bf7f	20 15 bd	jsr $bd15			jsr 	FPUToFloat 					; convert that to a float.
.bf82	68		pla				pla 								; calculate - chars consumed.
.bf83	8c 23 04	sty $0423			sty 	ExpTemp
.bf86	38		sec				sec
.bf87	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.bf8a	20 3d be	jsr $be3d			jsr 	FPUScale10A 				; scale it by 10^AC
.bf8d	fa		plx				plx 								; restore original X
.bf8e	20 f7 b9	jsr $b9f7			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.bf91	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.bf93	c9 45		cmp #$45			cmp 	#"E"
.bf95	f0 04		beq $bf9b			beq 	_FPFExponent
.bf97	c9 65		cmp #$65			cmp 	#"e"
.bf99	d0 38		bne $bfd3			bne 	_FPFNotDecimal 				; no, then exit normally.
.bf9b					_FPFExponent:
.bf9b	c8		iny				iny 								; skip over E symbol.
.bf9c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.bf9e	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.bfa0	d0 01		bne $bfa3			bne 	_FPFGotSign
.bfa2	c8		iny				iny 								; if it was - skip over it.
.bfa3					_FPFGotSign:
.bfa3	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.bfa4	da		phx				phx
.bfa5	e8		inx				inx
.bfa6	e8		inx				inx
.bfa7	e8		inx				inx
.bfa8	e8		inx				inx
.bfa9	e8		inx				inx
.bfaa	e8		inx				inx
.bfab	20 47 b9	jsr $b947			jsr 	INTFromStringY 				; get the exponent
.bfae	fa		plx				plx 								; restore X.
.bfaf	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.bfb2	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.bfb5	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.bfb8	d0 1b		bne $bfd5			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.bfba	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.bfbd	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.bfbf	b0 14		bcs $bfd5			bcs 	_FPFXOverflow
.bfc1	68		pla				pla 								; get direction
.bfc2	d0 09		bne $bfcd			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.bfc4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.bfc7	49 ff		eor #$ff			eor 	#$FF
.bfc9	1a		inc a				inc 	a
.bfca	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.bfcd					_FPFXScale:
.bfcd	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.bfd0	20 3d be	jsr $be3d			jsr 	FPUScale10A 				; scale by the exponent.
.bfd3					_FPFNotDecimal:
.bfd3	68		pla				pla
.bfd4	60		rts				rts
.bfd5					_FPFXOverflow:
.bfd5	20 37 ab	jsr $ab37			jsr 	ERR_Handler
>bfd8	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>bfe0	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.bfe7					Unary_Rnd:
.bfe7	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.bfea	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; check right bracket.
.bfed	20 6e b3	jsr $b36e			jsr 	GetSignCurrent 				; get sign -1,0,1.
.bff0	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.bff2	30 10		bmi $c004			bmi 	_URSetSeed
.bff4	f0 2c		beq $c022			beq 	_URMakeRandom 				; if zero return same number.
.bff6	da		phx				phx
.bff7	a2 00		ldx #$00			ldx 	#0
.bff9	20 5f c0	jsr $c05f			jsr 	Random16
.bffc	a2 02		ldx #$02			ldx 	#2
.bffe	20 5f c0	jsr $c05f			jsr 	Random16
.c001	fa		plx				plx
.c002	80 1e		bra $c022			bra 	_URMakeRandom
.c004					_URSetSeed:
.c004	20 15 bd	jsr $bd15			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c007	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c00a	8d 2c 04	sta $042c			sta 	RandomSeed+0
.c00d	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c010	8d 2d 04	sta $042d			sta 	RandomSeed+1
.c013	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c016	8d 2e 04	sta $042e			sta 	RandomSeed+2
.c019	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c01c	0a		asl a				asl 	a
.c01d	49 db		eor #$db			eor 	#$DB
.c01f	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c022					_URMakeRandom:
.c022	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; check if seed is zero.
.c025	0d 2d 04	ora $042d			ora 	RandomSeed+1
.c028	0d 2e 04	ora $042e			ora 	RandomSeed+2
.c02b	0d 2f 04	ora $042f			ora 	RandomSeed+3
.c02e	d0 0a		bne $c03a			bne 	_URNotZero
.c030	a9 47		lda #$47			lda 	#$47
.c032	8d 2d 04	sta $042d			sta 	RandomSeed+1				; if it is, make it non zero.
.c035	a9 3d		lda #$3d			lda 	#$3D
.c037	8d 2f 04	sta $042f			sta 	RandomSeed+3
.c03a					_URNotZero:
.c03a	ad 2c 04	lda $042c			lda 	RandomSeed+0 				; copy seed into mantissa.
.c03d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c040	ad 2d 04	lda $042d			lda 	RandomSeed+1
.c043	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c046	ad 2e 04	lda $042e			lda 	RandomSeed+2
.c049	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c04c	ad 2f 04	lda $042f			lda 	RandomSeed+3
.c04f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c052	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c054	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c057	a9 80		lda #$80			lda 	#$80
.c059	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c05c	4c 4c bd	jmp $bd4c			jmp 	FPUNormalise
.c05f					Random16:
.c05f	5e 2d 04	lsr $042d,x			lsr 	RandomSeed+1,x				; shift seed right
.c062	7e 2c 04	ror $042c,x			ror 	RandomSeed,x
.c065	90 08		bcc $c06f			bcc 	_R16_NoXor
.c067	bd 2d 04	lda $042d,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c06a	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c06c	9d 2d 04	sta $042d,x			sta 	RandomSeed+1,x
.c06f					_R16_NoXor:
.c06f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c070					Unary_Int:
.c070	20 81 b0	jsr $b081			jsr 	EvaluateNumberX 			; get value
.c073	20 0c b7	jsr $b70c			jsr 	CheckNextRParen 			; check right bracket.
.c076	4c 74 bd	jmp $bd74			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c079					TIM_Error:
.c079	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.c07c	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c07e	80 02		bra $c082			bra 	TIM_ShowPrompt
.c080					TIM_NewCommand:
.c080	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c082					TIM_ShowPrompt:
.c082	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c085	20 f9 a0	jsr $a0f9			jsr 	IFT_ReadLine	 			; get character, go to next line
.c088	20 5b a0	jsr $a05b			jsr 	IFT_NewLine					; go to next line.
.c08b	86 10		stx $10				stx 	zTemp1 						; save line read address
.c08d	84 11		sty $11				sty 	zTemp1+1
.c08f	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c091	b1 10		lda ($10),y			lda 	(zTemp1),y
.c093	c9 3f		cmp #$3f			cmp 	#"?"
.c095	f0 04		beq $c09b			beq 	TIM_SkipFirst
.c097	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c099	d0 01		bne $c09c			bne 	TIM_NotDot
.c09b					TIM_SkipFirst:
.c09b	c8		iny				iny
.c09c					TIM_NotDot:
.c09c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c09e	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c0a0	f0 6e		beq $c110			beq 	TIM_ShowRegisters
.c0a2	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c0a4	f0 12		beq $c0b8			beq 	TIM_ShowMemory
.c0a6	c9 47		cmp #$47			cmp 	#"G"						; execute
.c0a8	f0 49		beq $c0f3			beq 	TIM_Execute
.c0aa	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c0ac	f0 07		beq $c0b5			beq 	TIM_GoLoadMemory
.c0ae	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c0b0	d0 c7		bne $c079			bne 	TIM_Error
.c0b2	4c 35 c2	jmp $c235			jmp 	TIM_UpdateRegisters
.c0b5					TIM_GoLoadMemory:
.c0b5	4c 60 c2	jmp $c260			jmp 	TIM_LoadMemory
.c0b8					TIM_ShowMemory:
.c0b8	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0bb	b0 bc		bcs $c079			bcs 	TIM_Error
.c0bd	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c0bf	85 12		sta $12				sta 	zTemp2
.c0c1	a5 15		lda $15				lda 	zTemp3+1
.c0c3	85 13		sta $13				sta 	zTemp2+1
.c0c5	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c0c8	90 08		bcc $c0d2			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c0ca	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c0cc	85 14		sta $14				sta 	zTemp3
.c0ce	a5 13		lda $13				lda 	zTemp2+1
.c0d0	85 15		sta $15				sta 	zTemp3+1
.c0d2					_TIMSM_Start:
.c0d2	20 86 c1	jsr $c186			jsr 	TIM_WriteLine 				; write one line of hex out
.c0d5	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c0d7	18		clc				clc
.c0d8	69 10		adc #$10			adc 	#16
.c0da	85 12		sta $12				sta 	zTemp2
.c0dc	90 02		bcc $c0e0			bcc 	_TIMSM_NoCarry
.c0de	e6 13		inc $13				inc 	zTemp2+1
.c0e0					_TIMSM_NoCarry:
.c0e0	20 e4 a1	jsr $a1e4			jsr 	IF_CheckBreak 				; check CTL+C
.c0e3	d0 0b		bne $c0f0			bne 	_TIMSM_Ends 				; if pressed break out.
.c0e5	38		sec				sec 								; check past the end address in zTemp3
.c0e6	a5 14		lda $14				lda 	zTemp3
.c0e8	e5 12		sbc $12				sbc 	zTemp2
.c0ea	a5 15		lda $15				lda 	zTemp3+1
.c0ec	e5 13		sbc $13				sbc 	zTemp2+1
.c0ee	10 e2		bpl $c0d2			bpl 	_TIMSM_Start
.c0f0					_TIMSM_Ends:
.c0f0	4c 80 c0	jmp $c080			jmp 	TIM_NewCommand
.c0f3					TIM_Execute:
.c0f3	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; get the execute address
.c0f6	b0 81		bcs $c079			bcs 	TIM_Error 					; not legitimate
.c0f8	ae 39 04	ldx $0439			ldx 	TIM_SP 						; set up SP
.c0fb	9a		txs				txs
.c0fc	ad 34 04	lda $0434			lda 	TIM_SR 						; Status for PLP
.c0ff	48		pha				pha
.c100	ad 35 04	lda $0435			lda 	TIM_A 						; restore AXYZ
.c103	ae 36 04	ldx $0436			ldx 	TIM_X
.c106	ac 37 04	ldy $0437			ldy 	TIM_Y
.c109	ab 38 04	ldz $0438			ldz 	TIM_Z
.c10c	28		plp				plp 								; and PS Byte.
.c10d	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c110					TIM_Start:
.c110					TIM_ShowRegisters:
.c110	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c113	8d 33 04	sta $0433			sta 	TIM_IRQ+1
.c116	ad ff ff	lda $ffff			lda 	$FFFF
.c119	8d 32 04	sta $0432			sta 	TIM_IRQ
.c11c	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c11e					_TIMSR_Text:
.c11e	bd 4a c1	lda $c14a,x			lda 	_TIMSR_Label,x
.c121	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c124	e8		inx				inx
.c125	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c127	d0 f5		bne $c11e			bne 	_TIMSR_Text
.c129	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c12b					_TIMSR_Skip:
.c12b	e8		inx				inx
.c12c					_TIMSR_LoopSpace:
.c12c	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c12e	b0 04		bcs $c134			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c130	8a		txa				txa
.c131	4a		lsr a				lsr 	a
.c132	b0 05		bcs $c139			bcs 	_TIMSR_NoSpace
.c134					_TIMSR_Space:
.c134	a9 20		lda #$20			lda 	#" "
.c136	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c139					_TIMSR_NoSpace:
.c139	bd 30 04	lda $0430,x			lda 	TIM_PC,x 					; output hex value.
.c13c	20 6d c1	jsr $c16d			jsr 	TIM_WriteHex
.c13f	e8		inx				inx
.c140	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c142	d0 e8		bne $c12c			bne 	_TimSR_LoopSpace
.c144	20 5b a0	jsr $a05b			jsr 	IFT_NewLine 				; new line
.c147	4c 80 c0	jmp $c080			jmp	 	TIM_NewCommand 				; new command.
.c14a					_TIMSR_Label:
>c14a	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c152	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c162	52
>c163	20 5a 52					.text 	" ZR"
>c166	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c16d					_TIMSR_LabelEnd:
.c16d					TIM_WriteHex:
.c16d	48		pha				pha 								; save A
.c16e	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c16f	4a		lsr a				lsr 	a
.c170	4a		lsr a				lsr 	a
.c171	4a		lsr a				lsr 	a
.c172	20 76 c1	jsr $c176			jsr 	_TIMWH_Nibble 				; print MSB
.c175	68		pla				pla 								; restore and print LSB
.c176					_TIMWH_Nibble:
.c176	48		pha				pha
.c177	29 0f		and #$0f			and 	#15 						; mask out
.c179	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c17b	90 02		bcc $c17f			bcc 	_TIMWHNoLetter
.c17d	69 06		adc #$06			adc 	#6
.c17f					_TIMWHNoLetter:
.c17f	69 30		adc #$30			adc 	#48
.c181	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.c184	68		pla				pla
.c185	60		rts				rts
.c186					TIM_WriteLine:
.c186	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c188	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c18b	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c18d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c190	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c192	20 6d c1	jsr $c16d			jsr 	TIM_WriteHex
.c195	a5 12		lda $12				lda 	zTemp2
.c197	20 6d c1	jsr $c16d			jsr 	TIM_WriteHex
.c19a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c19c					_TIMWL_Loop:
.c19c	a9 20		lda #$20			lda 	#" "
.c19e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c1a1	b1 12		lda ($12),y			lda 	(zTemp2),y
.c1a3	20 6d c1	jsr $c16d			jsr 	TIM_WriteHex
.c1a6	c8		iny				iny
.c1a7	c0 10		cpy #$10			cpy 	#16
.c1a9	d0 f1		bne $c19c			bne 	_TIMWL_Loop
.c1ab	4c 5b a0	jmp $a05b			jmp 	IFT_NewLine 				; new line and exit
.c1ae					TIM_GetHex:
.c1ae	c8		iny				iny
.c1af	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c1b1	c9 20		cmp #$20			cmp 	#32
.c1b3	f0 f9		beq $c1ae			beq 	TIM_GetHex
.c1b5	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c1b7	f0 f5		beq $c1ae			beq 	TIM_GetHex
.c1b9	20 e2 c1	jsr $c1e2			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c1bc	b0 23		bcs $c1e1			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c1be	a9 00		lda #$00			lda 	#0 							; zero result
.c1c0	85 14		sta $14				sta 	zTemp3
.c1c2	85 15		sta $15				sta 	zTemp3+1
.c1c4					_TIM_GHLoop:
.c1c4	20 e2 c1	jsr $c1e2			jsr 	TIM_GetHexCharacter 		; get next character
.c1c7	b0 17		bcs $c1e0			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c1c9	c8		iny				iny 								; skip over it.
.c1ca	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c1cc	26 15		rol $15				rol 	zTemp3+1
.c1ce	06 14		asl $14				asl 	zTemp3 						; now x 2
.c1d0	26 15		rol $15				rol 	zTemp3+1
.c1d2	06 14		asl $14				asl 	zTemp3						; now x 4
.c1d4	26 15		rol $15				rol 	zTemp3+1
.c1d6	06 14		asl $14				asl 	zTemp3 						; now x 8
.c1d8	26 15		rol $15				rol 	zTemp3+1
.c1da	05 14		ora $14				ora 	zTemp3 						; OR result in
.c1dc	85 14		sta $14				sta 	zTemp3
.c1de	80 e4		bra $c1c4			bra 	_TIM_GHLoop 				; loop round again.
.c1e0					_TIMGH_Okay:
.c1e0	18		clc				clc
.c1e1					_TIMGH_Exit:
.c1e1	60		rts				rts
.c1e2					TIM_GetHexCharacter:
.c1e2	b1 10		lda ($10),y			lda 	(zTemp1),y
.c1e4	38		sec				sec
.c1e5	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c1e7	90 0e		bcc $c1f7			bcc 	_TIM_GHCFail
.c1e9	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c1eb	90 0b		bcc $c1f8			bcc 	_TIM_GHCExit
.c1ed	c9 11		cmp #$11			cmp 	#65-48						; < A
.c1ef	90 06		bcc $c1f7			bcc		_TIM_GHCFail
.c1f1	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c1f3	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c1f5	90 01		bcc $c1f8			bcc		_TIM_GHCExit
.c1f7					_TIM_GHCFail:
.c1f7	38		sec				sec
.c1f8					_TIM_GHCExit:
.c1f8	60		rts				rts
.c1f9					TIM_BreakVector:
.c1f9	da		phx				phx									; save X/A on stack
.c1fa	48		pha				pha
.c1fb	ba		tsx				tsx 								; X points to S
.c1fc	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c1ff	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c201	d0 03		bne $c206			bne 	_TIMBreak					; if set, it's BRK
.c203	68		pla				pla 								; abandon routine.
.c204	fa		plx				plx
.c205	40		rti				rti
.c206					_TIMBreak:
.c206	68		pla				pla 								; save A X Y and maybe Z
.c207	8d 35 04	sta $0435			sta 	TIM_A
.c20a	fa		plx				plx
.c20b	8e 36 04	stx $0436			stx 	TIM_X
.c20e	8c 37 04	sty $0437			sty 	TIM_Y
.c211	9c 38 04	stz $0438			stz 	TIM_Z
.c214	68		pla				pla 								; get Status Register
.c215	8d 34 04	sta $0434			sta 	TIM_SR
.c218	68		pla				pla
.c219	8d 31 04	sta $0431			sta 	TIM_PC+1 					; save calling address
.c21c	68		pla				pla
.c21d	8d 30 04	sta $0430			sta 	TIM_PC 						; high byte
.c220	ad 31 04	lda $0431			lda 	TIM_PC+1 					; dec PC to point right.
.c223	d0 03		bne $c228			bne 	_TIMDecrement 				; brk bumps it.
.c225	ce 30 04	dec $0430			dec 	TIM_PC
.c228					_TIMDecrement:
.c228	ce 31 04	dec $0431			dec 	TIM_PC+1
.c22b	ba		tsx				tsx 								; and copy SP
.c22c	8e 39 04	stx $0439			stx 	TIM_SP
.c22f	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c231	9a		txs				txs
.c232	4c 10 c1	jmp $c110			jmp 	TIM_Start 					; and start up TIM monitor.
.c235					TIM_UpdateRegisters:
.c235	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; PC
.c238	b0 23		bcs $c25d			bcs 	_TIMURFail
.c23a	a5 14		lda $14				lda 	zTemp3
.c23c	8d 31 04	sta $0431			sta 	Tim_PC+1
.c23f	a5 15		lda $15				lda 	zTemp3+1
.c241	8d 30 04	sta $0430			sta 	Tim_PC
.c244	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; ignore IRQ
.c247	b0 14		bcs $c25d			bcs 	_TIMURFail
.c249	a2 00		ldx #$00			ldx 	#0
.c24b					_TIM_URLoop:
.c24b	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; registers
.c24e	b0 0d		bcs $c25d			bcs 	_TIMURFail
.c250	a5 14		lda $14				lda 	zTemp3
.c252	9d 34 04	sta $0434,x			sta 	Tim_SR,x
.c255	e8		inx				inx
.c256	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c258	d0 f1		bne $c24b			bne 	_TIM_URLoop
.c25a	4c 80 c0	jmp $c080			jmp 	TIM_NewCommand
.c25d					_TIMURFail:
.c25d	4c 79 c0	jmp $c079			jmp 	TIM_Error
.c260					TIM_LoadMemory:
.c260	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; target address => zTemp2
.c263	a5 14		lda $14				lda 	zTemp3
.c265	85 12		sta $12				sta 	zTemp2
.c267	a5 15		lda $15				lda 	zTemp3+1
.c269	85 13		sta $13				sta 	zTemp2+1
.c26b					_TIM_LMLoop:
.c26b	20 ae c1	jsr $c1ae			jsr 	TIM_GetHex 					; next byte ?
.c26e	b0 0e		bcs $c27e			bcs 	_TIMLMDone 					; no more
.c270	a2 00		ldx #$00			ldx 	#0							; write out.
.c272	a5 14		lda $14				lda 	zTemp3
.c274	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c276	e6 12		inc $12				inc 	zTemp2 						; bump address
.c278	d0 f1		bne $c26b			bne 	_TIM_LMLoop
.c27a	e6 13		inc $13				inc 	zTemp2+1
.c27c	80 ed		bra $c26b			bra 	_TIM_LMLoop
.c27e					_TIMLMDone:
.c27e	4c 80 c0	jmp $c080			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c281	80 fe		bra $c281	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	f9 c1					.word TIM_BreakVector

;******  End of listing
