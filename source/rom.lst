
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Wed Sep  4 13:37:39 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	0c 0a 00 cf 01 b8 40 be			.byte	$0c,$0a,$00,$cf,$01,$b8,$40,$be
>8008	84 fe 02 00 0e 14 00 d6			.byte	$84,$fe,$02,$00,$0e,$14,$00,$d6
>8010	01 b8 40 be bf fe 04 48			.byte	$01,$b8,$40,$be,$bf,$fe,$04,$48
>8018	69 00 05 1e 00 c4 00 00			.byte	$69,$00,$05,$1e,$00,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4a a2	jsr $a24a			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c 2e b1	jmp $b12e		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b1 a1	jsr $a1b1			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c0 a1	jsr $a1c0			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b1 a1	jsr $a1b1			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 20		beq $a065			beq 	IFT_NewLine
.a045	c9 08		cmp #$08			cmp 	#8
.a047	f0 16		beq $a05f			beq 	_IFT_Left
.a049	48		pha				pha
.a04a	20 7d a0	jsr $a07d			jsr 	IFT_UpperCase 				; make upper case
.a04d	20 e0 a1	jsr $a1e0			jsr 	IF_Write 					; write out.
.a050	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a053	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a056	c9 50		cmp #$50			cmp 	#IF_Width
.a058	d0 03		bne $a05d			bne 	_IFT_PCNotEOL
.a05a	20 65 a0	jsr $a065			jsr 	IFT_NewLine 				; if so do new line.
.a05d					_IFT_PCNotEOL:
.a05d	68		pla				pla
.a05e	60		rts				rts
.a05f					_IFT_Left:
.a05f	48		pha				pha
.a060	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a063	68		pla				pla
.a064	60		rts				rts
.a065					IFT_NewLine:
.a065	48		pha				pha
.a066	20 c0 a1	jsr $a1c0			jsr 	IF_NewLine 					; new line on actual screen.
.a069	a9 00		lda #$00			lda 	#0 							; reset x position
.a06b	8d 00 05	sta $0500			sta 	IFT_XCursor
.a06e	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a071	ad 01 05	lda $0501			lda 	IFT_YCursor
.a074	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a076	d0 03		bne $a07b			bne 	_IFT_NL_NotEOS
.a078	20 88 a0	jsr $a088			jsr 	IFT_Scroll 					; scroll screen up.
.a07b					_IFT_NL_NotEOS:
.a07b	68		pla				pla
.a07c	60		rts				rts
.a07d					IFT_UpperCase:
.a07d	c9 61		cmp #$61			cmp 	#"a"
.a07f	90 06		bcc $a087			bcc 	_IFT_UCExit
.a081	c9 7b		cmp #$7b			cmp 	#"z"+1
.a083	b0 02		bcs $a087			bcs 	_IFT_UCExit
.a085	49 20		eor #$20			eor 	#$20
.a087					_IFT_UCExit:
.a087	60		rts				rts
.a088					IFT_Scroll:
.a088	48		pha				pha 								; save AXY
.a089	da		phx				phx
.a08a	5a		phy				phy
.a08b	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a08d					_IFT_SLoop:
.a08d	20 ad a0	jsr $a0ad			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a090	e8		inx				inx
.a091	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a093	d0 f8		bne $a08d			bne 	_IFT_SLoop
.a095	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a097	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a09a	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09c					_IFT_SBlank:
.a09c	a9 20		lda #$20			lda 	#32
.a09e	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a0a1	ca		dex				dex
.a0a2	d0 f8		bne $a09c			bne 	_IFT_SBlank
.a0a4	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a6	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a0a9	7a		ply				ply
.a0aa	fa		plx				plx
.a0ab	68		pla				pla
.a0ac	60		rts				rts
.a0ad					_IFT_ScrollLine:
.a0ad	da		phx				phx
.a0ae	da		phx				phx
.a0af	8a		txa				txa 								; copy line into buffer.
.a0b0	1a		inc a				inc 	a 							; next line down.
.a0b1	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a0b4	a2 00		ldx #$00			ldx 	#0
.a0b6					_IFTScrollCopy1:
.a0b6	20 d2 a1	jsr $a1d2			jsr 	IF_Read
.a0b9	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bc	e8		inx				inx
.a0bd	e0 50		cpx #$50			cpx 	#IF_Width
.a0bf	d0 f5		bne $a0b6			bne 	_IFTScrollCopy1
.a0c1	68		pla				pla
.a0c2	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a0c5	a2 00		ldx #$00			ldx 	#0
.a0c7					_IFTScrollCopy2:
.a0c7	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0ca	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a0cd	e8		inx				inx
.a0ce	e0 50		cpx #$50			cpx 	#IF_Width
.a0d0	d0 f5		bne $a0c7			bne 	_IFTScrollCopy2
.a0d2	fa		plx				plx
.a0d3	60		rts				rts
.a0d4					IFT_SetYPos:
.a0d4	48		pha				pha
.a0d5	da		phx				phx
.a0d6	aa		tax				tax
.a0d7	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0da	e0 00		cpx #$00			cpx 	#0
.a0dc	f0 09		beq $a0e7			beq 	_IFT_MOAExit
.a0de					_IFT_MOALoop:
.a0de	20 c0 a1	jsr $a1c0			jsr 	IF_NewLine
.a0e1	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e4	ca		dex				dex
.a0e5	d0 f7		bne $a0de			bne		_IFT_MOALoop
.a0e7					_IFT_MOAExit:
.a0e7	fa		plx				plx
.a0e8	68		pla				pla
.a0e9	60		rts				rts
.a0ea					IFT_GetKeyCursor:
.a0ea	20 f2 a0	jsr $a0f2			jsr 	_IFT_FlipCursor 			; reverse current
.a0ed					_IFT_GKCWait:
.a0ed	20 03 a2	jsr $a203			jsr 	IF_GetKey 					; get key
.a0f0	f0 fb		beq $a0ed			beq 	_IFT_GKCWait
.a0f2					_IFT_FlipCursor:
.a0f2	48		pha				pha 								; save
.a0f3	20 d2 a1	jsr $a1d2			jsr 	IF_Read 					; read
.a0f6	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a0f9	49 80		eor #$80			eor 	#$80 						; reverse
.a0fb	20 e0 a1	jsr $a1e0			jsr 	IF_Write 					; write
.a0fe	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a101	68		pla				pla
.a102	60		rts				rts
.a103					IFT_ReadLine:
.a103	48		pha				pha
.a104					_IFT_RLLoop:
.a104	20 ea a0	jsr $a0ea			jsr 	IFT_GetKeyCursor 			; get keystroke
.a107	c9 0d		cmp #$0d			cmp 	#13							; return
.a109	f0 7d		beq $a188			beq 	_IFT_RLExit
.a10b	c9 20		cmp #$20			cmp 	#32 						; control character
.a10d	90 05		bcc $a114			bcc 	_IFT_Control
.a10f	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a112	80 f0		bra $a104			bra 	_IFT_RLLoop
.a114					_IFT_Control:
.a114	c9 01		cmp #$01			cmp 	#"A"-64
.a116	f0 26		beq $a13e			beq 	_IFT_Left
.a118	c9 04		cmp #$04			cmp 	#"D"-64
.a11a	f0 2e		beq $a14a			beq 	_IFT_Right
.a11c	c9 17		cmp #$17			cmp 	#"W"-64
.a11e	f0 36		beq $a156			beq 	_IFT_Up
.a120	c9 13		cmp #$13			cmp 	#"S"-64
.a122	f0 3e		beq $a162			beq 	_IFT_Down
.a124	c9 08		cmp #$08			cmp 	#"H"-64
.a126	f0 09		beq $a131			beq 	_IFT_Backspace
.a128	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12a	d0 d8		bne $a104			bne 	_IFT_RLLoop
.a12c	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a12f	80 d3		bra $a104			bra 	_IFT_RLLoop
.a131					_IFT_Backspace:
.a131	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a134	f0 ce		beq $a104			beq 	_IFT_RLLoop
.a136	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a139	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13b	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a13e					_IFT_Left:
.a13e	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a141	10 29		bpl $a16c			bpl 	_IFT_Reposition
.a143	a9 4f		lda #$4f			lda 	#IF_Width-1
.a145					_IFT_SetX:
.a145	8d 00 05	sta $0500			sta 	IFT_XCursor
.a148	80 22		bra $a16c			bra 	_IFT_Reposition
.a14a					_IFT_Right:
.a14a	ee 00 05	inc $0500			inc 	IFT_XCursor
.a14d	ad 00 05	lda $0500			lda 	IFT_XCursor
.a150	49 50		eor #$50			eor 	#IF_Width
.a152	f0 f1		beq $a145			beq 	_IFT_SetX
.a154	80 16		bra $a16c			bra 	_IFT_Reposition
.a156					_IFT_Up:
.a156	ce 01 05	dec $0501			dec 	IFT_YCursor
.a159	10 11		bpl $a16c			bpl 	_IFT_Reposition
.a15b	a9 18		lda #$18			lda 	#IF_Height-1
.a15d					_IFT_SetY:
.a15d	8d 01 05	sta $0501			sta 	IFT_YCursor
.a160	80 0a		bra $a16c			bra 	_IFT_Reposition
.a162					_IFT_Down:
.a162	ee 01 05	inc $0501			inc 	IFT_YCursor
.a165	ad 01 05	lda $0501			lda 	IFT_YCursor
.a168	49 19		eor #$19			eor 	#IF_Height
.a16a	f0 f1		beq $a15d			beq 	_IFT_SetY
.a16c					_IFT_Reposition:
.a16c	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a16f	48		pha				pha
.a170	ad 01 05	lda $0501			lda 	IFT_YCursor
.a173	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a176	68		pla				pla
.a177	aa		tax				tax
.a178	e0 00		cpx #$00			cpx 	#0
.a17a	f0 88		beq $a104			beq 	_IFT_RLLoop
.a17c					_IFT_MoveRight:
.a17c	20 d2 a1	jsr $a1d2			jsr 	IF_Read
.a17f	ee 00 05	inc $0500			inc 	IFT_XCursor
.a182	ca		dex				dex
.a183	d0 f7		bne $a17c			bne 	_IFT_MoveRight
.a185	4c 04 a1	jmp $a104			jmp 	_IFT_RLLoop
.a188					_IFT_RLExit:
.a188	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18b	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a18e	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a190					_IFT_RLRead:
.a190	20 d2 a1	jsr $a1d2			jsr 	IF_Read
.a193	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a196	e8		inx				inx
.a197	e0 50		cpx #$50			cpx 	#IF_Width
.a199	d0 f5		bne $a190			bne 	_IFT_RLRead
.a19b					_IFT_RL_Trim:
.a19b	ca		dex				dex 	 							; previous char
.a19c	30 07		bmi $a1a5			bmi 	_IFT_Found 					; gone too far
.a19e	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a1	c9 20		cmp #$20			cmp 	#" "
.a1a3	f0 f6		beq $a19b			beq 	_IFT_RL_Trim
.a1a5					_IFT_Found:
.a1a5	e8		inx				inx 								; forward to non-space
.a1a6	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1a8	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ab	68		pla				pla
.a1ac	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1ae	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b1					IF_Home:
.a1b1	48		pha				pha 								; reset cursor position
.a1b2	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b4	85 04		sta $04				sta 	IF_Pos
.a1b6	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1b8	85 05		sta $05				sta 	IF_Pos+1
.a1ba	a9 00		lda #$00			lda 	#0
.a1bc	85 06		sta $06				sta 	IF_XPos
.a1be	68		pla				pla
.a1bf	60		rts				rts
.a1c0					IF_NewLine:
.a1c0	48		pha				pha
.a1c1	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c3	85 06		sta $06				sta 	IF_XPos
.a1c5	18		clc				clc 								; down one line
.a1c6	a5 04		lda $04				lda 	IF_Pos
.a1c8	69 50		adc #$50			adc 	#80
.a1ca	85 04		sta $04				sta 	IF_Pos
.a1cc	90 02		bcc $a1d0			bcc 	_IF_NoCarry 				; carry through.
.a1ce	e6 05		inc $05				inc 	IF_Pos+1
.a1d0					_IF_NoCarry:
.a1d0	68		pla				pla
.a1d1	60		rts				rts
.a1d2					IF_Read:
.a1d2	5a		phy				phy 								; save current Y
.a1d3	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d5	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1d7	49 20		eor #$20			eor 	#$20
.a1d9	18		clc				clc
.a1da	69 20		adc #$20			adc 	#$20
.a1dc	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1de	7a		ply				ply									; restore Y
.a1df	60		rts				rts
.a1e0					IF_Write:
.a1e0	5a		phy				phy 								; save current Y
.a1e1	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e3	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e5	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1e7	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e9	7a		ply				ply									; restore Y
.a1ea	60		rts				rts
.a1eb					IF_LeftOne:
.a1eb	c6 06		dec $06				dec 	IF_XPos
.a1ed	60		rts				rts
.a1ee					IF_CheckBreak:
.a1ee	db		phz				phz
.a1ef	20 37 a2	jsr $a237			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f2	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f4	ea		nop				nop 								; read modifiers.
.a1f5	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1f7	fb		plz				plz 								; restore Z
.a1f8	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fa	c9 05		cmp #$05			cmp 	#5
.a1fc	f0 02		beq $a200			beq 	_IF_CBExit
.a1fe	a9 00		lda #$00			lda 	#0
.a200					_IF_CBExit:
.a200	c9 00		cmp #$00			cmp 	#0
.a202	60		rts				rts
.a203					IF_GetKey:
.a203	db		phz				phz
.a204	20 37 a2	jsr $a237			jsr 	IF_SetupKeyAddress
.a207	ea		nop				nop 								; read keyboard
.a208	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20a	c9 14		cmp #$14			cmp 	#20
.a20c	d0 02		bne $a210			bne 	_KMNo
.a20e	a9 08		lda #$08			lda 	#"H"-64
.a210					_KMNo:
.a210	c9 91		cmp #$91			cmp 	#145
.a212	d0 02		bne $a216			bne 	_KMNo
.a214	a9 17		lda #$17			lda 	#"W"-64
.a216					_KMNo:
.a216	c9 11		cmp #$11			cmp 	#17
.a218	d0 02		bne $a21c			bne 	_KMNo
.a21a	a9 13		lda #$13			lda 	#"S"-64
.a21c					_KMNo:
.a21c	c9 9d		cmp #$9d			cmp 	#157
.a21e	d0 02		bne $a222			bne 	_KMNo
.a220	a9 01		lda #$01			lda 	#"A"-64
.a222					_KMNo:
.a222	c9 1d		cmp #$1d			cmp 	#29
.a224	d0 02		bne $a228			bne 	_KMNo
.a226	a9 04		lda #$04			lda 	#"D"-64
.a228					_KMNo:
.a228	c9 00		cmp #$00			cmp 	#0
.a22a	f0 07		beq $a233			beq 	_IFGKEmpty
.a22c	48		pha				pha
.a22d	a9 00		lda #$00			lda 	#0
.a22f	ea		nop				nop
.a230	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a232	68		pla				pla
.a233					_IFGKEmpty:
.a233	fb		plz				plz
.a234	c9 00		cmp #$00			cmp 	#0 							; set Z
.a236	60		rts				rts
.a237					IF_SetupKeyAddress:
.a237	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a239	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23b	a9 fd		lda #$fd			lda 	#$FD
.a23d	85 0a		sta $0a				sta 	IF_FarPtr+2
.a23f	a9 36		lda #$36			lda 	#$36
.a241	85 09		sta $09				sta 	IF_FarPtr+1
.a243	a9 10		lda #$10			lda 	#$10
.a245	85 08		sta $08				sta 	IF_FarPtr+0
.a247	a3 00		ldz #$00			ldz 	#0
.a249	60		rts				rts
.a24a					IF_Reset:
.a24a	48		pha				pha 								; save registers
.a24b	da		phx				phx
.a24c	5a		phy				phy
.a24d	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a24f	85 0b		sta $0b				sta 	IF_FarPtr+3
.a251	a9 fd		lda #$fd			lda 	#$FD
.a253	85 0a		sta $0a				sta 	IF_FarPtr+2
.a255	a9 30		lda #$30			lda 	#$30
.a257	85 09		sta $09				sta 	IF_FarPtr+1
.a259	a9 00		lda #$00			lda 	#$00
.a25b	85 08		sta $08				sta 	IF_FarPtr+0
.a25d	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a25f	a9 47		lda #$47			lda 	#$47
.a261	ea		nop				nop
.a262	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a264	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a266	a9 53		lda #$53			lda 	#$53
.a268	ea		nop				nop
.a269	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26b	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a26d	a9 40		lda #$40			lda 	#$40
.a26f	ea		nop				nop
.a270	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a272	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a274	a9 c0		lda #$c0			lda 	#$80+$40
.a276	ea		nop				nop
.a277	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a279	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27b	a9 00		lda #$00			lda 	#0
.a27d	ea		nop				nop
.a27e	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a280	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a282	a9 00		lda #$00			lda 	#0
.a284	ea		nop				nop
.a285	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a287	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a289	a9 40		lda #$40			lda 	#$40
.a28b	ea		nop				nop
.a28c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28e	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a290	a9 ff		lda #$ff			lda 	#$FF
.a292	ea		nop				nop
.a293	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a295	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a297	a9 ff		lda #$ff			lda 	#$FF
.a299	ea		nop				nop
.a29a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29c	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a29e	a9 cc		lda #$cc			lda 	#$CC
.a2a0	ea		nop				nop
.a2a1	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a3	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a5	a9 42		lda #$42			lda 	#$42
.a2a7	ea		nop				nop
.a2a8	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2aa	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2ac	a9 1b		lda #$1b			lda 	#$1B
.a2ae	ea		nop				nop
.a2af	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b1	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b3	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b5	a9 01		lda #$01			lda 	#$01
.a2b7	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2b9	a9 f8		lda #$f8			lda 	#$F8
.a2bb	85 09		sta $09				sta 	IF_FarPtr+1
.a2bd	a9 00		lda #$00			lda 	#$00
.a2bf	85 08		sta $08				sta 	IF_FarPtr+0
.a2c1	a3 00		ldz #$00			ldz 	#0
.a2c3					_EXTClearColorRam:
.a2c3	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c5	ea		nop				nop
.a2c6	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2c8	3b		dez				dez
.a2c9	d0 f8		bne $a2c3			bne 	_EXTClearColorRam
.a2cb	e6 09		inc $09				inc 	IF_FarPtr+1
.a2cd	d0 f4		bne $a2c3			bne 	_EXTClearColorRam
.a2cf	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d1					_EXTCopyCBMFont:
.a2d1	bd 12 a3	lda $a312,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d4	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2d7	49 ff		eor #$ff			eor 	#$FF
.a2d9	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2dc	bd 12 a4	lda $a412,x			lda 	IF_CBMFont+$100,x
.a2df	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e2	49 ff		eor #$ff			eor 	#$FF
.a2e4	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2e7	bd 12 a5	lda $a512,x			lda 	IF_CBMFont+$200,x
.a2ea	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2ed	49 ff		eor #$ff			eor 	#$FF
.a2ef	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f2	bd 12 a6	lda $a612,x			lda 	IF_CBMFont+$300,x
.a2f5	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2f8	49 ff		eor #$ff			eor 	#$FF
.a2fa	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a2fd	ca		dex				dex
.a2fe	d0 d1		bne $a2d1			bne 	_EXTCopyCBMFont
.a300	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a302	85 01		sta $01				sta 	$01
.a304	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a306	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a308	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30a	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30c	5c		map				map
.a30d	ea		nop				eom
.a30e	7a		ply				ply 								; restore and exit.
.a30f	fa		plx				plx
.a310	68		pla				pla
.a311	60		rts				rts
.a312					IF_CBMFont:
>a312	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31a	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32a	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33a	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34a	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35a	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36a	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37a	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38a	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39a	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3aa	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3ba	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3ca	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3da	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ea	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fa	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40a	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41a	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42a	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43a	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44a	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45a	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46a	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47a	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48a	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49a	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4aa	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4ba	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4ca	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4da	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ea	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fa	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50a	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51a	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52a	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53a	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54a	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55a	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56a	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57a	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58a	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59a	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5aa	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5ba	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5ca	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5da	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ea	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fa	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60a	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61a	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62a	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63a	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64a	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65a	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66a	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67a	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68a	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69a	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6aa	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6ba	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6ca	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6da	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ea	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fa	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70a	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71a	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72a	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73a	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74a	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75a	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76a	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77a	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78a	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79a	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7aa	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7ba	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7ca	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7da	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ea	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fa	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80a	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81a	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82a	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83a	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84a	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85a	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86a	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87a	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88a	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89a	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8aa	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8ba	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8ca	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8da	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ea	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fa	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90a	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91a	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92a	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93a	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94a	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95a	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96a	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97a	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98a	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99a	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9aa	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9ba	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9ca	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9da	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ea	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fa	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0a	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1a	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2a	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3a	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4a	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5a	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6a	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7a	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8a	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9a	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaaa	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aaba	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aaca	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aada	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaea	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafa	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0a	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab12					TIM_Error:
.ab12	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab15	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab17	80 02		bra $ab1b			bra 	TIM_ShowPrompt
.ab19					TIM_NewCommand:
.ab19	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1b					TIM_ShowPrompt:
.ab1b	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab1e	20 03 a1	jsr $a103			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab21	20 65 a0	jsr $a065			jsr 	IFT_NewLine					; go to next line.
.ab24	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab26	84 11		sty $11				sty 	zTemp1+1
.ab28	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2a	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2c	c9 3f		cmp #$3f			cmp 	#"?"
.ab2e	f0 04		beq $ab34			beq 	TIM_SkipFirst
.ab30	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab32	d0 01		bne $ab35			bne 	TIM_NotDot
.ab34					TIM_SkipFirst:
.ab34	c8		iny				iny
.ab35					TIM_NotDot:
.ab35	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab37	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab39	f0 6e		beq $aba9			beq 	TIM_ShowRegisters
.ab3b	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab3d	f0 12		beq $ab51			beq 	TIM_ShowMemory
.ab3f	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab41	f0 49		beq $ab8c			beq 	TIM_Execute
.ab43	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab45	f0 07		beq $ab4e			beq 	TIM_GoLoadMemory
.ab47	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab49	d0 c7		bne $ab12			bne 	TIM_Error
.ab4b	4c ce ac	jmp $acce			jmp 	TIM_UpdateRegisters
.ab4e					TIM_GoLoadMemory:
.ab4e	4c f9 ac	jmp $acf9			jmp 	TIM_LoadMemory
.ab51					TIM_ShowMemory:
.ab51	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab54	b0 bc		bcs $ab12			bcs 	TIM_Error
.ab56	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab58	85 12		sta $12				sta 	zTemp2
.ab5a	a5 15		lda $15				lda 	zTemp3+1
.ab5c	85 13		sta $13				sta 	zTemp2+1
.ab5e	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab61	90 08		bcc $ab6b			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab63	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab65	85 14		sta $14				sta 	zTemp3
.ab67	a5 13		lda $13				lda 	zTemp2+1
.ab69	85 15		sta $15				sta 	zTemp3+1
.ab6b					_TIMSM_Start:
.ab6b	20 1f ac	jsr $ac1f			jsr 	TIM_WriteLine 				; write one line of hex out
.ab6e	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab70	18		clc				clc
.ab71	69 10		adc #$10			adc 	#16
.ab73	85 12		sta $12				sta 	zTemp2
.ab75	90 02		bcc $ab79			bcc 	_TIMSM_NoCarry
.ab77	e6 13		inc $13				inc 	zTemp2+1
.ab79					_TIMSM_NoCarry:
.ab79	20 ee a1	jsr $a1ee			jsr 	IF_CheckBreak 				; check CTL+C
.ab7c	d0 0b		bne $ab89			bne 	_TIMSM_Ends 				; if pressed break out.
.ab7e	38		sec				sec 								; check past the end address in zTemp3
.ab7f	a5 14		lda $14				lda 	zTemp3
.ab81	e5 12		sbc $12				sbc 	zTemp2
.ab83	a5 15		lda $15				lda 	zTemp3+1
.ab85	e5 13		sbc $13				sbc 	zTemp2+1
.ab87	10 e2		bpl $ab6b			bpl 	_TIMSM_Start
.ab89					_TIMSM_Ends:
.ab89	4c 19 ab	jmp $ab19			jmp 	TIM_NewCommand
.ab8c					TIM_Execute:
.ab8c	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; get the execute address
.ab8f	b0 81		bcs $ab12			bcs 	TIM_Error 					; not legitimate
.ab91	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.ab94	9a		txs				txs
.ab95	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.ab98	48		pha				pha
.ab99	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.ab9c	ae ca 03	ldx $03ca			ldx 	TIM_X
.ab9f	ac cb 03	ldy $03cb			ldy 	TIM_Y
.aba2	ab cc 03	ldz $03cc			ldz 	TIM_Z
.aba5	28		plp				plp 								; and PS Byte.
.aba6	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.aba9					TIM_Start:
.aba9					TIM_ShowRegisters:
.aba9	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abac	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.abaf	ad ff ff	lda $ffff			lda 	$FFFF
.abb2	8d c6 03	sta $03c6			sta 	TIM_IRQ
.abb5	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abb7					_TIMSR_Text:
.abb7	bd e3 ab	lda $abe3,x			lda 	_TIMSR_Label,x
.abba	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abbd	e8		inx				inx
.abbe	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc0	d0 f5		bne $abb7			bne 	_TIMSR_Text
.abc2	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc4					_TIMSR_Skip:
.abc4	e8		inx				inx
.abc5					_TIMSR_LoopSpace:
.abc5	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abc7	b0 04		bcs $abcd			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abc9	8a		txa				txa
.abca	4a		lsr a				lsr 	a
.abcb	b0 05		bcs $abd2			bcs 	_TIMSR_NoSpace
.abcd					_TIMSR_Space:
.abcd	a9 20		lda #$20			lda 	#" "
.abcf	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd2					_TIMSR_NoSpace:
.abd2	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.abd5	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.abd8	e8		inx				inx
.abd9	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abdb	d0 e8		bne $abc5			bne 	_TimSR_LoopSpace
.abdd	20 65 a0	jsr $a065			jsr 	IFT_NewLine 				; new line
.abe0	4c 19 ab	jmp $ab19			jmp	 	TIM_NewCommand 				; new command.
.abe3					_TIMSR_Label:
>abe3	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abeb	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfb	52
>abfc	20 5a 52					.text 	" ZR"
>abff	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac06					_TIMSR_LabelEnd:
.ac06					TIM_WriteHex:
.ac06	48		pha				pha 								; save A
.ac07	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac08	4a		lsr a				lsr 	a
.ac09	4a		lsr a				lsr 	a
.ac0a	4a		lsr a				lsr 	a
.ac0b	20 0f ac	jsr $ac0f			jsr 	_TIMWH_Nibble 				; print MSB
.ac0e	68		pla				pla 								; restore and print LSB
.ac0f					_TIMWH_Nibble:
.ac0f	48		pha				pha
.ac10	29 0f		and #$0f			and 	#15 						; mask out
.ac12	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac14	90 02		bcc $ac18			bcc 	_TIMWHNoLetter
.ac16	69 06		adc #$06			adc 	#6
.ac18					_TIMWHNoLetter:
.ac18	69 30		adc #$30			adc 	#48
.ac1a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac1d	68		pla				pla
.ac1e	60		rts				rts
.ac1f					TIM_WriteLine:
.ac1f	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac21	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac24	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac26	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac29	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2b	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.ac2e	a5 12		lda $12				lda 	zTemp2
.ac30	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.ac33	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac35					_TIMWL_Loop:
.ac35	a9 20		lda #$20			lda 	#" "
.ac37	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3a	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3c	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.ac3f	c8		iny				iny
.ac40	c0 10		cpy #$10			cpy 	#16
.ac42	d0 f1		bne $ac35			bne 	_TIMWL_Loop
.ac44	4c 65 a0	jmp $a065			jmp 	IFT_NewLine 				; new line and exit
.ac47					TIM_GetHex:
.ac47	c8		iny				iny
.ac48	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4a	c9 20		cmp #$20			cmp 	#32
.ac4c	f0 f9		beq $ac47			beq 	TIM_GetHex
.ac4e	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac50	f0 f5		beq $ac47			beq 	TIM_GetHex
.ac52	20 7b ac	jsr $ac7b			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac55	b0 23		bcs $ac7a			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac57	a9 00		lda #$00			lda 	#0 							; zero result
.ac59	85 14		sta $14				sta 	zTemp3
.ac5b	85 15		sta $15				sta 	zTemp3+1
.ac5d					_TIM_GHLoop:
.ac5d	20 7b ac	jsr $ac7b			jsr 	TIM_GetHexCharacter 		; get next character
.ac60	b0 17		bcs $ac79			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac62	c8		iny				iny 								; skip over it.
.ac63	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac65	26 15		rol $15				rol 	zTemp3+1
.ac67	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac69	26 15		rol $15				rol 	zTemp3+1
.ac6b	06 14		asl $14				asl 	zTemp3						; now x 4
.ac6d	26 15		rol $15				rol 	zTemp3+1
.ac6f	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac71	26 15		rol $15				rol 	zTemp3+1
.ac73	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac75	85 14		sta $14				sta 	zTemp3
.ac77	80 e4		bra $ac5d			bra 	_TIM_GHLoop 				; loop round again.
.ac79					_TIMGH_Okay:
.ac79	18		clc				clc
.ac7a					_TIMGH_Exit:
.ac7a	60		rts				rts
.ac7b					TIM_GetHexCharacter:
.ac7b	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac7d	38		sec				sec
.ac7e	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac80	90 0e		bcc $ac90			bcc 	_TIM_GHCFail
.ac82	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac84	90 0b		bcc $ac91			bcc 	_TIM_GHCExit
.ac86	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac88	90 06		bcc $ac90			bcc		_TIM_GHCFail
.ac8a	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8c	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac8e	90 01		bcc $ac91			bcc		_TIM_GHCExit
.ac90					_TIM_GHCFail:
.ac90	38		sec				sec
.ac91					_TIM_GHCExit:
.ac91	60		rts				rts
.ac92					TIM_BreakVector:
.ac92	da		phx				phx									; save X/A on stack
.ac93	48		pha				pha
.ac94	ba		tsx				tsx 								; X points to S
.ac95	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac98	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9a	d0 03		bne $ac9f			bne 	_TIMBreak					; if set, it's BRK
.ac9c	68		pla				pla 								; abandon routine.
.ac9d	fa		plx				plx
.ac9e	40		rti				rti
.ac9f					_TIMBreak:
.ac9f	68		pla				pla 								; save A X Y and maybe Z
.aca0	8d c9 03	sta $03c9			sta 	TIM_A
.aca3	fa		plx				plx
.aca4	8e ca 03	stx $03ca			stx 	TIM_X
.aca7	8c cb 03	sty $03cb			sty 	TIM_Y
.acaa	9c cc 03	stz $03cc			stz 	TIM_Z
.acad	68		pla				pla 								; get Status Register
.acae	8d c8 03	sta $03c8			sta 	TIM_SR
.acb1	68		pla				pla
.acb2	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.acb5	68		pla				pla
.acb6	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.acb9	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.acbc	d0 03		bne $acc1			bne 	_TIMDecrement 				; brk bumps it.
.acbe	ce c4 03	dec $03c4			dec 	TIM_PC
.acc1					_TIMDecrement:
.acc1	ce c5 03	dec $03c5			dec 	TIM_PC+1
.acc4	ba		tsx				tsx 								; and copy SP
.acc5	8e cd 03	stx $03cd			stx 	TIM_SP
.acc8	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.acca	9a		txs				txs
.accb	4c a9 ab	jmp $aba9			jmp 	TIM_Start 					; and start up TIM monitor.
.acce					TIM_UpdateRegisters:
.acce	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; PC
.acd1	b0 23		bcs $acf6			bcs 	_TIMURFail
.acd3	a5 14		lda $14				lda 	zTemp3
.acd5	8d c5 03	sta $03c5			sta 	Tim_PC+1
.acd8	a5 15		lda $15				lda 	zTemp3+1
.acda	8d c4 03	sta $03c4			sta 	Tim_PC
.acdd	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; ignore IRQ
.ace0	b0 14		bcs $acf6			bcs 	_TIMURFail
.ace2	a2 00		ldx #$00			ldx 	#0
.ace4					_TIM_URLoop:
.ace4	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; registers
.ace7	b0 0d		bcs $acf6			bcs 	_TIMURFail
.ace9	a5 14		lda $14				lda 	zTemp3
.aceb	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.acee	e8		inx				inx
.acef	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf1	d0 f1		bne $ace4			bne 	_TIM_URLoop
.acf3	4c 19 ab	jmp $ab19			jmp 	TIM_NewCommand
.acf6					_TIMURFail:
.acf6	4c 12 ab	jmp $ab12			jmp 	TIM_Error
.acf9					TIM_LoadMemory:
.acf9	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; target address => zTemp2
.acfc	a5 14		lda $14				lda 	zTemp3
.acfe	85 12		sta $12				sta 	zTemp2
.ad00	a5 15		lda $15				lda 	zTemp3+1
.ad02	85 13		sta $13				sta 	zTemp2+1
.ad04					_TIM_LMLoop:
.ad04	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; next byte ?
.ad07	b0 0e		bcs $ad17			bcs 	_TIMLMDone 					; no more
.ad09	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0b	a5 14		lda $14				lda 	zTemp3
.ad0d	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad0f	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad11	d0 f1		bne $ad04			bne 	_TIM_LMLoop
.ad13	e6 13		inc $13				inc 	zTemp2+1
.ad15	80 ed		bra $ad04			bra 	_TIM_LMLoop
.ad17					_TIMLMDone:
.ad17	4c 19 ab	jmp $ab19			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.ad1a					StructureSearchSingle:
.ad1a	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.ad1c					StructureSearchDouble:
.ad1c	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.ad1e	86 11		stx $11				stx 	zTemp1+1
.ad20	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.ad22	85 12		sta $12				sta 	zTemp2
.ad24	80 1a		bra $ad40			bra 	_SSWLoop 					; jump in, start scanning from here.
.ad26					_SSWNextLine:
.ad26	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ad28	ea		nop				nop
.ad29	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.ad2b	18		clc				clc
.ad2c	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.ad2e	85 18		sta $18				sta 	zCodePtr
.ad30	90 02		bcc $ad34			bcc 	_SNLNoCarry
.ad32	e6 19		inc $19				inc 	zCodePtr+1
.ad34					_SNLNoCarry:
.ad34	a3 00		ldz #$00			ldz 	#0
.ad36	ea		nop				nop
.ad37	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ad39	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.ad3b	f0 57		beq $ad94			beq 	_SSWFail
.ad3d	1b		inz				inz
.ad3e	1b		inz				inz
.ad3f					_SSWNextSimple:
.ad3f	1b		inz				inz
.ad40					_SSWLoop:
.ad40	ea		nop				nop
.ad41	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ad43	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.ad45	f0 df		beq $ad26			beq 	_SSWNextLine 				; if so, then next line
.ad47	10 f6		bpl $ad3f			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.ad49	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.ad4b	d0 08		bne $ad55			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.ad4d	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.ad4f	f0 2f		beq $ad80			beq 	_SSWFound 					; then exit.
.ad51	c5 11		cmp $11				cmp 	zTemp1+1
.ad53	f0 2b		beq $ad80			beq 	_SSWFound
.ad55					_SSWCheckUpDown:
.ad55	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.ad57	90 10		bcc $ad69			bcc 	_SSWNext
.ad59	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.ad5b	90 08		bcc $ad65			bcc 	_SSWPlus
.ad5d	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.ad5f	b0 08		bcs $ad69			bcs 	_SSWNext
.ad61	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.ad63	c6 12		dec $12				dec 	zTemp2
.ad65					_SSWPlus:
.ad65	e6 12		inc $12				inc 	zTemp2
.ad67	30 18		bmi $ad81			bmi 	_SSWUnder					; error if driven -ve
.ad69					_SSWNext:
.ad69	ea		nop				nop
.ad6a	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.ad6c	1b		inz				inz 								; skip
.ad6d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ad6f	90 0d		bcc $ad7e			bcc 	_SEDone 					; so just skip over it.
.ad71	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ad73	90 08		bcc $ad7d			bcc 	_SEDouble
.ad75	6b		tza				tza 								; this is Y + 1
.ad76	18		clc				clc
.ad77	ea		nop				nop
.ad78	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.ad7a	4b		taz				taz 								; back in Y.
.ad7b	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ad7c	3b		dez				dez
.ad7d					_SEDouble:
.ad7d	1b		inz				inz
.ad7e					_SEDone:
.ad7e	80 c0		bra $ad40			bra 	_SSWLoop
.ad80					_SSWFound:
.ad80	60		rts				rts
.ad81					_SSWUnder:
.ad81	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ad84	53 74 72 75 63 74 75 72			.text "Structure order",0
>ad8c	65 20 6f 72 64 65 72 00
.ad94					_SSWFail:
.ad94	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ad97	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>ad9f	6e 64 20 73 74 72 75 63 74 75 72 65 00
.adac					SkipEndOfCommand:
.adac	ea		nop				nop
.adad	b2 18		lda ($18),z			lda 	(zCodePtr),z
.adaf	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.adb1	f0 1b		beq $adce			beq 	_SOCExit
.adb3	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.adb5	f0 17		beq $adce			beq 	_SOCExit
.adb7	ea		nop				nop
.adb8	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.adba	1b		inz				inz 								; skip
.adbb	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adbd	90 0d		bcc $adcc			bcc 	_SEDone 					; so just skip over it.
.adbf	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adc1	90 08		bcc $adcb			bcc 	_SEDouble
.adc3	6b		tza				tza 								; this is Y + 1
.adc4	18		clc				clc
.adc5	ea		nop				nop
.adc6	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.adc8	4b		taz				taz 								; back in Y.
.adc9	3b		dez				dez 								; fix up, one for the +1, one for the iny
.adca	3b		dez				dez
.adcb					_SEDouble:
.adcb	1b		inz				inz
.adcc					_SEDone:
.adcc	80 de		bra $adac			bra 	SkipEndOfCommand
.adce					_SOCExit:
.adce	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.adcf					StackReset:
.adcf	48		pha				pha
.add0	5a		phy				phy
.add1	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.add3	85 28		sta $28				sta 	zBasicSP
.add5	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.add7	85 29		sta $29				sta 	zBasicSP+1
.add9	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.addb	98		tya				tya 								; be a legal token.
.addc	91 28		sta ($28),y			sta 	(zBasicSP),y
.adde	7a		ply				ply
.addf	68		pla				pla
.ade0	60		rts				rts
.ade1					StackPushFrame:
.ade1	48		pha				pha
.ade2	5a		phy				phy
.ade3	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.ade4	48		pha				pha 								; save it.
.ade5	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.ade7	18		clc				clc 								; add to Basic Stack
.ade8	65 28		adc $28				adc 	zBasicSP
.adea	85 28		sta $28				sta 	zBasicSP
.adec	90 02		bcc $adf0			bcc 	_SPFNoBump
.adee	e6 29		inc $29				inc 	zBasicSP+1
.adf0					_SPFNoBump:
.adf0	a0 00		ldy #$00			ldy 	#0
.adf2	68		pla				pla
.adf3	91 28		sta ($28),y			sta 	(zBasicSP),y
.adf5	7a		ply				ply
.adf6	68		pla				pla
.adf7	60		rts				rts
.adf8					StackPopFrame:
.adf8	48		pha				pha
.adf9	5a		phy				phy
.adfa	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.adfc	51 28		eor ($28),y			eor 	(zBasicSP),y
.adfe	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ae00	d0 12		bne $ae14			bne 	SPFError 					; mixed structures
.ae02	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.ae04	29 0f		and #$0f			and 	#$0F
.ae06	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ae08	38		sec				sec
.ae09	65 28		adc $28				adc 	zBasicSP
.ae0b	85 28		sta $28				sta 	zBasicSP
.ae0d	b0 02		bcs $ae11			bcs 	_SPFNoBump
.ae0f	c6 29		dec $29				dec 	zBasicSP+1
.ae11					_SPFNoBump:
.ae11	7a		ply				ply
.ae12	68		pla				pla
.ae13	60		rts				rts
.ae14					SPFError:
.ae14	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ae17	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ae1f	72 75 63 74 75 72 65 73 00
.ae28					StackSavePosition:
.ae28	6b		tza				tza
.ae29	5a		phy				phy
.ae2a	a0 05		ldy #$05			ldy 	#5
.ae2c	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae2e	a0 01		ldy #$01			ldy 	#1
.ae30	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ae32	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae34	c8		iny				iny
.ae35	a5 19		lda $19				lda 	zCodePtr+1
.ae37	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae39	c8		iny				iny
.ae3a	a5 1a		lda $1a				lda 	zCodePtr+2
.ae3c	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae3e	c8		iny				iny
.ae3f	a5 1b		lda $1b				lda 	zCodePtr+3
.ae41	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae43	7a		ply				ply
.ae44	60		rts				rts
.ae45					StackRestorePosition:
.ae45	5a		phy				phy
.ae46	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ae48	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae4a	85 18		sta $18				sta 	zCodePtr+0
.ae4c	c8		iny				iny
.ae4d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae4f	85 19		sta $19				sta 	zCodePtr+1
.ae51	c8		iny				iny
.ae52	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae54	85 1a		sta $1a				sta 	zCodePtr+2
.ae56	c8		iny				iny
.ae57	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae59	85 1b		sta $1b				sta 	zCodePtr+3
.ae5b	c8		iny				iny
.ae5c	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.ae5e	7a		ply				ply 								; restore Y
.ae5f	4b		taz				taz
.ae60	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.ae61					VIOCharPrint:
.ae61	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.ae64					VIOCharGet:
.ae64	20 03 a2	jsr $a203			jsr 	IF_GetKey
.ae67	c9 00		cmp #$00			cmp 	#0
.ae69	f0 02		beq $ae6d			beq 	_VCG0
.ae6b	38		sec				sec
.ae6c	60		rts				rts
.ae6d	18		clc		_VCG0:	clc
.ae6e	60		rts				rts
.ae6f					VIOCheckBreak:
.ae6f	4c ee a1	jmp $a1ee			jmp 	IF_CheckBreak
.ae72					VIOCharGetPosition:
.ae72	ad 00 05	lda $0500			lda 	IFT_XCursor
.ae75	60		rts				rts
.ae76					VIOReadLine:
.ae76	4c 03 a1	jmp $a103			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ae79					SyntaxError:
.ae79	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>ae7c	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ae84	72 72 6f 72 00
.ae89					TypeError:
.ae89	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>ae8c	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ae94	70 65 00
.ae97					BadParamError:
.ae97	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>ae9a	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>aea2	6d 65 74 65 72 00
.aea8					ERR_Handler:
.aea8	a3 00		ldz #$00			ldz 	#0
.aeaa	1b		inz				inz
.aeab	ea		nop				nop
.aeac	b2 18		lda ($18),z			lda 	(zCodePtr),z
.aeae	85 80		sta $80				sta 	XS_Mantissa
.aeb0	1b		inz				inz
.aeb1	ea		nop				nop
.aeb2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.aeb4	85 81		sta $81				sta 	XS_Mantissa+1
.aeb6	fa		plx				plx 								; address in XY
.aeb7	7a		ply				ply
.aeb8	e8		inx				inx 								; bump, because of RTS/JSR address -1
.aeb9	d0 01		bne $aebc			bne 	_EHNoSkip
.aebb	c8		iny				iny
.aebc					_EHNoSkip:
.aebc	20 db ae	jsr $aedb			jsr 	PrintROMMessage 			; print message from ROM.
.aebf	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.aec1	05 81		ora $81				ora 	XS_Mantissa+1
.aec3	f0 0c		beq $aed1			beq 	_EHNoLine
.aec5	a2 d6		ldx #$d6			ldx 	#_EHAt & $FF 				; print " at "
.aec7	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.aec9	20 db ae	jsr $aedb			jsr 	PrintROMMessage
.aecc	a2 00		ldx #$00			ldx 	#0 							; Print line number
.aece	20 ec ae	jsr $aeec			jsr 	Print16BitInteger
.aed1					_EHNoLine:
.aed1	80 fe		bra $aed1			bra 	_EHNoLine
.aed3	4c 61 b1	jmp $b161			jmp 	ErrorStart 					; normally warm start, no message.
>aed6	20 61 74 20 00			_EHAt:	.text 	" at ",0
.aedb					PrintROMMessage:
.aedb	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.aedd	84 1d		sty $1d				sty 	zLTemp1+1
.aedf	a0 00		ldy #$00			ldy 	#0
.aee1					_PRMLoop:
.aee1	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; 6502/4510
.aee3	f0 06		beq $aeeb			beq		_PRMExit 					; character $00 => exit
.aee5	c8		iny				iny  								; bump Y and print it.
.aee6	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.aee9	80 f6		bra $aee1			bra 	_PRMLoop
.aeeb					_PRMExit:
.aeeb	60		rts				rts
.aeec					Print16BitInteger:
.aeec	a9 00		lda #$00			lda 	#0 							; make 32 bit
.aeee	85 82		sta $82				sta 	XS_Mantissa+2
.aef0	85 83		sta $83				sta 	XS_Mantissa+3
.aef2					Print32BitInteger:
.aef2	a9 00		lda #$00			lda 	#0
.aef4	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.aef7	aa		tax				tax 								; convert bottom level.
.aef8	20 3a cb	jsr $cb3a			jsr 	INTToString 				; make string from integer in Num_Buffer
.aefb	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.aefd	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.af00	f0 06		beq $af08			beq 	_P1Exit
.af02	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.af05	e8		inx				inx
.af06	80 f5		bra $aefd			bra 	_P1Loop
.af08	8a		txa		_P1Exit:txa 								; return chars printed.
.af09	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.af0a					VectorTable:
>af0a	58 bd					.word BinaryOp_And         & $FFFF ; $80 and
>af0c	74 bd					.word BinaryOp_Or          & $FFFF ; $81 or
>af0e	90 bd					.word BinaryOp_Xor         & $FFFF ; $82 xor
>af10	90 bd					.word BinaryOp_Eor         & $FFFF ; $83 eor
>af12	c7 bd					.word Binary_Equal         & $FFFF ; $84 =
>af14	d0 bd					.word Binary_NotEqual      & $FFFF ; $85 <>
>af16	d9 bd					.word Binary_Less          & $FFFF ; $86 <
>af18	e2 bd					.word Binary_LessEqual     & $FFFF ; $87 <=
>af1a	f4 bd					.word Binary_Greater       & $FFFF ; $88 >
>af1c	eb bd					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>af1e	8c be					.word BinaryOp_Add         & $FFFF ; $8a +
>af20	a8 be					.word BinaryOp_Subtract    & $FFFF ; $8b -
>af22	b9 be					.word BinaryOp_Multiply    & $FFFF ; $8c *
>af24	ca be					.word BinaryOp_Divide      & $FFFF ; $8d /
>af26	c8 af					.word NotImplemented       & $FFFF ; $8e ^
>af28	b9 b6					.word Command_IF           & $FFFF ; $8f if
>af2a	4d bb					.word Command_WHILE        & $FFFF ; $90 while
>af2c	75 bb					.word Command_REPEAT       & $FFFF ; $91 repeat
>af2e	fa b2					.word Command_FOR          & $FFFF ; $92 for
>af30	c8 af					.word NotImplemented       & $FFFF ; $93 then
>af32	1c b7					.word Command_ENDIF        & $FFFF ; $94 endif
>af34	6a bb					.word Command_WEND         & $FFFF ; $95 wend
>af36	7e bb					.word Command_UNTIL        & $FFFF ; $96 until
>af38	78 b3					.word Command_NEXT         & $FFFF ; $97 next
>af3a	c8 af					.word NotImplemented       & $FFFF ; $98 not
>af3c	c8 af					.word NotImplemented       & $FFFF ; $99 fn(
>af3e	cf bf					.word Unary_Abs            & $FFFF ; $9a abs(
>af40	29 c1					.word Unary_Asc            & $FFFF ; $9b asc(
>af42	64 d2					.word Unary_Int            & $FFFF ; $9c int(
>af44	e9 bf					.word Unary_Peek           & $FFFF ; $9d peek(
>af46	e5 d1					.word Unary_Rnd            & $FFFF ; $9e rnd(
>af48	5c c0					.word Unary_Usr            & $FFFF ; $9f usr(
>af4a	68 c1					.word Unary_Left           & $FFFF ; $a0 left$(
>af4c	7d c1					.word Unary_Right          & $FFFF ; $a1 right$(
>af4e	4f c1					.word Unary_Mid            & $FFFF ; $a2 mid$(
>af50	c8 c2					.word Unary_Spc            & $FFFF ; $a3 spc(
>af52	f7 c0					.word Unary_Str            & $FFFF ; $a4 str$(
>af54	7c c0					.word Unary_Val            & $FFFF ; $a5 val(
>af56	40 c1					.word Unary_Len            & $FFFF ; $a6 len(
>af58	f5 c1					.word Unary_Hex            & $FFFF ; $a7 hex$(
>af5a	c8 af					.word NotImplemented       & $FFFF ; $a8 sin(
>af5c	c8 af					.word NotImplemented       & $FFFF ; $a9 cos(
>af5e	c8 af					.word NotImplemented       & $FFFF ; $aa tan(
>af60	c8 af					.word NotImplemented       & $FFFF ; $ab atn(
>af62	c8 af					.word NotImplemented       & $FFFF ; $ac exp(
>af64	c8 af					.word NotImplemented       & $FFFF ; $ad log(
>af66	c8 af					.word NotImplemented       & $FFFF ; $ae sqr(
>af68	4b c2					.word Unary_Dec            & $FFFF ; $af dec(
>af6a	ed bf					.word Unary_Deek           & $FFFF ; $b0 deek(
>af6c	f1 bf					.word Unary_Leek           & $FFFF ; $b1 leek(
>af6e	29 c0					.word Unary_Mod            & $FFFF ; $b2 mod(
>af70	89 bf					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>af72	aa c2					.word Unary_Chr            & $FFFF ; $b4 chr$(
>af74	1d c0					.word Unary_Pos            & $FFFF ; $b5 pos(
>af76	eb c2					.word Unary_Tab            & $FFFF ; $b6 tab(
>af78	c8 af					.word NotImplemented       & $FFFF ; $b7 $
>af7a	c8 af					.word NotImplemented       & $FFFF ; $b8 $(
>af7c	c8 af					.word NotImplemented       & $FFFF ; $b9 #
>af7e	c8 af					.word NotImplemented       & $FFFF ; $ba #(
>af80	c8 af					.word NotImplemented       & $FFFF ; $bb %
>af82	c8 af					.word NotImplemented       & $FFFF ; $bc %(
>af84	c8 af					.word NotImplemented       & $FFFF ; $bd (
>af86	c8 af					.word NotImplemented       & $FFFF ; $be )
>af88	c8 af					.word NotImplemented       & $FFFF ; $bf ,
>af8a	f9 b2					.word Command_COLON        & $FFFF ; $c0 :
>af8c	c8 af					.word NotImplemented       & $FFFF ; $c1 ;
>af8e	c8 af					.word NotImplemented       & $FFFF ; $c2 def
>af90	2e bb					.word Command_CLR          & $FFFF ; $c3 clr
>af92	45 bb					.word Command_STOP         & $FFFF ; $c4 stop
>af94	54 b4					.word Command_DATA         & $FFFF ; $c5 data
>af96	2d b4					.word Command_READ         & $FFFF ; $c6 read
>af98	98 b1					.word Command_DIM          & $FFFF ; $c7 dim
>af9a	c8 af					.word NotImplemented       & $FFFF ; $c8 to
>af9c	c8 af					.word NotImplemented       & $FFFF ; $c9 step
>af9e	6d ba					.word Command_GOSUB        & $FFFF ; $ca gosub
>afa0	7d ba					.word Command_RETURN       & $FFFF ; $cb return
>afa2	65 ba					.word Command_GOTO         & $FFFF ; $cc goto
>afa4	b4 b6					.word Command_END          & $FFFF ; $cd end
>afa6	7f b5					.word Command_INPUT        & $FFFF ; $ce input
>afa8	fa b4					.word Command_LET          & $FFFF ; $cf let
>afaa	22 b7					.word Command_LIST         & $FFFF ; $d0 list
>afac	08 ba					.word Command_NEW          & $FFFF ; $d1 new
>afae	27 ba					.word Command_OLD          & $FFFF ; $d2 old
>afb0	86 ba					.word Command_ON           & $FFFF ; $d3 on
>afb2	57 b4					.word Command_RESTORE      & $FFFF ; $d4 restore
>afb4	d7 b9					.word Command_POKE         & $FFFF ; $d5 poke
>afb6	27 b9					.word Command_PRINT        & $FFFF ; $d6 print
>afb8	66 b2					.word Command_RUN          & $FFFF ; $d7 run
>afba	25 b2					.word Command_WAIT         & $FFFF ; $d8 wait
>afbc	66 b5					.word Command_SYS          & $FFFF ; $d9 sys
>afbe	db b9					.word Command_DOKE         & $FFFF ; $da doke
>afc0	df b9					.word Command_LOKE         & $FFFF ; $db loke
>afc2	bf b9					.word Command_ASSERT       & $FFFF ; $dc assert
>afc4	1b b5					.word Command_GET          & $FFFF ; $dd get
>afc6	16 b7					.word Command_ELSE         & $FFFF ; $de else
.afc8					NotImplemented:
.afc8	20 a8 ae	jsr $aea8			jsr ERR_Handler
>afcb	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>afd3	65 6d 65 6e 74 65 64 00
.afdb					BinaryPrecedence:
>afdb	01					.byte 1    ; $80 and
>afdc	01					.byte 1    ; $81 or
>afdd	01					.byte 1    ; $82 xor
>afde	01					.byte 1    ; $83 eor
>afdf	02					.byte 2    ; $84 =
>afe0	02					.byte 2    ; $85 <>
>afe1	02					.byte 2    ; $86 <
>afe2	02					.byte 2    ; $87 <=
>afe3	02					.byte 2    ; $88 >
>afe4	02					.byte 2    ; $89 >=
>afe5	03					.byte 3    ; $8a +
>afe6	03					.byte 3    ; $8b -
>afe7	04					.byte 4    ; $8c *
>afe8	04					.byte 4    ; $8d /
>afe9	05					.byte 5    ; $8e ^
.afea					KeywordText:
>afea	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>afed	4f d2					.byte $4f,$d2                          ; $81 or
>afef	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>aff2	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>aff5	bd					.byte $bd                              ; $84 =
>aff6	3c be					.byte $3c,$be                          ; $85 <>
>aff8	bc					.byte $bc                              ; $86 <
>aff9	3c bd					.byte $3c,$bd                          ; $87 <=
>affb	be					.byte $be                              ; $88 >
>affc	3e bd					.byte $3e,$bd                          ; $89 >=
>affe	ab					.byte $ab                              ; $8a +
>afff	ad					.byte $ad                              ; $8b -
>b000	aa					.byte $aa                              ; $8c *
>b001	af					.byte $af                              ; $8d /
>b002	de					.byte $de                              ; $8e ^
>b003	49 c6					.byte $49,$c6                          ; $8f if
>b005	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>b00a	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>b010	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>b013	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>b017	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>b01c	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>b020	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>b025	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>b029	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>b02c	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>b02f	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>b033	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>b037	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>b03b	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>b040	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>b044	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>b048	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>b04e	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>b055	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>b05a	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>b05e	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>b063	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>b067	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>b06b	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>b070	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>b074	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>b078	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>b07c	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>b080	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>b084	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>b088	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>b08c	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>b090	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>b095	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>b09a	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>b09e	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>b0a2	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>b0a7	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>b0ab	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>b0af	a4					.byte $a4                              ; $b7 $
>b0b0	24 a8					.byte $24,$a8                          ; $b8 $(
>b0b2	a3					.byte $a3                              ; $b9 #
>b0b3	23 a8					.byte $23,$a8                          ; $ba #(
>b0b5	a5					.byte $a5                              ; $bb %
>b0b6	25 a8					.byte $25,$a8                          ; $bc %(
>b0b8	a8					.byte $a8                              ; $bd (
>b0b9	a9					.byte $a9                              ; $be )
>b0ba	ac					.byte $ac                              ; $bf ,
>b0bb	ba					.byte $ba                              ; $c0 :
>b0bc	bb					.byte $bb                              ; $c1 ;
>b0bd	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>b0c0	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>b0c3	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b0c7	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b0cb	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b0cf	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b0d2	54 cf					.byte $54,$cf                          ; $c8 to
>b0d4	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b0d8	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b0dd	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b0e3	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b0e7	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b0ea	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b0ef	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b0f2	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b0f6	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b0f9	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b0fc	4f ce					.byte $4f,$ce                          ; $d3 on
>b0fe	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b105	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b109	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b10e	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b111	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b115	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b118	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b11c	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b120	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b126	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b129	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>b12d	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.b12e					BASIC_Start:
.b12e	20 4a a2	jsr $a24a			jsr 	IF_Reset 					; set up and clear screen.
.b131	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b134	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b136	8d 10 03	sta $0310			sta 	LocalVector
.b139	8d 0c 03	sta $030c			sta 	UserVector
.b13c	a9 6a		lda #$6a			lda 	#USRDefault & $FF 			; reset USR vector to a default
.b13e	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.b141	a9 c0		lda #$c0			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.b143	8d 0e 03	sta $030e			sta 	UserVector+2
.b146	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b148	8d 0f 03	sta $030f			sta 	UserVector+3
.b14b	20 38 c3	jsr $c338			jsr 	UpdateProgramEnd 			; update the program end.
.b14e	20 2e bb	jsr $bb2e			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b151	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b153	9a		txs				txs
.b154	4c 66 b2	jmp $b266			jmp 	COMMAND_Run
.b157	20 08 ba	jsr $ba08			jsr 	Command_NEW 				; new command, will not return.
.b15a					WarmStart:
.b15a	a2 8e		ldx #$8e			ldx 	#ReadyMsg & $FF 			; Print READY.
.b15c	a0 b1		ldy #$b1			ldy 	#(ReadyMsg >> 8) & $FF
.b15e	20 db ae	jsr $aedb			jsr 	PrintROMMessage
.b161					ErrorStart:
.b161	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b163	9a		txs				txs
.b164	20 03 a1	jsr $a103			jsr 	IFT_ReadLine 				; read line in.
.b167	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF 		; tokenise it.
.b169	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.b16b	20 d5 c4	jsr $c4d5			jsr 	TokeniseString
.b16e	ad 00 04	lda $0400			lda 	TokeniseBuffer 				; what is first.
.b171	29 c0		and #$c0			and 	#$C0 						; is it a number 4000-7FFF
.b173	c9 40		cmp #$40			cmp 	#$40
.b175	f0 1f		beq $b196			beq 	EditLine 					; if true, go to edit line.
.b177	a9 00		lda #$00			lda 	#TokeniseBuffer & $FF
.b179	85 18		sta $18				sta 	zCodePtr+0
.b17b	a9 04		lda #$04			lda 	#TokeniseBuffer >> 8
.b17d	85 19		sta $19				sta 	zCodePtr+1
.b17f	a9 02		lda #$02			lda 	#2
.b181	85 1a		sta $1a				sta 	zCodePtr+2
.b183	a9 00		lda #$00			lda 	#0
.b185	85 1b		sta $1b				sta 	zCodePtr+3
.b187	a3 03		ldz #$03			ldz 	#3
.b189	a3 00		ldz #$00			ldz 	#0
.b18b	4c 9f b2	jmp $b29f			jmp 	RUN_NextCommand
.b18e					ReadyMsg:
>b18e	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0
.b196					EditLine:
.b196	80 fe		bra $b196			bra 	EditLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b198					Command_DIM:
.b198	6b		tza				tza
.b199	48		pha				pha 								; push on stack.
.b19a	20 c1 c6	jsr $c6c1			jsr 	VariableExtract 			; get the identifier
.b19d	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b1a0	29 01		and #$01			and 	#1
.b1a2	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b1a4	d0 71		bne $b217			bne 	_CDIError
.b1a6	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b1a8	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b1ab					_CDIGetDimension:
.b1ab	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.b1ae	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b1b0	f0 65		beq $b217			beq 	_CDIError
.b1b2	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; evaluate an index size
.b1b5	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b1b7	29 80		and #$80			and 	#$80
.b1b9	05 82		ora $82				ora 	XS_Mantissa+2
.b1bb	05 83		ora $83				ora 	XS_Mantissa+3
.b1bd	d0 58		bne $b217			bne 	_CDIError
.b1bf	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.b1c2	18		clc				clc 								; add 1 - max index => size.
.b1c3	a5 80		lda $80				lda 	XS_Mantissa+0
.b1c5	69 01		adc #$01			adc 	#1
.b1c7	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.b1ca	a5 81		lda $81				lda 	XS_Mantissa+1
.b1cc	69 00		adc #$00			adc 	#0
.b1ce	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.b1d1	30 44		bmi $b217			bmi 	_CDIError 					; could be dim a(32767)
.b1d3	e8		inx				inx 								; bump index.
.b1d4	e8		inx				inx
.b1d5	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.b1d8	ea		nop				nop
.b1d9	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b1db	1b		inz				inz
.b1dc	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b1de	f0 cb		beq $b1ab			beq 	_CDIGetDimension
.b1e0	3b		dez				dez
.b1e1	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; closing ) present ?
.b1e4	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.b1e7	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b1e9	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.b1ec					_CDICopy:
.b1ec	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.b1ef	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.b1f2	ca		dex				dex
.b1f3	10 f7		bpl $b1ec			bpl 	_CDICopy
.b1f5	68		pla				pla									; position of array identifier
.b1f6	85 10		sta $10				sta 	zTemp1
.b1f8	6b		tza				tza
.b1f9	48		pha				pha
.b1fa	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b1fc	4b		taz				taz
.b1fd	20 c1 c6	jsr $c6c1			jsr 	VariableExtract 			; get the identifier
.b200	20 5c c9	jsr $c95c			jsr 	VariableLocate 				; check if it exists already.
.b203	b0 12		bcs $b217			bcs 	_CDIError
.b205	20 4f c7	jsr $c74f			jsr 	VariableCreate 				; create it using the current ArrayDef
.b208	68		pla				pla 								; restore code position
.b209	4b		taz				taz
.b20a	ea		nop				nop
.b20b	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b20d	1b		inz				inz
.b20e	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b210	f0 86		beq $b198			beq 	Command_DIM
.b212	3b		dez				dez
.b213	20 5e c8	jsr $c85e			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.b216	60		rts				rts
.b217					_CDIError:
.b217	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b21a	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b222					_CDISyntax:
.b222	4c 79 ae	jmp $ae79			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.b225					Command_WAIT:
.b225	20 39 bd	jsr $bd39			jsr		EvaluateInteger 			; get address to monitor
.b228	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.b22a	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma
.b22d	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX
.b230	a9 00		lda #$00			lda 	#0							; set default xor value.
.b232	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.b234	ea		nop				nop
.b235	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b237	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.b239	d0 06		bne $b241			bne 	_CWAXorDefault
.b23b	1b		inz				inz
.b23c	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.b23e	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX
.b241					_CWAXorDefault:
.b241	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.b243	85 1c		sta $1c				sta 	zLTemp1
.b245	a5 81		lda $81				lda 	XS_Mantissa+1
.b247	85 1d		sta $1d				sta 	zLTemp1+1
.b249	a5 82		lda $82				lda 	XS_Mantissa+2
.b24b	85 1e		sta $1e				sta 	zLTemp1+2
.b24d					_CWAWaitLoop:
.b24d	20 6f ae	jsr $ae6f			jsr 	VIOCheckBreak 				; exit on break.
.b250	c9 00		cmp #$00			cmp 	#0
.b252	d0 11		bne $b265			bne 	_CWAWaitExit
.b254	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.b256	a2 00		ldx #$00			ldx 	#0
.b258	5a		phy				phy 								; this is the same routine as PEEK.
.b259	20 10 c3	jsr $c310			jsr 	MemRead
.b25c	7a		ply				ply
.b25d	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.b25f	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.b261	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.b263	f0 e8		beq $b24d			beq 	_CWAWaitLoop 				; and loop if zero.
.b265					_CWAWaitExit:
.b265	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b266					Command_RUN:
.b266	20 2e bb	jsr $bb2e			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b269	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b26b	85 18		sta $18				sta 	zCodePtr+0
.b26d	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b26f	85 19		sta $19				sta 	zCodePtr+1
.b271	a9 02		lda #$02			lda 	#2
.b273	85 1a		sta $1a				sta 	zCodePtr+2
.b275	a9 00		lda #$00			lda 	#0
.b277	85 1b		sta $1b				sta 	zCodePtr+3
.b279	a3 03		ldz #$03			ldz 	#3
.b27b					RUN_NewLine:
.b27b	a3 00		ldz #$00			ldz 	#0
.b27d	ea		nop				nop
.b27e	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b280	1b		inz				inz
.b281	1b		inz				inz
.b282	1b		inz				inz
.b283	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b285	d0 18		bne $b29f			bne 	RUN_NextCommand
.b287	4c b4 b6	jmp $b6b4			jmp 	Command_END 				; go do the command code.
.b28a					RUN_Skip:
.b28a	ea		nop				nop
.b28b	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b28d	1b		inz				inz 								; skip
.b28e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b290	90 0d		bcc $b29f			bcc 	_SEDone 					; so just skip over it.
.b292	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b294	90 08		bcc $b29e			bcc 	_SEDouble
.b296	6b		tza				tza 								; this is Y + 1
.b297	18		clc				clc
.b298	ea		nop				nop
.b299	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b29b	4b		taz				taz 								; back in Y.
.b29c	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b29d	3b		dez				dez
.b29e					_SEDouble:
.b29e	1b		inz				inz
.b29f					_SEDone:
.b29f					RUN_NextCommand:
.b29f	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.b2a2	69 10		adc #$10			adc 	#16 						; one time in 16
.b2a4	8d a8 03	sta $03a8			sta 	BreakCount
.b2a7	90 0a		bcc $b2b3			bcc 	RUN_NoCheckBreak
.b2a9	20 6f ae	jsr $ae6f			jsr 	VIOCheckBreak 				; check for break
.b2ac	c9 00		cmp #$00			cmp 	#0
.b2ae	f0 03		beq $b2b3			beq 	RUN_NoCheckBreak
.b2b0	4c 45 bb	jmp $bb45			jmp 	Command_STOP 				; stop on BREAK.
.b2b3					RUN_NoCheckBreak:
.b2b3	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b2b5	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.b2b7	ea		nop				nop
.b2b8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b2ba	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b2bc	f0 cc		beq $b28a			beq 	RUN_Skip
.b2be	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b2c0	d0 10		bne $b2d2			bne 	RUN_Execute
.b2c2					RUN_NextLine:
.b2c2	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b2c4	ea		nop				nop
.b2c5	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b2c7	18		clc				clc
.b2c8	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b2ca	85 18		sta $18				sta 	zCodePtr
.b2cc	90 02		bcc $b2d0			bcc 	_SNLNoCarry
.b2ce	e6 19		inc $19				inc 	zCodePtr+1
.b2d0					_SNLNoCarry:
.b2d0	80 a9		bra $b27b			bra 	RUN_NewLine 				; go do the new line code
.b2d2					RUN_Execute:
.b2d2	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b2d4	b0 1c		bcs $b2f2			bcs 	RUN_Extension
.b2d6	1b		inz				inz
.b2d7	0a		asl a				asl 	a 							; double the character read.
.b2d8	90 12		bcc $b2ec			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b2da	aa		tax				tax 								; ready to look up.
.b2db	bd 0a af	lda $af0a,x			lda 	VectorTable,x 				; copy address into LocalVector
.b2de	8d 11 03	sta $0311			sta 	LocalVector+1
.b2e1	bd 0b af	lda $af0b,x			lda 	VectorTable+1,x
.b2e4	8d 12 03	sta $0312			sta 	LocalVector+2
.b2e7	20 82 bc	jsr $bc82			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b2ea	80 b3		bra $b29f			bra 	RUN_NextCommand 			; do the next command.
.b2ec					RUN_Default:
.b2ec	3b		dez				dez
.b2ed	20 fa b4	jsr $b4fa			jsr 	Command_LET 				; and try LET.
.b2f0	80 ad		bra $b29f			bra 	RUN_NextCommand
.b2f2					RUN_Extension:
.b2f2	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b2f4	f0 94		beq $b28a			beq 	RUN_Skip 					; skip over it.
.b2f6	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.b2f9					Command_COLON:
.b2f9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.b2fa					Command_FOR:
.b2fa	20 fa b4	jsr $b4fa			jsr 	Command_LET 				; do the A = 99 bit
.b2fd	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.b2ff	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b301	f0 72		beq $b375			beq 	_CFOError
.b303	48		pha				pha 								; save the variable type.
.b304	5a		phy				phy 								; save type/variable address.
.b305	a0 01		ldy #$01			ldy 	#1							; type at + 1
.b307	91 28		sta ($28),y			sta 	(zBasicSP),y
.b309	c8		iny				iny
.b30a	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.b30c	91 28		sta ($28),y			sta 	(zBasicSP),y
.b30e	c8		iny				iny
.b30f	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.b311	91 28		sta ($28),y			sta 	(zBasicSP),y
.b313	7a		ply				ply
.b314	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.b316	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.b319	a9 c8		lda #$c8			lda 	#token_TO
.b31b	20 81 c3	jsr $c381			jsr 	CheckNextToken
.b31e	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.b320	20 9c bb	jsr $bb9c			jsr 	EvaluateExpression
.b323	ea		nop				nop
.b324	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b326	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.b328	c9 c9		cmp #$c9			cmp 	#token_STEP
.b32a	d0 06		bne $b332			bne 	_CFOStep1
.b32c	1b		inz				inz
.b32d	20 9e bb	jsr $bb9e			jsr 	EvaluateExpressionX 		; get STEP value.
.b330	80 0e		bra $b340			bra 	_CFOHaveStep
.b332					_CFOStep1:
.b332	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.b334	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b336	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b338	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b33a	a9 01		lda #$01			lda 	#1
.b33c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b33e	95 85		sta $85,x			sta 	XS_Type,x
.b340					_CFOHaveStep:
.b340	68		pla				pla 								; restore variable type
.b341	a2 00		ldx #$00			ldx 	#0
.b343	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.b345	f0 0a		beq $b351			beq 	_CFOInteger
.b347	20 65 cf	jsr $cf65			jsr 	FPUToFloat
.b34a	a2 06		ldx #$06			ldx 	#6
.b34c	20 65 cf	jsr $cf65			jsr 	FPUToFloat
.b34f	80 08		bra $b359			bra 	_CFOEndConv
.b351					_CFOInteger:
.b351	20 b1 cf	jsr $cfb1			jsr 	FPUToInteger
.b354	a2 06		ldx #$06			ldx 	#6
.b356	20 b1 cf	jsr $cfb1			jsr 	FPUToInteger
.b359					_CFOEndConv:
.b359	20 28 ae	jsr $ae28			jsr 	StackSavePosition 			; save the loop position at 1-5
.b35c	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.b35e	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push the loop address frame.
.b361	5a		phy				phy
.b362	a0 00		ldy #$00			ldy 	#0
.b364					_CFOCopy:
.b364	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.b367	c8		iny				iny
.b368	91 28		sta ($28),y			sta 	(zBasicSP),y
.b36a	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.b36c	d0 f6		bne $b364			bne 	_CFOCopy
.b36e	7a		ply				ply
.b36f	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.b371	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.b374	60		rts				rts
.b375					_CFOError:
.b375	4c 89 ae	jmp $ae89			jmp 	TypeError 					; wrong type.
.b378					Command_NEXT:
.b378	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.b37a	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.b37c	ea		nop				nop
.b37d	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b37f	c9 00		cmp #$00			cmp 	#0 							; EOL
.b381	f0 07		beq $b38a			beq 	_CNextNoVariable
.b383	c9 40		cmp #$40			cmp 	#$40
.b385	b0 03		bcs $b38a			bcs 	_CNextNoVariable
.b387	20 56 c6	jsr $c656			jsr 	VariableFind
.b38a					_CNextNoVariable:
.b38a	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.b38c	48		pha				pha
.b38d	a5 29		lda $29				lda 	zBasicSP+1
.b38f	48		pha				pha
.b390	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.b392	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b395	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.b397	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b39a	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.b39c	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b39f	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.b3a1	f0 11		beq $b3b4			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.b3a3	5a		phy				phy 								; check addresses match.
.b3a4	a0 02		ldy #$02			ldy 	#2
.b3a6	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3a8	c5 24		cmp $24				cmp 	zVarDataPtr
.b3aa	d0 6a		bne $b416			bne 	_CNextWrong
.b3ac	c8		iny				iny
.b3ad	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3af	c5 25		cmp $25				cmp 	zVarDataPtr+1
.b3b1	d0 63		bne $b416			bne 	_CNextWrong
.b3b3	7a		ply				ply
.b3b4					_CNextGetTarget:
.b3b4	5a		phy				phy
.b3b5	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.b3b7	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3b9	85 26		sta $26				sta 	zVarType
.b3bb	c8		iny				iny
.b3bc	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3be	85 24		sta $24				sta 	zVarDataPtr
.b3c0	c8		iny				iny
.b3c1	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3c3	85 25		sta $25				sta 	zVarDataPtr+1
.b3c5	a2 0c		ldx #$0c			ldx 	#12
.b3c7	20 a0 c9	jsr $c9a0			jsr 	VariableGet 				; get that variable value into expr[2]
.b3ca	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.b3cc	a0 0b		ldy #$0b			ldy 	#11
.b3ce					_CNXCopy:
.b3ce	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3d0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b3d2	e8		inx				inx
.b3d3	c8		iny				iny
.b3d4	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.b3d6	d0 f6		bne $b3ce			bne 	_CNXCopy
.b3d8	7a		ply				ply
.b3d9	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.b3db	20 ad bf	jsr $bfad			jsr 	GetSignCurrent
.b3de	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.b3e1	a2 06		ldx #$06			ldx 	#6 							; add them, however
.b3e3	20 8c be	jsr $be8c			jsr 	BinaryOp_Add
.b3e6	20 f1 c9	jsr $c9f1			jsr 	VariableSet					; and write variable back.
.b3e9	a2 00		ldx #$00			ldx 	#0
.b3eb	20 10 be	jsr $be10			jsr 	CompareValues
.b3ee	09 00		ora #$00			ora 	#0
.b3f0	f0 05		beq $b3f7			beq 	_CNXAgain 					; if true, then do it again.
.b3f2	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.b3f5	d0 0f		bne $b406			bne 	_CNXLoopDone
.b3f7					_CNXAgain:
.b3f7	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.b3f9	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.b3fc	20 45 ae	jsr $ae45			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.b3ff	68		pla				pla
.b400	85 29		sta $29				sta 	zBasicSP+1
.b402	68		pla				pla
.b403	85 28		sta $28				sta 	zBasicSP
.b405					_CNXExit:
.b405	60		rts				rts
.b406					_CNXLoopDone:
.b406	68		pla				pla 								; throw away saved to Basic Stack Pointer
.b407	68		pla				pla
.b408	ea		nop				nop
.b409	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b40b	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.b40d	d0 f6		bne $b405			bne 	_CNXExit
.b40f	1b		inz				inz
.b410	20 56 c6	jsr $c656			jsr 	VariableFind 				; identify the variable
.b413	4c 8a b3	jmp $b38a			jmp 	_CNextNoVariable 			; go back with variable pre-found
.b416					_CNextWrong:
.b416	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b419	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>b421	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.b42d					Command_READ:
.b42d	20 56 c6	jsr $c656			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.b430	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.b432	48		pha				pha
.b433	a5 25		lda $25				lda 	zVarDataPtr+1
.b435	48		pha				pha
.b436	a5 26		lda $26				lda 	zVarType
.b438	48		pha				pha
.b439	20 80 b4	jsr $b480			jsr 	READGetDataItem 			; get the next data item
.b43c	68		pla				pla 								; restore target variable information.
.b43d	85 26		sta $26				sta 	zVarType
.b43f	68		pla				pla
.b440	85 25		sta $25				sta 	zVarDataPtr+1
.b442	68		pla				pla
.b443	85 24		sta $24				sta 	zVarDataPtr
.b445	a2 00		ldx #$00			ldx 	#0
.b447	20 f1 c9	jsr $c9f1			jsr 	VariableSet 				; set the value out.
.b44a	ea		nop				nop
.b44b	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b44d	1b		inz				inz
.b44e	c9 bf		cmp #$bf			cmp 	#token_Comma
.b450	f0 db		beq $b42d			beq 	Command_READ 				; found, do another READ
.b452	3b		dez				dez
.b453	60		rts				rts
.b454					Command_DATA:
.b454	4c ac ad	jmp $adac			jmp 	SkipEndOfCommand
.b457					Command_RESTORE:
.b457	48		pha				pha
.b458	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.b45a	8d bd 03	sta $03bd			sta 	DataLPtr+0
.b45d	8d be 03	sta $03be			sta 	DataLPtr+1
.b460	68		pla				pla
.b461	60		rts				rts
.b462					READSwapPointers:
.b462	6b		tza				tza
.b463	48		pha				pha 								; save it
.b464	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.b467	4b		taz				taz
.b468	68		pla				pla 								; get code offset and save in DataIndex
.b469	8d c1 03	sta $03c1			sta 	DataIndex
.b46c	da		phx				phx
.b46d	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.b46f					_RSWLoop:
.b46f	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.b472	48		pha				pha
.b473	b5 18		lda $18,x			lda 	zCodePtr+0,x
.b475	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.b478	68		pla				pla
.b479	95 18		sta $18,x			sta 	zCodePtr+0,x
.b47b	ca		dex				dex
.b47c	10 f1		bpl $b46f			bpl 	_RSWLoop
.b47e	fa		plx				plx
.b47f	60		rts				rts
.b480					READGetDataItem:
.b480	20 62 b4	jsr $b462			jsr 	ReadSwapPointers 			; swap code and data pointer.
.b483	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.b485	05 19		ora $19				ora 	zCodePtr+1
.b487	d0 14		bne $b49d			bne 	_RGDIIsInitialised
.b489	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b48b	85 18		sta $18				sta 	zCodePtr+0
.b48d	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b48f	85 19		sta $19				sta 	zCodePtr+1
.b491	a9 02		lda #$02			lda 	#2
.b493	85 1a		sta $1a				sta 	zCodePtr+2
.b495	a9 00		lda #$00			lda 	#0
.b497	85 1b		sta $1b				sta 	zCodePtr+3
.b499	a3 03		ldz #$03			ldz 	#3
.b49b	80 07		bra $b4a4			bra 	_RGDIFindData 				; locate next data from start and read that.
.b49d					_RGDIIsInitialised:
.b49d	ea		nop				nop
.b49e	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b4a0	c9 bf		cmp #$bf			cmp 	#token_Comma
.b4a2	f0 4e		beq $b4f2			beq 	_RGDISkipEvaluateExit
.b4a4					_RGDIFindData:
.b4a4	ea		nop				nop
.b4a5	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b4a7	c9 00		cmp #$00			cmp 	#0 							; end of line
.b4a9	f0 1b		beq $b4c6			beq 	_RGDIFindNextLine
.b4ab	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.b4ad	f0 43		beq $b4f2			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.b4af	ea		nop				nop
.b4b0	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b4b2	1b		inz				inz 								; skip
.b4b3	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b4b5	90 0d		bcc $b4c4			bcc 	_SEDone 					; so just skip over it.
.b4b7	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b4b9	90 08		bcc $b4c3			bcc 	_SEDouble
.b4bb	6b		tza				tza 								; this is Y + 1
.b4bc	18		clc				clc
.b4bd	ea		nop				nop
.b4be	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b4c0	4b		taz				taz 								; back in Y.
.b4c1	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b4c2	3b		dez				dez
.b4c3					_SEDouble:
.b4c3	1b		inz				inz
.b4c4					_SEDone:
.b4c4	80 de		bra $b4a4			bra 	_RGDIFindData
.b4c6					_RGDIFindNextLine:
.b4c6	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b4c8	ea		nop				nop
.b4c9	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b4cb	18		clc				clc
.b4cc	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b4ce	85 18		sta $18				sta 	zCodePtr
.b4d0	90 02		bcc $b4d4			bcc 	_SNLNoCarry
.b4d2	e6 19		inc $19				inc 	zCodePtr+1
.b4d4					_SNLNoCarry:
.b4d4	a3 00		ldz #$00			ldz 	#0
.b4d6	ea		nop				nop
.b4d7	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b4d9	48		pha				pha
.b4da	1b		inz				inz
.b4db	1b		inz				inz
.b4dc	1b		inz				inz
.b4dd	68		pla				pla
.b4de	d0 c4		bne $b4a4			bne 	_RGDIFindData 				; back to scanning.
.b4e0	20 62 b4	jsr $b462			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.b4e3	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b4e6	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>b4ee	61 74 61 00
.b4f2					_RGDISkipEvaluateExit:
.b4f2	1b		inz				inz
.b4f3	20 9c bb	jsr $bb9c			jsr 	EvaluateExpression 			; evaluate the expression
.b4f6	20 62 b4	jsr $b462			jsr 	ReadSwapPointers 			; swap the pointers around.
.b4f9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b4fa					Command_LET:
.b4fa	20 56 c6	jsr $c656			jsr 	VariableFind 				; get reference to one variable.
.b4fd	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b4ff	20 81 c3	jsr $c381			jsr 	CheckNextToken
.b502	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.b504	48		pha				pha
.b505	a5 25		lda $25				lda 	zVarDataPtr+1
.b507	48		pha				pha
.b508	a5 26		lda $26				lda 	zVarType
.b50a	48		pha				pha
.b50b	20 9c bb	jsr $bb9c			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.b50e	68		pla				pla 								; restore target variable information.
.b50f	85 26		sta $26				sta 	zVarType
.b511	68		pla				pla
.b512	85 25		sta $25				sta 	zVarDataPtr+1
.b514	68		pla				pla
.b515	85 24		sta $24				sta 	zVarDataPtr
.b517	20 f1 c9	jsr $c9f1			jsr 	VariableSet 				; set the value out.
.b51a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.b51b					Command_GET:
.b51b					_CGLoop:
.b51b	20 56 c6	jsr $c656			jsr 	VariableFind 				; get a variable.
.b51e	20 64 ae	jsr $ae64			jsr 	VIOCharGet 					; get character
.b521	b0 02		bcs $b525			bcs 	_CGNoKey
.b523	a9 00		lda #$00			lda 	#0 							; if no character return zero
.b525					_CGNoKey:
.b525	48		pha				pha
.b526	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.b528	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b52a	f0 1f		beq $b54b			beq 	_CGString
.b52c	68		pla				pla 								; put character in slot.
.b52d	85 80		sta $80				sta 	XS_Mantissa
.b52f	a9 00		lda #$00			lda 	#0
.b531	85 81		sta $81				sta 	XS_Mantissa+1
.b533	85 82		sta $82				sta 	XS_Mantissa+2
.b535	85 83		sta $83				sta 	XS_Mantissa+3
.b537	a9 01		lda #$01			lda 	#1 							; type integer
.b539	85 85		sta $85				sta 	XS_Type
.b53b					_CGWriteSetNext:
.b53b	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.b53d	20 f1 c9	jsr $c9f1			jsr 	VariableSet
.b540	ea		nop				nop
.b541	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b543	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.b545	d0 03		bne $b54a			bne 	_CGExit
.b547	1b		inz				inz
.b548	80 d1		bra $b51b			bra 	_CGLoop 					; and get another.
.b54a					_CGExit:
.b54a	60		rts				rts
.b54b					_CGString:
.b54b	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.b54d	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString 			; initially empty.
.b550	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.b552	85 80		sta $80				sta 	XS_Mantissa
.b554	a5 23		lda $23				lda 	zTempStr+1
.b556	85 81		sta $81				sta 	XS_Mantissa+1
.b558	a9 02		lda #$02			lda 	#2
.b55a	85 85		sta $85				sta 	XS_Type
.b55c	68		pla				pla 								; get A
.b55d	c9 00		cmp #$00			cmp 	#0
.b55f	f0 da		beq $b53b			beq 	_CGWriteSetNext
.b561	20 13 c4	jsr $c413			jsr 	WriteTempString 			; write it into string
.b564	80 d5		bra $b53b			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.b566					Command_SYS:
.b566	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; address to call.
.b569	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.b56b	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.b56e	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.b570	8d 11 03	sta $0311			sta 	LocalVector+1
.b573	a5 82		lda $82				lda 	XS_Mantissa+2
.b575	8d 12 03	sta $0312			sta 	LocalVector+2
.b578	20 7c b5	jsr $b57c			jsr 	_CSYLocalCall
.b57b	60		rts				rts
.b57c					_CSYLocalCall:
.b57c	6c 10 03	jmp ($0310)			jmp 	(LocalVector)

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.b57f					Command_INPUT:
.b57f	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.b581	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.b584	8d c3 03	sta $03c3		sta 	InputRetry
.b587					_CILoop:
.b587	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.b589	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.b58b	ea		nop				nop
.b58c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b58e	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.b590	d0 17		bne $b5a9		bne 	_CINoPrompt
.b592	1b		inz				inz
.b593	ea		nop				nop
.b594	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b596	aa		tax			tax 									; into X
.b597	1b		inz				inz
.b598	ca		dex			dex 									; deduct marker/prompt length
.b599	ca		dex			dex
.b59a	f0 eb		beq $b587		beq 	_CILoop 						; nothing.
.b59c					_CIShowPrompt:
.b59c	ea		nop				nop
.b59d	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b59f	20 61 ae	jsr $ae61		jsr 	VIOCharPrint
.b5a2	1b		inz				inz
.b5a3	ca		dex			dex
.b5a4	d0 f6		bne $b59c		bne 	_CIShowPrompt
.b5a6	80 df		bra $b587		bra 	_CILoop
.b5a8					_CIAdvance:
.b5a8	1b		inz				inz
.b5a9					_CINoPrompt:
.b5a9	ea		nop				nop
.b5aa	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b5ac	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.b5ae	f0 f8		beq $b5a8		beq 	_CIAdvance
.b5b0	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.b5b2	f0 f4		beq $b5a8		beq 	_CIAdvance
.b5b4	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.b5b6	f0 04		beq $b5bc		beq 	_CIExit
.b5b8	c9 c0		cmp #$c0		cmp 	#token_Colon
.b5ba	d0 01		bne $b5bd		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.b5bc					_CIExit:
.b5bc	60		rts			rts
.b5bd					_CIIsVariable:
.b5bd	20 56 c6	jsr $c656		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.b5c0	a5 26		lda $26			lda 	zVarType
.b5c2	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.b5c4	f0 40		beq $b606		beq 	_CIIsString
.b5c6					_CINGetText:
.b5c6	a9 00		lda #$00		lda 	#0
.b5c8	8d 14 03	sta $0314		sta 	NumBufX
.b5cb					_CINSkip:
.b5cb	20 65 b6	jsr $b665		jsr 	CIGetCharacter 					; get character skip spaces
.b5ce	c9 20		cmp #$20		cmp 	#" "
.b5d0	f0 f9		beq $b5cb		beq 	_CINSkip
.b5d2	c9 2c		cmp #$2c		cmp 	#","
.b5d4	f0 f5		beq $b5cb		beq 	_CINSkip
.b5d6					_CINLoop:
.b5d6	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.b5d9	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.b5dc	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.b5de	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.b5e1	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.b5e4	20 65 b6	jsr $b665		jsr 	CIGetCharacter 					; get next character
.b5e7	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.b5e9	f0 08		beq $b5f3		beq 	_CINCopied
.b5eb	c9 2c		cmp #$2c		cmp 	#","
.b5ed	f0 04		beq $b5f3		beq 	_CINCopied
.b5ef	c9 21		cmp #$21		cmp 	#" "+1
.b5f1	b0 e3		bcs $b5d6		bcs 	_CINLoop
.b5f3					_CINCopied:
.b5f3	a2 00		ldx #$00		ldx 	#0
.b5f5	20 bb c0	jsr $c0bb		jsr 	ConvertNumBuffer 				; convert number
.b5f8	b0 05		bcs $b5ff		bcs 	_CINFailed 						; didn't work.
.b5fa	20 f1 c9	jsr $c9f1		jsr 	VariableSet 					; set variable.
.b5fd	80 88		bra $b587		bra 	_CILoop 						; go round again.
.b5ff					_CINFailed:
.b5ff	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.b601	8d c2 03	sta $03c2		sta 	InputAvailable
.b604	80 c0		bra $b5c6		bra 	_CINGetText 					; and try again
.b606					_CIIsString:
.b606	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.b608	20 e8 c3	jsr $c3e8		jsr 	AllocateTempString
.b60b	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.b60d	8d 14 03	sta $0314		sta 	NumBufX
.b610					_CISSkip:
.b610	20 65 b6	jsr $b665		jsr 	CIGetCharacter 					; get character skip spaces
.b613	c9 20		cmp #$20		cmp 	#" "
.b615	f0 f9		beq $b610		beq 	_CISSkip
.b617	80 03		bra $b61c		bra 	_CISInputProcess 				; handle that as the first character
.b619					_CISInput:
.b619	20 65 b6	jsr $b665		jsr 	CIGetCharacter
.b61c					_CISInputProcess:
.b61c	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.b61e	f0 31		beq $b651		beq 	_CISDone
.b620	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.b622	d0 05		bne $b629		bne 	_CISNotColon
.b624	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.b627	10 28		bpl $b651		bpl 	_CISDone 						; if quote flag zero, done
.b629					_CISNotColon:
.b629	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.b62b	f0 1a		beq $b647		beq 	_CISIsQuote						; if so handle that code.
.b62d	20 13 c4	jsr $c413		jsr 	WriteTempString 				; write to the temporary string
.b630	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.b633	10 e4		bpl $b619		bpl 	_CISInput
.b635	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b638	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>b640	6f 20 6c 6f 6e 67 00
.b647					_CISIsQuote:
.b647	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.b64a	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.b64c	8d 14 03	sta $0314		sta 	NumBufX
.b64f	d0 c8		bne $b619		bne 	_CISInput 						; if entered quote mode, get next character
.b651					_CISDone:
.b651	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.b653	85 80		sta $80			sta 	XS_Mantissa+0
.b655	a5 23		lda $23			lda 	zTempStr+1
.b657	85 81		sta $81			sta 	XS_Mantissa+1
.b659	a9 02		lda #$02		lda 	#2
.b65b	85 85		sta $85			sta 	XS_Type
.b65d	a2 00		ldx #$00		ldx 	#0
.b65f	20 f1 c9	jsr $c9f1		jsr 	VariableSet 					; set variable.
.b662	4c 87 b5	jmp $b587		jmp 	_CILoop 						; and try again
.b665					CIGetCharacter:
.b665	5a		phy			phy
.b666	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.b669	f0 0c		beq $b677		beq 	_CIGCNewLine 					; no, needs a new line.
.b66b	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.b66e	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.b670	f0 03		beq $b675		beq 	_CIGCNoInc
.b672	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.b675					_CIGCNoInc:
.b675	7a		ply			ply
.b676	60		rts			rts
.b677					_CIGCNewLine:
.b677	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.b67a	a9 3f		lda #$3f		lda 	#"?"
.b67c	20 61 ae	jsr $ae61		jsr 	VIOCharPrint
.b67f	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.b682	f0 03		beq $b687		beq 	_CIGCPrompt 					; if so, then print ? again
.b684	20 61 ae	jsr $ae61		jsr 	VIOCharPrint
.b687					_CIGCPrompt:
.b687	a0 01		ldy #$01		ldy 	#1
.b689	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.b68c					_CIGCBackOne:
.b68c	88		dey			dey
.b68d					_CIGCLoop:
.b68d	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.b68f	f0 fb		beq $b68c		beq 	_CIGCBackOne
.b691	20 64 ae	jsr $ae64		jsr 	VIOCharGet 						; get a character
.b694	f0 f7		beq $b68d		beq 	_CIGCLoop 						; wait until key pressed
.b696	c9 08		cmp #$08		cmp 	#8 								; backspace
.b698	f0 10		beq $b6aa		beq 	_CIGCBackSpace
.b69a	20 61 ae	jsr $ae61		jsr 	VIOCharPrint 					; echo character
.b69d	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.b6a0	c8		iny			iny
.b6a1	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.b6a3	d0 e8		bne $b68d		bne 	_CIGCLoop
.b6a5	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.b6a8	7a		ply			ply 									; restore Y
.b6a9	60		rts			rts
.b6aa					_CIGCBackSpace:
.b6aa	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.b6ac	f0 df		beq $b68d		beq 	_CIGCLoop
.b6ae	20 61 ae	jsr $ae61		jsr 	VIOCharPrint 					; echo BS
.b6b1	88		dey			dey 									; go back one.
.b6b2	80 d9		bra $b68d		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b6b4					Command_END:
.b6b4	80 fe		bra $b6b4	_halt:	bra 		_halt
.b6b6	4c 5a b1	jmp $b15a			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.b6b9					Command_IF:
.b6b9	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; check success.
.b6bc	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b6be	05 81		ora $81				ora 	XS_Mantissa+1
.b6c0	05 82		ora $82				ora 	XS_Mantissa+2
.b6c2	05 83		ora $83				ora 	XS_Mantissa+3
.b6c4	aa		tax				tax 								; put into X.
.b6c5	ea		nop				nop
.b6c6	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b6c8	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.b6ca	d0 30		bne $b6fc			bne 	_FIFExtended
.b6cc	1b		inz				inz
.b6cd	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.b6cf	f0 0c		beq $b6dd			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.b6d1	ea		nop				nop
.b6d2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b6d4	29 c0		and #$c0			and 	#$C0 						; is it a number
.b6d6	c9 40		cmp #$40			cmp 	#$40
.b6d8	d0 21		bne $b6fb			bne 	_FIFContinue 				; if not, do what ever follows.
.b6da	4c 65 ba	jmp $ba65			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.b6dd					_FIFEndOfLine:
.b6dd	ea		nop				nop
.b6de	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b6e0	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.b6e2	f0 17		beq $b6fb			beq 	_FIFContinue
.b6e4	ea		nop				nop
.b6e5	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b6e7	1b		inz				inz 								; skip
.b6e8	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b6ea	90 0d		bcc $b6f9			bcc 	_SEDone 					; so just skip over it.
.b6ec	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b6ee	90 08		bcc $b6f8			bcc 	_SEDouble
.b6f0	6b		tza				tza 								; this is Y + 1
.b6f1	18		clc				clc
.b6f2	ea		nop				nop
.b6f3	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b6f5	4b		taz				taz 								; back in Y.
.b6f6	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b6f7	3b		dez				dez
.b6f8					_SEDouble:
.b6f8	1b		inz				inz
.b6f9					_SEDone:
.b6f9	80 e2		bra $b6dd			bra 	_FIFEndOfLine
.b6fb					_FIFContinue:
.b6fb	60		rts				rts
.b6fc					_FIFExtended:
.b6fc	da		phx				phx 								; save result
.b6fd	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.b6ff	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.b702	68		pla				pla 								; restore result
.b703	f0 01		beq $b706			beq 	_FIXSkip 					; if zero then it has failed.
.b705	60		rts				rts 								; test passed, so continue executing
.b706					_FIXSkip:
.b706	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.b708	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.b70a	20 1c ad	jsr $ad1c			jsr 	StructureSearchDouble
.b70d	ea		nop				nop
.b70e	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b710	1b		inz				inz
.b711	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.b713	f0 07		beq $b71c			beq 	Command_ENDIF
.b715	60		rts				rts
.b716					Command_ELSE:
.b716	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.b718	20 1a ad	jsr $ad1a			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.b71b	1b		inz				inz
.b71c					Command_ENDIF:
.b71c	a9 40		lda #$40			lda 	#(SMark_If << 4)
.b71e	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b721	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b722					Command_LIST:
.b722	20 bb b8	jsr $b8bb			jsr 	ListGetRange				; get any parameters
.b725	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b727	85 18		sta $18				sta 	zCodePtr+0
.b729	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b72b	85 19		sta $19				sta 	zCodePtr+1
.b72d	a9 02		lda #$02			lda 	#2
.b72f	85 1a		sta $1a				sta 	zCodePtr+2
.b731	a9 00		lda #$00			lda 	#0
.b733	85 1b		sta $1b				sta 	zCodePtr+3
.b735	a3 03		ldz #$03			ldz 	#3
.b737	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.b739	8d bc 03	sta $03bc			sta 	LastListIndent
.b73c	8d bb 03	sta $03bb			sta 	ListIndent
.b73f					_CILLoop:
.b73f	a3 00		ldz #$00			ldz 	#0
.b741	ea		nop				nop
.b742	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b744	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b746	f0 24		beq $b76c			beq 	_CILExit
.b748	20 6f ae	jsr $ae6f			jsr 	VIOCheckBreak 				; check break
.b74b	c9 00		cmp #$00			cmp 	#0
.b74d	d0 1d		bne $b76c			bne 	_CILExit
.b74f	20 05 b9	jsr $b905			jsr 	ListCheckRange 				; check current line in range.
.b752	b0 08		bcs $b75c			bcs		_CILNext
.b754	a3 00		ldz #$00			ldz 	#0
.b756	1b		inz				inz
.b757	1b		inz				inz
.b758	1b		inz				inz
.b759	20 6f b7	jsr $b76f			jsr 	ListLine 					; list one line.
.b75c					_CILNext:
.b75c	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b75e	ea		nop				nop
.b75f	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b761	18		clc				clc
.b762	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b764	85 18		sta $18				sta 	zCodePtr
.b766	90 02		bcc $b76a			bcc 	_SNLNoCarry
.b768	e6 19		inc $19				inc 	zCodePtr+1
.b76a					_SNLNoCarry:
.b76a	80 d3		bra $b73f			bra 	_CILLoop
.b76c					_CILExit:
.b76c	4c 5a b1	jmp $b15a			jmp 	WarmStart
.b76f					ListLine:
.b76f	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.b772	8d bc 03	sta $03bc			sta 	LastListIndent
.b775					_LICountIndent:
.b775	ea		nop				nop
.b776	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b778	c9 00		cmp #$00			cmp 	#0
.b77a	f0 31		beq $b7ad			beq 	_LIDoneIndent
.b77c	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.b77e	90 16		bcc $b796			bcc 	_LICINext
.b780	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b782	b0 12		bcs $b796			bcs 	_LICINext
.b784	ee bb 03	inc $03bb			inc 	ListIndent
.b787	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.b789	90 0b		bcc $b796			bcc 	_LICINext
.b78b	ce bb 03	dec $03bb			dec 	ListIndent
.b78e	ce bb 03	dec $03bb			dec 	ListIndent
.b791	10 03		bpl $b796			bpl 	_LICINext
.b793	ee bb 03	inc $03bb			inc 	ListIndent
.b796					_LICINext:
.b796	ea		nop				nop
.b797	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b799	1b		inz				inz 								; skip
.b79a	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b79c	90 0d		bcc $b7ab			bcc 	_SEDone 					; so just skip over it.
.b79e	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b7a0	90 08		bcc $b7aa			bcc 	_SEDouble
.b7a2	6b		tza				tza 								; this is Y + 1
.b7a3	18		clc				clc
.b7a4	ea		nop				nop
.b7a5	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b7a7	4b		taz				taz 								; back in Y.
.b7a8	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b7a9	3b		dez				dez
.b7aa					_SEDouble:
.b7aa	1b		inz				inz
.b7ab					_SEDone:
.b7ab	80 c8		bra $b775			bra 	_LICountIndent
.b7ad					_LIDoneIndent:
.b7ad	a3 00		ldz #$00			ldz 	#0
.b7af	1b		inz				inz
.b7b0	ea		nop				nop
.b7b1	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7b3	85 80		sta $80				sta 	XS_Mantissa
.b7b5	1b		inz				inz
.b7b6	ea		nop				nop
.b7b7	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7b9	85 81		sta $81				sta 	XS_Mantissa+1
.b7bb	20 ec ae	jsr $aeec			jsr 	Print16BitInteger 			; print integer.
.b7be	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.b7c0	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.b7c3	cd bc 03	cmp $03bc			cmp 	LastListIndent
.b7c6	90 03		bcc $b7cb			bcc 	_LISmaller
.b7c8	ad bc 03	lda $03bc			lda 	LastListIndent
.b7cb					_LISmaller:
.b7cb	0a		asl a				asl 	a 							; double indent
.b7cc	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.b7ce	38		sec				sec
.b7cf	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.b7d1	aa		tax				tax 								; print spaces to column 6
.b7d2					_LISpace:
.b7d2	a9 20		lda #$20			lda 	#" "
.b7d4	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b7d7	e8		inx				inx
.b7d8	e0 06		cpx #$06			cpx 	#6
.b7da	d0 f6		bne $b7d2			bne 	_LISpace
.b7dc					_LIDecode:
.b7dc	1b		inz				inz
.b7dd	ea		nop				nop
.b7de	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7e0	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b7e2	f0 0f		beq $b7f3			beq 	_LIExit
.b7e4	30 12		bmi $b7f8			bmi 	_LIToken
.b7e6	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b7e8	b0 52		bcs $b83c			bcs 	_LIInteger
.b7ea	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b7ec	69 20		adc #$20			adc 	#$20
.b7ee	20 ab b8	jsr $b8ab			jsr 	ListPrintLC 				; print in LC
.b7f1	80 e9		bra $b7dc			bra 	_LIDecode
.b7f3					_LIExit:
.b7f3	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b7f5	4c ab b8	jmp $b8ab			jmp 	ListPrintLC
.b7f8					_LIToken:
.b7f8	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b7fa	90 4b		bcc $b847			bcc		_LICommandToken
.b7fc	48		pha				pha 								; save in case end
.b7fd	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b7ff	c9 fe		cmp #$fe			cmp 	#$FE
.b801	f0 17		beq $b81a			beq 	_LIPrint
.b803	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b805	c9 fd		cmp #$fd			cmp 	#$FD
.b807	f0 11		beq $b81a			beq 	_LIPrint
.b809	a9 52		lda #$52			lda 	#'R'						; must be REM
.b80b	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b80e	a9 45		lda #$45			lda 	#'E'
.b810	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b813	a9 4d		lda #$4d			lda 	#'M'
.b815	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b818	a2 20		ldx #$20			ldx 	#' '
.b81a					_LIPrint:
.b81a	8a		txa				txa
.b81b	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b81e	1b		inz				inz
.b81f	ea		nop				nop
.b820	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b822	aa		tax				tax 								; put in X
.b823	ca		dex				dex
.b824					_LILoop:
.b824	ca		dex				dex 								; exit when count reached zero.
.b825	f0 09		beq $b830			beq 	_LIEnd
.b827	1b		inz				inz
.b828	ea		nop				nop
.b829	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b82b	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b82e	80 f4		bra $b824			bra 	_LILoop
.b830	68		pla		_LIEnd:	pla 								; get A back
.b831	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b833	d0 a7		bne $b7dc			bne 	_LIDecode
.b835	a9 22		lda #$22			lda 	#'"'
.b837	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b83a	80 a0		bra $b7dc			bra 	_LIDecode
.b83c					_LIInteger:
.b83c	a2 00		ldx #$00			ldx 	#0
.b83e	20 a7 bc	jsr $bca7			jsr 	EvaluateGetInteger 			; get an atom
.b841	3b		dez				dez
.b842	20 f2 ae	jsr $aef2			jsr 	Print32BitInteger 			; print integer.
.b845	80 95		bra $b7dc			bra 	_LIDecode
.b847					_LICommandToken:
.b847	5a		phy				phy 								; save Y
.b848	48		pha				pha 								; save token
.b849	a2 ea		ldx #$ea			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b84b	a9 af		lda #$af			lda 	(#KeywordText >> 8) & $FF
.b84d	86 1c		stx $1c				stx 	zLTemp1
.b84f	85 1d		sta $1d				sta 	zLTemp1+1
.b851	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b853	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b855	68		pla				pla 								; get token
.b856	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.b858	f0 16		beq $b870			beq 	_LIFoundToken
.b85a	aa		tax				tax
.b85b					_LITokenLoop:
.b85b	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.b85d					_LIFindEnd:
.b85d	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.b85f	c8		iny				iny
.b860	0a		asl a				asl 	a
.b861	90 fa		bcc $b85d			bcc 	_LIFindEnd
.b863	98		tya				tya 								; that is step to the next
.b864	18		clc				clc 								; we don't bother bumping the 3rd byte
.b865	65 1c		adc $1c				adc 	zLTemp1 					; here.
.b867	85 1c		sta $1c				sta 	zLTemp1
.b869	90 02		bcc $b86d			bcc 	_LINoBump
.b86b	e6 1d		inc $1d				inc 	zLTemp1+1
.b86d					_LINoBump:
.b86d	ca		dex				dex 								; no go round again.
.b86e	d0 eb		bne $b85b			bne 	_LITokenLoop
.b870					_LIFoundToken:
.b870	a0 00		ldy #$00			ldy 	#0
.b872					_LIPrintToken:
.b872	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.b874	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.b876	d0 16		bne $b88e			bne 	_LINoPrefixSpace
.b878	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.b87a	90 12		bcc $b88e			bcc 	_LINoPrefixSpace
.b87c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b87e	b0 0e		bcs $b88e			bcs 	_LINoPrefixSpace
.b880	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.b883	e0 20		cpx #$20			cpx 	#" "
.b885	f0 07		beq $b88e			beq 	_LINoPrefixSpace
.b887	48		pha				pha
.b888	a9 20		lda #$20			lda 	#" "
.b88a	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b88d	68		pla				pla
.b88e					_LINoPrefixSpace:
.b88e	c8		iny				iny
.b88f	48		pha				pha 								; save it
.b890	29 7f		and #$7f			and 	#$7F
.b892	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b895	68		pla				pla
.b896	10 da		bpl $b872			bpl 	_LIPrintToken 				; go back if not end
.b898	7a		ply				ply 								; restore Y
.b899	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b89b	c9 41		cmp #$41			cmp 	#"A"
.b89d	90 09		bcc $b8a8			bcc 	_LINotLetter2
.b89f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b8a1	b0 05		bcs $b8a8			bcs 	_LINotLetter2
.b8a3	a9 20		lda #$20			lda 	#" " 						; add spacing
.b8a5	20 ab b8	jsr $b8ab			jsr 	ListPrintLC
.b8a8					_LINotLetter2:
.b8a8	4c dc b7	jmp $b7dc			jmp 	_LIDecode
.b8ab					ListPrintLC:
.b8ab	8d ba 03	sta $03ba			sta 	LastPrinted
.b8ae	c9 41		cmp #$41			cmp 	#"A"
.b8b0	90 06		bcc $b8b8			bcc 	_LPLC0
.b8b2	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b8b4	b0 02		bcs $b8b8			bcs 	_LPLC0
.b8b6	69 20		adc #$20			adc 	#$20
.b8b8	4c 61 ae	jmp $ae61	_LPLC0:	jmp 	VIOCharPrint
.b8bb					ListGetRange:
.b8bb	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.b8bd					_LGRClear:
.b8bd	a9 00		lda #$00			lda 	#0
.b8bf	95 80		sta $80,x			sta 	XS_Mantissa,x
.b8c1	ca		dex				dex
.b8c2	10 f9		bpl $b8bd			bpl 	_LGRClear
.b8c4	ea		nop				nop
.b8c5	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b8c7	c9 00		cmp #$00			cmp 	#0 							; nothing
.b8c9	f0 22		beq $b8ed			beq 	_LGRBlank
.b8cb	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.b8cd	f0 1e		beq $b8ed			beq 	_LGRBlank
.b8cf	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.b8d1	f0 19		beq $b8ec			beq 	_LGREnd 					; then it's LIST ,x
.b8d3	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; get the first number into bottom
.b8d6	ea		nop				nop
.b8d7	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b8d9	c9 bf		cmp #$bf			cmp 	#token_Comma
.b8db	f0 0f		beq $b8ec			beq 	_LGREnd 					; then it is LIST a,b
.b8dd	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.b8df	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.b8e1	a5 81		lda $81				lda 	XS_Mantissa+1
.b8e3	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b8e5					_LGRBumpExit:
.b8e5	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.b8e7	d0 02		bne $b8eb			bne 	_LGRBump2
.b8e9	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.b8eb					_LGRBump2:
.b8eb	60		rts				rts
.b8ec					_LGREnd:
.b8ec	1b		inz				inz
.b8ed					_LGRBlank:
.b8ed	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.b8ef	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.b8f1	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b8f3	ea		nop				nop
.b8f4	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b8f6	c9 00		cmp #$00			cmp 	#0
.b8f8	f0 f1		beq $b8eb			beq 	_LGRBump2
.b8fa	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.b8fb	b0 ee		bcs $b8eb			bcs 	_LGRBump2
.b8fd	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.b8ff	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX
.b902	80 e1		bra $b8e5			bra 	_LGRBumpExit
.b904	60		rts				rts
.b905					ListCheckRange:
.b905	1b		inz				inz
.b906	a2 00		ldx #$00			ldx 	#0 							; test low
.b908	20 15 b9	jsr $b915			jsr 	_LCRCompare
.b90b	90 06		bcc $b913			bcc 	_LCRFail
.b90d	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.b90f	20 15 b9	jsr $b915			jsr 	_LCRCompare
.b912	60		rts				rts
.b913					_LCRFail:
.b913	38		sec				sec
.b914	60		rts				rts
.b915					_LCRCompare:
.b915	ea		nop				nop
.b916	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b918	38		sec				sec
.b919	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.b91b	08		php				php
.b91c	1b		inz				inz
.b91d	ea		nop				nop
.b91e	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b920	28		plp				plp
.b921	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.b923	08		php				php
.b924	3b		dez				dez
.b925	28		plp				plp
.b926	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b927					Command_PRINT:
.b927					_CPR_Loop:
.b927	ea		nop				nop
.b928	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b92a	c9 00		cmp #$00			cmp 	#0 							; end
.b92c	f0 24		beq $b952			beq 	_CPR_GoNewLine
.b92e	c9 c0		cmp #$c0			cmp 	#token_Colon
.b930	f0 20		beq $b952			beq 	_CPR_GoNewLine
.b932	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b934	f0 74		beq $b9aa			beq 	_CPR_Skip
.b936	c9 bf		cmp #$bf			cmp 	#token_Comma
.b938	f0 57		beq $b991			beq 	_CPR_Tab
.b93a	20 9c bb	jsr $bb9c			jsr 	EvaluateExpression 			; get expression.
.b93d	a5 85		lda $85				lda 	XS_Type 					; get type.
.b93f	29 02		and #$02			and 	#2
.b941	d0 27		bne $b96a			bne 	_CPR_String 				; if type = 2 output as string.
.b943					_CPR_Number:
.b943	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b945	8d 14 03	sta $0314			sta 	NumBufX
.b948	a5 85		lda $85				lda 	XS_Type 					; get type
.b94a	4a		lsr a				lsr 	a
.b94b	b0 08		bcs $b955			bcs 	_CPRInt 					; if msb set do as integer
.b94d	20 b0 d0	jsr $d0b0			jsr 	FPToString 					; call fp to str otherwise
.b950	80 06		bra $b958			bra 	_CPRNPrint
.b952					_CPR_GoNewLine:
.b952	4c b9 b9	jmp $b9b9			jmp 	_CPR_NewLine
.b955	20 3a cb	jsr $cb3a	_CPRInt:jsr 	IntToString
.b958					_CPRNPrint:
.b958	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b95b	c9 2d		cmp #$2d			cmp 	#"-"
.b95d	f0 05		beq $b964			beq 	_CPRNoSpace
.b95f	a9 20		lda #$20			lda 	#" "						; print the leading space
.b961	20 61 ae	jsr $ae61			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.b964					_CPRNoSpace:
.b964	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b966	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b968	80 04		bra $b96e			bra 	_CPRPrint
.b96a					_CPR_String:
.b96a	a6 80		ldx $80				ldx 	XS_Mantissa
.b96c	a5 81		lda $81				lda 	XS_Mantissa+1
.b96e					_CPRPrint:
.b96e	86 20		stx $20				stx 	zGenPtr
.b970	85 21		sta $21				sta 	zGenPtr+1
.b972	5a		phy				phy
.b973	a0 00		ldy #$00			ldy 	#0							; get length into X
.b975	b1 20		lda ($20),y			lda 	(zGenPtr),y
.b977	aa		tax				tax
.b978	f0 09		beq $b983			beq 	_CPREndPrint 				; nothing to print
.b97a					_CPRLoop:
.b97a	c8		iny				iny
.b97b	b1 20		lda ($20),y			lda 	(zGenPtr),y
.b97d	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b980	ca		dex				dex
.b981	d0 f7		bne $b97a			bne 	_CPRLoop
.b983					_CPREndPrint:
.b983	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.b985	29 02		and #$02			and 	#2
.b987	d0 05		bne $b98e			bne 	_CPRNoTrail
.b989	a9 20		lda #$20			lda 	#" "
.b98b	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b98e					_CPRNoTrail:
.b98e	7a		ply				ply
.b98f	80 96		bra $b927			bra 	_CPR_Loop
.b991					_CPR_Tab:
.b991	20 72 ae	jsr $ae72			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.b994					_CPR_CalcSpaces:
.b994	38		sec				sec 								; calculate position mod 10.
.b995	e9 0a		sbc #$0a			sbc 	#10
.b997	b0 fb		bcs $b994			bcs 	_CPR_CalcSpaces
.b999	69 0a		adc #$0a			adc 	#10
.b99b	f0 0d		beq $b9aa			beq 	_CPR_Skip 					; nothing to print
.b99d	aa		tax				tax 								; print out spaces to mod 10
.b99e					_CPRTabSpaces:
.b99e	a9 20		lda #$20			lda 	#" "
.b9a0	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b9a3	e8		inx				inx
.b9a4	e0 0a		cpx #$0a			cpx 	#10
.b9a6	d0 f6		bne $b99e			bne 	_CPRTabSpaces
.b9a8	80 e7		bra $b991			bra 	_CPR_Tab
.b9aa					_CPR_Skip:
.b9aa	1b		inz				inz
.b9ab	ea		nop				nop
.b9ac	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b9ae	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b9b0	f0 0c		beq $b9be			beq 	_CPR_Exit
.b9b2	c9 00		cmp #$00			cmp 	#0
.b9b4	f0 08		beq $b9be			beq 	_CPR_Exit 					; if not go round again.
.b9b6	4c 27 b9	jmp $b927			jmp 	_CPR_Loop
.b9b9					_CPR_NewLine:
.b9b9	a9 0d		lda #$0d			lda 	#13
.b9bb	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b9be					_CPR_Exit:
.b9be	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b9bf					Command_ASSERT:
.b9bf	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.b9c2	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b9c4	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b9c6	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b9c8	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b9ca	f0 01		beq $b9cd			beq 	_ASFail
.b9cc	60		rts				rts
.b9cd					_ASFail:
.b9cd	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b9d0	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.b9d7					Command_POKE:
.b9d7	a9 01		lda #$01			lda 	#1 							; 1 byte
.b9d9	80 06		bra $b9e1			bra 	CmdPoke_Main
.b9db					Command_DOKE:
.b9db	a9 02		lda #$02			lda 	#2 							; 2 bytes
.b9dd	80 02		bra $b9e1			bra 	CmdPoke_Main
.b9df					Command_LOKE:
.b9df	a9 04		lda #$04			lda 	#4							; 4 bytes
.b9e1					CmdPoke_Main:
.b9e1	48		pha				pha
.b9e2	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; get two parameters. First is address
.b9e5	e8		inx				inx
.b9e6	e8		inx				inx
.b9e7	e8		inx				inx
.b9e8	e8		inx				inx
.b9e9	e8		inx				inx
.b9ea	e8		inx				inx
.b9eb	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma
.b9ee	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX 			; second is the data.
.b9f1	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.b9f3	85 1c		sta $1c				sta 	zLTemp1
.b9f5	a5 81		lda $81				lda 	XS_Mantissa+1
.b9f7	85 1d		sta $1d				sta 	zLTemp1+1
.b9f9	a5 82		lda $82				lda 	XS_Mantissa+2
.b9fb	85 1e		sta $1e				sta 	zLTemp1+2
.b9fd	a5 83		lda $83				lda 	XS_Mantissa+3
.b9ff	85 1f		sta $1f				sta 	zLTemp1+3
.ba01	68		pla				pla 								; get count
.ba02	5a		phy				phy 								; save Y
.ba03	20 24 c3	jsr $c324			jsr 	MemWrite 					; write it out
.ba06	7a		ply				ply 								; restore Y and done.
.ba07	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.ba08					Command_NEW:
.ba08	a9 00		lda #$00			lda 	#BasicProgram & $FF
.ba0a	85 18		sta $18				sta 	zCodePtr+0
.ba0c	a9 80		lda #$80			lda 	#BasicProgram >> 8
.ba0e	85 19		sta $19				sta 	zCodePtr+1
.ba10	a9 02		lda #$02			lda 	#2
.ba12	85 1a		sta $1a				sta 	zCodePtr+2
.ba14	a9 00		lda #$00			lda 	#0
.ba16	85 1b		sta $1b				sta 	zCodePtr+3
.ba18	a3 03		ldz #$03			ldz 	#3
.ba1a	a3 00		ldz #$00			ldz 	#0
.ba1c	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.ba1e	ea		nop				nop
.ba1f	92 18		sta ($18),z			sta 	(zCodePtr),z
.ba21	20 38 c3	jsr $c338			jsr 	UpdateProgramEnd 			; update program end.
.ba24	4c 5a b1	jmp $b15a			jmp 	WarmStart 					; and always warmstart, can't be running program.
.ba27					Command_OLD:
.ba27	a9 00		lda #$00			lda 	#BasicProgram & $FF
.ba29	85 18		sta $18				sta 	zCodePtr+0
.ba2b	a9 80		lda #$80			lda 	#BasicProgram >> 8
.ba2d	85 19		sta $19				sta 	zCodePtr+1
.ba2f	a9 02		lda #$02			lda 	#2
.ba31	85 1a		sta $1a				sta 	zCodePtr+2
.ba33	a9 00		lda #$00			lda 	#0
.ba35	85 1b		sta $1b				sta 	zCodePtr+3
.ba37	a3 03		ldz #$03			ldz 	#3
.ba39					_COL_Find:
.ba39	ea		nop				nop
.ba3a	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ba3c	1b		inz				inz
.ba3d	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.ba3f	f0 18		beq $ba59			beq 	_COL_Found
.ba41	6b		tza				tza
.ba42	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.ba44	d0 f3		bne $ba39			bne 	_COL_Find 					; can't find old EOL, give up.
.ba46	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ba49	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>ba51	43 6f 72 72 75 70 74 00
.ba59					_COL_Found:
.ba59	6b		tza				tza
.ba5a	48		pha				pha
.ba5b	a3 00		ldz #$00			ldz 	#0
.ba5d	68		pla				pla
.ba5e	ea		nop				nop
.ba5f	92 18		sta ($18),z			sta 	(zCodePtr),z
.ba61	20 38 c3	jsr $c338			jsr 	UpdateProgramEnd 			; reset variable pointer
.ba64	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.ba65					Command_GOTO:
.ba65	20 bb ba	jsr $babb			jsr 	GotoGetLineNumber 			; get line number
.ba68					CmdGOTO:
.ba68	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.ba6a	4c d8 ba	jmp $bad8			jmp 	GotoChangeToLineNumberX
.ba6d					Command_GOSUB:
.ba6d	20 bb ba	jsr $babb			jsr 	GotoGetLineNumber 			; get line number
.ba70					CmdGOSUB:
.ba70	20 28 ae	jsr $ae28			jsr 	StackSavePosition 			; save position on stack and push frame
.ba73	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.ba75	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.ba78	a2 00		ldx #$00			ldx		#0 							; go to that line number
.ba7a	4c d8 ba	jmp $bad8			jmp 	GotoChangeToLineNumberX
.ba7d					Command_RETURN:
.ba7d	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.ba7f	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.ba82	20 45 ae	jsr $ae45			jsr 	StackRestorePosition 		; restore position.
.ba85	60		rts				rts
.ba86					Command_ON:
.ba86	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.ba88	20 e4 c1	jsr $c1e4			jsr 	SLIByteParameter
.ba8b	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.ba8d	f0 29		beq $bab8			beq 	_CONFail 					; can't be zero, error if it is.
.ba8f	aa		tax				tax 								; save in X.
.ba90	ea		nop				nop
.ba91	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ba93	1b		inz				inz
.ba94	48		pha				pha 								; so we can check what we're doing later.
.ba95	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.ba97	f0 07		beq $baa0			beq 	_CONOkayToken
.ba99	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.ba9b	f0 03		beq $baa0			beq 	_CONOkayToken
.ba9d	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.baa0					_CONOkayToken:
.baa0	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.baa1					_CONFindNumber:
.baa1	20 bb ba	jsr $babb			jsr 	GotoGetLineNumber 			; get a line number.
.baa4	fa		plx				plx 								; restore count
.baa5	ca		dex				dex  								; decrement, exit if zero.
.baa6	f0 06		beq $baae			beq 	_CONFound
.baa8	da		phx				phx 								; push back
.baa9	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma				; check for comma
.baac	80 f3		bra $baa1			bra 	_CONFindNumber 				; go round again.
.baae					_CONFound:
.baae	68		pla				pla 								; get token to decide what to do
.baaf	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.bab1	f0 b5		beq $ba68			beq		CmdGOTO 					; then just branch.
.bab3	20 ac ad	jsr $adac			jsr 	SkipEndOfCommand 			; go to end of command
.bab6	80 b8		bra $ba70			bra 	CmdGOSUB 					; and do a GOSUB.
.bab8					_CONFail:
.bab8	4c 97 ae	jmp $ae97			jmp 	BadParamError
.babb					GotoGetLineNumber:
.babb	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; get integer into mantissa.0
.babe	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.bac0	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.bac2	d0 01		bne $bac5			bne 	_GLINError
.bac4	60		rts				rts
.bac5					_GLINError:
.bac5	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bac8	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>bad0	20 4e 75 6d 62 65 72 00
.bad8					GotoChangeToLineNumberX:
.bad8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.bada	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.badc	f0 3d		beq $bb1b			beq 	_GCTLFail 					; if so, no can do.
.bade	a9 00		lda #$00			lda 	#BasicProgram & $FF
.bae0	85 18		sta $18				sta 	zCodePtr+0
.bae2	a9 80		lda #$80			lda 	#BasicProgram >> 8
.bae4	85 19		sta $19				sta 	zCodePtr+1
.bae6	a9 02		lda #$02			lda 	#2
.bae8	85 1a		sta $1a				sta 	zCodePtr+2
.baea	a9 00		lda #$00			lda 	#0
.baec	85 1b		sta $1b				sta 	zCodePtr+3
.baee	a3 03		ldz #$03			ldz 	#3
.baf0					_GCTLLoop:
.baf0	a3 00		ldz #$00			ldz 	#0
.baf2	ea		nop				nop
.baf3	b2 18		lda ($18),z			lda 	(zCodePtr),z
.baf5	c9 00		cmp #$00			cmp 	#0
.baf7	f0 22		beq $bb1b			beq 	_GCTLFail
.baf9	1b		inz				inz
.bafa	ea		nop				nop
.bafb	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bafd	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.baff	d0 08		bne $bb09			bne 	_GCTLNext
.bb01	1b		inz				inz
.bb02	ea		nop				nop
.bb03	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb05	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.bb07	f0 10		beq $bb19			beq 	_GCTLExit
.bb09					_GCTLNext:
.bb09	a3 00		ldz #$00			ldz 	#0 							; point to offset
.bb0b	ea		nop				nop
.bb0c	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.bb0e	18		clc				clc
.bb0f	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.bb11	85 18		sta $18				sta 	zCodePtr
.bb13	90 02		bcc $bb17			bcc 	_SNLNoCarry
.bb15	e6 19		inc $19				inc 	zCodePtr+1
.bb17					_SNLNoCarry:
.bb17	80 d7		bra $baf0			bra 	_GCTLLoop 					; try next line.
.bb19					_GCTLExit:
.bb19	1b		inz				inz
.bb1a	60		rts				rts
.bb1b					_GCTLFail:
.bb1b	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bb1e	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>bb26	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.bb2e					Command_CLR:
.bb2e					ResetRunStatus:
.bb2e	20 92 c6	jsr $c692			jsr 	VariableClear
.bb31	20 cf ad	jsr $adcf			jsr 	StackReset
.bb34	a9 00		lda #$00			lda 	#HighMemory & $FF
.bb36	8d 00 03	sta $0300			sta 	StringPtr
.bb39	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.bb3b	8d 01 03	sta $0301			sta 	StringPtr+1
.bb3e	20 5e c8	jsr $c85e			jsr 	ArrayResetDefault
.bb41	20 57 b4	jsr $b457			jsr 	Command_RESTORE
.bb44	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.bb45					Command_STOP:
.bb45	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bb48	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.bb4d					Command_WHILE:
.bb4d	20 28 ae	jsr $ae28			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.bb50	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 			; calculate the while loop value.
.bb53	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.bb55	05 81		ora $81				ora 	XS_Mantissa+1
.bb57	05 82		ora $82				ora 	XS_Mantissa+2
.bb59	05 83		ora $83				ora 	XS_Mantissa+3
.bb5b	f0 06		beq $bb63			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.bb5d	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.bb5f	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push on stack
.bb62	60		rts				rts
.bb63					_CWHSkip:
.bb63	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.bb65	20 1a ad	jsr $ad1a			jsr 	StructureSearchSingle
.bb68	1b		inz				inz
.bb69	60		rts				rts
.bb6a					Command_WEND:
.bb6a	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.bb6c	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.bb6f	20 45 ae	jsr $ae45			jsr 	StackRestorePosition
.bb72	80 d9		bra $bb4d			bra 	Command_WHILE 				; and do the while again.
.bb74	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.bb75					Command_REPEAT:
.bb75	20 28 ae	jsr $ae28			jsr 	StackSavePosition			; save position into stack
.bb78	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.bb7a	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push on stack
.bb7d	60		rts				rts
.bb7e					Command_UNTIL:
.bb7e	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.bb80	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.bb83	20 39 bd	jsr $bd39			jsr 	EvaluateInteger				; work out the UNTIL expression.
.bb86	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.bb88	05 81		ora $81				ora 	XS_Mantissa+1
.bb8a	05 82		ora $82				ora 	XS_Mantissa+2
.bb8c	05 83		ora $83				ora 	XS_Mantissa+3
.bb8e	d0 08		bne $bb98			bne 	_CUTExit 					; if not, just exit
.bb90	20 45 ae	jsr $ae45			jsr 	StackRestorePosition 		; otherwise loop round again.
.bb93	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.bb95	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.bb98					_CUTExit:
.bb98	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.bb99					EVESyntax:
.bb99	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.bb9c					EvaluateExpression:
.bb9c	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.bb9e					EvaluateExpressionX:
.bb9e	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.bba0					EvaluateExpressionXA:
.bba0	48		pha				pha 								; save precedence on stack.
.bba1	ea		nop				nop
.bba2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bba4	f0 f3		beq $bb99			beq 	EVESyntax 					; end of line, syntax error.
.bba6	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.bba8	b0 03		bcs $bbad			bcs 	_EVNotVariable
.bbaa	4c 79 bc	jmp $bc79			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.bbad					_EVNotVariable:
.bbad	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.bbaf	90 e8		bcc $bb99			bcc 	EVESyntax
.bbb1	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.bbb3	b0 59		bcs $bc0e			bcs 	_EVNotInteger
.bbb5	20 a7 bc	jsr $bca7			jsr 	EvaluateGetInteger
.bbb8					_EVCheckDecimal:
.bbb8	ea		nop				nop
.bbb9	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbbb	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.bbbd	d0 05		bne $bbc4			bne 	_EVGotAtom 					; no, get atom.
.bbbf					_EVIsDecimal:
.bbbf	20 cf bc	jsr $bccf			jsr 	EVGetDecimal 				; extend to the decimal part.
.bbc2	80 00		bra $bbc4			bra 	_EVGotAtom 					; and continue to got atom.
.bbc4					_EVGotAtom:
.bbc4	ea		nop				nop
.bbc5	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbc7	10 43		bpl $bc0c			bpl 	_EVExitDrop 				; must be a token.
.bbc9	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.bbcb	b0 3f		bcs $bc0c			bcs 	_EVExitDrop
.bbcd	68		pla				pla 								; get current precedence
.bbce	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.bbd0	da		phx				phx 								; save X
.bbd1	ea		nop				nop
.bbd2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbd4	aa		tax				tax 								; put in X
.bbd5	bd 5b af	lda $af5b,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.bbd8	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.bbda	fa		plx				plx 								; restore X
.bbdb	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.bbdd	90 2e		bcc $bc0d			bcc 	_EVExit 					; exit if too low.
.bbdf	f0 2c		beq $bc0d			beq 	_EVExit 					; exit if equals
.bbe1	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.bbe3	48		pha				pha
.bbe4	ea		nop				nop
.bbe5	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbe7	48		pha				pha
.bbe8	1b		inz				inz
.bbe9	da		phx				phx 								; save current position
.bbea	e8		inx				inx
.bbeb	e8		inx				inx
.bbec	e8		inx				inx
.bbed	e8		inx				inx
.bbee	e8		inx				inx
.bbef	e8		inx				inx
.bbf0	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.bbf2	20 a0 bb	jsr $bba0			jsr 	EvaluateExpressionXA 		; do the RHS.
.bbf5	fa		plx				plx 								; restore X
.bbf6	68		pla				pla 								; get the binary operator in A.
.bbf7					_EVCallA:
.bbf7	da		phx				phx 								; save X again
.bbf8	0a		asl a				asl 	a 							; double, lose the MSB.
.bbf9	aa		tax				tax									; put in X
.bbfa	bd 0a af	lda $af0a,x			lda 	VectorTable,x 				; copy address into zGenPtr
.bbfd	8d 11 03	sta $0311			sta 	LocalVector+1
.bc00	bd 0b af	lda $af0b,x			lda 	VectorTable+1,x
.bc03	8d 12 03	sta $0312			sta 	LocalVector+2
.bc06	fa		plx				plx 								; restore X
.bc07	20 82 bc	jsr $bc82			jsr 	EVCallLocalVector
.bc0a	80 b8		bra $bbc4			bra 	_EVGotAtom 					; and loop back.
.bc0c					_EVExitDrop:
.bc0c	68		pla				pla
.bc0d					_EVExit:
.bc0d	60		rts				rts
.bc0e					_EVNotInteger:
.bc0e	1b		inz				inz
.bc0f	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.bc11	d0 16		bne $bc29			bne 	_EVNotMinus
.bc13	20 1a bd	jsr $bd1a			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.bc16	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bc18	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bc1a	f0 05		beq $bc21			beq 	_EVMinusFloat
.bc1c	20 1d cb	jsr $cb1d			jsr 	IntegerNegateAlways 		; negation
.bc1f	80 a3		bra $bbc4			bra 	_EVGotAtom 					; and go back.
.bc21					_EVMinusFloat:
.bc21	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.bc23	49 80		eor #$80			eor 	#$80
.bc25	95 85		sta $85,x			sta 	XS_Type,x
.bc27	80 9b		bra $bbc4			bra 	_EVGotAtom
.bc29					_EVNotMinus:
.bc29	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.bc2b	d0 18		bne $bc45			bne 	_EVNotParenthesis
.bc2d	20 9e bb	jsr $bb9e			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.bc30	ea		nop				nop
.bc31	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc33	1b		inz				inz
.bc34	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.bc36	f0 8c		beq $bbc4			beq 	_EVGotAtom
.bc38	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bc3b	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>bc43	29 00
.bc45					_EVNotParenthesis:
.bc45	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.bc47	d0 0c		bne $bc55			bne 	_EVNotNot
.bc49	20 1a bd	jsr $bd1a			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.bc4c	20 b1 cf	jsr $cfb1			jsr 	FPUToInteger 				; make it an integer - if possible.
.bc4f	20 ff bc	jsr $bcff			jsr 	NotInteger 					; do the not calculation
.bc52	4c c4 bb	jmp $bbc4			jmp 	_EVGotAtom
.bc55					_EVNotNot:
.bc55	c9 fe		cmp #$fe			cmp 	#$FE
.bc57	d0 12		bne $bc6b			bne 	_EVNotString
.bc59	20 23 c4	jsr $c423			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.bc5c	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.bc5e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc60	a5 23		lda $23				lda 	zTempStr+1
.bc62	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc64	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.bc66	95 85		sta $85,x			sta 	XS_Type,x
.bc68	4c c4 bb	jmp $bbc4			jmp 	_EVGotAtom
.bc6b					_EVNotString:
.bc6b	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.bc6d	90 04		bcc $bc73			bcc 	_EVBadElement
.bc6f	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.bc71	90 03		bcc $bc76			bcc 	_EVUnaryFunction
.bc73					_EVBadElement:
.bc73	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.bc76					_EVUnaryFunction:
.bc76	4c f7 bb	jmp $bbf7			jmp 	_EVCallA
.bc79					_EVVariableHandler:
.bc79	20 56 c6	jsr $c656			jsr 	VariableFind 				; locate a variable
.bc7c	20 a0 c9	jsr $c9a0			jsr 	VariableGet 				; copy into memory.
.bc7f	4c c4 bb	jmp $bbc4			jmp 	_EVGotAtom 					; and go round.
.bc82					EVCallLocalVector:
.bc82	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.bc85					EVShiftMantissaLeft6:
.bc85	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.bc87	95 84		sta $84,x			sta 	XS_Exponent,x
.bc89	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bc8b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bc8d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc8f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bc91	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bc93	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc95	a9 00		lda #$00			lda 	#0
.bc97	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc99	20 9c bc	jsr $bc9c			jsr 	_EVSMLShift 					; call it here to do it twice
.bc9c					_EVSMLShift:
.bc9c	56 84		lsr $84,x			lsr 	XS_Exponent,x
.bc9e	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.bca0	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.bca2	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.bca4	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.bca6	60		rts				rts
.bca7					EvaluateGetInteger:
.bca7	ea		nop				nop
.bca8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bcaa	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.bcac	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.bcae	a9 00		lda #$00			lda 	#0
.bcb0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bcb2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bcb4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bcb6	1a		inc a				inc 	a 							; set to type 1 (integer)
.bcb7	95 85		sta $85,x			sta 	XS_Type,x
.bcb9					_EVCheckNextInteger:
.bcb9	1b		inz				inz
.bcba	ea		nop				nop
.bcbb	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bcbd	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.bcbf	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.bcc1	b0 0b		bcs $bcce			bcs 	_EVEndInteger
.bcc3	48		pha				pha 								; save it.
.bcc4	20 85 bc	jsr $bc85			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.bcc7	68		pla				pla
.bcc8	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.bcca	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bccc	80 eb		bra $bcb9			bra 	_EVCheckNextInteger
.bcce					_EVEndInteger:
.bcce	60		rts				rts
.bccf					EVGetDecimal:
.bccf	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.bcd1	8d 15 03	sta $0315			sta 	Num_Buffer
.bcd4	da		phx				phx
.bcd5	1b		inz				inz
.bcd6	ea		nop				nop
.bcd7	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bcd9	1b		inz				inz
.bcda	3a		dec a				dec 	a								; convert to a string length.
.bcdb	3a		dec a				dec 	a
.bcdc	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.bcde					_EVGDCopy:
.bcde	48		pha				pha 									; save count
.bcdf	ea		nop				nop
.bce0	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bce2	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.bce5	e8		inx				inx 									; forward ....
.bce6	1b		inz				inz
.bce7	68		pla				pla 									; get count
.bce8	3a		dec a				dec 	a 								; until zero
.bce9	d0 f3		bne $bcde			bne 	_EVGDCopy
.bceb	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.bcee	fa		plx				plx 									; restore X
.bcef	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.bcf1	85 20		sta $20				sta 	zGenPtr
.bcf3	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.bcf5	85 21		sta $21				sta 	zGenPtr+1
.bcf7	5a		phy				phy 									; save Y
.bcf8	a0 00		ldy #$00			ldy 	#0 								; start position
.bcfa	20 6b d1	jsr $d16b			jsr 	FPFromString 					; convert current
.bcfd	7a		ply				ply 									; restore Y
.bcfe	60		rts				rts
.bcff					NotInteger:
.bcff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bd01	49 ff		eor #$ff			eor 	#$FF
.bd03	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd05	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd07	49 ff		eor #$ff			eor 	#$FF
.bd09	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd0b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bd0d	49 ff		eor #$ff			eor 	#$FF
.bd0f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd11	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bd13	49 ff		eor #$ff			eor 	#$FF
.bd15	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd17	60		rts				rts
.bd18					EvaluateGetAtom:
.bd18	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.bd1a					EvaluateGetAtomX:
.bd1a	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.bd1c	20 a0 bb	jsr $bba0			jsr 	EvaluateExpressionXA
.bd1f	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.bd21	29 0f		and #$0f			and 	#15
.bd23	c9 02		cmp #$02			cmp 	#2
.bd25	b0 01		bcs $bd28			bcs 	EvaluateType
.bd27	60		rts				rts
.bd28					EvaluateType:
.bd28	4c 89 ae	jmp $ae89			jmp 	TypeError
.bd2b					EvaluateNumber:
.bd2b	a2 00		ldx #$00			ldx 	#0
.bd2d					EvaluateNumberX:
.bd2d	20 9e bb	jsr $bb9e			jsr 	EvaluateExpressionX
.bd30	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.bd32	29 0f		and #$0f			and 	#15
.bd34	c9 02		cmp #$02			cmp 	#2
.bd36	b0 f0		bcs $bd28			bcs 	EvaluateType
.bd38	60		rts				rts
.bd39					EvaluateInteger:
.bd39	a2 00		ldx #$00			ldx 	#0
.bd3b					EvaluateIntegerX:
.bd3b	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX
.bd3e	20 b1 cf	jsr $cfb1			jsr 	FPUToInteger
.bd41	60		rts				rts
.bd42					EvaluateString:
.bd42	a2 00		ldx #$00			ldx 	#0
.bd44					EvaluateStringX:
.bd44	20 9e bb	jsr $bb9e			jsr 	EvaluateExpressionX
.bd47	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.bd49	29 0f		and #$0f			and 	#15
.bd4b	c9 02		cmp #$02			cmp 	#2
.bd4d	d0 d9		bne $bd28			bne 	EvaluateType
.bd4f	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.bd51	85 20		sta $20				sta 	zGenPtr
.bd53	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd55	85 21		sta $21				sta 	zGenPtr+1
.bd57	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.bd58					BinaryOp_And:
.bd58	20 ac bd	jsr $bdac			jsr 	BinaryMakeBothInteger
.bd5b	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bd5d	35 86		and $86,x			and 	XS2_Mantissa+0,x
.bd5f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd61	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bd63	35 87		and $87,x			and 	XS2_Mantissa+1,x
.bd65	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd67	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bd69	35 88		and $88,x			and 	XS2_Mantissa+2,x
.bd6b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd6d	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bd6f	35 89		and $89,x			and 	XS2_Mantissa+3,x
.bd71	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd73	60		rts				rts
.bd74					BinaryOp_Or:
.bd74	20 ac bd	jsr $bdac			jsr 	BinaryMakeBothInteger
.bd77	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bd79	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.bd7b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd7d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bd7f	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.bd81	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd83	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bd85	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.bd87	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd89	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bd8b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.bd8d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd8f	60		rts				rts
.bd90					BinaryOp_Eor:
.bd90					BinaryOp_Xor:
.bd90	20 ac bd	jsr $bdac			jsr 	BinaryMakeBothInteger
.bd93	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bd95	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.bd97	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd99	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bd9b	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.bd9d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd9f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bda1	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.bda3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bda5	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bda7	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.bda9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bdab	60		rts				rts
.bdac					BinaryMakeBothInteger:
.bdac	da		phx				phx 								; save X
.bdad	e8		inx				inx
.bdae	e8		inx				inx
.bdaf	e8		inx				inx
.bdb0	e8		inx				inx
.bdb1	e8		inx				inx
.bdb2	e8		inx				inx
.bdb3	20 b7 bd	jsr $bdb7			jsr 	BinaryMakeInteger 			; convert to integer.
.bdb6	fa		plx				plx 								; restore X and fall through.
.bdb7					BinaryMakeInteger:
.bdb7	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.bdb9	29 0f		and #$0f			and 	#15 						; check type zero
.bdbb	f0 04		beq $bdc1			beq 	_BMIConvert 				; if float convert to integer.
.bdbd	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.bdbe	90 04		bcc $bdc4			bcc 	_BMIError
.bdc0	60		rts				rts
.bdc1					_BMIConvert:
.bdc1	4c b1 cf	jmp $cfb1			jmp 	FPUToInteger 				; convert to integer
.bdc4					_BMIError:
.bdc4	4c 89 ae	jmp $ae89			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.bdc7					Binary_Equal:
.bdc7	20 10 be	jsr $be10			jsr 	CompareValues 				; compare the values
.bdca	09 00		ora #$00			ora 	#0 							; true if 0
.bdcc	f0 33		beq $be01			beq 	CCTrue
.bdce	80 2d		bra $bdfd			bra 	CCFalse
.bdd0					Binary_NotEqual:
.bdd0	20 10 be	jsr $be10			jsr 	CompareValues
.bdd3	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.bdd5	f0 26		beq $bdfd			beq 	CCFalse
.bdd7	80 28		bra $be01			bra 	CCTrue
.bdd9					Binary_Less:
.bdd9	20 10 be	jsr $be10			jsr 	CompareValues
.bddc	09 00		ora #$00			ora 	#0 							; true if -1
.bdde	30 21		bmi $be01			bmi 	CCTrue
.bde0	80 1b		bra $bdfd			bra 	CCFalse
.bde2					Binary_LessEqual:
.bde2	20 10 be	jsr $be10			jsr 	CompareValues
.bde5	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.bde7	d0 18		bne $be01			bne 	CCTrue
.bde9	80 12		bra $bdfd			bra 	CCFalse
.bdeb					Binary_GreaterEqual:
.bdeb	20 10 be	jsr $be10			jsr 	CompareValues
.bdee	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.bdf0	10 0f		bpl $be01			bpl 	CCTrue
.bdf2	80 09		bra $bdfd			bra 	CCFalse
.bdf4					Binary_Greater:
.bdf4	20 10 be	jsr $be10			jsr 	CompareValues 				; true if 1
.bdf7	c9 01		cmp #$01			cmp 	#1
.bdf9	f0 06		beq $be01			beq 	CCTrue
.bdfb	80 00		bra $bdfd			bra 	CCFalse
.bdfd	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.bdff	80 02		bra $be03			bra 	CCWrite
.be01	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.be03	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.be05	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.be07	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.be09	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.be0b	a9 01		lda #$01			lda 	#1
.be0d	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.be0f	60		rts				rts
.be10					CompareValues:
.be10	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.be12	35 8b		and $8b,x			and 	XS2_Type,x
.be14	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.be16	f0 11		beq $be29			beq 	_CVString					; comparison routine.
.be18	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.be1a	35 8b		and $8b,x			and 	XS2_Type,x
.be1c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.be1d	90 03		bcc $be22			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.be1f	4c 6b be	jmp $be6b			jmp 	CompareInteger32 							; so execute code at \1
.be22					_BCFloat:
.be22	20 0f bf	jsr $bf0f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.be25	4c aa ce	jmp $ceaa			jmp 	FPCompare 							; and execute code at \2
.be28	60		rts				rts
.be29					_CVString:
.be29	da		phx				phx 								; save XY
.be2a	5a		phy				phy
.be2b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.be2d	85 1c		sta $1c				sta		zLTemp1+0
.be2f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.be31	85 1d		sta $1d				sta 	zLTemp1+1
.be33	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.be35	85 1e		sta $1e				sta 	zLTemp1+2
.be37	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.be39	85 1f		sta $1f				sta 	zLTemp1+3
.be3b	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.be3d	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.be3f	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.be41	90 02		bcc $be45			bcc 	_CVCommon
.be43	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.be45					_CVCommon:
.be45	aa		tax				tax 								; put shorter string length in zero.
.be46	f0 0c		beq $be54			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.be48					_CVCompare:
.be48	c8		iny				iny 								; next character
.be49	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.be4b	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.be4d	90 13		bcc $be62			bcc 	_CVReturnLess 				; <
.be4f	d0 15		bne $be66			bne 	_CVReturnGreater 			; >
.be51	ca		dex				dex 								; until common length matched.
.be52	d0 f4		bne $be48			bne 	_CVCompare
.be54					_CVMatch:
.be54	a0 00		ldy #$00			ldy 	#0
.be56	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.be58	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.be5a	90 06		bcc $be62			bcc 	_CVReturnLess 				; <
.be5c	d0 08		bne $be66			bne 	_CVReturnGreater 			; >
.be5e	a9 00		lda #$00			lda 	#0
.be60	80 06		bra $be68			bra 	_CVExit
.be62					_CVReturnLess:
.be62	a9 ff		lda #$ff			lda 	#$FF
.be64	80 02		bra $be68			bra 	_CVExit
.be66					_CVReturnGreater:
.be66	a9 01		lda #$01			lda 	#$01
.be68					_CVExit:
.be68	7a		ply				ply
.be69	fa		plx				plx
.be6a	60		rts				rts
.be6b					CompareInteger32:
.be6b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.be6d	49 80		eor #$80			eor 	#$80
.be6f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.be71	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.be73	49 80		eor #$80			eor 	#$80
.be75	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.be77	20 f5 be	jsr $bef5			jsr 	SubInteger32 				; subtraction
.be7a	90 0d		bcc $be89			bcc 	_CI32Less 					; cc return -1
.be7c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.be7e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.be80	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.be82	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.be84	f0 02		beq $be88			beq 	_CI32Exit
.be86	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.be88					_CI32Exit:
.be88	60		rts				rts
.be89					_CI32Less:
.be89	a9 ff		lda #$ff			lda 	#$FF
.be8b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.be8c					BinaryOp_Add:
.be8c	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.be8e	35 8b		and $8b,x			and 	XS2_Type,x
.be90	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.be92	d0 11		bne $bea5			bne 	_BOAString 					; so go do the string code.
.be94	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.be96	35 8b		and $8b,x			and 	XS2_Type,x
.be98	4a		lsr a				lsr 	a 							; shift bit 0 into C
.be99	90 03		bcc $be9e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.be9b	4c db be	jmp $bedb			jmp 	AddInteger32 							; so execute code at \1
.be9e					_BCFloat:
.be9e	20 0f bf	jsr $bf0f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bea1	4c 85 cc	jmp $cc85			jmp 	FPAdd 							; and execute code at \2
.bea4	60		rts				rts
.bea5					_BOAString:
.bea5	4c 29 bf	jmp $bf29			jmp 	ConcatenateString 			; concatenate two strings.
.bea8					BinaryOp_Subtract:
.bea8	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.beaa	35 8b		and $8b,x			and 	XS2_Type,x
.beac	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bead	90 03		bcc $beb2			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.beaf	4c f5 be	jmp $bef5			jmp 	SubInteger32 							; so execute code at \1
.beb2					_BCFloat:
.beb2	20 0f bf	jsr $bf0f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.beb5	4c 7d cc	jmp $cc7d			jmp 	FPSubtract 							; and execute code at \2
.beb8	60		rts				rts
.beb9					BinaryOp_Multiply:
.beb9	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bebb	35 8b		and $8b,x			and 	XS2_Type,x
.bebd	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bebe	90 03		bcc $bec3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bec0	4c 58 ca	jmp $ca58			jmp 	MulInteger32 							; so execute code at \1
.bec3					_BCFloat:
.bec3	20 0f bf	jsr $bf0f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bec6	4c ac cd	jmp $cdac			jmp 	FPMultiply 							; and execute code at \2
.bec9	60		rts				rts
.beca					BinaryOp_Divide:
.beca	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.becc	35 8b		and $8b,x			and 	XS2_Type,x
.bece	4a		lsr a				lsr 	a 							; shift bit 0 into C
.becf	90 03		bcc $bed4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bed1	4c 96 ca	jmp $ca96			jmp 	DivInteger32 							; so execute code at \1
.bed4					_BCFloat:
.bed4	20 0f bf	jsr $bf0f			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bed7	4c 39 cd	jmp $cd39			jmp 	FPDivide 							; and execute code at \2
.beda	60		rts				rts
.bedb					AddInteger32:
.bedb	18		clc				clc
.bedc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bede	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.bee0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bee2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bee4	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.bee6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bee8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.beea	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.beec	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.beee	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bef0	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.bef2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bef4	60		rts				rts
.bef5					SubInteger32:
.bef5	38		sec				sec
.bef6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bef8	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.befa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.befc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.befe	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.bf00	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf02	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bf04	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.bf06	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf08	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf0a	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.bf0c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf0e	60		rts				rts
.bf0f					BinaryMakeBothFloat:
.bf0f	da		phx				phx 								; save X
.bf10	e8		inx				inx
.bf11	e8		inx				inx
.bf12	e8		inx				inx
.bf13	e8		inx				inx
.bf14	e8		inx				inx
.bf15	e8		inx				inx
.bf16	20 1a bf	jsr $bf1a			jsr 	BinaryMakeFloat 			; convert to float.
.bf19	fa		plx				plx 								; restore X and fall through.
.bf1a					BinaryMakeFloat:
.bf1a	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.bf1c	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.bf1d	b0 04		bcs $bf23			bcs 	_BMFConvert
.bf1f	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.bf20	b0 04		bcs $bf26			bcs 	_BMFError
.bf22	60		rts				rts
.bf23					_BMFConvert:
.bf23	4c 65 cf	jmp $cf65			jmp 	FPUToFloat 					; convert to float, only float builds of course
.bf26					_BMFError:
.bf26	4c 89 ae	jmp $ae89			jmp 	TypeError
.bf29					ConcatenateString:
.bf29	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.bf2b	85 1c		sta $1c				sta		zLTemp1+0
.bf2d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf2f	85 1d		sta $1d				sta 	zLTemp1+1
.bf31	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.bf33	85 1e		sta $1e				sta 	zLTemp1+2
.bf35	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.bf37	85 1f		sta $1f				sta 	zLTemp1+3
.bf39	5a		phy				phy
.bf3a	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.bf3c	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.bf3e	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.bf40	7a		ply				ply
.bf41	b0 33		bcs $bf76			bcs 	_CSError					; check in range.
.bf43	c9 fe		cmp #$fe			cmp 	#maxString+1
.bf45	b0 2f		bcs $bf76			bcs 	_CSError
.bf47	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString 			; store the result
.bf4a	20 61 bf	jsr $bf61			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.bf4d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.bf4f	85 1c		sta $1c				sta 	zLTemp1
.bf51	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.bf53	85 1d		sta $1d				sta 	zLTemp1+1
.bf55	20 61 bf	jsr $bf61			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.bf58	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.bf5a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf5c	a5 23		lda $23				lda 	zTempStr+1
.bf5e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf60	60		rts				rts
.bf61					_CSCopyString:
.bf61	da		phx				phx
.bf62	5a		phy				phy
.bf63	a0 00		ldy #$00			ldy 	#0 							; get length
.bf65	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.bf67	f0 0a		beq $bf73			beq 	_CSCSExit 					; if zero, exit immediately
.bf69	aa		tax				tax 								; put in X which is the counter.
.bf6a					_CSCSLoop:
.bf6a	c8		iny				iny 								; get next char
.bf6b	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.bf6d	20 13 c4	jsr $c413			jsr		WriteTempString 			; copy out to new string
.bf70	ca		dex				dex 								; do whole string
.bf71	d0 f7		bne $bf6a			bne 	_CSCSLoop
.bf73					_CSCSExit:
.bf73	7a		ply				ply
.bf74	fa		plx				plx
.bf75	60		rts				rts
.bf76					_CSError:
.bf76	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bf79	53 74 72 69 6e 67 20 74			.text "String too long",0
>bf81	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.bf89					Unary_Sgn:
.bf89	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX 			; get value
.bf8c	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; check right bracket.
.bf8f	20 ad bf	jsr $bfad			jsr 	GetSignCurrent 				; get sign.
.bf92	09 00		ora #$00			ora 	#0
.bf94	10 08		bpl $bf9e			bpl		UnarySetAInteger			; if 0,1 return that.
.bf96	80 00		bra $bf98			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.bf98					UnarySetAMinus1:
.bf98	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.bf9a	95 80		sta $80,x			sta 	XS_Mantissa,x
.bf9c	80 04		bra $bfa2			bra 	UnarySetAFill
.bf9e					UnarySetAInteger:
.bf9e	95 80		sta $80,x			sta 	XS_Mantissa,x
.bfa0	a9 00		lda #$00			lda 	#0
.bfa2					UnarySetAFill:
.bfa2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bfa4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bfa6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bfa8	a9 01		lda #$01			lda 	#1 							; set type to integer.
.bfaa	95 85		sta $85,x			sta 	XS_Type,x
.bfac	60		rts				rts
.bfad					GetSignCurrent:
.bfad	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.bfaf	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.bfb0	90 15		bcc $bfc7			bcc 	_GSCFloat 					; if clear do the float code.
.bfb2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.bfb4	30 0e		bmi $bfc4			bmi 	_GSCMinus1
.bfb6	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.bfb8	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.bfba	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bfbc	d0 03		bne $bfc1			bne 	_GSCPlus1 					; check if zero by oring all together.
.bfbe					_GSCZero:
.bfbe	a9 00		lda #$00			lda 	#0
.bfc0	60		rts				rts
.bfc1					_GSCPlus1:
.bfc1	a9 01		lda #$01			lda 	#$01
.bfc3	60		rts				rts
.bfc4					_GSCMinus1:
.bfc4	a9 ff		lda #$ff			lda 	#$FF
.bfc6	60		rts				rts
.bfc7					_GSCFloat:
.bfc7	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.bfc9	70 f3		bvs $bfbe			bvs 	_GSCZero 					; if zero flag set return zero
.bfcb	30 f7		bmi $bfc4			bmi 	_GSCMinus1 					; if sign set return -1
.bfcd	80 f2		bra $bfc1			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.bfcf					Unary_Abs:
.bfcf	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX 			; get value
.bfd2	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; check right bracket.
.bfd5	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bfd7	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bfd9	f0 07		beq $bfe2			beq 	_UAMinusFloat
.bfdb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.bfdd	10 09		bpl $bfe8			bpl 	_UAExit
.bfdf	4c 1d cb	jmp $cb1d			jmp 	IntegerNegateAlways 		; if so negate it.
.bfe2					_UAMinusFloat:
.bfe2	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.bfe4	29 7f		and #$7f			and		#$7F
.bfe6	95 85		sta $85,x			sta 	XS_Type,x
.bfe8					_UAExit:
.bfe8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.bfe9					Unary_Peek:
.bfe9	a9 01		lda #$01			lda 	#1 							; 1 byte
.bfeb	80 06		bra $bff3			bra 	UPMain
.bfed					Unary_Deek:
.bfed	a9 02		lda #$02			lda 	#2 							; 2 bytes
.bfef	80 02		bra $bff3			bra 	UPMain
.bff1					Unary_Leek:
.bff1	a9 04		lda #$04			lda 	#4 							; 4 bytes
.bff3					UPMain:
.bff3	48		pha				pha 								; save bytes to copy.
.bff4	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.bff7	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.bffa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.bffc	85 1c		sta $1c				sta 	zLTemp1
.bffe	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c000	85 1d		sta $1d				sta 	zLTemp1+1
.c002	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c004	85 1e		sta $1e				sta 	zLTemp1+2
.c006	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c008	85 1f		sta $1f				sta 	zLTemp1+3
.c00a	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.c00c	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.c00e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c010	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c012	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c014	68		pla				pla 								; restore bytes to copy
.c015	da		phx				phx 								; save XY
.c016	5a		phy				phy
.c017	20 10 c3	jsr $c310			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.c01a	7a		ply				ply 								; restore and exit
.c01b	fa		plx				plx
.c01c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.c01d					Unary_Pos:
.c01d	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.c020	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; check right bracket.
.c023	20 72 ae	jsr $ae72			jsr 	VIOCharGetPosition 			; get the position
.c026	4c 9e bf	jmp $bf9e			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.c029					Unary_Mod:
.c029	20 51 c0	jsr $c051			jsr 	_UMParameter 				; first parameter, get |param|
.c02c	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma
.c02f	da		phx				phx 								; second parameter, get |param|
.c030	e8		inx				inx
.c031	e8		inx				inx
.c032	e8		inx				inx
.c033	e8		inx				inx
.c034	e8		inx				inx
.c035	e8		inx				inx
.c036	20 51 c0	jsr $c051			jsr 	_UMParameter
.c039	fa		plx				plx
.c03a	20 99 c3	jsr $c399			jsr 	CheckNextRParen
.c03d	20 96 ca	jsr $ca96			jsr 	DivInteger32 				; divide, which handily leaves ....
.c040	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.c042	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c044	a5 1d		lda $1d				lda 	zLTemp1+1
.c046	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c048	a5 1e		lda $1e				lda 	zLTemp1+2
.c04a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c04c	a5 1f		lda $1f				lda 	zLTemp1+3
.c04e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c050	60		rts				rts
.c051					_UMParameter:
.c051	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX 			; get value
.c054	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.c056	10 03		bpl $c05b			bpl 	_UMNotSigned
.c058	20 1d cb	jsr $cb1d			jsr 	IntegerNegateAlways
.c05b					_UMNotSigned:
.c05b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.c05c					Unary_Usr:
.c05c	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX 			; numeric parameter
.c05f	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.c062	da		phx				phx 								; save XY
.c063	5a		phy				phy
.c064	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.c067	7a		ply				ply 								; restore YX and exit with whatever the
.c068	fa		plx				plx 								; routine called has chosen to do with it.
.c069	60		rts				rts
.c06a					USRDefault:
.c06a	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c06d	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>c075	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.c07c					Unary_Val:
.c07c	20 44 bd	jsr $bd44			jsr 	EvaluateStringX 			; get string
.c07f	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; check right bracket.
.c082	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.c084	85 20		sta $20				sta 	zGenPtr
.c086	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c088	85 21		sta $21				sta 	zGenPtr+1
.c08a	da		phx				phx
.c08b	5a		phy				phy
.c08c	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.c08e	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.c090	f0 1b		beq $c0ad			beq 	UVBadNumber
.c092	aa		tax				tax
.c093					_UVCopy1:
.c093	c8		iny				iny
.c094	c0 18		cpy #$18			cpy 	#24 						; too long
.c096	f0 15		beq $c0ad			beq 	UVBadNumber
.c098	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.c09a	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.c09d	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.c09f	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.c0a2	ca		dex				dex
.c0a3	d0 ee		bne $c093			bne 	_UVCopy1
.c0a5	7a		ply				ply
.c0a6	fa		plx				plx
.c0a7	20 bb c0	jsr $c0bb			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.c0aa	b0 01		bcs $c0ad			bcs 	UVBadNumber
.c0ac	60		rts				rts
.c0ad					UVBadNumber:
.c0ad	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c0b0	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>c0b8	65 72 00
.c0bb					ConvertNumBuffer:
.c0bb	5a		phy				phy
.c0bc	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.c0be	85 20		sta $20				sta 	zGenPtr
.c0c0	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.c0c2	85 21		sta $21				sta 	zGenPtr+1
.c0c4	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.c0c7	c9 2d		cmp #$2d			cmp 	#"-"
.c0c9	d0 02		bne $c0cd			bne 	_UVNotMinus1
.c0cb	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.c0cd					_UVNotMinus1:
.c0cd	20 eb cb	jsr $cbeb			jsr 	IntFromString 				; get integer
.c0d0	b0 22		bcs $c0f4			bcs 	_UVFail
.c0d2	20 6b d1	jsr $d16b			jsr 	FPFromString 				; possibly float it.
.c0d5	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.c0d7	d0 1b		bne $c0f4			bne 	_UVFail 					; no, exit.
.c0d9	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.c0dc	c9 2d		cmp #$2d			cmp 	#"-"
.c0de	d0 11		bne $c0f1			bne 	_UVNotMinus2
.c0e0	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.c0e2	29 0f		and #$0f			and 	#$0F
.c0e4	f0 05		beq $c0eb			beq 	_UVNegateFloat
.c0e6	20 1d cb	jsr $cb1d			jsr 	IntegerNegateAlways
.c0e9	80 06		bra $c0f1			bra 	_UVNotMinus2
.c0eb					_UVNegateFloat:
.c0eb	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.c0ed	09 80		ora #$80			ora 	#$80
.c0ef	95 85		sta $85,x			sta 	XS_Type,x
.c0f1					_UVNotMinus2:
.c0f1	7a		ply				ply
.c0f2	18		clc				clc
.c0f3	60		rts				rts
.c0f4	7a		ply		_UVFail:ply
.c0f5	38		sec				sec
.c0f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.c0f7					Unary_Str:
.c0f7	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX 			; numeric parameter
.c0fa	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.c0fd	a9 00		lda #$00			lda 	#0 							; reset buffer index
.c0ff	8d 14 03	sta $0314			sta 	NumBufX
.c102	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.c104	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.c105	b0 05		bcs $c10c			bcs 	_USInt 						; if msb set do as integer
.c107	20 b0 d0	jsr $d0b0			jsr 	FPToString 					; call fp to str otherwise
.c10a	80 03		bra $c10f			bra 	_USDuplicate
.c10c	20 3a cb	jsr $cb3a	_USInt:	jsr 	IntToString					; call int to str.
.c10f					_USDuplicate:
.c10f	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.c112	1a		inc a				inc 	a 							; one more for length
.c113	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString 			; allocate space for it.
.c116	5a		phy				phy 								; save Y
.c117	a0 00		ldy #$00			ldy 	#0 							; start copying
.c119	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.c11c	20 13 c4	jsr $c413			jsr 	WriteTempString
.c11f	c8		iny				iny
.c120	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.c123	d0 f4		bne $c119			bne 	_USCopy
.c125	7a		ply				ply 								; restore Y
.c126	4c 03 c3	jmp $c303			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c129					Unary_Asc:
.c129	20 44 bd	jsr $bd44			jsr 	EvaluateStringX 			; string parameter
.c12c	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.c12f	5a		phy				phy 								; get the string length
.c130	a0 00		ldy #$00			ldy 	#0
.c132	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c134	f0 07		beq $c13d			beq 	_UAIllegal 					; must be at least one character, 0 => error
.c136	c8		iny				iny
.c137	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.c139	7a		ply				ply
.c13a	4c 9e bf	jmp $bf9e			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.c13d					_UAIllegal:
.c13d	4c 97 ae	jmp $ae97			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c140					Unary_Len:
.c140	20 44 bd	jsr $bd44			jsr 	EvaluateStringX 			; string parameter
.c143	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.c146	5a		phy				phy 								; get the string length
.c147	a0 00		ldy #$00			ldy 	#0
.c149	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c14b	7a		ply				ply
.c14c	4c 9e bf	jmp $bf9e			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.c14f					Unary_Mid:
.c14f	20 44 bd	jsr $bd44			jsr 	EvaluateStringX 				; get string.
.c152	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c154	48		pha				pha
.c155	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c157	48		pha				pha
.c158	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma 					; skip comma
.c15b	20 e4 c1	jsr $c1e4			jsr 	SLIByteParameter 				; get a byte parameter (start)
.c15e	48		pha				pha 									; and push it.
.c15f	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma 					; skip comma
.c162	20 e4 c1	jsr $c1e4			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.c165	48		pha				pha 									; and push it.
.c166	80 41		bra $c1a9			bra 	SLIProcess
.c168					Unary_Left:
.c168	20 44 bd	jsr $bd44			jsr 	EvaluateStringX 				; get string.
.c16b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c16d	48		pha				pha
.c16e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c170	48		pha				pha
.c171	a9 01		lda #$01			lda 	#1 								; push start position (1)
.c173	48		pha				pha
.c174	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma 					; skip comma
.c177	20 e4 c1	jsr $c1e4			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.c17a	48		pha				pha 									; and push it.
.c17b	80 2c		bra $c1a9			bra 	SLIProcess
.c17d					Unary_Right:
.c17d	20 44 bd	jsr $bd44			jsr 	EvaluateStringX 				; get string.
.c180	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c182	48		pha				pha
.c183	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c185	48		pha				pha
.c186	da		phx				phx 									; get the string length and push on stack.
.c187	a2 00		ldx #$00			ldx 	#0
.c189	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.c18b	fa		plx				plx
.c18c	48		pha				pha
.c18d	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma 					; skip comma
.c190	20 e4 c1	jsr $c1e4			jsr 	SLIByteParameter 				; get a byte parameter.
.c193	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.c196	68		pla				pla 									; restore string length.
.c197	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.c198	38		sec				sec
.c199	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.c19c	f0 02		beq $c1a0			beq 	_URStart 						; if <= 0 start from 1.
.c19e	10 02		bpl $c1a2			bpl 	_UROkay
.c1a0					_URStart:
.c1a0	a9 01		lda #$01			lda 	#1
.c1a2					_UROkay:
.c1a2	48		pha				pha 									; push start
.c1a3	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.c1a6	48		pha				pha
.c1a7	80 00		bra $c1a9			bra 	SLIProcess
.c1a9					SLIProcess:
.c1a9	20 99 c3	jsr $c399			jsr 	CheckNextRParen 				; closing right bracket.
.c1ac	68		pla				pla
.c1ad	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.c1b0	1a		inc a				inc 	a 								; allocate +1 for it.
.c1b1	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString
.c1b4	68		pla				pla 									; pop start number off stack.
.c1b5	f0 3b		beq $c1f2			beq 	SLIError 						; exit if start = 0
.c1b7	8d a1 03	sta $03a1			sta 	SliceStart
.c1ba	68		pla				pla  									; pop string address.
.c1bb	85 21		sta $21				sta 	zGenPtr+1
.c1bd	68		pla				pla
.c1be	85 20		sta $20				sta 	zGenPtr
.c1c0	da		phx				phx
.c1c1	5a		phy				phy
.c1c2	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.c1c4	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.c1c7					_SLICopy:
.c1c7	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.c1ca	f0 12		beq $c1de			beq 	_SLIExit
.c1cc	ce a2 03	dec $03a2			dec 	SliceCount
.c1cf	98		tya				tya 									; index of character
.c1d0	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.c1d2	f0 02		beq $c1d6			beq 	_SLIOk 							; if equal, okay.
.c1d4	b0 08		bcs $c1de			bcs 	_SLIExit 						; if past end, then exit.
.c1d6	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.c1d8	c8		iny				iny
.c1d9	20 13 c4	jsr $c413			jsr 	WriteTempString
.c1dc	80 e9		bra $c1c7			bra 	_SLICopy 						; go round till copied characters
.c1de					_SLIExit:
.c1de	7a		ply				ply 									; restore YX
.c1df	fa		plx				plx
.c1e0	4c 03 c3	jmp $c303			jmp 	UnaryReturnTempStr 				; return new temporary string.
.c1e3	ea		nop				nop
.c1e4					SLIByteParameter:
.c1e4	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX 				; get integer
.c1e7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.c1e9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c1eb	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c1ed	d0 03		bne $c1f2			bne 	SLIError
.c1ef	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c1f1	60		rts				rts
.c1f2					SLIError:
.c1f2	4c 97 ae	jmp $ae97			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.c1f5					Unary_Hex:
.c1f5	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX 			; numeric parameter
.c1f8	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.c1fb	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.c1fd	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString			; allocate string space
.c200	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.c202	20 26 c2	jsr $c226			jsr 	_UHConvert
.c205	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c207	20 26 c2	jsr $c226			jsr 	_UHConvert
.c20a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c20c	20 26 c2	jsr $c226			jsr 	_UHConvert
.c20f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c211	20 26 c2	jsr $c226			jsr 	_UHConvert
.c214	5a		phy				phy 								; get length of new string
.c215	a0 00		ldy #$00			ldy 	#0
.c217	b1 22		lda ($22),y			lda 	(zTempStr),y
.c219	7a		ply				ply
.c21a	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.c21c	d0 05		bne $c223			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.c21e	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.c220	20 13 c4	jsr $c413			jsr 	WriteTempString
.c223					_UHExit:
.c223	4c 03 c3	jmp $c303			jmp 	UnaryReturnTempStr 			; return new temporary string.
.c226					_UHConvert:
.c226	48		pha				pha
.c227	4a		lsr a				lsr 	a 							; do MSB
.c228	4a		lsr a				lsr 	a
.c229	4a		lsr a				lsr 	a
.c22a	4a		lsr a				lsr 	a
.c22b	20 2f c2	jsr $c22f			jsr 	_UHNibble
.c22e	68		pla				pla 								; do LSB
.c22f					_UHNibble:
.c22f	29 0f		and #$0f			and 	#15 						; get nibble
.c231	d0 0c		bne $c23f			bne 	_UHNonZero 					; if not zero, write it out anyway.
.c233	5a		phy				phy									; get the length
.c234	a0 00		ldy #$00			ldy 	#0
.c236	b1 22		lda ($22),y			lda 	(zTempStr),y
.c238	7a		ply				ply
.c239	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.c23b	f0 0d		beq $c24a			beq 	_UHExit2
.c23d	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.c23f					_UHNonZero:
.c23f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c241	90 02		bcc $c245			bcc 	_UHDigit
.c243	69 06		adc #$06			adc 	#7-1
.c245					_UHDigit:
.c245	69 30		adc #$30			adc 	#48
.c247	20 13 c4	jsr $c413			jsr 	WriteTempString				; output to temp string.
.c24a					_UHExit2:
.c24a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.c24b					Unary_Dec:
.c24b	20 44 bd	jsr $bd44			jsr 	EvaluateStringX 			; string parameter
.c24e	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.c251	5a		phy				phy
.c252	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.c254	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c256	f0 43		beq $c29b			beq 	_UDFail 					; must fail if zero.
.c258	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.c25b	a9 00		lda #$00			lda 	#0 							; set result to zero
.c25d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c25f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c261	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c263	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c265	a9 01		lda #$01			lda 	#1 							; set type to integer.
.c267	95 85		sta $85,x			sta 	XS_Type,x
.c269					_UDConvertLoop:
.c269	5a		phy				phy 								; shift mantissa left 4
.c26a	a0 04		ldy #$04			ldy 	#4
.c26c					_UDShift:
.c26c	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c26e	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c270	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c272	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c274	88		dey				dey
.c275	d0 f5		bne $c26c			bne 	_UDShift
.c277	7a		ply				ply
.c278	c8		iny				iny 								; next character
.c279	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.c27b	20 9e c2	jsr $c29e			jsr 	ConvertUpper 				; convert to U/C
.c27e	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.c280	90 19		bcc $c29b			bcc 	_UDFail
.c282	c9 3a		cmp #$3a			cmp 	#"9"+1
.c284	90 08		bcc $c28e			bcc 	_UDOkay
.c286	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.c288	90 11		bcc $c29b			bcc 	_UDFail 					; fails if between 9 and @
.c28a	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.c28c	b0 0d		bcs $c29b			bcs 	_UDFail
.c28e					_UDOkay:
.c28e	29 0f		and #$0f			and 	#15 						; nibble only
.c290	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.c292	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c294	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.c297	d0 d0		bne $c269			bne 	_UDConvertLoop
.c299	7a		ply				ply
.c29a	60		rts				rts
.c29b					_UDFail:
.c29b	4c 97 ae	jmp $ae97			jmp 	BadParamError
.c29e					ConvertUpper:
.c29e	c9 61		cmp #$61			cmp 	#"a"
.c2a0	90 07		bcc $c2a9			bcc 	_CUExit
.c2a2	c9 7b		cmp #$7b			cmp 	#"z"+1
.c2a4	b0 03		bcs $c2a9			bcs 	_CUExit
.c2a6	38		sec				sec
.c2a7	e9 20		sbc #$20			sbc 	#32
.c2a9	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.c2aa					Unary_Chr:
.c2aa	20 3b bd	jsr $bd3b			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.c2ad	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; right bracket.
.c2b0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c2b2	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c2b4	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c2b6	d0 0d		bne $c2c5			bne 	_UCChar
.c2b8	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.c2ba	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString			; allocate it.
.c2bd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.c2bf	20 13 c4	jsr $c413			jsr 	WriteTempString
.c2c2	4c 03 c3	jmp $c303			jmp 	UnaryReturnTempStr 			; and return that string.
.c2c5					_UCChar:
.c2c5	4c 97 ae	jmp $ae97			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.c2c8					Unary_Spc:
.c2c8	20 e4 c1	jsr $c1e4			jsr 	SLIByteParameter 			; get number of spaces
.c2cb	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; skip )
.c2ce	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.c2d0					UnarySpcCreate:
.c2d0	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.c2d2	b0 14		bcs $c2e8			bcs 	_USSize
.c2d4	48		pha				pha 								; save length
.c2d5	1a		inc a				inc 	a 							; allocate one more.
.c2d6	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString
.c2d9	68		pla				pla 								; get length
.c2da	f0 27		beq $c303			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.c2dc					_USLoop:
.c2dc	48		pha				pha
.c2dd	a9 20		lda #$20			lda 	#" "
.c2df	20 13 c4	jsr $c413			jsr 	WriteTempString
.c2e2	68		pla				pla
.c2e3	3a		dec a				dec 	a
.c2e4	d0 f6		bne $c2dc			bne 	_USLoop
.c2e6	80 1b		bra $c303			bra 	UnaryReturnTempStr 			; and return the temporary space.
.c2e8					_USSize:
.c2e8	4c 97 ae	jmp $ae97			jmp 	BadParamError
.c2eb					Unary_Tab:
.c2eb	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.c2ed	20 e4 c1	jsr $c1e4			jsr 	SLIByteParameter
.c2f0	20 99 c3	jsr $c399			jsr 	CheckNextRParen
.c2f3	20 72 ae	jsr $ae72			jsr 	VIOCharGetPosition 			; were are we ?
.c2f6	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.c2f8	38		sec				sec
.c2f9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.c2fb	e5 10		sbc $10				sbc 	zTemp1
.c2fd	b0 d1		bcs $c2d0			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.c2ff	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.c301	80 cd		bra $c2d0			bra 	UnarySpcCreate
.c303					UnaryReturnTempStr:
.c303	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.c305	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c307	a5 23		lda $23				lda 	zTempStr+1
.c309	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c30b	a9 02		lda #$02			lda 	#2 							; set type to string
.c30d	95 85		sta $85,x			sta 	XS_Type,x
.c30f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.c310	db		phz		MemRead:phz
.c311	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c314	a3 00		ldz #$00			ldz 	#0 							; start from here
.c316	ea		nop		_MLoop1:nop
.c317	b2 1c		lda ($1c),z			lda 	(zlTemp1),z 				; read the long address
.c319	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.c31b	1b		inz				inz 								; next to copy
.c31c	e8		inx				inx
.c31d	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c320	d0 f4		bne $c316			bne 	_MLoop1
.c322	fb		plz				plz
.c323	60		rts				rts
.c324					MemWrite:
.c324	db		phz				phz
.c325	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c328	a3 00		ldz #$00			ldz 	#0 							; start from here
.c32a	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.c32c	ea		nop				nop
.c32d	92 1c		sta ($1c),z			sta 	(zlTemp1),z 				; write it out
.c32f	1b		inz				inz 								; next to copy
.c330	e8		inx				inx
.c331	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c334	d0 f4		bne $c32a			bne 	_MLoop1
.c336	fb		plz				plz
.c337	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.c338					UpdateProgramEnd:
.c338	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c33a	85 18		sta $18				sta 	zCodePtr+0
.c33c	a9 80		lda #$80			lda 	#BasicProgram >> 8
.c33e	85 19		sta $19				sta 	zCodePtr+1
.c340	a9 02		lda #$02			lda 	#2
.c342	85 1a		sta $1a				sta 	zCodePtr+2
.c344	a9 00		lda #$00			lda 	#0
.c346	85 1b		sta $1b				sta 	zCodePtr+3
.c348	a3 03		ldz #$03			ldz 	#3
.c34a					_UPDLoop:
.c34a	a3 00		ldz #$00			ldz 	#0
.c34c	ea		nop				nop
.c34d	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c34f	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.c351	f0 10		beq $c363			beq 	_UPDFoundEnd
.c353	a3 00		ldz #$00			ldz 	#0 							; point to offset
.c355	ea		nop				nop
.c356	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.c358	18		clc				clc
.c359	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.c35b	85 18		sta $18				sta 	zCodePtr
.c35d	90 02		bcc $c361			bcc 	_SNLNoCarry
.c35f	e6 19		inc $19				inc 	zCodePtr+1
.c361					_SNLNoCarry:
.c361	80 e7		bra $c34a			bra 	_UPDLoop
.c363					_UPDFoundEnd:
.c363	18		clc				clc 								; end of program 2 on.
.c364	a5 18		lda $18				lda 	zCodePtr
.c366	69 02		adc #$02			adc 	#2
.c368	8d 04 03	sta $0304			sta 	endOfProgram
.c36b	a5 19		lda $19				lda 	zCodePtr+1
.c36d	69 00		adc #$00			adc 	#0
.c36f	8d 05 03	sta $0305			sta 	endOfProgram+1
.c372	a5 1a		lda $1a				lda 	zCodePtr+2
.c374	69 00		adc #$00			adc		#0
.c376	8d 06 03	sta $0306			sta 	endOfProgram+2
.c379	a5 1b		lda $1b				lda 	zCodePtr+3
.c37b	69 00		adc #$00			adc 	#0
.c37d	8d 07 03	sta $0307			sta 	endOfProgram+3
.c380	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.c381					CheckNextToken:
.c381	ea		nop				nop
.c382	d2 18		cmp ($18),z			cmp 	(zCodePtr),z
.c384	d0 02		bne $c388			bne 	CTFail 						; no, then fail
.c386	1b		inz				inz
.c387	60		rts				rts
.c388					CTFail:
.c388	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c38b	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>c393	74 6f 6b 65 6e 00
.c399					CheckNextRParen:
.c399	ea		nop				nop
.c39a	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c39c	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.c39e	d0 e8		bne $c388			bne 	CTFail 						; fail if not
.c3a0	1b		inz				inz
.c3a1	60		rts				rts
.c3a2					CheckNextComma:
.c3a2	ea		nop				nop
.c3a3	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c3a5	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.c3a7	d0 df		bne $c388			bne 	CTFail 						; fail if not
.c3a9	1b		inz				inz
.c3aa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.c3ab					StringConcrete:
.c3ab	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.c3ad	85 10		sta $10				sta 	zTemp1
.c3af	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c3b1	85 11		sta $11				sta 	zTemp1+1
.c3b3	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.c3b5	b1 10		lda ($10),y			lda 	(zTemp1),y
.c3b7	f0 26		beq $c3df			beq		_SCEmpty 					; concreting it wastes memory.
.c3b9	18		clc				clc 								; from the string pointer
.c3ba	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.c3bd	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.c3bf	8d 00 03	sta $0300			sta 	StringPtr
.c3c2	85 12		sta $12				sta 	zTemp2
.c3c4	ad 01 03	lda $0301			lda 	StringPtr+1
.c3c7	e9 00		sbc #$00			sbc 	#0
.c3c9	8d 01 03	sta $0301			sta 	StringPtr+1
.c3cc	85 13		sta $13				sta 	zTemp2+1
.c3ce	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.c3d0	1a		inc a				inc 	a
.c3d1	aa		tax				tax
.c3d2	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.c3d4	91 12		sta ($12),y			sta 	(zTemp2),y
.c3d6	c8		iny				iny
.c3d7	ca		dex				dex
.c3d8	d0 f8		bne $c3d2			bne 	_SCCopy
.c3da	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.c3dc	a6 12		ldx $12				ldx 	zTemp2
.c3de	60		rts				rts
.c3df					_SCEmpty:
.c3df	a9 00		lda #$00			lda 	#0
.c3e1	85 27		sta $27				sta 	zNullString
.c3e3	a9 00		lda #$00			lda 	#zNullString >> 8
.c3e5	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.c3e7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c3e8					AllocateTempString:
.c3e8	48		pha				pha 								; save required count.
.c3e9	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.c3eb	d0 0b		bne $c3f8			bne 	_ATSInitialised
.c3ed	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c3f0	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.c3f2	ad 01 03	lda $0301			lda 	StringPtr+1
.c3f5	3a		dec a				dec 	a 							; allow the page.
.c3f6	85 23		sta $23				sta 	zTempStr+1
.c3f8					_ATSInitialised:
.c3f8	68		pla				pla 								; get required count back.
.c3f9	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.c3fb	1a		inc a				inc 	a
.c3fc	18		clc				clc
.c3fd	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.c3ff	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.c401	a9 ff		lda #$ff			lda 	#$FF
.c403	65 23		adc $23				adc 	zTempStr+1
.c405	85 23		sta $23				sta 	zTempStr+1
.c407	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.c409	5a		phy				phy
.c40a	a8		tay				tay
.c40b	91 22		sta ($22),y			sta 	(zTempStr),y
.c40d	7a		ply				ply
.c40e	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.c40f	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.c412	60		rts				rts
.c413					WriteTempString:
.c413	5a		phy				phy 								; save Y
.c414	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.c417	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.c419	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.c41c	98		tya				tya 								; unchanged Y is now length
.c41d	a0 00		ldy #$00			ldy 	#0
.c41f	91 22		sta ($22),y			sta 	(zTempStr),y
.c421	7a		ply				ply 								; restore Y and exit
.c422	60		rts				rts
.c423					CreateTempStringCopy:
.c423	da		phx				phx 								; save X
.c424	ea		nop				nop
.c425	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c427	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c428	20 e8 c3	jsr $c3e8			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c42b	ea		nop				nop
.c42c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c42e	1b		inz				inz
.c42f	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.c430	3a		dec a				dec 	a 							; for the marker and the length.
.c431	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c433	81 22		sta ($22,x)			sta 	(zTempStr,x)
.c435	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.c437	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c439	f0 0f		beq $c44a			beq 	_CTSCExit
.c43b					_CTSCLoop:
.c43b	ea		nop				nop
.c43c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c43e	1b		inz				inz
.c43f	5a		phy				phy 								; save Y
.c440	e8		inx				inx 								; bump index
.c441	da		phx				phx 								; save that
.c442	7a		ply				ply 								; index into Y
.c443	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.c445	7a		ply				ply 								; restore Y
.c446	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.c448	d0 f1		bne $c43b			bne 	_CTSCLoop
.c44a					_CTSCExit:
.c44a	fa		plx				plx 								; restore X
.c44b	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.c44c					TokeniseKeyword:
.c44c	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.c44d	18		clc				clc
.c44e	65 20		adc $20				adc 	zGenPtr
.c450	85 20		sta $20				sta 	zGenPtr
.c452	90 02		bcc $c456			bcc 	_TKWNoBump
.c454	e6 21		inc $21				inc 	zGenPtr+1
.c456					_TKWNoBump:
.c456	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.c458	da		phx				phx
.c459	a9 ea		lda #$ea			lda 	#KeyWordText & $FF 			; scan this table.
.c45b	a2 af		ldx #$af			ldx 	#(KeyWordText >> 8) & $FF
.c45d	20 68 c4	jsr $c468			jsr 	TKWScanTokenTable
.c460	fa		plx				plx
.c461	90 04		bcc $c467			bcc 	_TKWNoWrite
.c463	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.c466	e8		inx				inx
.c467					_TKWNoWrite:
.c467	60		rts				rts
.c468					TKWScanTokenTable:
.c468	86 1d		stx $1d				stx 	zLTemp1+1
.c46a	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.c46c	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.c46e	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.c470	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c472	20 76 c5	jsr $c576			jsr 	TOKCapitalise 					; save this in zTemp3
.c475	85 14		sta $14				sta 	zTemp3
.c477	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.c479	85 15		sta $15				sta 	zTemp3+1
.c47b					_TKWScanLoop:
.c47b	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c47d	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.c47f	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.c481	d0 26		bne $c4a9			bne		_TKWNext 						; if it doesn't match, go to next.
.c483	20 c8 c4	jsr $c4c8			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.c486	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.c488					_TKWCompareFull:
.c488	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c48a	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.c48c	85 16		sta $16				sta 	zTemp4
.c48e	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.c490	20 76 c5	jsr $c576			jsr 	TOKCapitalise 					; make it U/C
.c493	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.c495	d0 12		bne $c4a9			bne 	_TKWNext 						; failed, go to next slot.
.c497	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c499	c8		iny				iny 									; bump pointer
.c49a	0a		asl a				asl 	a 								; shift bit 7 into C
.c49b	90 eb		bcc $c488			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.c49d	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.c49f	90 08		bcc $c4a9			bcc 	_TKWNext 						; if shorter, the original was better
.c4a1	84 12		sty $12				sty 	zTemp2							; update longest match.
.c4a3	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.c4a5	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.c4a7	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.c4a9					_TKWNext:
.c4a9	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c4ab	c8		iny				iny 									; next one.
.c4ac	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.c4ad	90 fa		bcc $c4a9			bcc 	_TKWNext
.c4af	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.c4b1	98		tya				tya 									; has Y gone negative.
.c4b2	10 03		bpl $c4b7			bpl 	_TKWNoYZero
.c4b4	20 c8 c4	jsr $c4c8			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.c4b7					_TKWNoYZero:
.c4b7	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c4b9	d0 c0		bne $c47b			bne 	_TKWScanLoop 					; if not, try the next one.
.c4bb	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.c4bd	f0 05		beq $c4c4			beq 	_TKWFail 						; if zero, none found.
.c4bf	a8		tay				tay 									; return the token in zTemp2, length => y
.c4c0	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.c4c2	38		sec				sec
.c4c3	60		rts				rts
.c4c4					_TKWFail:
.c4c4	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.c4c6	18		clc				clc
.c4c7	60		rts				rts
.c4c8					_TKWClearY:
.c4c8	98		tya				tya
.c4c9	18		clc				clc
.c4ca	65 1c		adc $1c				adc 	zLTemp1
.c4cc	85 1c		sta $1c				sta 	zLTemp1
.c4ce	90 02		bcc $c4d2			bcc 	_TKWCNoBump
.c4d0	e6 1d		inc $1d				inc 	zLTemp1+1
.c4d2					_TKWCNoBump:
.c4d2	a0 00		ldy #$00			ldy 	#0
.c4d4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.c4d5					TokeniseString:
.c4d5	85 20		sta $20				sta 	zGenPtr 					; save source
.c4d7	86 21		stx $21				stx 	zGenPtr+1
.c4d9	a0 00		ldy #$00			ldy 	#0 							; source
.c4db	a2 00		ldx #$00			ldx 	#0 							; target
.c4dd					_TSMainLoop:
.c4dd					_TSSkipSpaces:
.c4dd	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.c4df	c8		iny				iny
.c4e0	c9 20		cmp #$20			cmp 	#" "
.c4e2	f0 f9		beq $c4dd			beq 	_TSSkipSpaces
.c4e4	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.c4e6	90 0a		bcc $c4f2			bcc 	_TSNotConstant
.c4e8	c9 3a		cmp #$3a			cmp 	#"9"+1
.c4ea	b0 06		bcs $c4f2			bcs 	_TSNotConstant
.c4ec	88		dey				dey 								; point back to start
.c4ed	20 11 c6	jsr $c611			jsr 	TokeniseConstant 			; tokenise a constant
.c4f0	80 eb		bra $c4dd			bra 	_TSMainLoop			 		; and loop back.
.c4f2					_TSNotConstant:
.c4f2	c9 20		cmp #$20			cmp 	#32 						; end of line.
.c4f4	90 52		bcc $c548			bcc 	_TSExit
.c4f6	c9 22		cmp #$22			cmp		#'"'						; quoted string
.c4f8	f0 55		beq $c54f			beq 	_TSQuotedString
.c4fa	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.c4fc	f0 56		beq $c554			beq 	_TSDecimal
.c4fe	20 76 c5	jsr $c576			jsr 	TOKCapitalise 				; make U/C
.c501	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.c503	d0 05		bne $c50a			bne 	_TSNoRemCheck
.c505	20 59 c5	jsr $c559			jsr 	TOKCheckREM
.c508	b0 d3		bcs $c4dd			bcs 	_TSMainLoop 				; and if REM okay, go back.
.c50a					_TSNoRemCheck:
.c50a	88		dey				dey 								; point to character
.c50b	20 4c c4	jsr $c44c			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.c50e	b0 cd		bcs $c4dd			bcs 	_TSMainLoop					; true if tokenised okay.
.c510	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.c512	20 76 c5	jsr $c576			jsr 	TOKCapitalise
.c515	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.c517	90 04		bcc $c51d			bcc 	_TSSingle
.c519	c9 5b		cmp #$5b			cmp 	#"Z"+1
.c51b	90 0d		bcc $c52a			bcc 	_TSAlphaNumeric
.c51d					_TSSingle:
.c51d	c8		iny				iny 								; skip over output
.c51e	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.c520	09 80		ora #$80			ora 	#128
.c522	f0 b9		beq $c4dd			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.c524	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c527	e8		inx				inx
.c528	80 b3		bra $c4dd			bra 	_TSMainLoop
.c52a					_TSAlphaNumeric:
.c52a	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.c52c	20 76 c5	jsr $c576			jsr 	TOKCapitalise
.c52f	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.c531	90 aa		bcc $c4dd			bcc 	_TSMainLoop
.c533	c9 3a		cmp #$3a			cmp 	#"9"+1
.c535	90 0a		bcc $c541			bcc 	_TSANOkay
.c537	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.c539	90 a2		bcc $c4dd			bcc 	_TSMainLoop
.c53b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.c53d	b0 9e		bcs $c4dd			bcs 	_TSMainLoop
.c53f	29 3f		and #$3f			and 	#63 						; write it out
.c541					_TSANOkay:
.c541	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c544	e8		inx				inx
.c545	c8		iny				iny
.c546	80 e2		bra $c52a			bra 	_TSAlphaNumeric
.c548	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.c54a	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c54d	8a		txa				txa 								; return length of tokenised line in bytes.
.c54e	60		rts				rts
.c54f					_TSQuotedString:
.c54f	20 af c5	jsr $c5af			jsr 	TokeniseQuotedString
.c552	80 89		bra $c4dd			bra 	_TSMainLoop
.c554					_TSDecimal:
.c554	20 d5 c5	jsr $c5d5			jsr 	TokeniseDecimalString
.c557	80 84		bra $c4dd			bra 	_TSMainLoop
.c559					TOKCheckREM:
.c559	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.c55b	20 76 c5	jsr $c576			jsr 	TOKCapitalise
.c55e	c9 45		cmp #$45			cmp 	#"E"
.c560	d0 12		bne $c574			bne 	_TCRFail
.c562	c8		iny				iny
.c563	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.c565	88		dey				dey
.c566	20 76 c5	jsr $c576			jsr 	TOKCapitalise
.c569	c9 4d		cmp #$4d			cmp 	#"M"
.c56b	d0 07		bne $c574			bne 	_TCRFail
.c56d	c8		iny				iny									; point to first character
.c56e	c8		iny				iny
.c56f	20 81 c5	jsr $c581			jsr 	TokeniseREMString 			; tokenise REM
.c572	38		sec				sec
.c573	60		rts				rts
.c574					_TCRFail:
.c574	18		clc				clc
.c575	60		rts				rts
.c576					TOKCapitalise:
.c576	c9 61		cmp #$61			cmp 	#"a"
.c578	90 06		bcc $c580			bcc 	_TOKCExit
.c57a	c9 7b		cmp #$7b			cmp 	#"z"+1
.c57c	b0 02		bcs $c580			bcs 	_TOKCExit
.c57e	49 20		eor #$20			eor 	#$20
.c580					_TOKCExit:
.c580	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.c581					TokeniseREMString:
.c581	86 10		stx $10				stx 	zTemp1 						; save position
.c583	a9 ff		lda #$ff			lda 	#$FF 						; write marker
.c585	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c588	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.c58b	e8		inx				inx 								; bump, and one space for the count.
.c58c	e8		inx				inx
.c58d					_TSRSkip:
.c58d	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c58f	c8		iny				iny
.c590	c9 20		cmp #$20			cmp 	#" "
.c592	f0 f9		beq $c58d			beq 	_TSRSkip
.c594	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.c596	f0 31		beq $c5c9			beq 	SequenceExit 				; ... that's it.
.c598					_TSRCopy:
.c598	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.c59b	e8		inx				inx
.c59c	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.c59e	f0 05		beq $c5a5			beq 	_TSRExit 					; zero is exit
.c5a0	c8		iny				iny 								; bump pointer
.c5a1	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.c5a3	d0 f3		bne $c598			bne 	_TSRCopy
.c5a5					_TSRExit:
.c5a5	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.c5a8	c9 20		cmp #$20			cmp 	#" "
.c5aa	d0 1d		bne $c5c9			bne 	SequenceExit
.c5ac	ca		dex				dex 								; go back - will bump into $FF eventually.
.c5ad	80 f6		bra $c5a5			bra 	_TSRExit
.c5af					TokeniseQuotedString:
.c5af	86 10		stx $10				stx 	zTemp1 						; save position
.c5b1	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.c5b3	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c5b6	e8		inx				inx 								; bump, and one space for the count.
.c5b7	e8		inx				inx
.c5b8					_TSQCopy:
.c5b8	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c5ba	c9 20		cmp #$20			cmp 	#" "
.c5bc	90 0b		bcc $c5c9			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.c5be	c8		iny				iny
.c5bf	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.c5c1	f0 06		beq $c5c9			beq 	SequenceExit
.c5c3	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.c5c6	e8		inx				inx
.c5c7	80 ef		bra $c5b8			bra 	_TSQCopy
.c5c9					SequenceExit:
.c5c9	8a		txa				txa 								; current position
.c5ca	38		sec				sec 								; subtract start.
.c5cb	e5 10		sbc $10				sbc 	zTemp1
.c5cd	da		phx				phx 								; copy that in
.c5ce	a6 10		ldx $10				ldx 	zTemp1
.c5d0	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.c5d3	fa		plx				plx
.c5d4	60		rts				rts
.c5d5					TokeniseDecimalString:
.c5d5	86 10		stx $10				stx 	zTemp1 						; save position
.c5d7	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.c5d9	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c5dc	e8		inx				inx 								; bump, and one space for the count.
.c5dd	e8		inx				inx
.c5de	20 ff c5	jsr $c5ff			jsr 	_TDSCopyNumber 				; copy a number.
.c5e1	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.c5e3	20 76 c5	jsr $c576			jsr 	TOKCapitalise
.c5e6	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.c5e8	d0 df		bne $c5c9			bne 	SequenceExit 				; exit now.
.c5ea	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.c5ed	e8		inx				inx
.c5ee	c8		iny				iny
.c5ef	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.c5f1	c9 2d		cmp #$2d			cmp 	#"-"
.c5f3	d0 05		bne $c5fa			bne 	_TDSNoMinusExponent
.c5f5	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.c5f8	e8		inx				inx
.c5f9	c8		iny				iny
.c5fa					_TDSNoMinusExponent:
.c5fa	20 ff c5	jsr $c5ff			jsr 	_TDSCopyNumber 				; do the exponent
.c5fd	80 ca		bra $c5c9			bra 	SequenceExit
.c5ff					_TDSCopyNumber:
.c5ff	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c601	c9 30		cmp #$30			cmp 	#"0"
.c603	90 0b		bcc $c610			bcc 	_TDSCNExit
.c605	c9 3a		cmp #$3a			cmp 	#"9"+1
.c607	b0 07		bcs $c610			bcs 	_TDSCNExit
.c609	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c60c	e8		inx				inx
.c60d	c8		iny				iny
.c60e	80 ef		bra $c5ff			bra 	_TDSCopyNumber
.c610					_TDSCNExit:
.c610	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.c611					TokeniseConstant:
.c611	da		phx				phx 								; save X
.c612	a2 00		ldx #$00			ldx 	#0
.c614	20 ed cb	jsr $cbed			jsr 	IntFromStringY 				; get the integer out.
.c617	b0 37		bcs $c650			bcs 	_TCQ 						; should not happen.
.c619	fa		plx				plx 								; restore X.
.c61a	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.c61c	85 10		sta $10				sta 	zTemp1
.c61e					_TCRotate:
.c61e	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.c620	29 c0		and #$c0			and 	#$C0
.c622	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.c624	05 82		ora $82				ora 	XS_Mantissa+2
.c626	05 83		ora $83				ora 	XS_Mantissa+3
.c628	f0 16		beq $c640			beq 	_TCDone						; if so, at the bottom.
.c62a	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.c62c	29 3f		and #$3f			and 	#$3F
.c62e	48		pha				pha
.c62f	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.c631	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.c633					_TCShiftRight:
.c633	46 83		lsr $83				lsr 	XS_Mantissa+3
.c635	66 82		ror $82				ror 	XS_Mantissa+2
.c637	66 81		ror $81				ror 	XS_Mantissa+1
.c639	66 80		ror $80				ror 	XS_Mantissa+0
.c63b	3a		dec a				dec 	a
.c63c	d0 f5		bne $c633			bne 	_TCShiftRight
.c63e	80 de		bra $c61e			bra 	_TCRotate 					; and go round again.
.c640	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.c642					_TCWrite:
.c642	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.c644	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c647	e8		inx				inx
.c648	c6 10		dec $10				dec 	zTemp1 						; done all of them
.c64a	30 03		bmi $c64f			bmi 	_TCExit 					; no , more to pop
.c64c	68		pla				pla
.c64d	80 f3		bra $c642			bra 	_TCWrite 					; until everything's off.
.c64f					_TCExit:
.c64f	60		rts				rts
.c650					_TCQ:
.c650	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c653	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.c656					VariableFind:
.c656	20 c1 c6	jsr $c6c1			jsr 	VariableExtract 		; find out all about it ....
.c659	20 5c c9	jsr $c95c			jsr 	VariableLocate 			; does it already exist ?
.c65c	b0 03		bcs $c661			bcs 	_VFExists 				; if so, use that.
.c65e	20 4f c7	jsr $c74f			jsr 	VariableCreate 			; otherwise create it.
.c661					_VFExists:
.c661	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.c663	29 01		and #$01			and 	#1
.c665	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c667	d0 28		bne $c691			bne 	_VFSingleElement
.c669					_VFNextIndex:
.c669	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.c66b	48		pha				pha
.c66c	a5 25		lda $25				lda 	zVarDataPtr+1
.c66e	48		pha				pha
.c66f	a5 26		lda $26				lda 	zVarType
.c671	48		pha				pha
.c672	20 39 bd	jsr $bd39			jsr 	EvaluateInteger 		; calculate the index.
.c675	68		pla				pla 							; restore and index.
.c676	85 26		sta $26				sta 	zVarType
.c678	68		pla				pla
.c679	85 25		sta $25				sta 	zVarDataPtr+1
.c67b	68		pla				pla
.c67c	85 24		sta $24				sta 	zVarDataPtr
.c67e	20 da c7	jsr $c7da			jsr 	ArrayIndexFollow 		; do the index.
.c681	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.c683	29 01		and #$01			and 	#1
.c685	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c687	d0 05		bne $c68e			bne 	_VFArrayDone 			; if so then exit.
.c689	20 a2 c3	jsr $c3a2			jsr 	CheckNextComma 			; comma should follow
.c68c	80 db		bra $c669			bra 	_VFNextIndex
.c68e					_VFArrayDone:
.c68e	20 99 c3	jsr $c399			jsr 	CheckNextRParen 		; check closing right bracket.
.c691					_VFSingleElement:
.c691	60		rts				rts
.c692					VariableClear:
.c692	48		pha				pha 							; save registers
.c693	da		phx				phx
.c694	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.c696	8a		txa				txa
.c697	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.c69a	e8		inx				inx
.c69b	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.c69d	d0 f8		bne $c697			bne 	_VCLoop
.c69f	a9 00		lda #$00			lda 	#VariableMemory & $FF
.c6a1	8d 02 03	sta $0302			sta 	VarMemPtr
.c6a4	a9 20		lda #$20			lda 	#VariableMemory >> 8
.c6a6	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c6a9	fa		plx				plx 							; restore registers
.c6aa	68		pla				pla
.c6ab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.c6ac					VariableNameError:
.c6ac	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c6af	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>c6b7	61 62 6c 65 20 4e 61 6d 65 00
.c6c1					VariableExtract:
.c6c1	da		phx				phx 							; save X.
.c6c2	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.c6c4	8d 95 03	sta $0395			sta 	Var_Type
.c6c7	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.c6ca	ea		nop				nop
.c6cb	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c6cd	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.c6cf	f0 db		beq $c6ac			beq 	VariableNameError
.c6d1	c9 1b		cmp #$1b			cmp 	#26+1
.c6d3	b0 d7		bcs $c6ac			bcs 	VariableNameError
.c6d5	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.c6d7					_VECopyBuffer:
.c6d7	e8		inx				inx
.c6d8	e0 1f		cpx #$1f			cpx 	#31 					; too long
.c6da	f0 d0		beq $c6ac			beq 	VariableNameError
.c6dc	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.c6df	18		clc				clc  							; update the hash value for it.
.c6e0	6d 96 03	adc $0396			adc 	Var_Hash
.c6e3	8d 96 03	sta $0396			sta 	Var_Hash
.c6e6	1b		inz				inz
.c6e7	ea		nop				nop
.c6e8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c6ea	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.c6ec	f0 0e		beq $c6fc			beq 	_VECopyEnd
.c6ee	30 0c		bmi $c6fc			bmi 	_VECopyEnd
.c6f0	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.c6f2	90 e3		bcc $c6d7			bcc 	_VECopyBuffer
.c6f4	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.c6f6	90 04		bcc $c6fc			bcc 	_VECopyEnd
.c6f8	c9 3a		cmp #$3a			cmp 	#"9"+1
.c6fa	90 db		bcc $c6d7			bcc 	_VECopyBuffer
.c6fc					_VECopyEnd:
.c6fc	1b		inz				inz
.c6fd	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.c6ff	90 04		bcc $c705			bcc 	_VEDefaultRequired
.c701	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.c703	90 0b		bcc $c710			bcc 	_VEHaveType
.c705					_VEDefaultRequired:
.c705	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.c707	f0 04		beq $c70d			beq 	_VESetType 				; default set above.
.c709	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.c70c	3b		dez				dez
.c70d					_VESetType:
.c70d	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.c710					_VEHaveType:
.c710	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.c713	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.c716	09 80		ora #$80			ora 	#$80
.c718	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.c71b	e8		inx				inx 							; offset 3 => length 4.
.c71c	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.c71f	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.c722	38		sec				sec
.c723	e9 b7		sbc #$b7			sbc 	#token_Dollar
.c725	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.c726	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.c727	0a		asl a				asl 	a
.c728	0a		asl a				asl 	a
.c729	8d 98 03	sta $0398			sta 	Var_HashAddress
.c72c	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.c72f	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.c731	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.c732	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.c735	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.c737	8d 98 03	sta $0398			sta 	Var_HashAddress
.c73a	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.c73c	ad 95 03	lda $0395			lda 	Var_Type
.c73f	c9 b9		cmp #$b9			cmp 	#token_Hash
.c741	f0 07		beq $c74a			beq 	_VEHaveSize
.c743	ca		dex				dex
.c744	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.c746	f0 02		beq $c74a			beq 	_VEHaveSize
.c748	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.c74a					_VEHaveSize:
.c74a	8e 99 03	stx $0399			stx 	Var_DataSize
.c74d	fa		plx				plx
.c74e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.c74f					VariableCreate:
.c74f	da		phx				phx
.c750	5a		phy				phy
.c751	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.c754	85 10		sta $10				sta 	zTemp1
.c756	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c759	85 11		sta $11				sta 	zTemp1+1
.c75b	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.c75e	18		clc				clc
.c75f	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.c762	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.c764	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.c767	8d 02 03	sta $0302			sta 	VarMemPtr
.c76a	90 03		bcc $c76f			bcc 	_VCNoCarry
.c76c	ee 03 03	inc $0303			inc 	VarMemPtr+1
.c76f					_VCNoCarry:
.c76f	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c772	85 12		sta $12				sta 	zTemp2
.c774	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c776	85 13		sta $13				sta 	zTemp2+1
.c778	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.c77a	b1 12		lda ($12),y			lda 	(zTemp2),y
.c77c	91 10		sta ($10),y			sta 	(zTemp1),y
.c77e	c8		iny				iny
.c77f	b1 12		lda ($12),y			lda 	(zTemp2),y
.c781	91 10		sta ($10),y			sta 	(zTemp1),y
.c783	c8		iny				iny
.c784	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.c787	91 10		sta ($10),y			sta 	(zTemp1),y
.c789	c8		iny				iny
.c78a	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.c78c					_VCCopyName:
.c78c	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.c78f	91 10		sta ($10),y			sta 	(zTemp1),y
.c791	e8		inx				inx
.c792	c8		iny				iny
.c793	ec 97 03	cpx $0397			cpx 	Var_Length
.c796	d0 f4		bne $c78c			bne 	_VCCopyName
.c798	5a		phy				phy 								; save the data offset.
.c799	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.c79c	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.c79e					_VCClearData:
.c79e	91 10		sta ($10),y			sta 	(zTemp1),y
.c7a0	c8		iny				iny
.c7a1	ca		dex				dex
.c7a2	d0 fa		bne $c79e			bne 	_VCClearData
.c7a4	68		pla				pla 								; offset to the data
.c7a5	18		clc				clc
.c7a6	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.c7a8	85 24		sta $24				sta 	zVarDataPtr
.c7aa	a5 11		lda $11				lda 	zTemp1+1
.c7ac	69 00		adc #$00			adc 	#0
.c7ae	85 25		sta $25				sta 	zVarDataPtr+1
.c7b0	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c7b3	85 26		sta $26				sta 	zVarType
.c7b5	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.c7b7	a0 00		ldy #$00			ldy 	#0
.c7b9	91 12		sta ($12),y			sta 	(zTemp2),y
.c7bb	c8		iny				iny
.c7bc	a5 11		lda $11				lda 	zTemp1+1
.c7be	91 12		sta ($12),y			sta 	(zTemp2),y
.c7c0	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.c7c3	29 01		and #$01			and 	#1
.c7c5	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.c7c7	d0 0e		bne $c7d7			bne 	_VCNotArray
.c7c9	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.c7cb	20 71 c8	jsr $c871			jsr 	ArrayCreate
.c7ce	5a		phy				phy 								; save YA at zVarDataPtr
.c7cf	a0 00		ldy #$00			ldy 	#0
.c7d1	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c7d3	c8		iny				iny
.c7d4	68		pla				pla
.c7d5	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c7d7					_VCNotArray:
.c7d7	7a		ply				ply
.c7d8	fa		plx				plx
.c7d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.c7da					ArrayIndexFollow:
.c7da	5a		phy				phy
.c7db	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.c7dd	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.c7df	48		pha				pha
.c7e0	c8		iny				iny
.c7e1	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c7e3	85 25		sta $25				sta 	zVarDataPtr+1
.c7e5	68		pla				pla
.c7e6	85 24		sta $24				sta 	zVarDataPtr
.c7e8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.c7ea	29 80		and #$80			and 	#$80 						; must be zero.
.c7ec	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c7ee	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c7f0	d0 59		bne $c84b			bne 	_AIFError
.c7f2	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.c7f4	18		clc				clc
.c7f5	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c7f7	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c7f9	c8		iny				iny
.c7fa	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c7fc	08		php				php 								; clear bit 7 retaining borrow.
.c7fd	29 7f		and #$7f			and 	#$7F
.c7ff	28		plp				plp
.c800	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c802	90 47		bcc $c84b			bcc 	_AIFError 					; eror if size-current < 0
.c804	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.c806	0a		asl a				asl 	a 							; (e.g. index * 2)
.c807	85 10		sta $10				sta 	zTemp1
.c809	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c80b	2a		rol a				rol 	a
.c80c	85 11		sta $11				sta 	zTemp1+1
.c80e	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.c810	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.c812	30 1d		bmi $c831			bmi 	_AIFCalculate
.c814	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.c816	a5 26		lda $26				lda 	zVarType 					; check that type
.c818	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.c81a	f0 15		beq $c831			beq 	_AIFCalculate
.c81c	06 10		asl $10				asl 	zTemp1			 			; double the index
.c81e	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.c820	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.c822	f0 0d		beq $c831			beq 	_AIFCalculate
.c824	18		clc				clc 								; add the original mantissa in again
.c825	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.c827	65 10		adc $10				adc 	zTemp1
.c829	85 10		sta $10				sta 	zTemp1
.c82b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c82d	65 11		adc $11				adc 	zTemp1+1
.c82f	85 11		sta $11				sta 	zTemp1+1
.c831					_AIFCalculate:
.c831	18		clc				clc 								; add index x 2,4 or 5 to base
.c832	a5 24		lda $24				lda 	zVarDataPtr
.c834	65 10		adc $10				adc 	zTemp1
.c836	85 24		sta $24				sta 	zVarDataPtr
.c838	a5 25		lda $25				lda 	zVarDataPtr+1
.c83a	65 11		adc $11				adc 	zTemp1+1
.c83c	85 25		sta $25				sta 	zVarDataPtr+1
.c83e	18		clc				clc 								; add 2 more for the length prefix.
.c83f	a5 24		lda $24				lda 	zVarDataPtr
.c841	69 02		adc #$02			adc 	#2
.c843	85 24		sta $24				sta 	zVarDataPtr
.c845	90 02		bcc $c849			bcc 	_AIFNoBump
.c847	e6 25		inc $25				inc 	zVarDataPtr+1
.c849					_AIFNoBump:
.c849	7a		ply				ply
.c84a	60		rts				rts
.c84b					_AIFError:
.c84b	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c84e	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c856	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.c85e					ArrayResetDefault:
.c85e	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.c860	8d a9 03	sta $03a9			sta 	ArrayDef+0
.c863	a9 00		lda #$00			lda 	#0
.c865	8d aa 03	sta $03aa			sta 	ArrayDef+1
.c868	a9 ff		lda #$ff			lda 	#$FF
.c86a	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.c86d	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.c870	60		rts				rts
.c871					ArrayCreate:
.c871	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.c874	0a		asl a				asl 	a
.c875	85 10		sta $10				sta 	zTemp1
.c877	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c87a	2a		rol a				rol 	a
.c87b	85 11		sta $11				sta 	zTemp1+1
.c87d	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.c880	10 22		bpl $c8a4			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.c882	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.c885	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.c887	f0 1b		beq $c8a4			beq 	_ACSized
.c889	06 10		asl $10				asl 	zTemp1 						; double again
.c88b	26 11		rol $11				rol 	zTemp1+1
.c88d	b0 6f		bcs $c8fe			bcs 	ArrayIndexError 			; too large.
.c88f	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.c891	f0 11		beq $c8a4			beq 	_ACSized
.c893	18		clc				clc 								; add original value x 5 for reals.
.c894	a5 10		lda $10				lda 	zTemp1
.c896	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.c899	85 10		sta $10				sta 	zTemp1
.c89b	a5 11		lda $11				lda 	zTemp1+1
.c89d	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.c8a0	85 11		sta $11				sta 	zTemp1+1
.c8a2	b0 5a		bcs $c8fe			bcs 	ArrayIndexError
.c8a4					_ACSized:
.c8a4	18		clc				clc
.c8a5	a5 10		lda $10				lda 	zTemp1
.c8a7	69 02		adc #$02			adc 	#2
.c8a9	85 10		sta $10				sta 	zTemp1
.c8ab	90 04		bcc $c8b1			bcc 	_ACNoBump
.c8ad	e6 10		inc $10				inc 	zTemp1
.c8af	f0 4d		beq $c8fe			beq 	ArrayIndexError
.c8b1					_ACNoBump:
.c8b1	18		clc				clc
.c8b2	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.c8b5	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.c8b7	85 14		sta $14				sta 	zTemp3
.c8b9	65 10		adc $10				adc 	zTemp1
.c8bb	8d 02 03	sta $0302			sta 	VarMemPtr
.c8be	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c8c1	85 13		sta $13				sta 	zTemp2+1
.c8c3	85 15		sta $15				sta 	zTemp3+1
.c8c5	65 11		adc $11				adc 	zTemp1+1
.c8c7	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c8ca	85 11		sta $11				sta 	zTemp1+1
.c8cc	b0 30		bcs $c8fe			bcs 	ArrayIndexError
.c8ce	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.c8d0					_ACClear:
.c8d0	98		tya				tya
.c8d1	91 12		sta ($12),y			sta 	(zTemp2),y
.c8d3	e6 12		inc $12				inc 	zTemp2
.c8d5	d0 02		bne $c8d9			bne 	_ACCBump
.c8d7	e6 13		inc $13				inc 	zTemp2+1
.c8d9					_ACCBump:
.c8d9	a5 12		lda $12				lda 	zTemp2
.c8db	cd 02 03	cmp $0302			cmp 	VarMemPtr
.c8de	d0 f0		bne $c8d0			bne 	_ACClear
.c8e0	a5 13		lda $13				lda 	zTemp2+1
.c8e2	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.c8e5	d0 e9		bne $c8d0			bne 	_ACClear
.c8e7	a0 00		ldy #$00			ldy 	#0
.c8e9	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.c8ec	91 14		sta ($14),y			sta 	(zTemp3),y
.c8ee	c8		iny				iny
.c8ef	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c8f2	91 14		sta ($14),y			sta 	(zTemp3),y
.c8f4	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.c8f7	10 18		bpl $c911			bpl 	ACCFillRecursive
.c8f9	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.c8fb	a5 14		lda $14				lda 	zTemp3
.c8fd	60		rts				rts
.c8fe					ArrayIndexError:
.c8fe	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c901	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c909	79 20 69 6e 64 65 78 00
.c911					ACCFillRecursive:
.c911	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.c913	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.c915	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.c917	c8		iny				iny
.c918	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.c91a	09 80		ora #$80			ora 	#$80 						; an array of pointers
.c91c	91 14		sta ($14),y			sta 	(zTemp3),y
.c91e	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.c920	48		pha				pha
.c921	a5 15		lda $15				lda 	zTemp3+1
.c923	48		pha				pha
.c924					_ACCFillLoop:
.c924	18		clc				clc
.c925	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.c927	69 02		adc #$02			adc 	#2
.c929	85 14		sta $14				sta 	zTemp3
.c92b	90 02		bcc $c92f			bcc 	_ACCSkip2
.c92d	e6 15		inc $15				inc 	zTemp3+1
.c92f					_ACCSkip2:
.c92f	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.c931	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.c933	c8		iny				iny
.c934	11 14		ora ($14),y			ora 	(zTemp3),y
.c936	d0 21		bne $c959			bne 	_ACCExit
.c938	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.c93a	48		pha				pha
.c93b	a5 15		lda $15				lda 	zTemp3+1
.c93d	48		pha				pha
.c93e	e8		inx				inx
.c93f	e8		inx				inx
.c940	20 71 c8	jsr $c871			jsr 	ArrayCreate 				; create array recursively.
.c943	ca		dex				dex
.c944	ca		dex				dex
.c945	85 12		sta $12				sta 	zTemp2 						; save A
.c947	68		pla				pla
.c948	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.c94a	68		pla				pla
.c94b	85 14		sta $14				sta 	zTemp3
.c94d	98		tya				tya 								; write high bye from Y
.c94e	a0 01		ldy #$01			ldy 	#1
.c950	91 14		sta ($14),y			sta 	(zTemp3),y
.c952	88		dey				dey 								; write low byte out.
.c953	a5 12		lda $12				lda 	zTemp2
.c955	91 14		sta ($14),y			sta 	(zTemp3),y
.c957	80 cb		bra $c924			bra 	_ACCFillLoop 				; and try again.
.c959					_ACCExit:
.c959	7a		ply				ply 								; restore the original address
.c95a	68		pla				pla
.c95b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.c95c					VariableLocate:
.c95c	da		phx				phx
.c95d	5a		phy				phy
.c95e	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c961	85 12		sta $12				sta 	zTemp2 						; points to first address.
.c963	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c965	85 13		sta $13				sta 	zTemp2+1
.c967	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.c969	b1 12		lda ($12),y			lda 	(zTemp2),y
.c96b	aa		tax				tax
.c96c	c8		iny				iny
.c96d	b1 12		lda ($12),y			lda 	(zTemp2),y
.c96f	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c971	86 12		stx $12				stx 	zTemp2
.c973	05 12		ora $12				ora 	zTemp2 						; got zero
.c975	18		clc				clc
.c976	f0 25		beq $c99d			beq 	_VLExit 					; if so, then fail as end of chain.
.c978	c8		iny				iny 								; point to hash (offset + 2)
.c979	b1 12		lda ($12),y			lda 	(zTemp2),y
.c97b	cd 96 03	cmp $0396			cmp 	Var_Hash
.c97e	d0 e7		bne $c967			bne 	_VLNext 					; try next if different.
.c980					_VLCompare:
.c980	c8		iny				iny 								; next character
.c981	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c983	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c986	d0 df		bne $c967			bne 	_VLNext 					; fail if different, try next.
.c988	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c989	90 f5		bcc $c980			bcc 	_VLCompare
.c98b	98		tya				tya
.c98c	38		sec				sec 								; add 1 as Y points to last character
.c98d	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c98f	85 24		sta $24				sta 	zVarDataPtr
.c991	a5 13		lda $13				lda 	zTemp2+1
.c993	69 00		adc #$00			adc 	#0
.c995	85 25		sta $25				sta 	zVarDataPtr+1
.c997	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c99a	85 26		sta $26				sta 	zVarType
.c99c	38		sec				sec 								; return CS
.c99d	7a		ply		_VLExit:ply
.c99e	fa		plx				plx
.c99f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c9a0					VariableGet:
.c9a0	5a		phy				phy
.c9a1	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c9a3	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c9a5	95 80		sta $80,x			sta 	XS_Mantissa,x
.c9a7	c8		iny				iny
.c9a8	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c9aa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c9ac	c8		iny				iny
.c9ad	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.c9af	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c9b1	f0 2c		beq $c9df			beq 	_VGString
.c9b3	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c9b5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c9b7	c8		iny				iny
.c9b8	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c9ba	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c9bc	c8		iny				iny
.c9bd	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c9bf	95 85		sta $85,x			sta 	XS_Type,x
.c9c1	a5 26		lda $26				lda 	zVarType
.c9c3	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.c9c5	f0 28		beq $c9ef			beq 	_VGExit
.c9c7	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.c9c9	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.c9cb	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.c9cd	95 84		sta $84,x			sta 	XS_Exponent,x
.c9cf	f0 1e		beq $c9ef			beq 	_VGExit 					; if exponent is zero ... it's zero.
.c9d1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.c9d3	48		pha				pha
.c9d4	29 80		and #$80			and 	#$80
.c9d6	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.c9d8	68		pla				pla
.c9d9	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.c9db	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.c9dd	80 10		bra $c9ef			bra 	_VGExit
.c9df					_VGString:
.c9df	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.c9e1	95 85		sta $85,x			sta 	XS_Type,x
.c9e3	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.c9e5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c9e7	d0 06		bne $c9ef			bne 	_VGExit 					; if not, exit.
.c9e9	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.c9eb	a9 27		lda #$27			lda 	#zNullString
.c9ed	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.c9ef					_VGExit:
.c9ef	7a		ply				ply
.c9f0	60		rts				rts
.c9f1					VariableSet:
.c9f1	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.c9f3	29 02		and #$02			and 	#2 							; if so, it has to be
.c9f5	d0 4b		bne $ca42			bne 	_VSString
.c9f7	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.c9f9	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c9fb	f0 42		beq $ca3f			beq 	_VSBadType
.c9fd	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.c9ff	f0 05		beq $ca06			beq 	_VSMakeInt
.ca01	20 65 cf	jsr $cf65			jsr 	FPUToFloat
.ca04	80 03		bra $ca09			bra 	_VSCopy
.ca06					_VSMakeInt:
.ca06	20 b1 cf	jsr $cfb1			jsr 	FPUToInteger
.ca09					_VSCopy:
.ca09	5a		phy				phy
.ca0a	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.ca0c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ca0e	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca10	c8		iny				iny
.ca11	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ca13	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca15	c8		iny				iny
.ca16	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ca18	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca1a	c8		iny				iny
.ca1b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ca1d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca1f	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.ca21	c9 bb		cmp #$bb			cmp 	#token_Percent
.ca23	f0 18		beq $ca3d			beq 	_VSExit
.ca25	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.ca27	0a		asl a				asl 	a
.ca28	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.ca2a	08		php				php
.ca2b	0a		asl a				asl 	a
.ca2c	28		plp				plp
.ca2d	6a		ror a				ror 	a
.ca2e	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca30	c8		iny				iny
.ca31	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.ca33	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca35	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.ca37	50 04		bvc $ca3d			bvc 	_VSExit
.ca39	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.ca3b	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca3d					_VSExit:
.ca3d	7a		ply				ply
.ca3e	60		rts				rts
.ca3f					_VSBadType:
.ca3f	4c 89 ae	jmp $ae89			jmp 	TypeError
.ca42					_VSString:
.ca42	a5 26		lda $26				lda 	zVarType 					; type must be $
.ca44	c9 b7		cmp #$b7			cmp 	#token_Dollar
.ca46	d0 f7		bne $ca3f			bne 	_VSBadType
.ca48	da		phx				phx
.ca49	5a		phy				phy
.ca4a	20 ab c3	jsr $c3ab			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.ca4d	a0 01		ldy #$01			ldy 	#1 							; save high byte
.ca4f	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca51	88		dey				dey 								; save low byte
.ca52	8a		txa				txa
.ca53	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca55	7a		ply				ply 								; and exit.
.ca56	fa		plx				plx
.ca57	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.ca58					MulInteger32:
.ca58	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.ca5a	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.ca5c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ca5e	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.ca60	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ca62	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.ca64	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ca66	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.ca68	a9 00		lda #$00			lda 	#0
.ca6a	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.ca6c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ca6e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ca70	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ca72					_BFMMultiply:
.ca72	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.ca74	29 01		and #$01			and 	#1
.ca76	f0 03		beq $ca7b			beq 	_BFMNoAdd
.ca78	20 db be	jsr $bedb			jsr 	AddInteger32 					; co-opt this code
.ca7b					_BFMNoAdd:
.ca7b	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.ca7d	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.ca7f	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.ca81	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.ca83	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.ca85	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.ca87	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.ca89	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.ca8b	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.ca8d	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.ca8f	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.ca91	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.ca93	d0 dd		bne $ca72			bne 	_BFMMultiply
.ca95	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.ca96					DivInteger32:
.ca96	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.ca98	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.ca9a	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.ca9c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.ca9e	d0 14		bne $cab4			bne 	_BFDOkay
.caa0	20 a8 ae	jsr $aea8			jsr ERR_Handler
>caa3	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>caab	20 62 79 20 5a 65 72 6f 00
.cab4					_BFDOkay:
.cab4	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.cab6	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.cab8	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.caba	85 1e		sta $1e				sta 	zLTemp1+2
.cabc	85 1f		sta $1f				sta 	zLTemp1+3
.cabe	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.cac1	20 18 cb	jsr $cb18			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.cac4	da		phx				phx
.cac5	e8		inx				inx
.cac6	e8		inx				inx
.cac7	e8		inx				inx
.cac8	e8		inx				inx
.cac9	e8		inx				inx
.caca	e8		inx				inx
.cacb	20 18 cb	jsr $cb18			jsr 	CheckIntegerNegate
.cace	fa		plx				plx
.cacf	5a		phy				phy 								; Y is the counter
.cad0	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.cad2					_BFDLoop:
.cad2	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.cad4	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.cad6	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.cad8	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.cada	26 1c		rol $1c				rol 	zLTemp1
.cadc	26 1d		rol $1d				rol 	zLTemp1+1
.cade	26 1e		rol $1e				rol 	zLTemp1+2
.cae0	26 1f		rol $1f				rol 	zLTemp1+3
.cae2	38		sec				sec
.cae3	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.cae5	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.cae7	48		pha				pha
.cae8	a5 1d		lda $1d				lda 	zLTemp1+1
.caea	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.caec	48		pha				pha
.caed	a5 1e		lda $1e				lda 	zLTemp1+2
.caef	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.caf1	48		pha				pha
.caf2	a5 1f		lda $1f				lda 	zLTemp1+3
.caf4	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.caf6	90 13		bcc $cb0b			bcc 	_BFDNoAdd
.caf8	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.cafa	68		pla				pla
.cafb	85 1e		sta $1e				sta 	zLTemp1+2
.cafd	68		pla				pla
.cafe	85 1d		sta $1d				sta 	zLTemp1+1
.cb00	68		pla				pla
.cb01	85 1c		sta $1c				sta 	zLTemp1+0
.cb03	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.cb05	09 01		ora #$01			ora 	#1
.cb07	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cb09	80 03		bra $cb0e			bra 	_BFDNext
.cb0b					_BFDNoAdd:
.cb0b	68		pla				pla 								; Throw away the intermediate calculations
.cb0c	68		pla				pla
.cb0d	68		pla				pla
.cb0e					_BFDNext:
.cb0e	88		dey				dey
.cb0f	d0 c1		bne $cad2			bne 	_BFDLoop
.cb11	7a		ply				ply 								; restore Y
.cb12	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.cb15	b0 06		bcs $cb1d			bcs		IntegerNegateAlways 		; negate the result
.cb17	60		rts				rts
.cb18					CheckIntegerNegate:
.cb18	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.cb1a	30 01		bmi $cb1d			bmi 	IntegerNegateAlways 		; if so negate it
.cb1c	60		rts				rts
.cb1d					IntegerNegateAlways:
.cb1d	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.cb20	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.cb21	a9 00		lda #$00			lda 	#0
.cb23	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.cb25	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cb27	a9 00		lda #$00			lda 	#0
.cb29	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.cb2b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cb2d	a9 00		lda #$00			lda 	#0
.cb2f	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.cb31	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cb33	a9 00		lda #$00			lda 	#0
.cb35	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.cb37	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cb39	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cb3a					INTToString:
.cb3a	48		pha				pha
.cb3b	5a		phy				phy
.cb3c	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.cb3e	10 08		bpl $cb48			bpl 		_ITSNotMinus
.cb40	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cb42	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.cb45	20 1d cb	jsr $cb1d			jsr 		IntegerNegateAlways 	; negate the number.
.cb48					_ITSNotMinus:
.cb48	a9 00		lda #$00			lda 		#0
.cb4a	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.cb4d	8a		txa				txa 								; use Y for the mantissa index.
.cb4e	a8		tay				tay
.cb4f	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.cb51					_ITSNextSubtractor:
.cb51	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cb53	8d 9b 03	sta $039b			sta 		NumConvCount
.cb56					_ITSSubtract:
.cb56	38		sec				sec
.cb57	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.cb5a	fd b4 cb	sbc $cbb4,x			sbc 		_ITSSubtractors+0,x
.cb5d	48		pha				pha
.cb5e	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.cb61	fd b5 cb	sbc $cbb5,x			sbc 		_ITSSubtractors+1,x
.cb64	48		pha				pha
.cb65	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.cb68	fd b6 cb	sbc $cbb6,x			sbc 		_ITSSubtractors+2,x
.cb6b	48		pha				pha
.cb6c	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.cb6f	fd b7 cb	sbc $cbb7,x			sbc 		_ITSSubtractors+3,x
.cb72	90 14		bcc $cb88			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cb74	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.cb77	68		pla				pla
.cb78	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.cb7b	68		pla				pla
.cb7c	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.cb7f	68		pla				pla
.cb80	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.cb83	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.cb86	80 ce		bra $cb56			bra 		_ITSSubtract 			; go round again.
.cb88					_ITSCantSubtract:
.cb88	68		pla				pla 								; throw away interim answers
.cb89	68		pla				pla
.cb8a	68		pla				pla
.cb8b	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.cb8e	c9 30		cmp #$30			cmp 		#"0"
.cb90	d0 05		bne $cb97			bne 		_ITSOutputDigit
.cb92	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cb95	10 09		bpl $cba0			bpl	 		_ITSGoNextSubtractor
.cb97					_ITSOutputDigit:
.cb97	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.cb9a	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.cb9d	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter 		; output it.
.cba0					_ITSGoNextSubtractor:
.cba0	e8		inx				inx 								; next dword
.cba1	e8		inx				inx
.cba2	e8		inx				inx
.cba3	e8		inx				inx
.cba4	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.cba6	d0 a9		bne $cb51			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cba8	98		tya				tya 								; X is back as the mantissa index
.cba9	aa		tax				tax
.cbaa	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cbac	09 30		ora #$30			ora 		#"0"
.cbae	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.cbb1	7a		ply				ply 								; and exit
.cbb2	68		pla				pla
.cbb3	60		rts				rts
.cbb4					_ITSSubtractors:
>cbb4	00 ca 9a 3b					.dword 		1000000000
>cbb8	00 e1 f5 05					.dword 		100000000
>cbbc	80 96 98 00					.dword 		10000000
>cbc0	40 42 0f 00					.dword 		1000000
>cbc4	a0 86 01 00					.dword 		100000
>cbc8	10 27 00 00					.dword 		10000
>cbcc	e8 03 00 00					.dword 		1000
>cbd0	64 00 00 00					.dword 		100
>cbd4	0a 00 00 00					.dword 		10
.cbd8					_ITSSubtractorsEnd:
.cbd8					ITSOutputCharacter:
.cbd8	48		pha				pha
.cbd9	da		phx				phx
.cbda	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.cbdd	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.cbe0	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cbe2	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.cbe5	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.cbe8	fa		plx				plx
.cbe9	68		pla				pla
.cbea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cbeb					IntFromString:
.cbeb	a0 00		ldy #$00			ldy 	#0
.cbed					IntFromStringY:
.cbed	a9 00		lda #$00			lda 	#0
.cbef	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.cbf2	48		pha				pha
.cbf3	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.cbf5	95 80		sta $80,x			sta 	XS_Mantissa,x
.cbf7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cbf9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cbfb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cbfd	a9 01		lda #$01			lda 	#1
.cbff	95 85		sta $85,x			sta 	XS_Type,x
.cc01					_IFSLoop:
.cc01	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.cc03	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.cc05	90 4e		bcc $cc55			bcc 	_IFSExit
.cc07	c9 3a		cmp #$3a			cmp 	#"9"+1
.cc09	b0 4a		bcs $cc55			bcs 	_IFSExit
.cc0b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cc0d	c9 0c		cmp #$0c			cmp 	#12
.cc0f	b0 4e		bcs $cc5f			bcs 	_IFSOverflow
.cc11	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cc13	48		pha				pha
.cc14	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cc16	48		pha				pha
.cc17	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cc19	48		pha				pha
.cc1a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.cc1c	48		pha				pha
.cc1d	20 74 cc	jsr $cc74			jsr 	IFSX1ShiftLeft 				; double
.cc20	20 74 cc	jsr $cc74			jsr 	IFSX1ShiftLeft 				; x 4
.cc23	18		clc				clc 								; add saved value x 5
.cc24	68		pla				pla
.cc25	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.cc27	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cc29	68		pla				pla
.cc2a	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.cc2c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cc2e	68		pla				pla
.cc2f	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.cc31	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cc33	68		pla				pla
.cc34	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.cc36	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cc38	20 74 cc	jsr $cc74			jsr 	IFSX1ShiftLeft 				; x 10
.cc3b	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.cc3e	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.cc40	29 0f		and #$0f			and 	#15
.cc42	c8		iny				iny
.cc43	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.cc45	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cc47	90 b8		bcc $cc01			bcc 	_IFSLoop
.cc49	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cc4b	d0 b4		bne $cc01			bne 	_IFSLoop
.cc4d	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.cc4f	d0 b0		bne $cc01			bne 	_IFSLoop
.cc51	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.cc53	80 ac		bra $cc01			bra 	_IFSLoop
.cc55					_IFSExit:
.cc55	98		tya				tya 								; get offset
.cc56					_IFSOkay:
.cc56	38		sec				sec
.cc57	ad 9c 03	lda $039c			lda 	ExpTemp
.cc5a	f0 01		beq $cc5d			beq 	_IFSSkipFail
.cc5c	18		clc				clc
.cc5d					_IFSSkipFail:
.cc5d	68		pla				pla 								; and exit.
.cc5e	60		rts				rts
.cc5f					_IFSOverflow:
.cc5f	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>cc62	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cc6a	20 6f 76 65 72 66 6c 6f 77 00
.cc74					IFSX1ShiftLeft:
.cc74	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.cc76	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.cc78	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.cc7a	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.cc7c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.cc7d					FPSubtract:
.cc7d	48		pha				pha
.cc7e	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.cc80	49 80		eor #$80			eor 	#$80
.cc82	95 8b		sta $8b,x			sta 	XS2_Type,x
.cc84	68		pla				pla 								; --- and fall through ---
.cc85					FPAdd:
.cc85	48		pha				pha
.cc86	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.cc88	d0 05		bne $cc8f			bne 	_FPA_NegativeLHS
.cc8a	20 a6 cc	jsr $cca6			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cc8d	68		pla				pla
.cc8e	60		rts				rts
.cc8f					_FPA_NegativeLHS:
.cc8f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.cc91	49 80		eor #$80			eor 	#$80
.cc93	95 85		sta $85,x			sta 	XS_Type,x
.cc95	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.cc97	49 80		eor #$80			eor 	#$80
.cc99	95 8b		sta $8b,x			sta 	XS2_Type,x
.cc9b	20 a6 cc	jsr $cca6			jsr 	FPAdd_Worker 				; do the add calculation.
.cc9e	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.cca0	49 80		eor #$80			eor 	#$80
.cca2	95 85		sta $85,x			sta 	XS_Type,x
.cca4	68		pla				pla
.cca5	60		rts				rts
.cca6					FPAdd_Worker:
.cca6	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cca8	70 07		bvs $ccb1			bvs 	_FPAWExit 					; no change.
.ccaa	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.ccac	50 07		bvc $ccb5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.ccae	20 23 cf	jsr $cf23			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.ccb1					_FPAWExit:
.ccb1	20 92 cf	jsr $cf92			jsr 	FPUNormalise 				; normalise the result.
.ccb4	60		rts				rts
.ccb5					_FPAWMakeSame:
.ccb5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.ccb7	38		sec				sec
.ccb8	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.ccba	f0 16		beq $ccd2			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.ccbc	da		phx				phx 								; save X
.ccbd	90 06		bcc $ccc5			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.ccbf	e8		inx				inx
.ccc0	e8		inx				inx
.ccc1	e8		inx				inx
.ccc2	e8		inx				inx
.ccc3	e8		inx				inx
.ccc4	e8		inx				inx
.ccc5					_FPAWShiftA:
.ccc5	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ccc7	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.ccc9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cccb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cccd	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cccf	fa		plx				plx 								; restore original X
.ccd0	80 e3		bra $ccb5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.ccd2					_FPAW_DoArithmetic:
.ccd2	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.ccd4	30 28		bmi $ccfe			bmi 	_FPAW_BNegative
.ccd6	18		clc				clc
.ccd7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ccd9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.ccdb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ccdd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ccdf	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.cce1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cce3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cce5	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.cce7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cce9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cceb	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.cced	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ccef	90 c0		bcc $ccb1			bcc 	_FPAWExit 					; no carry.
.ccf1	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ccf3	38		sec				sec
.ccf4	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.ccf6	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.ccf8	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.ccfa	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.ccfc	80 b3		bra $ccb1			bra 	_FPAWExit
.ccfe					_FPAW_BNegative:
.ccfe	38		sec				sec
.ccff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.cd01	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.cd03	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cd05	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cd07	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cd09	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cd0b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cd0d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.cd0f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cd11	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cd13	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.cd15	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cd17	b0 09		bcs $cd22			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.cd19	20 49 cf	jsr $cf49			jsr 	FPUNegateInteger			; negate the mantissa
.cd1c	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.cd1e	49 80		eor #$80			eor 	#$80
.cd20	95 85		sta $85,x			sta 	XS_Type,x
.cd22					_FPAWGoExit:
.cd22	4c b1 cc	jmp $ccb1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cd25					FPD_IsDivZero:
.cd25	20 a8 ae	jsr $aea8			jsr ERR_Handler
>cd28	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>cd30	20 62 79 20 7a 65 72 6f 00
.cd39					FPDivide:
.cd39	48		pha				pha
.cd3a	5a		phy				phy
.cd3b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.cd3d	70 e6		bvs $cd25			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cd3f	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cd41	f0 03		beq $cd46			beq 	_FPDCalculateExp
.cd43					_FPD_Exit:
.cd43	7a		ply				ply
.cd44	68		pla				pla
.cd45	60		rts				rts
.cd46					_FPDCalculateExp:
.cd46	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cd48	49 ff		eor #$ff			eor 	#$FF
.cd4a	1a		inc a				inc 	a
.cd4b	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.cd4d	20 1d ce	jsr $ce1d			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cd50	18		clc				clc 	 							; add 1 to the resulting exponent
.cd51	69 01		adc #$01			adc 	#1
.cd53	b0 54		bcs $cda9			bcs 	_FPD_Overflow 				; which can overflow.
.cd55	95 84		sta $84,x			sta 	XS_Exponent,x
.cd57	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cd59	85 1c		sta $1c				sta 	zLTemp1+0
.cd5b	85 1d		sta $1d				sta 	zLTemp1+1
.cd5d	85 1e		sta $1e				sta 	zLTemp1+2
.cd5f	85 1f		sta $1f				sta 	zLTemp1+3
.cd61	a0 20		ldy #$20			ldy 	#32 						; times round.
.cd63					_FPD_Loop:
.cd63	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cd64	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.cd66	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.cd68	48		pha				pha
.cd69	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cd6b	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cd6d	48		pha				pha
.cd6e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cd70	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.cd72	48		pha				pha
.cd73	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cd75	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.cd77	90 13		bcc $cd8c			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cd79	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cd7b	68		pla				pla
.cd7c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cd7e	68		pla				pla
.cd7f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cd81	68		pla				pla
.cd82	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cd84	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.cd86	09 80		ora #$80			ora 	#$80
.cd88	85 1f		sta $1f				sta 	zLTemp1+3
.cd8a	80 03		bra $cd8f			bra 	_FPD_Rotates
.cd8c					_FPD_NoSubtract:
.cd8c	68		pla				pla 								; throw away unwanted results
.cd8d	68		pla				pla
.cd8e	68		pla				pla
.cd8f					_FPD_Rotates:
.cd8f	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.cd91	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.cd93	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.cd95	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.cd97	06 1c		asl $1c				asl 	zLTemp1 					; rotate result round left
.cd99	26 1d		rol $1d				rol 	zLTemp1+1
.cd9b	26 1e		rol $1e				rol 	zLTemp1+2
.cd9d	26 1f		rol $1f				rol 	zLTemp1+3
.cd9f	90 02		bcc $cda3			bcc 	_FPD_NoCarry
.cda1	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.cda3					_FPD_NoCarry:
.cda3	88		dey				dey 								; do 32 times
.cda4	d0 bd		bne $cd63			bne 	_FPD_Loop
.cda6	4c 01 ce	jmp $ce01			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cda9					_FPD_Overflow:
.cda9	4c ef cf	jmp $cfef			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cdac					FPMultiply:
.cdac	48		pha				pha
.cdad	5a		phy				phy
.cdae	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cdb0	70 07		bvs $cdb9			bvs 	_FPM_Exit
.cdb2	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cdb4	50 06		bvc $cdbc			bvc 	_FPM_CalcExponent
.cdb6	20 23 cf	jsr $cf23			jsr 	FPUCopyX2ToX1
.cdb9					_FPM_Exit:
.cdb9	7a		ply				ply
.cdba	68		pla				pla
.cdbb	60		rts				rts
.cdbc					_FPM_CalcExponent:
.cdbc	18		clc				clc
.cdbd	20 1d ce	jsr $ce1d			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cdc0	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.cdc2	a9 00		lda #$00			lda 	#0
.cdc4	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cdc6	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cdc8	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cdca	85 1f		sta $1f				sta 	zLTemp1+3
.cdcc	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cdce					_FPM_Loop:
.cdce	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.cdd0	29 01		and #$01			and 	#1
.cdd2	18		clc				clc 								; clear carry for the long rotate.
.cdd3	f0 19		beq $cdee			beq 	_FPM_NoAddition
.cdd5	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cdd6	a5 1c		lda $1c				lda 	zLTemp1+0
.cdd8	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.cdda	85 1c		sta $1c				sta 	zLTemp1+0
.cddc	a5 1d		lda $1d				lda 	zLTemp1+1
.cdde	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.cde0	85 1d		sta $1d				sta 	zLTemp1+1
.cde2	a5 1e		lda $1e				lda 	zLTemp1+2
.cde4	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.cde6	85 1e		sta $1e				sta 	zLTemp1+2
.cde8	a5 1f		lda $1f				lda 	zLTemp1+3
.cdea	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.cdec	85 1f		sta $1f				sta 	zLTemp1+3
.cdee					_FPM_NoAddition:
.cdee	66 1f		ror $1f				ror 	3+zLTemp1
.cdf0	66 1e		ror $1e				ror 	2+zLTemp1
.cdf2	66 1d		ror $1d				ror 	1+zLTemp1
.cdf4	66 1c		ror $1c				ror 	0+zLTemp1
.cdf6	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.cdf8	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cdfa	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cdfc	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cdfe	88		dey				dey
.cdff	d0 cd		bne $cdce			bne 	_FPM_Loop 					; do this 32 times.
.ce01					FPM_CopySignNormalize:
.ce01	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.ce03	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.ce05	a5 1d		lda $1d				lda 	zLTemp1+1
.ce07	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ce09	a5 1e		lda $1e				lda 	zLTemp1+2
.ce0b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ce0d	a5 1f		lda $1f				lda 	zLTemp1+3
.ce0f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ce11	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.ce13	55 8b		eor $8b,x			eor 	XS2_Type,x
.ce15	95 85		sta $85,x			sta 	XS_Type,x
.ce17	20 92 cf	jsr $cf92			jsr 	FPUNormalise 				; normalise and exit.
.ce1a	7a		ply				ply
.ce1b	68		pla				pla
.ce1c	60		rts				rts
.ce1d					FPCalculateExponent:
.ce1d	18		clc				clc
.ce1e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.ce20	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.ce22	b0 08		bcs $ce2c			bcs 	_FPCECarry 					; carry out ?
.ce24	10 03		bpl $ce29			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.ce26	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.ce28	60		rts				rts
.ce29					_FPCEExpZero:
.ce29	a9 00		lda #$00			lda 	#0
.ce2b	60		rts				rts
.ce2c					_FPCECarry:
.ce2c	30 03		bmi $ce31			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.ce2e	09 80		ora #$80			ora 	#$80 						; put in right range
.ce30	60		rts				rts
.ce31					_FPCEOverflow:
.ce31	4c ef cf	jmp $cfef			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.ce34					FPFractionalPart:
.ce34	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.ce36	38		sec				sec 								; this flag tells us to keep the fractional part
.ce37	30 0d		bmi $ce46			bmi 	FPGetPart
.ce39	60		rts				rts
.ce3a					FPIntegerPart:
.ce3a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.ce3c	18		clc				clc 								; this flag says keep the integer part.
.ce3d	30 07		bmi $ce46			bmi 	FPGetPart 					; -ve exponents are 0..127
.ce3f	48		pha				pha
.ce40	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.ce42	95 85		sta $85,x			sta 	XS_Type,x
.ce44	68		pla				pla
.ce45	60		rts				rts
.ce46					FPGetPart:
.ce46	48		pha				pha
.ce47	5a		phy				phy 								; save Y
.ce48	08		php				php 								; save action
.ce49	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.ce4b	70 59		bvs $cea6			bvs 	_FPGP_Exit 					; then do nothing.
.ce4d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.ce4f	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.ce51	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.ce53	85 1e		sta $1e				sta 	zLTemp1+2
.ce55	85 1f		sta $1f				sta 	zLTemp1+3
.ce57	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.ce59	38		sec				sec
.ce5a	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.ce5c	f0 12		beq $ce70			beq 	_FPGP_NoShift 				; ... if any
.ce5e	c9 20		cmp #$20			cmp 	#32
.ce60	90 02		bcc $ce64			bcc 	_FPGP_NotMax
.ce62	a9 20		lda #$20			lda 	#32 						; max of 32.
.ce64					_FPGP_NotMax:
.ce64	a8		tay				tay 								; Y is the mask shift count.
.ce65					_FPGP_ShiftMask:
.ce65	46 1f		lsr $1f				lsr 	3+zLTemp1
.ce67	66 1e		ror $1e				ror 	2+zLTemp1
.ce69	66 1d		ror $1d				ror 	1+zLTemp1
.ce6b	66 1c		ror $1c				ror 	0+zLTemp1
.ce6d	88		dey				dey
.ce6e	d0 f5		bne $ce65			bne 	_FPGP_ShiftMask
.ce70					_FPGP_NoShift:
.ce70	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.ce72	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.ce75					_FPGP_MaskLoop:
.ce75	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.ce78	28		plp				plp 								; if CC we keep the top part, so we
.ce79	08		php				php		 							; flip the mask.
.ce7a	b0 02		bcs $ce7e			bcs		_FPGP_NoFlip
.ce7c	49 ff		eor #$ff			eor 	#$FF
.ce7e					_FPGP_NoFlip:
.ce7e	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.ce80	95 80		sta $80,x			sta 	XS_Mantissa,x
.ce82	e8		inx				inx
.ce83	c8		iny				iny
.ce84	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.ce86	d0 ed		bne $ce75			bne 	_FPGP_MaskLoop
.ce88	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.ce8b	28		plp				plp
.ce8c	08		php				php 								; get action flag on the stack
.ce8d	90 04		bcc $ce93			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.ce8f	a9 00		lda #$00			lda 	#0
.ce91	95 85		sta $85,x			sta 	XS_Type,x
.ce93					_FPGP_NotFractional:
.ce93	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.ce95	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.ce97	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ce99	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.ce9b	f0 05		beq $cea2			beq 	_FPGP_Zero 					; if zero, return zero
.ce9d	20 92 cf	jsr $cf92			jsr 	FPUNormalise
.cea0	80 04		bra $cea6			bra 	_FPGP_Exit 					; and exit
.cea2					_FPGP_Zero:
.cea2	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cea4	95 85		sta $85,x			sta 	XS_Type,x
.cea6					_FPGP_Exit:
.cea6	68		pla				pla 								; throw saved action flag.
.cea7	7a		ply				ply
.cea8	68		pla				pla
.cea9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.ceaa					FPCompare:
.ceaa	20 eb ce	jsr $ceeb			jsr 	FPFastCompare 				; fast compare try first
.cead	b0 3b		bcs $ceea			bcs 	_FPCExit 					; that worked.
.ceaf	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.ceb1	48		pha				pha
.ceb2	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.ceb4	48		pha				pha
.ceb5	20 7d cc	jsr $cc7d			jsr 	FPSubtract 					; calculate X1-X2
.ceb8	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.ceba	70 2a		bvs $cee6			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.cebc	68		pla				pla
.cebd	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.cec0	68		pla				pla
.cec1	38		sec				sec
.cec2	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.cec5	70 14		bvs $cedb			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cec7	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cec8	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.ceca	b0 0f		bcs $cedb			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cecc	38		sec				sec
.cecd	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.ced0	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.ced2	b0 02		bcs $ced6			bcs 	_FPCNotRange 				; keep in range.
.ced4	a9 01		lda #$01			lda 	#1
.ced6					_FPCNotRange:
.ced6	38		sec				sec
.ced7	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.ced9	b0 0d		bcs $cee8			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cedb					_FPCNotEqual:
.cedb	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cedd	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cedf	f0 02		beq $cee3			beq 	_FPCNE2
.cee1	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cee3	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cee4	80 04		bra $ceea			bra 	_FPCExit
.cee6					_FPCPullZero:
.cee6	68		pla				pla 								; throw saved exponents
.cee7	68		pla				pla
.cee8					_FPCZero:
.cee8	a9 00		lda #$00			lda 	#0 							; and return zero
.ceea					_FPCExit:
.ceea	60		rts				rts
.ceeb					FPFastCompare:
.ceeb	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.ceed	70 23		bvs $cf12			bvs 	_FPFLeftZero
.ceef	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.cef1	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.cef3	70 25		bvs $cf1a			bvs 	_FPFSignBit
.cef5	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.cef7	0a		asl a				asl 	a 							; put in CS if different.
.cef8	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.cefa	b0 1e		bcs $cf1a			bcs 	_FPFSignBit
.cefc	38		sec				sec 								; same sign and not-zero. compare exponents
.cefd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.ceff	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.cf01	f0 09		beq $cf0c			beq 	_FPNoFastCompare
.cf03	6a		ror a				ror 	a 							; put carry into bit 7.
.cf04	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.cf06	30 02		bmi $cf0a			bmi		_FPFCNotMinus
.cf08	49 80		eor #$80			eor 	#$80
.cf0a					_FPFCNotMinus:
.cf0a	80 0e		bra $cf1a			bra		_FPFSignBit
.cf0c					_FPNoFastCompare:
.cf0c	18		clc				clc
.cf0d	60		rts				rts
.cf0e					_FPFZero:
.cf0e	a9 00		lda #$00			lda 	#0
.cf10					_FPFExitSet:
.cf10	38		sec				sec
.cf11	60		rts				rts
.cf12					_FPFLeftZero:
.cf12	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.cf14	70 f8		bvs $cf0e			bvs 	_FPFZero
.cf16	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.cf18	49 80		eor #$80			eor 	#$80						; return that as a sign.
.cf1a					_FPFSignBit:
.cf1a	0a		asl a				asl 	a
.cf1b	a9 01		lda #$01			lda 	#1
.cf1d	90 f1		bcc $cf10			bcc		_FPFExitSet
.cf1f	a9 ff		lda #$ff			lda 	#$FF
.cf21	38		sec				sec
.cf22	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cf23					FPUCopyX2ToX1:
.cf23	48		pha				pha
.cf24	da		phx				phx
.cf25	5a		phy				phy
.cf26	a0 08		ldy #$08			ldy 	#8
.cf28	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.cf2a	95 80		sta $80,x			sta 	XS_Mantissa,x
.cf2c	e8		inx				inx
.cf2d	88		dey				dey
.cf2e	10 f8		bpl $cf28			bpl 	_FPUC21
.cf30	7a		ply				ply
.cf31	fa		plx				plx
.cf32	68		pla				pla
.cf33	60		rts				rts
.cf34					FPUSetInteger:
.cf34	48		pha				pha
.cf35	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cf37	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cf39	10 02		bpl $cf3d			bpl 	_FPUSIExtend
.cf3b	a9 ff		lda #$ff			lda 	#$FF
.cf3d					_FPUSIExtend:
.cf3d	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cf3f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cf41	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cf43	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cf45	95 85		sta $85,x			sta 	XS_Type,x
.cf47	68		pla				pla
.cf48	60		rts				rts
.cf49					FPUNegateInteger:
.cf49	48		pha				pha
.cf4a	38		sec				sec
.cf4b	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cf4d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.cf4f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cf51	a9 00		lda #$00			lda 	#0
.cf53	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.cf55	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cf57	a9 00		lda #$00			lda 	#0
.cf59	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.cf5b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cf5d	a9 00		lda #$00			lda 	#0
.cf5f	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.cf61	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cf63	68		pla				pla
.cf64	60		rts				rts
.cf65					FPUToFloat:
.cf65	48		pha				pha
.cf66	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.cf68	29 0f		and #$0f			and 	#$0F
.cf6a	f0 24		beq $cf90			beq 	_FPUFExit
.cf6c	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cf6e	95 85		sta $85,x			sta 	XS_Type,x
.cf70	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cf72	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.cf74	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cf76	10 07		bpl $cf7f			bpl		_FPUFPositive
.cf78	20 49 cf	jsr $cf49			jsr 	FPUNegateInteger 			; negate the mantissa
.cf7b	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cf7d	95 85		sta $85,x			sta 	XS_Type,x
.cf7f					_FPUFPositive:
.cf7f	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cf81	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.cf83	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.cf85	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.cf87	d0 04		bne $cf8d			bne 	_FPUFNonZero
.cf89	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cf8b	95 85		sta $85,x			sta 	XS_Type,x
.cf8d					_FPUFNonZero:
.cf8d	20 92 cf	jsr $cf92			jsr 	FPUNormalise 				; normalise the floating point.
.cf90					_FPUFExit:
.cf90	68		pla				pla
.cf91	60		rts				rts
.cf92					FPUNormalise:
.cf92	48		pha				pha
.cf93	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cf95	70 18		bvs $cfaf			bvs 	_FPUNExit
.cf97	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cf99	f0 10		beq $cfab			beq 	_FPUNSetZero
.cf9b					_FPUNLoop:
.cf9b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cf9d	30 10		bmi $cfaf			bmi 	_FPUNExit 					; if so, we are normalised.
.cf9f	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.cfa1	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.cfa3	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.cfa5	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.cfa7	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.cfa9	d0 f0		bne $cf9b			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cfab					_FPUNSetZero:
.cfab	a9 40		lda #$40			lda 	#$40
.cfad	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.cfaf					_FPUNExit:
.cfaf	68		pla				pla
.cfb0	60		rts				rts
.cfb1					FPUToInteger:
.cfb1	48		pha				pha
.cfb2	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.cfb4	29 01		and #$01			and 	#1
.cfb6	d0 31		bne $cfe9			bne 	_FPUTOI_Exit
.cfb8	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.cfba	70 23		bvs $cfdf			bvs 	_FPUTOI_Zero
.cfbc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.cfbe	10 1f		bpl $cfdf			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.cfc0	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.cfc2	b0 2b		bcs $cfef			bcs 	FP_Overflow
.cfc4					_FPUToIToInteger:
.cfc4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.cfc6	c9 a0		cmp #$a0			cmp 	#128+32
.cfc8	f0 0c		beq $cfd6			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.cfca	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.cfcc	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.cfce	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cfd0	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cfd2	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cfd4	80 ee		bra $cfc4			bra 	_FPUToIToInteger 			; keep going.
.cfd6					_FPUToICheckSign:
.cfd6	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.cfd8	10 0f		bpl $cfe9			bpl 	_FPUToI_Exit 				; exit if unsigned.
.cfda	20 49 cf	jsr $cf49			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.cfdd	80 0a		bra $cfe9			bra 	_FPUTOI_Exit
.cfdf					_FPUTOI_Zero:
.cfdf	a9 00		lda #$00			lda 	#0 							; return zero integer.
.cfe1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cfe3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cfe5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cfe7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cfe9					_FPUToI_Exit:
.cfe9	a9 01		lda #$01			lda 	#1 							; set type to integer
.cfeb	95 85		sta $85,x			sta 	XS_Type,x
.cfed	68		pla				pla
.cfee	60		rts				rts
.cfef					FP_Overflow:
.cfef	20 a8 ae	jsr $aea8			jsr ERR_Handler
>cff2	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>cffa	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.d00a					FPUTimes10:
.d00a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.d00c	85 1c		sta $1c				sta 	ZLTemp1+0
.d00e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.d010	85 1d		sta $1d				sta 	ZLTemp1+1
.d012	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.d014	85 1e		sta $1e				sta 	ZLTemp1+2
.d016	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.d018	85 1f		sta $1f				sta 	ZLTemp1+3
.d01a	20 4f d0	jsr $d04f			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.d01d	20 4f d0	jsr $d04f			jsr 	_FPUT_LSR_ZLTemp1
.d020	18		clc				clc
.d021	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.d023	65 1c		adc $1c				adc 	ZLTemp1+0
.d025	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.d027	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.d029	65 1d		adc $1d				adc 	ZLTemp1+1
.d02b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d02d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.d02f	65 1e		adc $1e				adc 	ZLTemp1+2
.d031	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d033	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.d035	65 1f		adc $1f				adc 	ZLTemp1+3
.d037	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d039	90 0a		bcc $d045			bcc 	_FPUTimes10
.d03b	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.d03d	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.d03f	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.d041	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.d043	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.d045					_FPUTimes10:
.d045	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.d047	18		clc				clc
.d048	69 03		adc #$03			adc 	#3
.d04a	95 84		sta $84,x			sta 	XS_Exponent,x
.d04c	b0 a1		bcs $cfef			bcs 	FP_Overflow 				; error
.d04e	60		rts				rts
.d04f					_FPUT_LSR_ZLTemp1:
.d04f	46 1f		lsr $1f				lsr 	ZLTemp1+3
.d051	66 1e		ror $1e				ror 	ZLTemp1+2
.d053	66 1d		ror $1d				ror 	ZLTemp1+1
.d055	66 1c		ror $1c				ror 	ZLTemp1+0
.d057	60		rts				rts
.d058					FPUScale10A:
.d058	5a		phy				phy
.d059	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.d05b	f0 37		beq $d094			beq 	_FPUScaleExit
.d05d	da		phx				phx 								; save X
.d05e	e8		inx				inx
.d05f	e8		inx				inx
.d060	e8		inx				inx
.d061	e8		inx				inx
.d062	e8		inx				inx
.d063	e8		inx				inx
.d064	a8		tay				tay 								; save power scalar in Y.
.d065	a9 00		lda #$00			lda 	#0
.d067	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.d069	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d06b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d06d	95 85		sta $85,x			sta 	XS_Type,x
.d06f	a9 80		lda #$80			lda 	#$80
.d071	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d073	a9 81		lda #$81			lda 	#$81
.d075	95 84		sta $84,x			sta 	XS_Exponent,x
.d077	5a		phy				phy 								; save 10^n on stack.
.d078	c0 00		cpy #$00			cpy 	#0
.d07a	10 05		bpl $d081			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.d07c	98		tya				tya
.d07d	49 ff		eor #$ff			eor 	#$FF
.d07f	1a		inc a				inc 	a
.d080	a8		tay				tay
.d081					_FPUSAbs:
.d081	20 0a d0	jsr $d00a			jsr 	FPUTimes10
.d084	88		dey				dey
.d085	d0 fa		bne $d081			bne 	_FPUSAbs 					; tos is now 10^|AC|
.d087	68		pla				pla 								; restore count in A
.d088	fa		plx				plx 								; restore X pointing to number to scale.
.d089	0a		asl a				asl 	a
.d08a	b0 05		bcs $d091			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.d08c	20 ac cd	jsr $cdac			jsr 	FPMultiply 					; if clear multiply.
.d08f	80 03		bra $d094			bra		_FPUScaleExit
.d091					_FPUSDivide:
.d091	20 39 cd	jsr $cd39			jsr 	FPDivide
.d094					_FPUScaleExit:
.d094	7a		ply				ply
.d095	60		rts				rts
.d096					FPUCopyToNext:
.d096	a0 06		ldy #$06			ldy 		#6
.d098	da		phx				phx
.d099					_FPUCopy1:
.d099	b5 80		lda $80,x			lda 	XS_Mantissa,x
.d09b	95 86		sta $86,x			sta 	XS2_Mantissa,x
.d09d	e8		inx				inx
.d09e	88		dey				dey
.d09f	d0 f8		bne $d099			bne 	_FPUCopy1
.d0a1	fa		plx				plx
.d0a2	60		rts				rts
.d0a3					FPUCopyFromNext:
.d0a3	a0 06		ldy #$06			ldy 		#6
.d0a5	da		phx				phx
.d0a6					_FPUCopy1:
.d0a6	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.d0a8	95 80		sta $80,x			sta 	XS_Mantissa,x
.d0aa	e8		inx				inx
.d0ab	88		dey				dey
.d0ac	d0 f8		bne $d0a6			bne 	_FPUCopy1
.d0ae	fa		plx				plx
.d0af	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.d0b0					FPToString:
.d0b0	48		pha				pha
.d0b1	5a		phy				phy
.d0b2	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.d0b4	50 0a		bvc $d0c0			bvc 		_FPTSIsFloat 			; if zero,
.d0b6					_FPTSZero:
.d0b6	a9 30		lda #$30			lda 		#"0"
.d0b8	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d0bb					_FPTSExit:
.d0bb	7a		ply				ply
.d0bc	68		pla				pla
.d0bd	60		rts				rts
.d0be	80 fb		bra $d0bb			bra 		_FPTSExit
.d0c0					_FPTSIsFloat:
.d0c0	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.d0c2	10 09		bpl $d0cd			bpl 		_FPTSNotSigned
.d0c4	a9 00		lda #$00			lda 		#0 						; clear sign flag
.d0c6	95 85		sta $85,x			sta 		XS_Type,x
.d0c8	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d0ca	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d0cd					_FPTSNotSigned:
.d0cd	b5 84		lda $84,x			lda 		XS_Exponent,x
.d0cf	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.d0d1	b0 09		bcs $d0dc			bcs 		_FPTSExponent
.d0d3	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.d0d5	90 05		bcc $d0dc			bcc 		_FPTSExponent 			;
.d0d7					_FPTSStandard:
.d0d7	20 1b d1	jsr $d11b			jsr 		FPTOutputBody 			; output the body.
.d0da	80 df		bra $d0bb			bra 		_FPTSExit
.d0dc					_FPTSExponent:
.d0dc	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.d0de	8d 9d 03	sta $039d			sta 		ExpCount
.d0e1					_FPTSExponentLoop:
.d0e1	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.d0e3	10 0e		bpl $d0f3			bpl 		_FPTSTimes
.d0e5	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.d0e7	90 14		bcc $d0fd			bcc 		_FPTSScaledToExp
.d0e9	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.d0eb	20 58 d0	jsr $d058			jsr 		FPUScale10A
.d0ee	ee 9d 03	inc $039d			inc 		ExpCount
.d0f1	80 ee		bra $d0e1			bra 		_FPTSExponentLoop
.d0f3					_FPTSTimes:
.d0f3	a9 01		lda #$01			lda 		#1
.d0f5	20 58 d0	jsr $d058			jsr 		FPUScale10A
.d0f8	ce 9d 03	dec $039d			dec 		ExpCount
.d0fb	80 e4		bra $d0e1			bra 		_FPTSExponentLoop
.d0fd					_FPTSScaledToExp:
.d0fd	20 1b d1	jsr $d11b			jsr 		FPTOutputBody 			; output the body.
.d100	a9 65		lda #$65			lda 		#"e"					; output E
.d102	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d105	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.d108	95 80		sta $80,x			sta 		XS_Mantissa,x
.d10a	29 80		and #$80			and 		#$80 					; sign extend it
.d10c	f0 02		beq $d110			beq 		_FPTSSExt
.d10e	a9 ff		lda #$ff			lda 		#$FF
.d110					_FPTSSExt:
.d110	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.d112	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.d114	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.d116	20 3a cb	jsr $cb3a			jsr 		INTToString 			; output the exponent.
.d119	80 a0		bra $d0bb			bra			_FPTSExit 				; and exit.
.d11b					FPTOutputBody:
.d11b	20 96 d0	jsr $d096			jsr 		FPUCopyToNext 			; copy to next slot.
.d11e	20 b1 cf	jsr $cfb1			jsr 		FPUToInteger 			; convert to an integer
.d121	20 3a cb	jsr $cb3a			jsr 		INTToString 			; output the main integer part.
.d124	20 a3 d0	jsr $d0a3			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d127	20 34 ce	jsr $ce34			jsr 		FPFractionalPart 		; get the decimal part.
.d12a	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.d12c	70 3c		bvs $d16a			bvs 		_FPTOExit 				; if not, exit now.
.d12e	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d130	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d133					_FPOutLoop:
.d133	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.d135	70 1d		bvs $d154			bvs 		_FPStripZeros 			; strip trailing zeros
.d137	20 0a d0	jsr $d00a			jsr 		FPUTimes10 				; multiply by 10
.d13a	20 96 d0	jsr $d096			jsr 		FPUCopyToNext			; copy to next slot.
.d13d	20 b1 cf	jsr $cfb1			jsr 		FPUToInteger 			; convert to integer
.d140	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.d142	09 30		ora #$30			ora 		#"0"
.d144	20 d8 cb	jsr $cbd8			jsr 		ITSOutputCharacter
.d147	20 a3 d0	jsr $d0a3			jsr 		FPUCopyFromNext 		; get it back
.d14a	20 34 ce	jsr $ce34			jsr 		FPFractionalPart 		; get fractional part
.d14d	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.d150	c9 0b		cmp #$0b			cmp 	 	#11
.d152	90 df		bcc $d133			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d154					_FPStripZeros:
.d154	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.d157					_FPStripLoop:
.d157	88		dey				dey 								; back one, if at start then no strip
.d158	f0 10		beq $d16a			beq 		_FPToExit
.d15a	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.d15d	c9 30		cmp #$30			cmp 		#"0"
.d15f	f0 f6		beq $d157			beq 		_FPStripLoop
.d161	c8		iny				iny
.d162	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d164	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.d167	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.d16a					_FPTOExit:
.d16a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d16b					FPFromString:
.d16b	48		pha				pha 								; push A
.d16c	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d16e	c9 2e		cmp #$2e			cmp 	#"."
.d170	f0 03		beq $d175			beq	 	_FPFIsDecimal
.d172	4c d1 d1	jmp $d1d1			jmp 	_FPFNotDecimal
.d175					_FPFIsDecimal:
.d175	c8		iny				iny 								; consume the decimal.
.d176	20 65 cf	jsr $cf65			jsr 	FPUToFloat 					; convert the integer to float.
.d179	da		phx				phx 								; save X.
.d17a	5a		phy				phy 								; save decimal start position
.d17b	e8		inx				inx
.d17c	e8		inx				inx
.d17d	e8		inx				inx
.d17e	e8		inx				inx
.d17f	e8		inx				inx
.d180	e8		inx				inx
.d181	20 ed cb	jsr $cbed			jsr 	INTFromStringY 				; get the part after the DP.
.d184	20 65 cf	jsr $cf65			jsr 	FPUToFloat 					; convert that to a float.
.d187	68		pla				pla 								; calculate - chars consumed.
.d188	8c 9c 03	sty $039c			sty 	ExpTemp
.d18b	38		sec				sec
.d18c	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.d18f	20 58 d0	jsr $d058			jsr 	FPUScale10A 				; scale it by 10^AC
.d192	fa		plx				plx 								; restore original X
.d193	20 85 cc	jsr $cc85			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d196	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.d198	c9 45		cmp #$45			cmp 	#"E"
.d19a	f0 04		beq $d1a0			beq 	_FPFExponent
.d19c	c9 65		cmp #$65			cmp 	#"e"
.d19e	d0 31		bne $d1d1			bne 	_FPFNotDecimal 				; no, then exit normally.
.d1a0					_FPFExponent:
.d1a0	c8		iny				iny 								; skip over E symbol.
.d1a1	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.d1a3	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d1a5	d0 01		bne $d1a8			bne 	_FPFGotSign
.d1a7	c8		iny				iny 								; if it was - skip over it.
.d1a8					_FPFGotSign:
.d1a8	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d1a9	da		phx				phx
.d1aa	e8		inx				inx
.d1ab	e8		inx				inx
.d1ac	e8		inx				inx
.d1ad	e8		inx				inx
.d1ae	e8		inx				inx
.d1af	e8		inx				inx
.d1b0	20 ed cb	jsr $cbed			jsr 	INTFromStringY 				; get the exponent
.d1b3	fa		plx				plx 								; restore X.
.d1b4	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d1b6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.d1b8	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.d1ba	d0 17		bne $d1d3			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d1bc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d1be	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d1c0	b0 11		bcs $d1d3			bcs 	_FPFXOverflow
.d1c2	68		pla				pla 								; get direction
.d1c3	d0 07		bne $d1cc			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d1c5	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d1c7	49 ff		eor #$ff			eor 	#$FF
.d1c9	1a		inc a				inc 	a
.d1ca	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.d1cc					_FPFXScale:
.d1cc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d1ce	20 58 d0	jsr $d058			jsr 	FPUScale10A 				; scale by the exponent.
.d1d1					_FPFNotDecimal:
.d1d1	68		pla				pla
.d1d2	60		rts				rts
.d1d3					_FPFXOverflow:
.d1d3	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>d1d6	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d1de	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.d1e5					Unary_Rnd:
.d1e5	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX 			; get value
.d1e8	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; check right bracket.
.d1eb	20 ad bf	jsr $bfad			jsr 	GetSignCurrent 				; get sign -1,0,1.
.d1ee	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.d1f0	30 10		bmi $d202			bmi 	_URSetSeed
.d1f2	f0 28		beq $d21c			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.d1f4	da		phx				phx
.d1f5	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.d1f7	20 53 d2	jsr $d253			jsr 	Random16
.d1fa	a2 02		ldx #$02			ldx 	#2
.d1fc	20 53 d2	jsr $d253			jsr 	Random16
.d1ff	fa		plx				plx
.d200	80 1a		bra $d21c			bra 	_URMakeRandom
.d202					_URSetSeed:
.d202	20 65 cf	jsr $cf65			jsr 	FPUToFloat 					; make it a float to twiddle it.
.d205	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.d207	8d a3 03	sta $03a3			sta 	RandomSeed+0
.d20a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.d20c	8d a4 03	sta $03a4			sta 	RandomSeed+1
.d20f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.d211	8d a5 03	sta $03a5			sta 	RandomSeed+2
.d214	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.d216	0a		asl a				asl 	a 							; resemblance to the seed value.
.d217	49 db		eor #$db			eor 	#$DB
.d219	8d a6 03	sta $03a6			sta 	RandomSeed+3
.d21c					_URMakeRandom:
.d21c	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.d21f	0d a4 03	ora $03a4			ora 	RandomSeed+1
.d222	0d a5 03	ora $03a5			ora 	RandomSeed+2
.d225	0d a6 03	ora $03a6			ora 	RandomSeed+3
.d228	d0 0a		bne $d234			bne 	_URNotZero
.d22a	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.d22c	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.d22f	a9 3d		lda #$3d			lda 	#$3D
.d231	8d a6 03	sta $03a6			sta 	RandomSeed+3
.d234					_URNotZero:
.d234	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.d237	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.d239	ad a4 03	lda $03a4			lda 	RandomSeed+1
.d23c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d23e	ad a5 03	lda $03a5			lda 	RandomSeed+2
.d241	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d243	ad a6 03	lda $03a6			lda 	RandomSeed+3
.d246	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d248	a9 00		lda #$00			lda 	#$00 						; set type to float.
.d24a	95 85		sta $85,x			sta 	XS_Type,x
.d24c	a9 80		lda #$80			lda 	#$80
.d24e	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.d250	4c 92 cf	jmp $cf92			jmp 	FPUNormalise 				; and normalise.
.d253					Random16:
.d253	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.d256	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.d259	90 08		bcc $d263			bcc 	_R16_NoXor
.d25b	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.d25e	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.d260	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.d263					_R16_NoXor:
.d263	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.d264					Unary_Int:
.d264	20 2d bd	jsr $bd2d			jsr 	EvaluateNumberX 			; get value
.d267	20 99 c3	jsr $c399			jsr 	CheckNextRParen 			; check right bracket.
.d26a	4c b1 cf	jmp $cfb1			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.d26d	80 fe		bra $d26d	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM 					; Reset vector
>fffe	92 ac					.word TIM_BreakVector

;******  End of listing
