
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 21 20:35:33 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0428					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>042a					Tim_SR:		.byte ? 						; Processor Status
>042b					Tim_A:		.byte ? 						; Processor Registers
>042c					Tim_X:		.byte ?
>042d					Tim_Y:		.byte ?
>042e					Tim_Z:		.byte ?
>042f					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0f 0a 00 d7 98 8b 43 bc			.byte	$0f,$0a,$00,$d7,$98,$8b,$43,$bc
>1008	ff 06 68 69 20 21 00 00			.byte	$ff,$06,$68,$69,$20,$21,$00,$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../common/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b2					lastUnaryFunction = $b2
.c000					VectorTable:
>c000	ae c0					.word NotImplemented       ; $80 and
>c002	ae c0					.word NotImplemented       ; $81 or
>c004	ae c0					.word NotImplemented       ; $82 xor
>c006	ae c0					.word NotImplemented       ; $83 eor
>c008	ae c0					.word NotImplemented       ; $84 =
>c00a	ae c0					.word NotImplemented       ; $85 <>
>c00c	ae c0					.word NotImplemented       ; $86 <
>c00e	ae c0					.word NotImplemented       ; $87 <=
>c010	ae c0					.word NotImplemented       ; $88 >
>c012	ae c0					.word NotImplemented       ; $89 >=
>c014	8f c6					.word BinaryOp_Add         ; $8a +
>c016	a2 c6					.word BinaryOp_Subtract    ; $8b -
>c018	b5 c6					.word BinaryOp_Multiply    ; $8c *
>c01a	c8 c6					.word BinaryOp_Divide      ; $8d /
>c01c	ae c0					.word NotImplemented       ; $8e ^
>c01e	ae c0					.word NotImplemented       ; $8f if
>c020	ae c0					.word NotImplemented       ; $90 while
>c022	ae c0					.word NotImplemented       ; $91 repeat
>c024	ae c0					.word NotImplemented       ; $92 for
>c026	ae c0					.word NotImplemented       ; $93 then
>c028	ae c0					.word NotImplemented       ; $94 endif
>c02a	ae c0					.word NotImplemented       ; $95 wend
>c02c	ae c0					.word NotImplemented       ; $96 until
>c02e	ae c0					.word NotImplemented       ; $97 next
>c030	ae c0					.word NotImplemented       ; $98 not
>c032	ae c0					.word NotImplemented       ; $99 fn(
>c034	ae c0					.word NotImplemented       ; $9a abs(
>c036	ae c0					.word NotImplemented       ; $9b asc(
>c038	ae c0					.word NotImplemented       ; $9c int(
>c03a	ae c0					.word NotImplemented       ; $9d peek(
>c03c	ae c0					.word NotImplemented       ; $9e rnd(
>c03e	ae c0					.word NotImplemented       ; $9f usr(
>c040	ae c0					.word NotImplemented       ; $a0 left$(
>c042	ae c0					.word NotImplemented       ; $a1 right$(
>c044	ae c0					.word NotImplemented       ; $a2 mid$(
>c046	ae c0					.word NotImplemented       ; $a3 spc(
>c048	ae c0					.word NotImplemented       ; $a4 str$(
>c04a	ae c0					.word NotImplemented       ; $a5 val(
>c04c	ae c0					.word NotImplemented       ; $a6 len(
>c04e	ae c0					.word NotImplemented       ; $a7 hex$(
>c050	ae c0					.word NotImplemented       ; $a8 sin(
>c052	ae c0					.word NotImplemented       ; $a9 cos(
>c054	ae c0					.word NotImplemented       ; $aa tan(
>c056	ae c0					.word NotImplemented       ; $ab atn(
>c058	ae c0					.word NotImplemented       ; $ac exp(
>c05a	ae c0					.word NotImplemented       ; $ad log(
>c05c	ae c0					.word NotImplemented       ; $ae sqr(
>c05e	ae c0					.word NotImplemented       ; $af dec(
>c060	ae c0					.word NotImplemented       ; $b0 deek(
>c062	ae c0					.word NotImplemented       ; $b1 leek(
>c064	ae c0					.word NotImplemented       ; $b2 mod(
>c066	ae c0					.word NotImplemented       ; $b3 $(
>c068	ae c0					.word NotImplemented       ; $b4 $
>c06a	ae c0					.word NotImplemented       ; $b5 #(
>c06c	ae c0					.word NotImplemented       ; $b6 #
>c06e	ae c0					.word NotImplemented       ; $b7 %(
>c070	ae c0					.word NotImplemented       ; $b8 %
>c072	ae c0					.word NotImplemented       ; $b9 (
>c074	ae c0					.word NotImplemented       ; $ba )
>c076	ae c0					.word NotImplemented       ; $bb ,
>c078	ae c0					.word NotImplemented       ; $bc :
>c07a	ae c0					.word NotImplemented       ; $bd ;
>c07c	ae c0					.word NotImplemented       ; $be def
>c07e	ae c0					.word NotImplemented       ; $bf clr
>c080	ae c0					.word NotImplemented       ; $c1 data
>c082	ae c0					.word NotImplemented       ; $c2 read
>c084	ae c0					.word NotImplemented       ; $c3 dim
>c086	ae c0					.word NotImplemented       ; $c4 to
>c088	ae c0					.word NotImplemented       ; $c5 step
>c08a	ae c0					.word NotImplemented       ; $c6 gosub
>c08c	ae c0					.word NotImplemented       ; $c7 return
>c08e	ae c0					.word NotImplemented       ; $c8 goto
>c090	ae c0					.word NotImplemented       ; $c9 input
>c092	ae c0					.word NotImplemented       ; $ca let
>c094	ae c0					.word NotImplemented       ; $cb list
>c096	ae c0					.word NotImplemented       ; $cc new
>c098	ae c0					.word NotImplemented       ; $cd old
>c09a	ae c0					.word NotImplemented       ; $ce on
>c09c	ae c0					.word NotImplemented       ; $cf restore
>c09e	ae c0					.word NotImplemented       ; $d0 poke
>c0a0	ae c0					.word NotImplemented       ; $d1 print
>c0a2	ae c0					.word NotImplemented       ; $d2 run
>c0a4	ae c0					.word NotImplemented       ; $d3 stop
>c0a6	ae c0					.word NotImplemented       ; $d4 wait
>c0a8	ae c0					.word NotImplemented       ; $d5 doke
>c0aa	ae c0					.word NotImplemented       ; $d6 loke
>c0ac	ae c0					.word NotImplemented       ; $d7 assert
.c0ae					NotImplemented:
.c0ae	80 fe		bra $c0ae		_error: bra _error
>c0b0	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>c0b8	72 72 6f 72 00
.c0bd					BinaryPrecedence:
>c0bd	01					.byte 1    ; $80 and
>c0be	01					.byte 1    ; $81 or
>c0bf	01					.byte 1    ; $82 xor
>c0c0	01					.byte 1    ; $83 eor
>c0c1	02					.byte 2    ; $84 =
>c0c2	02					.byte 2    ; $85 <>
>c0c3	02					.byte 2    ; $86 <
>c0c4	02					.byte 2    ; $87 <=
>c0c5	02					.byte 2    ; $88 >
>c0c6	02					.byte 2    ; $89 >=
>c0c7	03					.byte 3    ; $8a +
>c0c8	03					.byte 3    ; $8b -
>c0c9	04					.byte 4    ; $8c *
>c0ca	04					.byte 4    ; $8d /
>c0cb	05					.byte 5    ; $8e ^
.c0cc					KeywordText:
>c0cc	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0cf	4f d2					.byte $4f,$d2                          ; $81 or
>c0d1	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0d4	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0d7	bd					.byte $bd                              ; $84 =
>c0d8	3c be					.byte $3c,$be                          ; $85 <>
>c0da	bc					.byte $bc                              ; $86 <
>c0db	3c bd					.byte $3c,$bd                          ; $87 <=
>c0dd	be					.byte $be                              ; $88 >
>c0de	3e bd					.byte $3e,$bd                          ; $89 >=
>c0e0	ab					.byte $ab                              ; $8a +
>c0e1	ad					.byte $ad                              ; $8b -
>c0e2	aa					.byte $aa                              ; $8c *
>c0e3	af					.byte $af                              ; $8d /
>c0e4	de					.byte $de                              ; $8e ^
>c0e5	49 c6					.byte $49,$c6                          ; $8f if
>c0e7	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0ec	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0f2	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0f5	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0f9	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0fe	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c102	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c107	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c10b	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c10e	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c111	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c115	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c119	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c11d	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c122	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c126	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c12a	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c130	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c137	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c13c	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c140	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c145	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c149	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c14d	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c152	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c156	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c15a	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c15e	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c162	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c166	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c16a	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c16e	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c172	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c177	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c17c	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c180	24 a8					.byte $24,$a8                          ; $b3 $(
>c182	a4					.byte $a4                              ; $b4 $
>c183	23 a8					.byte $23,$a8                          ; $b5 #(
>c185	a3					.byte $a3                              ; $b6 #
>c186	25 a8					.byte $25,$a8                          ; $b7 %(
>c188	a5					.byte $a5                              ; $b8 %
>c189	a8					.byte $a8                              ; $b9 (
>c18a	a9					.byte $a9                              ; $ba )
>c18b	ac					.byte $ac                              ; $bb ,
>c18c	ba					.byte $ba                              ; $bc :
>c18d	bb					.byte $bb                              ; $bd ;
>c18e	44 45 c6				.byte $44,$45,$c6                      ; $be def
>c191	43 4c d2				.byte $43,$4c,$d2                      ; $bf clr
>c194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c1 data
>c198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c2 read
>c19c	44 49 cd				.byte $44,$49,$cd                      ; $c3 dim
>c19f	54 cf					.byte $54,$cf                          ; $c4 to
>c1a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c5 step
>c1a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c6 gosub
>c1aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c7 return
>c1b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c8 goto
>c1b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c9 input
>c1b9	4c 45 d4				.byte $4c,$45,$d4                      ; $ca let
>c1bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cb list
>c1c0	4e 45 d7				.byte $4e,$45,$d7                      ; $cc new
>c1c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cd old
>c1c6	4f ce					.byte $4f,$ce                          ; $ce on
>c1c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $cf restore
>c1cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d0 poke
>c1d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d1 print
>c1d8	52 55 ce				.byte $52,$55,$ce                      ; $d2 run
>c1db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d3 stop
>c1df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d4 wait
>c1e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d5 doke
>c1e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d6 loke
>c1eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d7 assert
>c1f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_dollarlparen = $b3
=$b4					token_dollar = $b4
=$b5					token_hashlparen = $b5
=$b6					token_hash = $b6
=$b7					token_percentlparen = $b7
=$b8					token_percent = $b8
=$b9					token_lparen = $b9
=$ba					token_rparen = $ba
=$bb					token_comma = $bb
=$bc					token_colon = $bc
=$bd					token_semicolon = $bd
=$be					token_def = $be
=$bf					token_clr = $bf
=$c1					token_data = $c1
=$c2					token_read = $c2
=$c3					token_dim = $c3
=$c4					token_to = $c4
=$c5					token_step = $c5
=$c6					token_gosub = $c6
=$c7					token_return = $c7
=$c8					token_goto = $c8
=$c9					token_input = $c9
=$ca					token_let = $ca
=$cb					token_list = $cb
=$cc					token_new = $cc
=$cd					token_old = $cd
=$ce					token_on = $ce
=$cf					token_restore = $cf
=$d0					token_poke = $d0
=$d1					token_print = $d1
=$d2					token_run = $d2
=$d3					token_stop = $d3
=$d4					token_wait = $d4
=$d5					token_doke = $d5
=$d6					token_loke = $d6
=$d7					token_assert = $d7

;******  Return to file: modules/hardware/em65816.asm

.c1f2					StartROM:
.c1f2	18		clc				clc
.c1f3	fb		xce				xce
.c1f4	c2 30		rep #$30			rep 	#$30
.c1f6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f9	1b		tcs				tcs
.c1fa	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1fc	c2 30		rep #$30			rep 	#$30
.c1fe	a9 00 00	lda #$0000			lda 	#$0000
.c201	aa		tax				tax
.c202	a8		tay				tay
.c203	e2 30		sep #$30			sep 	#$30
.c205	20 a9 c3	jsr $c3a9			jsr 	IF_Reset 					; reset external interface
.c208	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen
.c20b	4c f8 c3	jmp $c3f8		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c20e					IFT_ClearScreen:
.c20e	48		pha				pha
.c20f	da		phx				phx
.c210	5a		phy				phy
.c211	20 aa c3	jsr $c3aa			jsr 	IF_Home 					; home cursor
.c214	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c216					_IFT_CS0:
.c216	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c218					_IFT_CS1:
.c218	a9 20		lda #$20			lda 	#' '						; clear line.
.c21a	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c21d	88		dey				dey
.c21e	d0 f8		bne $c218			bne 	_IFT_CS1
.c220	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; next line down
.c223	ca		dex				dex
.c224	d0 f0		bne $c216			bne 	_IFT_CS0
.c226	7a		ply				ply
.c227	fa		plx				plx
.c228	68		pla				pla
.c229					IFT_HomeCursor:
.c229	48		pha				pha
.c22a	20 aa c3	jsr $c3aa			jsr 	IF_Home
.c22d	a9 00		lda #$00			lda 	#0
.c22f	8d 00 02	sta $0200			sta 	IFT_XCursor
.c232	8d 01 02	sta $0201			sta 	IFT_YCursor
.c235	68		pla				pla
.c236	60		rts				rts
.c237					IFT_UpLine:
.c237	48		pha				pha
.c238	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c23b	3a		dec a				dec 	a 							; line above
.c23c	30 03		bmi $c241			bmi 	_IFTULExit 					; too far, abort
.c23e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos					; set to that line.
.c241					_IFTULExit:
.c241	68		pla				pla
.c242	60		rts				rts
.c243					IFT_PrintCharacter:
.c243	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c245	f0 16		beq $c25d			beq 	IFT_NewLine
.c247	48		pha				pha
.c248	20 75 c2	jsr $c275			jsr 	IFT_UpperCase 				; make upper case
.c24b	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write out.
.c24e	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c251	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c254	c9 40		cmp #$40			cmp 	#IF_Width
.c256	d0 03		bne $c25b			bne 	_IFT_PCNotEOL
.c258	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; if so do new line.
.c25b					_IFT_PCNotEOL:
.c25b	68		pla				pla
.c25c	60		rts				rts
.c25d					IFT_NewLine:
.c25d	48		pha				pha
.c25e	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; new line on actual screen.
.c261	a9 00		lda #$00			lda 	#0 							; reset x position
.c263	8d 00 02	sta $0200			sta 	IFT_XCursor
.c266	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c269	ad 01 02	lda $0201			lda 	IFT_YCursor
.c26c	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c26e	d0 03		bne $c273			bne 	_IFT_NL_NotEOS
.c270	20 80 c2	jsr $c280			jsr 	IFT_Scroll 					; scroll screen up.
.c273					_IFT_NL_NotEOS:
.c273	68		pla				pla
.c274	60		rts				rts
.c275					IFT_UpperCase:
.c275	c9 61		cmp #$61			cmp 	#"a"
.c277	90 06		bcc $c27f			bcc 	_IFT_UCExit
.c279	c9 7b		cmp #$7b			cmp 	#"z"+1
.c27b	b0 02		bcs $c27f			bcs 	_IFT_UCExit
.c27d	49 20		eor #$20			eor 	#$20
.c27f					_IFT_UCExit:
.c27f	60		rts				rts
.c280					IFT_Scroll:
.c280	48		pha				pha 								; save AXY
.c281	da		phx				phx
.c282	5a		phy				phy
.c283	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c285					_IFT_SLoop:
.c285	20 a5 c2	jsr $c2a5			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c288	e8		inx				inx
.c289	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c28b	d0 f8		bne $c285			bne 	_IFT_SLoop
.c28d	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c28f	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c292	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c294					_IFT_SBlank:
.c294	a9 20		lda #$20			lda 	#32
.c296	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c299	ca		dex				dex
.c29a	d0 f8		bne $c294			bne 	_IFT_SBlank
.c29c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c29e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2a1	7a		ply				ply
.c2a2	fa		plx				plx
.c2a3	68		pla				pla
.c2a4	60		rts				rts
.c2a5					_IFT_ScrollLine:
.c2a5	da		phx				phx
.c2a6	da		phx				phx
.c2a7	8a		txa				txa 								; copy line into buffer.
.c2a8	1a		inc a				inc 	a 							; next line down.
.c2a9	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2ac	a2 00		ldx #$00			ldx 	#0
.c2ae					_IFTScrollCopy1:
.c2ae	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c2b1	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2b4	e8		inx				inx
.c2b5	e0 40		cpx #$40			cpx 	#IF_Width
.c2b7	d0 f5		bne $c2ae			bne 	_IFTScrollCopy1
.c2b9	68		pla				pla
.c2ba	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2bd	a2 00		ldx #$00			ldx 	#0
.c2bf					_IFTScrollCopy2:
.c2bf	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2c2	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c2c5	e8		inx				inx
.c2c6	e0 40		cpx #$40			cpx 	#IF_Width
.c2c8	d0 f5		bne $c2bf			bne 	_IFTScrollCopy2
.c2ca	fa		plx				plx
.c2cb	60		rts				rts
.c2cc					IFT_SetYPos:
.c2cc	48		pha				pha
.c2cd	da		phx				phx
.c2ce	aa		tax				tax
.c2cf	20 29 c2	jsr $c229			jsr 	IFT_HomeCursor
.c2d2	e0 00		cpx #$00			cpx 	#0
.c2d4	f0 09		beq $c2df			beq 	_IFT_MOAExit
.c2d6					_IFT_MOALoop:
.c2d6	20 bd c3	jsr $c3bd			jsr 	IF_NewLine
.c2d9	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2dc	ca		dex				dex
.c2dd	d0 f7		bne $c2d6			bne		_IFT_MOALoop
.c2df					_IFT_MOAExit:
.c2df	fa		plx				plx
.c2e0	68		pla				pla
.c2e1	60		rts				rts
.c2e2					IFT_GetKeyCursor:
.c2e2	20 ea c2	jsr $c2ea			jsr 	_IFT_FlipCursor 			; reverse current
.c2e5					_IFT_GKCWait:
.c2e5	20 e7 c3	jsr $c3e7			jsr 	IF_GetKey 					; get key
.c2e8	f0 fb		beq $c2e5			beq 	_IFT_GKCWait
.c2ea					_IFT_FlipCursor:
.c2ea	48		pha				pha 								; save
.c2eb	20 cd c3	jsr $c3cd			jsr 	IF_Read 					; read
.c2ee	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f1	49 80		eor #$80			eor 	#$80 						; reverse
.c2f3	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write
.c2f6	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f9	68		pla				pla
.c2fa	60		rts				rts
.c2fb					IFT_ReadLine:
.c2fb	48		pha				pha
.c2fc					_IFT_RLLoop:
.c2fc	20 e2 c2	jsr $c2e2			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2ff	c9 0d		cmp #$0d			cmp 	#13							; return
.c301	f0 7d		beq $c380			beq 	_IFT_RLExit
.c303	c9 20		cmp #$20			cmp 	#32 						; control character
.c305	90 05		bcc $c30c			bcc 	_IFT_Control
.c307	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.c30a	80 f0		bra $c2fc			bra 	_IFT_RLLoop
.c30c					_IFT_Control:
.c30c	c9 01		cmp #$01			cmp 	#"A"-64
.c30e	f0 26		beq $c336			beq 	_IFT_Left
.c310	c9 04		cmp #$04			cmp 	#"D"-64
.c312	f0 2e		beq $c342			beq 	_IFT_Right
.c314	c9 17		cmp #$17			cmp 	#"W"-64
.c316	f0 36		beq $c34e			beq 	_IFT_Up
.c318	c9 13		cmp #$13			cmp 	#"S"-64
.c31a	f0 3e		beq $c35a			beq 	_IFT_Down
.c31c	c9 08		cmp #$08			cmp 	#"H"-64
.c31e	f0 09		beq $c329			beq 	_IFT_Backspace
.c320	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c322	d0 d8		bne $c2fc			bne 	_IFT_RLLoop
.c324	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen				; clear CTL-Z
.c327	80 d3		bra $c2fc			bra 	_IFT_RLLoop
.c329					_IFT_Backspace:
.c329	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c32c	f0 ce		beq $c2fc			beq 	_IFT_RLLoop
.c32e	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c331	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c333	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c336					_IFT_Left:
.c336	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c339	10 29		bpl $c364			bpl 	_IFT_Reposition
.c33b	a9 3f		lda #$3f			lda 	#IF_Width-1
.c33d					_IFT_SetX:
.c33d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c340	80 22		bra $c364			bra 	_IFT_Reposition
.c342					_IFT_Right:
.c342	ee 00 02	inc $0200			inc 	IFT_XCursor
.c345	ad 00 02	lda $0200			lda 	IFT_XCursor
.c348	49 40		eor #$40			eor 	#IF_Width
.c34a	f0 f1		beq $c33d			beq 	_IFT_SetX
.c34c	80 16		bra $c364			bra 	_IFT_Reposition
.c34e					_IFT_Up:
.c34e	ce 01 02	dec $0201			dec 	IFT_YCursor
.c351	10 11		bpl $c364			bpl 	_IFT_Reposition
.c353	a9 1f		lda #$1f			lda 	#IF_Height-1
.c355					_IFT_SetY:
.c355	8d 01 02	sta $0201			sta 	IFT_YCursor
.c358	80 0a		bra $c364			bra 	_IFT_Reposition
.c35a					_IFT_Down:
.c35a	ee 01 02	inc $0201			inc 	IFT_YCursor
.c35d	ad 01 02	lda $0201			lda 	IFT_YCursor
.c360	49 20		eor #$20			eor 	#IF_Height
.c362	f0 f1		beq $c355			beq 	_IFT_SetY
.c364					_IFT_Reposition:
.c364	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c367	48		pha				pha
.c368	ad 01 02	lda $0201			lda 	IFT_YCursor
.c36b	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c36e	68		pla				pla
.c36f	aa		tax				tax
.c370	e0 00		cpx #$00			cpx 	#0
.c372	f0 88		beq $c2fc			beq 	_IFT_RLLoop
.c374					_IFT_MoveRight:
.c374	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c377	ee 00 02	inc $0200			inc 	IFT_XCursor
.c37a	ca		dex				dex
.c37b	d0 f7		bne $c374			bne 	_IFT_MoveRight
.c37d	4c fc c2	jmp $c2fc			jmp 	_IFT_RLLoop
.c380					_IFT_RLExit:
.c380	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c383	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c386	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c388					_IFT_RLRead:
.c388	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c38b	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c38e	e8		inx				inx
.c38f	e0 40		cpx #$40			cpx 	#IF_Width
.c391	d0 f5		bne $c388			bne 	_IFT_RLRead
.c393					_IFT_RL_Trim:
.c393	ca		dex				dex 	 							; previous char
.c394	30 07		bmi $c39d			bmi 	_IFT_Found 					; gone too far
.c396	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c399	c9 20		cmp #$20			cmp 	#" "
.c39b	f0 f6		beq $c393			beq 	_IFT_RL_Trim
.c39d					_IFT_Found:
.c39d	e8		inx				inx 								; forward to non-space
.c39e	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c3a0	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c3a3	68		pla				pla
.c3a4	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a6	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a9					IF_Reset:
.c3a9	60		rts				rts
.c3aa					IF_Home:
.c3aa	48		pha				pha
.c3ab	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3ad	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3af	85 04		sta $04				sta 	IF_Pos
.c3b1	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3b3	85 05		sta $05				sta 	IF_Pos+1
.c3b5	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b7	85 06		sta $06				sta 	IF_Pos+2
.c3b9	64 07		stz $07				stz 	IF_Pos+3
.c3bb	68		pla				pla
.c3bc	60		rts				rts
.c3bd					IF_NewLine:
.c3bd	48		pha				pha
.c3be	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3c0	18		clc				clc 								; down one line
.c3c1	a5 04		lda $04				lda 	IF_Pos
.c3c3	69 40		adc #$40			adc 	#64
.c3c5	85 04		sta $04				sta 	IF_Pos
.c3c7	90 02		bcc $c3cb			bcc 	_IF_NoCarry 				; carry through.
.c3c9	e6 05		inc $05				inc 	IF_Pos+1
.c3cb					_IF_NoCarry:
.c3cb	68		pla				pla
.c3cc	60		rts				rts
.c3cd					IF_Read:
.c3cd	5a		phy				phy 								; save current Y
.c3ce	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3d0	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3d2	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d4	7a		ply				ply									; restore Y
.c3d5	60		rts				rts
.c3d6					IF_Write:
.c3d6	5a		phy				phy 								; save current Y
.c3d7	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d9	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3db	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3dd	7a		ply				ply									; restore Y
.c3de	60		rts				rts
.c3df					IF_LeftOne:
.c3df	c6 08		dec $08				dec 	IF_XPos
.c3e1	60		rts				rts
.c3e2					IF_CheckBreak:
.c3e2	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e6	60		rts				rts
.c3e7					IF_GetKey:
.c3e7	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3eb	f0 08		beq $c3f5			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3ed	48		pha				pha 								; key pressed, clear queue.
.c3ee	a9 00		lda #$00			lda 	#0
.c3f0	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3f4	68		pla				pla
.c3f5					_IFGK_NoKey:
.c3f5	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f8					BASIC_Start:
.c3f8	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c3fa	85 16		sta $16				sta 	zCodePtr+0
.c3fc	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c3fe	85 17		sta $17				sta 	zCodePtr+1
.c400	a9 00		lda #$00			lda 	#0
.c402	85 18		sta $18				sta 	zCodePtr+2
.c404	85 19		sta $19				sta 	zCodePtr+3
.c406	a0 03		ldy #$03			ldy 	#3
.c408	c8		iny				iny
.c409	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c40b	20 14 c4	jsr $c414			jsr 	EvaluateExpression
>c40e	02						.byte 	2
.c40f					SyntaxError:
.c40f					ERR_Handler:
.c40f	80 fe		bra $c40f			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c411					EVESyntax:
.c411	4c 0f c4	jmp $c40f			jmp 	SyntaxError
.c414					EvaluateExpression:
.c414	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c416					EvaluateExpressionX:
.c416	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c418					EvaluateExpressionXA:
.c418	48		pha				pha 								; save precedence on stack.
.c419	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c41b	f0 f4		beq $c411			beq 	EVESyntax 					; end of line, syntax error.
.c41d	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c41f	b0 03		bcs $c424			bcs 	_EVNotVariable
.c421	4c d5 c4	jmp $c4d5			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c424					_EVNotVariable:
.c424	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c426	90 e9		bcc $c411			bcc 	EVESyntax
.c428	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c42a	b0 7b		bcs $c4a7			bcs 	_EVNotInteger
.c42c	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c42e	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c431	a9 00		lda #$00			lda 	#0
.c433	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c436	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c439	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c43c	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c43e	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c441					_EVCheckNextInteger:
.c441	c8		iny				iny
.c442	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c444	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c446	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c448	b0 0d		bcs $c457			bcs 	_EVCheckDecimal
.c44a	48		pha				pha 								; save it.
.c44b	20 d9 c4	jsr $c4d9			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c44e	68		pla				pla
.c44f	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c452	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c455	80 ea		bra $c441			bra 	_EVCheckNextInteger
.c457					_EVCheckDecimal:
.c457	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c459	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c45b	d0 05		bne $c462			bne 	_EVGotAtom 					; no, get atom.
.c45d					_EVIsDecimal:
.c45d	20 09 c5	jsr $c509			jsr 	EVGetDecimal 				; extend to the decimal part.
.c460	80 00		bra $c462			bra 	_EVGotAtom 					; and continue to got atom.
.c462					_EVGotAtom:
.c462	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c464	10 3f		bpl $c4a5			bpl 	_EVExitDrop 				; must be a token.
.c466	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c468	b0 3b		bcs $c4a5			bcs 	_EVExitDrop
.c46a	68		pla				pla 								; get current precedence
.c46b	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c46d	da		phx				phx 								; save X
.c46e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c470	aa		tax				tax 								; put in X
.c471	bd 3d c0	lda $c03d,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c474	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c476	fa		plx				plx 								; restore X
.c477	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c479	90 2b		bcc $c4a6			bcc 	_EVExit 					; exit if too low.
.c47b	f0 29		beq $c4a6			beq 	_EVExit 					; exit if equals
.c47d	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c47f	48		pha				pha
.c480	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c482	48		pha				pha
.c483	c8		iny				iny
.c484	da		phx				phx 								; save current position
.c485	e8		inx				inx
.c486	e8		inx				inx
.c487	e8		inx				inx
.c488	e8		inx				inx
.c489	e8		inx				inx
.c48a	e8		inx				inx
.c48b	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c48d	20 18 c4	jsr $c418			jsr 	EvaluateExpressionXA 		; do the RHS.
.c490	fa		plx				plx 								; restore X
.c491	68		pla				pla 								; get the binary operator in A.
.c492	da		phx				phx 								; save X again
.c493	0a		asl a				asl 	a 							; double, lose the MSB.
.c494	aa		tax				tax									; put in X
.c495	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c498	85 1e		sta $1e				sta 	zGenPtr
.c49a	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c49d	85 1f		sta $1f				sta 	zGenPtr+1
.c49f	fa		plx				plx 								; restore X
.c4a0	20 d6 c4	jsr $c4d6			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4a3	80 bd		bra $c462			bra 	_EVGotAtom 					; and loop back.
.c4a5					_EVExitDrop:
.c4a5	68		pla				pla
.c4a6					_EVExit:
.c4a6	60		rts				rts
.c4a7					_EVNotInteger:
.c4a7	c8		iny				iny
.c4a8	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4aa	d0 19		bne $c4c5			bne 	_EVNotMinus
.c4ac	20 5a c5	jsr $c55a			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4af	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4b2	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4b4	f0 05		beq $c4bb			beq 	_EVMinusFloat
.c4b6	20 6a c6	jsr $c66a			jsr 	IntegerNegateAlways 		; negation
.c4b9	80 a7		bra $c462			bra 	_EVGotAtom 					; and go back.
.c4bb					_EVMinusFloat:
.c4bb	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4be	49 80		eor #$80			eor 	#$80
.c4c0	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4c3	80 9d		bra $c462			bra 	_EVGotAtom
.c4c5					_EVNotMinus:
.c4c5	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4c7	d0 0b		bne $c4d4			bne 	_EVNotNot
.c4c9	20 5a c5	jsr $c55a			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4cc	20 dd ca	jsr $cadd			jsr 	FPUToInteger 				; make it an integer.
.c4cf	20 37 c5	jsr $c537			jsr 	NotInteger 					; do the not calculation
.c4d2	80 8e		bra $c462			bra 	_EVGotAtom
.c4d4					_EVNotNot:
.c4d4	ea		nop				nop
.c4d5					_EVVariableHandler:
.c4d5	ea		nop				nop
.c4d6					EVGoZGenPtr:
.c4d6	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c4d9					EVShiftMantissaLeft6:
.c4d9	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c4dc	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c4df	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c4e2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c4e5	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c4e8	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c4eb	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c4ee	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c4f1	a9 00		lda #$00			lda 	#0
.c4f3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c4f6	20 f9 c4	jsr $c4f9			jsr 	_EVSMLShift 					; call it here to do it twice
.c4f9					_EVSMLShift:
.c4f9	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c4fc	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c4ff	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c502	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c505	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c508	60		rts				rts
.c509					EVGetDecimal:
.c509	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c50b	8d 00 04	sta $0400			sta 	Num_Buffer
.c50e	da		phx				phx
.c50f	c8		iny				iny
.c510	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c512	c8		iny				iny
.c513	3a		dec a				dec 	a								; convert to a string length.
.c514	3a		dec a				dec 	a
.c515	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c517					_EVGDCopy:
.c517	48		pha				pha 									; save count
.c518	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c51a	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c51d	e8		inx				inx 									; forward ....
.c51e	c8		iny				iny
.c51f	68		pla				pla 									; get count
.c520	3a		dec a				dec 	a 								; until zero
.c521	d0 f4		bne $c517			bne 	_EVGDCopy
.c523	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c526	fa		plx				plx 									; restore X
.c527	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c529	85 1e		sta $1e				sta 	zGenPtr
.c52b	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c52d	85 1f		sta $1f				sta 	zGenPtr+1
.c52f	5a		phy				phy 									; save Y
.c530	a0 00		ldy #$00			ldy 	#0 								; start position
.c532	20 ce cc	jsr $ccce			jsr 	FPFromString 					; convert current
.c535	7a		ply				ply 									; restore Y
.c536	60		rts				rts
.c537					NotInteger:
.c537	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c53a	49 ff		eor #$ff			eor 	#$FF
.c53c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c53f	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c542	49 ff		eor #$ff			eor 	#$FF
.c544	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c547	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c54a	49 ff		eor #$ff			eor 	#$FF
.c54c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c54f	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c552	49 ff		eor #$ff			eor 	#$FF
.c554	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c557	60		rts				rts
.c558					EvaluateGetAtom:
.c558	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c55a					EvaluateGetAtomX:
.c55a	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c55c	20 18 c4	jsr $c418			jsr 	EvaluateExpressionXA
.c55f	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c562	29 0f		and #$0f			and 	#15
.c564	c9 02		cmp #$02			cmp 	#2
.c566	b0 01		bcs $c569			bcs 	EvaluateType
.c568	60		rts				rts
.c569					EvaluateType:
.c569	80 fe		bra $c569		_error: bra _error
>c56b	57 72 6f 6e 67 20 74 79				.text 	"Wrong type of data",0
>c573	70 65 20 6f 66 20 64 61 74 61 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/multiply.asm

.c57e					MulInteger32:
.c57e	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c581	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c584	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c587	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c58a	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c58d	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c590	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c593	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c596	a9 00		lda #$00			lda 	#0
.c598	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c59b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c59e	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5a1	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5a4					_BFMMultiply:
.c5a4	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c5a7	29 01		and #$01			and 	#1
.c5a9	f0 03		beq $c5ae			beq 	_BFMNoAdd
.c5ab	20 db c6	jsr $c6db			jsr 	AddInteger32
.c5ae					_BFMNoAdd:
.c5ae	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c5b1	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.c5b4	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.c5b7	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.c5ba	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c5bd	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.c5c0	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.c5c3	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.c5c6	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c5c9	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.c5cc	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.c5cf	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.c5d2	d0 d0		bne $c5a4			bne 	_BFMMultiply
.c5d4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/divide.asm

.c5d5					DivInteger32:
.c5d5	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c5d8	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c5db	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c5de	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c5e1	d0 13		bne $c5f6			bne 	_BFDOkay
.c5e3	80 fe		bra $c5e3		_error: bra _error
>c5e5	44 69 76 69 73 69 6f 6e				.text "Division by Zero",0
>c5ed	20 62 79 20 5a 65 72 6f 00
.c5f6					_BFDOkay:
.c5f6	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c5f8	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c5fa	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c5fc	85 1c		sta $1c				sta 	zLTemp1+2
.c5fe	85 1d		sta $1d				sta 	zLTemp1+3
.c600	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.c603	20 64 c6	jsr $c664			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c606	da		phx				phx
.c607	e8		inx				inx
.c608	e8		inx				inx
.c609	e8		inx				inx
.c60a	e8		inx				inx
.c60b	e8		inx				inx
.c60c	e8		inx				inx
.c60d	20 64 c6	jsr $c664			jsr 	CheckIntegerNegate
.c610	fa		plx				plx
.c611	5a		phy				phy 								; Y is the counter
.c612	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c614					_BFDLoop:
.c614	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c617	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c61a	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c61d	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c620	26 1a		rol $1a				rol 	zLTemp1
.c622	26 1b		rol $1b				rol 	zLTemp1+1
.c624	26 1c		rol $1c				rol 	zLTemp1+2
.c626	26 1d		rol $1d				rol 	zLTemp1+3
.c628	38		sec				sec
.c629	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c62b	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c62e	48		pha				pha
.c62f	a5 1b		lda $1b				lda 	zLTemp1+1
.c631	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c634	48		pha				pha
.c635	a5 1c		lda $1c				lda 	zLTemp1+2
.c637	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c63a	48		pha				pha
.c63b	a5 1d		lda $1d				lda 	zLTemp1+3
.c63d	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c640	90 15		bcc $c657			bcc 	_BFDNoAdd
.c642	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c644	68		pla				pla
.c645	85 1c		sta $1c				sta 	zLTemp1+2
.c647	68		pla				pla
.c648	85 1b		sta $1b				sta 	zLTemp1+1
.c64a	68		pla				pla
.c64b	85 1a		sta $1a				sta 	zLTemp1+0
.c64d	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c650	09 01		ora #$01			ora 	#1
.c652	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c655	80 03		bra $c65a			bra 	_BFDNext
.c657					_BFDNoAdd:
.c657	68		pla				pla 								; Throw away the intermediate calculations
.c658	68		pla				pla
.c659	68		pla				pla
.c65a					_BFDNext:
.c65a	88		dey				dey
.c65b	d0 b7		bne $c614			bne 	_BFDLoop
.c65d	7a		ply				ply 								; restore Y and exit
.c65e	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.c661	b0 07		bcs $c66a			bcs		IntegerNegateAlways 			; negate the result
.c663	60		rts				rts
.c664					CheckIntegerNegate:
.c664	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c667	30 01		bmi $c66a			bmi 	IntegerNegateAlways
.c669	60		rts				rts
.c66a					IntegerNegateAlways:
.c66a	ee 25 04	inc $0425			inc 	SignCount
.c66d	38		sec				sec
.c66e	a9 00		lda #$00			lda 	#0
.c670	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c673	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c676	a9 00		lda #$00			lda 	#0
.c678	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c67b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c67e	a9 00		lda #$00			lda 	#0
.c680	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c683	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c686	a9 00		lda #$00			lda 	#0
.c688	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c68b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c68e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c68f					BinaryOp_Add:
.c68f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c692	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c695	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c696	90 03		bcc $c69b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c698	4c db c6	jmp $c6db			jmp 	AddInteger32 							; so execute code at \1
.c69b					_BCFloat:
.c69b	20 27 c7	jsr $c727			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c69e	4c 61 c7	jmp $c761			jmp 	FPAdd 							; and execute code at \2
.c6a1	60		rts				rts
.c6a2					BinaryOp_Subtract:
.c6a2	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6a5	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6a8	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6a9	90 03		bcc $c6ae			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6ab	4c 01 c7	jmp $c701			jmp 	SubInteger32 							; so execute code at \1
.c6ae					_BCFloat:
.c6ae	20 27 c7	jsr $c727			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6b1	4c 57 c7	jmp $c757			jmp 	FPSubtract 							; and execute code at \2
.c6b4	60		rts				rts
.c6b5					BinaryOp_Multiply:
.c6b5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6b8	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6bb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6bc	90 03		bcc $c6c1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6be	4c 7e c5	jmp $c57e			jmp 	MulInteger32 							; so execute code at \1
.c6c1					_BCFloat:
.c6c1	20 27 c7	jsr $c727			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6c4	4c cc c8	jmp $c8cc			jmp 	FPMultiply 							; and execute code at \2
.c6c7	60		rts				rts
.c6c8					BinaryOp_Divide:
.c6c8	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6cb	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6ce	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6cf	90 03		bcc $c6d4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6d1	4c d5 c5	jmp $c5d5			jmp 	DivInteger32 							; so execute code at \1
.c6d4					_BCFloat:
.c6d4	20 27 c7	jsr $c727			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6d7	4c 44 c8	jmp $c844			jmp 	FPDivide 							; and execute code at \2
.c6da	60		rts				rts
.c6db					AddInteger32:
.c6db	18		clc				clc
.c6dc	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c6df	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c6e2	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c6e5	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6e8	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c6eb	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c6ee	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c6f1	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c6f4	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c6f7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c6fa	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c6fd	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c700	60		rts				rts
.c701					SubInteger32:
.c701	38		sec				sec
.c702	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c705	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c708	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c70b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c70e	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c711	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c714	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c717	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c71a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c71d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c720	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c723	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c726	60		rts				rts
.c727					BinaryMakeBothFloat:
.c727	da		phx				phx 								; save X
.c728	e8		inx				inx
.c729	e8		inx				inx
.c72a	e8		inx				inx
.c72b	e8		inx				inx
.c72c	e8		inx				inx
.c72d	e8		inx				inx
.c72e	20 32 c7	jsr $c732			jsr 	BinaryMakeFloat 			; convert to float.
.c731	fa		plx				plx 								; restore X and fall through.
.c732					BinaryMakeFloat:
.c732	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c735	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c736	b0 04		bcs $c73c			bcs 	_BMFConvert
.c738	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c739	b0 04		bcs $c73f			bcs 	_BMFError
.c73b	60		rts				rts
.c73c					_BMFConvert:
.c73c	4c 7e ca	jmp $ca7e			jmp 	FPUToFloat 					; convert to float
.c73f					_BMFError:
.c73f	80 fe		bra $c73f		_error: bra _error
>c741	4e 75 6d 65 72 69 63 20				.text 	"Numeric type required",0
>c749	74 79 70 65 20 72 65 71 75 69 72 65 64 00

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c757					FPSubtract:
.c757	48		pha				pha
.c758	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c75b	49 80		eor #$80			eor 	#$80
.c75d	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c760	68		pla				pla 								; --- and fall through ---
.c761					FPAdd:
.c761	48		pha				pha
.c762	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c765	d0 05		bne $c76c			bne 	_FPA_NegativeLHS
.c767	20 89 c7	jsr $c789			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c76a	68		pla				pla
.c76b	60		rts				rts
.c76c					_FPA_NegativeLHS:
.c76c	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c76f	49 80		eor #$80			eor 	#$80
.c771	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c774	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c777	49 80		eor #$80			eor 	#$80
.c779	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c77c	20 89 c7	jsr $c789			jsr 	FPAdd_Worker 				; do the add calculation.
.c77f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.c782	49 80		eor #$80			eor 	#$80
.c784	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c787	68		pla				pla
.c788	60		rts				rts
.c789					FPAdd_Worker:
.c789	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c78c	70 08		bvs $c796			bvs 	_FPAWExit 					; no change.
.c78e	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c791	50 07		bvc $c79a			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c793	20 2d ca	jsr $ca2d			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c796					_FPAWExit:
.c796	20 b5 ca	jsr $cab5			jsr 	FPUNormalise 				; normalise the result.
.c799	60		rts				rts
.c79a					_FPAWMakeSame:
.c79a	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c79d	38		sec				sec
.c79e	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c7a1	f0 1b		beq $c7be			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c7a3	da		phx				phx 								; save X
.c7a4	90 06		bcc $c7ac			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c7a6	e8		inx				inx
.c7a7	e8		inx				inx
.c7a8	e8		inx				inx
.c7a9	e8		inx				inx
.c7aa	e8		inx				inx
.c7ab	e8		inx				inx
.c7ac					_FPAWShiftA:
.c7ac	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c7af	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.c7b2	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c7b5	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c7b8	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c7bb	fa		plx				plx 								; restore original X
.c7bc	80 dc		bra $c79a			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c7be					_FPAW_DoArithmetic:
.c7be	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c7c1	30 39		bmi $c7fc			bmi 	_FPAW_BNegative
.c7c3	18		clc				clc
.c7c4	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7c7	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c7ca	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7cd	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7d0	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c7d3	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7d6	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7d9	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c7dc	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7df	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7e2	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c7e5	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7e8	90 ac		bcc $c796			bcc 	_FPAWExit 					; no carry.
.c7ea	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c7ed	38		sec				sec
.c7ee	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c7f1	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c7f4	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c7f7	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c7fa	80 9a		bra $c796			bra 	_FPAWExit
.c7fc					_FPAW_BNegative:
.c7fc	38		sec				sec
.c7fd	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c800	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c803	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c806	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c809	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c80c	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c80f	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c812	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c815	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c818	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c81b	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c81e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c821	b0 0b		bcs $c82e			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c823	20 5a ca	jsr $ca5a			jsr 	FPUNegateInteger			; negate the mantissa
.c826	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.c829	49 80		eor #$80			eor 	#$80
.c82b	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c82e					_FPAWGoExit:
.c82e	4c 96 c7	jmp $c796			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c831					FPD_IsDivZero:
.c831	80 fe		bra $c831		_error: bra _error
>c833	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>c83b	20 62 79 20 7a 65 72 6f 00
.c844					FPDivide:
.c844	48		pha				pha
.c845	5a		phy				phy
.c846	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.c849	70 e6		bvs $c831			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c84b	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c84e	f0 03		beq $c853			beq 	_FPDCalculateExp
.c850					_FPD_Exit:
.c850	7a		ply				ply
.c851	68		pla				pla
.c852	60		rts				rts
.c853					_FPDCalculateExp:
.c853	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c856	49 ff		eor #$ff			eor 	#$FF
.c858	1a		inc a				inc 	a
.c859	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.c85c	20 50 c9	jsr $c950			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c85f	18		clc				clc 	 							; add 1 to the resulting exponent
.c860	69 01		adc #$01			adc 	#1
.c862	b0 65		bcs $c8c9			bcs 	_FPD_Overflow 				; which can overflow.
.c864	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c867	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c869	85 1a		sta $1a				sta 	zLTemp1+0
.c86b	85 1b		sta $1b				sta 	zLTemp1+1
.c86d	85 1c		sta $1c				sta 	zLTemp1+2
.c86f	85 1d		sta $1d				sta 	zLTemp1+3
.c871	a0 20		ldy #$20			ldy 	#32 						; times round.
.c873					_FPD_Loop:
.c873	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c874	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.c877	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.c87a	48		pha				pha
.c87b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c87e	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c881	48		pha				pha
.c882	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c885	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c888	48		pha				pha
.c889	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c88c	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c88f	90 17		bcc $c8a8			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c891	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c894	68		pla				pla
.c895	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c898	68		pla				pla
.c899	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c89c	68		pla				pla
.c89d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c8a0	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c8a2	09 80		ora #$80			ora 	#$80
.c8a4	85 1d		sta $1d				sta 	zLTemp1+3
.c8a6	80 03		bra $c8ab			bra 	_FPD_Rotates
.c8a8					_FPD_NoSubtract:
.c8a8	68		pla				pla 								; throw away unwanted results
.c8a9	68		pla				pla
.c8aa	68		pla				pla
.c8ab					_FPD_Rotates:
.c8ab	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.c8ae	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.c8b1	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.c8b4	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.c8b7	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c8b9	26 1b		rol $1b				rol 	zLTemp1+1
.c8bb	26 1c		rol $1c				rol 	zLTemp1+2
.c8bd	26 1d		rol $1d				rol 	zLTemp1+3
.c8bf	90 02		bcc $c8c3			bcc 	_FPD_NoCarry
.c8c1	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c8c3					_FPD_NoCarry:
.c8c3	88		dey				dey 								; do 32 times
.c8c4	d0 ad		bne $c873			bne 	_FPD_Loop
.c8c6	4c 2d c9	jmp $c92d			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c8c9					_FPD_Overflow:
.c8c9	4c 2a cb	jmp $cb2a			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c8cc					FPMultiply:
.c8cc	48		pha				pha
.c8cd	5a		phy				phy
.c8ce	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c8d1	70 08		bvs $c8db			bvs 	_FPM_Exit
.c8d3	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c8d6	50 06		bvc $c8de			bvc 	_FPM_CalcExponent
.c8d8	20 2d ca	jsr $ca2d			jsr 	FPUCopyX2ToX1
.c8db					_FPM_Exit:
.c8db	7a		ply				ply
.c8dc	68		pla				pla
.c8dd	60		rts				rts
.c8de					_FPM_CalcExponent:
.c8de	18		clc				clc
.c8df	20 50 c9	jsr $c950			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c8e2	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.c8e5	a9 00		lda #$00			lda 	#0
.c8e7	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c8e9	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c8eb	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c8ed	85 1d		sta $1d				sta 	zLTemp1+3
.c8ef	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c8f1					_FPM_Loop:
.c8f1	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.c8f4	29 01		and #$01			and 	#1
.c8f6	18		clc				clc 								; clear carry for the long rotate.
.c8f7	f0 1d		beq $c916			beq 	_FPM_NoAddition
.c8f9	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c8fa	a5 1a		lda $1a				lda 	zLTemp1+0
.c8fc	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c8ff	85 1a		sta $1a				sta 	zLTemp1+0
.c901	a5 1b		lda $1b				lda 	zLTemp1+1
.c903	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c906	85 1b		sta $1b				sta 	zLTemp1+1
.c908	a5 1c		lda $1c				lda 	zLTemp1+2
.c90a	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c90d	85 1c		sta $1c				sta 	zLTemp1+2
.c90f	a5 1d		lda $1d				lda 	zLTemp1+3
.c911	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c914	85 1d		sta $1d				sta 	zLTemp1+3
.c916					_FPM_NoAddition:
.c916	66 1d		ror $1d				ror 	3+zLTemp1
.c918	66 1c		ror $1c				ror 	2+zLTemp1
.c91a	66 1b		ror $1b				ror 	1+zLTemp1
.c91c	66 1a		ror $1a				ror 	0+zLTemp1
.c91e	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.c921	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c924	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c927	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c92a	88		dey				dey
.c92b	d0 c4		bne $c8f1			bne 	_FPM_Loop 					; do this 32 times.
.c92d					FPM_CopySignNormalize:
.c92d	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c92f	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c932	a5 1b		lda $1b				lda 	zLTemp1+1
.c934	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c937	a5 1c		lda $1c				lda 	zLTemp1+2
.c939	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c93c	a5 1d		lda $1d				lda 	zLTemp1+3
.c93e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c941	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.c944	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.c947	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c94a	20 b5 ca	jsr $cab5			jsr 	FPUNormalise 				; normalise and exit.
.c94d	7a		ply				ply
.c94e	68		pla				pla
.c94f	60		rts				rts
.c950					FPCalculateExponent:
.c950	18		clc				clc
.c951	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c954	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.c957	b0 08		bcs $c961			bcs 	_FPCECarry 					; carry out ?
.c959	10 03		bpl $c95e			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c95b	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c95d	60		rts				rts
.c95e					_FPCEExpZero:
.c95e	a9 00		lda #$00			lda 	#0
.c960	60		rts				rts
.c961					_FPCECarry:
.c961	30 03		bmi $c966			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c963	09 80		ora #$80			ora 	#$80 						; put in right range
.c965	60		rts				rts
.c966					_FPCEOverflow:
.c966	4c 2a cb	jmp $cb2a			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c969					FPFractionalPart:
.c969	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c96c	38		sec				sec 								; this flag tells us to keep the fractional part
.c96d	30 0f		bmi $c97e			bmi 	FPGetPart
.c96f	60		rts				rts
.c970					FPIntegerPart:
.c970	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c973	18		clc				clc 								; this flag says keep the integer part.
.c974	30 08		bmi $c97e			bmi 	FPGetPart 					; -ve exponents are 0..127
.c976	48		pha				pha
.c977	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c979	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c97c	68		pla				pla
.c97d	60		rts				rts
.c97e					FPGetPart:
.c97e	48		pha				pha
.c97f	5a		phy				phy 								; save Y
.c980	08		php				php 								; save action
.c981	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c984	70 62		bvs $c9e8			bvs 	_FPGP_Exit 					; then do nothing.
.c986	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c988	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c98a	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c98c	85 1c		sta $1c				sta 	zLTemp1+2
.c98e	85 1d		sta $1d				sta 	zLTemp1+3
.c990	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.c993	38		sec				sec
.c994	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c996	f0 12		beq $c9aa			beq 	_FPGP_NoShift 				; ... if any
.c998	c9 20		cmp #$20			cmp 	#32
.c99a	90 02		bcc $c99e			bcc 	_FPGP_NotMax
.c99c	a9 20		lda #$20			lda 	#32 						; max of 32.
.c99e					_FPGP_NotMax:
.c99e	a8		tay				tay 								; Y is the mask shift count.
.c99f					_FPGP_ShiftMask:
.c99f	46 1d		lsr $1d				lsr 	3+zLTemp1
.c9a1	66 1c		ror $1c				ror 	2+zLTemp1
.c9a3	66 1b		ror $1b				ror 	1+zLTemp1
.c9a5	66 1a		ror $1a				ror 	0+zLTemp1
.c9a7	88		dey				dey
.c9a8	d0 f5		bne $c99f			bne 	_FPGP_ShiftMask
.c9aa					_FPGP_NoShift:
.c9aa	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c9ac	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.c9af					_FPGP_MaskLoop:
.c9af	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c9b2	28		plp				plp 								; if CC we keep the top part, so we
.c9b3	08		php				php		 							; flip the mask.
.c9b4	b0 02		bcs $c9b8			bcs		_FPGP_NoFlip
.c9b6	49 ff		eor #$ff			eor 	#$FF
.c9b8					_FPGP_NoFlip:
.c9b8	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c9bb	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c9be	e8		inx				inx
.c9bf	c8		iny				iny
.c9c0	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c9c2	d0 eb		bne $c9af			bne 	_FPGP_MaskLoop
.c9c4	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.c9c7	28		plp				plp
.c9c8	08		php				php 								; get action flag on the stack
.c9c9	90 05		bcc $c9d0			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c9cb	a9 00		lda #$00			lda 	#0
.c9cd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9d0					_FPGP_NotFractional:
.c9d0	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c9d3	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c9d6	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c9d9	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c9dc	f0 05		beq $c9e3			beq 	_FPGP_Zero 					; if zero, return zero
.c9de	20 b5 ca	jsr $cab5			jsr 	FPUNormalise
.c9e1	80 05		bra $c9e8			bra 	_FPGP_Exit 					; and exit
.c9e3					_FPGP_Zero:
.c9e3	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c9e5	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9e8					_FPGP_Exit:
.c9e8	68		pla				pla 								; throw saved action flag.
.c9e9	7a		ply				ply
.c9ea	68		pla				pla
.c9eb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c9ec					FPCompare:
.c9ec	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c9ef	48		pha				pha
.c9f0	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.c9f3	48		pha				pha
.c9f4	20 57 c7	jsr $c757			jsr 	FPSubtract 					; calculate X1-X2
.c9f7	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c9fa	70 2c		bvs $ca28			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c9fc	68		pla				pla
.c9fd	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.ca00	68		pla				pla
.ca01	38		sec				sec
.ca02	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.ca05	70 15		bvs $ca1c			bvs 	_FPCNotEqual				; overflow, can't be equal.
.ca07	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.ca08	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.ca0a	b0 10		bcs $ca1c			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.ca0c	38		sec				sec
.ca0d	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.ca10	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.ca12	b0 02		bcs $ca16			bcs 	_FPCNotRange 				; keep in range.
.ca14	a9 01		lda #$01			lda 	#1
.ca16					_FPCNotRange:
.ca16	38		sec				sec
.ca17	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.ca1a	b0 0e		bcs $ca2a			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.ca1c					_FPCNotEqual:
.ca1c	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.ca1f	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.ca21	f0 02		beq $ca25			beq 	_FPCNE2
.ca23	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.ca25	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.ca26	80 04		bra $ca2c			bra 	_FPCExit
.ca28					_FPCPullZero:
.ca28	68		pla				pla 								; throw saved exponents
.ca29	68		pla				pla
.ca2a					_FPCZero:
.ca2a	a9 00		lda #$00			lda 	#0 							; and return zero
.ca2c					_FPCExit:
.ca2c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.ca2d					FPUCopyX2ToX1:
.ca2d	48		pha				pha
.ca2e	da		phx				phx
.ca2f	5a		phy				phy
.ca30	a0 08		ldy #$08			ldy 	#8
.ca32	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.ca35	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ca38	e8		inx				inx
.ca39	88		dey				dey
.ca3a	10 f6		bpl $ca32			bpl 	_FPUC21
.ca3c	7a		ply				ply
.ca3d	fa		plx				plx
.ca3e	68		pla				pla
.ca3f	60		rts				rts
.ca40					FPUSetInteger:
.ca40	48		pha				pha
.ca41	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.ca44	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.ca46	10 02		bpl $ca4a			bpl 	_FPUSIExtend
.ca48	a9 ff		lda #$ff			lda 	#$FF
.ca4a					_FPUSIExtend:
.ca4a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.ca4d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca50	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca53	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.ca55	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca58	68		pla				pla
.ca59	60		rts				rts
.ca5a					FPUNegateInteger:
.ca5a	48		pha				pha
.ca5b	38		sec				sec
.ca5c	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.ca5e	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.ca61	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca64	a9 00		lda #$00			lda 	#0
.ca66	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.ca69	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca6c	a9 00		lda #$00			lda 	#0
.ca6e	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.ca71	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca74	a9 00		lda #$00			lda 	#0
.ca76	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.ca79	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca7c	68		pla				pla
.ca7d	60		rts				rts
.ca7e					FPUToFloat:
.ca7e	48		pha				pha
.ca7f	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.ca82	29 0f		and #$0f			and 	#$0F
.ca84	f0 2d		beq $cab3			beq 	_FPUFExit
.ca86	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.ca88	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca8b	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.ca8d	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.ca90	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.ca93	10 08		bpl $ca9d			bpl		_FPUFPositive
.ca95	20 5a ca	jsr $ca5a			jsr 	FPUNegateInteger 			; negate the mantissa
.ca98	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.ca9a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca9d					_FPUFPositive:
.ca9d	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.caa0	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.caa3	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.caa6	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.caa9	d0 05		bne $cab0			bne 	_FPUFNonZero
.caab	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.caad	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cab0					_FPUFNonZero:
.cab0	20 b5 ca	jsr $cab5			jsr 	FPUNormalise 				; normalise the floating point.
.cab3					_FPUFExit:
.cab3	68		pla				pla
.cab4	60		rts				rts
.cab5					FPUNormalise:
.cab5	48		pha				pha
.cab6	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cab9	70 20		bvs $cadb			bvs 	_FPUNExit
.cabb	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cabe	f0 16		beq $cad6			beq 	_FPUNSetZero
.cac0					_FPUNLoop:
.cac0	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cac3	30 16		bmi $cadb			bmi 	_FPUNExit 					; if so, we are normalised.
.cac5	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.cac8	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.cacb	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.cace	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.cad1	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.cad4	d0 ea		bne $cac0			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cad6					_FPUNSetZero:
.cad6	a9 40		lda #$40			lda 	#$40
.cad8	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.cadb					_FPUNExit:
.cadb	68		pla				pla
.cadc	60		rts				rts
.cadd					FPUToInteger:
.cadd	48		pha				pha
.cade	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.cae1	29 01		and #$01			and 	#1
.cae3	d0 3e		bne $cb23			bne 	_FPUTOI_Exit
.cae5	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.cae8	70 2b		bvs $cb15			bvs 	_FPUTOI_Zero
.caea	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.caed	10 26		bpl $cb15			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.caef	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.caf1	b0 37		bcs $cb2a			bcs 	FP_Overflow
.caf3					_FPUToIToInteger:
.caf3	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.caf6	c9 a0		cmp #$a0			cmp 	#128+32
.caf8	f0 11		beq $cb0b			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.cafa	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.cafd	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cb00	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cb03	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cb06	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cb09	80 e8		bra $caf3			bra 	_FPUToIToInteger 			; keep going.
.cb0b					_FPUToICheckSign:
.cb0b	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.cb0e	10 13		bpl $cb23			bpl 	_FPUToI_Exit 				; exit if unsigned.
.cb10	20 5a ca	jsr $ca5a			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.cb13	80 0e		bra $cb23			bra 	_FPUTOI_Exit
.cb15					_FPUTOI_Zero:
.cb15	a9 00		lda #$00			lda 	#0 							; return zero integer.
.cb17	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb1a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb1d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb20	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb23					_FPUToI_Exit:
.cb23	a9 01		lda #$01			lda 	#1 							; set type to integer
.cb25	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb28	68		pla				pla
.cb29	60		rts				rts
.cb2a					FP_Overflow:
.cb2a	80 fe		bra $cb2a		_error: bra _error
>cb2c	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>cb34	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.cb44					FPUTimes10:
.cb44	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.cb47	85 1a		sta $1a				sta 	ZLTemp1+0
.cb49	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cb4c	85 1b		sta $1b				sta 	ZLTemp1+1
.cb4e	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb51	85 1c		sta $1c				sta 	ZLTemp1+2
.cb53	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb56	85 1d		sta $1d				sta 	ZLTemp1+3
.cb58	20 9c cb	jsr $cb9c			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.cb5b	20 9c cb	jsr $cb9c			jsr 	_FPUT_LSR_ZLTemp1
.cb5e	18		clc				clc
.cb5f	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.cb62	65 1a		adc $1a				adc 	ZLTemp1+0
.cb64	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb67	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cb6a	65 1b		adc $1b				adc 	ZLTemp1+1
.cb6c	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb6f	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb72	65 1c		adc $1c				adc 	ZLTemp1+2
.cb74	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb77	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb7a	65 1d		adc $1d				adc 	ZLTemp1+3
.cb7c	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb7f	90 0f		bcc $cb90			bcc 	_FPUTimes10
.cb81	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cb84	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cb87	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cb8a	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cb8d	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.cb90					_FPUTimes10:
.cb90	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.cb93	18		clc				clc
.cb94	69 03		adc #$03			adc 	#3
.cb96	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cb99	b0 8f		bcs $cb2a			bcs 	FP_Overflow 				; error
.cb9b	60		rts				rts
.cb9c					_FPUT_LSR_ZLTemp1:
.cb9c	46 1d		lsr $1d				lsr 	ZLTemp1+3
.cb9e	66 1c		ror $1c				ror 	ZLTemp1+2
.cba0	66 1b		ror $1b				ror 	ZLTemp1+1
.cba2	66 1a		ror $1a				ror 	ZLTemp1+0
.cba4	60		rts				rts
.cba5					FPUScale10A:
.cba5	5a		phy				phy
.cba6	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.cba8	f0 3d		beq $cbe7			beq 	_FPUScaleExit
.cbaa	da		phx				phx 								; save X
.cbab	e8		inx				inx
.cbac	e8		inx				inx
.cbad	e8		inx				inx
.cbae	e8		inx				inx
.cbaf	e8		inx				inx
.cbb0	e8		inx				inx
.cbb1	a8		tay				tay 								; save power scalar in Y.
.cbb2	a9 00		lda #$00			lda 	#0
.cbb4	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.cbb7	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cbba	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cbbd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cbc0	a9 80		lda #$80			lda 	#$80
.cbc2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cbc5	a9 81		lda #$81			lda 	#$81
.cbc7	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cbca	5a		phy				phy 								; save 10^n on stack.
.cbcb	c0 00		cpy #$00			cpy 	#0
.cbcd	10 05		bpl $cbd4			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.cbcf	98		tya				tya
.cbd0	49 ff		eor #$ff			eor 	#$FF
.cbd2	1a		inc a				inc 	a
.cbd3	a8		tay				tay
.cbd4					_FPUSAbs:
.cbd4	20 44 cb	jsr $cb44			jsr 	FPUTimes10
.cbd7	88		dey				dey
.cbd8	d0 fa		bne $cbd4			bne 	_FPUSAbs 					; tos is now 10^|AC|
.cbda	68		pla				pla 								; restore count in A
.cbdb	fa		plx				plx 								; restore X pointing to number to scale.
.cbdc	0a		asl a				asl 	a
.cbdd	b0 05		bcs $cbe4			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.cbdf	20 cc c8	jsr $c8cc			jsr 	FPMultiply 					; if clear multiply.
.cbe2	80 03		bra $cbe7			bra		_FPUScaleExit
.cbe4					_FPUSDivide:
.cbe4	20 44 c8	jsr $c844			jsr 	FPDivide
.cbe7					_FPUScaleExit:
.cbe7	7a		ply				ply
.cbe8	60		rts				rts
.cbe9					FPUCopyToNext:
.cbe9	a0 06		ldy #$06			ldy 		#6
.cbeb	da		phx				phx
.cbec					_FPUCopy1:
.cbec	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.cbef	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.cbf2	e8		inx				inx
.cbf3	88		dey				dey
.cbf4	d0 f6		bne $cbec			bne 	_FPUCopy1
.cbf6	fa		plx				plx
.cbf7	60		rts				rts
.cbf8					FPUCopyFromNext:
.cbf8	a0 06		ldy #$06			ldy 		#6
.cbfa	da		phx				phx
.cbfb					_FPUCopy1:
.cbfb	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.cbfe	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cc01	e8		inx				inx
.cc02	88		dey				dey
.cc03	d0 f6		bne $cbfb			bne 	_FPUCopy1
.cc05	fa		plx				plx
.cc06	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.cc07					FPToString:
.cc07	48		pha				pha
.cc08	5a		phy				phy
.cc09	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.cc0c	50 0a		bvc $cc18			bvc 		_FPTSIsFloat 			; if zero,
.cc0e					_FPTSZero:
.cc0e	a9 30		lda #$30			lda 		#"0"
.cc10	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter
.cc13					_FPTSExit:
.cc13	7a		ply				ply
.cc14	68		pla				pla
.cc15	60		rts				rts
.cc16	80 fb		bra $cc13			bra 		_FPTSExit
.cc18					_FPTSIsFloat:
.cc18	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.cc1b	10 0a		bpl $cc27			bpl 		_FPTSNotSigned
.cc1d	a9 00		lda #$00			lda 		#0 						; clear sign flag
.cc1f	9d 05 03	sta $0305,x			sta 		XS_Type,x
.cc22	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cc24	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter
.cc27					_FPTSNotSigned:
.cc27	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.cc2a	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.cc2c	b0 09		bcs $cc37			bcs 		_FPTSExponent
.cc2e	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.cc30	90 05		bcc $cc37			bcc 		_FPTSExponent 			;
.cc32					_FPTSStandard:
.cc32	20 7b cc	jsr $cc7b			jsr 		FPTOutputBody 			; output the body.
.cc35	80 dc		bra $cc13			bra 		_FPTSExit
.cc37					_FPTSExponent:
.cc37	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.cc39	8d 24 04	sta $0424			sta 		ExpCount
.cc3c					_FPTSExponentLoop:
.cc3c	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.cc3f	10 0e		bpl $cc4f			bpl 		_FPTSTimes
.cc41	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.cc43	90 14		bcc $cc59			bcc 		_FPTSScaledToExp
.cc45	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.cc47	20 a5 cb	jsr $cba5			jsr 		FPUScale10A
.cc4a	ee 24 04	inc $0424			inc 		ExpCount
.cc4d	80 ed		bra $cc3c			bra 		_FPTSExponentLoop
.cc4f					_FPTSTimes:
.cc4f	a9 01		lda #$01			lda 		#1
.cc51	20 a5 cb	jsr $cba5			jsr 		FPUScale10A
.cc54	ce 24 04	dec $0424			dec 		ExpCount
.cc57	80 e3		bra $cc3c			bra 		_FPTSExponentLoop
.cc59					_FPTSScaledToExp:
.cc59	20 7b cc	jsr $cc7b			jsr 		FPTOutputBody 			; output the body.
.cc5c	a9 65		lda #$65			lda 		#"e"					; output E
.cc5e	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter
.cc61	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.cc64	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.cc67	29 80		and #$80			and 		#$80 					; sign extend it
.cc69	f0 02		beq $cc6d			beq 		_FPTSSExt
.cc6b	a9 ff		lda #$ff			lda 		#$FF
.cc6d					_FPTSSExt:
.cc6d	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cc70	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cc73	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.cc76	20 4f cd	jsr $cd4f			jsr 		INTToString 			; output the exponent.
.cc79	80 98		bra $cc13			bra			_FPTSExit 				; and exit.
.cc7b					FPTOutputBody:
.cc7b	20 e9 cb	jsr $cbe9			jsr 		FPUCopyToNext 			; copy to next slot.
.cc7e	20 dd ca	jsr $cadd			jsr 		FPUToInteger 			; convert to an integer
.cc81	20 4f cd	jsr $cd4f			jsr 		INTToString 			; output the main integer part.
.cc84	20 f8 cb	jsr $cbf8			jsr 		FPUCopyFromNext 		; get the fractional part back.
.cc87	20 69 c9	jsr $c969			jsr 		FPFractionalPart 		; get the decimal part.
.cc8a	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.cc8d	70 3e		bvs $cccd			bvs 		_FPTOExit 				; if not, exit now.
.cc8f	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.cc91	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter
.cc94					_FPOutLoop:
.cc94	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.cc97	70 1e		bvs $ccb7			bvs 		_FPStripZeros 			; strip trailing zeros
.cc99	20 44 cb	jsr $cb44			jsr 		FPUTimes10 				; multiply by 10
.cc9c	20 e9 cb	jsr $cbe9			jsr 		FPUCopyToNext			; copy to next slot.
.cc9f	20 dd ca	jsr $cadd			jsr 		FPUToInteger 			; convert to integer
.cca2	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.cca5	09 30		ora #$30			ora 		#"0"
.cca7	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter
.ccaa	20 f8 cb	jsr $cbf8			jsr 		FPUCopyFromNext 		; get it back
.ccad	20 69 c9	jsr $c969			jsr 		FPFractionalPart 		; get fractional part
.ccb0	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.ccb3	c9 0b		cmp #$0b			cmp 	 	#11
.ccb5	90 dd		bcc $cc94			bcc 		_FPOutLoop 				; if so, keep going till zero.
.ccb7					_FPStripZeros:
.ccb7	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.ccba					_FPStripLoop:
.ccba	88		dey				dey 								; back one, if at start then no strip
.ccbb	f0 10		beq $cccd			beq 		_FPToExit
.ccbd	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.ccc0	c9 30		cmp #$30			cmp 		#"0"
.ccc2	f0 f6		beq $ccba			beq 		_FPStripLoop
.ccc4	c8		iny				iny
.ccc5	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.ccc7	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.ccca	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.cccd					_FPTOExit:
.cccd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.ccce					FPFromString:
.ccce	48		pha				pha 								; push A
.cccf	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.ccd1	c9 2e		cmp #$2e			cmp 	#"."
.ccd3	f0 03		beq $ccd8			beq	 	_FPFIsDecimal
.ccd5	4c 3b cd	jmp $cd3b			jmp 	_FPFNotDecimal
.ccd8					_FPFIsDecimal:
.ccd8	c8		iny				iny 								; consume the decimal.
.ccd9	20 7e ca	jsr $ca7e			jsr 	FPUToFloat 					; convert the integer to float.
.ccdc	da		phx				phx 								; save X.
.ccdd	5a		phy				phy 								; save decimal start position
.ccde	e8		inx				inx
.ccdf	e8		inx				inx
.cce0	e8		inx				inx
.cce1	e8		inx				inx
.cce2	e8		inx				inx
.cce3	e8		inx				inx
.cce4	20 03 ce	jsr $ce03			jsr 	INTFromStringY 				; get the part after the DP.
.cce7	20 7e ca	jsr $ca7e			jsr 	FPUToFloat 					; convert that to a float.
.ccea	68		pla				pla 								; calculate - chars consumed.
.cceb	8c 23 04	sty $0423			sty 	ExpTemp
.ccee	38		sec				sec
.ccef	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.ccf2	20 a5 cb	jsr $cba5			jsr 	FPUScale10A 				; scale it by 10^AC
.ccf5	fa		plx				plx 								; restore original X
.ccf6	20 61 c7	jsr $c761			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.ccf9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.ccfb	c9 45		cmp #$45			cmp 	#"E"
.ccfd	f0 04		beq $cd03			beq 	_FPFExponent
.ccff	c9 65		cmp #$65			cmp 	#"e"
.cd01	d0 38		bne $cd3b			bne 	_FPFNotDecimal 				; no, then exit normally.
.cd03					_FPFExponent:
.cd03	c8		iny				iny 								; skip over E symbol.
.cd04	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.cd06	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.cd08	d0 01		bne $cd0b			bne 	_FPFGotSign
.cd0a	c8		iny				iny 								; if it was - skip over it.
.cd0b					_FPFGotSign:
.cd0b	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.cd0c	da		phx				phx
.cd0d	e8		inx				inx
.cd0e	e8		inx				inx
.cd0f	e8		inx				inx
.cd10	e8		inx				inx
.cd11	e8		inx				inx
.cd12	e8		inx				inx
.cd13	20 03 ce	jsr $ce03			jsr 	INTFromStringY 				; get the exponent
.cd16	fa		plx				plx 								; restore X.
.cd17	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.cd1a	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.cd1d	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.cd20	d0 1b		bne $cd3d			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.cd22	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.cd25	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.cd27	b0 14		bcs $cd3d			bcs 	_FPFXOverflow
.cd29	68		pla				pla 								; get direction
.cd2a	d0 09		bne $cd35			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.cd2c	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.cd2f	49 ff		eor #$ff			eor 	#$FF
.cd31	1a		inc a				inc 	a
.cd32	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.cd35					_FPFXScale:
.cd35	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.cd38	20 a5 cb	jsr $cba5			jsr 	FPUScale10A 				; scale by the exponent.
.cd3b					_FPFNotDecimal:
.cd3b	68		pla				pla
.cd3c	60		rts				rts
.cd3d					_FPFXOverflow:
.cd3d	20 0f c4	jsr $c40f			jsr 	ERR_Handler
>cd40	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>cd48	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cd4f					INTToString:
.cd4f	48		pha				pha
.cd50	5a		phy				phy
.cd51	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.cd54	10 08		bpl $cd5e			bpl 		_ITSNotMinus
.cd56	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cd58	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter
.cd5b	20 5a ca	jsr $ca5a			jsr 		FPUNegateInteger
.cd5e					_ITSNotMinus:
.cd5e	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.cd60	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.cd63	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.cd65					_ITSNextSubtractor:
.cd65	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cd67	8d 22 04	sta $0422			sta 		NumConvCount
.cd6a					_ITSSubtract:
.cd6a	38		sec				sec
.cd6b	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.cd6e	f9 c7 cd	sbc $cdc7,y			sbc 		_ITSSubtractors+0,y
.cd71	48		pha				pha
.cd72	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.cd75	f9 c8 cd	sbc $cdc8,y			sbc 		_ITSSubtractors+1,y
.cd78	48		pha				pha
.cd79	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.cd7c	f9 c9 cd	sbc $cdc9,y			sbc 		_ITSSubtractors+2,y
.cd7f	48		pha				pha
.cd80	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.cd83	f9 ca cd	sbc $cdca,y			sbc 		_ITSSubtractors+3,y
.cd86	90 14		bcc $cd9c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cd88	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.cd8b	68		pla				pla
.cd8c	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cd8f	68		pla				pla
.cd90	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cd93	68		pla				pla
.cd94	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.cd97	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.cd9a	80 ce		bra $cd6a			bra 		_ITSSubtract 			; go round again.
.cd9c					_ITSCantSubtract:
.cd9c	68		pla				pla 								; throw away interim answers
.cd9d	68		pla				pla
.cd9e	68		pla				pla
.cd9f	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.cda2	c9 30		cmp #$30			cmp 		#"0"
.cda4	d0 05		bne $cdab			bne 		_ITSOutputDigit
.cda6	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cda9	10 09		bpl $cdb4			bpl 		_ITSGoNextSubtractor
.cdab					_ITSOutputDigit:
.cdab	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.cdae	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.cdb1	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter 		; output it.
.cdb4					_ITSGoNextSubtractor:
.cdb4	c8		iny				iny 								; next dword
.cdb5	c8		iny				iny
.cdb6	c8		iny				iny
.cdb7	c8		iny				iny
.cdb8	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.cdba	d0 a9		bne $cd65			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cdbc	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cdbf	09 30		ora #$30			ora 		#"0"
.cdc1	20 eb cd	jsr $cdeb			jsr 		ITSOutputCharacter
.cdc4	7a		ply				ply 								; and exit
.cdc5	68		pla				pla
.cdc6	60		rts				rts
.cdc7					_ITSSubtractors:
>cdc7	00 ca 9a 3b					.dword 		1000000000
>cdcb	00 e1 f5 05					.dword 		100000000
>cdcf	80 96 98 00					.dword 		10000000
>cdd3	40 42 0f 00					.dword 		1000000
>cdd7	a0 86 01 00					.dword 		100000
>cddb	10 27 00 00					.dword 		10000
>cddf	e8 03 00 00					.dword 		1000
>cde3	64 00 00 00					.dword 		100
>cde7	0a 00 00 00					.dword 		10
.cdeb					_ITSSubtractorsEnd:
.cdeb					ITSOutputCharacter:
.cdeb	48		pha				pha
.cdec	da		phx				phx
.cded	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.cdf0	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.cdf3	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cdf5	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.cdf8	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.cdfb	fa		plx				plx
.cdfc	68		pla				pla
.cdfd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cdfe					IntFromString:
.cdfe	a0 00		ldy #$00			ldy 	#0
.ce00	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.ce03					IntFromStringY:
.ce03	48		pha				pha
.ce04	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.ce06	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ce09	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce0c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce0f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce12	a9 01		lda #$01			lda 	#1
.ce14	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce17					_IFSLoop:
.ce17	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.ce19	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.ce1b	90 60		bcc $ce7d			bcc 	_IFSExit
.ce1d	c9 3a		cmp #$3a			cmp 	#"9"+1
.ce1f	b0 5c		bcs $ce7d			bcs 	_IFSExit
.ce21	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.ce24	c9 0c		cmp #$0c			cmp 	#12
.ce26	b0 5f		bcs $ce87			bcs 	_IFSOverflow
.ce28	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.ce2b	48		pha				pha
.ce2c	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce2f	48		pha				pha
.ce30	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ce33	48		pha				pha
.ce34	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ce37	48		pha				pha
.ce38	20 9c ce	jsr $ce9c			jsr 	IFSX1ShiftLeft 				; double
.ce3b	20 9c ce	jsr $ce9c			jsr 	IFSX1ShiftLeft 				; x 4
.ce3e	18		clc				clc 								; add saved value x 5
.ce3f	68		pla				pla
.ce40	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ce43	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce46	68		pla				pla
.ce47	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.ce4a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce4d	68		pla				pla
.ce4e	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.ce51	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce54	68		pla				pla
.ce55	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.ce58	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce5b	20 9c ce	jsr $ce9c			jsr 	IFSX1ShiftLeft 				; x 10
.ce5e	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.ce61	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.ce63	29 0f		and #$0f			and 	#15
.ce65	c8		iny				iny
.ce66	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ce69	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce6c	90 a9		bcc $ce17			bcc 	_IFSLoop
.ce6e	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.ce71	d0 a4		bne $ce17			bne 	_IFSLoop
.ce73	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.ce76	d0 9f		bne $ce17			bne 	_IFSLoop
.ce78	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.ce7b	80 9a		bra $ce17			bra 	_IFSLoop
.ce7d					_IFSExit:
.ce7d	98		tya				tya 								; get offset
.ce7e					_IFSOkay:
.ce7e	38		sec				sec
.ce7f	ad 23 04	lda $0423			lda 	ExpTemp
.ce82	f0 01		beq $ce85			beq 	_IFSSkipFail
.ce84	18		clc				clc
.ce85					_IFSSkipFail:
.ce85	68		pla				pla 								; and exit.
.ce86	60		rts				rts
.ce87					_IFSOverflow:
.ce87	20 0f c4	jsr $c40f			jsr 	ERR_Handler
>ce8a	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>ce92	20 6f 76 65 72 66 6c 6f 77 00
.ce9c					IFSX1ShiftLeft:
.ce9c	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa,x
.ce9f	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa,x
.cea2	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa,x
.cea5	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa,x
.cea8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.cea9					TIM_Error:
.cea9	20 37 c2	jsr $c237			jsr 	IFT_UpLine 					; go up one line.
.ceac	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ceae	80 02		bra $ceb2			bra 	TIM_ShowPrompt
.ceb0					TIM_NewCommand:
.ceb0	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ceb2					TIM_ShowPrompt:
.ceb2	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ceb5	20 fb c2	jsr $c2fb			jsr 	IFT_ReadLine	 			; get character, go to next line
.ceb8	20 5d c2	jsr $c25d			jsr 	IFT_NewLine					; go to next line.
.cebb	86 10		stx $10				stx 	zTemp1 						; save line read address
.cebd	84 11		sty $11				sty 	zTemp1+1
.cebf	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.cec1	b1 10		lda ($10),y			lda 	(zTemp1),y
.cec3	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.cec5	d0 01		bne $cec8			bne 	TIM_NotDot
.cec7	c8		iny				iny
.cec8					TIM_NotDot:
.cec8	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ceca	c9 52		cmp #$52			cmp 	#"R"						; show registers
.cecc	f0 6b		beq $cf39			beq 	TIM_ShowRegisters
.cece	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ced0	f0 12		beq $cee4			beq 	TIM_ShowMemory
.ced2	c9 47		cmp #$47			cmp 	#"G"						; execute
.ced4	f0 49		beq $cf1f			beq 	TIM_Execute
.ced6	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ced8	f0 07		beq $cee1			beq 	TIM_GoLoadMemory
.ceda	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.cedc	d0 cb		bne $cea9			bne 	TIM_Error
.cede	4c 5c d0	jmp $d05c			jmp 	TIM_UpdateRegisters
.cee1					TIM_GoLoadMemory:
.cee1	4c 8c d0	jmp $d08c			jmp 	TIM_LoadMemory
.cee4					TIM_ShowMemory:
.cee4	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.cee7	b0 c0		bcs $cea9			bcs 	TIM_Error
.cee9	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ceeb	85 12		sta $12				sta 	zTemp2
.ceed	a5 15		lda $15				lda 	zTemp3+1
.ceef	85 13		sta $13				sta 	zTemp2+1
.cef1	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.cef4	90 08		bcc $cefe			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.cef6	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.cef8	85 14		sta $14				sta 	zTemp3
.cefa	a5 13		lda $13				lda 	zTemp2+1
.cefc	85 15		sta $15				sta 	zTemp3+1
.cefe					_TIMSM_Start:
.cefe	20 b0 cf	jsr $cfb0			jsr 	TIM_WriteLine 				; write one line of hex out
.cf01	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.cf03	18		clc				clc
.cf04	69 10		adc #$10			adc 	#16
.cf06	85 12		sta $12				sta 	zTemp2
.cf08	90 02		bcc $cf0c			bcc 	_TIMSM_NoCarry
.cf0a	e6 13		inc $13				inc 	zTemp2+1
.cf0c					_TIMSM_NoCarry:
.cf0c	20 e2 c3	jsr $c3e2			jsr 	IF_CheckBreak 				; check CTL+C
.cf0f	d0 0b		bne $cf1c			bne 	_TIMSM_Ends 				; if pressed break out.
.cf11	38		sec				sec 								; check past the end address in zTemp3
.cf12	a5 14		lda $14				lda 	zTemp3
.cf14	e5 12		sbc $12				sbc 	zTemp2
.cf16	a5 15		lda $15				lda 	zTemp3+1
.cf18	e5 13		sbc $13				sbc 	zTemp2+1
.cf1a	10 e2		bpl $cefe			bpl 	_TIMSM_Start
.cf1c					_TIMSM_Ends:
.cf1c	4c b0 ce	jmp $ceb0			jmp 	TIM_NewCommand
.cf1f					TIM_Execute:
.cf1f	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; get the execute address
.cf22	b0 85		bcs $cea9			bcs 	TIM_Error 					; not legitimate
.cf24	ae 2f 04	ldx $042f			ldx 	TIM_SP 						; set up SP
.cf27	9a		txs				txs
.cf28	ad 2a 04	lda $042a			lda 	TIM_SR 						; Status for PLP
.cf2b	48		pha				pha
.cf2c	ad 2b 04	lda $042b			lda 	TIM_A 						; restore AXYZ
.cf2f	ae 2c 04	ldx $042c			ldx 	TIM_X
.cf32	ac 2d 04	ldy $042d			ldy 	TIM_Y
.cf35	28		plp				plp 								; and PS Byte.
.cf36	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.cf39					TIM_Start:
.cf39					TIM_ShowRegisters:
.cf39	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.cf3c	8d 29 04	sta $0429			sta 	TIM_IRQ+1
.cf3f	ad ff ff	lda $ffff			lda 	$FFFF
.cf42	8d 28 04	sta $0428			sta 	TIM_IRQ
.cf45	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.cf47					_TIMSR_Text:
.cf47	bd 77 cf	lda $cf77,x			lda 	_TIMSR_Label,x
.cf4a	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.cf4d	e8		inx				inx
.cf4e	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.cf50	d0 f5		bne $cf47			bne 	_TIMSR_Text
.cf52	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.cf54					_TIMSR_Skip:
.cf54	e8		inx				inx
.cf55					_TIMSR_LoopSpace:
.cf55	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.cf57	b0 04		bcs $cf5d			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.cf59	8a		txa				txa
.cf5a	4a		lsr a				lsr 	a
.cf5b	b0 05		bcs $cf62			bcs 	_TIMSR_NoSpace
.cf5d					_TIMSR_Space:
.cf5d	a9 20		lda #$20			lda 	#" "
.cf5f	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.cf62					_TIMSR_NoSpace:
.cf62	bd 26 04	lda $0426,x			lda 	TIM_PC,x 					; output hex value.
.cf65	20 97 cf	jsr $cf97			jsr 	TIM_WriteHex
.cf68	e8		inx				inx
.cf69	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.cf6b	f0 e7		beq $cf54			beq 	_TIMSR_Skip
.cf6d	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.cf6f	d0 e4		bne $cf55			bne 	_TimSR_LoopSpace
.cf71	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; new line
.cf74	4c b0 ce	jmp $ceb0			jmp	 	TIM_NewCommand 				; new command.
.cf77					_TIMSR_Label:
>cf77	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>cf7f	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>cf8f	52
>cf90	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.cf97					_TIMSR_LabelEnd:
.cf97					TIM_WriteHex:
.cf97	48		pha				pha 								; save A
.cf98	4a		lsr a				lsr 	a 							; shift MSB->LSB
.cf99	4a		lsr a				lsr 	a
.cf9a	4a		lsr a				lsr 	a
.cf9b	4a		lsr a				lsr 	a
.cf9c	20 a0 cf	jsr $cfa0			jsr 	_TIMWH_Nibble 				; print MSB
.cf9f	68		pla				pla 								; restore and print LSB
.cfa0					_TIMWH_Nibble:
.cfa0	48		pha				pha
.cfa1	29 0f		and #$0f			and 	#15 						; mask out
.cfa3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.cfa5	90 02		bcc $cfa9			bcc 	_TIMWHNoLetter
.cfa7	69 06		adc #$06			adc 	#6
.cfa9					_TIMWHNoLetter:
.cfa9	69 30		adc #$30			adc 	#48
.cfab	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter 			; print it out.
.cfae	68		pla				pla
.cfaf	60		rts				rts
.cfb0					TIM_WriteLine:
.cfb0	a9 2e		lda #$2e			lda 	#"." 						; prompt
.cfb2	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.cfb5	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.cfb7	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.cfba	a5 13		lda $13				lda 	zTemp2+1 					; write address
.cfbc	20 97 cf	jsr $cf97			jsr 	TIM_WriteHex
.cfbf	a5 12		lda $12				lda 	zTemp2
.cfc1	20 97 cf	jsr $cf97			jsr 	TIM_WriteHex
.cfc4	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.cfc6					_TIMWL_Loop:
.cfc6	a9 20		lda #$20			lda 	#" "
.cfc8	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.cfcb	b1 12		lda ($12),y			lda 	(zTemp2),y
.cfcd	20 97 cf	jsr $cf97			jsr 	TIM_WriteHex
.cfd0	c8		iny				iny
.cfd1	c0 10		cpy #$10			cpy 	#16
.cfd3	d0 f1		bne $cfc6			bne 	_TIMWL_Loop
.cfd5	4c 5d c2	jmp $c25d			jmp 	IFT_NewLine 				; new line and exit
.cfd8					TIM_GetHex:
.cfd8	c8		iny				iny
.cfd9	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.cfdb	c9 20		cmp #$20			cmp 	#32
.cfdd	f0 f9		beq $cfd8			beq 	TIM_GetHex
.cfdf	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.cfe1	f0 f5		beq $cfd8			beq 	TIM_GetHex
.cfe3	20 0c d0	jsr $d00c			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.cfe6	b0 23		bcs $d00b			bcs 	_TIMGH_Exit					; if first bad then exit now.
.cfe8	a9 00		lda #$00			lda 	#0 							; zero result
.cfea	85 14		sta $14				sta 	zTemp3
.cfec	85 15		sta $15				sta 	zTemp3+1
.cfee					_TIM_GHLoop:
.cfee	20 0c d0	jsr $d00c			jsr 	TIM_GetHexCharacter 		; get next character
.cff1	b0 17		bcs $d00a			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.cff3	c8		iny				iny 								; skip over it.
.cff4	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.cff6	26 15		rol $15				rol 	zTemp3+1
.cff8	06 14		asl $14				asl 	zTemp3 						; now x 2
.cffa	26 15		rol $15				rol 	zTemp3+1
.cffc	06 14		asl $14				asl 	zTemp3						; now x 4
.cffe	26 15		rol $15				rol 	zTemp3+1
.d000	06 14		asl $14				asl 	zTemp3 						; now x 8
.d002	26 15		rol $15				rol 	zTemp3+1
.d004	05 14		ora $14				ora 	zTemp3 						; OR result in
.d006	85 14		sta $14				sta 	zTemp3
.d008	80 e4		bra $cfee			bra 	_TIM_GHLoop 				; loop round again.
.d00a					_TIMGH_Okay:
.d00a	18		clc				clc
.d00b					_TIMGH_Exit:
.d00b	60		rts				rts
.d00c					TIM_GetHexCharacter:
.d00c	b1 10		lda ($10),y			lda 	(zTemp1),y
.d00e	38		sec				sec
.d00f	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d011	90 0e		bcc $d021			bcc 	_TIM_GHCFail
.d013	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d015	90 0b		bcc $d022			bcc 	_TIM_GHCExit
.d017	c9 11		cmp #$11			cmp 	#65-48						; < A
.d019	90 06		bcc $d021			bcc		_TIM_GHCFail
.d01b	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d01d	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d01f	90 01		bcc $d022			bcc		_TIM_GHCExit
.d021					_TIM_GHCFail:
.d021	38		sec				sec
.d022					_TIM_GHCExit:
.d022	60		rts				rts
.d023					TIM_BreakVector:
.d023	da		phx				phx									; save X/A on stack
.d024	48		pha				pha
.d025	ba		tsx				tsx 								; X points to S
.d026	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d029	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d02b	d0 03		bne $d030			bne 	_TIMBreak					; if set, it's BRK
.d02d	68		pla				pla 								; abandon routine.
.d02e	fa		plx				plx
.d02f	40		rti				rti
.d030					_TIMBreak:
.d030	68		pla				pla 								; save A X Y and maybe Z
.d031	8d 2b 04	sta $042b			sta 	TIM_A
.d034	fa		plx				plx
.d035	8e 2c 04	stx $042c			stx 	TIM_X
.d038	8c 2d 04	sty $042d			sty 	TIM_Y
.d03b	68		pla				pla 								; get Status Register
.d03c	8d 2a 04	sta $042a			sta 	TIM_SR
.d03f	68		pla				pla
.d040	8d 27 04	sta $0427			sta 	TIM_PC+1 					; save calling address
.d043	68		pla				pla
.d044	8d 26 04	sta $0426			sta 	TIM_PC 						; high byte
.d047	ad 27 04	lda $0427			lda 	TIM_PC+1 					; dec PC to point right.
.d04a	d0 03		bne $d04f			bne 	_TIMDecrement 				; brk bumps it.
.d04c	ce 26 04	dec $0426			dec 	TIM_PC
.d04f					_TIMDecrement:
.d04f	ce 27 04	dec $0427			dec 	TIM_PC+1
.d052	ba		tsx				tsx 								; and copy SP
.d053	8e 2f 04	stx $042f			stx 	TIM_SP
.d056	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d058	9a		txs				txs
.d059	4c 39 cf	jmp $cf39			jmp 	TIM_Start 					; and start up TIM monitor.
.d05c					TIM_UpdateRegisters:
.d05c	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; PC
.d05f	b0 28		bcs $d089			bcs 	_TIMURFail
.d061	a5 14		lda $14				lda 	zTemp3
.d063	8d 27 04	sta $0427			sta 	Tim_PC+1
.d066	a5 15		lda $15				lda 	zTemp3+1
.d068	8d 26 04	sta $0426			sta 	Tim_PC
.d06b	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; ignore IRQ
.d06e	b0 19		bcs $d089			bcs 	_TIMURFail
.d070	a2 00		ldx #$00			ldx 	#0
.d072					_TIM_URLoop:
.d072	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d074	d0 01		bne $d077			bne 	_TIM_1
.d076	e8		inx				inx
.d077					_TIM_1:
.d077	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; registers
.d07a	b0 0d		bcs $d089			bcs 	_TIMURFail
.d07c	a5 14		lda $14				lda 	zTemp3
.d07e	9d 2a 04	sta $042a,x			sta 	Tim_SR,x
.d081	e8		inx				inx
.d082	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d084	d0 ec		bne $d072			bne 	_TIM_URLoop
.d086	4c b0 ce	jmp $ceb0			jmp 	TIM_NewCommand
.d089					_TIMURFail:
.d089	4c a9 ce	jmp $cea9			jmp 	TIM_Error
.d08c					TIM_LoadMemory:
.d08c	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; target address => zTemp2
.d08f	a5 14		lda $14				lda 	zTemp3
.d091	85 12		sta $12				sta 	zTemp2
.d093	a5 15		lda $15				lda 	zTemp3+1
.d095	85 13		sta $13				sta 	zTemp2+1
.d097					_TIM_LMLoop:
.d097	20 d8 cf	jsr $cfd8			jsr 	TIM_GetHex 					; next byte ?
.d09a	b0 0e		bcs $d0aa			bcs 	_TIMLMDone 					; no more
.d09c	a2 00		ldx #$00			ldx 	#0							; write out.
.d09e	a5 14		lda $14				lda 	zTemp3
.d0a0	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d0a2	e6 12		inc $12				inc 	zTemp2 						; bump address
.d0a4	d0 f1		bne $d097			bne 	_TIM_LMLoop
.d0a6	e6 13		inc $13				inc 	zTemp2+1
.d0a8	80 ed		bra $d097			bra 	_TIM_LMLoop
.d0aa					_TIMLMDone:
.d0aa	4c b0 ce	jmp $ceb0			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d0ad	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	f2 c1						.word 	StartROM
>fffe	23 d0					.word TIM_BreakVector

;******  End of listing
