
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 29 21:25:39 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN.
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.
=2					SMark_While 	= 	2 							; 2 is WHILE/WEND.
=3					SMark_If 		= 	3 							; 3 is IF/ENDIF

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a8					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b0					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b8					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b9					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bb					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bd					Tim_SR:		.byte ? 						; Processor Status
>03be					Tim_A:		.byte ? 						; Processor Registers
>03bf					Tim_X:		.byte ?
>03c0					Tim_Y:		.byte ?
>03c1					Tim_Z:		.byte ?
>03c2					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	18 0a 00 ff 14 74 68 69			.byte	$18,$0a,$00,$ff,$14,$74,$68,$69
>8008	73 20 69 73 20 61 20 63			.byte	$73,$20,$69,$73,$20,$61,$20,$63
>8010	6f 6d 6d 65 6e 74 2e 00			.byte	$6f,$6d,$6d,$65,$6e,$74,$2e,$00
>8018	0d 14 00 ca 4f 68 c0 ca			.byte	$0d,$14,$00,$ca,$4f,$68,$c0,$ca
>8020	4f 68 c0 c4 00 0e e8 03			.byte	$4f,$68,$c0,$c4,$00,$0e,$e8,$03
>8028	d6 fe 09 48 65 6c 6c 6f			.byte	$d6,$fe,$09,$48,$65,$6c,$6c,$6f
>8030	20 21 00 07 f2 03 18 84			.byte	$20,$21,$00,$07,$f2,$03,$18,$84
>8038	42 00 08 fc 03 90 18 88			.byte	$42,$00,$08,$fc,$03,$90,$18,$88
>8040	40 00 07 06 04 19 84 40			.byte	$40,$00,$07,$06,$04,$19,$84,$40
>8048	00 05 10 04 91 00 08 1a			.byte	$00,$05,$10,$04,$91,$00,$08,$1a
>8050	04 8f 18 84 42 00 14 24			.byte	$04,$8f,$18,$84,$42,$00,$14,$24
>8058	04 d6 fe 0e 49 74 73 20			.byte	$04,$d6,$fe,$0e,$49,$74,$73,$20
>8060	32 20 21 20 20 20 20 20			.byte	$32,$20,$21,$20,$20,$20,$20,$20
>8068	c1 00 05 2e 04 de 00 14			.byte	$c1,$00,$05,$2e,$04,$de,$00,$14
>8070	38 04 d6 fe 0e 49 74 73			.byte	$38,$04,$d6,$fe,$0e,$49,$74,$73
>8078	20 6e 6f 74 20 32 20 21			.byte	$20,$6e,$6f,$74,$20,$32,$20,$21
>8080	20 c1 00 05 42 04 94 00			.byte	$20,$c1,$00,$05,$42,$04,$94,$00
>8088	0e 4c 04 d6 18 c1 19 c0			.byte	$0e,$4c,$04,$d6,$18,$c1,$19,$c0
>8090	19 84 19 8a 41 00 0e 56			.byte	$19,$84,$19,$8a,$41,$00,$0e,$56
>8098	04 96 19 84 43 c0 18 84			.byte	$04,$96,$19,$84,$43,$c0,$18,$84
>80a0	18 8b 41 00 05 60 04 95			.byte	$18,$8b,$41,$00,$05,$60,$04,$95
>80a8	00 0b 6a 04 d6 fe 06 45			.byte	$00,$0b,$6a,$04,$d6,$fe,$06,$45
>80b0	6e 64 2e 00 05 74 04 cb			.byte	$6e,$64,$2e,$00,$05,$74,$04,$cb
>80b8	00 00					.byte	$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c ff b0	jmp $b0ff		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 05	sta $0500			sta 	IFT_XCursor
.a071	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a074	ad 01 05	lda $0501			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 05	sta $0500			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 05	inc $0500			inc 	IFT_XCursor
.a150	ad 00 05	lda $0500			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 05	dec $0501			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 05	sta $0501			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 05	inc $0501			inc 	IFT_YCursor
.a168	ad 01 05	lda $0501			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 05	lda $0501			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 05	inc $0500			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae c2 03	ldx $03c2			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad bd 03	lda $03bd			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad be 03	lda $03be			lda 	TIM_A 						; restore AXYZ
.ab9f	ae bf 03	ldx $03bf			ldx 	TIM_X
.aba2	ac c0 03	ldy $03c0			ldy 	TIM_Y
.aba5	ab c1 03	ldz $03c1			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d bc 03	sta $03bc			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d bb 03	sta $03bb			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd b9 03	lda $03b9,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d be 03	sta $03be			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e bf 03	stx $03bf			stx 	TIM_X
.acaa	8c c0 03	sty $03c0			sty 	TIM_Y
.acad	9c c1 03	stz $03c1			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d bd 03	sta $03bd			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d ba 03	sta $03ba			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d b9 03	sta $03b9			sta 	TIM_PC 						; high byte
.acbc	ad ba 03	lda $03ba			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce b9 03	dec $03b9			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce ba 03	dec $03ba			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e c2 03	stx $03c2			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d ba 03	sta $03ba			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d b9 03	sta $03b9			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d bd 03	sta $03bd,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.ad1d					StructureSearchSingle:
.ad1d	a2 00		ldx #$00			ldx 	#0
.ad1f					StructureSearchDouble:
.ad1f	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.ad21	86 11		stx $11				stx 	zTemp1+1
.ad23	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.ad25	85 12		sta $12				sta 	zTemp2
.ad27	80 1a		bra $ad43			bra 	_SSWLoop 					; jump in, start scanning from here.
.ad29					_SSWNextLine:
.ad29	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ad2b	ea		nop				nop
.ad2c	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ad2e	18		clc				clc
.ad2f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ad31	85 16		sta $16				sta 	zCodePtr
.ad33	90 02		bcc $ad37			bcc 	_SNLNoCarry
.ad35	e6 17		inc $17				inc 	zCodePtr+1
.ad37					_SNLNoCarry:
.ad37	a3 00		ldz #$00			ldz 	#0
.ad39	ea		nop				nop
.ad3a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad3c	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.ad3e	f0 57		beq $ad97			beq 	_SSWFail
.ad40	1b		inz				inz
.ad41	1b		inz				inz
.ad42					_SSWNextSimple:
.ad42	1b		inz				inz
.ad43					_SSWLoop:
.ad43	ea		nop				nop
.ad44	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ad46	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.ad48	f0 df		beq $ad29			beq 	_SSWNextLine 				; if so, then next line
.ad4a	10 f6		bpl $ad42			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.ad4c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.ad4e	d0 08		bne $ad58			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.ad50	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.ad52	f0 2f		beq $ad83			beq 	_SSWFound 					; so exit.
.ad54	c5 11		cmp $11				cmp 	zTemp1+1
.ad56	f0 2b		beq $ad83			beq 	_SSWFound
.ad58					_SSWCheckUpDown:
.ad58	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.ad5a	90 10		bcc $ad6c			bcc 	_SSWNext
.ad5c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.ad5e	90 08		bcc $ad68			bcc 	_SSWPlus
.ad60	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.ad62	b0 08		bcs $ad6c			bcs 	_SSWNext
.ad64	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.ad66	c6 12		dec $12				dec 	zTemp2
.ad68					_SSWPlus:
.ad68	e6 12		inc $12				inc 	zTemp2
.ad6a	30 18		bmi $ad84			bmi 	_SSWUnder					; error if driven -ve
.ad6c					_SSWNext:
.ad6c	ea		nop				nop
.ad6d	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.ad6f	1b		inz				inz 								; skip
.ad70	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ad72	90 0d		bcc $ad81			bcc 	_SEDone 					; so just skip over it.
.ad74	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ad76	90 08		bcc $ad80			bcc 	_SEDouble
.ad78	6b		tza				tza 								; this is Y + 1
.ad79	18		clc				clc
.ad7a	ea		nop				nop
.ad7b	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.ad7d	4b		taz				taz 								; back in Y.
.ad7e	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ad7f	3b		dez				dez
.ad80					_SEDouble:
.ad80	1b		inz				inz
.ad81					_SEDone:
.ad81	80 c0		bra $ad43			bra 	_SSWLoop
.ad83					_SSWFound:
.ad83	60		rts				rts
.ad84					_SSWUnder:
.ad84	20 79 ae	jsr $ae79			jsr ERR_Handler
>ad87	53 74 72 75 63 74 75 72			.text "Structure order",0
>ad8f	65 20 6f 72 64 65 72 00
.ad97					_SSWFail:
.ad97	20 79 ae	jsr $ae79			jsr ERR_Handler
>ad9a	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>ada2	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.adaf					StackReset:
.adaf	48		pha				pha
.adb0	5a		phy				phy
.adb1	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.adb3	85 26		sta $26				sta 	zBasicSP
.adb5	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.adb7	85 27		sta $27				sta 	zBasicSP+1
.adb9	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.adbb	98		tya				tya 								; be a legal token.
.adbc	91 26		sta ($26),y			sta 	(zBasicSP),y
.adbe	7a		ply				ply
.adbf	68		pla				pla
.adc0	60		rts				rts
.adc1					StackPushFrame:
.adc1	48		pha				pha
.adc2	5a		phy				phy
.adc3	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.adc4	48		pha				pha 								; save it.
.adc5	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.adc7	18		clc				clc 								; add to Basic Stack
.adc8	65 26		adc $26				adc 	zBasicSP
.adca	85 26		sta $26				sta 	zBasicSP
.adcc	90 02		bcc $add0			bcc 	_SPFNoBump
.adce	e6 27		inc $27				inc 	zBasicSP+1
.add0					_SPFNoBump:
.add0	a0 00		ldy #$00			ldy 	#0
.add2	68		pla				pla
.add3	91 26		sta ($26),y			sta 	(zBasicSP),y
.add5	7a		ply				ply
.add6	68		pla				pla
.add7	60		rts				rts
.add8					StackPopFrame:
.add8	48		pha				pha
.add9	5a		phy				phy
.adda	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.addc	51 26		eor ($26),y			eor 	(zBasicSP),y
.adde	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ade0	d0 12		bne $adf4			bne 	_SPFError 					; mixed structures
.ade2	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.ade4	29 0f		and #$0f			and 	#$0F
.ade6	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ade8	38		sec				sec
.ade9	65 26		adc $26				adc 	zBasicSP
.adeb	85 26		sta $26				sta 	zBasicSP
.aded	b0 02		bcs $adf1			bcs 	_SPFNoBump
.adef	c6 27		dec $27				dec 	zBasicSP+1
.adf1					_SPFNoBump:
.adf1	7a		ply				ply
.adf2	68		pla				pla
.adf3	60		rts				rts
.adf4					_SPFError:
.adf4	20 79 ae	jsr $ae79			jsr ERR_Handler
>adf7	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>adff	72 75 63 74 75 72 65 73 00
.ae08					StackSavePosition:
.ae08	6b		tza				tza
.ae09	5a		phy				phy
.ae0a	a0 05		ldy #$05			ldy 	#5
.ae0c	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae0e	a0 01		ldy #$01			ldy 	#1
.ae10	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ae12	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae14	c8		iny				iny
.ae15	a5 17		lda $17				lda 	zCodePtr+1
.ae17	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae19	c8		iny				iny
.ae1a	a5 18		lda $18				lda 	zCodePtr+2
.ae1c	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae1e	c8		iny				iny
.ae1f	a5 19		lda $19				lda 	zCodePtr+3
.ae21	91 26		sta ($26),y			sta 	(zBasicSP),y
.ae23	7a		ply				ply
.ae24	60		rts				rts
.ae25					StackRestorePosition:
.ae25	5a		phy				phy
.ae26	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ae28	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae2a	85 16		sta $16				sta 	zCodePtr+0
.ae2c	c8		iny				iny
.ae2d	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae2f	85 17		sta $17				sta 	zCodePtr+1
.ae31	c8		iny				iny
.ae32	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae34	85 18		sta $18				sta 	zCodePtr+2
.ae36	c8		iny				iny
.ae37	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ae39	85 19		sta $19				sta 	zCodePtr+3
.ae3b	c8		iny				iny
.ae3c	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.ae3e	7a		ply				ply 								; restore Y
.ae3f	4b		taz				taz
.ae40	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.ae41					CharPrint:
.ae41	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.ae44					CharGet:
.ae44	4c 06 a2	jmp $a206			jmp 	IF_GetKey
.ae47					CheckBreak:
.ae47	4c f1 a1	jmp $a1f1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ae4a					SyntaxError:
.ae4a	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ae4d	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ae55	72 72 6f 72 00
.ae5a					TypeError:
.ae5a	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ae5d	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ae65	70 65 00
.ae68					BadParamError:
.ae68	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ae6b	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ae73	6d 65 74 65 72 00
.ae79					ERR_Handler:
.ae79	a3 00		ldz #$00			ldz 	#0
.ae7b	1b		inz				inz
.ae7c	ea		nop				nop
.ae7d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae7f	85 80		sta $80				sta 	XS_Mantissa
.ae81	1b		inz				inz
.ae82	ea		nop				nop
.ae83	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae85	85 81		sta $81				sta 	XS_Mantissa+1
.ae87	fa		plx				plx 								; address in XY
.ae88	7a		ply				ply
.ae89	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ae8a	d0 01		bne $ae8d			bne 	_EHNoSkip
.ae8c	c8		iny				iny
.ae8d					_EHNoSkip:
.ae8d	20 ac ae	jsr $aeac			jsr 	PrintROMMessage 			; print message from ROM.
.ae90	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.ae92	05 81		ora $81				ora 	XS_Mantissa+1
.ae94	f0 0c		beq $aea2			beq 	_EHNoLine
.ae96	a2 a7		ldx #$a7			ldx 	#_EHAt & $FF 				; print " at "
.ae98	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.ae9a	20 ac ae	jsr $aeac			jsr 	PrintROMMessage
.ae9d	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ae9f	20 bd ae	jsr $aebd			jsr 	Print16BitInteger
.aea2					_EHNoLine:
.aea2	80 fe		bra $aea2			bra 	_EHNoLine
.aea4	4c 28 b1	jmp $b128			jmp 	WarmStart
>aea7	20 61 74 20 00			_EHAt:	.text 	" at ",0
.aeac					PrintROMMessage:
.aeac	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.aeae	84 1b		sty $1b				sty 	zLTemp1+1
.aeb0	a0 00		ldy #$00			ldy 	#0
.aeb2					_PRMLoop:
.aeb2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.aeb4	f0 06		beq $aebc			beq		_PRMExit
.aeb6	c8		iny				iny
.aeb7	20 41 ae	jsr $ae41			jsr 	CharPrint
.aeba	80 f6		bra $aeb2			bra 	_PRMLoop
.aebc					_PRMExit:
.aebc	60		rts				rts
.aebd					Print16BitInteger:
.aebd	a9 00		lda #$00			lda 	#0 							; make 32 bit
.aebf	85 82		sta $82				sta 	XS_Mantissa+2
.aec1	85 83		sta $83				sta 	XS_Mantissa+3
.aec3					Print32BitInteger:
.aec3	a9 00		lda #$00			lda 	#0
.aec5	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.aec8	aa		tax				tax 								; convert bottom level.
.aec9	20 d5 c3	jsr $c3d5			jsr 	INTToString 				; make string
.aecc	a2 00		ldx #$00			ldx 	#0 							; print buffer
.aece	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.aed1	f0 06		beq $aed9			beq 	_P1Exit
.aed3	20 41 ae	jsr $ae41			jsr 	CharPrint
.aed6	e8		inx				inx
.aed7	80 f5		bra $aece			bra 	_P1Loop
.aed9	8a		txa		_P1Exit:txa 								; return chars printed.
.aeda	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.aedb					VectorTable:
>aedb	38 b8					.word BinaryOp_And         & $FFFF ; $80 and
>aedd	54 b8					.word BinaryOp_Or          & $FFFF ; $81 or
>aedf	70 b8					.word BinaryOp_Xor         & $FFFF ; $82 xor
>aee1	70 b8					.word BinaryOp_Eor         & $FFFF ; $83 eor
>aee3	a7 b8					.word Binary_Equal         & $FFFF ; $84 =
>aee5	c1 b8					.word Binary_NotEqual      & $FFFF ; $85 <>
>aee7	ca b8					.word Binary_Less          & $FFFF ; $86 <
>aee9	d3 b8					.word Binary_LessEqual     & $FFFF ; $87 <=
>aeeb	e5 b8					.word Binary_Greater       & $FFFF ; $88 >
>aeed	dc b8					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>aeef	6a b9					.word BinaryOp_Add         & $FFFF ; $8a +
>aef1	86 b9					.word BinaryOp_Subtract    & $FFFF ; $8b -
>aef3	97 b9					.word BinaryOp_Multiply    & $FFFF ; $8c *
>aef5	a8 b9					.word BinaryOp_Divide      & $FFFF ; $8d /
>aef7	99 af					.word NotImplemented       & $FFFF ; $8e ^
>aef9	71 b2					.word Command_IF           & $FFFF ; $8f if
>aefb	2d b6					.word Command_WHILE        & $FFFF ; $90 while
>aefd	55 b6					.word Command_REPEAT       & $FFFF ; $91 repeat
>aeff	99 af					.word NotImplemented       & $FFFF ; $92 for
>af01	99 af					.word NotImplemented       & $FFFF ; $93 then
>af03	d4 b2					.word Command_ENDIF        & $FFFF ; $94 endif
>af05	4a b6					.word Command_WEND         & $FFFF ; $95 wend
>af07	5e b6					.word Command_UNTIL        & $FFFF ; $96 until
>af09	99 af					.word NotImplemented       & $FFFF ; $97 next
>af0b	99 af					.word NotImplemented       & $FFFF ; $98 not
>af0d	99 af					.word NotImplemented       & $FFFF ; $99 fn(
>af0f	ad ba					.word Unary_Abs            & $FFFF ; $9a abs(
>af11	ed bb					.word Unary_Asc            & $FFFF ; $9b asc(
>af13	c0 ca					.word Unary_Int            & $FFFF ; $9c int(
>af15	c7 ba					.word Unary_Peek           & $FFFF ; $9d peek(
>af17	41 ca					.word Unary_Rnd            & $FFFF ; $9e rnd(
>af19	2e bb					.word Unary_Usr            & $FFFF ; $9f usr(
>af1b	2c bc					.word Unary_Left           & $FFFF ; $a0 left$(
>af1d	41 bc					.word Unary_Right          & $FFFF ; $a1 right$(
>af1f	13 bc					.word Unary_Mid            & $FFFF ; $a2 mid$(
>af21	8a bd					.word Unary_Spc            & $FFFF ; $a3 spc(
>af23	bb bb					.word Unary_Str            & $FFFF ; $a4 str$(
>af25	4f bb					.word Unary_Val            & $FFFF ; $a5 val(
>af27	04 bc					.word Unary_Len            & $FFFF ; $a6 len(
>af29	b9 bc					.word Unary_Hex            & $FFFF ; $a7 hex$(
>af2b	99 af					.word NotImplemented       & $FFFF ; $a8 sin(
>af2d	99 af					.word NotImplemented       & $FFFF ; $a9 cos(
>af2f	99 af					.word NotImplemented       & $FFFF ; $aa tan(
>af31	99 af					.word NotImplemented       & $FFFF ; $ab atn(
>af33	99 af					.word NotImplemented       & $FFFF ; $ac exp(
>af35	99 af					.word NotImplemented       & $FFFF ; $ad log(
>af37	99 af					.word NotImplemented       & $FFFF ; $ae sqr(
>af39	0f bd					.word Unary_Dec            & $FFFF ; $af dec(
>af3b	cb ba					.word Unary_Deek           & $FFFF ; $b0 deek(
>af3d	cf ba					.word Unary_Leek           & $FFFF ; $b1 leek(
>af3f	fb ba					.word Unary_Mod            & $FFFF ; $b2 mod(
>af41	67 ba					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>af43	6c bd					.word Unary_Chr            & $FFFF ; $b4 chr$(
>af45	99 af					.word NotImplemented       & $FFFF ; $b5 pos(
>af47	99 af					.word NotImplemented       & $FFFF ; $b6 tab(
>af49	99 af					.word NotImplemented       & $FFFF ; $b7 $
>af4b	99 af					.word NotImplemented       & $FFFF ; $b8 $(
>af4d	99 af					.word NotImplemented       & $FFFF ; $b9 #
>af4f	99 af					.word NotImplemented       & $FFFF ; $ba #(
>af51	99 af					.word NotImplemented       & $FFFF ; $bb %
>af53	99 af					.word NotImplemented       & $FFFF ; $bc %(
>af55	99 af					.word NotImplemented       & $FFFF ; $bd (
>af57	99 af					.word NotImplemented       & $FFFF ; $be )
>af59	99 af					.word NotImplemented       & $FFFF ; $bf ,
>af5b	4a b2					.word Command_COLON        & $FFFF ; $c0 :
>af5d	99 af					.word NotImplemented       & $FFFF ; $c1 ;
>af5f	99 af					.word NotImplemented       & $FFFF ; $c2 def
>af61	11 b6					.word Command_CLR          & $FFFF ; $c3 clr
>af63	25 b6					.word Command_STOP         & $FFFF ; $c4 stop
>af65	99 af					.word NotImplemented       & $FFFF ; $c5 data
>af67	99 af					.word NotImplemented       & $FFFF ; $c6 read
>af69	2d b1					.word Command_DIM          & $FFFF ; $c7 dim
>af6b	99 af					.word NotImplemented       & $FFFF ; $c8 to
>af6d	99 af					.word NotImplemented       & $FFFF ; $c9 step
>af6f	87 b5					.word Command_GOSUB        & $FFFF ; $ca gosub
>af71	95 b5					.word Command_RETURN       & $FFFF ; $cb return
>af73	81 b5					.word Command_GOTO         & $FFFF ; $cc goto
>af75	6c b2					.word Command_END          & $FFFF ; $cd end
>af77	99 af					.word NotImplemented       & $FFFF ; $ce input
>af79	4b b2					.word Command_LET          & $FFFF ; $cf let
>af7b	da b2					.word Command_LIST         & $FFFF ; $d0 list
>af7d	23 b5					.word Command_NEW          & $FFFF ; $d1 new
>af7f	42 b5					.word Command_OLD          & $FFFF ; $d2 old
>af81	99 af					.word NotImplemented       & $FFFF ; $d3 on
>af83	99 af					.word NotImplemented       & $FFFF ; $d4 restore
>af85	f2 b4					.word Command_POKE         & $FFFF ; $d5 poke
>af87	69 b4					.word Command_PRINT        & $FFFF ; $d6 print
>af89	b7 b1					.word Command_RUN          & $FFFF ; $d7 run
>af8b	99 af					.word NotImplemented       & $FFFF ; $d8 wait
>af8d	99 af					.word NotImplemented       & $FFFF ; $d9 sys
>af8f	f6 b4					.word Command_DOKE         & $FFFF ; $da doke
>af91	fa b4					.word Command_LOKE         & $FFFF ; $db loke
>af93	da b4					.word Command_ASSERT       & $FFFF ; $dc assert
>af95	99 af					.word NotImplemented       & $FFFF ; $dd get
>af97	ce b2					.word Command_ELSE         & $FFFF ; $de else
.af99					NotImplemented:
.af99	20 79 ae	jsr $ae79			jsr ERR_Handler
>af9c	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>afa4	65 6d 65 6e 74 65 64 00
.afac					BinaryPrecedence:
>afac	01					.byte 1    ; $80 and
>afad	01					.byte 1    ; $81 or
>afae	01					.byte 1    ; $82 xor
>afaf	01					.byte 1    ; $83 eor
>afb0	02					.byte 2    ; $84 =
>afb1	02					.byte 2    ; $85 <>
>afb2	02					.byte 2    ; $86 <
>afb3	02					.byte 2    ; $87 <=
>afb4	02					.byte 2    ; $88 >
>afb5	02					.byte 2    ; $89 >=
>afb6	03					.byte 3    ; $8a +
>afb7	03					.byte 3    ; $8b -
>afb8	04					.byte 4    ; $8c *
>afb9	04					.byte 4    ; $8d /
>afba	05					.byte 5    ; $8e ^
.afbb					KeywordText:
>afbb	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>afbe	4f d2					.byte $4f,$d2                          ; $81 or
>afc0	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>afc3	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>afc6	bd					.byte $bd                              ; $84 =
>afc7	3c be					.byte $3c,$be                          ; $85 <>
>afc9	bc					.byte $bc                              ; $86 <
>afca	3c bd					.byte $3c,$bd                          ; $87 <=
>afcc	be					.byte $be                              ; $88 >
>afcd	3e bd					.byte $3e,$bd                          ; $89 >=
>afcf	ab					.byte $ab                              ; $8a +
>afd0	ad					.byte $ad                              ; $8b -
>afd1	aa					.byte $aa                              ; $8c *
>afd2	af					.byte $af                              ; $8d /
>afd3	de					.byte $de                              ; $8e ^
>afd4	49 c6					.byte $49,$c6                          ; $8f if
>afd6	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>afdb	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>afe1	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>afe4	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>afe8	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>afed	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>aff1	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>aff6	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>affa	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>affd	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>b000	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>b004	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>b008	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>b00c	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>b011	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>b015	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>b019	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>b01f	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>b026	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>b02b	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>b02f	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>b034	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>b038	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>b03c	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>b041	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>b045	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>b049	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>b04d	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>b051	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>b055	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>b059	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>b05d	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>b061	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>b066	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>b06b	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>b06f	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>b073	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>b078	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>b07c	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>b080	a4					.byte $a4                              ; $b7 $
>b081	24 a8					.byte $24,$a8                          ; $b8 $(
>b083	a3					.byte $a3                              ; $b9 #
>b084	23 a8					.byte $23,$a8                          ; $ba #(
>b086	a5					.byte $a5                              ; $bb %
>b087	25 a8					.byte $25,$a8                          ; $bc %(
>b089	a8					.byte $a8                              ; $bd (
>b08a	a9					.byte $a9                              ; $be )
>b08b	ac					.byte $ac                              ; $bf ,
>b08c	ba					.byte $ba                              ; $c0 :
>b08d	bb					.byte $bb                              ; $c1 ;
>b08e	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>b091	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>b094	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b098	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b09c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b0a0	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b0a3	54 cf					.byte $54,$cf                          ; $c8 to
>b0a5	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b0a9	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b0ae	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b0b4	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b0b8	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b0bb	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b0c0	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b0c3	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b0c7	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b0ca	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b0cd	4f ce					.byte $4f,$ce                          ; $d3 on
>b0cf	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b0d6	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b0da	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b0df	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b0e2	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b0e6	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b0e9	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b0ed	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b0f1	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b0f7	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b0fa	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>b0fe	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.b0ff					BASIC_Start:
.b0ff	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.b102	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b105	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b107	8d 10 03	sta $0310			sta 	LocalVector
.b10a	8d 0c 03	sta $030c			sta 	UserVector
.b10d	a9 3d		lda #$3d			lda 	#USRDefault & $FF 			; reset USR vector
.b10f	8d 0d 03	sta $030d			sta 	UserVector+1
.b112	a9 bb		lda #$bb			lda 	#(USRDefault >> 8) & $FF
.b114	8d 0e 03	sta $030e			sta 	UserVector+2
.b117	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b119	8d 0f 03	sta $030f			sta 	UserVector+3
.b11c	20 ea bd	jsr $bdea			jsr 	UpdateProgramEnd 			; update the program end.
.b11f	20 11 b6	jsr $b611			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b122	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b124	9a		txs				txs
.b125	4c b7 b1	jmp $b1b7			jmp 	COMMAND_Run
.b128					WarmStart:
.b128	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b12a	9a		txs				txs
.b12b	80 fb		bra $b128			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b12d					Command_DIM:
.b12d	6b		tza				tza
.b12e	48		pha				pha 								; push on stack.
.b12f	20 5c bf	jsr $bf5c			jsr 	VariableExtract 			; get the identifier
.b132	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b135	29 01		and #$01			and 	#1
.b137	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b139	d0 6e		bne $b1a9			bne 	_CDIError
.b13b	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b13d	8d b8 03	sta $03b8			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b140					_CDIGetDimension:
.b140	ad b8 03	lda $03b8			lda 	UsrArrayIdx 				; done too many ?
.b143	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b145	f0 62		beq $b1a9			beq 	_CDIError
.b147	20 19 b8	jsr $b819			jsr 	EvaluateInteger 			; evaluate an index size
.b14a	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b14c	29 80		and #$80			and 	#$80
.b14e	05 82		ora $82				ora 	XS_Mantissa+2
.b150	05 83		ora $83				ora 	XS_Mantissa+3
.b152	d0 55		bne $b1a9			bne 	_CDIError
.b154	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy into the array table.
.b157	18		clc				clc 								; add 1 - max index => size.
.b158	a5 80		lda $80				lda 	XS_Mantissa+0
.b15a	69 01		adc #$01			adc 	#1
.b15c	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+0,x
.b15f	a5 81		lda $81				lda 	XS_Mantissa+1
.b161	69 00		adc #$00			adc 	#0
.b163	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+1,x
.b166	30 41		bmi $b1a9			bmi 	_CDIError 					; could be dim a(32767)
.b168	e8		inx				inx 								; bump index.
.b169	e8		inx				inx
.b16a	8e b8 03	stx $03b8			stx 	UsrArrayIdx
.b16d	ea		nop				nop
.b16e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b170	1b		inz				inz
.b171	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b173	f0 cb		beq $b140			beq 	_CDIGetDimension
.b175	3b		dez				dez
.b176	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; closing ) present ?
.b179	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy USR array to default
.b17c	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b17e	9d a9 03	sta $03a9,x			sta 	ArrayDef+1,x
.b181					_CDICopy:
.b181	bd b0 03	lda $03b0,x			lda 	UsrArrayDef,x
.b184	9d a8 03	sta $03a8,x			sta 	ArrayDef,x
.b187	ca		dex				dex
.b188	10 f7		bpl $b181			bpl 	_CDICopy
.b18a	68		pla				pla									; position of array identifier
.b18b	85 10		sta $10				sta 	zTemp1
.b18d	6b		tza				tza
.b18e	48		pha				pha
.b18f	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b191	4b		taz				taz
.b192	20 5c bf	jsr $bf5c			jsr 	VariableExtract 			; get the identifier
.b195	20 f7 c1	jsr $c1f7			jsr 	VariableLocate 				; check if it exists already.
.b198	b0 0f		bcs $b1a9			bcs 	_CDIError
.b19a	20 ea bf	jsr $bfea			jsr 	VariableCreate 				; create it using the current ArrayDef
.b19d	68		pla				pla 								; restore code position
.b19e	4b		taz				taz
.b19f	ea		nop				nop
.b1a0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1a2	1b		inz				inz
.b1a3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b1a5	f0 86		beq $b12d			beq 	Command_DIM
.b1a7	3b		dez				dez
.b1a8	60		rts				rts
.b1a9					_CDIError:
.b1a9	20 79 ae	jsr $ae79			jsr ERR_Handler
>b1ac	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b1b4					_CDISyntax:
.b1b4	4c 4a ae	jmp $ae4a			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b1b7					Command_RUN:
.b1b7	20 11 b6	jsr $b611			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b1ba	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b1bc	85 16		sta $16				sta 	zCodePtr+0
.b1be	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b1c0	85 17		sta $17				sta 	zCodePtr+1
.b1c2	a9 02		lda #$02			lda 	#2
.b1c4	85 18		sta $18				sta 	zCodePtr+2
.b1c6	a9 00		lda #$00			lda 	#0
.b1c8	85 19		sta $19				sta 	zCodePtr+3
.b1ca	a3 03		ldz #$03			ldz 	#3
.b1cc					RUN_NewLine:
.b1cc	a3 00		ldz #$00			ldz 	#0
.b1ce	ea		nop				nop
.b1cf	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1d1	1b		inz				inz
.b1d2	1b		inz				inz
.b1d3	1b		inz				inz
.b1d4	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b1d6	d0 18		bne $b1f0			bne 	RUN_NextCommand
.b1d8	4c 6c b2	jmp $b26c			jmp 	Command_END 				; go do the command code.
.b1db					RUN_Skip:
.b1db	ea		nop				nop
.b1dc	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b1de	1b		inz				inz 								; skip
.b1df	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b1e1	90 0d		bcc $b1f0			bcc 	_SEDone 					; so just skip over it.
.b1e3	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b1e5	90 08		bcc $b1ef			bcc 	_SEDouble
.b1e7	6b		tza				tza 								; this is Y + 1
.b1e8	18		clc				clc
.b1e9	ea		nop				nop
.b1ea	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b1ec	4b		taz				taz 								; back in Y.
.b1ed	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b1ee	3b		dez				dez
.b1ef					_SEDouble:
.b1ef	1b		inz				inz
.b1f0					_SEDone:
.b1f0					RUN_NextCommand:
.b1f0	ad a7 03	lda $03a7			lda 	BreakCount 					; break counter
.b1f3	69 10		adc #$10			adc 	#16 						; one time in 16
.b1f5	8d a7 03	sta $03a7			sta 	BreakCount
.b1f8	90 0a		bcc $b204			bcc 	RUN_NoCheckBreak
.b1fa	20 47 ae	jsr $ae47			jsr 	CheckBreak 					; check for break
.b1fd	c9 00		cmp #$00			cmp 	#0
.b1ff	f0 03		beq $b204			beq 	RUN_NoCheckBreak
.b201	4c 25 b6	jmp $b625			jmp 	Command_STOP 				; stop on BREAK.
.b204					RUN_NoCheckBreak:
.b204	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b206	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b208	ea		nop				nop
.b209	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b20b	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b20d	f0 cc		beq $b1db			beq 	RUN_Skip
.b20f	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b211	d0 10		bne $b223			bne 	RUN_Execute
.b213					RUN_NextLine:
.b213	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b215	ea		nop				nop
.b216	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b218	18		clc				clc
.b219	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b21b	85 16		sta $16				sta 	zCodePtr
.b21d	90 02		bcc $b221			bcc 	_SNLNoCarry
.b21f	e6 17		inc $17				inc 	zCodePtr+1
.b221					_SNLNoCarry:
.b221	80 a9		bra $b1cc			bra 	RUN_NewLine 				; go do the new line code
.b223					RUN_Execute:
.b223	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b225	b0 1c		bcs $b243			bcs 	RUN_Extension
.b227	1b		inz				inz
.b228	0a		asl a				asl 	a 							; double the character read.
.b229	90 12		bcc $b23d			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b22b	aa		tax				tax 								; ready to look up.
.b22c	bd db ae	lda $aedb,x			lda 	VectorTable,x 				; copy address into LocalVector
.b22f	8d 11 03	sta $0311			sta 	LocalVector+1
.b232	bd dc ae	lda $aedc,x			lda 	VectorTable+1,x
.b235	8d 12 03	sta $0312			sta 	LocalVector+2
.b238	20 62 b7	jsr $b762			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b23b	80 b3		bra $b1f0			bra 	RUN_NextCommand 			; do the next command.
.b23d					RUN_Default:
.b23d	3b		dez				dez
.b23e	20 4b b2	jsr $b24b			jsr 	Command_LET 				; and try LET.
.b241	80 ad		bra $b1f0			bra 	RUN_NextCommand
.b243					RUN_Extension:
.b243	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b245	f0 94		beq $b1db			beq 	RUN_Skip 					; skip over it.
.b247	4c 4a ae	jmp $ae4a			jmp 	SyntaxError
.b24a					Command_COLON:
.b24a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b24b					Command_LET:
.b24b	20 f1 be	jsr $bef1			jsr 	VariableFind 				; get reference to one variable.
.b24e	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b250	20 33 be	jsr $be33			jsr 	CheckNextToken
.b253	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b255	48		pha				pha
.b256	a5 23		lda $23				lda 	zVarDataPtr+1
.b258	48		pha				pha
.b259	a5 24		lda $24				lda 	zVarType
.b25b	48		pha				pha
.b25c	20 7c b6	jsr $b67c			jsr 	EvaluateExpression 			; evaluate the RHS.
.b25f	68		pla				pla 								; restore target variable information.
.b260	85 24		sta $24				sta 	zVarType
.b262	68		pla				pla
.b263	85 23		sta $23				sta 	zVarDataPtr+1
.b265	68		pla				pla
.b266	85 22		sta $22				sta 	zVarDataPtr
.b268	20 8c c2	jsr $c28c			jsr 	VariableSet 				; set the value out.
.b26b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b26c					Command_END:
.b26c	80 fe		bra $b26c	_halt:	bra 		_halt
.b26e	4c 28 b1	jmp $b128			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.b271					Command_IF:
.b271	20 19 b8	jsr $b819			jsr 	EvaluateInteger 			; check success.
.b274	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b276	05 81		ora $81				ora 	XS_Mantissa+1
.b278	05 82		ora $82				ora 	XS_Mantissa+2
.b27a	05 83		ora $83				ora 	XS_Mantissa+3
.b27c	aa		tax				tax 								; put into X.
.b27d	ea		nop				nop
.b27e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b280	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.b282	d0 30		bne $b2b4			bne 	_FIFExtended
.b284	1b		inz				inz
.b285	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.b287	f0 0c		beq $b295			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.b289	ea		nop				nop
.b28a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b28c	29 c0		and #$c0			and 	#$C0 						; is it a number
.b28e	c9 40		cmp #$40			cmp 	#$40
.b290	d0 21		bne $b2b3			bne 	_FIFContinue 				; if not, do what ever follows.
.b292	4c 81 b5	jmp $b581			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.b295					_FIFEndOfLine:
.b295	ea		nop				nop
.b296	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b298	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.b29a	f0 17		beq $b2b3			beq 	_FIFContinue
.b29c	ea		nop				nop
.b29d	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b29f	1b		inz				inz 								; skip
.b2a0	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b2a2	90 0d		bcc $b2b1			bcc 	_SEDone 					; so just skip over it.
.b2a4	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b2a6	90 08		bcc $b2b0			bcc 	_SEDouble
.b2a8	6b		tza				tza 								; this is Y + 1
.b2a9	18		clc				clc
.b2aa	ea		nop				nop
.b2ab	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b2ad	4b		taz				taz 								; back in Y.
.b2ae	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b2af	3b		dez				dez
.b2b0					_SEDouble:
.b2b0	1b		inz				inz
.b2b1					_SEDone:
.b2b1	80 e2		bra $b295			bra 	_FIFEndOfLine
.b2b3					_FIFContinue:
.b2b3	60		rts				rts
.b2b4					_FIFExtended:
.b2b4	da		phx				phx 								; save result
.b2b5	a9 30		lda #$30			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.b2b7	20 c1 ad	jsr $adc1			jsr 	StackPushFrame
.b2ba	68		pla				pla 								; restore result
.b2bb	f0 01		beq $b2be			beq 	_FIXSkip 					; if zero then it has failed.
.b2bd	60		rts				rts 								; test passed, so continue executing
.b2be					_FIXSkip:
.b2be	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.b2c0	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.b2c2	20 1f ad	jsr $ad1f			jsr 	StructureSearchDouble
.b2c5	ea		nop				nop
.b2c6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2c8	1b		inz				inz
.b2c9	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.b2cb	f0 07		beq $b2d4			beq 	Command_ENDIF
.b2cd	60		rts				rts
.b2ce					Command_ELSE:
.b2ce	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.b2d0	20 1d ad	jsr $ad1d			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.b2d3	1b		inz				inz
.b2d4					Command_ENDIF:
.b2d4	a9 30		lda #$30			lda 	#(SMark_If << 4)
.b2d6	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b2d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b2da					Command_LIST:
.b2da	20 fd b3	jsr $b3fd			jsr 	ListGetRange				; get any parameters
.b2dd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b2df	85 16		sta $16				sta 	zCodePtr+0
.b2e1	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b2e3	85 17		sta $17				sta 	zCodePtr+1
.b2e5	a9 02		lda #$02			lda 	#2
.b2e7	85 18		sta $18				sta 	zCodePtr+2
.b2e9	a9 00		lda #$00			lda 	#0
.b2eb	85 19		sta $19				sta 	zCodePtr+3
.b2ed	a3 03		ldz #$03			ldz 	#3
.b2ef					_CILLoop:
.b2ef	a3 00		ldz #$00			ldz 	#0
.b2f1	ea		nop				nop
.b2f2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2f4	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b2f6	f0 24		beq $b31c			beq 	_CILExit
.b2f8	20 47 ae	jsr $ae47			jsr 	CheckBreak 					; check break
.b2fb	c9 00		cmp #$00			cmp 	#0
.b2fd	d0 1d		bne $b31c			bne 	_CILExit
.b2ff	20 47 b4	jsr $b447			jsr 	ListCheckRange 				; check current line in range.
.b302	b0 08		bcs $b30c			bcs		_CILNext
.b304	a3 00		ldz #$00			ldz 	#0
.b306	1b		inz				inz
.b307	1b		inz				inz
.b308	1b		inz				inz
.b309	20 1f b3	jsr $b31f			jsr 	ListLine 					; list one line.
.b30c					_CILNext:
.b30c	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b30e	ea		nop				nop
.b30f	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b311	18		clc				clc
.b312	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b314	85 16		sta $16				sta 	zCodePtr
.b316	90 02		bcc $b31a			bcc 	_SNLNoCarry
.b318	e6 17		inc $17				inc 	zCodePtr+1
.b31a					_SNLNoCarry:
.b31a	80 d3		bra $b2ef			bra 	_CILLoop
.b31c					_CILExit:
.b31c	4c 28 b1	jmp $b128			jmp 	WarmStart
.b31f					ListLine:
.b31f	a3 00		ldz #$00			ldz 	#0
.b321	1b		inz				inz
.b322	ea		nop				nop
.b323	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b325	85 80		sta $80				sta 	XS_Mantissa
.b327	1b		inz				inz
.b328	ea		nop				nop
.b329	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b32b	85 81		sta $81				sta 	XS_Mantissa+1
.b32d	20 bd ae	jsr $aebd			jsr 	Print16BitInteger 			; print integer.
.b330	aa		tax				tax 								; print spaces to column 6
.b331					_LISpace:
.b331	a9 20		lda #$20			lda 	#" "
.b333	20 41 ae	jsr $ae41			jsr 	CharPrint
.b336	e8		inx				inx
.b337	e0 06		cpx #$06			cpx 	#6
.b339	d0 f6		bne $b331			bne 	_LISpace
.b33b					_LIDecode:
.b33b	1b		inz				inz
.b33c	ea		nop				nop
.b33d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b33f	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b341	f0 0f		beq $b352			beq 	_LIExit
.b343	30 12		bmi $b357			bmi 	_LIToken
.b345	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b347	b0 52		bcs $b39b			bcs 	_LIInteger
.b349	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b34b	69 20		adc #$20			adc 	#$20
.b34d	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC 				; print in LC
.b350	80 e9		bra $b33b			bra 	_LIDecode
.b352					_LIExit:
.b352	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b354	4c 41 ae	jmp $ae41			jmp 	CharPrint
.b357					_LIToken:
.b357	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b359	90 4b		bcc $b3a6			bcc		_LICommandToken
.b35b	48		pha				pha 								; save in case end
.b35c	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b35e	c9 fe		cmp #$fe			cmp 	#$FE
.b360	f0 17		beq $b379			beq 	_LIPrint
.b362	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b364	c9 fd		cmp #$fd			cmp 	#$FD
.b366	f0 11		beq $b379			beq 	_LIPrint
.b368	a9 52		lda #$52			lda 	#'R'						; must be REM
.b36a	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b36d	a9 45		lda #$45			lda 	#'E'
.b36f	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b372	a9 4d		lda #$4d			lda 	#'M'
.b374	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b377	a2 20		ldx #$20			ldx 	#' '
.b379					_LIPrint:
.b379	8a		txa				txa
.b37a	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b37d	1b		inz				inz
.b37e	ea		nop				nop
.b37f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b381	aa		tax				tax 								; put in X
.b382	ca		dex				dex
.b383					_LILoop:
.b383	ca		dex				dex 								; exit when count reached zero.
.b384	f0 09		beq $b38f			beq 	_LIEnd
.b386	1b		inz				inz
.b387	ea		nop				nop
.b388	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b38a	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b38d	80 f4		bra $b383			bra 	_LILoop
.b38f	68		pla		_LIEnd:	pla 								; get A back
.b390	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b392	d0 a7		bne $b33b			bne 	_LIDecode
.b394	a9 22		lda #$22			lda 	#'"'
.b396	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b399	80 a0		bra $b33b			bra 	_LIDecode
.b39b					_LIInteger:
.b39b	a2 00		ldx #$00			ldx 	#0
.b39d	20 87 b7	jsr $b787			jsr 	EvaluateGetInteger 			; get an atom
.b3a0	3b		dez				dez
.b3a1	20 c3 ae	jsr $aec3			jsr 	Print32BitInteger 			; print integer.
.b3a4	80 95		bra $b33b			bra 	_LIDecode
.b3a6					_LICommandToken:
.b3a6	5a		phy				phy 								; save Y
.b3a7	48		pha				pha 								; save token
.b3a8	a2 bb		ldx #$bb			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b3aa	a9 af		lda #$af			lda 	(#KeywordText >> 8) & $FF
.b3ac	86 1a		stx $1a				stx 	zLTemp1
.b3ae	85 1b		sta $1b				sta 	zLTemp1+1
.b3b0	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b3b2	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b3b4	68		pla				pla 								; get token, chuck bit 7.
.b3b5	29 7f		and #$7f			and 	#127
.b3b7	f0 16		beq $b3cf			beq 	_LIFoundToken
.b3b9	aa		tax				tax
.b3ba					_LITokenLoop:
.b3ba	a0 00		ldy #$00			ldy 	#0
.b3bc					_LIFindEnd:
.b3bc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b3be	c8		iny				iny
.b3bf	0a		asl a				asl 	a
.b3c0	90 fa		bcc $b3bc			bcc 	_LIFindEnd
.b3c2	98		tya				tya 								; that is step to the next
.b3c3	18		clc				clc 								; we don't bother bumping the 3rd byte
.b3c4	65 1a		adc $1a				adc 	zLTemp1 					; here.
.b3c6	85 1a		sta $1a				sta 	zLTemp1
.b3c8	90 02		bcc $b3cc			bcc 	_LINoBump
.b3ca	e6 1b		inc $1b				inc 	zLTemp1+1
.b3cc					_LINoBump:
.b3cc	ca		dex				dex 								; no go round again.
.b3cd	d0 eb		bne $b3ba			bne 	_LITokenLoop
.b3cf					_LIFoundToken:
.b3cf	a0 00		ldy #$00			ldy 	#0
.b3d1					_LIPrintToken:
.b3d1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b3d3	c8		iny				iny
.b3d4	48		pha				pha 								; save it
.b3d5	29 7f		and #$7f			and 	#$7F
.b3d7	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b3da	68		pla				pla
.b3db	10 f4		bpl $b3d1			bpl 	_LIPrintToken 				; go back if not end
.b3dd	7a		ply				ply 								; restore Y
.b3de	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b3e0	c9 41		cmp #$41			cmp 	#"A"
.b3e2	90 09		bcc $b3ed			bcc 	_LINotLetter
.b3e4	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b3e6	b0 05		bcs $b3ed			bcs 	_LINotLetter
.b3e8	a9 20		lda #$20			lda 	#" " 						; add spacing
.b3ea	20 f0 b3	jsr $b3f0			jsr 	ListPrintLC
.b3ed					_LINotLetter:
.b3ed	4c 3b b3	jmp $b33b			jmp 	_LIDecode
.b3f0					ListPrintLC:
.b3f0	c9 41		cmp #$41			cmp 	#"A"
.b3f2	90 06		bcc $b3fa			bcc 	_LPLC0
.b3f4	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b3f6	b0 02		bcs $b3fa			bcs 	_LPLC0
.b3f8	69 20		adc #$20			adc 	#$20
.b3fa	4c 41 ae	jmp $ae41	_LPLC0:	jmp 	CharPrint
.b3fd					ListGetRange:
.b3fd	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.b3ff					_LGRClear:
.b3ff	a9 00		lda #$00			lda 	#0
.b401	95 80		sta $80,x			sta 	XS_Mantissa,x
.b403	ca		dex				dex
.b404	10 f9		bpl $b3ff			bpl 	_LGRClear
.b406	ea		nop				nop
.b407	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b409	c9 00		cmp #$00			cmp 	#0 							; nothing
.b40b	f0 22		beq $b42f			beq 	_LGRBlank
.b40d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.b40f	f0 1e		beq $b42f			beq 	_LGRBlank
.b411	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.b413	f0 19		beq $b42e			beq 	_LGREnd 					; then it's LIST ,x
.b415	20 19 b8	jsr $b819			jsr 	EvaluateInteger 			; get the first number into bottom
.b418	ea		nop				nop
.b419	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b41b	c9 bf		cmp #$bf			cmp 	#token_Comma
.b41d	f0 0f		beq $b42e			beq 	_LGREnd 					; then it is LIST a,b
.b41f	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.b421	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.b423	a5 81		lda $81				lda 	XS_Mantissa+1
.b425	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b427					_LGRBumpExit:
.b427	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.b429	d0 02		bne $b42d			bne 	_LGRBump2
.b42b	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.b42d					_LGRBump2:
.b42d	60		rts				rts
.b42e					_LGREnd:
.b42e	1b		inz				inz
.b42f					_LGRBlank:
.b42f	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.b431	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.b433	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b435	ea		nop				nop
.b436	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b438	c9 00		cmp #$00			cmp 	#0
.b43a	f0 f1		beq $b42d			beq 	_LGRBump2
.b43c	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.b43d	b0 ee		bcs $b42d			bcs 	_LGRBump2
.b43f	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.b441	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX
.b444	80 e1		bra $b427			bra 	_LGRBumpExit
.b446	60		rts				rts
.b447					ListCheckRange:
.b447	1b		inz				inz
.b448	a2 00		ldx #$00			ldx 	#0 							; test low
.b44a	20 57 b4	jsr $b457			jsr 	_LCRCompare
.b44d	90 06		bcc $b455			bcc 	_LCRFail
.b44f	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.b451	20 57 b4	jsr $b457			jsr 	_LCRCompare
.b454	60		rts				rts
.b455					_LCRFail:
.b455	38		sec				sec
.b456	60		rts				rts
.b457					_LCRCompare:
.b457	ea		nop				nop
.b458	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b45a	38		sec				sec
.b45b	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.b45d	08		php				php
.b45e	1b		inz				inz
.b45f	ea		nop				nop
.b460	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b462	28		plp				plp
.b463	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.b465	08		php				php
.b466	3b		dez				dez
.b467	28		plp				plp
.b468	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b469					Command_PRINT:
.b469	ea		nop				nop
.b46a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b46c	c9 00		cmp #$00			cmp 	#0 							; end
.b46e	f0 66		beq $b4d6			beq 	_CPR_NewLine
.b470	c9 c0		cmp #$c0			cmp 	#token_Colon
.b472	f0 62		beq $b4d6			beq 	_CPR_NewLine
.b474	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b476	f0 50		beq $b4c8			beq 	_CPR_Skip
.b478	c9 bf		cmp #$bf			cmp 	#token_Comma
.b47a	f0 49		beq $b4c5			beq 	_CPR_Tab
.b47c	20 7c b6	jsr $b67c			jsr 	EvaluateExpression 			; get expression.
.b47f	a5 85		lda $85				lda 	XS_Type 					; get type.
.b481	29 02		and #$02			and 	#2
.b483	d0 24		bne $b4a9			bne 	_CPR_String 				; if type = 2 output as string.
.b485					_CPR_Number:
.b485	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b487	8d 14 03	sta $0314			sta 	NumBufX
.b48a	a5 85		lda $85				lda 	XS_Type 					; get type
.b48c	4a		lsr a				lsr 	a
.b48d	b0 05		bcs $b494			bcs 	_CPRInt 					; if msb set do as integer
.b48f	20 0c c9	jsr $c90c			jsr 	FPToString 					; call fp to str otherwise
.b492	80 03		bra $b497			bra 	_CPRNPrint
.b494	20 d5 c3	jsr $c3d5	_CPRInt:jsr 	IntToString
.b497					_CPRNPrint:
.b497	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b49a	c9 2d		cmp #$2d			cmp 	#"-"
.b49c	f0 05		beq $b4a3			beq 	_CPRNoSpace
.b49e	a9 20		lda #$20			lda 	#" "						; print the leading space
.b4a0	20 41 ae	jsr $ae41			jsr 	CharPrint 					; so beloved of MS Basics.
.b4a3					_CPRNoSpace:
.b4a3	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b4a5	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b4a7	80 04		bra $b4ad			bra 	_CPRPrint
.b4a9					_CPR_String:
.b4a9	a6 80		ldx $80				ldx 	XS_Mantissa
.b4ab	a5 81		lda $81				lda 	XS_Mantissa+1
.b4ad					_CPRPrint:
.b4ad	86 1e		stx $1e				stx 	zGenPtr
.b4af	85 1f		sta $1f				sta 	zGenPtr+1
.b4b1	5a		phy				phy
.b4b2	a0 00		ldy #$00			ldy 	#0							; get length into X
.b4b4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b4b6	aa		tax				tax
.b4b7	f0 09		beq $b4c2			beq 	_CPREndPrint 				; nothing to print
.b4b9					_CPRLoop:
.b4b9	c8		iny				iny
.b4ba	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b4bc	20 41 ae	jsr $ae41			jsr 	CharPrint
.b4bf	ca		dex				dex
.b4c0	d0 f7		bne $b4b9			bne 	_CPRLoop
.b4c2					_CPREndPrint:
.b4c2	7a		ply				ply
.b4c3	80 a4		bra $b469			bra 	Command_Print
.b4c5					_CPR_Tab:
.b4c5	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b4c8					_CPR_Skip:
.b4c8	1b		inz				inz
.b4c9	ea		nop				nop
.b4ca	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b4cc	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b4ce	f0 09		beq $b4d9			beq 	_CPR_Exit
.b4d0	c9 00		cmp #$00			cmp 	#0
.b4d2	d0 95		bne $b469			bne 	Command_PRINT 				; if not go round again.
.b4d4	80 03		bra $b4d9			bra 	_CPR_Exit
.b4d6					_CPR_NewLine:
.b4d6	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b4d9					_CPR_Exit:
.b4d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b4da					Command_ASSERT:
.b4da	20 19 b8	jsr $b819			jsr 	EvaluateInteger 			; calculate thing being asserted
.b4dd	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b4df	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b4e1	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b4e3	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b4e5	f0 01		beq $b4e8			beq 	_ASFail
.b4e7	60		rts				rts
.b4e8					_ASFail:
.b4e8	20 79 ae	jsr $ae79			jsr ERR_Handler
>b4eb	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.b4f2					Command_POKE:
.b4f2	a9 01		lda #$01			lda 	#1
.b4f4	80 06		bra $b4fc			bra 	CmdPoke_Main
.b4f6					Command_DOKE:
.b4f6	a9 02		lda #$02			lda 	#2
.b4f8	80 02		bra $b4fc			bra 	CmdPoke_Main
.b4fa					Command_LOKE:
.b4fa	a9 04		lda #$04			lda 	#4
.b4fc					CmdPoke_Main:
.b4fc	48		pha				pha
.b4fd	20 19 b8	jsr $b819			jsr 	EvaluateInteger 			; get two parameters.
.b500	e8		inx				inx
.b501	e8		inx				inx
.b502	e8		inx				inx
.b503	e8		inx				inx
.b504	e8		inx				inx
.b505	e8		inx				inx
.b506	20 54 be	jsr $be54			jsr 	CheckNextComma
.b509	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX
.b50c	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.b50e	85 1a		sta $1a				sta 	zLTemp1
.b510	a5 81		lda $81				lda 	XS_Mantissa+1
.b512	85 1b		sta $1b				sta 	zLTemp1+1
.b514	a5 82		lda $82				lda 	XS_Mantissa+2
.b516	85 1c		sta $1c				sta 	zLTemp1+2
.b518	a5 83		lda $83				lda 	XS_Mantissa+3
.b51a	85 1d		sta $1d				sta 	zLTemp1+3
.b51c	68		pla				pla 								; get count
.b51d	5a		phy				phy 								; save Y
.b51e	20 d6 bd	jsr $bdd6			jsr 	MemWrite 					; write it out
.b521	7a		ply				ply 								; restore Y and done.
.b522	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.b523					Command_NEW:
.b523	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b525	85 16		sta $16				sta 	zCodePtr+0
.b527	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b529	85 17		sta $17				sta 	zCodePtr+1
.b52b	a9 02		lda #$02			lda 	#2
.b52d	85 18		sta $18				sta 	zCodePtr+2
.b52f	a9 00		lda #$00			lda 	#0
.b531	85 19		sta $19				sta 	zCodePtr+3
.b533	a3 03		ldz #$03			ldz 	#3
.b535	a3 00		ldz #$00			ldz 	#0
.b537	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.b539	ea		nop				nop
.b53a	92 16		sta ($16),z			sta 	(zCodePtr),z
.b53c	20 ea bd	jsr $bdea			jsr 	UpdateProgramEnd 			; update program end.
.b53f	4c 28 b1	jmp $b128			jmp 	WarmStart
.b542					Command_OLD:
.b542	ea		nop				nop
.b543	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b545	85 16		sta $16				sta 	zCodePtr+0
.b547	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b549	85 17		sta $17				sta 	zCodePtr+1
.b54b	a9 02		lda #$02			lda 	#2
.b54d	85 18		sta $18				sta 	zCodePtr+2
.b54f	a9 00		lda #$00			lda 	#0
.b551	85 19		sta $19				sta 	zCodePtr+3
.b553	a3 03		ldz #$03			ldz 	#3
.b555					_COL_Find:
.b555	ea		nop				nop
.b556	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b558	1b		inz				inz
.b559	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.b55b	f0 18		beq $b575			beq 	_COL_Found
.b55d	6b		tza				tza
.b55e	c9 00		cmp #$00			cmp 	#0
.b560	d0 f3		bne $b555			bne 	_COL_Find 					; can't find old EOL, give up.
.b562	20 79 ae	jsr $ae79			jsr ERR_Handler
>b565	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>b56d	43 6f 72 72 75 70 74 00
.b575					_COL_Found:
.b575	6b		tza				tza
.b576	48		pha				pha
.b577	a3 00		ldz #$00			ldz 	#0
.b579	68		pla				pla
.b57a	ea		nop				nop
.b57b	92 16		sta ($16),z			sta 	(zCodePtr),z
.b57d	20 ea bd	jsr $bdea			jsr 	UpdateProgramEnd 			; reset variable pointer
.b580	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b581					Command_GOTO:
.b581	20 9e b5	jsr $b59e			jsr 	GotoGetLineNumber
.b584	4c bb b5	jmp $b5bb			jmp 	GotoChangeToLineNumber
.b587					Command_GOSUB:
.b587	20 9e b5	jsr $b59e			jsr 	GotoGetLineNumber
.b58a	20 08 ae	jsr $ae08			jsr 	StackSavePosition
.b58d	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.b58f	20 c1 ad	jsr $adc1			jsr 	StackPushFrame
.b592	4c bb b5	jmp $b5bb			jmp 	GotoChangeToLineNumber
.b595					Command_RETURN:
.b595	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.b597	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b59a	20 25 ae	jsr $ae25			jsr 	StackRestorePosition
.b59d	60		rts				rts
.b59e					GotoGetLineNumber:
.b59e	20 19 b8	jsr $b819			jsr 	EvaluateInteger
.b5a1	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b5a3	05 83		ora $83				ora 	XS_Mantissa+3
.b5a5	d0 01		bne $b5a8			bne 	_GLINError
.b5a7	60		rts				rts
.b5a8					_GLINError:
.b5a8	20 79 ae	jsr $ae79			jsr ERR_Handler
>b5ab	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b5b3	20 4e 75 6d 62 65 72 00
.b5bb					GotoChangeToLineNumber:
.b5bb	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.b5bd	05 81		ora $81				ora 	XS_Mantissa+1
.b5bf	f0 3d		beq $b5fe			beq 	_GCTLFail
.b5c1	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b5c3	85 16		sta $16				sta 	zCodePtr+0
.b5c5	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b5c7	85 17		sta $17				sta 	zCodePtr+1
.b5c9	a9 02		lda #$02			lda 	#2
.b5cb	85 18		sta $18				sta 	zCodePtr+2
.b5cd	a9 00		lda #$00			lda 	#0
.b5cf	85 19		sta $19				sta 	zCodePtr+3
.b5d1	a3 03		ldz #$03			ldz 	#3
.b5d3					_GCTLLoop:
.b5d3	a3 00		ldz #$00			ldz 	#0
.b5d5	ea		nop				nop
.b5d6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5d8	c9 00		cmp #$00			cmp 	#0
.b5da	f0 22		beq $b5fe			beq 	_GCTLFail
.b5dc	1b		inz				inz
.b5dd	ea		nop				nop
.b5de	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5e0	c5 80		cmp $80				cmp 	XS_Mantissa+0
.b5e2	d0 08		bne $b5ec			bne 	_GCTLNext
.b5e4	1b		inz				inz
.b5e5	ea		nop				nop
.b5e6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b5e8	c5 81		cmp $81				cmp 	XS_Mantissa+1
.b5ea	f0 10		beq $b5fc			beq 	_GCTLExit
.b5ec					_GCTLNext:
.b5ec	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b5ee	ea		nop				nop
.b5ef	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b5f1	18		clc				clc
.b5f2	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b5f4	85 16		sta $16				sta 	zCodePtr
.b5f6	90 02		bcc $b5fa			bcc 	_SNLNoCarry
.b5f8	e6 17		inc $17				inc 	zCodePtr+1
.b5fa					_SNLNoCarry:
.b5fa	80 d7		bra $b5d3			bra 	_GCTLLoop 					; try next line.
.b5fc					_GCTLExit:
.b5fc	1b		inz				inz
.b5fd	60		rts				rts
.b5fe					_GCTLFail:
.b5fe	20 79 ae	jsr $ae79			jsr ERR_Handler
>b601	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b609	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b611					Command_CLR:
.b611					ResetRunStatus:
.b611	20 2d bf	jsr $bf2d			jsr 	VariableClear
.b614	20 af ad	jsr $adaf			jsr 	StackReset
.b617	a9 00		lda #$00			lda 	#HighMemory & $FF
.b619	8d 00 03	sta $0300			sta 	StringPtr
.b61c	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.b61e	8d 01 03	sta $0301			sta 	StringPtr+1
.b621	20 f9 c0	jsr $c0f9			jsr 	ArrayResetDefault
.b624	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b625					Command_STOP:
.b625	20 79 ae	jsr $ae79			jsr ERR_Handler
>b628	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.b62d					Command_WHILE:
.b62d	20 08 ae	jsr $ae08			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.b630	20 19 b8	jsr $b819			jsr 	EvaluateInteger 			; calculate the while loop value.
.b633	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b635	05 81		ora $81				ora 	XS_Mantissa+1
.b637	05 82		ora $82				ora 	XS_Mantissa+2
.b639	05 83		ora $83				ora 	XS_Mantissa+3
.b63b	f0 06		beq $b643			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.b63d	a9 25		lda #$25			lda 	#(SMark_While << 4)+SourcePosSize
.b63f	20 c1 ad	jsr $adc1			jsr 	StackPushFrame 				; push on stack
.b642	60		rts				rts
.b643					_CWHSkip:
.b643	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.b645	20 1d ad	jsr $ad1d			jsr 	StructureSearchSingle
.b648	1b		inz				inz
.b649	60		rts				rts
.b64a					Command_WEND:
.b64a	a9 20		lda #$20			lda 	#(SMark_While << 4)			; remove the frame
.b64c	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b64f	20 25 ae	jsr $ae25			jsr 	StackRestorePosition
.b652	80 d9		bra $b62d			bra 	Command_WHILE 				; and do the while again.
.b654	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.b655					Command_REPEAT:
.b655	20 08 ae	jsr $ae08			jsr 	StackSavePosition			; save position into stack
.b658	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b65a	20 c1 ad	jsr $adc1			jsr 	StackPushFrame 				; push on stack
.b65d	60		rts				rts
.b65e					Command_UNTIL:
.b65e	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.b660	20 d8 ad	jsr $add8			jsr 	StackPopFrame
.b663	20 19 b8	jsr $b819			jsr 	EvaluateInteger				; work out UNTIL
.b666	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.b668	05 81		ora $81				ora 	XS_Mantissa+1
.b66a	05 82		ora $82				ora 	XS_Mantissa+2
.b66c	05 83		ora $83				ora 	XS_Mantissa+3
.b66e	d0 08		bne $b678			bne 	_CUTExit 					; if not, just exit
.b670	20 25 ae	jsr $ae25			jsr 	StackRestorePosition 		; otherwise loop round again.
.b673	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b675	20 c1 ad	jsr $adc1			jsr 	StackPushFrame 				; fix the stack back.
.b678					_CUTExit:
.b678	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b679					EVESyntax:
.b679	4c 4a ae	jmp $ae4a			jmp 	SyntaxError
.b67c					EvaluateExpression:
.b67c	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b67e					EvaluateExpressionX:
.b67e	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b680					EvaluateExpressionXA:
.b680	48		pha				pha 								; save precedence on stack.
.b681	ea		nop				nop
.b682	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b684	f0 f3		beq $b679			beq 	EVESyntax 					; end of line, syntax error.
.b686	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b688	b0 03		bcs $b68d			bcs 	_EVNotVariable
.b68a	4c 59 b7	jmp $b759			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b68d					_EVNotVariable:
.b68d	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b68f	90 e8		bcc $b679			bcc 	EVESyntax
.b691	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b693	b0 59		bcs $b6ee			bcs 	_EVNotInteger
.b695	20 87 b7	jsr $b787			jsr 	EvaluateGetInteger
.b698					_EVCheckDecimal:
.b698	ea		nop				nop
.b699	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b69b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b69d	d0 05		bne $b6a4			bne 	_EVGotAtom 					; no, get atom.
.b69f					_EVIsDecimal:
.b69f	20 af b7	jsr $b7af			jsr 	EVGetDecimal 				; extend to the decimal part.
.b6a2	80 00		bra $b6a4			bra 	_EVGotAtom 					; and continue to got atom.
.b6a4					_EVGotAtom:
.b6a4	ea		nop				nop
.b6a5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6a7	10 43		bpl $b6ec			bpl 	_EVExitDrop 				; must be a token.
.b6a9	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b6ab	b0 3f		bcs $b6ec			bcs 	_EVExitDrop
.b6ad	68		pla				pla 								; get current precedence
.b6ae	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b6b0	da		phx				phx 								; save X
.b6b1	ea		nop				nop
.b6b2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6b4	aa		tax				tax 								; put in X
.b6b5	bd 2c af	lda $af2c,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b6b8	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b6ba	fa		plx				plx 								; restore X
.b6bb	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b6bd	90 2e		bcc $b6ed			bcc 	_EVExit 					; exit if too low.
.b6bf	f0 2c		beq $b6ed			beq 	_EVExit 					; exit if equals
.b6c1	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b6c3	48		pha				pha
.b6c4	ea		nop				nop
.b6c5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b6c7	48		pha				pha
.b6c8	1b		inz				inz
.b6c9	da		phx				phx 								; save current position
.b6ca	e8		inx				inx
.b6cb	e8		inx				inx
.b6cc	e8		inx				inx
.b6cd	e8		inx				inx
.b6ce	e8		inx				inx
.b6cf	e8		inx				inx
.b6d0	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b6d2	20 80 b6	jsr $b680			jsr 	EvaluateExpressionXA 		; do the RHS.
.b6d5	fa		plx				plx 								; restore X
.b6d6	68		pla				pla 								; get the binary operator in A.
.b6d7					_EVCallA:
.b6d7	da		phx				phx 								; save X again
.b6d8	0a		asl a				asl 	a 							; double, lose the MSB.
.b6d9	aa		tax				tax									; put in X
.b6da	bd db ae	lda $aedb,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b6dd	8d 11 03	sta $0311			sta 	LocalVector+1
.b6e0	bd dc ae	lda $aedc,x			lda 	VectorTable+1,x
.b6e3	8d 12 03	sta $0312			sta 	LocalVector+2
.b6e6	fa		plx				plx 								; restore X
.b6e7	20 62 b7	jsr $b762			jsr 	EVCallLocalVector
.b6ea	80 b8		bra $b6a4			bra 	_EVGotAtom 					; and loop back.
.b6ec					_EVExitDrop:
.b6ec	68		pla				pla
.b6ed					_EVExit:
.b6ed	60		rts				rts
.b6ee					_EVNotInteger:
.b6ee	1b		inz				inz
.b6ef	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b6f1	d0 16		bne $b709			bne 	_EVNotMinus
.b6f3	20 fa b7	jsr $b7fa			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b6f6	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b6f8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b6fa	f0 05		beq $b701			beq 	_EVMinusFloat
.b6fc	20 b8 c3	jsr $c3b8			jsr 	IntegerNegateAlways 		; negation
.b6ff	80 a3		bra $b6a4			bra 	_EVGotAtom 					; and go back.
.b701					_EVMinusFloat:
.b701	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.b703	49 80		eor #$80			eor 	#$80
.b705	95 85		sta $85,x			sta 	XS_Type,x
.b707	80 9b		bra $b6a4			bra 	_EVGotAtom
.b709					_EVNotMinus:
.b709	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b70b	d0 18		bne $b725			bne 	_EVNotParenthesis
.b70d	20 7e b6	jsr $b67e			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b710	ea		nop				nop
.b711	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b713	1b		inz				inz
.b714	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b716	f0 8c		beq $b6a4			beq 	_EVGotAtom
.b718	20 79 ae	jsr $ae79			jsr ERR_Handler
>b71b	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b723	29 00
.b725					_EVNotParenthesis:
.b725	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b727	d0 0c		bne $b735			bne 	_EVNotNot
.b729	20 fa b7	jsr $b7fa			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b72c	20 0d c8	jsr $c80d			jsr 	FPUToInteger 				; make it an integer - if possible.
.b72f	20 df b7	jsr $b7df			jsr 	NotInteger 					; do the not calculation
.b732	4c a4 b6	jmp $b6a4			jmp 	_EVGotAtom
.b735					_EVNotNot:
.b735	c9 fe		cmp #$fe			cmp 	#$FE
.b737	d0 12		bne $b74b			bne 	_EVNotString
.b739	20 c8 be	jsr $bec8			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b73c	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b73e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b740	a5 21		lda $21				lda 	zTempStr+1
.b742	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b744	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b746	95 85		sta $85,x			sta 	XS_Type,x
.b748	4c a4 b6	jmp $b6a4			jmp 	_EVGotAtom
.b74b					_EVNotString:
.b74b	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b74d	90 04		bcc $b753			bcc 	_EVBadElement
.b74f	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b751	90 03		bcc $b756			bcc 	_EVUnaryFunction
.b753					_EVBadElement:
.b753	4c 4a ae	jmp $ae4a			jmp 	SyntaxError
.b756					_EVUnaryFunction:
.b756	4c d7 b6	jmp $b6d7			jmp 	_EVCallA
.b759					_EVVariableHandler:
.b759	20 f1 be	jsr $bef1			jsr 	VariableFind 				; locate a variable
.b75c	20 3b c2	jsr $c23b			jsr 	VariableGet 				; copy into memory.
.b75f	4c a4 b6	jmp $b6a4			jmp 	_EVGotAtom 					; and go round.
.b762					EVCallLocalVector:
.b762	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.b765					EVShiftMantissaLeft6:
.b765	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b767	95 84		sta $84,x			sta 	XS_Exponent,x
.b769	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b76b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b76d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b76f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b771	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b773	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b775	a9 00		lda #$00			lda 	#0
.b777	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b779	20 7c b7	jsr $b77c			jsr 	_EVSMLShift 					; call it here to do it twice
.b77c					_EVSMLShift:
.b77c	56 84		lsr $84,x			lsr 	XS_Exponent,x
.b77e	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.b780	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.b782	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.b784	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.b786	60		rts				rts
.b787					EvaluateGetInteger:
.b787	ea		nop				nop
.b788	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b78a	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b78c	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b78e	a9 00		lda #$00			lda 	#0
.b790	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b792	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b794	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b796	1a		inc a				inc 	a 							; set to type 1 (integer)
.b797	95 85		sta $85,x			sta 	XS_Type,x
.b799					_EVCheckNextInteger:
.b799	1b		inz				inz
.b79a	ea		nop				nop
.b79b	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b79d	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b79f	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b7a1	b0 0b		bcs $b7ae			bcs 	_EVEndInteger
.b7a3	48		pha				pha 								; save it.
.b7a4	20 65 b7	jsr $b765			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b7a7	68		pla				pla
.b7a8	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b7aa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7ac	80 eb		bra $b799			bra 	_EVCheckNextInteger
.b7ae					_EVEndInteger:
.b7ae	60		rts				rts
.b7af					EVGetDecimal:
.b7af	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b7b1	8d 15 03	sta $0315			sta 	Num_Buffer
.b7b4	da		phx				phx
.b7b5	1b		inz				inz
.b7b6	ea		nop				nop
.b7b7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7b9	1b		inz				inz
.b7ba	3a		dec a				dec 	a								; convert to a string length.
.b7bb	3a		dec a				dec 	a
.b7bc	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b7be					_EVGDCopy:
.b7be	48		pha				pha 									; save count
.b7bf	ea		nop				nop
.b7c0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7c2	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.b7c5	e8		inx				inx 									; forward ....
.b7c6	1b		inz				inz
.b7c7	68		pla				pla 									; get count
.b7c8	3a		dec a				dec 	a 								; until zero
.b7c9	d0 f3		bne $b7be			bne 	_EVGDCopy
.b7cb	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b7ce	fa		plx				plx 									; restore X
.b7cf	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b7d1	85 1e		sta $1e				sta 	zGenPtr
.b7d3	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.b7d5	85 1f		sta $1f				sta 	zGenPtr+1
.b7d7	5a		phy				phy 									; save Y
.b7d8	a0 00		ldy #$00			ldy 	#0 								; start position
.b7da	20 c7 c9	jsr $c9c7			jsr 	FPFromString 					; convert current
.b7dd	7a		ply				ply 									; restore Y
.b7de	60		rts				rts
.b7df					NotInteger:
.b7df	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b7e1	49 ff		eor #$ff			eor 	#$FF
.b7e3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7e5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7e7	49 ff		eor #$ff			eor 	#$FF
.b7e9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7eb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b7ed	49 ff		eor #$ff			eor 	#$FF
.b7ef	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7f1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b7f3	49 ff		eor #$ff			eor 	#$FF
.b7f5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7f7	60		rts				rts
.b7f8					EvaluateGetAtom:
.b7f8	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b7fa					EvaluateGetAtomX:
.b7fa	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b7fc	20 80 b6	jsr $b680			jsr 	EvaluateExpressionXA
.b7ff	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b801	29 0f		and #$0f			and 	#15
.b803	c9 02		cmp #$02			cmp 	#2
.b805	b0 01		bcs $b808			bcs 	EvaluateType
.b807	60		rts				rts
.b808					EvaluateType:
.b808	4c 5a ae	jmp $ae5a			jmp 	TypeError
.b80b					EvaluateNumber:
.b80b	a2 00		ldx #$00			ldx 	#0
.b80d					EvaluateNumberX:
.b80d	20 7e b6	jsr $b67e			jsr 	EvaluateExpressionX
.b810	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.b812	29 0f		and #$0f			and 	#15
.b814	c9 02		cmp #$02			cmp 	#2
.b816	b0 f0		bcs $b808			bcs 	EvaluateType
.b818	60		rts				rts
.b819					EvaluateInteger:
.b819	a2 00		ldx #$00			ldx 	#0
.b81b					EvaluateIntegerX:
.b81b	20 0d b8	jsr $b80d			jsr 	EvaluateNumberX
.b81e	20 0d c8	jsr $c80d			jsr 	FPUToInteger
.b821	60		rts				rts
.b822					EvaluateString:
.b822	a2 00		ldx #$00			ldx 	#0
.b824					EvaluateStringX:
.b824	20 7e b6	jsr $b67e			jsr 	EvaluateExpressionX
.b827	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.b829	29 0f		and #$0f			and 	#15
.b82b	c9 02		cmp #$02			cmp 	#2
.b82d	d0 d9		bne $b808			bne 	EvaluateType
.b82f	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b831	85 1e		sta $1e				sta 	zGenPtr
.b833	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b835	85 1f		sta $1f				sta 	zGenPtr+1
.b837	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b838					BinaryOp_And:
.b838	20 8c b8	jsr $b88c			jsr 	BinaryMakeBothInteger
.b83b	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b83d	35 86		and $86,x			and 	XS2_Mantissa+0,x
.b83f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b841	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b843	35 87		and $87,x			and 	XS2_Mantissa+1,x
.b845	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b847	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b849	35 88		and $88,x			and 	XS2_Mantissa+2,x
.b84b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b84d	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b84f	35 89		and $89,x			and 	XS2_Mantissa+3,x
.b851	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b853	60		rts				rts
.b854					BinaryOp_Or:
.b854	20 8c b8	jsr $b88c			jsr 	BinaryMakeBothInteger
.b857	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b859	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.b85b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b85d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b85f	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.b861	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b863	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b865	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.b867	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b869	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b86b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.b86d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b86f	60		rts				rts
.b870					BinaryOp_Eor:
.b870					BinaryOp_Xor:
.b870	20 8c b8	jsr $b88c			jsr 	BinaryMakeBothInteger
.b873	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b875	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.b877	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b879	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b87b	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.b87d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b87f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b881	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.b883	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b885	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b887	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.b889	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b88b	60		rts				rts
.b88c					BinaryMakeBothInteger:
.b88c	da		phx				phx 								; save X
.b88d	e8		inx				inx
.b88e	e8		inx				inx
.b88f	e8		inx				inx
.b890	e8		inx				inx
.b891	e8		inx				inx
.b892	e8		inx				inx
.b893	20 97 b8	jsr $b897			jsr 	BinaryMakeInteger 			; convert to integer.
.b896	fa		plx				plx 								; restore X and fall through.
.b897					BinaryMakeInteger:
.b897	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b899	29 0f		and #$0f			and 	#15 						; check type zero
.b89b	f0 04		beq $b8a1			beq 	_BMIConvert 				; if float convert to integer.
.b89d	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b89e	90 04		bcc $b8a4			bcc 	_BMIError
.b8a0	60		rts				rts
.b8a1					_BMIConvert:
.b8a1	4c 0d c8	jmp $c80d			jmp 	FPUToInteger 				; convert to integer
.b8a4					_BMIError:
.b8a4	4c 5a ae	jmp $ae5a			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b8a7					Binary_Equal:
.b8a7	20 ee b8	jsr $b8ee			jsr 	CompareValues
.b8aa	09 00		ora #$00			ora 	#0
.b8ac	f0 04		beq $b8b2			beq 	CCTrue
.b8ae	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b8b0	80 02		bra $b8b4			bra 	CCWrite
.b8b2	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b8b4	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b8b6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b8b8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b8ba	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b8bc	a9 01		lda #$01			lda 	#1
.b8be	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.b8c0	60		rts				rts
.b8c1					Binary_NotEqual:
.b8c1	20 ee b8	jsr $b8ee			jsr 	CompareValues
.b8c4	09 00		ora #$00			ora 	#0
.b8c6	f0 e6		beq $b8ae			beq 	CCFalse
.b8c8	80 e8		bra $b8b2			bra 	CCTrue
.b8ca					Binary_Less:
.b8ca	20 ee b8	jsr $b8ee			jsr 	CompareValues
.b8cd	09 00		ora #$00			ora 	#0
.b8cf	30 e1		bmi $b8b2			bmi 	CCTrue
.b8d1	80 db		bra $b8ae			bra 	CCFalse
.b8d3					Binary_LessEqual:
.b8d3	20 ee b8	jsr $b8ee			jsr 	CompareValues
.b8d6	c9 01		cmp #$01			cmp 	#1
.b8d8	d0 d8		bne $b8b2			bne 	CCTrue
.b8da	80 d2		bra $b8ae			bra 	CCFalse
.b8dc					Binary_GreaterEqual:
.b8dc	20 ee b8	jsr $b8ee			jsr 	CompareValues
.b8df	09 00		ora #$00			ora 	#0
.b8e1	10 cf		bpl $b8b2			bpl 	CCTrue
.b8e3	80 c9		bra $b8ae			bra 	CCFalse
.b8e5					Binary_Greater:
.b8e5	20 ee b8	jsr $b8ee			jsr 	CompareValues
.b8e8	c9 01		cmp #$01			cmp 	#1
.b8ea	f0 c6		beq $b8b2			beq 	CCTrue
.b8ec	80 c0		bra $b8ae			bra 	CCFalse
.b8ee					CompareValues:
.b8ee	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.b8f0	35 8b		and $8b,x			and 	XS2_Type,x
.b8f2	c9 02		cmp #$02			cmp 	#2
.b8f4	f0 11		beq $b907			beq 	_CVString
.b8f6	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b8f8	35 8b		and $8b,x			and 	XS2_Type,x
.b8fa	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b8fb	90 03		bcc $b900			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b8fd	4c 49 b9	jmp $b949			jmp 	CompareInteger32 							; so execute code at \1
.b900					_BCFloat:
.b900	20 ed b9	jsr $b9ed			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b903	4c 43 c7	jmp $c743			jmp 	FPCompare 							; and execute code at \2
.b906	60		rts				rts
.b907					_CVString:
.b907	da		phx				phx 								; save XY
.b908	5a		phy				phy
.b909	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b90b	85 1a		sta $1a				sta		zLTemp1+0
.b90d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b90f	85 1b		sta $1b				sta 	zLTemp1+1
.b911	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b913	85 1c		sta $1c				sta 	zLTemp1+2
.b915	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b917	85 1d		sta $1d				sta 	zLTemp1+3
.b919	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b91b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b91d	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b91f	90 02		bcc $b923			bcc 	_CVCommon
.b921	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b923					_CVCommon:
.b923	aa		tax				tax 								; put shorter string length in zero.
.b924	f0 0c		beq $b932			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b926					_CVCompare:
.b926	c8		iny				iny 								; next character
.b927	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b929	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b92b	90 13		bcc $b940			bcc 	_CVReturnLess 				; <
.b92d	d0 15		bne $b944			bne 	_CVReturnGreater 			; >
.b92f	ca		dex				dex 								; until common length matched.
.b930	d0 f4		bne $b926			bne 	_CVCompare
.b932					_CVMatch:
.b932	a0 00		ldy #$00			ldy 	#0
.b934	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b936	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b938	90 06		bcc $b940			bcc 	_CVReturnLess 				; <
.b93a	d0 08		bne $b944			bne 	_CVReturnGreater 			; >
.b93c	a9 00		lda #$00			lda 	#0
.b93e	80 06		bra $b946			bra 	_CVExit 					; same common, same length, same string
.b940					_CVReturnLess:
.b940	a9 ff		lda #$ff			lda 	#$FF
.b942	80 02		bra $b946			bra 	_CVExit
.b944					_CVReturnGreater:
.b944	a9 01		lda #$01			lda 	#$01
.b946					_CVExit:
.b946	7a		ply				ply
.b947	fa		plx				plx
.b948	60		rts				rts
.b949					CompareInteger32:
.b949	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b94b	49 80		eor #$80			eor 	#$80
.b94d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b94f	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.b951	49 80		eor #$80			eor 	#$80
.b953	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.b955	20 d3 b9	jsr $b9d3			jsr 	SubInteger32 				; subtraction
.b958	90 0d		bcc $b967			bcc 	_CI32Less 					; cc return -1
.b95a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.b95c	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b95e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b960	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b962	f0 02		beq $b966			beq 	_CI32Exit
.b964	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b966					_CI32Exit:
.b966	60		rts				rts
.b967					_CI32Less:
.b967	a9 ff		lda #$ff			lda 	#$FF
.b969	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b96a					BinaryOp_Add:
.b96a	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.b96c	35 8b		and $8b,x			and 	XS2_Type,x
.b96e	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b970	d0 11		bne $b983			bne 	_BOAString
.b972	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b974	35 8b		and $8b,x			and 	XS2_Type,x
.b976	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b977	90 03		bcc $b97c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b979	4c b9 b9	jmp $b9b9			jmp 	AddInteger32 							; so execute code at \1
.b97c					_BCFloat:
.b97c	20 ed b9	jsr $b9ed			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b97f	4c 1e c5	jmp $c51e			jmp 	FPAdd 							; and execute code at \2
.b982	60		rts				rts
.b983					_BOAString:
.b983	4c 07 ba	jmp $ba07			jmp 	ConcatenateString 			; concatenate two strings.
.b986					BinaryOp_Subtract:
.b986	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b988	35 8b		and $8b,x			and 	XS2_Type,x
.b98a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b98b	90 03		bcc $b990			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b98d	4c d3 b9	jmp $b9d3			jmp 	SubInteger32 							; so execute code at \1
.b990					_BCFloat:
.b990	20 ed b9	jsr $b9ed			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b993	4c 16 c5	jmp $c516			jmp 	FPSubtract 							; and execute code at \2
.b996	60		rts				rts
.b997					BinaryOp_Multiply:
.b997	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b999	35 8b		and $8b,x			and 	XS2_Type,x
.b99b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b99c	90 03		bcc $b9a1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b99e	4c f3 c2	jmp $c2f3			jmp 	MulInteger32 							; so execute code at \1
.b9a1					_BCFloat:
.b9a1	20 ed b9	jsr $b9ed			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b9a4	4c 45 c6	jmp $c645			jmp 	FPMultiply 							; and execute code at \2
.b9a7	60		rts				rts
.b9a8					BinaryOp_Divide:
.b9a8	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b9aa	35 8b		and $8b,x			and 	XS2_Type,x
.b9ac	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b9ad	90 03		bcc $b9b2			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b9af	4c 31 c3	jmp $c331			jmp 	DivInteger32 							; so execute code at \1
.b9b2					_BCFloat:
.b9b2	20 ed b9	jsr $b9ed			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b9b5	4c d2 c5	jmp $c5d2			jmp 	FPDivide 							; and execute code at \2
.b9b8	60		rts				rts
.b9b9					AddInteger32:
.b9b9	18		clc				clc
.b9ba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b9bc	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.b9be	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b9c0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b9c2	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.b9c4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b9c6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b9c8	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.b9ca	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b9cc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b9ce	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.b9d0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b9d2	60		rts				rts
.b9d3					SubInteger32:
.b9d3	38		sec				sec
.b9d4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b9d6	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.b9d8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b9da	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b9dc	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.b9de	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b9e0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b9e2	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.b9e4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b9e6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b9e8	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.b9ea	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b9ec	60		rts				rts
.b9ed					BinaryMakeBothFloat:
.b9ed	da		phx				phx 								; save X
.b9ee	e8		inx				inx
.b9ef	e8		inx				inx
.b9f0	e8		inx				inx
.b9f1	e8		inx				inx
.b9f2	e8		inx				inx
.b9f3	e8		inx				inx
.b9f4	20 f8 b9	jsr $b9f8			jsr 	BinaryMakeFloat 			; convert to float.
.b9f7	fa		plx				plx 								; restore X and fall through.
.b9f8					BinaryMakeFloat:
.b9f8	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b9fa	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b9fb	b0 04		bcs $ba01			bcs 	_BMFConvert
.b9fd	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b9fe	b0 04		bcs $ba04			bcs 	_BMFError
.ba00	60		rts				rts
.ba01					_BMFConvert:
.ba01	4c c1 c7	jmp $c7c1			jmp 	FPUToFloat 					; convert to float
.ba04					_BMFError:
.ba04	4c 5a ae	jmp $ae5a			jmp 	TypeError
.ba07					ConcatenateString:
.ba07	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.ba09	85 1a		sta $1a				sta		zLTemp1+0
.ba0b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ba0d	85 1b		sta $1b				sta 	zLTemp1+1
.ba0f	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.ba11	85 1c		sta $1c				sta 	zLTemp1+2
.ba13	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.ba15	85 1d		sta $1d				sta 	zLTemp1+3
.ba17	5a		phy				phy
.ba18	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.ba1a	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.ba1c	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.ba1e	7a		ply				ply
.ba1f	b0 33		bcs $ba54			bcs 	_CSError					; check in range.
.ba21	c9 fe		cmp #$fe			cmp 	#maxString+1
.ba23	b0 2f		bcs $ba54			bcs 	_CSError
.ba25	20 8d be	jsr $be8d			jsr 	AllocateTempString 			; store the result
.ba28	20 3f ba	jsr $ba3f			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.ba2b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.ba2d	85 1a		sta $1a				sta 	zLTemp1
.ba2f	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.ba31	85 1b		sta $1b				sta 	zLTemp1+1
.ba33	20 3f ba	jsr $ba3f			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.ba36	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.ba38	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba3a	a5 21		lda $21				lda 	zTempStr+1
.ba3c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba3e	60		rts				rts
.ba3f					_CSCopyString:
.ba3f	da		phx				phx
.ba40	5a		phy				phy
.ba41	a0 00		ldy #$00			ldy 	#0 							; get length
.ba43	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ba45	f0 0a		beq $ba51			beq 	_CSCSExit 					; if zero, exit
.ba47	aa		tax				tax 								; put in X
.ba48					_CSCSLoop:
.ba48	c8		iny				iny 								; get next char
.ba49	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ba4b	20 b8 be	jsr $beb8			jsr		WriteTempString 			; copy out
.ba4e	ca		dex				dex 								; do whole string
.ba4f	d0 f7		bne $ba48			bne 	_CSCSLoop
.ba51					_CSCSExit:
.ba51	7a		ply				ply
.ba52	fa		plx				plx
.ba53	60		rts				rts
.ba54					_CSError:
.ba54	20 79 ae	jsr $ae79			jsr ERR_Handler
>ba57	53 74 72 69 6e 67 20 74			.text "String too long",0
>ba5f	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.ba67					Unary_Sgn:
.ba67	20 0d b8	jsr $b80d			jsr 	EvaluateNumberX 			; get value
.ba6a	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; check right bracket.
.ba6d	20 8b ba	jsr $ba8b			jsr 	GetSignCurrent 				; get sign.
.ba70	09 00		ora #$00			ora 	#0
.ba72	10 08		bpl $ba7c			bpl		UnarySetAInteger			; if 0,1 return that.
.ba74	80 00		bra $ba76			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.ba76					UnarySetAMinus1:
.ba76	a9 ff		lda #$ff			lda 	#$FF
.ba78	95 80		sta $80,x			sta 	XS_Mantissa,x
.ba7a	80 04		bra $ba80			bra 	UnarySetAFill
.ba7c					UnarySetAInteger:
.ba7c	95 80		sta $80,x			sta 	XS_Mantissa,x
.ba7e	a9 00		lda #$00			lda 	#0
.ba80					UnarySetAFill:
.ba80	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba82	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ba84	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ba86	a9 01		lda #$01			lda 	#1
.ba88	95 85		sta $85,x			sta 	XS_Type,x
.ba8a	60		rts				rts
.ba8b					GetSignCurrent:
.ba8b	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.ba8d	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.ba8e	90 15		bcc $baa5			bcc 	_GSCFloat
.ba90	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ba92	30 0e		bmi $baa2			bmi 	_GSCMinus1
.ba94	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.ba96	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.ba98	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ba9a	d0 03		bne $ba9f			bne 	_GSCPlus1
.ba9c					_GSCZero:
.ba9c	a9 00		lda #$00			lda 	#0
.ba9e	60		rts				rts
.ba9f					_GSCPlus1:
.ba9f	a9 01		lda #$01			lda 	#$01
.baa1	60		rts				rts
.baa2					_GSCMinus1:
.baa2	a9 ff		lda #$ff			lda 	#$FF
.baa4	60		rts				rts
.baa5					_GSCFloat:
.baa5	34 85		bit $85,x			bit 	XS_Type,x
.baa7	70 f3		bvs $ba9c			bvs 	_GSCZero
.baa9	30 f7		bmi $baa2			bmi 	_GSCMinus1
.baab	80 f2		bra $ba9f			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.baad					Unary_Abs:
.baad	20 0d b8	jsr $b80d			jsr 	EvaluateNumberX 			; get value
.bab0	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; check right bracket.
.bab3	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bab5	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bab7	f0 07		beq $bac0			beq 	_UAMinusFloat
.bab9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.babb	10 09		bpl $bac6			bpl 	_UAExit
.babd	4c b8 c3	jmp $c3b8			jmp 	IntegerNegateAlways 		; negation
.bac0					_UAMinusFloat:
.bac0	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.bac2	29 7f		and #$7f			and		#$7F
.bac4	95 85		sta $85,x			sta 	XS_Type,x
.bac6					_UAExit:
.bac6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.bac7					Unary_Peek:
.bac7	a9 01		lda #$01			lda 	#1
.bac9	80 06		bra $bad1			bra 	UPMain
.bacb					Unary_Deek:
.bacb	a9 02		lda #$02			lda 	#2
.bacd	80 02		bra $bad1			bra 	UPMain
.bacf					Unary_Leek:
.bacf	a9 04		lda #$04			lda 	#4
.bad1					UPMain:
.bad1	48		pha				pha 								; set bytes to copy.
.bad2	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX 			; numeric parameter
.bad5	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bad8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.bada	85 1a		sta $1a				sta 	zLTemp1
.badc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bade	85 1b		sta $1b				sta 	zLTemp1+1
.bae0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bae2	85 1c		sta $1c				sta 	zLTemp1+2
.bae4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bae6	85 1d		sta $1d				sta 	zLTemp1+3
.bae8	a9 00		lda #$00			lda 	#0 							; clear target area
.baea	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.baec	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.baee	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.baf0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.baf2	68		pla				pla 								; restore bytes to copy
.baf3	da		phx				phx 								; save XY
.baf4	5a		phy				phy
.baf5	20 c2 bd	jsr $bdc2			jsr 	MemRead 					; read the bytes in
.baf8	7a		ply				ply 								; restore and exit
.baf9	fa		plx				plx
.bafa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.bafb					Unary_Mod:
.bafb	20 23 bb	jsr $bb23			jsr 	_UMParameter 				; first parameter
.bafe	20 54 be	jsr $be54			jsr 	CheckNextComma
.bb01	da		phx				phx 								; second parameter
.bb02	e8		inx				inx
.bb03	e8		inx				inx
.bb04	e8		inx				inx
.bb05	e8		inx				inx
.bb06	e8		inx				inx
.bb07	e8		inx				inx
.bb08	20 23 bb	jsr $bb23			jsr 	_UMParameter
.bb0b	fa		plx				plx
.bb0c	20 4b be	jsr $be4b			jsr 	CheckNextRParen
.bb0f	20 31 c3	jsr $c331			jsr 	DivInteger32 				; divide
.bb12	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.bb14	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bb16	a5 1b		lda $1b				lda 	zLTemp1+1
.bb18	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bb1a	a5 1c		lda $1c				lda 	zLTemp1+2
.bb1c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bb1e	a5 1d		lda $1d				lda 	zLTemp1+3
.bb20	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bb22	60		rts				rts
.bb23					_UMParameter:
.bb23	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX 			; get value
.bb26	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.bb28	10 03		bpl $bb2d			bpl 	_UMNotSigned
.bb2a	20 b8 c3	jsr $c3b8			jsr 	IntegerNegateAlways
.bb2d					_UMNotSigned:
.bb2d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.bb2e					Unary_Usr:
.bb2e	20 0d b8	jsr $b80d			jsr 	EvaluateNumberX 			; numeric parameter
.bb31	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bb34	da		phx				phx 								; save XY
.bb35	5a		phy				phy
.bb36	ea		nop				nop
.bb37	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.bb3a	7a		ply				ply 								; and exit
.bb3b	fa		plx				plx
.bb3c	60		rts				rts
.bb3d					USRDefault:
.bb3d	20 79 ae	jsr $ae79			jsr ERR_Handler
>bb40	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>bb48	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.bb4f					Unary_Val:
.bb4f	20 24 b8	jsr $b824			jsr 	EvaluateStringX 			; get string
.bb52	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; check right bracket.
.bb55	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.bb57	85 1e		sta $1e				sta 	zGenPtr
.bb59	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bb5b	85 1f		sta $1f				sta 	zGenPtr+1
.bb5d	5a		phy				phy
.bb5e	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.bb60	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.bb62	f0 54		beq $bbb8			beq 	_UVBadNumber
.bb64	48		pha				pha 								; save length.
.bb65	1a		inc a				inc 	a 							; one for the length, one for the terminator
.bb66	1a		inc a				inc 	a
.bb67	20 8d be	jsr $be8d			jsr 	AllocateTempString
.bb6a	c8		iny				iny 								; move to the next.
.bb6b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.bb6d	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.bb6f	8d a0 03	sta $03a0			sta 	ValSign
.bb72	d0 04		bne $bb78			bne 	_UVNotMinus
.bb74	c8		iny				iny 								; skip over it.
.bb75	68		pla				pla 								; decrement character count.
.bb76	3a		dec a				dec 	a
.bb77	48		pha				pha
.bb78					_UVNotMinus:
.bb78	68		pla				pla 								; this is the count.
.bb79	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.bb7a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bb7c	c8		iny				iny
.bb7d	20 b8 be	jsr $beb8			jsr 	WriteTempString
.bb80	68		pla				pla
.bb81	3a		dec a				dec 	a
.bb82	d0 f5		bne $bb79			bne 	_UVCopy
.bb84	20 b8 be	jsr $beb8			jsr 	WriteTempString 			; make it ASCIIZ
.bb87	18		clc				clc
.bb88	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.bb8a	69 01		adc #$01			adc 	#1
.bb8c	85 1e		sta $1e				sta 	zGenPtr
.bb8e	a5 21		lda $21				lda 	zTempStr+1
.bb90	69 00		adc #$00			adc 	#0
.bb92	85 1f		sta $1f				sta 	zGenPtr+1
.bb94	18		clc				clc
.bb95	20 86 c4	jsr $c486			jsr 	IntFromString 				; first bit.
.bb98	b0 1e		bcs $bbb8			bcs 	_UVBadNumber
.bb9a	20 c7 c9	jsr $c9c7			jsr 	FPFromString				; try for a float part.
.bb9d	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.bba0	d0 10		bne $bbb2			bne 	_UVNotNegative
.bba2	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.bba4	4a		lsr a				lsr 	a
.bba5	b0 08		bcs $bbaf			bcs 	_UVInteger
.bba7	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.bba9	09 80		ora #$80			ora 	#$80
.bbab	95 85		sta $85,x			sta 	XS_Type,x
.bbad	80 03		bra $bbb2			bra 	_UVNotNegative
.bbaf					_UVInteger:
.bbaf	20 b8 c3	jsr $c3b8			jsr 	IntegerNegateAlways 		; sign it.
.bbb2					_UVNotNegative:
.bbb2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.bbb4	d0 02		bne $bbb8			bne 	_UVBadNumber
.bbb6	7a		ply				ply
.bbb7	60		rts				rts
.bbb8					_UVBadNumber:
.bbb8	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.bbbb					Unary_Str:
.bbbb	20 0d b8	jsr $b80d			jsr 	EvaluateNumberX 			; numeric parameter
.bbbe	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bbc1	a9 00		lda #$00			lda 	#0 							; reset buffer index
.bbc3	8d 14 03	sta $0314			sta 	NumBufX
.bbc6	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bbc8	4a		lsr a				lsr 	a
.bbc9	b0 05		bcs $bbd0			bcs 	_USInt 						; if msb set do as integer
.bbcb	20 0c c9	jsr $c90c			jsr 	FPToString 					; call fp to str otherwise
.bbce	80 03		bra $bbd3			bra 	_USDuplicate
.bbd0	20 d5 c3	jsr $c3d5	_USInt:	jsr 	IntToString
.bbd3					_USDuplicate:
.bbd3	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.bbd6	1a		inc a				inc 	a 							; one more for length
.bbd7	20 8d be	jsr $be8d			jsr 	AllocateTempString 			; allocate space for it.
.bbda	5a		phy				phy 								; save Y
.bbdb	a0 00		ldy #$00			ldy 	#0 							; start copying
.bbdd	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.bbe0	20 b8 be	jsr $beb8			jsr 	WriteTempString
.bbe3	c8		iny				iny
.bbe4	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.bbe7	d0 f4		bne $bbdd			bne 	_USCopy
.bbe9	7a		ply				ply 								; restore Y
.bbea	4c b5 bd	jmp $bdb5			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.bbed					Unary_Asc:
.bbed	20 24 b8	jsr $b824			jsr 	EvaluateStringX 			; string parameter
.bbf0	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bbf3	5a		phy				phy 								; get the string length
.bbf4	a0 00		ldy #$00			ldy 	#0
.bbf6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bbf8	f0 07		beq $bc01			beq 	_UAIllegal 					; must be at least one character
.bbfa	c8		iny				iny
.bbfb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.bbfd	7a		ply				ply
.bbfe	4c 7c ba	jmp $ba7c			jmp 	UnarySetAInteger
.bc01					_UAIllegal:
.bc01	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.bc04					Unary_Len:
.bc04	20 24 b8	jsr $b824			jsr 	EvaluateStringX 			; string parameter
.bc07	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bc0a	5a		phy				phy 								; get the string length
.bc0b	a0 00		ldy #$00			ldy 	#0
.bc0d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bc0f	7a		ply				ply
.bc10	4c 7c ba	jmp $ba7c			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.bc13					Unary_Mid:
.bc13	20 24 b8	jsr $b824			jsr 	EvaluateStringX 				; get string.
.bc16	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bc18	48		pha				pha
.bc19	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc1b	48		pha				pha
.bc1c	20 54 be	jsr $be54			jsr 	CheckNextComma 					; skip comma
.bc1f	20 a8 bc	jsr $bca8			jsr 	SLIByteParameter 				; get a byte parameter (start)
.bc22	48		pha				pha 									; and push it.
.bc23	20 54 be	jsr $be54			jsr 	CheckNextComma 					; skip comma
.bc26	20 a8 bc	jsr $bca8			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.bc29	48		pha				pha 									; and push it.
.bc2a	80 41		bra $bc6d			bra 	SLIProcess
.bc2c					Unary_Left:
.bc2c	20 24 b8	jsr $b824			jsr 	EvaluateStringX 				; get string.
.bc2f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bc31	48		pha				pha
.bc32	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc34	48		pha				pha
.bc35	a9 01		lda #$01			lda 	#1 								; push start position (1)
.bc37	48		pha				pha
.bc38	20 54 be	jsr $be54			jsr 	CheckNextComma 					; skip comma
.bc3b	20 a8 bc	jsr $bca8			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.bc3e	48		pha				pha 									; and push it.
.bc3f	80 2c		bra $bc6d			bra 	SLIProcess
.bc41					Unary_Right:
.bc41	20 24 b8	jsr $b824			jsr 	EvaluateStringX 				; get string.
.bc44	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.bc46	48		pha				pha
.bc47	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc49	48		pha				pha
.bc4a	da		phx				phx 									; get the string length and push on stack.
.bc4b	a2 00		ldx #$00			ldx 	#0
.bc4d	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.bc4f	fa		plx				plx
.bc50	48		pha				pha
.bc51	20 54 be	jsr $be54			jsr 	CheckNextComma 					; skip comma
.bc54	20 a8 bc	jsr $bca8			jsr 	SLIByteParameter 				; get a byte parameter.
.bc57	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.bc5a	68		pla				pla 									; restore string length.
.bc5b	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.bc5c	38		sec				sec
.bc5d	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.bc60	f0 02		beq $bc64			beq 	_URStart 						; if <= 0 start from 1.
.bc62	10 02		bpl $bc66			bpl 	_UROkay
.bc64					_URStart:
.bc64	a9 01		lda #$01			lda 	#1
.bc66					_UROkay:
.bc66	48		pha				pha 									; push start
.bc67	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.bc6a	48		pha				pha
.bc6b	80 00		bra $bc6d			bra 	SLIProcess
.bc6d					SLIProcess:
.bc6d	20 4b be	jsr $be4b			jsr 	CheckNextRParen 				; closing right bracket.
.bc70	68		pla				pla
.bc71	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.bc74	1a		inc a				inc 	a 								; allocate +1 for it.
.bc75	20 8d be	jsr $be8d			jsr 	AllocateTempString
.bc78	68		pla				pla 									; pop start number off stack.
.bc79	f0 3b		beq $bcb6			beq 	SLIError 						; exit if start = 0
.bc7b	8d a1 03	sta $03a1			sta 	SliceStart
.bc7e	68		pla				pla  									; pop string address.
.bc7f	85 1f		sta $1f				sta 	zGenPtr+1
.bc81	68		pla				pla
.bc82	85 1e		sta $1e				sta 	zGenPtr
.bc84	da		phx				phx
.bc85	5a		phy				phy
.bc86	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.bc88	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.bc8b					_SLICopy:
.bc8b	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.bc8e	f0 12		beq $bca2			beq 	_SLIExit
.bc90	ce a2 03	dec $03a2			dec 	SliceCount
.bc93	98		tya				tya 									; index of character
.bc94	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.bc96	f0 02		beq $bc9a			beq 	_SLIOk 							; if equal, okay.
.bc98	b0 08		bcs $bca2			bcs 	_SLIExit 						; if past end, then exit.
.bc9a	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.bc9c	c8		iny				iny
.bc9d	20 b8 be	jsr $beb8			jsr 	WriteTempString
.bca0	80 e9		bra $bc8b			bra 	_SLICopy 						; go round till copied characters
.bca2					_SLIExit:
.bca2	7a		ply				ply 									; restore YX
.bca3	fa		plx				plx
.bca4	4c b5 bd	jmp $bdb5			jmp 	UnaryReturnTempStr 				; return new temporary string.
.bca7	ea		nop				nop
.bca8					SLIByteParameter:
.bca8	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX 				; get integer
.bcab	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.bcad	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bcaf	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bcb1	d0 03		bne $bcb6			bne 	SLIError
.bcb3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bcb5	60		rts				rts
.bcb6					SLIError:
.bcb6	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.bcb9					Unary_Hex:
.bcb9	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX 			; numeric parameter
.bcbc	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bcbf	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.bcc1	20 8d be	jsr $be8d			jsr 	AllocateTempString			; allocate string space
.bcc4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.bcc6	20 ea bc	jsr $bcea			jsr 	_UHConvert
.bcc9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bccb	20 ea bc	jsr $bcea			jsr 	_UHConvert
.bcce	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bcd0	20 ea bc	jsr $bcea			jsr 	_UHConvert
.bcd3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bcd5	20 ea bc	jsr $bcea			jsr 	_UHConvert
.bcd8	5a		phy				phy 								; get length of new string
.bcd9	a0 00		ldy #$00			ldy 	#0
.bcdb	b1 20		lda ($20),y			lda 	(zTempStr),y
.bcdd	7a		ply				ply
.bcde	c9 00		cmp #$00			cmp 	#0
.bce0	d0 05		bne $bce7			bne 	_UHExit 					; if it was non zero okay
.bce2	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.bce4	20 b8 be	jsr $beb8			jsr 	WriteTempString
.bce7					_UHExit:
.bce7	4c b5 bd	jmp $bdb5			jmp 	UnaryReturnTempStr 			; return new temporary string.
.bcea					_UHConvert:
.bcea	48		pha				pha
.bceb	4a		lsr a				lsr 	a 							; do MSB
.bcec	4a		lsr a				lsr 	a
.bced	4a		lsr a				lsr 	a
.bcee	4a		lsr a				lsr 	a
.bcef	20 f3 bc	jsr $bcf3			jsr 	_UHNibble
.bcf2	68		pla				pla 								; do LSB
.bcf3					_UHNibble:
.bcf3	29 0f		and #$0f			and 	#15 						; get nibble
.bcf5	d0 0c		bne $bd03			bne 	_UHNonZero
.bcf7	5a		phy				phy									; get the length
.bcf8	a0 00		ldy #$00			ldy 	#0
.bcfa	b1 20		lda ($20),y			lda 	(zTempStr),y
.bcfc	7a		ply				ply
.bcfd	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.bcff	f0 0d		beq $bd0e			beq 	_UHExit2
.bd01	a9 00		lda #$00			lda 	#0
.bd03					_UHNonZero:
.bd03	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.bd05	90 02		bcc $bd09			bcc 	_UHDigit
.bd07	69 06		adc #$06			adc 	#7-1
.bd09					_UHDigit:
.bd09	69 30		adc #$30			adc 	#48
.bd0b	20 b8 be	jsr $beb8			jsr 	WriteTempString				; output.
.bd0e					_UHExit2:
.bd0e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.bd0f					Unary_Dec:
.bd0f	20 24 b8	jsr $b824			jsr 	EvaluateStringX 			; string parameter
.bd12	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bd15	5a		phy				phy
.bd16	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.bd18	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.bd1a	f0 41		beq $bd5d			beq 	_UDFail 					; must fail if zero.
.bd1c	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.bd1f	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.bd21	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd23	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd25	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd27	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd29	a9 01		lda #$01			lda 	#1
.bd2b	95 85		sta $85,x			sta 	XS_Type,x
.bd2d					_UDConvertLoop:
.bd2d	5a		phy				phy 								; shift mantissa left 4
.bd2e	a0 04		ldy #$04			ldy 	#4
.bd30					_UDShift:
.bd30	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.bd32	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.bd34	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.bd36	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.bd38	88		dey				dey
.bd39	d0 f5		bne $bd30			bne 	_UDShift
.bd3b	7a		ply				ply
.bd3c	c8		iny				iny 								; next character
.bd3d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.bd3f	20 60 bd	jsr $bd60			jsr 	ConvertUpper 				; convert to U/C
.bd42	c9 30		cmp #$30			cmp 	#"0"
.bd44	90 17		bcc $bd5d			bcc 	_UDFail
.bd46	c9 3a		cmp #$3a			cmp 	#"9"+1
.bd48	90 06		bcc $bd50			bcc 	_UDOkay
.bd4a	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.bd4c	c9 10		cmp #$10			cmp 	#16
.bd4e	b0 0d		bcs $bd5d			bcs 	_UDFail
.bd50					_UDOkay:
.bd50	29 0f		and #$0f			and 	#15 						; nibble only
.bd52	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.bd54	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd56	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.bd59	d0 d2		bne $bd2d			bne 	_UDConvertLoop
.bd5b	7a		ply				ply
.bd5c	60		rts				rts
.bd5d					_UDFail:
.bd5d	4c 68 ae	jmp $ae68			jmp 	BadParamError
.bd60					ConvertUpper:
.bd60	c9 61		cmp #$61			cmp 	#"a"
.bd62	90 07		bcc $bd6b			bcc 	_CUExit
.bd64	c9 7b		cmp #$7b			cmp 	#"z"+1
.bd66	b0 03		bcs $bd6b			bcs 	_CUExit
.bd68	38		sec				sec
.bd69	e9 20		sbc #$20			sbc 	#32
.bd6b	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.bd6c					Unary_Chr:
.bd6c	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX			; numeric parameter
.bd6f	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bd72	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bd74	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bd76	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bd78	d0 0d		bne $bd87			bne 	_UCChar
.bd7a	a9 01		lda #$01			lda 	#1 							; one character string
.bd7c	20 8d be	jsr $be8d			jsr 	AllocateTempString
.bd7f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.bd81	20 b8 be	jsr $beb8			jsr 	WriteTempString
.bd84	4c b5 bd	jmp $bdb5			jmp 	UnaryReturnTempStr
.bd87					_UCChar:
.bd87	4c 68 ae	jmp $ae68			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.bd8a					Unary_Spc:
.bd8a	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX 			; numeric parameter
.bd8d	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; right bracket.
.bd90	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.bd92	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bd94	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bd96	d0 1a		bne $bdb2			bne 	_USSize
.bd98	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bd9a	c9 fe		cmp #$fe			cmp 	#maxString+1
.bd9c	b0 14		bcs $bdb2			bcs 	_USSize
.bd9e	48		pha				pha 								; save length
.bd9f	1a		inc a				inc 	a 							; allocate one more.
.bda0	20 8d be	jsr $be8d			jsr 	AllocateTempString
.bda3	68		pla				pla 								; get length
.bda4	f0 0f		beq $bdb5			beq 	UnaryReturnTempStr 			; return the current temp string
.bda6					_USLoop:
.bda6	48		pha				pha
.bda7	a9 20		lda #$20			lda 	#" "
.bda9	20 b8 be	jsr $beb8			jsr 	WriteTempString
.bdac	68		pla				pla
.bdad	3a		dec a				dec 	a
.bdae	d0 f6		bne $bda6			bne 	_USLoop
.bdb0	80 03		bra $bdb5			bra 	UnaryReturnTempStr
.bdb2					_USSize:
.bdb2	4c 68 ae	jmp $ae68			jmp 	BadParamError
.bdb5					UnaryReturnTempStr:
.bdb5	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.bdb7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bdb9	a5 21		lda $21				lda 	zTempStr+1
.bdbb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bdbd	a9 02		lda #$02			lda 	#2 							; set type to string
.bdbf	95 85		sta $85,x			sta 	XS_Type,x
.bdc1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.bdc2	db		phz		MemRead:phz
.bdc3	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.bdc6	a3 00		ldz #$00			ldz 	#0 							; start from here
.bdc8	ea		nop		_MLoop1:nop
.bdc9	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.bdcb	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.bdcd	1b		inz				inz 								; next to copy
.bdce	e8		inx				inx
.bdcf	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.bdd2	d0 f4		bne $bdc8			bne 	_MLoop1
.bdd4	fb		plz				plz
.bdd5	60		rts				rts
.bdd6					MemWrite:
.bdd6	db		phz				phz
.bdd7	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.bdda	a3 00		ldz #$00			ldz 	#0 							; start from here
.bddc	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.bdde	ea		nop				nop
.bddf	92 1a		sta ($1a),z			sta 	(zlTemp1),z 				; write it out
.bde1	1b		inz				inz 								; next to copy
.bde2	e8		inx				inx
.bde3	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.bde6	d0 f4		bne $bddc			bne 	_MLoop1
.bde8	fb		plz				plz
.bde9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.bdea					UpdateProgramEnd:
.bdea	a9 00		lda #$00			lda 	#BasicProgram & $FF
.bdec	85 16		sta $16				sta 	zCodePtr+0
.bdee	a9 80		lda #$80			lda 	#BasicProgram >> 8
.bdf0	85 17		sta $17				sta 	zCodePtr+1
.bdf2	a9 02		lda #$02			lda 	#2
.bdf4	85 18		sta $18				sta 	zCodePtr+2
.bdf6	a9 00		lda #$00			lda 	#0
.bdf8	85 19		sta $19				sta 	zCodePtr+3
.bdfa	a3 03		ldz #$03			ldz 	#3
.bdfc					_UPDLoop:
.bdfc	a3 00		ldz #$00			ldz 	#0
.bdfe	ea		nop				nop
.bdff	b2 16		lda ($16),z			lda 	(zCodePtr),z
.be01	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.be03	f0 10		beq $be15			beq 	_UPDFoundEnd
.be05	a3 00		ldz #$00			ldz 	#0 							; point to offset
.be07	ea		nop				nop
.be08	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.be0a	18		clc				clc
.be0b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.be0d	85 16		sta $16				sta 	zCodePtr
.be0f	90 02		bcc $be13			bcc 	_SNLNoCarry
.be11	e6 17		inc $17				inc 	zCodePtr+1
.be13					_SNLNoCarry:
.be13	80 e7		bra $bdfc			bra 	_UPDLoop
.be15					_UPDFoundEnd:
.be15	18		clc				clc 								; end of program 2 on.
.be16	a5 16		lda $16				lda 	zCodePtr
.be18	69 02		adc #$02			adc 	#2
.be1a	8d 04 03	sta $0304			sta 	endOfProgram
.be1d	a5 17		lda $17				lda 	zCodePtr+1
.be1f	69 00		adc #$00			adc 	#0
.be21	8d 05 03	sta $0305			sta 	endOfProgram+1
.be24	a5 18		lda $18				lda 	zCodePtr+2
.be26	69 00		adc #$00			adc		#0
.be28	8d 06 03	sta $0306			sta 	endOfProgram+2
.be2b	a5 19		lda $19				lda 	zCodePtr+3
.be2d	69 00		adc #$00			adc 	#0
.be2f	8d 07 03	sta $0307			sta 	endOfProgram+3
.be32	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.be33					CheckNextToken:
.be33	ea		nop				nop
.be34	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.be36	d0 02		bne $be3a			bne 	CTFail 						; no, then fail
.be38	1b		inz				inz
.be39	60		rts				rts
.be3a					CTFail:
.be3a	20 79 ae	jsr $ae79			jsr ERR_Handler
>be3d	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>be45	74 6f 6b 65 6e 00
.be4b					CheckNextRParen:
.be4b	ea		nop				nop
.be4c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.be4e	c9 be		cmp #$be			cmp 	#token_rparen
.be50	d0 e8		bne $be3a			bne 	CTFail
.be52	1b		inz				inz
.be53	60		rts				rts
.be54					CheckNextComma:
.be54	ea		nop				nop
.be55	b2 16		lda ($16),z			lda 	(zCodePtr),z
.be57	c9 bf		cmp #$bf			cmp 	#token_comma
.be59	d0 df		bne $be3a			bne 	CTFail
.be5b	1b		inz				inz
.be5c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.be5d					StringConcrete:
.be5d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.be5f	85 10		sta $10				sta 	zTemp1
.be61	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.be63	85 11		sta $11				sta 	zTemp1+1
.be65	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.be67	18		clc				clc 								; from the string pointer
.be68	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.be6b	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.be6d	8d 00 03	sta $0300			sta 	StringPtr
.be70	85 12		sta $12				sta 	zTemp2
.be72	ad 01 03	lda $0301			lda 	StringPtr+1
.be75	e9 00		sbc #$00			sbc 	#0
.be77	8d 01 03	sta $0301			sta 	StringPtr+1
.be7a	85 13		sta $13				sta 	zTemp2+1
.be7c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.be7e	1a		inc a				inc 	a
.be7f	aa		tax				tax
.be80	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.be82	91 12		sta ($12),y			sta 	(zTemp2),y
.be84	c8		iny				iny
.be85	ca		dex				dex
.be86	d0 f8		bne $be80			bne 	_SCCopy
.be88	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.be8a	a6 12		ldx $12				ldx 	zTemp2
.be8c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.be8d					AllocateTempString:
.be8d	48		pha				pha 								; save required count.
.be8e	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.be90	d0 0b		bne $be9d			bne 	_ATSInitialised
.be92	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.be95	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.be97	ad 01 03	lda $0301			lda 	StringPtr+1
.be9a	3a		dec a				dec 	a
.be9b	85 21		sta $21				sta 	zTempStr+1
.be9d					_ATSInitialised:
.be9d	68		pla				pla 								; get required count back.
.be9e	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.bea0	1a		inc a				inc 	a
.bea1	18		clc				clc
.bea2	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.bea4	85 20		sta $20				sta 	zTempStr
.bea6	a9 ff		lda #$ff			lda 	#$FF
.bea8	65 21		adc $21				adc 	zTempStr+1
.beaa	85 21		sta $21				sta 	zTempStr+1
.beac	a9 00		lda #$00			lda 	#0 							; clear temp string.
.beae	5a		phy				phy
.beaf	a8		tay				tay
.beb0	91 20		sta ($20),y			sta 	(zTempStr),y
.beb2	7a		ply				ply
.beb3	1a		inc a				inc 	a 							; reset the write index.
.beb4	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.beb7	60		rts				rts
.beb8					WriteTempString:
.beb8	5a		phy				phy 								; save Y
.beb9	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.bebc	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.bebe	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.bec1	98		tya				tya 								; unchanged Y is now length
.bec2	a0 00		ldy #$00			ldy 	#0
.bec4	91 20		sta ($20),y			sta 	(zTempStr),y
.bec6	7a		ply				ply 								; restore Y and exit
.bec7	60		rts				rts
.bec8					CreateTempStringCopy:
.bec8	da		phx				phx 								; save X
.bec9	ea		nop				nop
.beca	b2 16		lda ($16),z			lda 	(zCodePtr),z
.becc	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.becd	20 8d be	jsr $be8d			jsr 	AllocateTempString 			; allocate memory for temporary string.
.bed0	ea		nop				nop
.bed1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bed3	1b		inz				inz
.bed4	3a		dec a				dec 	a 							; make the actual length in charactes
.bed5	3a		dec a				dec 	a
.bed6	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.bed8	81 20		sta ($20,x)			sta 	(zTempStr,x)
.beda	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.bedc	09 00		ora #$00			ora 	#0 							; if zero already, exit
.bede	f0 0f		beq $beef			beq 	_CTSCExit
.bee0					_CTSCLoop:
.bee0	ea		nop				nop
.bee1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bee3	1b		inz				inz
.bee4	5a		phy				phy 								; save in Y
.bee5	e8		inx				inx 								; bump index
.bee6	da		phx				phx 								; index into Y
.bee7	7a		ply				ply
.bee8	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.beea	7a		ply				ply 								; restore Y
.beeb	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.beed	d0 f1		bne $bee0			bne 	_CTSCLoop
.beef					_CTSCExit:
.beef	fa		plx				plx 								; restore X
.bef0	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.bef1					VariableFind:
.bef1	20 5c bf	jsr $bf5c			jsr 	VariableExtract 		; find out all about it ....
.bef4	20 f7 c1	jsr $c1f7			jsr 	VariableLocate 			; does it already exist ?
.bef7	b0 03		bcs $befc			bcs 	_VFExists 				; if so, use that.
.bef9	20 ea bf	jsr $bfea			jsr 	VariableCreate 			; otherwise create it.
.befc					_VFExists:
.befc	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.befe	29 01		and #$01			and 	#1
.bf00	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bf02	d0 28		bne $bf2c			bne 	_VFSingleElement
.bf04					_VFNextIndex:
.bf04	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.bf06	48		pha				pha
.bf07	a5 23		lda $23				lda 	zVarDataPtr+1
.bf09	48		pha				pha
.bf0a	a5 24		lda $24				lda 	zVarType
.bf0c	48		pha				pha
.bf0d	20 1b b8	jsr $b81b			jsr 	EvaluateIntegerX 		; calculate the index.
.bf10	68		pla				pla 							; restore and index.
.bf11	85 24		sta $24				sta 	zVarType
.bf13	68		pla				pla
.bf14	85 23		sta $23				sta 	zVarDataPtr+1
.bf16	68		pla				pla
.bf17	85 22		sta $22				sta 	zVarDataPtr
.bf19	20 75 c0	jsr $c075			jsr 	ArrayIndexFollow 		; do the index.
.bf1c	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bf1e	29 01		and #$01			and 	#1
.bf20	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bf22	d0 05		bne $bf29			bne 	_VFArrayDone 			; if so then exit.
.bf24	20 54 be	jsr $be54			jsr 	CheckNextComma 			; comma should follow
.bf27	80 db		bra $bf04			bra 	_VFNextIndex
.bf29					_VFArrayDone:
.bf29	20 4b be	jsr $be4b			jsr 	CheckNextRParen 		; check closing right bracket.
.bf2c					_VFSingleElement:
.bf2c	60		rts				rts
.bf2d					VariableClear:
.bf2d	48		pha				pha 							; save registers
.bf2e	da		phx				phx
.bf2f	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.bf31	8a		txa				txa
.bf32	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.bf35	e8		inx				inx
.bf36	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bf38	d0 f8		bne $bf32			bne 	_VCLoop
.bf3a	a9 00		lda #$00			lda 	#VariableMemory & $FF
.bf3c	8d 02 03	sta $0302			sta 	VarMemPtr
.bf3f	a9 20		lda #$20			lda 	#VariableMemory >> 8
.bf41	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bf44	fa		plx				plx 							; restore registers
.bf45	68		pla				pla
.bf46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bf47					VariableNameError:
.bf47	20 79 ae	jsr $ae79			jsr ERR_Handler
>bf4a	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>bf52	61 62 6c 65 20 4e 61 6d 65 00
.bf5c					VariableExtract:
.bf5c	da		phx				phx 							; save X.
.bf5d	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bf5f	8d 95 03	sta $0395			sta 	Var_Type
.bf62	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.bf65	ea		nop				nop
.bf66	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bf68	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bf6a	f0 db		beq $bf47			beq 	VariableNameError
.bf6c	c9 1b		cmp #$1b			cmp 	#26+1
.bf6e	b0 d7		bcs $bf47			bcs 	VariableNameError
.bf70	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.bf72					_VECopyBuffer:
.bf72	e8		inx				inx
.bf73	e0 1f		cpx #$1f			cpx 	#31 					; too long
.bf75	f0 d0		beq $bf47			beq 	VariableNameError
.bf77	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.bf7a	18		clc				clc  							; update the hash value for it.
.bf7b	6d 96 03	adc $0396			adc 	Var_Hash
.bf7e	8d 96 03	sta $0396			sta 	Var_Hash
.bf81	1b		inz				inz
.bf82	ea		nop				nop
.bf83	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bf85	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bf87	f0 0e		beq $bf97			beq 	_VECopyEnd
.bf89	30 0c		bmi $bf97			bmi 	_VECopyEnd
.bf8b	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bf8d	90 e3		bcc $bf72			bcc 	_VECopyBuffer
.bf8f	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bf91	90 04		bcc $bf97			bcc 	_VECopyEnd
.bf93	c9 3a		cmp #$3a			cmp 	#"9"+1
.bf95	90 db		bcc $bf72			bcc 	_VECopyBuffer
.bf97					_VECopyEnd:
.bf97	1b		inz				inz
.bf98	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bf9a	90 04		bcc $bfa0			bcc 	_VEDefaultRequired
.bf9c	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bf9e	90 0b		bcc $bfab			bcc 	_VEHaveType
.bfa0					_VEDefaultRequired:
.bfa0	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bfa2	f0 04		beq $bfa8			beq 	_VESetType 				; default set above.
.bfa4	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.bfa7	3b		dez				dez
.bfa8					_VESetType:
.bfa8	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.bfab					_VEHaveType:
.bfab	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.bfae	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.bfb1	09 80		ora #$80			ora 	#$80
.bfb3	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.bfb6	e8		inx				inx 							; offset 3 => length 4.
.bfb7	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.bfba	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.bfbd	38		sec				sec
.bfbe	e9 b7		sbc #$b7			sbc 	#token_Dollar
.bfc0	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.bfc1	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.bfc2	0a		asl a				asl 	a
.bfc3	0a		asl a				asl 	a
.bfc4	8d 98 03	sta $0398			sta 	Var_HashAddress
.bfc7	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.bfca	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.bfcc	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.bfcd	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.bfd0	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.bfd2	8d 98 03	sta $0398			sta 	Var_HashAddress
.bfd5	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.bfd7	ad 95 03	lda $0395			lda 	Var_Type
.bfda	c9 b9		cmp #$b9			cmp 	#token_Hash
.bfdc	f0 07		beq $bfe5			beq 	_VEHaveSize
.bfde	ca		dex				dex
.bfdf	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.bfe1	f0 02		beq $bfe5			beq 	_VEHaveSize
.bfe3	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.bfe5					_VEHaveSize:
.bfe5	8e 99 03	stx $0399			stx 	Var_DataSize
.bfe8	fa		plx				plx
.bfe9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.bfea					VariableCreate:
.bfea	da		phx				phx
.bfeb	5a		phy				phy
.bfec	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.bfef	85 10		sta $10				sta 	zTemp1
.bff1	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bff4	85 11		sta $11				sta 	zTemp1+1
.bff6	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.bff9	18		clc				clc
.bffa	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.bffd	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.bfff	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.c002	8d 02 03	sta $0302			sta 	VarMemPtr
.c005	90 03		bcc $c00a			bcc 	_VCNoCarry
.c007	ee 03 03	inc $0303			inc 	VarMemPtr+1
.c00a					_VCNoCarry:
.c00a	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c00d	85 12		sta $12				sta 	zTemp2
.c00f	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c011	85 13		sta $13				sta 	zTemp2+1
.c013	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.c015	b1 12		lda ($12),y			lda 	(zTemp2),y
.c017	91 10		sta ($10),y			sta 	(zTemp1),y
.c019	c8		iny				iny
.c01a	b1 12		lda ($12),y			lda 	(zTemp2),y
.c01c	91 10		sta ($10),y			sta 	(zTemp1),y
.c01e	c8		iny				iny
.c01f	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.c022	91 10		sta ($10),y			sta 	(zTemp1),y
.c024	c8		iny				iny
.c025	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.c027					_VCCopyName:
.c027	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.c02a	91 10		sta ($10),y			sta 	(zTemp1),y
.c02c	e8		inx				inx
.c02d	c8		iny				iny
.c02e	ec 97 03	cpx $0397			cpx 	Var_Length
.c031	d0 f4		bne $c027			bne 	_VCCopyName
.c033	5a		phy				phy 								; save the data offset.
.c034	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.c037	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.c039					_VCClearData:
.c039	91 10		sta ($10),y			sta 	(zTemp1),y
.c03b	c8		iny				iny
.c03c	ca		dex				dex
.c03d	d0 fa		bne $c039			bne 	_VCClearData
.c03f	68		pla				pla 								; offset to the data
.c040	18		clc				clc
.c041	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.c043	85 22		sta $22				sta 	zVarDataPtr
.c045	a5 11		lda $11				lda 	zTemp1+1
.c047	69 00		adc #$00			adc 	#0
.c049	85 23		sta $23				sta 	zVarDataPtr+1
.c04b	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c04e	85 24		sta $24				sta 	zVarType
.c050	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.c052	a0 00		ldy #$00			ldy 	#0
.c054	91 12		sta ($12),y			sta 	(zTemp2),y
.c056	c8		iny				iny
.c057	a5 11		lda $11				lda 	zTemp1+1
.c059	91 12		sta ($12),y			sta 	(zTemp2),y
.c05b	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.c05e	29 01		and #$01			and 	#1
.c060	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.c062	d0 0e		bne $c072			bne 	_VCNotArray
.c064	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.c066	20 0c c1	jsr $c10c			jsr 	ArrayCreate
.c069	5a		phy				phy 								; save YA at zVarDataPtr
.c06a	a0 00		ldy #$00			ldy 	#0
.c06c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c06e	c8		iny				iny
.c06f	68		pla				pla
.c070	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c072					_VCNotArray:
.c072	7a		ply				ply
.c073	fa		plx				plx
.c074	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.c075					ArrayIndexFollow:
.c075	5a		phy				phy
.c076	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.c078	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.c07a	48		pha				pha
.c07b	c8		iny				iny
.c07c	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c07e	85 23		sta $23				sta 	zVarDataPtr+1
.c080	68		pla				pla
.c081	85 22		sta $22				sta 	zVarDataPtr
.c083	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.c085	29 80		and #$80			and 	#$80 						; must be zero.
.c087	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c089	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c08b	d0 59		bne $c0e6			bne 	_AIFError
.c08d	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.c08f	18		clc				clc
.c090	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c092	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c094	c8		iny				iny
.c095	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c097	08		php				php 								; clear bit 7 retaining borrow.
.c098	29 7f		and #$7f			and 	#$7F
.c09a	28		plp				plp
.c09b	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c09d	90 47		bcc $c0e6			bcc 	_AIFError 					; eror if size-current < 0
.c09f	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.c0a1	0a		asl a				asl 	a 							; (e.g. index * 2)
.c0a2	85 10		sta $10				sta 	zTemp1
.c0a4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c0a6	2a		rol a				rol 	a
.c0a7	85 11		sta $11				sta 	zTemp1+1
.c0a9	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.c0ab	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.c0ad	30 1d		bmi $c0cc			bmi 	_AIFCalculate
.c0af	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.c0b1	a5 24		lda $24				lda 	zVarType 					; check that type
.c0b3	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.c0b5	f0 15		beq $c0cc			beq 	_AIFCalculate
.c0b7	06 10		asl $10				asl 	zTemp1			 			; double the index
.c0b9	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.c0bb	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.c0bd	f0 0d		beq $c0cc			beq 	_AIFCalculate
.c0bf	18		clc				clc 								; add the original mantissa in again
.c0c0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.c0c2	65 10		adc $10				adc 	zTemp1
.c0c4	85 10		sta $10				sta 	zTemp1
.c0c6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c0c8	65 11		adc $11				adc 	zTemp1+1
.c0ca	85 11		sta $11				sta 	zTemp1+1
.c0cc					_AIFCalculate:
.c0cc	18		clc				clc 								; add index x 2,4 or 5 to base
.c0cd	a5 22		lda $22				lda 	zVarDataPtr
.c0cf	65 10		adc $10				adc 	zTemp1
.c0d1	85 22		sta $22				sta 	zVarDataPtr
.c0d3	a5 23		lda $23				lda 	zVarDataPtr+1
.c0d5	65 11		adc $11				adc 	zTemp1+1
.c0d7	85 23		sta $23				sta 	zVarDataPtr+1
.c0d9	18		clc				clc 								; add 2 more for the length prefix.
.c0da	a5 22		lda $22				lda 	zVarDataPtr
.c0dc	69 02		adc #$02			adc 	#2
.c0de	85 22		sta $22				sta 	zVarDataPtr
.c0e0	90 02		bcc $c0e4			bcc 	_AIFNoBump
.c0e2	e6 23		inc $23				inc 	zVarDataPtr+1
.c0e4					_AIFNoBump:
.c0e4	7a		ply				ply
.c0e5	60		rts				rts
.c0e6					_AIFError:
.c0e6	20 79 ae	jsr $ae79			jsr ERR_Handler
>c0e9	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c0f1	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.c0f9					ArrayResetDefault:
.c0f9	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.c0fb	8d a8 03	sta $03a8			sta 	ArrayDef+0
.c0fe	a9 00		lda #$00			lda 	#0
.c100	8d a9 03	sta $03a9			sta 	ArrayDef+1
.c103	a9 ff		lda #$ff			lda 	#$FF
.c105	8d aa 03	sta $03aa			sta 	ArrayDef+2 					; $FFFF implies no second element.
.c108	8d ab 03	sta $03ab			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.c10b	60		rts				rts
.c10c					ArrayCreate:
.c10c	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.c10f	0a		asl a				asl 	a
.c110	85 10		sta $10				sta 	zTemp1
.c112	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.c115	2a		rol a				rol 	a
.c116	85 11		sta $11				sta 	zTemp1+1
.c118	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.c11b	10 22		bpl $c13f			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.c11d	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.c120	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.c122	f0 1b		beq $c13f			beq 	_ACSized
.c124	06 10		asl $10				asl 	zTemp1 						; double again
.c126	26 11		rol $11				rol 	zTemp1+1
.c128	b0 6f		bcs $c199			bcs 	ArrayIndexError 			; too large.
.c12a	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.c12c	f0 11		beq $c13f			beq 	_ACSized
.c12e	18		clc				clc 								; add original value x 5 for reals.
.c12f	a5 10		lda $10				lda 	zTemp1
.c131	7d a8 03	adc $03a8,x			adc 	ArrayDef+0,x
.c134	85 10		sta $10				sta 	zTemp1
.c136	a5 11		lda $11				lda 	zTemp1+1
.c138	7d a9 03	adc $03a9,x			adc 	ArrayDef+1,x
.c13b	85 11		sta $11				sta 	zTemp1+1
.c13d	b0 5a		bcs $c199			bcs 	ArrayIndexError
.c13f					_ACSized:
.c13f	18		clc				clc
.c140	a5 10		lda $10				lda 	zTemp1
.c142	69 02		adc #$02			adc 	#2
.c144	85 10		sta $10				sta 	zTemp1
.c146	90 04		bcc $c14c			bcc 	_ACNoBump
.c148	e6 10		inc $10				inc 	zTemp1
.c14a	f0 4d		beq $c199			beq 	ArrayIndexError
.c14c					_ACNoBump:
.c14c	18		clc				clc
.c14d	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.c150	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.c152	85 14		sta $14				sta 	zTemp3
.c154	65 10		adc $10				adc 	zTemp1
.c156	8d 02 03	sta $0302			sta 	VarMemPtr
.c159	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c15c	85 13		sta $13				sta 	zTemp2+1
.c15e	85 15		sta $15				sta 	zTemp3+1
.c160	65 11		adc $11				adc 	zTemp1+1
.c162	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c165	85 11		sta $11				sta 	zTemp1+1
.c167	b0 30		bcs $c199			bcs 	ArrayIndexError
.c169	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.c16b					_ACClear:
.c16b	98		tya				tya
.c16c	91 12		sta ($12),y			sta 	(zTemp2),y
.c16e	e6 12		inc $12				inc 	zTemp2
.c170	d0 02		bne $c174			bne 	_ACCBump
.c172	e6 13		inc $13				inc 	zTemp2+1
.c174					_ACCBump:
.c174	a5 12		lda $12				lda 	zTemp2
.c176	cd 02 03	cmp $0302			cmp 	VarMemPtr
.c179	d0 f0		bne $c16b			bne 	_ACClear
.c17b	a5 13		lda $13				lda 	zTemp2+1
.c17d	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.c180	d0 e9		bne $c16b			bne 	_ACClear
.c182	a0 00		ldy #$00			ldy 	#0
.c184	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; copy the size into the start
.c187	91 14		sta ($14),y			sta 	(zTemp3),y
.c189	c8		iny				iny
.c18a	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.c18d	91 14		sta ($14),y			sta 	(zTemp3),y
.c18f	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; have we reached the end
.c192	10 18		bpl $c1ac			bpl 	ACCFillRecursive
.c194	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.c196	a5 14		lda $14				lda 	zTemp3
.c198	60		rts				rts
.c199					ArrayIndexError:
.c199	20 79 ae	jsr $ae79			jsr ERR_Handler
>c19c	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c1a4	79 20 69 6e 64 65 78 00
.c1ac					ACCFillRecursive:
.c1ac	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.c1ae	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.c1b0	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.c1b2	c8		iny				iny
.c1b3	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.c1b5	09 80		ora #$80			ora 	#$80 						; an array of pointers
.c1b7	91 14		sta ($14),y			sta 	(zTemp3),y
.c1b9	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.c1bb	48		pha				pha
.c1bc	a5 15		lda $15				lda 	zTemp3+1
.c1be	48		pha				pha
.c1bf					_ACCFillLoop:
.c1bf	18		clc				clc
.c1c0	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.c1c2	69 02		adc #$02			adc 	#2
.c1c4	85 14		sta $14				sta 	zTemp3
.c1c6	90 02		bcc $c1ca			bcc 	_ACCSkip2
.c1c8	e6 15		inc $15				inc 	zTemp3+1
.c1ca					_ACCSkip2:
.c1ca	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.c1cc	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.c1ce	c8		iny				iny
.c1cf	11 14		ora ($14),y			ora 	(zTemp3),y
.c1d1	d0 21		bne $c1f4			bne 	_ACCExit
.c1d3	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.c1d5	48		pha				pha
.c1d6	a5 15		lda $15				lda 	zTemp3+1
.c1d8	48		pha				pha
.c1d9	e8		inx				inx
.c1da	e8		inx				inx
.c1db	20 0c c1	jsr $c10c			jsr 	ArrayCreate 				; create array recursively.
.c1de	ca		dex				dex
.c1df	ca		dex				dex
.c1e0	85 12		sta $12				sta 	zTemp2 						; save A
.c1e2	68		pla				pla
.c1e3	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.c1e5	68		pla				pla
.c1e6	85 14		sta $14				sta 	zTemp3
.c1e8	98		tya				tya 								; write high bye from Y
.c1e9	a0 01		ldy #$01			ldy 	#1
.c1eb	91 14		sta ($14),y			sta 	(zTemp3),y
.c1ed	88		dey				dey 								; write low byte out.
.c1ee	a5 12		lda $12				lda 	zTemp2
.c1f0	91 14		sta ($14),y			sta 	(zTemp3),y
.c1f2	80 cb		bra $c1bf			bra 	_ACCFillLoop 				; and try again.
.c1f4					_ACCExit:
.c1f4	7a		ply				ply 								; restore the original address
.c1f5	68		pla				pla
.c1f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.c1f7					VariableLocate:
.c1f7	da		phx				phx
.c1f8	5a		phy				phy
.c1f9	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c1fc	85 12		sta $12				sta 	zTemp2 						; points to first address.
.c1fe	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c200	85 13		sta $13				sta 	zTemp2+1
.c202	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.c204	b1 12		lda ($12),y			lda 	(zTemp2),y
.c206	aa		tax				tax
.c207	c8		iny				iny
.c208	b1 12		lda ($12),y			lda 	(zTemp2),y
.c20a	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c20c	86 12		stx $12				stx 	zTemp2
.c20e	05 12		ora $12				ora 	zTemp2 						; got zero
.c210	18		clc				clc
.c211	f0 25		beq $c238			beq 	_VLExit 					; if so, then fail as end of chain.
.c213	c8		iny				iny 								; point to hash (offset + 2)
.c214	b1 12		lda ($12),y			lda 	(zTemp2),y
.c216	cd 96 03	cmp $0396			cmp 	Var_Hash
.c219	d0 e7		bne $c202			bne 	_VLNext 					; try next if different.
.c21b					_VLCompare:
.c21b	c8		iny				iny 								; next character
.c21c	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c21e	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c221	d0 df		bne $c202			bne 	_VLNext 					; fail if different, try next.
.c223	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c224	90 f5		bcc $c21b			bcc 	_VLCompare
.c226	98		tya				tya
.c227	38		sec				sec 								; add 1 as Y points to last character
.c228	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c22a	85 22		sta $22				sta 	zVarDataPtr
.c22c	a5 13		lda $13				lda 	zTemp2+1
.c22e	69 00		adc #$00			adc 	#0
.c230	85 23		sta $23				sta 	zVarDataPtr+1
.c232	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c235	85 24		sta $24				sta 	zVarType
.c237	38		sec				sec 								; return CS
.c238	7a		ply		_VLExit:ply
.c239	fa		plx				plx
.c23a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c23b					VariableGet:
.c23b	5a		phy				phy
.c23c	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c23e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c240	95 80		sta $80,x			sta 	XS_Mantissa,x
.c242	c8		iny				iny
.c243	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c245	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c247	c8		iny				iny
.c248	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.c24a	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c24c	f0 2c		beq $c27a			beq 	_VGString
.c24e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c250	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c252	c8		iny				iny
.c253	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.c255	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c257	c8		iny				iny
.c258	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c25a	95 85		sta $85,x			sta 	XS_Type,x
.c25c	a5 24		lda $24				lda 	zVarType
.c25e	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.c260	f0 28		beq $c28a			beq 	_VGExit
.c262	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.c264	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.c266	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.c268	95 84		sta $84,x			sta 	XS_Exponent,x
.c26a	f0 1e		beq $c28a			beq 	_VGExit 					; if exponent is zero ... it's zero.
.c26c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.c26e	48		pha				pha
.c26f	29 80		and #$80			and 	#$80
.c271	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.c273	68		pla				pla
.c274	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.c276	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.c278	80 10		bra $c28a			bra 	_VGExit
.c27a					_VGString:
.c27a	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.c27c	95 85		sta $85,x			sta 	XS_Type,x
.c27e	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.c280	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c282	d0 06		bne $c28a			bne 	_VGExit 					; if not, exit.
.c284	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.c286	a9 25		lda #$25			lda 	#zNullString
.c288	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.c28a					_VGExit:
.c28a	7a		ply				ply
.c28b	60		rts				rts
.c28c					VariableSet:
.c28c	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.c28e	29 02		and #$02			and 	#2 							; if so, it has to be
.c290	d0 4b		bne $c2dd			bne 	_VSString
.c292	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.c294	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c296	f0 42		beq $c2da			beq 	_VSBadType
.c298	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.c29a	f0 05		beq $c2a1			beq 	_VSMakeInt
.c29c	20 c1 c7	jsr $c7c1			jsr 	FPUToFloat
.c29f	80 03		bra $c2a4			bra 	_VSCopy
.c2a1					_VSMakeInt:
.c2a1	20 0d c8	jsr $c80d			jsr 	FPUToInteger
.c2a4					_VSCopy:
.c2a4	5a		phy				phy
.c2a5	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.c2a7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c2a9	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2ab	c8		iny				iny
.c2ac	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c2ae	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2b0	c8		iny				iny
.c2b1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c2b3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2b5	c8		iny				iny
.c2b6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c2b8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2ba	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.c2bc	c9 bb		cmp #$bb			cmp 	#token_Percent
.c2be	f0 18		beq $c2d8			beq 	_VSExit
.c2c0	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.c2c2	0a		asl a				asl 	a
.c2c3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.c2c5	08		php				php
.c2c6	0a		asl a				asl 	a
.c2c7	28		plp				plp
.c2c8	6a		ror a				ror 	a
.c2c9	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2cb	c8		iny				iny
.c2cc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.c2ce	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2d0	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.c2d2	50 04		bvc $c2d8			bvc 	_VSExit
.c2d4	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.c2d6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2d8					_VSExit:
.c2d8	7a		ply				ply
.c2d9	60		rts				rts
.c2da					_VSBadType:
.c2da	4c 5a ae	jmp $ae5a			jmp 	TypeError
.c2dd					_VSString:
.c2dd	a5 24		lda $24				lda 	zVarType 					; type must be $
.c2df	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c2e1	d0 f7		bne $c2da			bne 	_VSBadType
.c2e3	da		phx				phx
.c2e4	5a		phy				phy
.c2e5	20 5d be	jsr $be5d			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.c2e8	a0 01		ldy #$01			ldy 	#1 							; save high byte
.c2ea	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2ec	88		dey				dey 								; save low byte
.c2ed	8a		txa				txa
.c2ee	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.c2f0	7a		ply				ply 								; and exit.
.c2f1	fa		plx				plx
.c2f2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c2f3					MulInteger32:
.c2f3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c2f5	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.c2f7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c2f9	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.c2fb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c2fd	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.c2ff	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c301	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.c303	a9 00		lda #$00			lda 	#0
.c305	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.c307	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c309	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c30b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c30d					_BFMMultiply:
.c30d	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c30f	29 01		and #$01			and 	#1
.c311	f0 03		beq $c316			beq 	_BFMNoAdd
.c313	20 b9 b9	jsr $b9b9			jsr 	AddInteger32
.c316					_BFMNoAdd:
.c316	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c318	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.c31a	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.c31c	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.c31e	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c320	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.c322	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.c324	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.c326	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c328	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.c32a	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.c32c	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.c32e	d0 dd		bne $c30d			bne 	_BFMMultiply
.c330	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c331					DivInteger32:
.c331	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c333	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.c335	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c337	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c339	d0 14		bne $c34f			bne 	_BFDOkay
.c33b	20 79 ae	jsr $ae79			jsr ERR_Handler
>c33e	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>c346	20 62 79 20 5a 65 72 6f 00
.c34f					_BFDOkay:
.c34f	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c351	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c353	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c355	85 1c		sta $1c				sta 	zLTemp1+2
.c357	85 1d		sta $1d				sta 	zLTemp1+3
.c359	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.c35c	20 b3 c3	jsr $c3b3			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c35f	da		phx				phx
.c360	e8		inx				inx
.c361	e8		inx				inx
.c362	e8		inx				inx
.c363	e8		inx				inx
.c364	e8		inx				inx
.c365	e8		inx				inx
.c366	20 b3 c3	jsr $c3b3			jsr 	CheckIntegerNegate
.c369	fa		plx				plx
.c36a	5a		phy				phy 								; Y is the counter
.c36b	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c36d					_BFDLoop:
.c36d	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c36f	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c371	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c373	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c375	26 1a		rol $1a				rol 	zLTemp1
.c377	26 1b		rol $1b				rol 	zLTemp1+1
.c379	26 1c		rol $1c				rol 	zLTemp1+2
.c37b	26 1d		rol $1d				rol 	zLTemp1+3
.c37d	38		sec				sec
.c37e	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c380	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c382	48		pha				pha
.c383	a5 1b		lda $1b				lda 	zLTemp1+1
.c385	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c387	48		pha				pha
.c388	a5 1c		lda $1c				lda 	zLTemp1+2
.c38a	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c38c	48		pha				pha
.c38d	a5 1d		lda $1d				lda 	zLTemp1+3
.c38f	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c391	90 13		bcc $c3a6			bcc 	_BFDNoAdd
.c393	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c395	68		pla				pla
.c396	85 1c		sta $1c				sta 	zLTemp1+2
.c398	68		pla				pla
.c399	85 1b		sta $1b				sta 	zLTemp1+1
.c39b	68		pla				pla
.c39c	85 1a		sta $1a				sta 	zLTemp1+0
.c39e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c3a0	09 01		ora #$01			ora 	#1
.c3a2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c3a4	80 03		bra $c3a9			bra 	_BFDNext
.c3a6					_BFDNoAdd:
.c3a6	68		pla				pla 								; Throw away the intermediate calculations
.c3a7	68		pla				pla
.c3a8	68		pla				pla
.c3a9					_BFDNext:
.c3a9	88		dey				dey
.c3aa	d0 c1		bne $c36d			bne 	_BFDLoop
.c3ac	7a		ply				ply 								; restore Y and exit
.c3ad	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.c3b0	b0 06		bcs $c3b8			bcs		IntegerNegateAlways 			; negate the result
.c3b2	60		rts				rts
.c3b3					CheckIntegerNegate:
.c3b3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c3b5	30 01		bmi $c3b8			bmi 	IntegerNegateAlways
.c3b7	60		rts				rts
.c3b8					IntegerNegateAlways:
.c3b8	ee 9e 03	inc $039e			inc 	SignCount
.c3bb	38		sec				sec
.c3bc	a9 00		lda #$00			lda 	#0
.c3be	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c3c0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c3c2	a9 00		lda #$00			lda 	#0
.c3c4	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c3c6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c3c8	a9 00		lda #$00			lda 	#0
.c3ca	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c3cc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c3ce	a9 00		lda #$00			lda 	#0
.c3d0	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c3d2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c3d4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c3d5					INTToString:
.c3d5	48		pha				pha
.c3d6	5a		phy				phy
.c3d7	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.c3d9	10 08		bpl $c3e3			bpl 		_ITSNotMinus
.c3db	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c3dd	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter
.c3e0	20 b8 c3	jsr $c3b8			jsr 		IntegerNegateAlways 	; negate the number.
.c3e3					_ITSNotMinus:
.c3e3	a9 00		lda #$00			lda 		#0
.c3e5	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.c3e8	8a		txa				txa 								; use Y for the mantissa index.
.c3e9	a8		tay				tay
.c3ea	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c3ec					_ITSNextSubtractor:
.c3ec	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c3ee	8d 9b 03	sta $039b			sta 		NumConvCount
.c3f1					_ITSSubtract:
.c3f1	38		sec				sec
.c3f2	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c3f5	fd 4f c4	sbc $c44f,x			sbc 		_ITSSubtractors+0,x
.c3f8	48		pha				pha
.c3f9	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.c3fc	fd 50 c4	sbc $c450,x			sbc 		_ITSSubtractors+1,x
.c3ff	48		pha				pha
.c400	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.c403	fd 51 c4	sbc $c451,x			sbc 		_ITSSubtractors+2,x
.c406	48		pha				pha
.c407	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.c40a	fd 52 c4	sbc $c452,x			sbc 		_ITSSubtractors+3,x
.c40d	90 14		bcc $c423			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c40f	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c412	68		pla				pla
.c413	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.c416	68		pla				pla
.c417	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.c41a	68		pla				pla
.c41b	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.c41e	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.c421	80 ce		bra $c3f1			bra 		_ITSSubtract 			; go round again.
.c423					_ITSCantSubtract:
.c423	68		pla				pla 								; throw away interim answers
.c424	68		pla				pla
.c425	68		pla				pla
.c426	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.c429	c9 30		cmp #$30			cmp 		#"0"
.c42b	d0 05		bne $c432			bne 		_ITSOutputDigit
.c42d	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c430	10 09		bpl $c43b			bpl	 		_ITSGoNextSubtractor
.c432					_ITSOutputDigit:
.c432	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.c435	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.c438	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter 		; output it.
.c43b					_ITSGoNextSubtractor:
.c43b	e8		inx				inx 								; next dword
.c43c	e8		inx				inx
.c43d	e8		inx				inx
.c43e	e8		inx				inx
.c43f	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c441	d0 a9		bne $c3ec			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c443	98		tya				tya 								; X is back as the mantissa index
.c444	aa		tax				tax
.c445	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c447	09 30		ora #$30			ora 		#"0"
.c449	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter
.c44c	7a		ply				ply 								; and exit
.c44d	68		pla				pla
.c44e	60		rts				rts
.c44f					_ITSSubtractors:
>c44f	00 ca 9a 3b					.dword 		1000000000
>c453	00 e1 f5 05					.dword 		100000000
>c457	80 96 98 00					.dword 		10000000
>c45b	40 42 0f 00					.dword 		1000000
>c45f	a0 86 01 00					.dword 		100000
>c463	10 27 00 00					.dword 		10000
>c467	e8 03 00 00					.dword 		1000
>c46b	64 00 00 00					.dword 		100
>c46f	0a 00 00 00					.dword 		10
.c473					_ITSSubtractorsEnd:
.c473					ITSOutputCharacter:
.c473	48		pha				pha
.c474	da		phx				phx
.c475	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.c478	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.c47b	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c47d	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.c480	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.c483	fa		plx				plx
.c484	68		pla				pla
.c485	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c486					IntFromString:
.c486	a0 00		ldy #$00			ldy 	#0
.c488	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.c48b					IntFromStringY:
.c48b	48		pha				pha
.c48c	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c48e	95 80		sta $80,x			sta 	XS_Mantissa,x
.c490	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c492	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c494	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c496	a9 01		lda #$01			lda 	#1
.c498	95 85		sta $85,x			sta 	XS_Type,x
.c49a					_IFSLoop:
.c49a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c49c	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c49e	90 4e		bcc $c4ee			bcc 	_IFSExit
.c4a0	c9 3a		cmp #$3a			cmp 	#"9"+1
.c4a2	b0 4a		bcs $c4ee			bcs 	_IFSExit
.c4a4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c4a6	c9 0c		cmp #$0c			cmp 	#12
.c4a8	b0 4e		bcs $c4f8			bcs 	_IFSOverflow
.c4aa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c4ac	48		pha				pha
.c4ad	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c4af	48		pha				pha
.c4b0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c4b2	48		pha				pha
.c4b3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c4b5	48		pha				pha
.c4b6	20 0d c5	jsr $c50d			jsr 	IFSX1ShiftLeft 				; double
.c4b9	20 0d c5	jsr $c50d			jsr 	IFSX1ShiftLeft 				; x 4
.c4bc	18		clc				clc 								; add saved value x 5
.c4bd	68		pla				pla
.c4be	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c4c0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c4c2	68		pla				pla
.c4c3	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c4c5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c4c7	68		pla				pla
.c4c8	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c4ca	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c4cc	68		pla				pla
.c4cd	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c4cf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c4d1	20 0d c5	jsr $c50d			jsr 	IFSX1ShiftLeft 				; x 10
.c4d4	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.c4d7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c4d9	29 0f		and #$0f			and 	#15
.c4db	c8		iny				iny
.c4dc	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c4de	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c4e0	90 b8		bcc $c49a			bcc 	_IFSLoop
.c4e2	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c4e4	d0 b4		bne $c49a			bne 	_IFSLoop
.c4e6	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c4e8	d0 b0		bne $c49a			bne 	_IFSLoop
.c4ea	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c4ec	80 ac		bra $c49a			bra 	_IFSLoop
.c4ee					_IFSExit:
.c4ee	98		tya				tya 								; get offset
.c4ef					_IFSOkay:
.c4ef	38		sec				sec
.c4f0	ad 9c 03	lda $039c			lda 	ExpTemp
.c4f3	f0 01		beq $c4f6			beq 	_IFSSkipFail
.c4f5	18		clc				clc
.c4f6					_IFSSkipFail:
.c4f6	68		pla				pla 								; and exit.
.c4f7	60		rts				rts
.c4f8					_IFSOverflow:
.c4f8	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>c4fb	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c503	20 6f 76 65 72 66 6c 6f 77 00
.c50d					IFSX1ShiftLeft:
.c50d	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c50f	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c511	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c513	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c515	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c516					FPSubtract:
.c516	48		pha				pha
.c517	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c519	49 80		eor #$80			eor 	#$80
.c51b	95 8b		sta $8b,x			sta 	XS2_Type,x
.c51d	68		pla				pla 								; --- and fall through ---
.c51e					FPAdd:
.c51e	48		pha				pha
.c51f	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c521	d0 05		bne $c528			bne 	_FPA_NegativeLHS
.c523	20 3f c5	jsr $c53f			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c526	68		pla				pla
.c527	60		rts				rts
.c528					_FPA_NegativeLHS:
.c528	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c52a	49 80		eor #$80			eor 	#$80
.c52c	95 85		sta $85,x			sta 	XS_Type,x
.c52e	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c530	49 80		eor #$80			eor 	#$80
.c532	95 8b		sta $8b,x			sta 	XS2_Type,x
.c534	20 3f c5	jsr $c53f			jsr 	FPAdd_Worker 				; do the add calculation.
.c537	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c539	49 80		eor #$80			eor 	#$80
.c53b	95 85		sta $85,x			sta 	XS_Type,x
.c53d	68		pla				pla
.c53e	60		rts				rts
.c53f					FPAdd_Worker:
.c53f	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c541	70 07		bvs $c54a			bvs 	_FPAWExit 					; no change.
.c543	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c545	50 07		bvc $c54e			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c547	20 7f c7	jsr $c77f			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c54a					_FPAWExit:
.c54a	20 ee c7	jsr $c7ee			jsr 	FPUNormalise 				; normalise the result.
.c54d	60		rts				rts
.c54e					_FPAWMakeSame:
.c54e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c550	38		sec				sec
.c551	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c553	f0 16		beq $c56b			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c555	da		phx				phx 								; save X
.c556	90 06		bcc $c55e			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c558	e8		inx				inx
.c559	e8		inx				inx
.c55a	e8		inx				inx
.c55b	e8		inx				inx
.c55c	e8		inx				inx
.c55d	e8		inx				inx
.c55e					_FPAWShiftA:
.c55e	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c560	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c562	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c564	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c566	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c568	fa		plx				plx 								; restore original X
.c569	80 e3		bra $c54e			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c56b					_FPAW_DoArithmetic:
.c56b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c56d	30 28		bmi $c597			bmi 	_FPAW_BNegative
.c56f	18		clc				clc
.c570	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c572	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c574	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c576	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c578	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c57a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c57c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c57e	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c580	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c582	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c584	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c586	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c588	90 c0		bcc $c54a			bcc 	_FPAWExit 					; no carry.
.c58a	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c58c	38		sec				sec
.c58d	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c58f	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c591	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c593	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c595	80 b3		bra $c54a			bra 	_FPAWExit
.c597					_FPAW_BNegative:
.c597	38		sec				sec
.c598	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c59a	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c59c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c59e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c5a0	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c5a2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c5a4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c5a6	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c5a8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c5aa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c5ac	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c5ae	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c5b0	b0 09		bcs $c5bb			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c5b2	20 a5 c7	jsr $c7a5			jsr 	FPUNegateInteger			; negate the mantissa
.c5b5	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.c5b7	49 80		eor #$80			eor 	#$80
.c5b9	95 85		sta $85,x			sta 	XS_Type,x
.c5bb					_FPAWGoExit:
.c5bb	4c 4a c5	jmp $c54a			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c5be					FPD_IsDivZero:
.c5be	20 79 ae	jsr $ae79			jsr ERR_Handler
>c5c1	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c5c9	20 62 79 20 7a 65 72 6f 00
.c5d2					FPDivide:
.c5d2	48		pha				pha
.c5d3	5a		phy				phy
.c5d4	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.c5d6	70 e6		bvs $c5be			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c5d8	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c5da	f0 03		beq $c5df			beq 	_FPDCalculateExp
.c5dc					_FPD_Exit:
.c5dc	7a		ply				ply
.c5dd	68		pla				pla
.c5de	60		rts				rts
.c5df					_FPDCalculateExp:
.c5df	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c5e1	49 ff		eor #$ff			eor 	#$FF
.c5e3	1a		inc a				inc 	a
.c5e4	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.c5e6	20 b6 c6	jsr $c6b6			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c5e9	18		clc				clc 	 							; add 1 to the resulting exponent
.c5ea	69 01		adc #$01			adc 	#1
.c5ec	b0 54		bcs $c642			bcs 	_FPD_Overflow 				; which can overflow.
.c5ee	95 84		sta $84,x			sta 	XS_Exponent,x
.c5f0	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c5f2	85 1a		sta $1a				sta 	zLTemp1+0
.c5f4	85 1b		sta $1b				sta 	zLTemp1+1
.c5f6	85 1c		sta $1c				sta 	zLTemp1+2
.c5f8	85 1d		sta $1d				sta 	zLTemp1+3
.c5fa	a0 20		ldy #$20			ldy 	#32 						; times round.
.c5fc					_FPD_Loop:
.c5fc	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c5fd	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.c5ff	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.c601	48		pha				pha
.c602	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c604	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c606	48		pha				pha
.c607	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c609	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c60b	48		pha				pha
.c60c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c60e	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c610	90 13		bcc $c625			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c612	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c614	68		pla				pla
.c615	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c617	68		pla				pla
.c618	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c61a	68		pla				pla
.c61b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c61d	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c61f	09 80		ora #$80			ora 	#$80
.c621	85 1d		sta $1d				sta 	zLTemp1+3
.c623	80 03		bra $c628			bra 	_FPD_Rotates
.c625					_FPD_NoSubtract:
.c625	68		pla				pla 								; throw away unwanted results
.c626	68		pla				pla
.c627	68		pla				pla
.c628					_FPD_Rotates:
.c628	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.c62a	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.c62c	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.c62e	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.c630	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c632	26 1b		rol $1b				rol 	zLTemp1+1
.c634	26 1c		rol $1c				rol 	zLTemp1+2
.c636	26 1d		rol $1d				rol 	zLTemp1+3
.c638	90 02		bcc $c63c			bcc 	_FPD_NoCarry
.c63a	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c63c					_FPD_NoCarry:
.c63c	88		dey				dey 								; do 32 times
.c63d	d0 bd		bne $c5fc			bne 	_FPD_Loop
.c63f	4c 9a c6	jmp $c69a			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c642					_FPD_Overflow:
.c642	4c 4b c8	jmp $c84b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c645					FPMultiply:
.c645	48		pha				pha
.c646	5a		phy				phy
.c647	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c649	70 07		bvs $c652			bvs 	_FPM_Exit
.c64b	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c64d	50 06		bvc $c655			bvc 	_FPM_CalcExponent
.c64f	20 7f c7	jsr $c77f			jsr 	FPUCopyX2ToX1
.c652					_FPM_Exit:
.c652	7a		ply				ply
.c653	68		pla				pla
.c654	60		rts				rts
.c655					_FPM_CalcExponent:
.c655	18		clc				clc
.c656	20 b6 c6	jsr $c6b6			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c659	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.c65b	a9 00		lda #$00			lda 	#0
.c65d	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c65f	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c661	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c663	85 1d		sta $1d				sta 	zLTemp1+3
.c665	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c667					_FPM_Loop:
.c667	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.c669	29 01		and #$01			and 	#1
.c66b	18		clc				clc 								; clear carry for the long rotate.
.c66c	f0 19		beq $c687			beq 	_FPM_NoAddition
.c66e	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c66f	a5 1a		lda $1a				lda 	zLTemp1+0
.c671	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c673	85 1a		sta $1a				sta 	zLTemp1+0
.c675	a5 1b		lda $1b				lda 	zLTemp1+1
.c677	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c679	85 1b		sta $1b				sta 	zLTemp1+1
.c67b	a5 1c		lda $1c				lda 	zLTemp1+2
.c67d	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c67f	85 1c		sta $1c				sta 	zLTemp1+2
.c681	a5 1d		lda $1d				lda 	zLTemp1+3
.c683	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c685	85 1d		sta $1d				sta 	zLTemp1+3
.c687					_FPM_NoAddition:
.c687	66 1d		ror $1d				ror 	3+zLTemp1
.c689	66 1c		ror $1c				ror 	2+zLTemp1
.c68b	66 1b		ror $1b				ror 	1+zLTemp1
.c68d	66 1a		ror $1a				ror 	0+zLTemp1
.c68f	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c691	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c693	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c695	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c697	88		dey				dey
.c698	d0 cd		bne $c667			bne 	_FPM_Loop 					; do this 32 times.
.c69a					FPM_CopySignNormalize:
.c69a	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c69c	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c69e	a5 1b		lda $1b				lda 	zLTemp1+1
.c6a0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c6a2	a5 1c		lda $1c				lda 	zLTemp1+2
.c6a4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c6a6	a5 1d		lda $1d				lda 	zLTemp1+3
.c6a8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c6aa	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.c6ac	55 8b		eor $8b,x			eor 	XS2_Type,x
.c6ae	95 85		sta $85,x			sta 	XS_Type,x
.c6b0	20 ee c7	jsr $c7ee			jsr 	FPUNormalise 				; normalise and exit.
.c6b3	7a		ply				ply
.c6b4	68		pla				pla
.c6b5	60		rts				rts
.c6b6					FPCalculateExponent:
.c6b6	18		clc				clc
.c6b7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c6b9	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.c6bb	b0 08		bcs $c6c5			bcs 	_FPCECarry 					; carry out ?
.c6bd	10 03		bpl $c6c2			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c6bf	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c6c1	60		rts				rts
.c6c2					_FPCEExpZero:
.c6c2	a9 00		lda #$00			lda 	#0
.c6c4	60		rts				rts
.c6c5					_FPCECarry:
.c6c5	30 03		bmi $c6ca			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c6c7	09 80		ora #$80			ora 	#$80 						; put in right range
.c6c9	60		rts				rts
.c6ca					_FPCEOverflow:
.c6ca	4c 4b c8	jmp $c84b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c6cd					FPFractionalPart:
.c6cd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c6cf	38		sec				sec 								; this flag tells us to keep the fractional part
.c6d0	30 0d		bmi $c6df			bmi 	FPGetPart
.c6d2	60		rts				rts
.c6d3					FPIntegerPart:
.c6d3	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c6d5	18		clc				clc 								; this flag says keep the integer part.
.c6d6	30 07		bmi $c6df			bmi 	FPGetPart 					; -ve exponents are 0..127
.c6d8	48		pha				pha
.c6d9	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c6db	95 85		sta $85,x			sta 	XS_Type,x
.c6dd	68		pla				pla
.c6de	60		rts				rts
.c6df					FPGetPart:
.c6df	48		pha				pha
.c6e0	5a		phy				phy 								; save Y
.c6e1	08		php				php 								; save action
.c6e2	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c6e4	70 59		bvs $c73f			bvs 	_FPGP_Exit 					; then do nothing.
.c6e6	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c6e8	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c6ea	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c6ec	85 1c		sta $1c				sta 	zLTemp1+2
.c6ee	85 1d		sta $1d				sta 	zLTemp1+3
.c6f0	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.c6f2	38		sec				sec
.c6f3	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c6f5	f0 12		beq $c709			beq 	_FPGP_NoShift 				; ... if any
.c6f7	c9 20		cmp #$20			cmp 	#32
.c6f9	90 02		bcc $c6fd			bcc 	_FPGP_NotMax
.c6fb	a9 20		lda #$20			lda 	#32 						; max of 32.
.c6fd					_FPGP_NotMax:
.c6fd	a8		tay				tay 								; Y is the mask shift count.
.c6fe					_FPGP_ShiftMask:
.c6fe	46 1d		lsr $1d				lsr 	3+zLTemp1
.c700	66 1c		ror $1c				ror 	2+zLTemp1
.c702	66 1b		ror $1b				ror 	1+zLTemp1
.c704	66 1a		ror $1a				ror 	0+zLTemp1
.c706	88		dey				dey
.c707	d0 f5		bne $c6fe			bne 	_FPGP_ShiftMask
.c709					_FPGP_NoShift:
.c709	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c70b	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.c70e					_FPGP_MaskLoop:
.c70e	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c711	28		plp				plp 								; if CC we keep the top part, so we
.c712	08		php				php		 							; flip the mask.
.c713	b0 02		bcs $c717			bcs		_FPGP_NoFlip
.c715	49 ff		eor #$ff			eor 	#$FF
.c717					_FPGP_NoFlip:
.c717	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c719	95 80		sta $80,x			sta 	XS_Mantissa,x
.c71b	e8		inx				inx
.c71c	c8		iny				iny
.c71d	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c71f	d0 ed		bne $c70e			bne 	_FPGP_MaskLoop
.c721	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.c724	28		plp				plp
.c725	08		php				php 								; get action flag on the stack
.c726	90 04		bcc $c72c			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c728	a9 00		lda #$00			lda 	#0
.c72a	95 85		sta $85,x			sta 	XS_Type,x
.c72c					_FPGP_NotFractional:
.c72c	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c72e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c730	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c732	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c734	f0 05		beq $c73b			beq 	_FPGP_Zero 					; if zero, return zero
.c736	20 ee c7	jsr $c7ee			jsr 	FPUNormalise
.c739	80 04		bra $c73f			bra 	_FPGP_Exit 					; and exit
.c73b					_FPGP_Zero:
.c73b	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c73d	95 85		sta $85,x			sta 	XS_Type,x
.c73f					_FPGP_Exit:
.c73f	68		pla				pla 								; throw saved action flag.
.c740	7a		ply				ply
.c741	68		pla				pla
.c742	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c743					FPCompare:
.c743	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c745	48		pha				pha
.c746	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.c748	48		pha				pha
.c749	20 16 c5	jsr $c516			jsr 	FPSubtract 					; calculate X1-X2
.c74c	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c74e	70 2a		bvs $c77a			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c750	68		pla				pla
.c751	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.c754	68		pla				pla
.c755	38		sec				sec
.c756	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.c759	70 14		bvs $c76f			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c75b	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c75c	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c75e	b0 0f		bcs $c76f			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c760	38		sec				sec
.c761	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.c764	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c766	b0 02		bcs $c76a			bcs 	_FPCNotRange 				; keep in range.
.c768	a9 01		lda #$01			lda 	#1
.c76a					_FPCNotRange:
.c76a	38		sec				sec
.c76b	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c76d	b0 0d		bcs $c77c			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c76f					_FPCNotEqual:
.c76f	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c771	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c773	f0 02		beq $c777			beq 	_FPCNE2
.c775	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c777	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c778	80 04		bra $c77e			bra 	_FPCExit
.c77a					_FPCPullZero:
.c77a	68		pla				pla 								; throw saved exponents
.c77b	68		pla				pla
.c77c					_FPCZero:
.c77c	a9 00		lda #$00			lda 	#0 							; and return zero
.c77e					_FPCExit:
.c77e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c77f					FPUCopyX2ToX1:
.c77f	48		pha				pha
.c780	da		phx				phx
.c781	5a		phy				phy
.c782	a0 08		ldy #$08			ldy 	#8
.c784	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.c786	95 80		sta $80,x			sta 	XS_Mantissa,x
.c788	e8		inx				inx
.c789	88		dey				dey
.c78a	10 f8		bpl $c784			bpl 	_FPUC21
.c78c	7a		ply				ply
.c78d	fa		plx				plx
.c78e	68		pla				pla
.c78f	60		rts				rts
.c790					FPUSetInteger:
.c790	48		pha				pha
.c791	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c793	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c795	10 02		bpl $c799			bpl 	_FPUSIExtend
.c797	a9 ff		lda #$ff			lda 	#$FF
.c799					_FPUSIExtend:
.c799	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c79b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c79d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c79f	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c7a1	95 85		sta $85,x			sta 	XS_Type,x
.c7a3	68		pla				pla
.c7a4	60		rts				rts
.c7a5					FPUNegateInteger:
.c7a5	48		pha				pha
.c7a6	38		sec				sec
.c7a7	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c7a9	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c7ab	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c7ad	a9 00		lda #$00			lda 	#0
.c7af	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c7b1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c7b3	a9 00		lda #$00			lda 	#0
.c7b5	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c7b7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c7b9	a9 00		lda #$00			lda 	#0
.c7bb	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c7bd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c7bf	68		pla				pla
.c7c0	60		rts				rts
.c7c1					FPUToFloat:
.c7c1	48		pha				pha
.c7c2	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.c7c4	29 0f		and #$0f			and 	#$0F
.c7c6	f0 24		beq $c7ec			beq 	_FPUFExit
.c7c8	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c7ca	95 85		sta $85,x			sta 	XS_Type,x
.c7cc	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c7ce	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.c7d0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c7d2	10 07		bpl $c7db			bpl		_FPUFPositive
.c7d4	20 a5 c7	jsr $c7a5			jsr 	FPUNegateInteger 			; negate the mantissa
.c7d7	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c7d9	95 85		sta $85,x			sta 	XS_Type,x
.c7db					_FPUFPositive:
.c7db	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c7dd	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c7df	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c7e1	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c7e3	d0 04		bne $c7e9			bne 	_FPUFNonZero
.c7e5	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c7e7	95 85		sta $85,x			sta 	XS_Type,x
.c7e9					_FPUFNonZero:
.c7e9	20 ee c7	jsr $c7ee			jsr 	FPUNormalise 				; normalise the floating point.
.c7ec					_FPUFExit:
.c7ec	68		pla				pla
.c7ed	60		rts				rts
.c7ee					FPUNormalise:
.c7ee	48		pha				pha
.c7ef	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c7f1	70 18		bvs $c80b			bvs 	_FPUNExit
.c7f3	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c7f5	f0 10		beq $c807			beq 	_FPUNSetZero
.c7f7					_FPUNLoop:
.c7f7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c7f9	30 10		bmi $c80b			bmi 	_FPUNExit 					; if so, we are normalised.
.c7fb	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.c7fd	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.c7ff	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.c801	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.c803	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.c805	d0 f0		bne $c7f7			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c807					_FPUNSetZero:
.c807	a9 40		lda #$40			lda 	#$40
.c809	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.c80b					_FPUNExit:
.c80b	68		pla				pla
.c80c	60		rts				rts
.c80d					FPUToInteger:
.c80d	48		pha				pha
.c80e	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.c810	29 01		and #$01			and 	#1
.c812	d0 31		bne $c845			bne 	_FPUTOI_Exit
.c814	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.c816	70 23		bvs $c83b			bvs 	_FPUTOI_Zero
.c818	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c81a	10 1f		bpl $c83b			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c81c	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c81e	b0 2b		bcs $c84b			bcs 	FP_Overflow
.c820					_FPUToIToInteger:
.c820	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c822	c9 a0		cmp #$a0			cmp 	#128+32
.c824	f0 0c		beq $c832			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c826	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.c828	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c82a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c82c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c82e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c830	80 ee		bra $c820			bra 	_FPUToIToInteger 			; keep going.
.c832					_FPUToICheckSign:
.c832	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.c834	10 0f		bpl $c845			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c836	20 a5 c7	jsr $c7a5			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c839	80 0a		bra $c845			bra 	_FPUTOI_Exit
.c83b					_FPUTOI_Zero:
.c83b	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c83d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c83f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c841	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c843	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c845					_FPUToI_Exit:
.c845	a9 01		lda #$01			lda 	#1 							; set type to integer
.c847	95 85		sta $85,x			sta 	XS_Type,x
.c849	68		pla				pla
.c84a	60		rts				rts
.c84b					FP_Overflow:
.c84b	20 79 ae	jsr $ae79			jsr ERR_Handler
>c84e	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c856	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c866					FPUTimes10:
.c866	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c868	85 1a		sta $1a				sta 	ZLTemp1+0
.c86a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c86c	85 1b		sta $1b				sta 	ZLTemp1+1
.c86e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c870	85 1c		sta $1c				sta 	ZLTemp1+2
.c872	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c874	85 1d		sta $1d				sta 	ZLTemp1+3
.c876	20 ab c8	jsr $c8ab			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c879	20 ab c8	jsr $c8ab			jsr 	_FPUT_LSR_ZLTemp1
.c87c	18		clc				clc
.c87d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c87f	65 1a		adc $1a				adc 	ZLTemp1+0
.c881	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c883	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c885	65 1b		adc $1b				adc 	ZLTemp1+1
.c887	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c889	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c88b	65 1c		adc $1c				adc 	ZLTemp1+2
.c88d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c88f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c891	65 1d		adc $1d				adc 	ZLTemp1+3
.c893	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c895	90 0a		bcc $c8a1			bcc 	_FPUTimes10
.c897	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c899	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c89b	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c89d	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c89f	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.c8a1					_FPUTimes10:
.c8a1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c8a3	18		clc				clc
.c8a4	69 03		adc #$03			adc 	#3
.c8a6	95 84		sta $84,x			sta 	XS_Exponent,x
.c8a8	b0 a1		bcs $c84b			bcs 	FP_Overflow 				; error
.c8aa	60		rts				rts
.c8ab					_FPUT_LSR_ZLTemp1:
.c8ab	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c8ad	66 1c		ror $1c				ror 	ZLTemp1+2
.c8af	66 1b		ror $1b				ror 	ZLTemp1+1
.c8b1	66 1a		ror $1a				ror 	ZLTemp1+0
.c8b3	60		rts				rts
.c8b4					FPUScale10A:
.c8b4	5a		phy				phy
.c8b5	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c8b7	f0 37		beq $c8f0			beq 	_FPUScaleExit
.c8b9	da		phx				phx 								; save X
.c8ba	e8		inx				inx
.c8bb	e8		inx				inx
.c8bc	e8		inx				inx
.c8bd	e8		inx				inx
.c8be	e8		inx				inx
.c8bf	e8		inx				inx
.c8c0	a8		tay				tay 								; save power scalar in Y.
.c8c1	a9 00		lda #$00			lda 	#0
.c8c3	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c8c5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c8c7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c8c9	95 85		sta $85,x			sta 	XS_Type,x
.c8cb	a9 80		lda #$80			lda 	#$80
.c8cd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c8cf	a9 81		lda #$81			lda 	#$81
.c8d1	95 84		sta $84,x			sta 	XS_Exponent,x
.c8d3	5a		phy				phy 								; save 10^n on stack.
.c8d4	c0 00		cpy #$00			cpy 	#0
.c8d6	10 05		bpl $c8dd			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c8d8	98		tya				tya
.c8d9	49 ff		eor #$ff			eor 	#$FF
.c8db	1a		inc a				inc 	a
.c8dc	a8		tay				tay
.c8dd					_FPUSAbs:
.c8dd	20 66 c8	jsr $c866			jsr 	FPUTimes10
.c8e0	88		dey				dey
.c8e1	d0 fa		bne $c8dd			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c8e3	68		pla				pla 								; restore count in A
.c8e4	fa		plx				plx 								; restore X pointing to number to scale.
.c8e5	0a		asl a				asl 	a
.c8e6	b0 05		bcs $c8ed			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c8e8	20 45 c6	jsr $c645			jsr 	FPMultiply 					; if clear multiply.
.c8eb	80 03		bra $c8f0			bra		_FPUScaleExit
.c8ed					_FPUSDivide:
.c8ed	20 d2 c5	jsr $c5d2			jsr 	FPDivide
.c8f0					_FPUScaleExit:
.c8f0	7a		ply				ply
.c8f1	60		rts				rts
.c8f2					FPUCopyToNext:
.c8f2	a0 06		ldy #$06			ldy 		#6
.c8f4	da		phx				phx
.c8f5					_FPUCopy1:
.c8f5	b5 80		lda $80,x			lda 	XS_Mantissa,x
.c8f7	95 86		sta $86,x			sta 	XS2_Mantissa,x
.c8f9	e8		inx				inx
.c8fa	88		dey				dey
.c8fb	d0 f8		bne $c8f5			bne 	_FPUCopy1
.c8fd	fa		plx				plx
.c8fe	60		rts				rts
.c8ff					FPUCopyFromNext:
.c8ff	a0 06		ldy #$06			ldy 		#6
.c901	da		phx				phx
.c902					_FPUCopy1:
.c902	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.c904	95 80		sta $80,x			sta 	XS_Mantissa,x
.c906	e8		inx				inx
.c907	88		dey				dey
.c908	d0 f8		bne $c902			bne 	_FPUCopy1
.c90a	fa		plx				plx
.c90b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c90c					FPToString:
.c90c	48		pha				pha
.c90d	5a		phy				phy
.c90e	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.c910	50 0a		bvc $c91c			bvc 		_FPTSIsFloat 			; if zero,
.c912					_FPTSZero:
.c912	a9 30		lda #$30			lda 		#"0"
.c914	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter
.c917					_FPTSExit:
.c917	7a		ply				ply
.c918	68		pla				pla
.c919	60		rts				rts
.c91a	80 fb		bra $c917			bra 		_FPTSExit
.c91c					_FPTSIsFloat:
.c91c	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.c91e	10 09		bpl $c929			bpl 		_FPTSNotSigned
.c920	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c922	95 85		sta $85,x			sta 		XS_Type,x
.c924	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c926	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter
.c929					_FPTSNotSigned:
.c929	b5 84		lda $84,x			lda 		XS_Exponent,x
.c92b	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c92d	b0 09		bcs $c938			bcs 		_FPTSExponent
.c92f	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c931	90 05		bcc $c938			bcc 		_FPTSExponent 			;
.c933					_FPTSStandard:
.c933	20 77 c9	jsr $c977			jsr 		FPTOutputBody 			; output the body.
.c936	80 df		bra $c917			bra 		_FPTSExit
.c938					_FPTSExponent:
.c938	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c93a	8d 9d 03	sta $039d			sta 		ExpCount
.c93d					_FPTSExponentLoop:
.c93d	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c93f	10 0e		bpl $c94f			bpl 		_FPTSTimes
.c941	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c943	90 14		bcc $c959			bcc 		_FPTSScaledToExp
.c945	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c947	20 b4 c8	jsr $c8b4			jsr 		FPUScale10A
.c94a	ee 9d 03	inc $039d			inc 		ExpCount
.c94d	80 ee		bra $c93d			bra 		_FPTSExponentLoop
.c94f					_FPTSTimes:
.c94f	a9 01		lda #$01			lda 		#1
.c951	20 b4 c8	jsr $c8b4			jsr 		FPUScale10A
.c954	ce 9d 03	dec $039d			dec 		ExpCount
.c957	80 e4		bra $c93d			bra 		_FPTSExponentLoop
.c959					_FPTSScaledToExp:
.c959	20 77 c9	jsr $c977			jsr 		FPTOutputBody 			; output the body.
.c95c	a9 65		lda #$65			lda 		#"e"					; output E
.c95e	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter
.c961	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.c964	95 80		sta $80,x			sta 		XS_Mantissa,x
.c966	29 80		and #$80			and 		#$80 					; sign extend it
.c968	f0 02		beq $c96c			beq 		_FPTSSExt
.c96a	a9 ff		lda #$ff			lda 		#$FF
.c96c					_FPTSSExt:
.c96c	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.c96e	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.c970	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.c972	20 d5 c3	jsr $c3d5			jsr 		INTToString 			; output the exponent.
.c975	80 a0		bra $c917			bra			_FPTSExit 				; and exit.
.c977					FPTOutputBody:
.c977	20 f2 c8	jsr $c8f2			jsr 		FPUCopyToNext 			; copy to next slot.
.c97a	20 0d c8	jsr $c80d			jsr 		FPUToInteger 			; convert to an integer
.c97d	20 d5 c3	jsr $c3d5			jsr 		INTToString 			; output the main integer part.
.c980	20 ff c8	jsr $c8ff			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c983	20 cd c6	jsr $c6cd			jsr 		FPFractionalPart 		; get the decimal part.
.c986	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.c988	70 3c		bvs $c9c6			bvs 		_FPTOExit 				; if not, exit now.
.c98a	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c98c	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter
.c98f					_FPOutLoop:
.c98f	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.c991	70 1d		bvs $c9b0			bvs 		_FPStripZeros 			; strip trailing zeros
.c993	20 66 c8	jsr $c866			jsr 		FPUTimes10 				; multiply by 10
.c996	20 f2 c8	jsr $c8f2			jsr 		FPUCopyToNext			; copy to next slot.
.c999	20 0d c8	jsr $c80d			jsr 		FPUToInteger 			; convert to integer
.c99c	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.c99e	09 30		ora #$30			ora 		#"0"
.c9a0	20 73 c4	jsr $c473			jsr 		ITSOutputCharacter
.c9a3	20 ff c8	jsr $c8ff			jsr 		FPUCopyFromNext 		; get it back
.c9a6	20 cd c6	jsr $c6cd			jsr 		FPFractionalPart 		; get fractional part
.c9a9	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.c9ac	c9 0b		cmp #$0b			cmp 	 	#11
.c9ae	90 df		bcc $c98f			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c9b0					_FPStripZeros:
.c9b0	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.c9b3					_FPStripLoop:
.c9b3	88		dey				dey 								; back one, if at start then no strip
.c9b4	f0 10		beq $c9c6			beq 		_FPToExit
.c9b6	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.c9b9	c9 30		cmp #$30			cmp 		#"0"
.c9bb	f0 f6		beq $c9b3			beq 		_FPStripLoop
.c9bd	c8		iny				iny
.c9be	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c9c0	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.c9c3	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.c9c6					_FPTOExit:
.c9c6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c9c7					FPFromString:
.c9c7	48		pha				pha 								; push A
.c9c8	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c9ca	c9 2e		cmp #$2e			cmp 	#"."
.c9cc	f0 03		beq $c9d1			beq	 	_FPFIsDecimal
.c9ce	4c 2d ca	jmp $ca2d			jmp 	_FPFNotDecimal
.c9d1					_FPFIsDecimal:
.c9d1	c8		iny				iny 								; consume the decimal.
.c9d2	20 c1 c7	jsr $c7c1			jsr 	FPUToFloat 					; convert the integer to float.
.c9d5	da		phx				phx 								; save X.
.c9d6	5a		phy				phy 								; save decimal start position
.c9d7	e8		inx				inx
.c9d8	e8		inx				inx
.c9d9	e8		inx				inx
.c9da	e8		inx				inx
.c9db	e8		inx				inx
.c9dc	e8		inx				inx
.c9dd	20 8b c4	jsr $c48b			jsr 	INTFromStringY 				; get the part after the DP.
.c9e0	20 c1 c7	jsr $c7c1			jsr 	FPUToFloat 					; convert that to a float.
.c9e3	68		pla				pla 								; calculate - chars consumed.
.c9e4	8c 9c 03	sty $039c			sty 	ExpTemp
.c9e7	38		sec				sec
.c9e8	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.c9eb	20 b4 c8	jsr $c8b4			jsr 	FPUScale10A 				; scale it by 10^AC
.c9ee	fa		plx				plx 								; restore original X
.c9ef	20 1e c5	jsr $c51e			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c9f2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c9f4	c9 45		cmp #$45			cmp 	#"E"
.c9f6	f0 04		beq $c9fc			beq 	_FPFExponent
.c9f8	c9 65		cmp #$65			cmp 	#"e"
.c9fa	d0 31		bne $ca2d			bne 	_FPFNotDecimal 				; no, then exit normally.
.c9fc					_FPFExponent:
.c9fc	c8		iny				iny 								; skip over E symbol.
.c9fd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c9ff	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.ca01	d0 01		bne $ca04			bne 	_FPFGotSign
.ca03	c8		iny				iny 								; if it was - skip over it.
.ca04					_FPFGotSign:
.ca04	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.ca05	da		phx				phx
.ca06	e8		inx				inx
.ca07	e8		inx				inx
.ca08	e8		inx				inx
.ca09	e8		inx				inx
.ca0a	e8		inx				inx
.ca0b	e8		inx				inx
.ca0c	20 8b c4	jsr $c48b			jsr 	INTFromStringY 				; get the exponent
.ca0f	fa		plx				plx 								; restore X.
.ca10	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.ca12	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.ca14	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.ca16	d0 17		bne $ca2f			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.ca18	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.ca1a	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.ca1c	b0 11		bcs $ca2f			bcs 	_FPFXOverflow
.ca1e	68		pla				pla 								; get direction
.ca1f	d0 07		bne $ca28			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.ca21	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.ca23	49 ff		eor #$ff			eor 	#$FF
.ca25	1a		inc a				inc 	a
.ca26	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.ca28					_FPFXScale:
.ca28	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.ca2a	20 b4 c8	jsr $c8b4			jsr 	FPUScale10A 				; scale by the exponent.
.ca2d					_FPFNotDecimal:
.ca2d	68		pla				pla
.ca2e	60		rts				rts
.ca2f					_FPFXOverflow:
.ca2f	20 79 ae	jsr $ae79			jsr 	ERR_Handler
>ca32	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>ca3a	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.ca41					Unary_Rnd:
.ca41	20 0d b8	jsr $b80d			jsr 	EvaluateNumberX 			; get value
.ca44	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; check right bracket.
.ca47	20 8b ba	jsr $ba8b			jsr 	GetSignCurrent 				; get sign -1,0,1.
.ca4a	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.ca4c	30 10		bmi $ca5e			bmi 	_URSetSeed
.ca4e	f0 28		beq $ca78			beq 	_URMakeRandom 				; if zero return same number.
.ca50	da		phx				phx
.ca51	a2 00		ldx #$00			ldx 	#0
.ca53	20 af ca	jsr $caaf			jsr 	Random16
.ca56	a2 02		ldx #$02			ldx 	#2
.ca58	20 af ca	jsr $caaf			jsr 	Random16
.ca5b	fa		plx				plx
.ca5c	80 1a		bra $ca78			bra 	_URMakeRandom
.ca5e					_URSetSeed:
.ca5e	20 c1 c7	jsr $c7c1			jsr 	FPUToFloat 					; make it a float to twiddle it.
.ca61	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.ca63	8d a3 03	sta $03a3			sta 	RandomSeed+0
.ca66	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.ca68	8d a4 03	sta $03a4			sta 	RandomSeed+1
.ca6b	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.ca6d	8d a5 03	sta $03a5			sta 	RandomSeed+2
.ca70	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.ca72	0a		asl a				asl 	a
.ca73	49 db		eor #$db			eor 	#$DB
.ca75	8d a6 03	sta $03a6			sta 	RandomSeed+3
.ca78					_URMakeRandom:
.ca78	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.ca7b	0d a4 03	ora $03a4			ora 	RandomSeed+1
.ca7e	0d a5 03	ora $03a5			ora 	RandomSeed+2
.ca81	0d a6 03	ora $03a6			ora 	RandomSeed+3
.ca84	d0 0a		bne $ca90			bne 	_URNotZero
.ca86	a9 47		lda #$47			lda 	#$47
.ca88	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.ca8b	a9 3d		lda #$3d			lda 	#$3D
.ca8d	8d a6 03	sta $03a6			sta 	RandomSeed+3
.ca90					_URNotZero:
.ca90	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.ca93	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ca95	ad a4 03	lda $03a4			lda 	RandomSeed+1
.ca98	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ca9a	ad a5 03	lda $03a5			lda 	RandomSeed+2
.ca9d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ca9f	ad a6 03	lda $03a6			lda 	RandomSeed+3
.caa2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.caa4	a9 00		lda #$00			lda 	#$00 						; set type to float.
.caa6	95 85		sta $85,x			sta 	XS_Type,x
.caa8	a9 80		lda #$80			lda 	#$80
.caaa	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.caac	4c ee c7	jmp $c7ee			jmp 	FPUNormalise
.caaf					Random16:
.caaf	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.cab2	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.cab5	90 08		bcc $cabf			bcc 	_R16_NoXor
.cab7	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.caba	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.cabc	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.cabf					_R16_NoXor:
.cabf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.cac0					Unary_Int:
.cac0	20 0d b8	jsr $b80d			jsr 	EvaluateNumberX 			; get value
.cac3	20 4b be	jsr $be4b			jsr 	CheckNextRParen 			; check right bracket.
.cac6	4c 0d c8	jmp $c80d			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.cac9	80 fe		bra $cac9	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
