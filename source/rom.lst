
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Tue Aug 27 16:59:12 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0497					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>049f					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>04a7					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>04a8					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04aa					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04ac					Tim_SR:		.byte ? 						; Processor Status
>04ad					Tim_A:		.byte ? 						; Processor Registers
>04ae					Tim_X:		.byte ?
>04af					Tim_Y:		.byte ?
>04b0					Tim_Z:		.byte ?
>04b1					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=$4000					VariableMemory = $4000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	09 02 00 c7 01 b8 42 be			.byte	$09,$02,$00,$c7,$01,$b8,$42,$be
>1008	00 0c 03 00 dc 01 b8 40			.byte	$00,$0c,$03,$00,$dc,$01,$b8,$40
>1010	be 84 fe 02 00 1b 04 00			.byte	$be,$84,$fe,$02,$00,$1b,$04,$00
>1018	d6 fe 14 50 61 73 73 65			.byte	$d6,$fe,$14,$50,$61,$73,$73,$65
>1020	64 20 41 73 73 69 67 6e			.byte	$64,$20,$41,$73,$73,$69,$67,$6e
>1028	6d 65 6e 74 2e c0 c4 00			.byte	$6d,$65,$6e,$74,$2e,$c0,$c4,$00
>1030	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c b4 86 01	jmp $0186b4		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae b1 04	ldx $04b1			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad ac 04	lda $04ac			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad ad 04	lda $04ad			lda 	TIM_A 						; restore AXYZ
.018281	ae ae 04	ldx $04ae			ldx 	TIM_X
.018284	ac af 04	ldy $04af			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d ab 04	sta $04ab			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d aa 04	sta $04aa			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd a8 04	lda $04a8,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d ad 04	sta $04ad			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e ae 04	stx $04ae			stx 	TIM_X
.01838b	8c af 04	sty $04af			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d ac 04	sta $04ac			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d a9 04	sta $04a9			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d a8 04	sta $04a8			sta 	TIM_PC 						; high byte
.01839a	ad a9 04	lda $04a9			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce a8 04	dec $04a8			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce a9 04	dec $04a9			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e b1 04	stx $04b1			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d a9 04	sta $04a9			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d a8 04	sta $04a8			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d ac 04	sta $04ac,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	8d 08 03	sta $0308			sta 	XS_Mantissa
.018437	c8		iny				iny
.018438	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01843a	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01843d	fa		plx				plx 								; address in XY
.01843e	7a		ply				ply
.01843f	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018440	d0 01		bne $018443			bne 	_EHNoSkip
.018442	c8		iny				iny
.018443					_EHNoSkip:
.018443	20 64 84	jsr $018464			jsr 	PrintROMMessage 			; print message from ROM.
.018446	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018449	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01844c	f0 0c		beq $01845a			beq 	_EHNoLine
.01844e	a2 5f		ldx #$5f			ldx 	#_EHAt & $FF 				; print " at "
.018450	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018452	20 64 84	jsr $018464			jsr 	PrintROMMessage
.018455	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018457	20 79 84	jsr $018479			jsr 	Print16BitInteger
.01845a					_EHNoLine:
.01845a	80 fe		bra $01845a			bra 	_EHNoLine
.01845c	4c d4 86	jmp $0186d4			jmp 	WarmStart
>01845f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018464					PrintROMMessage:
.018464	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018466	84 1b		sty $1b				sty 	zLTemp1+1
.018468	4b		phk				phk
.018469	68		pla				pla
.01846a	85 1c		sta $1c				sta 	ZLTemp1+2
.01846c	a0 00		ldy #$00			ldy 	#0
.01846e					_PRMLoop:
.01846e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018470	f0 06		beq $018478			beq		_PRMExit
.018472	c8		iny				iny
.018473	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018476	80 f6		bra $01846e			bra 	_PRMLoop
.018478					_PRMExit:
.018478	60		rts				rts
.018479					Print16BitInteger:
.018479	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01847b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.01847e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018481	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.018484	aa		tax				tax 								; convert bottom level.
.018485	20 c1 96	jsr $0196c1			jsr 	INTToString 				; make string
.018488	a2 00		ldx #$00			ldx 	#0 							; print buffer
.01848a	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.01848d	f0 06		beq $018495			beq 	_P1Exit
.01848f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018492	e8		inx				inx
.018493	80 f5		bra $01848a			bra 	_P1Loop
.018495	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.018496					VectorTable:
>018496	8a 8a					.word BinaryOp_And         & $FFFF ; $80 and
>018498	b2 8a					.word BinaryOp_Or          & $FFFF ; $81 or
>01849a	da 8a					.word BinaryOp_Xor         & $FFFF ; $82 xor
>01849c	da 8a					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01849e	1e 8b					.word Binary_Equal         & $FFFF ; $84 =
>0184a0	3d 8b					.word Binary_NotEqual      & $FFFF ; $85 <>
>0184a2	46 8b					.word Binary_Less          & $FFFF ; $86 <
>0184a4	4f 8b					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a6	61 8b					.word Binary_Greater       & $FFFF ; $88 >
>0184a8	58 8b					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184aa	f6 8b					.word BinaryOp_Add         & $FFFF ; $8a +
>0184ac	16 8c					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184ae	29 8c					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184b0	3c 8c					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184b2	52 85					.word NotImplemented       & $FFFF ; $8e ^
>0184b4	52 85					.word NotImplemented       & $FFFF ; $8f if
>0184b6	52 85					.word NotImplemented       & $FFFF ; $90 while
>0184b8	52 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184ba	52 85					.word NotImplemented       & $FFFF ; $92 for
>0184bc	52 85					.word NotImplemented       & $FFFF ; $93 then
>0184be	52 85					.word NotImplemented       & $FFFF ; $94 endif
>0184c0	52 85					.word NotImplemented       & $FFFF ; $95 wend
>0184c2	52 85					.word NotImplemented       & $FFFF ; $96 until
>0184c4	52 85					.word NotImplemented       & $FFFF ; $97 next
>0184c6	52 85					.word NotImplemented       & $FFFF ; $98 not
>0184c8	52 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184ca	70 8d					.word Unary_Abs            & $FFFF ; $9a abs(
>0184cc	c8 8e					.word Unary_Asc            & $FFFF ; $9b asc(
>0184ce	a6 9e					.word Unary_Int            & $FFFF ; $9c int(
>0184d0	8e 8d					.word Unary_Peek           & $FFFF ; $9d peek(
>0184d2	1d 9e					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184d4	02 8e					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d6	09 8f					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d8	20 8f					.word Unary_Right          & $FFFF ; $a1 right$(
>0184da	ee 8e					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184dc	82 90					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184de	95 8e					.word Unary_Str            & $FFFF ; $a4 str$(
>0184e0	24 8e					.word Unary_Val            & $FFFF ; $a5 val(
>0184e2	df 8e					.word Unary_Len            & $FFFF ; $a6 len(
>0184e4	9e 8f					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e6	52 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e8	52 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184ea	52 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184ec	52 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184ee	52 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184f0	52 85					.word NotImplemented       & $FFFF ; $ad log(
>0184f2	52 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184f4	f8 8f					.word Unary_Dec            & $FFFF ; $af dec(
>0184f6	92 8d					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f8	96 8d					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184fa	ca 8d					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184fc	1e 8d					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184fe	60 90					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018500	52 85					.word NotImplemented       & $FFFF ; $b5 pos(
>018502	52 85					.word NotImplemented       & $FFFF ; $b6 tab(
>018504	52 85					.word NotImplemented       & $FFFF ; $b7 $
>018506	52 85					.word NotImplemented       & $FFFF ; $b8 $(
>018508	52 85					.word NotImplemented       & $FFFF ; $b9 #
>01850a	52 85					.word NotImplemented       & $FFFF ; $ba #(
>01850c	52 85					.word NotImplemented       & $FFFF ; $bb %
>01850e	52 85					.word NotImplemented       & $FFFF ; $bc %(
>018510	52 85					.word NotImplemented       & $FFFF ; $bd (
>018512	52 85					.word NotImplemented       & $FFFF ; $be )
>018514	52 85					.word NotImplemented       & $FFFF ; $bf ,
>018516	e2 87					.word Command_COLON        & $FFFF ; $c0 :
>018518	52 85					.word NotImplemented       & $FFFF ; $c1 ;
>01851a	52 85					.word NotImplemented       & $FFFF ; $c2 def
>01851c	97 88					.word Command_CLR          & $FFFF ; $c3 clr
>01851e	a8 88					.word Command_STOP         & $FFFF ; $c4 stop
>018520	52 85					.word NotImplemented       & $FFFF ; $c5 data
>018522	52 85					.word NotImplemented       & $FFFF ; $c6 read
>018524	e2 86					.word Command_DIM          & $FFFF ; $c7 dim
>018526	52 85					.word NotImplemented       & $FFFF ; $c8 to
>018528	52 85					.word NotImplemented       & $FFFF ; $c9 step
>01852a	52 85					.word NotImplemented       & $FFFF ; $ca gosub
>01852c	52 85					.word NotImplemented       & $FFFF ; $cb return
>01852e	52 85					.word NotImplemented       & $FFFF ; $cc goto
>018530	04 88					.word Command_END          & $FFFF ; $cd end
>018532	52 85					.word NotImplemented       & $FFFF ; $ce input
>018534	e3 87					.word Command_LET          & $FFFF ; $cf let
>018536	52 85					.word NotImplemented       & $FFFF ; $d0 list
>018538	52 85					.word NotImplemented       & $FFFF ; $d1 new
>01853a	52 85					.word NotImplemented       & $FFFF ; $d2 old
>01853c	52 85					.word NotImplemented       & $FFFF ; $d3 on
>01853e	52 85					.word NotImplemented       & $FFFF ; $d4 restore
>018540	52 85					.word NotImplemented       & $FFFF ; $d5 poke
>018542	08 88					.word Command_PRINT        & $FFFF ; $d6 print
>018544	68 87					.word Command_RUN          & $FFFF ; $d7 run
>018546	52 85					.word NotImplemented       & $FFFF ; $d8 wait
>018548	52 85					.word NotImplemented       & $FFFF ; $d9 sys
>01854a	52 85					.word NotImplemented       & $FFFF ; $da doke
>01854c	52 85					.word NotImplemented       & $FFFF ; $db loke
>01854e	7b 88					.word Command_ASSERT       & $FFFF ; $dc assert
>018550	52 85					.word NotImplemented       & $FFFF ; $dd get
.018552					NotImplemented:
.018552	20 2f 84	jsr $01842f			jsr ERR_Handler
>018555	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01855d	65 6d 65 6e 74 65 64 00
.018565					BinaryPrecedence:
>018565	01					.byte 1    ; $80 and
>018566	01					.byte 1    ; $81 or
>018567	01					.byte 1    ; $82 xor
>018568	01					.byte 1    ; $83 eor
>018569	02					.byte 2    ; $84 =
>01856a	02					.byte 2    ; $85 <>
>01856b	02					.byte 2    ; $86 <
>01856c	02					.byte 2    ; $87 <=
>01856d	02					.byte 2    ; $88 >
>01856e	02					.byte 2    ; $89 >=
>01856f	03					.byte 3    ; $8a +
>018570	03					.byte 3    ; $8b -
>018571	04					.byte 4    ; $8c *
>018572	04					.byte 4    ; $8d /
>018573	05					.byte 5    ; $8e ^
.018574					KeywordText:
>018574	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018577	4f d2					.byte $4f,$d2                          ; $81 or
>018579	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01857c	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01857f	bd					.byte $bd                              ; $84 =
>018580	3c be					.byte $3c,$be                          ; $85 <>
>018582	bc					.byte $bc                              ; $86 <
>018583	3c bd					.byte $3c,$bd                          ; $87 <=
>018585	be					.byte $be                              ; $88 >
>018586	3e bd					.byte $3e,$bd                          ; $89 >=
>018588	ab					.byte $ab                              ; $8a +
>018589	ad					.byte $ad                              ; $8b -
>01858a	aa					.byte $aa                              ; $8c *
>01858b	af					.byte $af                              ; $8d /
>01858c	de					.byte $de                              ; $8e ^
>01858d	49 c6					.byte $49,$c6                          ; $8f if
>01858f	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018594	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>01859a	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01859d	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0185a1	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0185a6	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185aa	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185af	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185b3	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185b6	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b9	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185bd	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185c1	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185c5	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185ca	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185ce	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185d2	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d8	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185df	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185e4	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e8	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185ed	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185f1	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185f5	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185fa	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185fe	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018602	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018606	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01860a	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01860e	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018612	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018616	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01861a	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01861f	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018624	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018628	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01862c	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018631	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018635	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018639	a4					.byte $a4                              ; $b7 $
>01863a	24 a8					.byte $24,$a8                          ; $b8 $(
>01863c	a3					.byte $a3                              ; $b9 #
>01863d	23 a8					.byte $23,$a8                          ; $ba #(
>01863f	a5					.byte $a5                              ; $bb %
>018640	25 a8					.byte $25,$a8                          ; $bc %(
>018642	a8					.byte $a8                              ; $bd (
>018643	a9					.byte $a9                              ; $be )
>018644	ac					.byte $ac                              ; $bf ,
>018645	ba					.byte $ba                              ; $c0 :
>018646	bb					.byte $bb                              ; $c1 ;
>018647	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>01864a	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01864d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>018651	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018655	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018659	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01865c	54 cf					.byte $54,$cf                          ; $c8 to
>01865e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018662	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>018667	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>01866d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018671	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>018674	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018679	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>01867c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>018680	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>018683	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>018686	4f ce					.byte $4f,$ce                          ; $d3 on
>018688	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>01868f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>018693	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018698	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>01869b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>01869f	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0186a2	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0186a6	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0186aa	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0186b0	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0186b3	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.0186b4					BASIC_Start:
.0186b4	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186b7	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186ba	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186bc	8d 04 03	sta $0304			sta 	LocalVector
.0186bf	8d 00 03	sta $0300			sta 	UserVector
.0186c2	a9 12		lda #$12			lda 	#USRDefault & $FF 			; reset USR vector
.0186c4	8d 01 03	sta $0301			sta 	UserVector+1
.0186c7	a9 8e		lda #$8e			lda 	#(USRDefault >> 8) & $FF
.0186c9	8d 02 03	sta $0302			sta 	UserVector+2
.0186cc	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186ce	8d 03 03	sta $0303			sta 	UserVector+3
.0186d1	20 97 88	jsr $018897			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186d4					WarmStart:
.0186d4	c2 30		rep #$30			rep 	#$30
.0186d6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186d9	1b		tcs				tcs
.0186da	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186dd	e2 30		sep #$30			sep 	#$30
.0186df	4c 68 87	jmp $018768			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.0186e2					Command_DIM:
.0186e2	5a		phy				phy 								; save Y which is the start of the name.
.0186e3	20 f8 91	jsr $0191f8			jsr 	VariableExtract 			; get the identifier
.0186e6	ad 85 04	lda $0485			lda 	Var_Type 					; check it is an array
.0186e9	29 01		and #$01			and 	#1
.0186eb	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0186ed	d0 6b		bne $01875a			bne 	_CDIError
.0186ef	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.0186f1	8d a7 04	sta $04a7			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0186f4					_CDIGetDimension:
.0186f4	ad a7 04	lda $04a7			lda 	UsrArrayIdx 				; done too many ?
.0186f7	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0186f9	f0 5f		beq $01875a			beq 	_CDIError
.0186fb	20 b3 88	jsr $0188b3			jsr 	EvaluateExpression 			; evaluate an index size
.0186fe	ad 09 03	lda $0309			lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018701	29 80		and #$80			and 	#$80
.018703	0d 0a 03	ora $030a			ora 	XS_Mantissa+2
.018706	0d 0b 03	ora $030b			ora 	XS_Mantissa+3
.018709	d0 4f		bne $01875a			bne 	_CDIError
.01870b	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy into the array table.
.01870e	18		clc				clc 								; add 1 - max index => size.
.01870f	ad 08 03	lda $0308			lda 	XS_Mantissa+0
.018712	69 01		adc #$01			adc 	#1
.018714	9d 9f 04	sta $049f,x			sta 	UsrArrayDef+0,x
.018717	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.01871a	69 00		adc #$00			adc 	#0
.01871c	9d a0 04	sta $04a0,x			sta 	UsrArrayDef+1,x
.01871f	30 39		bmi $01875a			bmi 	_CDIError 					; could be dim a(32767)
.018721	e8		inx				inx 								; bump index.
.018722	e8		inx				inx
.018723	8e a7 04	stx $04a7			stx 	UsrArrayIdx
.018726	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018728	c8		iny				iny
.018729	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.01872b	f0 c7		beq $0186f4			beq 	_CDIGetDimension
.01872d	88		dey				dey
.01872e	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; closing ) present ?
.018731	ae a7 04	ldx $04a7			ldx 	UsrArrayIdx 				; copy USR array to default
.018734	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018736	9d 98 04	sta $0498,x			sta 	ArrayDef+1,x
.018739					_CDICopy:
.018739	bd 9f 04	lda $049f,x			lda 	UsrArrayDef,x
.01873c	9d 97 04	sta $0497,x			sta 	ArrayDef,x
.01873f	ca		dex				dex
.018740	10 f7		bpl $018739			bpl 	_CDICopy
.018742	68		pla				pla									; position of array identifier
.018743	5a		phy				phy 								; save end position.
.018744	a8		tay				tay 								; point to identifier
.018745	20 f8 91	jsr $0191f8			jsr 	VariableExtract 			; get the identifier
.018748	20 9a 94	jsr $01949a			jsr 	VariableLocate 				; check if it exists already.
.01874b	b0 0d		bcs $01875a			bcs 	_CDIError
.01874d	20 84 92	jsr $019284			jsr 	VariableCreate 				; create it using the current ArrayDef
.018750	7a		ply				ply 								; restore code position
.018751	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018753	c8		iny				iny
.018754	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018756	f0 8a		beq $0186e2			beq 	Command_DIM
.018758	88		dey				dey
.018759	60		rts				rts
.01875a					_CDIError:
.01875a	20 2f 84	jsr $01842f			jsr ERR_Handler
>01875d	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018765					_CDISyntax:
.018765	4c 00 84	jmp $018400			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018768					Command_RUN:
.018768	20 97 88	jsr $018897			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.01876b	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01876d	85 16		sta $16				sta 	zCodePtr+0
.01876f	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018771	85 17		sta $17				sta 	zCodePtr+1
.018773	a9 00		lda #$00			lda 	#0
.018775	85 18		sta $18				sta 	zCodePtr+2
.018777	85 19		sta $19				sta 	zCodePtr+3
.018779	a0 03		ldy #$03			ldy 	#3
.01877b					RUN_NewLine:
.01877b	a0 00		ldy #$00			ldy 	#0
.01877d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01877f	c8		iny				iny
.018780	c8		iny				iny
.018781	c8		iny				iny
.018782	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018784	d0 16		bne $01879c			bne 	RUN_NextCommand
.018786	4c a8 88	jmp $0188a8			jmp 	Command_STOP 				; go do the command code.
.018789					RUN_Skip:
.018789	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01878b	c8		iny				iny 								; skip
.01878c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01878e	90 0c		bcc $01879c			bcc 	_SEDone 					; so just skip over it.
.018790	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018792	90 07		bcc $01879b			bcc 	_SEDouble
.018794	98		tya				tya 								; this is Y + 1
.018795	18		clc				clc
.018796	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018798	a8		tay				tay 								; back in Y.
.018799	88		dey				dey 								; fix up, one for the +1, one for the iny
.01879a	88		dey				dey
.01879b					_SEDouble:
.01879b	c8		iny				iny
.01879c					_SEDone:
.01879c					RUN_NextCommand:
.01879c	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01879e	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0187a0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187a2	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0187a4	f0 e3		beq $018789			beq 	RUN_Skip
.0187a6	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0187a8	d0 0f		bne $0187b9			bne 	RUN_Execute
.0187aa					RUN_NextLine:
.0187aa	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0187ac	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0187ae	18		clc				clc
.0187af	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0187b1	85 16		sta $16				sta 	zCodePtr
.0187b3	90 02		bcc $0187b7			bcc 	_SNLNoCarry
.0187b5	e6 17		inc $17				inc 	zCodePtr+1
.0187b7					_SNLNoCarry:
.0187b7	80 c2		bra $01877b			bra 	RUN_NewLine 				; go do the new line code
.0187b9					RUN_Execute:
.0187b9	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0187bb	b0 1e		bcs $0187db			bcs 	RUN_Extension
.0187bd	c8		iny				iny
.0187be	0a		asl a				asl 	a 							; double the character read.
.0187bf	90 14		bcc $0187d5			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0187c1	aa		tax				tax 								; ready to look up.
.0187c2	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into LocalVector
.0187c6	8d 05 03	sta $0305			sta 	LocalVector+1
.0187c9	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0187cd	8d 06 03	sta $0306			sta 	LocalVector+2
.0187d0	20 c3 89	jsr $0189c3			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0187d3	80 c7		bra $01879c			bra 	RUN_NextCommand 			; do the next command.
.0187d5					RUN_Default:
.0187d5	88		dey				dey
.0187d6	20 e3 87	jsr $0187e3			jsr 	Command_LET 				; and try LET.
.0187d9	80 c1		bra $01879c			bra 	RUN_NextCommand
.0187db					RUN_Extension:
.0187db	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0187dd	f0 aa		beq $018789			beq 	RUN_Skip 					; skip over it.
.0187df	4c 00 84	jmp $018400			jmp 	SyntaxError
.0187e2					Command_COLON:
.0187e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.0187e3					Command_LET:
.0187e3	20 8d 91	jsr $01918d			jsr 	VariableFind 				; get reference to one variable.
.0187e6	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.0187e8	20 d3 90	jsr $0190d3			jsr 	CheckNextToken
.0187eb	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.0187ed	48		pha				pha
.0187ee	a5 23		lda $23				lda 	zVarDataPtr+1
.0187f0	48		pha				pha
.0187f1	a5 24		lda $24				lda 	zVarType
.0187f3	48		pha				pha
.0187f4	20 b3 88	jsr $0188b3			jsr 	EvaluateExpression 			; evaluate the RHS.
.0187f7	68		pla				pla 								; restore target variable information.
.0187f8	85 24		sta $24				sta 	zVarType
.0187fa	68		pla				pla
.0187fb	85 23		sta $23				sta 	zVarDataPtr+1
.0187fd	68		pla				pla
.0187fe	85 22		sta $22				sta 	zVarDataPtr
.018800	20 3f 95	jsr $01953f			jsr 	VariableSet 				; set the value out.
.018803	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018804					Command_END:
>018804	02						.byte 	2
.018805	4c d4 86	jmp $0186d4			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018808					Command_PRINT:
.018808	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01880a	c9 00		cmp #$00			cmp 	#0 							; end
.01880c	f0 69		beq $018877			beq 	_CPR_NewLine
.01880e	c9 c0		cmp #$c0			cmp 	#token_Colon
.018810	f0 65		beq $018877			beq 	_CPR_NewLine
.018812	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018814	f0 54		beq $01886a			beq 	_CPR_Skip
.018816	c9 bf		cmp #$bf			cmp 	#token_Comma
.018818	f0 4d		beq $018867			beq 	_CPR_Tab
.01881a	20 b3 88	jsr $0188b3			jsr 	EvaluateExpression 			; get expression.
.01881d	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018820	29 02		and #$02			and 	#2
.018822	d0 25		bne $018849			bne 	_CPR_String 				; if type = 2 output as string.
.018824					_CPR_Number:
.018824	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018826	8d 04 04	sta $0404			sta 	NumBufX
.018829	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.01882c	4a		lsr a				lsr 	a
.01882d	b0 05		bcs $018834			bcs 	_CPRInt 					; if msb set do as integer
.01882f	20 d5 9c	jsr $019cd5			jsr 	FPToString 					; call fp to str otherwise
.018832	80 03		bra $018837			bra 	_CPRNPrint
.018834	20 c1 96	jsr $0196c1	_CPRInt:jsr 	IntToString
.018837					_CPRNPrint:
.018837	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.01883a	c9 2d		cmp #$2d			cmp 	#"-"
.01883c	f0 05		beq $018843			beq 	_CPRNoSpace
.01883e	a9 20		lda #$20			lda 	#" "						; print the leading space
.018840	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.018843					_CPRNoSpace:
.018843	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.018845	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.018847	80 06		bra $01884f			bra 	_CPRPrint
.018849					_CPR_String:
.018849	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.01884c	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.01884f					_CPRPrint:
.01884f	86 1e		stx $1e				stx 	zGenPtr
.018851	85 1f		sta $1f				sta 	zGenPtr+1
.018853	5a		phy				phy
.018854	a0 00		ldy #$00			ldy 	#0							; get length into X
.018856	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018858	aa		tax				tax
.018859	f0 09		beq $018864			beq 	_CPREndPrint 				; nothing to print
.01885b					_CPRLoop:
.01885b	c8		iny				iny
.01885c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01885e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018861	ca		dex				dex
.018862	d0 f7		bne $01885b			bne 	_CPRLoop
.018864					_CPREndPrint:
.018864	7a		ply				ply
.018865	80 a1		bra $018808			bra 	Command_Print
.018867					_CPR_Tab:
.018867	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.01886a					_CPR_Skip:
.01886a	c8		iny				iny
.01886b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01886d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01886f	f0 09		beq $01887a			beq 	_CPR_Exit
.018871	c9 00		cmp #$00			cmp 	#0
.018873	d0 93		bne $018808			bne 	Command_PRINT 				; if not go round again.
.018875	80 03		bra $01887a			bra 	_CPR_Exit
.018877					_CPR_NewLine:
.018877	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.01887a					_CPR_Exit:
.01887a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.01887b					Command_ASSERT:
.01887b	20 59 8a	jsr $018a59			jsr 	EvaluateNumber 				; calculate thing being asserted
.01887e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018881	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018884	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018887	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01888a	f0 01		beq $01888d			beq 	_ASFail
.01888c	60		rts				rts
.01888d					_ASFail:
.01888d	20 2f 84	jsr $01842f			jsr ERR_Handler
>018890	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018897					Command_CLR:
.018897					ResetRunStatus:
.018897	20 c9 91	jsr $0191c9			jsr 	VariableClear
.01889a	a9 00		lda #$00			lda 	#HighMemory & $FF
.01889c	8d 00 04	sta $0400			sta 	StringPtr
.01889f	a9 80		lda #$80			lda 	#HighMemory >> 8
.0188a1	8d 01 04	sta $0401			sta 	StringPtr+1
.0188a4	20 9c 93	jsr $01939c			jsr 	ArrayResetDefault
.0188a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0188a8					Command_STOP:
.0188a8	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188ab	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0188b0					EVESyntax:
.0188b0	4c 00 84	jmp $018400			jmp 	SyntaxError
.0188b3					EvaluateExpression:
.0188b3	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0188b5					EvaluateExpressionX:
.0188b5	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0188b7					EvaluateExpressionXA:
.0188b7	48		pha				pha 								; save precedence on stack.
.0188b8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188ba	f0 f4		beq $0188b0			beq 	EVESyntax 					; end of line, syntax error.
.0188bc	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0188be	b0 03		bcs $0188c3			bcs 	_EVNotVariable
.0188c0	4c ba 89	jmp $0189ba			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0188c3					_EVNotVariable:
.0188c3	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0188c5	90 e9		bcc $0188b0			bcc 	EVESyntax
.0188c7	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0188c9	b0 7f		bcs $01894a			bcs 	_EVNotInteger
.0188cb	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0188cd	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.0188d0	a9 00		lda #$00			lda 	#0
.0188d2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0188d5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0188d8	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0188db	1a		inc a				inc 	a 							; set to type 1 (integer)
.0188dc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0188df					_EVCheckNextInteger:
.0188df	c8		iny				iny
.0188e0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188e2	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0188e4	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0188e6	b0 0d		bcs $0188f5			bcs 	_EVCheckDecimal
.0188e8	48		pha				pha 								; save it.
.0188e9	20 c6 89	jsr $0189c6			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0188ec	68		pla				pla
.0188ed	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0188f0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0188f3	80 ea		bra $0188df			bra 	_EVCheckNextInteger
.0188f5					_EVCheckDecimal:
.0188f5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188f7	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.0188f9	d0 05		bne $018900			bne 	_EVGotAtom 					; no, get atom.
.0188fb					_EVIsDecimal:
.0188fb	20 f6 89	jsr $0189f6			jsr 	EVGetDecimal 				; extend to the decimal part.
.0188fe	80 00		bra $018900			bra 	_EVGotAtom 					; and continue to got atom.
.018900					_EVGotAtom:
.018900	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018902	10 44		bpl $018948			bpl 	_EVExitDrop 				; must be a token.
.018904	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018906	b0 40		bcs $018948			bcs 	_EVExitDrop
.018908	68		pla				pla 								; get current precedence
.018909	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01890b	da		phx				phx 								; save X
.01890c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01890e	aa		tax				tax 								; put in X
.01890f	bf e5 84 01	lda $0184e5,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018913	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018915	fa		plx				plx 								; restore X
.018916	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018918	90 2f		bcc $018949			bcc 	_EVExit 					; exit if too low.
.01891a	f0 2d		beq $018949			beq 	_EVExit 					; exit if equals
.01891c	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.01891e	48		pha				pha
.01891f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018921	48		pha				pha
.018922	c8		iny				iny
.018923	da		phx				phx 								; save current position
.018924	e8		inx				inx
.018925	e8		inx				inx
.018926	e8		inx				inx
.018927	e8		inx				inx
.018928	e8		inx				inx
.018929	e8		inx				inx
.01892a	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01892c	20 b7 88	jsr $0188b7			jsr 	EvaluateExpressionXA 		; do the RHS.
.01892f	fa		plx				plx 								; restore X
.018930	68		pla				pla 								; get the binary operator in A.
.018931					_EVCallA:
.018931	da		phx				phx 								; save X again
.018932	0a		asl a				asl 	a 							; double, lose the MSB.
.018933	aa		tax				tax									; put in X
.018934	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018938	8d 05 03	sta $0305			sta 	LocalVector+1
.01893b	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.01893f	8d 06 03	sta $0306			sta 	LocalVector+2
.018942	fa		plx				plx 								; restore X
.018943	20 c3 89	jsr $0189c3			jsr 	EVCallLocalVector
.018946	80 b8		bra $018900			bra 	_EVGotAtom 					; and loop back.
.018948					_EVExitDrop:
.018948	68		pla				pla
.018949					_EVExit:
.018949	60		rts				rts
.01894a					_EVNotInteger:
.01894a	c8		iny				iny
.01894b	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.01894d	d0 19		bne $018968			bne 	_EVNotMinus
.01894f	20 47 8a	jsr $018a47			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018952	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018955	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018957	f0 05		beq $01895e			beq 	_EVMinusFloat
.018959	20 9c 96	jsr $01969c			jsr 	IntegerNegateAlways 		; negation
.01895c	80 a2		bra $018900			bra 	_EVGotAtom 					; and go back.
.01895e					_EVMinusFloat:
.01895e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.018961	49 80		eor #$80			eor 	#$80
.018963	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018966	80 98		bra $018900			bra 	_EVGotAtom
.018968					_EVNotMinus:
.018968	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01896a	d0 17		bne $018983			bne 	_EVNotParenthesis
.01896c	20 b5 88	jsr $0188b5			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.01896f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018971	c8		iny				iny
.018972	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.018974	f0 8a		beq $018900			beq 	_EVGotAtom
.018976	20 2f 84	jsr $01842f			jsr ERR_Handler
>018979	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018981	29 00
.018983					_EVNotParenthesis:
.018983	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.018985	d0 0c		bne $018993			bne 	_EVNotNot
.018987	20 47 8a	jsr $018a47			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01898a	20 aa 9b	jsr $019baa			jsr 	FPUToInteger 				; make it an integer - if possible.
.01898d	20 24 8a	jsr $018a24			jsr 	NotInteger 					; do the not calculation
.018990	4c 00 89	jmp $018900			jmp 	_EVGotAtom
.018993					_EVNotNot:
.018993	c9 fe		cmp #$fe			cmp 	#$FE
.018995	d0 15		bne $0189ac			bne 	_EVNotString
.018997	20 67 91	jsr $019167			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01899a	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01899c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01899f	a5 21		lda $21				lda 	zTempStr+1
.0189a1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189a4	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0189a6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0189a9	4c 00 89	jmp $018900			jmp 	_EVGotAtom
.0189ac					_EVNotString:
.0189ac	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0189ae	90 04		bcc $0189b4			bcc 	_EVBadElement
.0189b0	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0189b2	90 03		bcc $0189b7			bcc 	_EVUnaryFunction
.0189b4					_EVBadElement:
.0189b4	4c 00 84	jmp $018400			jmp 	SyntaxError
.0189b7					_EVUnaryFunction:
.0189b7	4c 31 89	jmp $018931			jmp 	_EVCallA
.0189ba					_EVVariableHandler:
.0189ba	20 8d 91	jsr $01918d			jsr 	VariableFind 				; locate a variable
.0189bd	20 de 94	jsr $0194de			jsr 	VariableGet 				; copy into memory.
.0189c0	4c 00 89	jmp $018900			jmp 	_EVGotAtom 					; and go round.
.0189c3					EVCallLocalVector:
.0189c3	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.0189c6					EVShiftMantissaLeft6:
.0189c6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0189c9	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0189cc	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189cf	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189d2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189d5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189d8	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189db	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189de	a9 00		lda #$00			lda 	#0
.0189e0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189e3	20 e6 89	jsr $0189e6			jsr 	_EVSMLShift 					; call it here to do it twice
.0189e6					_EVSMLShift:
.0189e6	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.0189e9	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.0189ec	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.0189ef	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.0189f2	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.0189f5	60		rts				rts
.0189f6					EVGetDecimal:
.0189f6	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0189f8	8d 05 04	sta $0405			sta 	Num_Buffer
.0189fb	da		phx				phx
.0189fc	c8		iny				iny
.0189fd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189ff	c8		iny				iny
.018a00	3a		dec a				dec 	a								; convert to a string length.
.018a01	3a		dec a				dec 	a
.018a02	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018a04					_EVGDCopy:
.018a04	48		pha				pha 									; save count
.018a05	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a07	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.018a0a	e8		inx				inx 									; forward ....
.018a0b	c8		iny				iny
.018a0c	68		pla				pla 									; get count
.018a0d	3a		dec a				dec 	a 								; until zero
.018a0e	d0 f4		bne $018a04			bne 	_EVGDCopy
.018a10	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018a13	fa		plx				plx 									; restore X
.018a14	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018a16	85 1e		sta $1e				sta 	zGenPtr
.018a18	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.018a1a	85 1f		sta $1f				sta 	zGenPtr+1
.018a1c	5a		phy				phy 									; save Y
.018a1d	a0 00		ldy #$00			ldy 	#0 								; start position
.018a1f	20 9c 9d	jsr $019d9c			jsr 	FPFromString 					; convert current
.018a22	7a		ply				ply 									; restore Y
.018a23	60		rts				rts
.018a24					NotInteger:
.018a24	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018a27	49 ff		eor #$ff			eor 	#$FF
.018a29	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a2c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a2f	49 ff		eor #$ff			eor 	#$FF
.018a31	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a34	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018a37	49 ff		eor #$ff			eor 	#$FF
.018a39	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a3c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018a3f	49 ff		eor #$ff			eor 	#$FF
.018a41	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a44	60		rts				rts
.018a45					EvaluateGetAtom:
.018a45	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018a47					EvaluateGetAtomX:
.018a47	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018a49	20 b7 88	jsr $0188b7			jsr 	EvaluateExpressionXA
.018a4c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018a4f	29 0f		and #$0f			and 	#15
.018a51	c9 02		cmp #$02			cmp 	#2
.018a53	b0 01		bcs $018a56			bcs 	EvaluateType
.018a55	60		rts				rts
.018a56					EvaluateType:
.018a56	4c 10 84	jmp $018410			jmp 	TypeError
.018a59					EvaluateNumber:
.018a59	a2 00		ldx #$00			ldx 	#0
.018a5b					EvaluateNumberX:
.018a5b	20 b5 88	jsr $0188b5			jsr 	EvaluateExpressionX
.018a5e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.018a61	29 0f		and #$0f			and 	#15
.018a63	c9 02		cmp #$02			cmp 	#2
.018a65	b0 ef		bcs $018a56			bcs 	EvaluateType
.018a67	60		rts				rts
.018a68					EvaluateInteger:
.018a68	a2 00		ldx #$00			ldx 	#0
.018a6a					EvaluateIntegerX:
.018a6a	20 5b 8a	jsr $018a5b			jsr 	EvaluateNumberX
.018a6d	20 aa 9b	jsr $019baa			jsr 	FPUToInteger
.018a70	60		rts				rts
.018a71					EvaluateString:
.018a71	a2 00		ldx #$00			ldx 	#0
.018a73					EvaluateStringX:
.018a73	20 b5 88	jsr $0188b5			jsr 	EvaluateExpressionX
.018a76	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.018a79	29 0f		and #$0f			and 	#15
.018a7b	c9 02		cmp #$02			cmp 	#2
.018a7d	d0 d7		bne $018a56			bne 	EvaluateType
.018a7f	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018a82	85 1e		sta $1e				sta 	zGenPtr
.018a84	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a87	85 1f		sta $1f				sta 	zGenPtr+1
.018a89	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018a8a					BinaryOp_And:
.018a8a	20 02 8b	jsr $018b02			jsr 	BinaryMakeBothInteger
.018a8d	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a90	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.018a93	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a96	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018a99	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.018a9c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a9f	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018aa2	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018aa5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018aa8	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018aab	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018aae	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ab1	60		rts				rts
.018ab2					BinaryOp_Or:
.018ab2	20 02 8b	jsr $018b02			jsr 	BinaryMakeBothInteger
.018ab5	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018ab8	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018abb	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018abe	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018ac1	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018ac4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ac7	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018aca	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018acd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ad0	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018ad3	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018ad6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ad9	60		rts				rts
.018ada					BinaryOp_Eor:
.018ada					BinaryOp_Xor:
.018ada	20 02 8b	jsr $018b02			jsr 	BinaryMakeBothInteger
.018add	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018ae0	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018ae3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018ae6	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018ae9	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018aec	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018aef	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018af2	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018af5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018af8	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018afb	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018afe	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b01	60		rts				rts
.018b02					BinaryMakeBothInteger:
.018b02	da		phx				phx 								; save X
.018b03	e8		inx				inx
.018b04	e8		inx				inx
.018b05	e8		inx				inx
.018b06	e8		inx				inx
.018b07	e8		inx				inx
.018b08	e8		inx				inx
.018b09	20 0d 8b	jsr $018b0d			jsr 	BinaryMakeInteger 			; convert to integer.
.018b0c	fa		plx				plx 								; restore X and fall through.
.018b0d					BinaryMakeInteger:
.018b0d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018b10	29 0f		and #$0f			and 	#15 						; check type zero
.018b12	f0 04		beq $018b18			beq 	_BMIConvert 				; if float convert to integer.
.018b14	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018b15	90 04		bcc $018b1b			bcc 	_BMIError
.018b17	60		rts				rts
.018b18					_BMIConvert:
.018b18	4c aa 9b	jmp $019baa			jmp 	FPUToInteger 				; convert to integer
.018b1b					_BMIError:
.018b1b	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018b1e					Binary_Equal:
.018b1e	20 6a 8b	jsr $018b6a			jsr 	CompareValues
.018b21	09 00		ora #$00			ora 	#0
.018b23	f0 04		beq $018b29			beq 	CCTrue
.018b25	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018b27	80 02		bra $018b2b			bra 	CCWrite
.018b29	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018b2b	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018b2e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b31	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b34	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b37	a9 01		lda #$01			lda 	#1
.018b39	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018b3c	60		rts				rts
.018b3d					Binary_NotEqual:
.018b3d	20 6a 8b	jsr $018b6a			jsr 	CompareValues
.018b40	09 00		ora #$00			ora 	#0
.018b42	f0 e1		beq $018b25			beq 	CCFalse
.018b44	80 e3		bra $018b29			bra 	CCTrue
.018b46					Binary_Less:
.018b46	20 6a 8b	jsr $018b6a			jsr 	CompareValues
.018b49	09 00		ora #$00			ora 	#0
.018b4b	30 dc		bmi $018b29			bmi 	CCTrue
.018b4d	80 d6		bra $018b25			bra 	CCFalse
.018b4f					Binary_LessEqual:
.018b4f	20 6a 8b	jsr $018b6a			jsr 	CompareValues
.018b52	c9 01		cmp #$01			cmp 	#1
.018b54	d0 d3		bne $018b29			bne 	CCTrue
.018b56	80 cd		bra $018b25			bra 	CCFalse
.018b58					Binary_GreaterEqual:
.018b58	20 6a 8b	jsr $018b6a			jsr 	CompareValues
.018b5b	09 00		ora #$00			ora 	#0
.018b5d	10 ca		bpl $018b29			bpl 	CCTrue
.018b5f	80 c4		bra $018b25			bra 	CCFalse
.018b61					Binary_Greater:
.018b61	20 6a 8b	jsr $018b6a			jsr 	CompareValues
.018b64	c9 01		cmp #$01			cmp 	#1
.018b66	f0 c1		beq $018b29			beq 	CCTrue
.018b68	80 bb		bra $018b25			bra 	CCFalse
.018b6a					CompareValues:
.018b6a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018b6d	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b70	c9 02		cmp #$02			cmp 	#2
.018b72	f0 13		beq $018b87			beq 	_CVString
.018b74	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b77	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b7a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b7b	90 03		bcc $018b80			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b7d	4c cd 8b	jmp $018bcd			jmp 	CompareInteger32 							; so execute code at \1
.018b80					_BCFloat:
.018b80	20 9b 8c	jsr $018c9b			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b83	4c b9 9a	jmp $019ab9			jmp 	FPCompare 							; and execute code at \2
.018b86	60		rts				rts
.018b87					_CVString:
.018b87	da		phx				phx 								; save XY
.018b88	5a		phy				phy
.018b89	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018b8c	85 1a		sta $1a				sta		zLTemp1+0
.018b8e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b91	85 1b		sta $1b				sta 	zLTemp1+1
.018b93	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018b96	85 1c		sta $1c				sta 	zLTemp1+2
.018b98	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018b9b	85 1d		sta $1d				sta 	zLTemp1+3
.018b9d	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018b9f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018ba1	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018ba3	90 02		bcc $018ba7			bcc 	_CVCommon
.018ba5	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018ba7					_CVCommon:
.018ba7	aa		tax				tax 								; put shorter string length in zero.
.018ba8	f0 0c		beq $018bb6			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018baa					_CVCompare:
.018baa	c8		iny				iny 								; next character
.018bab	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018bad	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018baf	90 13		bcc $018bc4			bcc 	_CVReturnLess 				; <
.018bb1	d0 15		bne $018bc8			bne 	_CVReturnGreater 			; >
.018bb3	ca		dex				dex 								; until common length matched.
.018bb4	d0 f4		bne $018baa			bne 	_CVCompare
.018bb6					_CVMatch:
.018bb6	a0 00		ldy #$00			ldy 	#0
.018bb8	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018bba	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018bbc	90 06		bcc $018bc4			bcc 	_CVReturnLess 				; <
.018bbe	d0 08		bne $018bc8			bne 	_CVReturnGreater 			; >
.018bc0	a9 00		lda #$00			lda 	#0
.018bc2	80 06		bra $018bca			bra 	_CVExit 					; same common, same length, same string
.018bc4					_CVReturnLess:
.018bc4	a9 ff		lda #$ff			lda 	#$FF
.018bc6	80 02		bra $018bca			bra 	_CVExit
.018bc8					_CVReturnGreater:
.018bc8	a9 01		lda #$01			lda 	#$01
.018bca					_CVExit:
.018bca	7a		ply				ply
.018bcb	fa		plx				plx
.018bcc	60		rts				rts
.018bcd					CompareInteger32:
.018bcd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018bd0	49 80		eor #$80			eor 	#$80
.018bd2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bd5	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018bd8	49 80		eor #$80			eor 	#$80
.018bda	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018bdd	20 75 8c	jsr $018c75			jsr 	SubInteger32 				; subtraction
.018be0	90 11		bcc $018bf3			bcc 	_CI32Less 					; cc return -1
.018be2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018be5	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018be8	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018beb	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018bee	f0 02		beq $018bf2			beq 	_CI32Exit
.018bf0	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018bf2					_CI32Exit:
.018bf2	60		rts				rts
.018bf3					_CI32Less:
.018bf3	a9 ff		lda #$ff			lda 	#$FF
.018bf5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018bf6					BinaryOp_Add:
.018bf6	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018bf9	3d 13 03	and $0313,x			and 	XS2_Type,x
.018bfc	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018bfe	d0 13		bne $018c13			bne 	_BOAString
.018c00	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c03	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c06	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c07	90 03		bcc $018c0c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c09	4c 4f 8c	jmp $018c4f			jmp 	AddInteger32 							; so execute code at \1
.018c0c					_BCFloat:
.018c0c	20 9b 8c	jsr $018c9b			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c0f	4c 2d 98	jmp $01982d			jmp 	FPAdd 							; and execute code at \2
.018c12	60		rts				rts
.018c13					_BOAString:
.018c13	4c b6 8c	jmp $018cb6			jmp 	ConcatenateString 			; concatenate two strings.
.018c16					BinaryOp_Subtract:
.018c16	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c19	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c1c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c1d	90 03		bcc $018c22			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c1f	4c 75 8c	jmp $018c75			jmp 	SubInteger32 							; so execute code at \1
.018c22					_BCFloat:
.018c22	20 9b 8c	jsr $018c9b			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c25	4c 23 98	jmp $019823			jmp 	FPSubtract 							; and execute code at \2
.018c28	60		rts				rts
.018c29					BinaryOp_Multiply:
.018c29	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c2c	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c2f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c30	90 03		bcc $018c35			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c32	4c af 95	jmp $0195af			jmp 	MulInteger32 							; so execute code at \1
.018c35					_BCFloat:
.018c35	20 9b 8c	jsr $018c9b			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c38	4c 99 99	jmp $019999			jmp 	FPMultiply 							; and execute code at \2
.018c3b	60		rts				rts
.018c3c					BinaryOp_Divide:
.018c3c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c3f	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c42	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c43	90 03		bcc $018c48			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c45	4c 06 96	jmp $019606			jmp 	DivInteger32 							; so execute code at \1
.018c48					_BCFloat:
.018c48	20 9b 8c	jsr $018c9b			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c4b	4c 11 99	jmp $019911			jmp 	FPDivide 							; and execute code at \2
.018c4e	60		rts				rts
.018c4f					AddInteger32:
.018c4f	18		clc				clc
.018c50	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018c53	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018c56	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c59	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c5c	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018c5f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c62	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018c65	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018c68	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018c6b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018c6e	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018c71	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018c74	60		rts				rts
.018c75					SubInteger32:
.018c75	38		sec				sec
.018c76	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018c79	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018c7c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c7f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c82	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018c85	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c88	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018c8b	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018c8e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018c91	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018c94	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018c97	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018c9a	60		rts				rts
.018c9b					BinaryMakeBothFloat:
.018c9b	da		phx				phx 								; save X
.018c9c	e8		inx				inx
.018c9d	e8		inx				inx
.018c9e	e8		inx				inx
.018c9f	e8		inx				inx
.018ca0	e8		inx				inx
.018ca1	e8		inx				inx
.018ca2	20 a6 8c	jsr $018ca6			jsr 	BinaryMakeFloat 			; convert to float.
.018ca5	fa		plx				plx 								; restore X and fall through.
.018ca6					BinaryMakeFloat:
.018ca6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018ca9	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018caa	b0 04		bcs $018cb0			bcs 	_BMFConvert
.018cac	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018cad	b0 04		bcs $018cb3			bcs 	_BMFError
.018caf	60		rts				rts
.018cb0					_BMFConvert:
.018cb0	4c 4b 9b	jmp $019b4b			jmp 	FPUToFloat 					; convert to float
.018cb3					_BMFError:
.018cb3	4c 10 84	jmp $018410			jmp 	TypeError
.018cb6					ConcatenateString:
.018cb6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018cb9	85 1a		sta $1a				sta		zLTemp1+0
.018cbb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018cbe	85 1b		sta $1b				sta 	zLTemp1+1
.018cc0	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018cc3	85 1c		sta $1c				sta 	zLTemp1+2
.018cc5	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018cc8	85 1d		sta $1d				sta 	zLTemp1+3
.018cca	5a		phy				phy
.018ccb	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018ccd	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018ccf	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018cd1	7a		ply				ply
.018cd2	b0 37		bcs $018d0b			bcs 	_CSError					; check in range.
.018cd4	c9 fe		cmp #$fe			cmp 	#maxString+1
.018cd6	b0 33		bcs $018d0b			bcs 	_CSError
.018cd8	20 2c 91	jsr $01912c			jsr 	AllocateTempString 			; store the result
.018cdb	20 f6 8c	jsr $018cf6			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018cde	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018ce1	85 1a		sta $1a				sta 	zLTemp1
.018ce3	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018ce6	85 1b		sta $1b				sta 	zLTemp1+1
.018ce8	20 f6 8c	jsr $018cf6			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018ceb	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018ced	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018cf0	a5 21		lda $21				lda 	zTempStr+1
.018cf2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018cf5	60		rts				rts
.018cf6					_CSCopyString:
.018cf6	da		phx				phx
.018cf7	5a		phy				phy
.018cf8	a0 00		ldy #$00			ldy 	#0 							; get length
.018cfa	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018cfc	f0 0a		beq $018d08			beq 	_CSCSExit 					; if zero, exit
.018cfe	aa		tax				tax 								; put in X
.018cff					_CSCSLoop:
.018cff	c8		iny				iny 								; get next char
.018d00	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018d02	20 57 91	jsr $019157			jsr		WriteTempString 			; copy out
.018d05	ca		dex				dex 								; do whole string
.018d06	d0 f7		bne $018cff			bne 	_CSCSLoop
.018d08					_CSCSExit:
.018d08	7a		ply				ply
.018d09	fa		plx				plx
.018d0a	60		rts				rts
.018d0b					_CSError:
.018d0b	20 2f 84	jsr $01842f			jsr ERR_Handler
>018d0e	53 74 72 69 6e 67 20 74			.text "String too long",0
>018d16	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018d1e					Unary_Sgn:
.018d1e	20 5b 8a	jsr $018a5b			jsr 	EvaluateNumberX 			; get value
.018d21	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; check right bracket.
.018d24	20 48 8d	jsr $018d48			jsr 	GetSignCurrent 				; get sign.
.018d27	09 00		ora #$00			ora 	#0
.018d29	10 09		bpl $018d34			bpl		UnarySetAInteger			; if 0,1 return that.
.018d2b	80 00		bra $018d2d			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018d2d					UnarySetAMinus1:
.018d2d	a9 ff		lda #$ff			lda 	#$FF
.018d2f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018d32	80 05		bra $018d39			bra 	UnarySetAFill
.018d34					UnarySetAInteger:
.018d34	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018d37	a9 00		lda #$00			lda 	#0
.018d39					UnarySetAFill:
.018d39	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d3c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d3f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d42	a9 01		lda #$01			lda 	#1
.018d44	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d47	60		rts				rts
.018d48					GetSignCurrent:
.018d48	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018d4b	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018d4c	90 19		bcc $018d67			bcc 	_GSCFloat
.018d4e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d51	30 11		bmi $018d64			bmi 	_GSCMinus1
.018d53	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018d56	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018d59	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018d5c	d0 03		bne $018d61			bne 	_GSCPlus1
.018d5e					_GSCZero:
.018d5e	a9 00		lda #$00			lda 	#0
.018d60	60		rts				rts
.018d61					_GSCPlus1:
.018d61	a9 01		lda #$01			lda 	#$01
.018d63	60		rts				rts
.018d64					_GSCMinus1:
.018d64	a9 ff		lda #$ff			lda 	#$FF
.018d66	60		rts				rts
.018d67					_GSCFloat:
.018d67	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018d6a	70 f2		bvs $018d5e			bvs 	_GSCZero
.018d6c	30 f6		bmi $018d64			bmi 	_GSCMinus1
.018d6e	80 f1		bra $018d61			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018d70					Unary_Abs:
.018d70	20 5b 8a	jsr $018a5b			jsr 	EvaluateNumberX 			; get value
.018d73	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; check right bracket.
.018d76	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018d79	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018d7b	f0 08		beq $018d85			beq 	_UAMinusFloat
.018d7d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018d80	10 0b		bpl $018d8d			bpl 	_UAExit
.018d82	4c 9c 96	jmp $01969c			jmp 	IntegerNegateAlways 		; negation
.018d85					_UAMinusFloat:
.018d85	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018d88	29 7f		and #$7f			and		#$7F
.018d8a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d8d					_UAExit:
.018d8d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018d8e					Unary_Peek:
.018d8e	a9 01		lda #$01			lda 	#1
.018d90	80 06		bra $018d98			bra 	UPMain
.018d92					Unary_Deek:
.018d92	a9 02		lda #$02			lda 	#2
.018d94	80 02		bra $018d98			bra 	UPMain
.018d96					Unary_Leek:
.018d96	a9 04		lda #$04			lda 	#4
.018d98					UPMain:
.018d98	48		pha				pha 								; set bytes to copy.
.018d99	20 6a 8a	jsr $018a6a			jsr 	EvaluateIntegerX 			; numeric parameter
.018d9c	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.018d9f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018da2	85 1a		sta $1a				sta 	zLTemp1
.018da4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018da7	85 1b		sta $1b				sta 	zLTemp1+1
.018da9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018dac	85 1c		sta $1c				sta 	zLTemp1+2
.018dae	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018db1	85 1d		sta $1d				sta 	zLTemp1+3
.018db3	a9 00		lda #$00			lda 	#0 							; clear target area
.018db5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018db8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018dbb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018dbe	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018dc1	68		pla				pla 								; restore bytes to copy
.018dc2	da		phx				phx 								; save XY
.018dc3	5a		phy				phy
.018dc4	20 c1 90	jsr $0190c1			jsr 	MemRead 					; read the bytes in
.018dc7	7a		ply				ply 								; restore and exit
.018dc8	fa		plx				plx
.018dc9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018dca					Unary_Mod:
.018dca	20 f6 8d	jsr $018df6			jsr 	_UMParameter 				; first parameter
.018dcd	20 f2 90	jsr $0190f2			jsr 	CheckNextComma
.018dd0	da		phx				phx 								; second parameter
.018dd1	e8		inx				inx
.018dd2	e8		inx				inx
.018dd3	e8		inx				inx
.018dd4	e8		inx				inx
.018dd5	e8		inx				inx
.018dd6	e8		inx				inx
.018dd7	20 f6 8d	jsr $018df6			jsr 	_UMParameter
.018dda	fa		plx				plx
.018ddb	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen
.018dde	20 06 96	jsr $019606			jsr 	DivInteger32 				; divide
.018de1	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018de3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018de6	a5 1b		lda $1b				lda 	zLTemp1+1
.018de8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018deb	a5 1c		lda $1c				lda 	zLTemp1+2
.018ded	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018df0	a5 1d		lda $1d				lda 	zLTemp1+3
.018df2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018df5	60		rts				rts
.018df6					_UMParameter:
.018df6	20 6a 8a	jsr $018a6a			jsr 	EvaluateIntegerX 			; get value
.018df9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018dfc	10 03		bpl $018e01			bpl 	_UMNotSigned
.018dfe	20 9c 96	jsr $01969c			jsr 	IntegerNegateAlways
.018e01					_UMNotSigned:
.018e01	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018e02					Unary_Usr:
.018e02	20 5b 8a	jsr $018a5b			jsr 	EvaluateNumberX 			; numeric parameter
.018e05	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.018e08	da		phx				phx 								; save XY
.018e09	5a		phy				phy
.018e0a	ea		nop				nop
.018e0b	22 00 03 00	jsl $000300			jsl 	UserVector
.018e0f	7a		ply				ply 								; and exit
.018e10	fa		plx				plx
.018e11	60		rts				rts
.018e12					USRDefault:
.018e12	20 2f 84	jsr $01842f			jsr ERR_Handler
>018e15	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018e1d	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018e24					Unary_Val:
.018e24	20 73 8a	jsr $018a73			jsr 	EvaluateStringX 			; get string
.018e27	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; check right bracket.
.018e2a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018e2d	85 1e		sta $1e				sta 	zGenPtr
.018e2f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e32	85 1f		sta $1f				sta 	zGenPtr+1
.018e34	5a		phy				phy
.018e35	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018e37	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018e39	f0 57		beq $018e92			beq 	_UVBadNumber
.018e3b	48		pha				pha 								; save length.
.018e3c	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018e3d	1a		inc a				inc 	a
.018e3e	20 2c 91	jsr $01912c			jsr 	AllocateTempString
.018e41	c8		iny				iny 								; move to the next.
.018e42	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018e44	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018e46	8d 90 04	sta $0490			sta 	ValSign
.018e49	d0 04		bne $018e4f			bne 	_UVNotMinus
.018e4b	c8		iny				iny 								; skip over it.
.018e4c	68		pla				pla 								; decrement character count.
.018e4d	3a		dec a				dec 	a
.018e4e	48		pha				pha
.018e4f					_UVNotMinus:
.018e4f	68		pla				pla 								; this is the count.
.018e50	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018e51	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e53	c8		iny				iny
.018e54	20 57 91	jsr $019157			jsr 	WriteTempString
.018e57	68		pla				pla
.018e58	3a		dec a				dec 	a
.018e59	d0 f5		bne $018e50			bne 	_UVCopy
.018e5b	20 57 91	jsr $019157			jsr 	WriteTempString 			; make it ASCIIZ
.018e5e	18		clc				clc
.018e5f	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018e61	69 01		adc #$01			adc 	#1
.018e63	85 1e		sta $1e				sta 	zGenPtr
.018e65	a5 21		lda $21				lda 	zTempStr+1
.018e67	69 00		adc #$00			adc 	#0
.018e69	85 1f		sta $1f				sta 	zGenPtr+1
.018e6b	18		clc				clc
.018e6c	20 78 97	jsr $019778			jsr 	IntFromString 				; first bit.
.018e6f	b0 21		bcs $018e92			bcs 	_UVBadNumber
.018e71	20 9c 9d	jsr $019d9c			jsr 	FPFromString				; try for a float part.
.018e74	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.018e77	d0 13		bne $018e8c			bne 	_UVNotNegative
.018e79	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018e7c	4a		lsr a				lsr 	a
.018e7d	b0 0a		bcs $018e89			bcs 	_UVInteger
.018e7f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018e82	09 80		ora #$80			ora 	#$80
.018e84	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018e87	80 03		bra $018e8c			bra 	_UVNotNegative
.018e89					_UVInteger:
.018e89	20 9c 96	jsr $01969c			jsr 	IntegerNegateAlways 		; sign it.
.018e8c					_UVNotNegative:
.018e8c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018e8e	d0 02		bne $018e92			bne 	_UVBadNumber
.018e90	7a		ply				ply
.018e91	60		rts				rts
.018e92					_UVBadNumber:
.018e92	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018e95					Unary_Str:
.018e95	20 5b 8a	jsr $018a5b			jsr 	EvaluateNumberX 			; numeric parameter
.018e98	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.018e9b	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e9d	8d 04 04	sta $0404			sta 	NumBufX
.018ea0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018ea3	4a		lsr a				lsr 	a
.018ea4	b0 05		bcs $018eab			bcs 	_USInt 						; if msb set do as integer
.018ea6	20 d5 9c	jsr $019cd5			jsr 	FPToString 					; call fp to str otherwise
.018ea9	80 03		bra $018eae			bra 	_USDuplicate
.018eab	20 c1 96	jsr $0196c1	_USInt:	jsr 	IntToString
.018eae					_USDuplicate:
.018eae	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.018eb1	1a		inc a				inc 	a 							; one more for length
.018eb2	20 2c 91	jsr $01912c			jsr 	AllocateTempString 			; allocate space for it.
.018eb5	5a		phy				phy 								; save Y
.018eb6	a0 00		ldy #$00			ldy 	#0 							; start copying
.018eb8	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018ebb	20 57 91	jsr $019157			jsr 	WriteTempString
.018ebe	c8		iny				iny
.018ebf	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.018ec2	d0 f4		bne $018eb8			bne 	_USCopy
.018ec4	7a		ply				ply 								; restore Y
.018ec5	4c b1 90	jmp $0190b1			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018ec8					Unary_Asc:
.018ec8	20 73 8a	jsr $018a73			jsr 	EvaluateStringX 			; string parameter
.018ecb	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.018ece	5a		phy				phy 								; get the string length
.018ecf	a0 00		ldy #$00			ldy 	#0
.018ed1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ed3	f0 07		beq $018edc			beq 	_UAIllegal 					; must be at least one character
.018ed5	c8		iny				iny
.018ed6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018ed8	7a		ply				ply
.018ed9	4c 34 8d	jmp $018d34			jmp 	UnarySetAInteger
.018edc					_UAIllegal:
.018edc	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018edf					Unary_Len:
.018edf	20 73 8a	jsr $018a73			jsr 	EvaluateStringX 			; string parameter
.018ee2	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.018ee5	5a		phy				phy 								; get the string length
.018ee6	a0 00		ldy #$00			ldy 	#0
.018ee8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018eea	7a		ply				ply
.018eeb	4c 34 8d	jmp $018d34			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018eee					Unary_Mid:
.018eee	20 73 8a	jsr $018a73			jsr 	EvaluateStringX 				; get string.
.018ef1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018ef4	48		pha				pha
.018ef5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ef8	48		pha				pha
.018ef9	20 f2 90	jsr $0190f2			jsr 	CheckNextComma 					; skip comma
.018efc	20 89 8f	jsr $018f89			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018eff	48		pha				pha 									; and push it.
.018f00	20 f2 90	jsr $0190f2			jsr 	CheckNextComma 					; skip comma
.018f03	20 89 8f	jsr $018f89			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018f06	48		pha				pha 									; and push it.
.018f07	80 45		bra $018f4e			bra 	SLIProcess
.018f09					Unary_Left:
.018f09	20 73 8a	jsr $018a73			jsr 	EvaluateStringX 				; get string.
.018f0c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f0f	48		pha				pha
.018f10	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f13	48		pha				pha
.018f14	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018f16	48		pha				pha
.018f17	20 f2 90	jsr $0190f2			jsr 	CheckNextComma 					; skip comma
.018f1a	20 89 8f	jsr $018f89			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018f1d	48		pha				pha 									; and push it.
.018f1e	80 2e		bra $018f4e			bra 	SLIProcess
.018f20					Unary_Right:
.018f20	20 73 8a	jsr $018a73			jsr 	EvaluateStringX 				; get string.
.018f23	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f26	48		pha				pha
.018f27	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f2a	48		pha				pha
.018f2b	da		phx				phx 									; get the string length and push on stack.
.018f2c	a2 00		ldx #$00			ldx 	#0
.018f2e	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018f30	fa		plx				plx
.018f31	48		pha				pha
.018f32	20 f2 90	jsr $0190f2			jsr 	CheckNextComma 					; skip comma
.018f35	20 89 8f	jsr $018f89			jsr 	SLIByteParameter 				; get a byte parameter.
.018f38	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.018f3b	68		pla				pla 									; restore string length.
.018f3c	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018f3d	38		sec				sec
.018f3e	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.018f41	f0 02		beq $018f45			beq 	_URStart 						; if <= 0 start from 1.
.018f43	10 02		bpl $018f47			bpl 	_UROkay
.018f45					_URStart:
.018f45	a9 01		lda #$01			lda 	#1
.018f47					_UROkay:
.018f47	48		pha				pha 									; push start
.018f48	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.018f4b	48		pha				pha
.018f4c	80 00		bra $018f4e			bra 	SLIProcess
.018f4e					SLIProcess:
.018f4e	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 				; closing right bracket.
.018f51	68		pla				pla
.018f52	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.018f55	1a		inc a				inc 	a 								; allocate +1 for it.
.018f56	20 2c 91	jsr $01912c			jsr 	AllocateTempString
.018f59	68		pla				pla 									; pop start number off stack.
.018f5a	f0 3f		beq $018f9b			beq 	SLIError 						; exit if start = 0
.018f5c	8d 91 04	sta $0491			sta 	SliceStart
.018f5f	68		pla				pla  									; pop string address.
.018f60	85 1f		sta $1f				sta 	zGenPtr+1
.018f62	68		pla				pla
.018f63	85 1e		sta $1e				sta 	zGenPtr
.018f65	da		phx				phx
.018f66	5a		phy				phy
.018f67	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018f69	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.018f6c					_SLICopy:
.018f6c	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.018f6f	f0 12		beq $018f83			beq 	_SLIExit
.018f71	ce 92 04	dec $0492			dec 	SliceCount
.018f74	98		tya				tya 									; index of character
.018f75	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018f77	f0 02		beq $018f7b			beq 	_SLIOk 							; if equal, okay.
.018f79	b0 08		bcs $018f83			bcs 	_SLIExit 						; if past end, then exit.
.018f7b	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018f7d	c8		iny				iny
.018f7e	20 57 91	jsr $019157			jsr 	WriteTempString
.018f81	80 e9		bra $018f6c			bra 	_SLICopy 						; go round till copied characters
.018f83					_SLIExit:
.018f83	7a		ply				ply 									; restore YX
.018f84	fa		plx				plx
.018f85	4c b1 90	jmp $0190b1			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018f88	ea		nop				nop
.018f89					SLIByteParameter:
.018f89	20 6a 8a	jsr $018a6a			jsr 	EvaluateIntegerX 				; get integer
.018f8c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018f8f	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018f92	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018f95	d0 04		bne $018f9b			bne 	SLIError
.018f97	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018f9a	60		rts				rts
.018f9b					SLIError:
.018f9b	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018f9e					Unary_Hex:
.018f9e	20 6a 8a	jsr $018a6a			jsr 	EvaluateIntegerX 			; numeric parameter
.018fa1	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.018fa4	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018fa6	20 2c 91	jsr $01912c			jsr 	AllocateTempString			; allocate string space
.018fa9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018fac	20 d3 8f	jsr $018fd3			jsr 	_UHConvert
.018faf	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018fb2	20 d3 8f	jsr $018fd3			jsr 	_UHConvert
.018fb5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018fb8	20 d3 8f	jsr $018fd3			jsr 	_UHConvert
.018fbb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018fbe	20 d3 8f	jsr $018fd3			jsr 	_UHConvert
.018fc1	5a		phy				phy 								; get length of new string
.018fc2	a0 00		ldy #$00			ldy 	#0
.018fc4	b1 20		lda ($20),y			lda 	(zTempStr),y
.018fc6	7a		ply				ply
.018fc7	c9 00		cmp #$00			cmp 	#0
.018fc9	d0 05		bne $018fd0			bne 	_UHExit 					; if it was non zero okay
.018fcb	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018fcd	20 57 91	jsr $019157			jsr 	WriteTempString
.018fd0					_UHExit:
.018fd0	4c b1 90	jmp $0190b1			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018fd3					_UHConvert:
.018fd3	48		pha				pha
.018fd4	4a		lsr a				lsr 	a 							; do MSB
.018fd5	4a		lsr a				lsr 	a
.018fd6	4a		lsr a				lsr 	a
.018fd7	4a		lsr a				lsr 	a
.018fd8	20 dc 8f	jsr $018fdc			jsr 	_UHNibble
.018fdb	68		pla				pla 								; do LSB
.018fdc					_UHNibble:
.018fdc	29 0f		and #$0f			and 	#15 						; get nibble
.018fde	d0 0c		bne $018fec			bne 	_UHNonZero
.018fe0	5a		phy				phy									; get the length
.018fe1	a0 00		ldy #$00			ldy 	#0
.018fe3	b1 20		lda ($20),y			lda 	(zTempStr),y
.018fe5	7a		ply				ply
.018fe6	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018fe8	f0 0d		beq $018ff7			beq 	_UHExit2
.018fea	a9 00		lda #$00			lda 	#0
.018fec					_UHNonZero:
.018fec	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018fee	90 02		bcc $018ff2			bcc 	_UHDigit
.018ff0	69 06		adc #$06			adc 	#7-1
.018ff2					_UHDigit:
.018ff2	69 30		adc #$30			adc 	#48
.018ff4	20 57 91	jsr $019157			jsr 	WriteTempString				; output.
.018ff7					_UHExit2:
.018ff7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018ff8					Unary_Dec:
.018ff8	20 73 8a	jsr $018a73			jsr 	EvaluateStringX 			; string parameter
.018ffb	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.018ffe	5a		phy				phy
.018fff	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019001	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019003	f0 4c		beq $019051			beq 	_UDFail 					; must fail if zero.
.019005	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.019008	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.01900a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01900d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019010	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019013	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019016	a9 01		lda #$01			lda 	#1
.019018	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01901b					_UDConvertLoop:
.01901b	5a		phy				phy 								; shift mantissa left 4
.01901c	a0 04		ldy #$04			ldy 	#4
.01901e					_UDShift:
.01901e	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.019021	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019024	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019027	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.01902a	88		dey				dey
.01902b	d0 f1		bne $01901e			bne 	_UDShift
.01902d	7a		ply				ply
.01902e	c8		iny				iny 								; next character
.01902f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019031	20 54 90	jsr $019054			jsr 	ConvertUpper 				; convert to U/C
.019034	c9 30		cmp #$30			cmp 	#"0"
.019036	90 19		bcc $019051			bcc 	_UDFail
.019038	c9 3a		cmp #$3a			cmp 	#"9"+1
.01903a	90 06		bcc $019042			bcc 	_UDOkay
.01903c	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.01903e	c9 10		cmp #$10			cmp 	#16
.019040	b0 0f		bcs $019051			bcs 	_UDFail
.019042					_UDOkay:
.019042	29 0f		and #$0f			and 	#15 						; nibble only
.019044	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.019047	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01904a	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.01904d	d0 cc		bne $01901b			bne 	_UDConvertLoop
.01904f	7a		ply				ply
.019050	60		rts				rts
.019051					_UDFail:
.019051	4c 1e 84	jmp $01841e			jmp 	BadParamError
.019054					ConvertUpper:
.019054	c9 61		cmp #$61			cmp 	#"a"
.019056	90 07		bcc $01905f			bcc 	_CUExit
.019058	c9 7b		cmp #$7b			cmp 	#"z"+1
.01905a	b0 03		bcs $01905f			bcs 	_CUExit
.01905c	38		sec				sec
.01905d	e9 20		sbc #$20			sbc 	#32
.01905f	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019060					Unary_Chr:
.019060	20 6a 8a	jsr $018a6a			jsr 	EvaluateIntegerX			; numeric parameter
.019063	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.019066	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019069	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01906c	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01906f	d0 0e		bne $01907f			bne 	_UCChar
.019071	a9 01		lda #$01			lda 	#1 							; one character string
.019073	20 2c 91	jsr $01912c			jsr 	AllocateTempString
.019076	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019079	20 57 91	jsr $019157			jsr 	WriteTempString
.01907c	4c b1 90	jmp $0190b1			jmp 	UnaryReturnTempStr
.01907f					_UCChar:
.01907f	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019082					Unary_Spc:
.019082	20 6a 8a	jsr $018a6a			jsr 	EvaluateIntegerX 			; numeric parameter
.019085	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; right bracket.
.019088	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01908b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01908e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019091	d0 1b		bne $0190ae			bne 	_USSize
.019093	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019096	c9 fe		cmp #$fe			cmp 	#maxString+1
.019098	b0 14		bcs $0190ae			bcs 	_USSize
.01909a	48		pha				pha 								; save length
.01909b	1a		inc a				inc 	a 							; allocate one more.
.01909c	20 2c 91	jsr $01912c			jsr 	AllocateTempString
.01909f	68		pla				pla 								; get length
.0190a0	f0 0f		beq $0190b1			beq 	UnaryReturnTempStr 			; return the current temp string
.0190a2					_USLoop:
.0190a2	48		pha				pha
.0190a3	a9 20		lda #$20			lda 	#" "
.0190a5	20 57 91	jsr $019157			jsr 	WriteTempString
.0190a8	68		pla				pla
.0190a9	3a		dec a				dec 	a
.0190aa	d0 f6		bne $0190a2			bne 	_USLoop
.0190ac	80 03		bra $0190b1			bra 	UnaryReturnTempStr
.0190ae					_USSize:
.0190ae	4c 1e 84	jmp $01841e			jmp 	BadParamError
.0190b1					UnaryReturnTempStr:
.0190b1	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0190b3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0190b6	a5 21		lda $21				lda 	zTempStr+1
.0190b8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0190bb	a9 02		lda #$02			lda 	#2 							; set type to string
.0190bd	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0190c0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0190c1					MemRead:
.0190c1	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.0190c4	a0 00		ldy #$00			ldy 	#0 							; start from here
.0190c6	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0190c8	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0190cb	c8		iny				iny 								; next to copy
.0190cc	e8		inx				inx
.0190cd	cc 8e 04	cpy $048e			cpy 	SignCount 					; do required # of bytes.
.0190d0	d0 f4		bne $0190c6			bne 	_MLoop1
.0190d2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0190d3					CheckNextToken:
.0190d3	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.0190d5	d0 02		bne $0190d9			bne 	CTFail 						; no, then fail
.0190d7	c8		iny				iny
.0190d8	60		rts				rts
.0190d9					CTFail:
.0190d9	20 2f 84	jsr $01842f			jsr ERR_Handler
>0190dc	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0190e4	74 6f 6b 65 6e 00
.0190ea					CheckNextRParen:
.0190ea	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190ec	c9 be		cmp #$be			cmp 	#token_rparen
.0190ee	d0 e9		bne $0190d9			bne 	CTFail
.0190f0	c8		iny				iny
.0190f1	60		rts				rts
.0190f2					CheckNextComma:
.0190f2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190f4	c9 bf		cmp #$bf			cmp 	#token_comma
.0190f6	d0 e1		bne $0190d9			bne 	CTFail
.0190f8	c8		iny				iny
.0190f9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0190fa					StringConcrete:
.0190fa	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0190fd	85 10		sta $10				sta 	zTemp1
.0190ff	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019102	85 11		sta $11				sta 	zTemp1+1
.019104	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019106	18		clc				clc 								; from the string pointer
.019107	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.01910a	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.01910c	8d 00 04	sta $0400			sta 	StringPtr
.01910f	85 12		sta $12				sta 	zTemp2
.019111	ad 01 04	lda $0401			lda 	StringPtr+1
.019114	e9 00		sbc #$00			sbc 	#0
.019116	8d 01 04	sta $0401			sta 	StringPtr+1
.019119	85 13		sta $13				sta 	zTemp2+1
.01911b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.01911d	1a		inc a				inc 	a
.01911e	aa		tax				tax
.01911f	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019121	91 12		sta ($12),y			sta 	(zTemp2),y
.019123	c8		iny				iny
.019124	ca		dex				dex
.019125	d0 f8		bne $01911f			bne 	_SCCopy
.019127	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019129	a6 12		ldx $12				ldx 	zTemp2
.01912b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.01912c					AllocateTempString:
.01912c	48		pha				pha 								; save required count.
.01912d	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.01912f	d0 0b		bne $01913c			bne 	_ATSInitialised
.019131	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019134	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.019136	ad 01 04	lda $0401			lda 	StringPtr+1
.019139	3a		dec a				dec 	a
.01913a	85 21		sta $21				sta 	zTempStr+1
.01913c					_ATSInitialised:
.01913c	68		pla				pla 								; get required count back.
.01913d	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.01913f	1a		inc a				inc 	a
.019140	18		clc				clc
.019141	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.019143	85 20		sta $20				sta 	zTempStr
.019145	a9 ff		lda #$ff			lda 	#$FF
.019147	65 21		adc $21				adc 	zTempStr+1
.019149	85 21		sta $21				sta 	zTempStr+1
.01914b	a9 00		lda #$00			lda 	#0 							; clear temp string.
.01914d	5a		phy				phy
.01914e	a8		tay				tay
.01914f	91 20		sta ($20),y			sta 	(zTempStr),y
.019151	7a		ply				ply
.019152	1a		inc a				inc 	a 							; reset the write index.
.019153	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.019156	60		rts				rts
.019157					WriteTempString:
.019157	5a		phy				phy 								; save Y
.019158	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.01915b	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.01915d	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.019160	98		tya				tya 								; unchanged Y is now length
.019161	a0 00		ldy #$00			ldy 	#0
.019163	91 20		sta ($20),y			sta 	(zTempStr),y
.019165	7a		ply				ply 								; restore Y and exit
.019166	60		rts				rts
.019167					CreateTempStringCopy:
.019167	da		phx				phx 								; save X
.019168	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01916a	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.01916b	20 2c 91	jsr $01912c			jsr 	AllocateTempString 			; allocate memory for temporary string.
.01916e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019170	c8		iny				iny
.019171	3a		dec a				dec 	a 							; make the actual length in charactes
.019172	3a		dec a				dec 	a
.019173	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019175	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019177	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019179	09 00		ora #$00			ora 	#0 							; if zero already, exit
.01917b	f0 0e		beq $01918b			beq 	_CTSCExit
.01917d					_CTSCLoop:
.01917d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01917f	c8		iny				iny
.019180	5a		phy				phy 								; save in Y
.019181	e8		inx				inx 								; bump index
.019182	da		phx				phx 								; index into Y
.019183	7a		ply				ply
.019184	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019186	7a		ply				ply 								; restore Y
.019187	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019189	d0 f2		bne $01917d			bne 	_CTSCLoop
.01918b					_CTSCExit:
.01918b	fa		plx				plx 								; restore X
.01918c	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.01918d					VariableFind:
.01918d	20 f8 91	jsr $0191f8			jsr 	VariableExtract 		; find out all about it ....
.019190	20 9a 94	jsr $01949a			jsr 	VariableLocate 			; does it already exist ?
.019193	b0 03		bcs $019198			bcs 	_VFExists 				; if so, use that.
.019195	20 84 92	jsr $019284			jsr 	VariableCreate 			; otherwise create it.
.019198					_VFExists:
.019198	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.01919a	29 01		and #$01			and 	#1
.01919c	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01919e	d0 28		bne $0191c8			bne 	_VFSingleElement
.0191a0					_VFNextIndex:
.0191a0	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.0191a2	48		pha				pha
.0191a3	a5 23		lda $23				lda 	zVarDataPtr+1
.0191a5	48		pha				pha
.0191a6	a5 24		lda $24				lda 	zVarType
.0191a8	48		pha				pha
.0191a9	20 6a 8a	jsr $018a6a			jsr 	EvaluateIntegerX 		; calculate the index.
.0191ac	68		pla				pla 							; restore and index.
.0191ad	85 24		sta $24				sta 	zVarType
.0191af	68		pla				pla
.0191b0	85 23		sta $23				sta 	zVarDataPtr+1
.0191b2	68		pla				pla
.0191b3	85 22		sta $22				sta 	zVarDataPtr
.0191b5	20 0f 93	jsr $01930f			jsr 	ArrayIndexFollow 		; do the index.
.0191b8	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.0191ba	29 01		and #$01			and 	#1
.0191bc	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.0191be	d0 05		bne $0191c5			bne 	_VFArrayDone 			; if so then exit.
.0191c0	20 f2 90	jsr $0190f2			jsr 	CheckNextComma 			; comma should follow
.0191c3	80 db		bra $0191a0			bra 	_VFNextIndex
.0191c5					_VFArrayDone:
.0191c5	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 		; check closing right bracket.
.0191c8					_VFSingleElement:
.0191c8	60		rts				rts
.0191c9					VariableClear:
.0191c9	48		pha				pha 							; save registers
.0191ca	da		phx				phx
.0191cb	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.0191cd	8a		txa				txa
.0191ce	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.0191d1	e8		inx				inx
.0191d2	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.0191d4	d0 f8		bne $0191ce			bne 	_VCLoop
.0191d6	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.0191d8	8d 02 04	sta $0402			sta 	VarMemPtr
.0191db	a9 40		lda #$40			lda 	#VariableMemory >> 8
.0191dd	8d 03 04	sta $0403			sta 	VarMemPtr+1
.0191e0	fa		plx				plx 							; restore registers
.0191e1	68		pla				pla
.0191e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.0191e3					VariableNameError:
.0191e3	20 2f 84	jsr $01842f			jsr ERR_Handler
>0191e6	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0191ee	61 62 6c 65 20 4e 61 6d 65 00
.0191f8					VariableExtract:
.0191f8	da		phx				phx 							; save X.
.0191f9	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0191fb	8d 85 04	sta $0485			sta 	Var_Type
.0191fe	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019201	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019203	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019205	f0 dc		beq $0191e3			beq 	VariableNameError
.019207	c9 1b		cmp #$1b			cmp 	#26+1
.019209	b0 d8		bcs $0191e3			bcs 	VariableNameError
.01920b	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.01920d					_VECopyBuffer:
.01920d	e8		inx				inx
.01920e	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019210	f0 d1		beq $0191e3			beq 	VariableNameError
.019212	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.019215	18		clc				clc  							; update the hash value for it.
.019216	6d 86 04	adc $0486			adc 	Var_Hash
.019219	8d 86 04	sta $0486			sta 	Var_Hash
.01921c	c8		iny				iny
.01921d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01921f	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019221	f0 0e		beq $019231			beq 	_VECopyEnd
.019223	30 0c		bmi $019231			bmi 	_VECopyEnd
.019225	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019227	90 e4		bcc $01920d			bcc 	_VECopyBuffer
.019229	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01922b	90 04		bcc $019231			bcc 	_VECopyEnd
.01922d	c9 3a		cmp #$3a			cmp 	#"9"+1
.01922f	90 dc		bcc $01920d			bcc 	_VECopyBuffer
.019231					_VECopyEnd:
.019231	c8		iny				iny
.019232	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019234	90 04		bcc $01923a			bcc 	_VEDefaultRequired
.019236	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019238	90 0b		bcc $019245			bcc 	_VEHaveType
.01923a					_VEDefaultRequired:
.01923a	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.01923c	f0 04		beq $019242			beq 	_VESetType 				; default set above.
.01923e	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.019241	88		dey				dey
.019242					_VESetType:
.019242	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.019245					_VEHaveType:
.019245	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.019248	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.01924b	09 80		ora #$80			ora 	#$80
.01924d	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.019250	e8		inx				inx 							; offset 3 => length 4.
.019251	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.019254	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.019257	38		sec				sec
.019258	e9 b7		sbc #$b7			sbc 	#token_Dollar
.01925a	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.01925b	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.01925c	0a		asl a				asl 	a
.01925d	0a		asl a				asl 	a
.01925e	8d 88 04	sta $0488			sta 	Var_HashAddress
.019261	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.019264	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019266	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019267	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.01926a	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.01926c	8d 88 04	sta $0488			sta 	Var_HashAddress
.01926f	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019271	ad 85 04	lda $0485			lda 	Var_Type
.019274	c9 b9		cmp #$b9			cmp 	#token_Hash
.019276	f0 07		beq $01927f			beq 	_VEHaveSize
.019278	ca		dex				dex
.019279	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.01927b	f0 02		beq $01927f			beq 	_VEHaveSize
.01927d	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.01927f					_VEHaveSize:
.01927f	8e 89 04	stx $0489			stx 	Var_DataSize
.019282	fa		plx				plx
.019283	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019284					VariableCreate:
.019284	da		phx				phx
.019285	5a		phy				phy
.019286	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.019289	85 10		sta $10				sta 	zTemp1
.01928b	ad 03 04	lda $0403			lda 	VarMemPtr+1
.01928e	85 11		sta $11				sta 	zTemp1+1
.019290	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.019293	18		clc				clc
.019294	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.019297	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019299	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.01929c	8d 02 04	sta $0402			sta 	VarMemPtr
.01929f	90 03		bcc $0192a4			bcc 	_VCNoCarry
.0192a1	ee 03 04	inc $0403			inc 	VarMemPtr+1
.0192a4					_VCNoCarry:
.0192a4	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0192a7	85 12		sta $12				sta 	zTemp2
.0192a9	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0192ab	85 13		sta $13				sta 	zTemp2+1
.0192ad	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.0192af	b1 12		lda ($12),y			lda 	(zTemp2),y
.0192b1	91 10		sta ($10),y			sta 	(zTemp1),y
.0192b3	c8		iny				iny
.0192b4	b1 12		lda ($12),y			lda 	(zTemp2),y
.0192b6	91 10		sta ($10),y			sta 	(zTemp1),y
.0192b8	c8		iny				iny
.0192b9	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.0192bc	91 10		sta ($10),y			sta 	(zTemp1),y
.0192be	c8		iny				iny
.0192bf	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.0192c1					_VCCopyName:
.0192c1	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.0192c4	91 10		sta ($10),y			sta 	(zTemp1),y
.0192c6	e8		inx				inx
.0192c7	c8		iny				iny
.0192c8	ec 87 04	cpx $0487			cpx 	Var_Length
.0192cb	d0 f4		bne $0192c1			bne 	_VCCopyName
.0192cd	5a		phy				phy 								; save the data offset.
.0192ce	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.0192d1	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.0192d3					_VCClearData:
.0192d3	91 10		sta ($10),y			sta 	(zTemp1),y
.0192d5	c8		iny				iny
.0192d6	ca		dex				dex
.0192d7	d0 fa		bne $0192d3			bne 	_VCClearData
.0192d9	68		pla				pla 								; offset to the data
.0192da	18		clc				clc
.0192db	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.0192dd	85 22		sta $22				sta 	zVarDataPtr
.0192df	a5 11		lda $11				lda 	zTemp1+1
.0192e1	69 00		adc #$00			adc 	#0
.0192e3	85 23		sta $23				sta 	zVarDataPtr+1
.0192e5	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.0192e8	85 24		sta $24				sta 	zVarType
.0192ea	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.0192ec	a0 00		ldy #$00			ldy 	#0
.0192ee	91 12		sta ($12),y			sta 	(zTemp2),y
.0192f0	c8		iny				iny
.0192f1	a5 11		lda $11				lda 	zTemp1+1
.0192f3	91 12		sta ($12),y			sta 	(zTemp2),y
.0192f5	ad 85 04	lda $0485			lda 	Var_Type 					; array ? if so create the empty one.
.0192f8	29 01		and #$01			and 	#1
.0192fa	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0192fc	d0 0e		bne $01930c			bne 	_VCNotArray
.0192fe	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019300	20 af 93	jsr $0193af			jsr 	ArrayCreate
.019303	5a		phy				phy 								; save YA at zVarDataPtr
.019304	a0 00		ldy #$00			ldy 	#0
.019306	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019308	c8		iny				iny
.019309	68		pla				pla
.01930a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01930c					_VCNotArray:
.01930c	7a		ply				ply
.01930d	fa		plx				plx
.01930e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.01930f					ArrayIndexFollow:
.01930f	5a		phy				phy
.019310	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019312	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019314	48		pha				pha
.019315	c8		iny				iny
.019316	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019318	85 23		sta $23				sta 	zVarDataPtr+1
.01931a	68		pla				pla
.01931b	85 22		sta $22				sta 	zVarDataPtr
.01931d	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019320	29 80		and #$80			and 	#$80 						; must be zero.
.019322	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019325	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019328	d0 5f		bne $019389			bne 	_AIFError
.01932a	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.01932c	18		clc				clc
.01932d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01932f	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019332	c8		iny				iny
.019333	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019335	08		php				php 								; clear bit 7 retaining borrow.
.019336	29 7f		and #$7f			and 	#$7F
.019338	28		plp				plp
.019339	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.01933c	90 4b		bcc $019389			bcc 	_AIFError 					; eror if size-current < 0
.01933e	bd 08 03	lda $0308,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019341	0a		asl a				asl 	a 							; (e.g. index * 2)
.019342	85 10		sta $10				sta 	zTemp1
.019344	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019347	2a		rol a				rol 	a
.019348	85 11		sta $11				sta 	zTemp1+1
.01934a	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.01934c	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.01934e	30 1f		bmi $01936f			bmi 	_AIFCalculate
.019350	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019352	a5 24		lda $24				lda 	zVarType 					; check that type
.019354	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019356	f0 17		beq $01936f			beq 	_AIFCalculate
.019358	06 10		asl $10				asl 	zTemp1			 			; double the index
.01935a	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.01935c	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.01935e	f0 0f		beq $01936f			beq 	_AIFCalculate
.019360	18		clc				clc 								; add the original mantissa in again
.019361	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019364	65 10		adc $10				adc 	zTemp1
.019366	85 10		sta $10				sta 	zTemp1
.019368	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01936b	65 11		adc $11				adc 	zTemp1+1
.01936d	85 11		sta $11				sta 	zTemp1+1
.01936f					_AIFCalculate:
.01936f	18		clc				clc 								; add index x 2,4 or 5 to base
.019370	a5 22		lda $22				lda 	zVarDataPtr
.019372	65 10		adc $10				adc 	zTemp1
.019374	85 22		sta $22				sta 	zVarDataPtr
.019376	a5 23		lda $23				lda 	zVarDataPtr+1
.019378	65 11		adc $11				adc 	zTemp1+1
.01937a	85 23		sta $23				sta 	zVarDataPtr+1
.01937c	18		clc				clc 								; add 2 more for the length prefix.
.01937d	a5 22		lda $22				lda 	zVarDataPtr
.01937f	69 02		adc #$02			adc 	#2
.019381	85 22		sta $22				sta 	zVarDataPtr
.019383	90 02		bcc $019387			bcc 	_AIFNoBump
.019385	e6 23		inc $23				inc 	zVarDataPtr+1
.019387					_AIFNoBump:
.019387	7a		ply				ply
.019388	60		rts				rts
.019389					_AIFError:
.019389	20 2f 84	jsr $01842f			jsr ERR_Handler
>01938c	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019394	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.01939c					ArrayResetDefault:
.01939c	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.01939e	8d 97 04	sta $0497			sta 	ArrayDef+0
.0193a1	a9 00		lda #$00			lda 	#0
.0193a3	8d 98 04	sta $0498			sta 	ArrayDef+1
.0193a6	a9 ff		lda #$ff			lda 	#$FF
.0193a8	8d 99 04	sta $0499			sta 	ArrayDef+2 					; $FFFF implies no second element.
.0193ab	8d 9a 04	sta $049a			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.0193ae	60		rts				rts
.0193af					ArrayCreate:
.0193af	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.0193b2	0a		asl a				asl 	a
.0193b3	85 10		sta $10				sta 	zTemp1
.0193b5	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.0193b8	2a		rol a				rol 	a
.0193b9	85 11		sta $11				sta 	zTemp1+1
.0193bb	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.0193be	10 22		bpl $0193e2			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.0193c0	ad 85 04	lda $0485			lda 	Var_Type 					; check the type
.0193c3	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.0193c5	f0 1b		beq $0193e2			beq 	_ACSized
.0193c7	06 10		asl $10				asl 	zTemp1 						; double again
.0193c9	26 11		rol $11				rol 	zTemp1+1
.0193cb	b0 6f		bcs $01943c			bcs 	ArrayIndexError 			; too large.
.0193cd	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.0193cf	f0 11		beq $0193e2			beq 	_ACSized
.0193d1	18		clc				clc 								; add original value x 5 for reals.
.0193d2	a5 10		lda $10				lda 	zTemp1
.0193d4	7d 97 04	adc $0497,x			adc 	ArrayDef+0,x
.0193d7	85 10		sta $10				sta 	zTemp1
.0193d9	a5 11		lda $11				lda 	zTemp1+1
.0193db	7d 98 04	adc $0498,x			adc 	ArrayDef+1,x
.0193de	85 11		sta $11				sta 	zTemp1+1
.0193e0	b0 5a		bcs $01943c			bcs 	ArrayIndexError
.0193e2					_ACSized:
.0193e2	18		clc				clc
.0193e3	a5 10		lda $10				lda 	zTemp1
.0193e5	69 02		adc #$02			adc 	#2
.0193e7	85 10		sta $10				sta 	zTemp1
.0193e9	90 04		bcc $0193ef			bcc 	_ACNoBump
.0193eb	e6 10		inc $10				inc 	zTemp1
.0193ed	f0 4d		beq $01943c			beq 	ArrayIndexError
.0193ef					_ACNoBump:
.0193ef	18		clc				clc
.0193f0	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.0193f3	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.0193f5	85 14		sta $14				sta 	zTemp3
.0193f7	65 10		adc $10				adc 	zTemp1
.0193f9	8d 02 04	sta $0402			sta 	VarMemPtr
.0193fc	ad 03 04	lda $0403			lda 	VarMemPtr+1
.0193ff	85 13		sta $13				sta 	zTemp2+1
.019401	85 15		sta $15				sta 	zTemp3+1
.019403	65 11		adc $11				adc 	zTemp1+1
.019405	8d 03 04	sta $0403			sta 	VarMemPtr+1
.019408	85 11		sta $11				sta 	zTemp1+1
.01940a	b0 30		bcs $01943c			bcs 	ArrayIndexError
.01940c	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.01940e					_ACClear:
.01940e	98		tya				tya
.01940f	91 12		sta ($12),y			sta 	(zTemp2),y
.019411	e6 12		inc $12				inc 	zTemp2
.019413	d0 02		bne $019417			bne 	_ACCBump
.019415	e6 13		inc $13				inc 	zTemp2+1
.019417					_ACCBump:
.019417	a5 12		lda $12				lda 	zTemp2
.019419	cd 02 04	cmp $0402			cmp 	VarMemPtr
.01941c	d0 f0		bne $01940e			bne 	_ACClear
.01941e	a5 13		lda $13				lda 	zTemp2+1
.019420	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.019423	d0 e9		bne $01940e			bne 	_ACClear
.019425	a0 00		ldy #$00			ldy 	#0
.019427	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; copy the size into the start
.01942a	91 14		sta ($14),y			sta 	(zTemp3),y
.01942c	c8		iny				iny
.01942d	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.019430	91 14		sta ($14),y			sta 	(zTemp3),y
.019432	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; have we reached the end
.019435	10 18		bpl $01944f			bpl 	ACCFillRecursive
.019437	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019439	a5 14		lda $14				lda 	zTemp3
.01943b	60		rts				rts
.01943c					ArrayIndexError:
.01943c	20 2f 84	jsr $01842f			jsr ERR_Handler
>01943f	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019447	79 20 69 6e 64 65 78 00
.01944f					ACCFillRecursive:
.01944f	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019451	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019453	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019455	c8		iny				iny
.019456	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019458	09 80		ora #$80			ora 	#$80 						; an array of pointers
.01945a	91 14		sta ($14),y			sta 	(zTemp3),y
.01945c	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.01945e	48		pha				pha
.01945f	a5 15		lda $15				lda 	zTemp3+1
.019461	48		pha				pha
.019462					_ACCFillLoop:
.019462	18		clc				clc
.019463	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019465	69 02		adc #$02			adc 	#2
.019467	85 14		sta $14				sta 	zTemp3
.019469	90 02		bcc $01946d			bcc 	_ACCSkip2
.01946b	e6 14		inc $14				inc 	zTemp3
.01946d					_ACCSkip2:
.01946d	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.01946f	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019471	c8		iny				iny
.019472	11 14		ora ($14),y			ora 	(zTemp3),y
.019474	d0 21		bne $019497			bne 	_ACCExit
.019476	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019478	48		pha				pha
.019479	a5 15		lda $15				lda 	zTemp3+1
.01947b	48		pha				pha
.01947c	e8		inx				inx
.01947d	e8		inx				inx
.01947e	20 af 93	jsr $0193af			jsr 	ArrayCreate 				; create array recursively.
.019481	ca		dex				dex
.019482	ca		dex				dex
.019483	85 12		sta $12				sta 	zTemp2 						; save A
.019485	68		pla				pla
.019486	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019488	68		pla				pla
.019489	85 14		sta $14				sta 	zTemp3
.01948b	98		tya				tya 								; write high bye from Y
.01948c	a0 01		ldy #$01			ldy 	#1
.01948e	91 14		sta ($14),y			sta 	(zTemp3),y
.019490	88		dey				dey 								; write low byte out.
.019491	a5 12		lda $12				lda 	zTemp2
.019493	91 14		sta ($14),y			sta 	(zTemp3),y
.019495	80 cb		bra $019462			bra 	_ACCFillLoop 				; and try again.
.019497					_ACCExit:
.019497	7a		ply				ply 								; restore the original address
.019498	68		pla				pla
.019499	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01949a					VariableLocate:
.01949a	da		phx				phx
.01949b	5a		phy				phy
.01949c	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01949f	85 12		sta $12				sta 	zTemp2 						; points to first address.
.0194a1	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0194a3	85 13		sta $13				sta 	zTemp2+1
.0194a5	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.0194a7	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194a9	aa		tax				tax
.0194aa	c8		iny				iny
.0194ab	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194ad	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.0194af	86 12		stx $12				stx 	zTemp2
.0194b1	05 12		ora $12				ora 	zTemp2 						; got zero
.0194b3	18		clc				clc
.0194b4	f0 25		beq $0194db			beq 	_VLExit 					; if so, then fail as end of chain.
.0194b6	c8		iny				iny 								; point to hash (offset + 2)
.0194b7	b1 12		lda ($12),y			lda 	(zTemp2),y
.0194b9	cd 86 04	cmp $0486			cmp 	Var_Hash
.0194bc	d0 e7		bne $0194a5			bne 	_VLNext 					; try next if different.
.0194be					_VLCompare:
.0194be	c8		iny				iny 								; next character
.0194bf	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.0194c1	d9 02 04	cmp $0402,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.0194c4	d0 df		bne $0194a5			bne 	_VLNext 					; fail if different, try next.
.0194c6	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.0194c7	90 f5		bcc $0194be			bcc 	_VLCompare
.0194c9	98		tya				tya
.0194ca	38		sec				sec 								; add 1 as Y points to last character
.0194cb	65 12		adc $12				adc 	zTemp2 						; add to the current address
.0194cd	85 22		sta $22				sta 	zVarDataPtr
.0194cf	a5 13		lda $13				lda 	zTemp2+1
.0194d1	69 00		adc #$00			adc 	#0
.0194d3	85 23		sta $23				sta 	zVarDataPtr+1
.0194d5	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.0194d8	85 24		sta $24				sta 	zVarType
.0194da	38		sec				sec 								; return CS
.0194db	7a		ply		_VLExit:ply
.0194dc	fa		plx				plx
.0194dd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.0194de					VariableGet:
.0194de	5a		phy				phy
.0194df	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.0194e1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194e3	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0194e6	c8		iny				iny
.0194e7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194e9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0194ec	c8		iny				iny
.0194ed	ad 85 04	lda $0485			lda 	Var_Type 					; if it is a string, set up for that.
.0194f0	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0194f2	f0 35		beq $019529			beq 	_VGString
.0194f4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.0194f6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0194f9	c8		iny				iny
.0194fa	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0194fc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0194ff	c8		iny				iny
.019500	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019502	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019505	ad 85 04	lda $0485			lda 	Var_Type
.019508	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01950a	f0 31		beq $01953d			beq 	_VGExit
.01950c	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01950e	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019511	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019513	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019516	f0 25		beq $01953d			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019518	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01951b	48		pha				pha
.01951c	29 80		and #$80			and 	#$80
.01951e	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.019521	68		pla				pla
.019522	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019524	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019527	80 14		bra $01953d			bra 	_VGExit
.019529					_VGString:
.019529	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01952b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01952e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019531	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019534	d0 07		bne $01953d			bne 	_VGExit 					; if not, exit.
.019536	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019538	a9 25		lda #$25			lda 	#zNullString
.01953a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.01953d					_VGExit:
.01953d	7a		ply				ply
.01953e	60		rts				rts
.01953f					VariableSet:
.01953f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.019542	29 02		and #$02			and 	#2 							; if so, it has to be
.019544	d0 53		bne $019599			bne 	_VSString
.019546	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019548	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01954a	f0 4a		beq $019596			beq 	_VSBadType
.01954c	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01954e	f0 05		beq $019555			beq 	_VSMakeInt
.019550	20 4b 9b	jsr $019b4b			jsr 	FPUToFloat
.019553	80 03		bra $019558			bra 	_VSCopy
.019555					_VSMakeInt:
.019555	20 aa 9b	jsr $019baa			jsr 	FPUToInteger
.019558					_VSCopy:
.019558	5a		phy				phy
.019559	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01955b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01955e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019560	c8		iny				iny
.019561	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019564	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019566	c8		iny				iny
.019567	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01956a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01956c	c8		iny				iny
.01956d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019570	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019572	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019574	c9 bb		cmp #$bb			cmp 	#token_Percent
.019576	f0 1c		beq $019594			beq 	_VSExit
.019578	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01957b	0a		asl a				asl 	a
.01957c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01957f	08		php				php
.019580	0a		asl a				asl 	a
.019581	28		plp				plp
.019582	6a		ror a				ror 	a
.019583	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019585	c8		iny				iny
.019586	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.019589	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01958b	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.01958e	50 04		bvc $019594			bvc 	_VSExit
.019590	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019592	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019594					_VSExit:
.019594	7a		ply				ply
.019595	60		rts				rts
.019596					_VSBadType:
.019596	4c 10 84	jmp $018410			jmp 	TypeError
.019599					_VSString:
.019599	a5 24		lda $24				lda 	zVarType 					; type must be $
.01959b	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01959d	d0 f7		bne $019596			bne 	_VSBadType
.01959f	da		phx				phx
.0195a0	5a		phy				phy
.0195a1	20 fa 90	jsr $0190fa			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.0195a4	a0 01		ldy #$01			ldy 	#1 							; save high byte
.0195a6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195a8	88		dey				dey 								; save low byte
.0195a9	8a		txa				txa
.0195aa	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0195ac	7a		ply				ply 								; and exit.
.0195ad	fa		plx				plx
.0195ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.0195af					MulInteger32:
.0195af	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.0195b2	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.0195b5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0195b8	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.0195bb	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0195be	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.0195c1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0195c4	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.0195c7	a9 00		lda #$00			lda 	#0
.0195c9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.0195cc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0195cf	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0195d2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0195d5					_BFMMultiply:
.0195d5	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.0195d8	29 01		and #$01			and 	#1
.0195da	f0 03		beq $0195df			beq 	_BFMNoAdd
.0195dc	20 4f 8c	jsr $018c4f			jsr 	AddInteger32
.0195df					_BFMNoAdd:
.0195df	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.0195e2	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.0195e5	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.0195e8	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.0195eb	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.0195ee	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.0195f1	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.0195f4	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.0195f7	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.0195fa	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.0195fd	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.019600	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.019603	d0 d0		bne $0195d5			bne 	_BFMMultiply
.019605	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019606					DivInteger32:
.019606	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019609	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.01960c	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.01960f	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019612	d0 14		bne $019628			bne 	_BFDOkay
.019614	20 2f 84	jsr $01842f			jsr ERR_Handler
>019617	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01961f	20 62 79 20 5a 65 72 6f 00
.019628					_BFDOkay:
.019628	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01962a	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01962c	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01962e	85 1c		sta $1c				sta 	zLTemp1+2
.019630	85 1d		sta $1d				sta 	zLTemp1+3
.019632	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.019635	20 96 96	jsr $019696			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019638	da		phx				phx
.019639	e8		inx				inx
.01963a	e8		inx				inx
.01963b	e8		inx				inx
.01963c	e8		inx				inx
.01963d	e8		inx				inx
.01963e	e8		inx				inx
.01963f	20 96 96	jsr $019696			jsr 	CheckIntegerNegate
.019642	fa		plx				plx
.019643	5a		phy				phy 								; Y is the counter
.019644	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019646					_BFDLoop:
.019646	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019649	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01964c	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.01964f	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019652	26 1a		rol $1a				rol 	zLTemp1
.019654	26 1b		rol $1b				rol 	zLTemp1+1
.019656	26 1c		rol $1c				rol 	zLTemp1+2
.019658	26 1d		rol $1d				rol 	zLTemp1+3
.01965a	38		sec				sec
.01965b	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01965d	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.019660	48		pha				pha
.019661	a5 1b		lda $1b				lda 	zLTemp1+1
.019663	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019666	48		pha				pha
.019667	a5 1c		lda $1c				lda 	zLTemp1+2
.019669	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.01966c	48		pha				pha
.01966d	a5 1d		lda $1d				lda 	zLTemp1+3
.01966f	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019672	90 15		bcc $019689			bcc 	_BFDNoAdd
.019674	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019676	68		pla				pla
.019677	85 1c		sta $1c				sta 	zLTemp1+2
.019679	68		pla				pla
.01967a	85 1b		sta $1b				sta 	zLTemp1+1
.01967c	68		pla				pla
.01967d	85 1a		sta $1a				sta 	zLTemp1+0
.01967f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019682	09 01		ora #$01			ora 	#1
.019684	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019687	80 03		bra $01968c			bra 	_BFDNext
.019689					_BFDNoAdd:
.019689	68		pla				pla 								; Throw away the intermediate calculations
.01968a	68		pla				pla
.01968b	68		pla				pla
.01968c					_BFDNext:
.01968c	88		dey				dey
.01968d	d0 b7		bne $019646			bne 	_BFDLoop
.01968f	7a		ply				ply 								; restore Y and exit
.019690	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.019693	b0 07		bcs $01969c			bcs		IntegerNegateAlways 			; negate the result
.019695	60		rts				rts
.019696					CheckIntegerNegate:
.019696	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019699	30 01		bmi $01969c			bmi 	IntegerNegateAlways
.01969b	60		rts				rts
.01969c					IntegerNegateAlways:
.01969c	ee 8e 04	inc $048e			inc 	SignCount
.01969f	38		sec				sec
.0196a0	a9 00		lda #$00			lda 	#0
.0196a2	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0196a5	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0196a8	a9 00		lda #$00			lda 	#0
.0196aa	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0196ad	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0196b0	a9 00		lda #$00			lda 	#0
.0196b2	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0196b5	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0196b8	a9 00		lda #$00			lda 	#0
.0196ba	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0196bd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0196c0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.0196c1					INTToString:
.0196c1	48		pha				pha
.0196c2	5a		phy				phy
.0196c3	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.0196c6	10 08		bpl $0196d0			bpl 		_ITSNotMinus
.0196c8	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.0196ca	20 65 97	jsr $019765			jsr 		ITSOutputCharacter
.0196cd	20 9c 96	jsr $01969c			jsr 		IntegerNegateAlways 	; negate the number.
.0196d0					_ITSNotMinus:
.0196d0	a9 00		lda #$00			lda 		#0
.0196d2	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.0196d5	8a		txa				txa 								; use Y for the mantissa index.
.0196d6	a8		tay				tay
.0196d7	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.0196d9					_ITSNextSubtractor:
.0196d9	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.0196db	8d 8b 04	sta $048b			sta 		NumConvCount
.0196de					_ITSSubtract:
.0196de	38		sec				sec
.0196df	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.0196e2	ff 41 97 01	sbc $019741,x			sbc 		_ITSSubtractors+0,x
.0196e6	48		pha				pha
.0196e7	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.0196ea	ff 42 97 01	sbc $019742,x			sbc 		_ITSSubtractors+1,x
.0196ee	48		pha				pha
.0196ef	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.0196f2	ff 43 97 01	sbc $019743,x			sbc 		_ITSSubtractors+2,x
.0196f6	48		pha				pha
.0196f7	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.0196fa	ff 44 97 01	sbc $019744,x			sbc 		_ITSSubtractors+3,x
.0196fe	90 14		bcc $019714			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019700	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019703	68		pla				pla
.019704	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.019707	68		pla				pla
.019708	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.01970b	68		pla				pla
.01970c	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.01970f	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.019712	80 ca		bra $0196de			bra 		_ITSSubtract 			; go round again.
.019714					_ITSCantSubtract:
.019714	68		pla				pla 								; throw away interim answers
.019715	68		pla				pla
.019716	68		pla				pla
.019717	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.01971a	c9 30		cmp #$30			cmp 		#"0"
.01971c	d0 05		bne $019723			bne 		_ITSOutputDigit
.01971e	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019721	10 09		bpl $01972c			bpl	 		_ITSGoNextSubtractor
.019723					_ITSOutputDigit:
.019723	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.019726	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.019729	20 65 97	jsr $019765			jsr 		ITSOutputCharacter 		; output it.
.01972c					_ITSGoNextSubtractor:
.01972c	e8		inx				inx 								; next dword
.01972d	e8		inx				inx
.01972e	e8		inx				inx
.01972f	e8		inx				inx
.019730	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019732	d0 a5		bne $0196d9			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019734	98		tya				tya 								; X is back as the mantissa index
.019735	aa		tax				tax
.019736	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019739	09 30		ora #$30			ora 		#"0"
.01973b	20 65 97	jsr $019765			jsr 		ITSOutputCharacter
.01973e	7a		ply				ply 								; and exit
.01973f	68		pla				pla
.019740	60		rts				rts
.019741					_ITSSubtractors:
>019741	00 ca 9a 3b					.dword 		1000000000
>019745	00 e1 f5 05					.dword 		100000000
>019749	80 96 98 00					.dword 		10000000
>01974d	40 42 0f 00					.dword 		1000000
>019751	a0 86 01 00					.dword 		100000
>019755	10 27 00 00					.dword 		10000
>019759	e8 03 00 00					.dword 		1000
>01975d	64 00 00 00					.dword 		100
>019761	0a 00 00 00					.dword 		10
.019765					_ITSSubtractorsEnd:
.019765					ITSOutputCharacter:
.019765	48		pha				pha
.019766	da		phx				phx
.019767	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.01976a	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.01976d	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01976f	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.019772	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.019775	fa		plx				plx
.019776	68		pla				pla
.019777	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019778					IntFromString:
.019778	a0 00		ldy #$00			ldy 	#0
.01977a	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.01977d					IntFromStringY:
.01977d	48		pha				pha
.01977e	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019780	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019783	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019786	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019789	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01978c	a9 01		lda #$01			lda 	#1
.01978e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019791					_IFSLoop:
.019791	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019793	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019795	90 60		bcc $0197f7			bcc 	_IFSExit
.019797	c9 3a		cmp #$3a			cmp 	#"9"+1
.019799	b0 5c		bcs $0197f7			bcs 	_IFSExit
.01979b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01979e	c9 0c		cmp #$0c			cmp 	#12
.0197a0	b0 5f		bcs $019801			bcs 	_IFSOverflow
.0197a2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.0197a5	48		pha				pha
.0197a6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0197a9	48		pha				pha
.0197aa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0197ad	48		pha				pha
.0197ae	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0197b1	48		pha				pha
.0197b2	20 16 98	jsr $019816			jsr 	IFSX1ShiftLeft 				; double
.0197b5	20 16 98	jsr $019816			jsr 	IFSX1ShiftLeft 				; x 4
.0197b8	18		clc				clc 								; add saved value x 5
.0197b9	68		pla				pla
.0197ba	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.0197bd	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197c0	68		pla				pla
.0197c1	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.0197c4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0197c7	68		pla				pla
.0197c8	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.0197cb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0197ce	68		pla				pla
.0197cf	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.0197d2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0197d5	20 16 98	jsr $019816			jsr 	IFSX1ShiftLeft 				; x 10
.0197d8	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.0197db	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.0197dd	29 0f		and #$0f			and 	#15
.0197df	c8		iny				iny
.0197e0	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.0197e3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197e6	90 a9		bcc $019791			bcc 	_IFSLoop
.0197e8	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.0197eb	d0 a4		bne $019791			bne 	_IFSLoop
.0197ed	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.0197f0	d0 9f		bne $019791			bne 	_IFSLoop
.0197f2	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.0197f5	80 9a		bra $019791			bra 	_IFSLoop
.0197f7					_IFSExit:
.0197f7	98		tya				tya 								; get offset
.0197f8					_IFSOkay:
.0197f8	38		sec				sec
.0197f9	ad 8c 04	lda $048c			lda 	ExpTemp
.0197fc	f0 01		beq $0197ff			beq 	_IFSSkipFail
.0197fe	18		clc				clc
.0197ff					_IFSSkipFail:
.0197ff	68		pla				pla 								; and exit.
.019800	60		rts				rts
.019801					_IFSOverflow:
.019801	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019804	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01980c	20 6f 76 65 72 66 6c 6f 77 00
.019816					IFSX1ShiftLeft:
.019816	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.019819	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01981c	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.01981f	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019822	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019823					FPSubtract:
.019823	48		pha				pha
.019824	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019827	49 80		eor #$80			eor 	#$80
.019829	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.01982c	68		pla				pla 								; --- and fall through ---
.01982d					FPAdd:
.01982d	48		pha				pha
.01982e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019831	d0 05		bne $019838			bne 	_FPA_NegativeLHS
.019833	20 55 98	jsr $019855			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019836	68		pla				pla
.019837	60		rts				rts
.019838					_FPA_NegativeLHS:
.019838	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01983b	49 80		eor #$80			eor 	#$80
.01983d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019840	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019843	49 80		eor #$80			eor 	#$80
.019845	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019848	20 55 98	jsr $019855			jsr 	FPAdd_Worker 				; do the add calculation.
.01984b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.01984e	49 80		eor #$80			eor 	#$80
.019850	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019853	68		pla				pla
.019854	60		rts				rts
.019855					FPAdd_Worker:
.019855	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019858	70 08		bvs $019862			bvs 	_FPAWExit 					; no change.
.01985a	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01985d	50 07		bvc $019866			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01985f	20 fa 9a	jsr $019afa			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019862					_FPAWExit:
.019862	20 82 9b	jsr $019b82			jsr 	FPUNormalise 				; normalise the result.
.019865	60		rts				rts
.019866					_FPAWMakeSame:
.019866	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019869	38		sec				sec
.01986a	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01986d	f0 1b		beq $01988a			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01986f	da		phx				phx 								; save X
.019870	90 06		bcc $019878			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019872	e8		inx				inx
.019873	e8		inx				inx
.019874	e8		inx				inx
.019875	e8		inx				inx
.019876	e8		inx				inx
.019877	e8		inx				inx
.019878					_FPAWShiftA:
.019878	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01987b	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.01987e	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019881	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019884	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019887	fa		plx				plx 								; restore original X
.019888	80 dc		bra $019866			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01988a					_FPAW_DoArithmetic:
.01988a	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01988d	30 39		bmi $0198c8			bmi 	_FPAW_BNegative
.01988f	18		clc				clc
.019890	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019893	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019896	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019899	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01989c	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.01989f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0198a2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0198a5	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0198a8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198ab	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0198ae	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0198b1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0198b4	90 ac		bcc $019862			bcc 	_FPAWExit 					; no carry.
.0198b6	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0198b9	38		sec				sec
.0198ba	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0198bd	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0198c0	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0198c3	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0198c6	80 9a		bra $019862			bra 	_FPAWExit
.0198c8					_FPAW_BNegative:
.0198c8	38		sec				sec
.0198c9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0198cc	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0198cf	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0198d2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0198d5	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0198d8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0198db	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0198de	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0198e1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198e4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0198e7	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0198ea	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0198ed	b0 0b		bcs $0198fa			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.0198ef	20 27 9b	jsr $019b27			jsr 	FPUNegateInteger			; negate the mantissa
.0198f2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.0198f5	49 80		eor #$80			eor 	#$80
.0198f7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0198fa					_FPAWGoExit:
.0198fa	4c 62 98	jmp $019862			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.0198fd					FPD_IsDivZero:
.0198fd	20 2f 84	jsr $01842f			jsr ERR_Handler
>019900	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019908	20 62 79 20 7a 65 72 6f 00
.019911					FPDivide:
.019911	48		pha				pha
.019912	5a		phy				phy
.019913	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.019916	70 e5		bvs $0198fd			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019918	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01991b	f0 03		beq $019920			beq 	_FPDCalculateExp
.01991d					_FPD_Exit:
.01991d	7a		ply				ply
.01991e	68		pla				pla
.01991f	60		rts				rts
.019920					_FPDCalculateExp:
.019920	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019923	49 ff		eor #$ff			eor 	#$FF
.019925	1a		inc a				inc 	a
.019926	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.019929	20 1d 9a	jsr $019a1d			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01992c	18		clc				clc 	 							; add 1 to the resulting exponent
.01992d	69 01		adc #$01			adc 	#1
.01992f	b0 65		bcs $019996			bcs 	_FPD_Overflow 				; which can overflow.
.019931	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019934	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019936	85 1a		sta $1a				sta 	zLTemp1+0
.019938	85 1b		sta $1b				sta 	zLTemp1+1
.01993a	85 1c		sta $1c				sta 	zLTemp1+2
.01993c	85 1d		sta $1d				sta 	zLTemp1+3
.01993e	a0 20		ldy #$20			ldy 	#32 						; times round.
.019940					_FPD_Loop:
.019940	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019941	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.019944	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.019947	48		pha				pha
.019948	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01994b	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.01994e	48		pha				pha
.01994f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019952	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019955	48		pha				pha
.019956	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019959	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01995c	90 17		bcc $019975			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01995e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019961	68		pla				pla
.019962	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019965	68		pla				pla
.019966	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019969	68		pla				pla
.01996a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01996d	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01996f	09 80		ora #$80			ora 	#$80
.019971	85 1d		sta $1d				sta 	zLTemp1+3
.019973	80 03		bra $019978			bra 	_FPD_Rotates
.019975					_FPD_NoSubtract:
.019975	68		pla				pla 								; throw away unwanted results
.019976	68		pla				pla
.019977	68		pla				pla
.019978					_FPD_Rotates:
.019978	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.01997b	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.01997e	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.019981	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.019984	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019986	26 1b		rol $1b				rol 	zLTemp1+1
.019988	26 1c		rol $1c				rol 	zLTemp1+2
.01998a	26 1d		rol $1d				rol 	zLTemp1+3
.01998c	90 02		bcc $019990			bcc 	_FPD_NoCarry
.01998e	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019990					_FPD_NoCarry:
.019990	88		dey				dey 								; do 32 times
.019991	d0 ad		bne $019940			bne 	_FPD_Loop
.019993	4c fa 99	jmp $0199fa			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019996					_FPD_Overflow:
.019996	4c f7 9b	jmp $019bf7			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019999					FPMultiply:
.019999	48		pha				pha
.01999a	5a		phy				phy
.01999b	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01999e	70 08		bvs $0199a8			bvs 	_FPM_Exit
.0199a0	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.0199a3	50 06		bvc $0199ab			bvc 	_FPM_CalcExponent
.0199a5	20 fa 9a	jsr $019afa			jsr 	FPUCopyX2ToX1
.0199a8					_FPM_Exit:
.0199a8	7a		ply				ply
.0199a9	68		pla				pla
.0199aa	60		rts				rts
.0199ab					_FPM_CalcExponent:
.0199ab	18		clc				clc
.0199ac	20 1d 9a	jsr $019a1d			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.0199af	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.0199b2	a9 00		lda #$00			lda 	#0
.0199b4	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.0199b6	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.0199b8	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.0199ba	85 1d		sta $1d				sta 	zLTemp1+3
.0199bc	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.0199be					_FPM_Loop:
.0199be	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.0199c1	29 01		and #$01			and 	#1
.0199c3	18		clc				clc 								; clear carry for the long rotate.
.0199c4	f0 1d		beq $0199e3			beq 	_FPM_NoAddition
.0199c6	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.0199c7	a5 1a		lda $1a				lda 	zLTemp1+0
.0199c9	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0199cc	85 1a		sta $1a				sta 	zLTemp1+0
.0199ce	a5 1b		lda $1b				lda 	zLTemp1+1
.0199d0	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.0199d3	85 1b		sta $1b				sta 	zLTemp1+1
.0199d5	a5 1c		lda $1c				lda 	zLTemp1+2
.0199d7	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.0199da	85 1c		sta $1c				sta 	zLTemp1+2
.0199dc	a5 1d		lda $1d				lda 	zLTemp1+3
.0199de	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0199e1	85 1d		sta $1d				sta 	zLTemp1+3
.0199e3					_FPM_NoAddition:
.0199e3	66 1d		ror $1d				ror 	3+zLTemp1
.0199e5	66 1c		ror $1c				ror 	2+zLTemp1
.0199e7	66 1b		ror $1b				ror 	1+zLTemp1
.0199e9	66 1a		ror $1a				ror 	0+zLTemp1
.0199eb	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0199ee	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0199f1	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0199f4	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0199f7	88		dey				dey
.0199f8	d0 c4		bne $0199be			bne 	_FPM_Loop 					; do this 32 times.
.0199fa					FPM_CopySignNormalize:
.0199fa	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.0199fc	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.0199ff	a5 1b		lda $1b				lda 	zLTemp1+1
.019a01	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019a04	a5 1c		lda $1c				lda 	zLTemp1+2
.019a06	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019a09	a5 1d		lda $1d				lda 	zLTemp1+3
.019a0b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019a0e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019a11	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019a14	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a17	20 82 9b	jsr $019b82			jsr 	FPUNormalise 				; normalise and exit.
.019a1a	7a		ply				ply
.019a1b	68		pla				pla
.019a1c	60		rts				rts
.019a1d					FPCalculateExponent:
.019a1d	18		clc				clc
.019a1e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019a21	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019a24	b0 08		bcs $019a2e			bcs 	_FPCECarry 					; carry out ?
.019a26	10 03		bpl $019a2b			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019a28	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019a2a	60		rts				rts
.019a2b					_FPCEExpZero:
.019a2b	a9 00		lda #$00			lda 	#0
.019a2d	60		rts				rts
.019a2e					_FPCECarry:
.019a2e	30 03		bmi $019a33			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019a30	09 80		ora #$80			ora 	#$80 						; put in right range
.019a32	60		rts				rts
.019a33					_FPCEOverflow:
.019a33	4c f7 9b	jmp $019bf7			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019a36					FPFractionalPart:
.019a36	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019a39	38		sec				sec 								; this flag tells us to keep the fractional part
.019a3a	30 0f		bmi $019a4b			bmi 	FPGetPart
.019a3c	60		rts				rts
.019a3d					FPIntegerPart:
.019a3d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019a40	18		clc				clc 								; this flag says keep the integer part.
.019a41	30 08		bmi $019a4b			bmi 	FPGetPart 					; -ve exponents are 0..127
.019a43	48		pha				pha
.019a44	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019a46	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a49	68		pla				pla
.019a4a	60		rts				rts
.019a4b					FPGetPart:
.019a4b	48		pha				pha
.019a4c	5a		phy				phy 								; save Y
.019a4d	08		php				php 								; save action
.019a4e	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019a51	70 62		bvs $019ab5			bvs 	_FPGP_Exit 					; then do nothing.
.019a53	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019a55	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019a57	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019a59	85 1c		sta $1c				sta 	zLTemp1+2
.019a5b	85 1d		sta $1d				sta 	zLTemp1+3
.019a5d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.019a60	38		sec				sec
.019a61	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019a63	f0 12		beq $019a77			beq 	_FPGP_NoShift 				; ... if any
.019a65	c9 20		cmp #$20			cmp 	#32
.019a67	90 02		bcc $019a6b			bcc 	_FPGP_NotMax
.019a69	a9 20		lda #$20			lda 	#32 						; max of 32.
.019a6b					_FPGP_NotMax:
.019a6b	a8		tay				tay 								; Y is the mask shift count.
.019a6c					_FPGP_ShiftMask:
.019a6c	46 1d		lsr $1d				lsr 	3+zLTemp1
.019a6e	66 1c		ror $1c				ror 	2+zLTemp1
.019a70	66 1b		ror $1b				ror 	1+zLTemp1
.019a72	66 1a		ror $1a				ror 	0+zLTemp1
.019a74	88		dey				dey
.019a75	d0 f5		bne $019a6c			bne 	_FPGP_ShiftMask
.019a77					_FPGP_NoShift:
.019a77	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019a79	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.019a7c					_FPGP_MaskLoop:
.019a7c	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019a7f	28		plp				plp 								; if CC we keep the top part, so we
.019a80	08		php				php		 							; flip the mask.
.019a81	b0 02		bcs $019a85			bcs		_FPGP_NoFlip
.019a83	49 ff		eor #$ff			eor 	#$FF
.019a85					_FPGP_NoFlip:
.019a85	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019a88	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019a8b	e8		inx				inx
.019a8c	c8		iny				iny
.019a8d	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019a8f	d0 eb		bne $019a7c			bne 	_FPGP_MaskLoop
.019a91	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.019a94	28		plp				plp
.019a95	08		php				php 								; get action flag on the stack
.019a96	90 05		bcc $019a9d			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019a98	a9 00		lda #$00			lda 	#0
.019a9a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a9d					_FPGP_NotFractional:
.019a9d	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019aa0	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019aa3	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019aa6	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019aa9	f0 05		beq $019ab0			beq 	_FPGP_Zero 					; if zero, return zero
.019aab	20 82 9b	jsr $019b82			jsr 	FPUNormalise
.019aae	80 05		bra $019ab5			bra 	_FPGP_Exit 					; and exit
.019ab0					_FPGP_Zero:
.019ab0	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019ab2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019ab5					_FPGP_Exit:
.019ab5	68		pla				pla 								; throw saved action flag.
.019ab6	7a		ply				ply
.019ab7	68		pla				pla
.019ab8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019ab9					FPCompare:
.019ab9	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019abc	48		pha				pha
.019abd	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019ac0	48		pha				pha
.019ac1	20 23 98	jsr $019823			jsr 	FPSubtract 					; calculate X1-X2
.019ac4	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019ac7	70 2c		bvs $019af5			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019ac9	68		pla				pla
.019aca	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.019acd	68		pla				pla
.019ace	38		sec				sec
.019acf	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.019ad2	70 15		bvs $019ae9			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019ad4	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019ad5	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019ad7	b0 10		bcs $019ae9			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019ad9	38		sec				sec
.019ada	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.019add	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019adf	b0 02		bcs $019ae3			bcs 	_FPCNotRange 				; keep in range.
.019ae1	a9 01		lda #$01			lda 	#1
.019ae3					_FPCNotRange:
.019ae3	38		sec				sec
.019ae4	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019ae7	b0 0e		bcs $019af7			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019ae9					_FPCNotEqual:
.019ae9	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019aec	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019aee	f0 02		beq $019af2			beq 	_FPCNE2
.019af0	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019af2	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019af3	80 04		bra $019af9			bra 	_FPCExit
.019af5					_FPCPullZero:
.019af5	68		pla				pla 								; throw saved exponents
.019af6	68		pla				pla
.019af7					_FPCZero:
.019af7	a9 00		lda #$00			lda 	#0 							; and return zero
.019af9					_FPCExit:
.019af9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019afa					FPUCopyX2ToX1:
.019afa	48		pha				pha
.019afb	da		phx				phx
.019afc	5a		phy				phy
.019afd	a0 08		ldy #$08			ldy 	#8
.019aff	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019b02	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019b05	e8		inx				inx
.019b06	88		dey				dey
.019b07	10 f6		bpl $019aff			bpl 	_FPUC21
.019b09	7a		ply				ply
.019b0a	fa		plx				plx
.019b0b	68		pla				pla
.019b0c	60		rts				rts
.019b0d					FPUSetInteger:
.019b0d	48		pha				pha
.019b0e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019b11	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019b13	10 02		bpl $019b17			bpl 	_FPUSIExtend
.019b15	a9 ff		lda #$ff			lda 	#$FF
.019b17					_FPUSIExtend:
.019b17	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019b1a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019b1d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019b20	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019b22	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b25	68		pla				pla
.019b26	60		rts				rts
.019b27					FPUNegateInteger:
.019b27	48		pha				pha
.019b28	38		sec				sec
.019b29	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019b2b	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019b2e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019b31	a9 00		lda #$00			lda 	#0
.019b33	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019b36	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019b39	a9 00		lda #$00			lda 	#0
.019b3b	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019b3e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019b41	a9 00		lda #$00			lda 	#0
.019b43	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019b46	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019b49	68		pla				pla
.019b4a	60		rts				rts
.019b4b					FPUToFloat:
.019b4b	48		pha				pha
.019b4c	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019b4f	29 0f		and #$0f			and 	#$0F
.019b51	f0 2d		beq $019b80			beq 	_FPUFExit
.019b53	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019b55	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b58	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019b5a	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019b5d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019b60	10 08		bpl $019b6a			bpl		_FPUFPositive
.019b62	20 27 9b	jsr $019b27			jsr 	FPUNegateInteger 			; negate the mantissa
.019b65	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019b67	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b6a					_FPUFPositive:
.019b6a	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019b6d	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019b70	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019b73	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019b76	d0 05		bne $019b7d			bne 	_FPUFNonZero
.019b78	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019b7a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b7d					_FPUFNonZero:
.019b7d	20 82 9b	jsr $019b82			jsr 	FPUNormalise 				; normalise the floating point.
.019b80					_FPUFExit:
.019b80	68		pla				pla
.019b81	60		rts				rts
.019b82					FPUNormalise:
.019b82	48		pha				pha
.019b83	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019b86	70 20		bvs $019ba8			bvs 	_FPUNExit
.019b88	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019b8b	f0 16		beq $019ba3			beq 	_FPUNSetZero
.019b8d					_FPUNLoop:
.019b8d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019b90	30 16		bmi $019ba8			bmi 	_FPUNExit 					; if so, we are normalised.
.019b92	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019b95	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019b98	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019b9b	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019b9e	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019ba1	d0 ea		bne $019b8d			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019ba3					_FPUNSetZero:
.019ba3	a9 40		lda #$40			lda 	#$40
.019ba5	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019ba8					_FPUNExit:
.019ba8	68		pla				pla
.019ba9	60		rts				rts
.019baa					FPUToInteger:
.019baa	48		pha				pha
.019bab	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019bae	29 01		and #$01			and 	#1
.019bb0	d0 3e		bne $019bf0			bne 	_FPUTOI_Exit
.019bb2	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019bb5	70 2b		bvs $019be2			bvs 	_FPUTOI_Zero
.019bb7	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019bba	10 26		bpl $019be2			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019bbc	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019bbe	b0 37		bcs $019bf7			bcs 	FP_Overflow
.019bc0					_FPUToIToInteger:
.019bc0	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019bc3	c9 a0		cmp #$a0			cmp 	#128+32
.019bc5	f0 11		beq $019bd8			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019bc7	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019bca	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019bcd	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019bd0	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019bd3	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019bd6	80 e8		bra $019bc0			bra 	_FPUToIToInteger 			; keep going.
.019bd8					_FPUToICheckSign:
.019bd8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019bdb	10 13		bpl $019bf0			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019bdd	20 27 9b	jsr $019b27			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019be0	80 0e		bra $019bf0			bra 	_FPUTOI_Exit
.019be2					_FPUTOI_Zero:
.019be2	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019be4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019be7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019bea	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019bed	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019bf0					_FPUToI_Exit:
.019bf0	a9 01		lda #$01			lda 	#1 							; set type to integer
.019bf2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019bf5	68		pla				pla
.019bf6	60		rts				rts
.019bf7					FP_Overflow:
.019bf7	20 2f 84	jsr $01842f			jsr ERR_Handler
>019bfa	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019c02	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019c12					FPUTimes10:
.019c12	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019c15	85 1a		sta $1a				sta 	ZLTemp1+0
.019c17	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019c1a	85 1b		sta $1b				sta 	ZLTemp1+1
.019c1c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019c1f	85 1c		sta $1c				sta 	ZLTemp1+2
.019c21	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019c24	85 1d		sta $1d				sta 	ZLTemp1+3
.019c26	20 6a 9c	jsr $019c6a			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019c29	20 6a 9c	jsr $019c6a			jsr 	_FPUT_LSR_ZLTemp1
.019c2c	18		clc				clc
.019c2d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019c30	65 1a		adc $1a				adc 	ZLTemp1+0
.019c32	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019c35	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019c38	65 1b		adc $1b				adc 	ZLTemp1+1
.019c3a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019c3d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019c40	65 1c		adc $1c				adc 	ZLTemp1+2
.019c42	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019c45	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019c48	65 1d		adc $1d				adc 	ZLTemp1+3
.019c4a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c4d	90 0f		bcc $019c5e			bcc 	_FPUTimes10
.019c4f	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019c52	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019c55	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019c58	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019c5b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019c5e					_FPUTimes10:
.019c5e	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019c61	18		clc				clc
.019c62	69 03		adc #$03			adc 	#3
.019c64	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019c67	b0 8e		bcs $019bf7			bcs 	FP_Overflow 				; error
.019c69	60		rts				rts
.019c6a					_FPUT_LSR_ZLTemp1:
.019c6a	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019c6c	66 1c		ror $1c				ror 	ZLTemp1+2
.019c6e	66 1b		ror $1b				ror 	ZLTemp1+1
.019c70	66 1a		ror $1a				ror 	ZLTemp1+0
.019c72	60		rts				rts
.019c73					FPUScale10A:
.019c73	5a		phy				phy
.019c74	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019c76	f0 3d		beq $019cb5			beq 	_FPUScaleExit
.019c78	da		phx				phx 								; save X
.019c79	e8		inx				inx
.019c7a	e8		inx				inx
.019c7b	e8		inx				inx
.019c7c	e8		inx				inx
.019c7d	e8		inx				inx
.019c7e	e8		inx				inx
.019c7f	a8		tay				tay 								; save power scalar in Y.
.019c80	a9 00		lda #$00			lda 	#0
.019c82	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019c85	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019c88	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019c8b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019c8e	a9 80		lda #$80			lda 	#$80
.019c90	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c93	a9 81		lda #$81			lda 	#$81
.019c95	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019c98	5a		phy				phy 								; save 10^n on stack.
.019c99	c0 00		cpy #$00			cpy 	#0
.019c9b	10 05		bpl $019ca2			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019c9d	98		tya				tya
.019c9e	49 ff		eor #$ff			eor 	#$FF
.019ca0	1a		inc a				inc 	a
.019ca1	a8		tay				tay
.019ca2					_FPUSAbs:
.019ca2	20 12 9c	jsr $019c12			jsr 	FPUTimes10
.019ca5	88		dey				dey
.019ca6	d0 fa		bne $019ca2			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019ca8	68		pla				pla 								; restore count in A
.019ca9	fa		plx				plx 								; restore X pointing to number to scale.
.019caa	0a		asl a				asl 	a
.019cab	b0 05		bcs $019cb2			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019cad	20 99 99	jsr $019999			jsr 	FPMultiply 					; if clear multiply.
.019cb0	80 03		bra $019cb5			bra		_FPUScaleExit
.019cb2					_FPUSDivide:
.019cb2	20 11 99	jsr $019911			jsr 	FPDivide
.019cb5					_FPUScaleExit:
.019cb5	7a		ply				ply
.019cb6	60		rts				rts
.019cb7					FPUCopyToNext:
.019cb7	a0 06		ldy #$06			ldy 		#6
.019cb9	da		phx				phx
.019cba					_FPUCopy1:
.019cba	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019cbd	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019cc0	e8		inx				inx
.019cc1	88		dey				dey
.019cc2	d0 f6		bne $019cba			bne 	_FPUCopy1
.019cc4	fa		plx				plx
.019cc5	60		rts				rts
.019cc6					FPUCopyFromNext:
.019cc6	a0 06		ldy #$06			ldy 		#6
.019cc8	da		phx				phx
.019cc9					_FPUCopy1:
.019cc9	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019ccc	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019ccf	e8		inx				inx
.019cd0	88		dey				dey
.019cd1	d0 f6		bne $019cc9			bne 	_FPUCopy1
.019cd3	fa		plx				plx
.019cd4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019cd5					FPToString:
.019cd5	48		pha				pha
.019cd6	5a		phy				phy
.019cd7	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019cda	50 0a		bvc $019ce6			bvc 		_FPTSIsFloat 			; if zero,
.019cdc					_FPTSZero:
.019cdc	a9 30		lda #$30			lda 		#"0"
.019cde	20 65 97	jsr $019765			jsr 		ITSOutputCharacter
.019ce1					_FPTSExit:
.019ce1	7a		ply				ply
.019ce2	68		pla				pla
.019ce3	60		rts				rts
.019ce4	80 fb		bra $019ce1			bra 		_FPTSExit
.019ce6					_FPTSIsFloat:
.019ce6	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019ce9	10 0a		bpl $019cf5			bpl 		_FPTSNotSigned
.019ceb	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019ced	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019cf0	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019cf2	20 65 97	jsr $019765			jsr 		ITSOutputCharacter
.019cf5					_FPTSNotSigned:
.019cf5	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019cf8	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019cfa	b0 09		bcs $019d05			bcs 		_FPTSExponent
.019cfc	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019cfe	90 05		bcc $019d05			bcc 		_FPTSExponent 			;
.019d00					_FPTSStandard:
.019d00	20 49 9d	jsr $019d49			jsr 		FPTOutputBody 			; output the body.
.019d03	80 dc		bra $019ce1			bra 		_FPTSExit
.019d05					_FPTSExponent:
.019d05	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019d07	8d 8d 04	sta $048d			sta 		ExpCount
.019d0a					_FPTSExponentLoop:
.019d0a	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019d0d	10 0e		bpl $019d1d			bpl 		_FPTSTimes
.019d0f	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019d11	90 14		bcc $019d27			bcc 		_FPTSScaledToExp
.019d13	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019d15	20 73 9c	jsr $019c73			jsr 		FPUScale10A
.019d18	ee 8d 04	inc $048d			inc 		ExpCount
.019d1b	80 ed		bra $019d0a			bra 		_FPTSExponentLoop
.019d1d					_FPTSTimes:
.019d1d	a9 01		lda #$01			lda 		#1
.019d1f	20 73 9c	jsr $019c73			jsr 		FPUScale10A
.019d22	ce 8d 04	dec $048d			dec 		ExpCount
.019d25	80 e3		bra $019d0a			bra 		_FPTSExponentLoop
.019d27					_FPTSScaledToExp:
.019d27	20 49 9d	jsr $019d49			jsr 		FPTOutputBody 			; output the body.
.019d2a	a9 65		lda #$65			lda 		#"e"					; output E
.019d2c	20 65 97	jsr $019765			jsr 		ITSOutputCharacter
.019d2f	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.019d32	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019d35	29 80		and #$80			and 		#$80 					; sign extend it
.019d37	f0 02		beq $019d3b			beq 		_FPTSSExt
.019d39	a9 ff		lda #$ff			lda 		#$FF
.019d3b					_FPTSSExt:
.019d3b	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019d3e	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019d41	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019d44	20 c1 96	jsr $0196c1			jsr 		INTToString 			; output the exponent.
.019d47	80 98		bra $019ce1			bra			_FPTSExit 				; and exit.
.019d49					FPTOutputBody:
.019d49	20 b7 9c	jsr $019cb7			jsr 		FPUCopyToNext 			; copy to next slot.
.019d4c	20 aa 9b	jsr $019baa			jsr 		FPUToInteger 			; convert to an integer
.019d4f	20 c1 96	jsr $0196c1			jsr 		INTToString 			; output the main integer part.
.019d52	20 c6 9c	jsr $019cc6			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019d55	20 36 9a	jsr $019a36			jsr 		FPFractionalPart 		; get the decimal part.
.019d58	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019d5b	70 3e		bvs $019d9b			bvs 		_FPTOExit 				; if not, exit now.
.019d5d	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019d5f	20 65 97	jsr $019765			jsr 		ITSOutputCharacter
.019d62					_FPOutLoop:
.019d62	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019d65	70 1e		bvs $019d85			bvs 		_FPStripZeros 			; strip trailing zeros
.019d67	20 12 9c	jsr $019c12			jsr 		FPUTimes10 				; multiply by 10
.019d6a	20 b7 9c	jsr $019cb7			jsr 		FPUCopyToNext			; copy to next slot.
.019d6d	20 aa 9b	jsr $019baa			jsr 		FPUToInteger 			; convert to integer
.019d70	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019d73	09 30		ora #$30			ora 		#"0"
.019d75	20 65 97	jsr $019765			jsr 		ITSOutputCharacter
.019d78	20 c6 9c	jsr $019cc6			jsr 		FPUCopyFromNext 		; get it back
.019d7b	20 36 9a	jsr $019a36			jsr 		FPFractionalPart 		; get fractional part
.019d7e	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.019d81	c9 0b		cmp #$0b			cmp 	 	#11
.019d83	90 dd		bcc $019d62			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019d85					_FPStripZeros:
.019d85	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.019d88					_FPStripLoop:
.019d88	88		dey				dey 								; back one, if at start then no strip
.019d89	f0 10		beq $019d9b			beq 		_FPToExit
.019d8b	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.019d8e	c9 30		cmp #$30			cmp 		#"0"
.019d90	f0 f6		beq $019d88			beq 		_FPStripLoop
.019d92	c8		iny				iny
.019d93	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019d95	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.019d98	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.019d9b					_FPTOExit:
.019d9b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019d9c					FPFromString:
.019d9c	48		pha				pha 								; push A
.019d9d	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019d9f	c9 2e		cmp #$2e			cmp 	#"."
.019da1	f0 03		beq $019da6			beq	 	_FPFIsDecimal
.019da3	4c 09 9e	jmp $019e09			jmp 	_FPFNotDecimal
.019da6					_FPFIsDecimal:
.019da6	c8		iny				iny 								; consume the decimal.
.019da7	20 4b 9b	jsr $019b4b			jsr 	FPUToFloat 					; convert the integer to float.
.019daa	da		phx				phx 								; save X.
.019dab	5a		phy				phy 								; save decimal start position
.019dac	e8		inx				inx
.019dad	e8		inx				inx
.019dae	e8		inx				inx
.019daf	e8		inx				inx
.019db0	e8		inx				inx
.019db1	e8		inx				inx
.019db2	20 7d 97	jsr $01977d			jsr 	INTFromStringY 				; get the part after the DP.
.019db5	20 4b 9b	jsr $019b4b			jsr 	FPUToFloat 					; convert that to a float.
.019db8	68		pla				pla 								; calculate - chars consumed.
.019db9	8c 8c 04	sty $048c			sty 	ExpTemp
.019dbc	38		sec				sec
.019dbd	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.019dc0	20 73 9c	jsr $019c73			jsr 	FPUScale10A 				; scale it by 10^AC
.019dc3	fa		plx				plx 								; restore original X
.019dc4	20 2d 98	jsr $01982d			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019dc7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019dc9	c9 45		cmp #$45			cmp 	#"E"
.019dcb	f0 04		beq $019dd1			beq 	_FPFExponent
.019dcd	c9 65		cmp #$65			cmp 	#"e"
.019dcf	d0 38		bne $019e09			bne 	_FPFNotDecimal 				; no, then exit normally.
.019dd1					_FPFExponent:
.019dd1	c8		iny				iny 								; skip over E symbol.
.019dd2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019dd4	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019dd6	d0 01		bne $019dd9			bne 	_FPFGotSign
.019dd8	c8		iny				iny 								; if it was - skip over it.
.019dd9					_FPFGotSign:
.019dd9	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019dda	da		phx				phx
.019ddb	e8		inx				inx
.019ddc	e8		inx				inx
.019ddd	e8		inx				inx
.019dde	e8		inx				inx
.019ddf	e8		inx				inx
.019de0	e8		inx				inx
.019de1	20 7d 97	jsr $01977d			jsr 	INTFromStringY 				; get the exponent
.019de4	fa		plx				plx 								; restore X.
.019de5	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019de8	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019deb	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019dee	d0 1b		bne $019e0b			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019df0	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019df3	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019df5	b0 14		bcs $019e0b			bcs 	_FPFXOverflow
.019df7	68		pla				pla 								; get direction
.019df8	d0 09		bne $019e03			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019dfa	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019dfd	49 ff		eor #$ff			eor 	#$FF
.019dff	1a		inc a				inc 	a
.019e00	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019e03					_FPFXScale:
.019e03	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019e06	20 73 9c	jsr $019c73			jsr 	FPUScale10A 				; scale by the exponent.
.019e09					_FPFNotDecimal:
.019e09	68		pla				pla
.019e0a	60		rts				rts
.019e0b					_FPFXOverflow:
.019e0b	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019e0e	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019e16	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019e1d					Unary_Rnd:
.019e1d	20 5b 8a	jsr $018a5b			jsr 	EvaluateNumberX 			; get value
.019e20	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; check right bracket.
.019e23	20 48 8d	jsr $018d48			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019e26	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019e28	30 10		bmi $019e3a			bmi 	_URSetSeed
.019e2a	f0 2c		beq $019e58			beq 	_URMakeRandom 				; if zero return same number.
.019e2c	da		phx				phx
.019e2d	a2 00		ldx #$00			ldx 	#0
.019e2f	20 95 9e	jsr $019e95			jsr 	Random16
.019e32	a2 02		ldx #$02			ldx 	#2
.019e34	20 95 9e	jsr $019e95			jsr 	Random16
.019e37	fa		plx				plx
.019e38	80 1e		bra $019e58			bra 	_URMakeRandom
.019e3a					_URSetSeed:
.019e3a	20 4b 9b	jsr $019b4b			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019e3d	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019e40	8d 93 04	sta $0493			sta 	RandomSeed+0
.019e43	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019e46	8d 94 04	sta $0494			sta 	RandomSeed+1
.019e49	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019e4c	8d 95 04	sta $0495			sta 	RandomSeed+2
.019e4f	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019e52	0a		asl a				asl 	a
.019e53	49 db		eor #$db			eor 	#$DB
.019e55	8d 96 04	sta $0496			sta 	RandomSeed+3
.019e58					_URMakeRandom:
.019e58	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.019e5b	0d 94 04	ora $0494			ora 	RandomSeed+1
.019e5e	0d 95 04	ora $0495			ora 	RandomSeed+2
.019e61	0d 96 04	ora $0496			ora 	RandomSeed+3
.019e64	d0 0a		bne $019e70			bne 	_URNotZero
.019e66	a9 47		lda #$47			lda 	#$47
.019e68	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.019e6b	a9 3d		lda #$3d			lda 	#$3D
.019e6d	8d 96 04	sta $0496			sta 	RandomSeed+3
.019e70					_URNotZero:
.019e70	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.019e73	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019e76	ad 94 04	lda $0494			lda 	RandomSeed+1
.019e79	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019e7c	ad 95 04	lda $0495			lda 	RandomSeed+2
.019e7f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019e82	ad 96 04	lda $0496			lda 	RandomSeed+3
.019e85	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019e88	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019e8a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019e8d	a9 80		lda #$80			lda 	#$80
.019e8f	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019e92	4c 82 9b	jmp $019b82			jmp 	FPUNormalise
.019e95					Random16:
.019e95	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.019e98	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.019e9b	90 08		bcc $019ea5			bcc 	_R16_NoXor
.019e9d	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019ea0	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019ea2	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.019ea5					_R16_NoXor:
.019ea5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019ea6					Unary_Int:
.019ea6	20 5b 8a	jsr $018a5b			jsr 	EvaluateNumberX 			; get value
.019ea9	20 ea 90	jsr $0190ea			jsr 	CheckNextRParen 			; check right bracket.
.019eac	4c aa 9b	jmp $019baa			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019eaf	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
