
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Aug 25 10:06:55 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					NumBufX 	.byte 	?						; buffer index position
>0401					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=$401					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0421					Var_Type    .byte ? 						; type of variable (as a type token)
>0422					Var_Hash 	.byte ? 						; hash of identifier name.
>0423					Var_Length 	.byte ? 						; length of variable name
>0424					Var_HashAddress .byte ?						; low byte of hash table entry.
>0425					NumSuppress	.byte 	?						; leading zero suppression flag
>0426					NumConvCount .byte 	? 						; count for conversions.
>0427					ExpTemp:	.byte ?							; Working temp for exponents.
>0428					ExpCount:	.byte ? 						; Count of decimal exponents.
>0429					SignCount:	.byte ?							; Integer Divide Sign Counts.
>042a					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>042c					TempStringWriteIndex: .byte ? 				; Write offset.
>042d					ValSign: 	.byte ? 						; sign flag for val()
>042e					SliceStart:	.byte ? 						; string slice parts
>042f					SliceCount:	.byte ?
>0430					RandomSeed:	.dword ? 						; Random seed.
>0434					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0436					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0438					Tim_SR:		.byte ? 						; Processor Status
>0439					Tim_A:		.byte ? 						; Processor Registers
>043a					Tim_X:		.byte ?
>043b					Tim_Y:		.byte ?
>043c					Tim_Z:		.byte ?
>043d					Tim_SP:		.word ?							; Stack Pointer (just in cases)
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.043f					HashTableBase:
>043f								.fill	HashTableCount * HashTableSize * 2
.049f					HashTableEnd:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	10 02 00 d4 14 05 13 14			.byte	$10,$02,$00,$d4,$14,$05,$13,$14
>1008	bd 56 8d 47 fd 03 30 00			.byte	$bd,$56,$8d,$47,$fd,$03,$30,$00
>1010	05 03 00 c2 00 00			.byte	$05,$03,$00,$c2,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 95 84 01	jmp $018495		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c ad 99 01	jmp $0199ad			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.0181f7					SyntaxError:
.0181f7	20 26 82	jsr $018226			jsr 	ERR_Handler
>0181fa	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018202	72 72 6f 72 00
.018207					TypeError:
.018207	20 26 82	jsr $018226			jsr 	ERR_Handler
>01820a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018212	70 65 00
.018215					BadParamError:
.018215	20 26 82	jsr $018226			jsr 	ERR_Handler
>018218	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018220	6d 65 74 65 72 00
.018226					ERR_Handler:
.018226	a0 00		ldy #$00			ldy 	#0
.018228	c8		iny				iny
.018229	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01822b	8d 08 03	sta $0308			sta 	XS_Mantissa
.01822e	c8		iny				iny
.01822f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018231	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.018234	fa		plx				plx 								; address in XY
.018235	7a		ply				ply
.018236	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018237	d0 01		bne $01823a			bne 	_EHNoSkip
.018239	c8		iny				iny
.01823a					_EHNoSkip:
.01823a	20 5b 82	jsr $01825b			jsr 	PrintROMMessage 			; print message from ROM.
.01823d	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018240	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.018243	f0 0c		beq $018251			beq 	_EHNoLine
.018245	a2 56		ldx #$56			ldx 	#_EHAt & $FF 				; print " at "
.018247	a0 82		ldy #$82			ldy 	#(_EHAt >> 8) & $FF
.018249	20 5b 82	jsr $01825b			jsr 	PrintROMMessage
.01824c	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01824e	20 70 82	jsr $018270			jsr 	Print16BitInteger
.018251					_EHNoLine:
.018251	80 fe		bra $018251			bra 	_EHNoLine
.018253	4c b5 84	jmp $0184b5			jmp 	WarmStart
>018256	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01825b					PrintROMMessage:
.01825b	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.01825d	84 1b		sty $1b				sty 	zLTemp1+1
.01825f	4b		phk				phk
.018260	68		pla				pla
.018261	85 1c		sta $1c				sta 	ZLTemp1+2
.018263	a0 00		ldy #$00			ldy 	#0
.018265					_PRMLoop:
.018265	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018267	f0 06		beq $01826f			beq		_PRMExit
.018269	c8		iny				iny
.01826a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01826d	80 f6		bra $018265			bra 	_PRMLoop
.01826f					_PRMExit:
.01826f	60		rts				rts
.018270					Print16BitInteger:
.018270	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018272	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.018275	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018278	8d 00 04	sta $0400			sta 	NumBufX 					; reset the conversion pointer
.01827b	aa		tax				tax 								; convert bottom level.
.01827c	20 40 90	jsr $019040			jsr 	INTToString 				; make string
.01827f	a2 00		ldx #$00			ldx 	#0 							; print buffer
.018281	bd 01 04	lda $0401,x	_P1Loop:lda 	Num_Buffer,x
.018284	f0 06		beq $01828c			beq 	_P1Exit
.018286	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018289	e8		inx				inx
.01828a	80 f5		bra $018281			bra 	_P1Loop
.01828c	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.01828d					VectorTable:
>01828d	bd 87					.word BinaryOp_And         & $FFFF ; $80 and
>01828f	e5 87					.word BinaryOp_Or          & $FFFF ; $81 or
>018291	0d 88					.word BinaryOp_Xor         & $FFFF ; $82 xor
>018293	0d 88					.word BinaryOp_Eor         & $FFFF ; $83 eor
>018295	51 88					.word Binary_Equal         & $FFFF ; $84 =
>018297	70 88					.word Binary_NotEqual      & $FFFF ; $85 <>
>018299	79 88					.word Binary_Less          & $FFFF ; $86 <
>01829b	82 88					.word Binary_LessEqual     & $FFFF ; $87 <=
>01829d	94 88					.word Binary_Greater       & $FFFF ; $88 >
>01829f	8b 88					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0182a1	29 89					.word BinaryOp_Add         & $FFFF ; $8a +
>0182a3	49 89					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0182a5	5c 89					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0182a7	6f 89					.word BinaryOp_Divide      & $FFFF ; $8d /
>0182a9	41 83					.word NotImplemented       & $FFFF ; $8e ^
>0182ab	41 83					.word NotImplemented       & $FFFF ; $8f if
>0182ad	41 83					.word NotImplemented       & $FFFF ; $90 while
>0182af	41 83					.word NotImplemented       & $FFFF ; $91 repeat
>0182b1	41 83					.word NotImplemented       & $FFFF ; $92 for
>0182b3	41 83					.word NotImplemented       & $FFFF ; $93 then
>0182b5	41 83					.word NotImplemented       & $FFFF ; $94 endif
>0182b7	41 83					.word NotImplemented       & $FFFF ; $95 wend
>0182b9	41 83					.word NotImplemented       & $FFFF ; $96 until
>0182bb	41 83					.word NotImplemented       & $FFFF ; $97 next
>0182bd	41 83					.word NotImplemented       & $FFFF ; $98 not
>0182bf	41 83					.word NotImplemented       & $FFFF ; $99 fn(
>0182c1	a3 8a					.word Unary_Abs            & $FFFF ; $9a abs(
>0182c3	fb 8b					.word Unary_Asc            & $FFFF ; $9b asc(
>0182c5	25 98					.word Unary_Int            & $FFFF ; $9c int(
>0182c7	c1 8a					.word Unary_Peek           & $FFFF ; $9d peek(
>0182c9	9c 97					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0182cb	35 8b					.word Unary_Usr            & $FFFF ; $9f usr(
>0182cd	3c 8c					.word Unary_Left           & $FFFF ; $a0 left$(
>0182cf	53 8c					.word Unary_Right          & $FFFF ; $a1 right$(
>0182d1	21 8c					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0182d3	b5 8d					.word Unary_Spc            & $FFFF ; $a3 spc(
>0182d5	c8 8b					.word Unary_Str            & $FFFF ; $a4 str$(
>0182d7	57 8b					.word Unary_Val            & $FFFF ; $a5 val(
>0182d9	12 8c					.word Unary_Len            & $FFFF ; $a6 len(
>0182db	d1 8c					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0182dd	41 83					.word NotImplemented       & $FFFF ; $a8 sin(
>0182df	41 83					.word NotImplemented       & $FFFF ; $a9 cos(
>0182e1	41 83					.word NotImplemented       & $FFFF ; $aa tan(
>0182e3	41 83					.word NotImplemented       & $FFFF ; $ab atn(
>0182e5	41 83					.word NotImplemented       & $FFFF ; $ac exp(
>0182e7	41 83					.word NotImplemented       & $FFFF ; $ad log(
>0182e9	41 83					.word NotImplemented       & $FFFF ; $ae sqr(
>0182eb	2b 8d					.word Unary_Dec            & $FFFF ; $af dec(
>0182ed	c5 8a					.word Unary_Deek           & $FFFF ; $b0 deek(
>0182ef	c9 8a					.word Unary_Leek           & $FFFF ; $b1 leek(
>0182f1	fd 8a					.word Unary_Mod            & $FFFF ; $b2 mod(
>0182f3	51 8a					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0182f5	93 8d					.word Unary_Chr            & $FFFF ; $b4 chr$(
>0182f7	41 83					.word NotImplemented       & $FFFF ; $b5 $
>0182f9	41 83					.word NotImplemented       & $FFFF ; $b6 $(
>0182fb	41 83					.word NotImplemented       & $FFFF ; $b7 #
>0182fd	41 83					.word NotImplemented       & $FFFF ; $b8 #(
>0182ff	41 83					.word NotImplemented       & $FFFF ; $b9 %
>018301	41 83					.word NotImplemented       & $FFFF ; $ba %(
>018303	41 83					.word NotImplemented       & $FFFF ; $bb (
>018305	41 83					.word NotImplemented       & $FFFF ; $bc )
>018307	41 83					.word NotImplemented       & $FFFF ; $bd ,
>018309	39 85					.word Command_COLON        & $FFFF ; $be :
>01830b	41 83					.word NotImplemented       & $FFFF ; $bf ;
>01830d	41 83					.word NotImplemented       & $FFFF ; $c0 def
>01830f	cd 85					.word Command_CLR          & $FFFF ; $c1 clr
>018311	db 85					.word Command_STOP         & $FFFF ; $c2 stop
>018313	41 83					.word NotImplemented       & $FFFF ; $c3 data
>018315	41 83					.word NotImplemented       & $FFFF ; $c4 read
>018317	41 83					.word NotImplemented       & $FFFF ; $c5 dim
>018319	41 83					.word NotImplemented       & $FFFF ; $c6 to
>01831b	41 83					.word NotImplemented       & $FFFF ; $c7 step
>01831d	41 83					.word NotImplemented       & $FFFF ; $c8 gosub
>01831f	41 83					.word NotImplemented       & $FFFF ; $c9 return
>018321	41 83					.word NotImplemented       & $FFFF ; $ca goto
>018323	3a 85					.word Command_END          & $FFFF ; $cb end
>018325	41 83					.word NotImplemented       & $FFFF ; $cc input
>018327	41 83					.word NotImplemented       & $FFFF ; $cd let
>018329	41 83					.word NotImplemented       & $FFFF ; $ce list
>01832b	41 83					.word NotImplemented       & $FFFF ; $cf new
>01832d	41 83					.word NotImplemented       & $FFFF ; $d0 old
>01832f	41 83					.word NotImplemented       & $FFFF ; $d1 on
>018331	41 83					.word NotImplemented       & $FFFF ; $d2 restore
>018333	41 83					.word NotImplemented       & $FFFF ; $d3 poke
>018335	3e 85					.word Command_PRINT        & $FFFF ; $d4 print
>018337	c3 84					.word Command_RUN          & $FFFF ; $d5 run
>018339	41 83					.word NotImplemented       & $FFFF ; $d6 wait
>01833b	41 83					.word NotImplemented       & $FFFF ; $d7 doke
>01833d	41 83					.word NotImplemented       & $FFFF ; $d8 loke
>01833f	b1 85					.word Command_ASSERT       & $FFFF ; $d9 assert
.018341					NotImplemented:
.018341	20 26 82	jsr $018226			jsr ERR_Handler
>018344	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01834c	65 6d 65 6e 74 65 64 00
.018354					BinaryPrecedence:
>018354	01					.byte 1    ; $80 and
>018355	01					.byte 1    ; $81 or
>018356	01					.byte 1    ; $82 xor
>018357	01					.byte 1    ; $83 eor
>018358	02					.byte 2    ; $84 =
>018359	02					.byte 2    ; $85 <>
>01835a	02					.byte 2    ; $86 <
>01835b	02					.byte 2    ; $87 <=
>01835c	02					.byte 2    ; $88 >
>01835d	02					.byte 2    ; $89 >=
>01835e	03					.byte 3    ; $8a +
>01835f	03					.byte 3    ; $8b -
>018360	04					.byte 4    ; $8c *
>018361	04					.byte 4    ; $8d /
>018362	05					.byte 5    ; $8e ^
.018363					KeywordText:
>018363	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018366	4f d2					.byte $4f,$d2                          ; $81 or
>018368	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01836b	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01836e	bd					.byte $bd                              ; $84 =
>01836f	3c be					.byte $3c,$be                          ; $85 <>
>018371	bc					.byte $bc                              ; $86 <
>018372	3c bd					.byte $3c,$bd                          ; $87 <=
>018374	be					.byte $be                              ; $88 >
>018375	3e bd					.byte $3e,$bd                          ; $89 >=
>018377	ab					.byte $ab                              ; $8a +
>018378	ad					.byte $ad                              ; $8b -
>018379	aa					.byte $aa                              ; $8c *
>01837a	af					.byte $af                              ; $8d /
>01837b	de					.byte $de                              ; $8e ^
>01837c	49 c6					.byte $49,$c6                          ; $8f if
>01837e	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018383	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018389	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01838c	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018390	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018395	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018399	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01839e	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0183a2	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0183a5	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0183a8	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0183ac	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0183b0	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0183b4	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0183b9	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0183bd	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0183c1	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0183c7	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0183ce	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0183d3	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0183d7	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0183dc	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0183e0	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0183e4	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0183e9	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0183ed	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0183f1	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>0183f5	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>0183f9	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>0183fd	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018401	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018405	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018409	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01840e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018413	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018417	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01841b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018420	a4					.byte $a4                              ; $b5 $
>018421	24 a8					.byte $24,$a8                          ; $b6 $(
>018423	a3					.byte $a3                              ; $b7 #
>018424	23 a8					.byte $23,$a8                          ; $b8 #(
>018426	a5					.byte $a5                              ; $b9 %
>018427	25 a8					.byte $25,$a8                          ; $ba %(
>018429	a8					.byte $a8                              ; $bb (
>01842a	a9					.byte $a9                              ; $bc )
>01842b	ac					.byte $ac                              ; $bd ,
>01842c	ba					.byte $ba                              ; $be :
>01842d	bb					.byte $bb                              ; $bf ;
>01842e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>018431	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>018434	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>018438	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>01843c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>018440	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>018443	54 cf					.byte $54,$cf                          ; $c6 to
>018445	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>018449	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>01844e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>018454	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>018458	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>01845b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>018460	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>018463	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>018467	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>01846a	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>01846d	4f ce					.byte $4f,$ce                          ; $d1 on
>01846f	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>018476	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>01847a	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>01847f	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>018482	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>018486	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>01848a	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>01848e	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>018494	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.018495					BASIC_Start:
.018495	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018498	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.01849b	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.01849d	8d 04 03	sta $0304			sta 	LocalVector
.0184a0	8d 00 03	sta $0300			sta 	UserVector
.0184a3	a9 45		lda #$45			lda 	#USRDefault & $FF 			; reset USR vector
.0184a5	8d 01 03	sta $0301			sta 	UserVector+1
.0184a8	a9 8b		lda #$8b			lda 	#(USRDefault >> 8) & $FF
.0184aa	8d 02 03	sta $0302			sta 	UserVector+2
.0184ad	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0184af	8d 03 03	sta $0303			sta 	UserVector+3
.0184b2	20 cd 85	jsr $0185cd			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0184b5					WarmStart:
.0184b5	c2 30		rep #$30			rep 	#$30
.0184b7	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0184ba	1b		tcs				tcs
.0184bb	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0184be	e2 30		sep #$30			sep 	#$30
.0184c0	4c c3 84	jmp $0184c3			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0184c3					Command_RUN:
.0184c3	20 cd 85	jsr $0185cd			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0184c6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0184c8	85 16		sta $16				sta 	zCodePtr+0
.0184ca	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0184cc	85 17		sta $17				sta 	zCodePtr+1
.0184ce	a9 00		lda #$00			lda 	#0
.0184d0	85 18		sta $18				sta 	zCodePtr+2
.0184d2	85 19		sta $19				sta 	zCodePtr+3
.0184d4	a0 03		ldy #$03			ldy 	#3
.0184d6					RUN_NewLine:
.0184d6	a0 00		ldy #$00			ldy 	#0
.0184d8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184da	c8		iny				iny
.0184db	c8		iny				iny
.0184dc	c8		iny				iny
.0184dd	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0184df	d0 16		bne $0184f7			bne 	RUN_NextCommand
.0184e1	4c db 85	jmp $0185db			jmp 	Command_STOP 				; go do the command code.
.0184e4					RUN_Skip:
.0184e4	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0184e6	c8		iny				iny 								; skip
.0184e7	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0184e9	90 0c		bcc $0184f7			bcc 	_SEDone 					; so just skip over it.
.0184eb	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184ed	90 07		bcc $0184f6			bcc 	_SEDouble
.0184ef	98		tya				tya 								; this is Y + 1
.0184f0	18		clc				clc
.0184f1	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0184f3	a8		tay				tay 								; back in Y.
.0184f4	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184f5	88		dey				dey
.0184f6					_SEDouble:
.0184f6	c8		iny				iny
.0184f7					_SEDone:
.0184f7					RUN_NextCommand:
.0184f7	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0184f9	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0184fb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0184fd	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.0184ff	f0 e3		beq $0184e4			beq 	RUN_Skip
.018501	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018503	d0 0f		bne $018514			bne 	RUN_Execute
.018505					RUN_NextLine:
.018505	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018507	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018509	18		clc				clc
.01850a	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01850c	85 16		sta $16				sta 	zCodePtr
.01850e	90 02		bcc $018512			bcc 	_SNLNoCarry
.018510	e6 17		inc $17				inc 	zCodePtr+1
.018512					_SNLNoCarry:
.018512	80 c2		bra $0184d6			bra 	RUN_NewLine 				; go do the new line code
.018514					RUN_Execute:
.018514	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018516	b0 1a		bcs $018532			bcs 	RUN_Extension
.018518	c8		iny				iny
.018519	0a		asl a				asl 	a 							; double the character read.
.01851a	90 14		bcc $018530			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.01851c	aa		tax				tax 								; ready to look up.
.01851d	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into LocalVector
.018521	8d 05 03	sta $0305			sta 	LocalVector+1
.018524	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.018528	8d 06 03	sta $0306			sta 	LocalVector+2
.01852b	20 f6 86	jsr $0186f6			jsr 	EVCallLocalVector 			; execute the appropriate code.
.01852e	80 c7		bra $0184f7			bra 	RUN_NextCommand 			; do the next command.
.018530					RUN_Default:
.018530	80 fe		bra $018530			bra 	RUN_Default
.018532					RUN_Extension:
.018532	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018534	f0 ae		beq $0184e4			beq 	RUN_Skip 					; skip over it.
.018536	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.018539					Command_COLON:
.018539	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.01853a					Command_END:
>01853a	02						.byte 	2
.01853b	4c b5 84	jmp $0184b5			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.01853e					Command_PRINT:
.01853e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018540	c9 00		cmp #$00			cmp 	#0 							; end
.018542	f0 69		beq $0185ad			beq 	_CPR_NewLine
.018544	c9 be		cmp #$be			cmp 	#token_Colon
.018546	f0 65		beq $0185ad			beq 	_CPR_NewLine
.018548	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.01854a	f0 54		beq $0185a0			beq 	_CPR_Skip
.01854c	c9 bd		cmp #$bd			cmp 	#token_Comma
.01854e	f0 4d		beq $01859d			beq 	_CPR_Tab
.018550	20 e6 85	jsr $0185e6			jsr 	EvaluateExpression 			; get expression.
.018553	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018556	29 02		and #$02			and 	#2
.018558	d0 25		bne $01857f			bne 	_CPR_String 				; if type = 2 output as string.
.01855a					_CPR_Number:
.01855a	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01855c	8d 00 04	sta $0400			sta 	NumBufX
.01855f	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018562	4a		lsr a				lsr 	a
.018563	b0 05		bcs $01856a			bcs 	_CPRInt 					; if msb set do as integer
.018565	20 54 96	jsr $019654			jsr 	FPToString 					; call fp to str otherwise
.018568	80 03		bra $01856d			bra 	_CPRNPrint
.01856a	20 40 90	jsr $019040	_CPRInt:jsr 	IntToString
.01856d					_CPRNPrint:
.01856d	ad 01 04	lda $0401			lda 	Num_Buffer 					; is first character -
.018570	c9 2d		cmp #$2d			cmp 	#"-"
.018572	f0 05		beq $018579			beq 	_CPRNoSpace
.018574	a9 20		lda #$20			lda 	#" "						; print the leading space
.018576	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.018579					_CPRNoSpace:
.018579	a2 00		ldx #$00			ldx 	#(Num_Buffer-1) & $FF
.01857b	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.01857d	80 06		bra $018585			bra 	_CPRPrint
.01857f					_CPR_String:
.01857f	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.018582	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.018585					_CPRPrint:
.018585	86 1e		stx $1e				stx 	zGenPtr
.018587	85 1f		sta $1f				sta 	zGenPtr+1
.018589	5a		phy				phy
.01858a	a0 00		ldy #$00			ldy 	#0							; get length into X
.01858c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01858e	aa		tax				tax
.01858f	f0 09		beq $01859a			beq 	_CPREndPrint 				; nothing to print
.018591					_CPRLoop:
.018591	c8		iny				iny
.018592	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018594	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018597	ca		dex				dex
.018598	d0 f7		bne $018591			bne 	_CPRLoop
.01859a					_CPREndPrint:
.01859a	7a		ply				ply
.01859b	80 a1		bra $01853e			bra 	Command_Print
.01859d					_CPR_Tab:
.01859d	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0185a0					_CPR_Skip:
.0185a0	c8		iny				iny
.0185a1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0185a3	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.0185a5	f0 09		beq $0185b0			beq 	_CPR_Exit
.0185a7	c9 00		cmp #$00			cmp 	#0
.0185a9	d0 93		bne $01853e			bne 	Command_PRINT 				; if not go round again.
.0185ab	80 03		bra $0185b0			bra 	_CPR_Exit
.0185ad					_CPR_NewLine:
.0185ad	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.0185b0					_CPR_Exit:
.0185b0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0185b1					Command_ASSERT:
.0185b1	20 8c 87	jsr $01878c			jsr 	EvaluateNumber 				; calculate thing being asserted
.0185b4	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0185b7	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0185ba	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0185bd	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0185c0	f0 01		beq $0185c3			beq 	_ASFail
.0185c2	60		rts				rts
.0185c3					_ASFail:
.0185c3	20 26 82	jsr $018226			jsr ERR_Handler
>0185c6	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0185cd					Command_CLR:
.0185cd					ResetRunStatus:
.0185cd	20 91 8e	jsr $018e91			jsr 	VariableClear
.0185d0	a9 00		lda #$00			lda 	#HighMemory & $FF
.0185d2	8d 2a 04	sta $042a			sta 	StringPtr
.0185d5	a9 80		lda #$80			lda 	#HighMemory >> 8
.0185d7	8d 2b 04	sta $042b			sta 	StringPtr+1
.0185da	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0185db					Command_STOP:
.0185db	20 26 82	jsr $018226			jsr ERR_Handler
>0185de	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0185e3					EVESyntax:
.0185e3	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.0185e6					EvaluateExpression:
.0185e6	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0185e8					EvaluateExpressionX:
.0185e8	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0185ea					EvaluateExpressionXA:
.0185ea	48		pha				pha 								; save precedence on stack.
.0185eb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0185ed	f0 f4		beq $0185e3			beq 	EVESyntax 					; end of line, syntax error.
.0185ef	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0185f1	b0 03		bcs $0185f6			bcs 	_EVNotVariable
.0185f3	4c ed 86	jmp $0186ed			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0185f6					_EVNotVariable:
.0185f6	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0185f8	90 e9		bcc $0185e3			bcc 	EVESyntax
.0185fa	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0185fc	b0 7f		bcs $01867d			bcs 	_EVNotInteger
.0185fe	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018600	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018603	a9 00		lda #$00			lda 	#0
.018605	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018608	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01860b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01860e	1a		inc a				inc 	a 							; set to type 1 (integer)
.01860f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018612					_EVCheckNextInteger:
.018612	c8		iny				iny
.018613	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018615	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018617	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018619	b0 0d		bcs $018628			bcs 	_EVCheckDecimal
.01861b	48		pha				pha 								; save it.
.01861c	20 f9 86	jsr $0186f9			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01861f	68		pla				pla
.018620	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018623	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018626	80 ea		bra $018612			bra 	_EVCheckNextInteger
.018628					_EVCheckDecimal:
.018628	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01862a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01862c	d0 05		bne $018633			bne 	_EVGotAtom 					; no, get atom.
.01862e					_EVIsDecimal:
.01862e	20 29 87	jsr $018729			jsr 	EVGetDecimal 				; extend to the decimal part.
.018631	80 00		bra $018633			bra 	_EVGotAtom 					; and continue to got atom.
.018633					_EVGotAtom:
.018633	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018635	10 44		bpl $01867b			bpl 	_EVExitDrop 				; must be a token.
.018637	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018639	b0 40		bcs $01867b			bcs 	_EVExitDrop
.01863b	68		pla				pla 								; get current precedence
.01863c	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01863e	da		phx				phx 								; save X
.01863f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018641	aa		tax				tax 								; put in X
.018642	bf d4 82 01	lda $0182d4,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018646	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018648	fa		plx				plx 								; restore X
.018649	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01864b	90 2f		bcc $01867c			bcc 	_EVExit 					; exit if too low.
.01864d	f0 2d		beq $01867c			beq 	_EVExit 					; exit if equals
.01864f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018651	48		pha				pha
.018652	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018654	48		pha				pha
.018655	c8		iny				iny
.018656	da		phx				phx 								; save current position
.018657	e8		inx				inx
.018658	e8		inx				inx
.018659	e8		inx				inx
.01865a	e8		inx				inx
.01865b	e8		inx				inx
.01865c	e8		inx				inx
.01865d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01865f	20 ea 85	jsr $0185ea			jsr 	EvaluateExpressionXA 		; do the RHS.
.018662	fa		plx				plx 								; restore X
.018663	68		pla				pla 								; get the binary operator in A.
.018664					_EVCallA:
.018664	da		phx				phx 								; save X again
.018665	0a		asl a				asl 	a 							; double, lose the MSB.
.018666	aa		tax				tax									; put in X
.018667	bf 8d 82 01	lda $01828d,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01866b	8d 05 03	sta $0305			sta 	LocalVector+1
.01866e	bf 8e 82 01	lda $01828e,x			lda 	VectorTable+1,x
.018672	8d 06 03	sta $0306			sta 	LocalVector+2
.018675	fa		plx				plx 								; restore X
.018676	20 f6 86	jsr $0186f6			jsr 	EVCallLocalVector
.018679	80 b8		bra $018633			bra 	_EVGotAtom 					; and loop back.
.01867b					_EVExitDrop:
.01867b	68		pla				pla
.01867c					_EVExit:
.01867c	60		rts				rts
.01867d					_EVNotInteger:
.01867d	c8		iny				iny
.01867e	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018680	d0 19		bne $01869b			bne 	_EVNotMinus
.018682	20 7a 87	jsr $01877a			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018685	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018688	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01868a	f0 05		beq $018691			beq 	_EVMinusFloat
.01868c	20 1b 90	jsr $01901b			jsr 	IntegerNegateAlways 		; negation
.01868f	80 a2		bra $018633			bra 	_EVGotAtom 					; and go back.
.018691					_EVMinusFloat:
.018691	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.018694	49 80		eor #$80			eor 	#$80
.018696	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018699	80 98		bra $018633			bra 	_EVGotAtom
.01869b					_EVNotMinus:
.01869b	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.01869d	d0 17		bne $0186b6			bne 	_EVNotParenthesis
.01869f	20 e8 85	jsr $0185e8			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0186a2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0186a4	c8		iny				iny
.0186a5	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0186a7	f0 8a		beq $018633			beq 	_EVGotAtom
.0186a9	20 26 82	jsr $018226			jsr ERR_Handler
>0186ac	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0186b4	29 00
.0186b6					_EVNotParenthesis:
.0186b6	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0186b8	d0 0c		bne $0186c6			bne 	_EVNotNot
.0186ba	20 7a 87	jsr $01877a			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0186bd	20 29 95	jsr $019529			jsr 	FPUToInteger 				; make it an integer - if possible.
.0186c0	20 57 87	jsr $018757			jsr 	NotInteger 					; do the not calculation
.0186c3	4c 33 86	jmp $018633			jmp 	_EVGotAtom
.0186c6					_EVNotNot:
.0186c6	c9 fe		cmp #$fe			cmp 	#$FE
.0186c8	d0 15		bne $0186df			bne 	_EVNotString
.0186ca	20 68 8e	jsr $018e68			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0186cd	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.0186cf	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0186d2	a5 21		lda $21				lda 	zTempStr+1
.0186d4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0186d7	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0186d9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0186dc	4c 33 86	jmp $018633			jmp 	_EVGotAtom
.0186df					_EVNotString:
.0186df	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0186e1	90 04		bcc $0186e7			bcc 	_EVBadElement
.0186e3	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.0186e5	90 03		bcc $0186ea			bcc 	_EVUnaryFunction
.0186e7					_EVBadElement:
.0186e7	4c f7 81	jmp $0181f7			jmp 	SyntaxError
.0186ea					_EVUnaryFunction:
.0186ea	4c 64 86	jmp $018664			jmp 	_EVCallA
.0186ed					_EVVariableHandler:
.0186ed	20 8e 8e	jsr $018e8e			jsr 	VariableFind 				; locate a variable
.0186f0	20 a1 8e	jsr $018ea1			jsr 	VariableGet 				; copy into memory.
.0186f3	4c 33 86	jmp $018633			jmp 	_EVGotAtom 					; and go round.
.0186f6					EVCallLocalVector:
.0186f6	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.0186f9					EVShiftMantissaLeft6:
.0186f9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0186fc	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0186ff	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018702	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018705	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018708	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01870b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01870e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018711	a9 00		lda #$00			lda 	#0
.018713	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018716	20 19 87	jsr $018719			jsr 	_EVSMLShift 					; call it here to do it twice
.018719					_EVSMLShift:
.018719	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.01871c	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.01871f	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018722	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018725	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018728	60		rts				rts
.018729					EVGetDecimal:
.018729	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01872b	8d 01 04	sta $0401			sta 	Num_Buffer
.01872e	da		phx				phx
.01872f	c8		iny				iny
.018730	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018732	c8		iny				iny
.018733	3a		dec a				dec 	a								; convert to a string length.
.018734	3a		dec a				dec 	a
.018735	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018737					_EVGDCopy:
.018737	48		pha				pha 									; save count
.018738	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01873a	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.01873d	e8		inx				inx 									; forward ....
.01873e	c8		iny				iny
.01873f	68		pla				pla 									; get count
.018740	3a		dec a				dec 	a 								; until zero
.018741	d0 f4		bne $018737			bne 	_EVGDCopy
.018743	9d 01 04	sta $0401,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018746	fa		plx				plx 									; restore X
.018747	a9 01		lda #$01			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018749	85 1e		sta $1e				sta 	zGenPtr
.01874b	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.01874d	85 1f		sta $1f				sta 	zGenPtr+1
.01874f	5a		phy				phy 									; save Y
.018750	a0 00		ldy #$00			ldy 	#0 								; start position
.018752	20 1b 97	jsr $01971b			jsr 	FPFromString 					; convert current
.018755	7a		ply				ply 									; restore Y
.018756	60		rts				rts
.018757					NotInteger:
.018757	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01875a	49 ff		eor #$ff			eor 	#$FF
.01875c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01875f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018762	49 ff		eor #$ff			eor 	#$FF
.018764	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018767	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01876a	49 ff		eor #$ff			eor 	#$FF
.01876c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01876f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018772	49 ff		eor #$ff			eor 	#$FF
.018774	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018777	60		rts				rts
.018778					EvaluateGetAtom:
.018778	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.01877a					EvaluateGetAtomX:
.01877a	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.01877c	20 ea 85	jsr $0185ea			jsr 	EvaluateExpressionXA
.01877f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018782	29 0f		and #$0f			and 	#15
.018784	c9 02		cmp #$02			cmp 	#2
.018786	b0 01		bcs $018789			bcs 	EvaluateType
.018788	60		rts				rts
.018789					EvaluateType:
.018789	4c 07 82	jmp $018207			jmp 	TypeError
.01878c					EvaluateNumber:
.01878c	a2 00		ldx #$00			ldx 	#0
.01878e					EvaluateNumberX:
.01878e	20 e8 85	jsr $0185e8			jsr 	EvaluateExpressionX
.018791	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.018794	29 0f		and #$0f			and 	#15
.018796	c9 02		cmp #$02			cmp 	#2
.018798	b0 ef		bcs $018789			bcs 	EvaluateType
.01879a	60		rts				rts
.01879b					EvaluateInteger:
.01879b	a2 00		ldx #$00			ldx 	#0
.01879d					EvaluateIntegerX:
.01879d	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX
.0187a0	20 29 95	jsr $019529			jsr 	FPUToInteger
.0187a3	60		rts				rts
.0187a4					EvaluateString:
.0187a4	a2 00		ldx #$00			ldx 	#0
.0187a6					EvaluateStringX:
.0187a6	20 e8 85	jsr $0185e8			jsr 	EvaluateExpressionX
.0187a9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0187ac	29 0f		and #$0f			and 	#15
.0187ae	c9 02		cmp #$02			cmp 	#2
.0187b0	d0 d7		bne $018789			bne 	EvaluateType
.0187b2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0187b5	85 1e		sta $1e				sta 	zGenPtr
.0187b7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0187ba	85 1f		sta $1f				sta 	zGenPtr+1
.0187bc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0187bd					BinaryOp_And:
.0187bd	20 35 88	jsr $018835			jsr 	BinaryMakeBothInteger
.0187c0	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0187c3	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0187c6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187c9	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0187cc	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.0187cf	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187d2	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0187d5	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.0187d8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0187db	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0187de	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.0187e1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0187e4	60		rts				rts
.0187e5					BinaryOp_Or:
.0187e5	20 35 88	jsr $018835			jsr 	BinaryMakeBothInteger
.0187e8	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0187eb	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.0187ee	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0187f1	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0187f4	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.0187f7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0187fa	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0187fd	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018800	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018803	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018806	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018809	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01880c	60		rts				rts
.01880d					BinaryOp_Eor:
.01880d					BinaryOp_Xor:
.01880d	20 35 88	jsr $018835			jsr 	BinaryMakeBothInteger
.018810	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018813	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018816	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018819	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.01881c	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.01881f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018822	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018825	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018828	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01882b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.01882e	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018831	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018834	60		rts				rts
.018835					BinaryMakeBothInteger:
.018835	da		phx				phx 								; save X
.018836	e8		inx				inx
.018837	e8		inx				inx
.018838	e8		inx				inx
.018839	e8		inx				inx
.01883a	e8		inx				inx
.01883b	e8		inx				inx
.01883c	20 40 88	jsr $018840			jsr 	BinaryMakeInteger 			; convert to integer.
.01883f	fa		plx				plx 								; restore X and fall through.
.018840					BinaryMakeInteger:
.018840	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018843	29 0f		and #$0f			and 	#15 						; check type zero
.018845	f0 04		beq $01884b			beq 	_BMIConvert 				; if float convert to integer.
.018847	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018848	90 04		bcc $01884e			bcc 	_BMIError
.01884a	60		rts				rts
.01884b					_BMIConvert:
.01884b	4c 29 95	jmp $019529			jmp 	FPUToInteger 				; convert to integer
.01884e					_BMIError:
.01884e	4c 07 82	jmp $018207			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018851					Binary_Equal:
.018851	20 9d 88	jsr $01889d			jsr 	CompareValues
.018854	09 00		ora #$00			ora 	#0
.018856	f0 04		beq $01885c			beq 	CCTrue
.018858	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.01885a	80 02		bra $01885e			bra 	CCWrite
.01885c	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01885e	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018861	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018864	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018867	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01886a	a9 01		lda #$01			lda 	#1
.01886c	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.01886f	60		rts				rts
.018870					Binary_NotEqual:
.018870	20 9d 88	jsr $01889d			jsr 	CompareValues
.018873	09 00		ora #$00			ora 	#0
.018875	f0 e1		beq $018858			beq 	CCFalse
.018877	80 e3		bra $01885c			bra 	CCTrue
.018879					Binary_Less:
.018879	20 9d 88	jsr $01889d			jsr 	CompareValues
.01887c	09 00		ora #$00			ora 	#0
.01887e	30 dc		bmi $01885c			bmi 	CCTrue
.018880	80 d6		bra $018858			bra 	CCFalse
.018882					Binary_LessEqual:
.018882	20 9d 88	jsr $01889d			jsr 	CompareValues
.018885	c9 01		cmp #$01			cmp 	#1
.018887	d0 d3		bne $01885c			bne 	CCTrue
.018889	80 cd		bra $018858			bra 	CCFalse
.01888b					Binary_GreaterEqual:
.01888b	20 9d 88	jsr $01889d			jsr 	CompareValues
.01888e	09 00		ora #$00			ora 	#0
.018890	10 ca		bpl $01885c			bpl 	CCTrue
.018892	80 c4		bra $018858			bra 	CCFalse
.018894					Binary_Greater:
.018894	20 9d 88	jsr $01889d			jsr 	CompareValues
.018897	c9 01		cmp #$01			cmp 	#1
.018899	f0 c1		beq $01885c			beq 	CCTrue
.01889b	80 bb		bra $018858			bra 	CCFalse
.01889d					CompareValues:
.01889d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.0188a0	3d 13 03	and $0313,x			and 	XS2_Type,x
.0188a3	c9 02		cmp #$02			cmp 	#2
.0188a5	f0 13		beq $0188ba			beq 	_CVString
.0188a7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0188aa	3d 13 03	and $0313,x			and 	XS2_Type,x
.0188ad	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0188ae	90 03		bcc $0188b3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0188b0	4c 00 89	jmp $018900			jmp 	CompareInteger32 							; so execute code at \1
.0188b3					_BCFloat:
.0188b3	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0188b6	4c 38 94	jmp $019438			jmp 	FPCompare 							; and execute code at \2
.0188b9	60		rts				rts
.0188ba					_CVString:
.0188ba	da		phx				phx 								; save XY
.0188bb	5a		phy				phy
.0188bc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0188bf	85 1a		sta $1a				sta		zLTemp1+0
.0188c1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0188c4	85 1b		sta $1b				sta 	zLTemp1+1
.0188c6	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0188c9	85 1c		sta $1c				sta 	zLTemp1+2
.0188cb	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0188ce	85 1d		sta $1d				sta 	zLTemp1+3
.0188d0	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0188d2	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0188d4	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188d6	90 02		bcc $0188da			bcc 	_CVCommon
.0188d8	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.0188da					_CVCommon:
.0188da	aa		tax				tax 								; put shorter string length in zero.
.0188db	f0 0c		beq $0188e9			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0188dd					_CVCompare:
.0188dd	c8		iny				iny 								; next character
.0188de	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.0188e0	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188e2	90 13		bcc $0188f7			bcc 	_CVReturnLess 				; <
.0188e4	d0 15		bne $0188fb			bne 	_CVReturnGreater 			; >
.0188e6	ca		dex				dex 								; until common length matched.
.0188e7	d0 f4		bne $0188dd			bne 	_CVCompare
.0188e9					_CVMatch:
.0188e9	a0 00		ldy #$00			ldy 	#0
.0188eb	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.0188ed	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.0188ef	90 06		bcc $0188f7			bcc 	_CVReturnLess 				; <
.0188f1	d0 08		bne $0188fb			bne 	_CVReturnGreater 			; >
.0188f3	a9 00		lda #$00			lda 	#0
.0188f5	80 06		bra $0188fd			bra 	_CVExit 					; same common, same length, same string
.0188f7					_CVReturnLess:
.0188f7	a9 ff		lda #$ff			lda 	#$FF
.0188f9	80 02		bra $0188fd			bra 	_CVExit
.0188fb					_CVReturnGreater:
.0188fb	a9 01		lda #$01			lda 	#$01
.0188fd					_CVExit:
.0188fd	7a		ply				ply
.0188fe	fa		plx				plx
.0188ff	60		rts				rts
.018900					CompareInteger32:
.018900	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018903	49 80		eor #$80			eor 	#$80
.018905	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018908	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.01890b	49 80		eor #$80			eor 	#$80
.01890d	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018910	20 a8 89	jsr $0189a8			jsr 	SubInteger32 				; subtraction
.018913	90 11		bcc $018926			bcc 	_CI32Less 					; cc return -1
.018915	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018918	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01891b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.01891e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018921	f0 02		beq $018925			beq 	_CI32Exit
.018923	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018925					_CI32Exit:
.018925	60		rts				rts
.018926					_CI32Less:
.018926	a9 ff		lda #$ff			lda 	#$FF
.018928	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018929					BinaryOp_Add:
.018929	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.01892c	3d 13 03	and $0313,x			and 	XS2_Type,x
.01892f	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018931	d0 13		bne $018946			bne 	_BOAString
.018933	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018936	3d 13 03	and $0313,x			and 	XS2_Type,x
.018939	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01893a	90 03		bcc $01893f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01893c	4c 82 89	jmp $018982			jmp 	AddInteger32 							; so execute code at \1
.01893f					_BCFloat:
.01893f	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018942	4c ac 91	jmp $0191ac			jmp 	FPAdd 							; and execute code at \2
.018945	60		rts				rts
.018946					_BOAString:
.018946	4c e9 89	jmp $0189e9			jmp 	ConcatenateString 			; concatenate two strings.
.018949					BinaryOp_Subtract:
.018949	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01894c	3d 13 03	and $0313,x			and 	XS2_Type,x
.01894f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018950	90 03		bcc $018955			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018952	4c a8 89	jmp $0189a8			jmp 	SubInteger32 							; so execute code at \1
.018955					_BCFloat:
.018955	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018958	4c a2 91	jmp $0191a2			jmp 	FPSubtract 							; and execute code at \2
.01895b	60		rts				rts
.01895c					BinaryOp_Multiply:
.01895c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01895f	3d 13 03	and $0313,x			and 	XS2_Type,x
.018962	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018963	90 03		bcc $018968			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018965	4c 2e 8f	jmp $018f2e			jmp 	MulInteger32 							; so execute code at \1
.018968					_BCFloat:
.018968	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01896b	4c 18 93	jmp $019318			jmp 	FPMultiply 							; and execute code at \2
.01896e	60		rts				rts
.01896f					BinaryOp_Divide:
.01896f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018972	3d 13 03	and $0313,x			and 	XS2_Type,x
.018975	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018976	90 03		bcc $01897b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018978	4c 85 8f	jmp $018f85			jmp 	DivInteger32 							; so execute code at \1
.01897b					_BCFloat:
.01897b	20 ce 89	jsr $0189ce			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01897e	4c 90 92	jmp $019290			jmp 	FPDivide 							; and execute code at \2
.018981	60		rts				rts
.018982					AddInteger32:
.018982	18		clc				clc
.018983	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018986	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018989	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01898c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01898f	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018992	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018995	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018998	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01899b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01899e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189a1	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.0189a4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189a7	60		rts				rts
.0189a8					SubInteger32:
.0189a8	38		sec				sec
.0189a9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0189ac	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0189af	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189b2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189b5	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0189b8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0189bb	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0189be	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0189c1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189c4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189c7	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0189ca	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189cd	60		rts				rts
.0189ce					BinaryMakeBothFloat:
.0189ce	da		phx				phx 								; save X
.0189cf	e8		inx				inx
.0189d0	e8		inx				inx
.0189d1	e8		inx				inx
.0189d2	e8		inx				inx
.0189d3	e8		inx				inx
.0189d4	e8		inx				inx
.0189d5	20 d9 89	jsr $0189d9			jsr 	BinaryMakeFloat 			; convert to float.
.0189d8	fa		plx				plx 								; restore X and fall through.
.0189d9					BinaryMakeFloat:
.0189d9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.0189dc	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0189dd	b0 04		bcs $0189e3			bcs 	_BMFConvert
.0189df	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0189e0	b0 04		bcs $0189e6			bcs 	_BMFError
.0189e2	60		rts				rts
.0189e3					_BMFConvert:
.0189e3	4c ca 94	jmp $0194ca			jmp 	FPUToFloat 					; convert to float
.0189e6					_BMFError:
.0189e6	4c 07 82	jmp $018207			jmp 	TypeError
.0189e9					ConcatenateString:
.0189e9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0189ec	85 1a		sta $1a				sta		zLTemp1+0
.0189ee	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189f1	85 1b		sta $1b				sta 	zLTemp1+1
.0189f3	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.0189f6	85 1c		sta $1c				sta 	zLTemp1+2
.0189f8	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.0189fb	85 1d		sta $1d				sta 	zLTemp1+3
.0189fd	5a		phy				phy
.0189fe	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018a00	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018a02	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018a04	7a		ply				ply
.018a05	b0 37		bcs $018a3e			bcs 	_CSError					; check in range.
.018a07	c9 fe		cmp #$fe			cmp 	#maxString+1
.018a09	b0 33		bcs $018a3e			bcs 	_CSError
.018a0b	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString 			; store the result
.018a0e	20 29 8a	jsr $018a29			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a11	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018a14	85 1a		sta $1a				sta 	zLTemp1
.018a16	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018a19	85 1b		sta $1b				sta 	zLTemp1+1
.018a1b	20 29 8a	jsr $018a29			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018a1e	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018a20	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a23	a5 21		lda $21				lda 	zTempStr+1
.018a25	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a28	60		rts				rts
.018a29					_CSCopyString:
.018a29	da		phx				phx
.018a2a	5a		phy				phy
.018a2b	a0 00		ldy #$00			ldy 	#0 							; get length
.018a2d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a2f	f0 0a		beq $018a3b			beq 	_CSCSExit 					; if zero, exit
.018a31	aa		tax				tax 								; put in X
.018a32					_CSCSLoop:
.018a32	c8		iny				iny 								; get next char
.018a33	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018a35	20 58 8e	jsr $018e58			jsr		WriteTempString 			; copy out
.018a38	ca		dex				dex 								; do whole string
.018a39	d0 f7		bne $018a32			bne 	_CSCSLoop
.018a3b					_CSCSExit:
.018a3b	7a		ply				ply
.018a3c	fa		plx				plx
.018a3d	60		rts				rts
.018a3e					_CSError:
.018a3e	20 26 82	jsr $018226			jsr ERR_Handler
>018a41	53 74 72 69 6e 67 20 74			.text "String too long",0
>018a49	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018a51					Unary_Sgn:
.018a51	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.018a54	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.018a57	20 7b 8a	jsr $018a7b			jsr 	GetSignCurrent 				; get sign.
.018a5a	09 00		ora #$00			ora 	#0
.018a5c	10 09		bpl $018a67			bpl		UnarySetAInteger			; if 0,1 return that.
.018a5e	80 00		bra $018a60			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018a60					UnarySetAMinus1:
.018a60	a9 ff		lda #$ff			lda 	#$FF
.018a62	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a65	80 05		bra $018a6c			bra 	UnarySetAFill
.018a67					UnarySetAInteger:
.018a67	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018a6a	a9 00		lda #$00			lda 	#0
.018a6c					UnarySetAFill:
.018a6c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a6f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a72	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a75	a9 01		lda #$01			lda 	#1
.018a77	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018a7a	60		rts				rts
.018a7b					GetSignCurrent:
.018a7b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018a7e	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018a7f	90 19		bcc $018a9a			bcc 	_GSCFloat
.018a81	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018a84	30 11		bmi $018a97			bmi 	_GSCMinus1
.018a86	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018a89	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018a8c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018a8f	d0 03		bne $018a94			bne 	_GSCPlus1
.018a91					_GSCZero:
.018a91	a9 00		lda #$00			lda 	#0
.018a93	60		rts				rts
.018a94					_GSCPlus1:
.018a94	a9 01		lda #$01			lda 	#$01
.018a96	60		rts				rts
.018a97					_GSCMinus1:
.018a97	a9 ff		lda #$ff			lda 	#$FF
.018a99	60		rts				rts
.018a9a					_GSCFloat:
.018a9a	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018a9d	70 f2		bvs $018a91			bvs 	_GSCZero
.018a9f	30 f6		bmi $018a97			bmi 	_GSCMinus1
.018aa1	80 f1		bra $018a94			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018aa3					Unary_Abs:
.018aa3	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.018aa6	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.018aa9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018aac	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018aae	f0 08		beq $018ab8			beq 	_UAMinusFloat
.018ab0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018ab3	10 0b		bpl $018ac0			bpl 	_UAExit
.018ab5	4c 1b 90	jmp $01901b			jmp 	IntegerNegateAlways 		; negation
.018ab8					_UAMinusFloat:
.018ab8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018abb	29 7f		and #$7f			and		#$7F
.018abd	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018ac0					_UAExit:
.018ac0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018ac1					Unary_Peek:
.018ac1	a9 01		lda #$01			lda 	#1
.018ac3	80 06		bra $018acb			bra 	UPMain
.018ac5					Unary_Deek:
.018ac5	a9 02		lda #$02			lda 	#2
.018ac7	80 02		bra $018acb			bra 	UPMain
.018ac9					Unary_Leek:
.018ac9	a9 04		lda #$04			lda 	#4
.018acb					UPMain:
.018acb	48		pha				pha 								; set bytes to copy.
.018acc	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; numeric parameter
.018acf	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018ad2	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018ad5	85 1a		sta $1a				sta 	zLTemp1
.018ad7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ada	85 1b		sta $1b				sta 	zLTemp1+1
.018adc	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018adf	85 1c		sta $1c				sta 	zLTemp1+2
.018ae1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018ae4	85 1d		sta $1d				sta 	zLTemp1+3
.018ae6	a9 00		lda #$00			lda 	#0 							; clear target area
.018ae8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018aeb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018aee	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018af1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018af4	68		pla				pla 								; restore bytes to copy
.018af5	da		phx				phx 								; save XY
.018af6	5a		phy				phy
.018af7	20 f4 8d	jsr $018df4			jsr 	MemRead 					; read the bytes in
.018afa	7a		ply				ply 								; restore and exit
.018afb	fa		plx				plx
.018afc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018afd					Unary_Mod:
.018afd	20 29 8b	jsr $018b29			jsr 	_UMParameter 				; first parameter
.018b00	20 25 8e	jsr $018e25			jsr 	CheckNextComma
.018b03	da		phx				phx 								; second parameter
.018b04	e8		inx				inx
.018b05	e8		inx				inx
.018b06	e8		inx				inx
.018b07	e8		inx				inx
.018b08	e8		inx				inx
.018b09	e8		inx				inx
.018b0a	20 29 8b	jsr $018b29			jsr 	_UMParameter
.018b0d	fa		plx				plx
.018b0e	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen
.018b11	20 85 8f	jsr $018f85			jsr 	DivInteger32 				; divide
.018b14	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018b16	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b19	a5 1b		lda $1b				lda 	zLTemp1+1
.018b1b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b1e	a5 1c		lda $1c				lda 	zLTemp1+2
.018b20	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b23	a5 1d		lda $1d				lda 	zLTemp1+3
.018b25	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b28	60		rts				rts
.018b29					_UMParameter:
.018b29	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; get value
.018b2c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018b2f	10 03		bpl $018b34			bpl 	_UMNotSigned
.018b31	20 1b 90	jsr $01901b			jsr 	IntegerNegateAlways
.018b34					_UMNotSigned:
.018b34	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018b35					Unary_Usr:
.018b35	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; numeric parameter
.018b38	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018b3b	da		phx				phx 								; save XY
.018b3c	5a		phy				phy
.018b3d	ea		nop				nop
.018b3e	22 00 03 00	jsl $000300			jsl 	UserVector
.018b42	7a		ply				ply 								; and exit
.018b43	fa		plx				plx
.018b44	60		rts				rts
.018b45					USRDefault:
.018b45	20 26 82	jsr $018226			jsr ERR_Handler
>018b48	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018b50	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018b57					Unary_Val:
.018b57	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; get string
.018b5a	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.018b5d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018b60	85 1e		sta $1e				sta 	zGenPtr
.018b62	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b65	85 1f		sta $1f				sta 	zGenPtr+1
.018b67	5a		phy				phy
.018b68	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018b6a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018b6c	f0 57		beq $018bc5			beq 	_UVBadNumber
.018b6e	48		pha				pha 								; save length.
.018b6f	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018b70	1a		inc a				inc 	a
.018b71	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018b74	c8		iny				iny 								; move to the next.
.018b75	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018b77	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018b79	8d 2d 04	sta $042d			sta 	ValSign
.018b7c	d0 04		bne $018b82			bne 	_UVNotMinus
.018b7e	c8		iny				iny 								; skip over it.
.018b7f	68		pla				pla 								; decrement character count.
.018b80	3a		dec a				dec 	a
.018b81	48		pha				pha
.018b82					_UVNotMinus:
.018b82	68		pla				pla 								; this is the count.
.018b83	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018b84	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018b86	c8		iny				iny
.018b87	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018b8a	68		pla				pla
.018b8b	3a		dec a				dec 	a
.018b8c	d0 f5		bne $018b83			bne 	_UVCopy
.018b8e	20 58 8e	jsr $018e58			jsr 	WriteTempString 			; make it ASCIIZ
.018b91	18		clc				clc
.018b92	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018b94	69 01		adc #$01			adc 	#1
.018b96	85 1e		sta $1e				sta 	zGenPtr
.018b98	a5 21		lda $21				lda 	zTempStr+1
.018b9a	69 00		adc #$00			adc 	#0
.018b9c	85 1f		sta $1f				sta 	zGenPtr+1
.018b9e	18		clc				clc
.018b9f	20 f7 90	jsr $0190f7			jsr 	IntFromString 				; first bit.
.018ba2	b0 21		bcs $018bc5			bcs 	_UVBadNumber
.018ba4	20 1b 97	jsr $01971b			jsr 	FPFromString				; try for a float part.
.018ba7	ad 2d 04	lda $042d			lda 	ValSign 					; was it negative
.018baa	d0 13		bne $018bbf			bne 	_UVNotNegative
.018bac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018baf	4a		lsr a				lsr 	a
.018bb0	b0 0a		bcs $018bbc			bcs 	_UVInteger
.018bb2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018bb5	09 80		ora #$80			ora 	#$80
.018bb7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018bba	80 03		bra $018bbf			bra 	_UVNotNegative
.018bbc					_UVInteger:
.018bbc	20 1b 90	jsr $01901b			jsr 	IntegerNegateAlways 		; sign it.
.018bbf					_UVNotNegative:
.018bbf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018bc1	d0 02		bne $018bc5			bne 	_UVBadNumber
.018bc3	7a		ply				ply
.018bc4	60		rts				rts
.018bc5					_UVBadNumber:
.018bc5	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018bc8					Unary_Str:
.018bc8	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; numeric parameter
.018bcb	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018bce	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018bd0	8d 00 04	sta $0400			sta 	NumBufX
.018bd3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018bd6	4a		lsr a				lsr 	a
.018bd7	b0 05		bcs $018bde			bcs 	_USInt 						; if msb set do as integer
.018bd9	20 54 96	jsr $019654			jsr 	FPToString 					; call fp to str otherwise
.018bdc	80 03		bra $018be1			bra 	_USDuplicate
.018bde	20 40 90	jsr $019040	_USInt:	jsr 	IntToString
.018be1					_USDuplicate:
.018be1	ad 00 04	lda $0400			lda 	NumBufX 					; chars in buffer
.018be4	1a		inc a				inc 	a 							; one more for length
.018be5	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString 			; allocate space for it.
.018be8	5a		phy				phy 								; save Y
.018be9	a0 00		ldy #$00			ldy 	#0 							; start copying
.018beb	b9 01 04	lda $0401,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018bee	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018bf1	c8		iny				iny
.018bf2	cc 00 04	cpy $0400			cpy 	NumBufX 					; done the lot
.018bf5	d0 f4		bne $018beb			bne 	_USCopy
.018bf7	7a		ply				ply 								; restore Y
.018bf8	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018bfb					Unary_Asc:
.018bfb	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; string parameter
.018bfe	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018c01	5a		phy				phy 								; get the string length
.018c02	a0 00		ldy #$00			ldy 	#0
.018c04	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c06	f0 07		beq $018c0f			beq 	_UAIllegal 					; must be at least one character
.018c08	c8		iny				iny
.018c09	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018c0b	7a		ply				ply
.018c0c	4c 67 8a	jmp $018a67			jmp 	UnarySetAInteger
.018c0f					_UAIllegal:
.018c0f	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018c12					Unary_Len:
.018c12	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; string parameter
.018c15	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018c18	5a		phy				phy 								; get the string length
.018c19	a0 00		ldy #$00			ldy 	#0
.018c1b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018c1d	7a		ply				ply
.018c1e	4c 67 8a	jmp $018a67			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018c21					Unary_Mid:
.018c21	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 				; get string.
.018c24	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c27	48		pha				pha
.018c28	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c2b	48		pha				pha
.018c2c	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c2f	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018c32	48		pha				pha 									; and push it.
.018c33	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c36	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018c39	48		pha				pha 									; and push it.
.018c3a	80 45		bra $018c81			bra 	SLIProcess
.018c3c					Unary_Left:
.018c3c	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 				; get string.
.018c3f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c42	48		pha				pha
.018c43	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c46	48		pha				pha
.018c47	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018c49	48		pha				pha
.018c4a	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c4d	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018c50	48		pha				pha 									; and push it.
.018c51	80 2e		bra $018c81			bra 	SLIProcess
.018c53					Unary_Right:
.018c53	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 				; get string.
.018c56	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018c59	48		pha				pha
.018c5a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c5d	48		pha				pha
.018c5e	da		phx				phx 									; get the string length and push on stack.
.018c5f	a2 00		ldx #$00			ldx 	#0
.018c61	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018c63	fa		plx				plx
.018c64	48		pha				pha
.018c65	20 25 8e	jsr $018e25			jsr 	CheckNextComma 					; skip comma
.018c68	20 bc 8c	jsr $018cbc			jsr 	SLIByteParameter 				; get a byte parameter.
.018c6b	8d 29 04	sta $0429			sta 	SignCount 						; save in temporary.
.018c6e	68		pla				pla 									; restore string length.
.018c6f	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018c70	38		sec				sec
.018c71	ed 29 04	sbc $0429			sbc 	SignCount 						; subtract characters needed, gives start position.
.018c74	f0 02		beq $018c78			beq 	_URStart 						; if <= 0 start from 1.
.018c76	10 02		bpl $018c7a			bpl 	_UROkay
.018c78					_URStart:
.018c78	a9 01		lda #$01			lda 	#1
.018c7a					_UROkay:
.018c7a	48		pha				pha 									; push start
.018c7b	ad 29 04	lda $0429			lda 	SignCount 						; push count of characters
.018c7e	48		pha				pha
.018c7f	80 00		bra $018c81			bra 	SLIProcess
.018c81					SLIProcess:
.018c81	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 				; closing right bracket.
.018c84	68		pla				pla
.018c85	8d 2f 04	sta $042f			sta 	SliceCount 						; count in signcount
.018c88	1a		inc a				inc 	a 								; allocate +1 for it.
.018c89	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018c8c	68		pla				pla 									; pop start number off stack.
.018c8d	f0 3f		beq $018cce			beq 	SLIError 						; exit if start = 0
.018c8f	8d 2e 04	sta $042e			sta 	SliceStart
.018c92	68		pla				pla  									; pop string address.
.018c93	85 1f		sta $1f				sta 	zGenPtr+1
.018c95	68		pla				pla
.018c96	85 1e		sta $1e				sta 	zGenPtr
.018c98	da		phx				phx
.018c99	5a		phy				phy
.018c9a	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018c9c	ac 2e 04	ldy $042e			ldy 	SliceStart 						; start of the string (+1 for count)
.018c9f					_SLICopy:
.018c9f	ad 2f 04	lda $042f			lda 	SliceCount 						; done count characters
.018ca2	f0 12		beq $018cb6			beq 	_SLIExit
.018ca4	ce 2f 04	dec $042f			dec 	SliceCount
.018ca7	98		tya				tya 									; index of character
.018ca8	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018caa	f0 02		beq $018cae			beq 	_SLIOk 							; if equal, okay.
.018cac	b0 08		bcs $018cb6			bcs 	_SLIExit 						; if past end, then exit.
.018cae	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018cb0	c8		iny				iny
.018cb1	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018cb4	80 e9		bra $018c9f			bra 	_SLICopy 						; go round till copied characters
.018cb6					_SLIExit:
.018cb6	7a		ply				ply 									; restore YX
.018cb7	fa		plx				plx
.018cb8	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018cbb	ea		nop				nop
.018cbc					SLIByteParameter:
.018cbc	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 				; get integer
.018cbf	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018cc2	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cc5	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018cc8	d0 04		bne $018cce			bne 	SLIError
.018cca	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018ccd	60		rts				rts
.018cce					SLIError:
.018cce	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018cd1					Unary_Hex:
.018cd1	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; numeric parameter
.018cd4	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018cd7	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018cd9	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString			; allocate string space
.018cdc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018cdf	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018ce2	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018ce5	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018ce8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ceb	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018cee	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018cf1	20 06 8d	jsr $018d06			jsr 	_UHConvert
.018cf4	5a		phy				phy 								; get length of new string
.018cf5	a0 00		ldy #$00			ldy 	#0
.018cf7	b1 20		lda ($20),y			lda 	(zTempStr),y
.018cf9	7a		ply				ply
.018cfa	c9 00		cmp #$00			cmp 	#0
.018cfc	d0 05		bne $018d03			bne 	_UHExit 					; if it was non zero okay
.018cfe	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018d00	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018d03					_UHExit:
.018d03	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018d06					_UHConvert:
.018d06	48		pha				pha
.018d07	4a		lsr a				lsr 	a 							; do MSB
.018d08	4a		lsr a				lsr 	a
.018d09	4a		lsr a				lsr 	a
.018d0a	4a		lsr a				lsr 	a
.018d0b	20 0f 8d	jsr $018d0f			jsr 	_UHNibble
.018d0e	68		pla				pla 								; do LSB
.018d0f					_UHNibble:
.018d0f	29 0f		and #$0f			and 	#15 						; get nibble
.018d11	d0 0c		bne $018d1f			bne 	_UHNonZero
.018d13	5a		phy				phy									; get the length
.018d14	a0 00		ldy #$00			ldy 	#0
.018d16	b1 20		lda ($20),y			lda 	(zTempStr),y
.018d18	7a		ply				ply
.018d19	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018d1b	f0 0d		beq $018d2a			beq 	_UHExit2
.018d1d	a9 00		lda #$00			lda 	#0
.018d1f					_UHNonZero:
.018d1f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018d21	90 02		bcc $018d25			bcc 	_UHDigit
.018d23	69 06		adc #$06			adc 	#7-1
.018d25					_UHDigit:
.018d25	69 30		adc #$30			adc 	#48
.018d27	20 58 8e	jsr $018e58			jsr 	WriteTempString				; output.
.018d2a					_UHExit2:
.018d2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018d2b					Unary_Dec:
.018d2b	20 a6 87	jsr $0187a6			jsr 	EvaluateStringX 			; string parameter
.018d2e	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018d31	5a		phy				phy
.018d32	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018d34	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d36	f0 4c		beq $018d84			beq 	_UDFail 					; must fail if zero.
.018d38	8d 29 04	sta $0429			sta 	SignCount 					; use SignCount as a counter
.018d3b	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018d3d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d40	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d43	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d46	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d49	a9 01		lda #$01			lda 	#1
.018d4b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018d4e					_UDConvertLoop:
.018d4e	5a		phy				phy 								; shift mantissa left 4
.018d4f	a0 04		ldy #$04			ldy 	#4
.018d51					_UDShift:
.018d51	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018d54	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018d57	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018d5a	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018d5d	88		dey				dey
.018d5e	d0 f1		bne $018d51			bne 	_UDShift
.018d60	7a		ply				ply
.018d61	c8		iny				iny 								; next character
.018d62	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018d64	20 87 8d	jsr $018d87			jsr 	ConvertUpper 				; convert to U/C
.018d67	c9 30		cmp #$30			cmp 	#"0"
.018d69	90 19		bcc $018d84			bcc 	_UDFail
.018d6b	c9 3a		cmp #$3a			cmp 	#"9"+1
.018d6d	90 06		bcc $018d75			bcc 	_UDOkay
.018d6f	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018d71	c9 10		cmp #$10			cmp 	#16
.018d73	b0 0f		bcs $018d84			bcs 	_UDFail
.018d75					_UDOkay:
.018d75	29 0f		and #$0f			and 	#15 						; nibble only
.018d77	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018d7a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d7d	ce 29 04	dec $0429			dec 	SignCount 					; do it for each character
.018d80	d0 cc		bne $018d4e			bne 	_UDConvertLoop
.018d82	7a		ply				ply
.018d83	60		rts				rts
.018d84					_UDFail:
.018d84	4c 15 82	jmp $018215			jmp 	BadParamError
.018d87					ConvertUpper:
.018d87	c9 61		cmp #$61			cmp 	#"a"
.018d89	90 07		bcc $018d92			bcc 	_CUExit
.018d8b	c9 7b		cmp #$7b			cmp 	#"z"+1
.018d8d	b0 03		bcs $018d92			bcs 	_CUExit
.018d8f	38		sec				sec
.018d90	e9 20		sbc #$20			sbc 	#32
.018d92	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018d93					Unary_Chr:
.018d93	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX			; numeric parameter
.018d96	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018d99	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018d9c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018d9f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018da2	d0 0e		bne $018db2			bne 	_UCChar
.018da4	a9 01		lda #$01			lda 	#1 							; one character string
.018da6	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018da9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018dac	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018daf	4c e4 8d	jmp $018de4			jmp 	UnaryReturnTempStr
.018db2					_UCChar:
.018db2	4c 15 82	jmp $018215			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018db5					Unary_Spc:
.018db5	20 9d 87	jsr $01879d			jsr 	EvaluateIntegerX 			; numeric parameter
.018db8	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; right bracket.
.018dbb	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018dbe	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018dc1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018dc4	d0 1b		bne $018de1			bne 	_USSize
.018dc6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018dc9	c9 fe		cmp #$fe			cmp 	#maxString+1
.018dcb	b0 14		bcs $018de1			bcs 	_USSize
.018dcd	48		pha				pha 								; save length
.018dce	1a		inc a				inc 	a 							; allocate one more.
.018dcf	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString
.018dd2	68		pla				pla 								; get length
.018dd3	f0 0f		beq $018de4			beq 	UnaryReturnTempStr 			; return the current temp string
.018dd5					_USLoop:
.018dd5	48		pha				pha
.018dd6	a9 20		lda #$20			lda 	#" "
.018dd8	20 58 8e	jsr $018e58			jsr 	WriteTempString
.018ddb	68		pla				pla
.018ddc	3a		dec a				dec 	a
.018ddd	d0 f6		bne $018dd5			bne 	_USLoop
.018ddf	80 03		bra $018de4			bra 	UnaryReturnTempStr
.018de1					_USSize:
.018de1	4c 15 82	jmp $018215			jmp 	BadParamError
.018de4					UnaryReturnTempStr:
.018de4	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.018de6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018de9	a5 21		lda $21				lda 	zTempStr+1
.018deb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018dee	a9 02		lda #$02			lda 	#2 							; set type to string
.018df0	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018df3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.018df4					MemRead:
.018df4	8d 29 04	sta $0429			sta 	SignCount 					; save count
.018df7	a0 00		ldy #$00			ldy 	#0 							; start from here
.018df9	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.018dfb	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.018dfe	c8		iny				iny 								; next to copy
.018dff	e8		inx				inx
.018e00	cc 29 04	cpy $0429			cpy 	SignCount 					; do required # of bytes.
.018e03	d0 f4		bne $018df9			bne 	_MLoop1
.018e05	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.018e06					CheckNextToken:
.018e06	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.018e08	d0 02		bne $018e0c			bne 	CTFail 						; no, then fail
.018e0a	c8		iny				iny
.018e0b	60		rts				rts
.018e0c					CTFail:
.018e0c	20 26 82	jsr $018226			jsr ERR_Handler
>018e0f	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>018e17	74 6f 6b 65 6e 00
.018e1d					CheckNextRParen:
.018e1d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e1f	c9 bc		cmp #$bc			cmp 	#token_rparen
.018e21	d0 e9		bne $018e0c			bne 	CTFail
.018e23	c8		iny				iny
.018e24	60		rts				rts
.018e25					CheckNextComma:
.018e25	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e27	c9 bd		cmp #$bd			cmp 	#token_comma
.018e29	d0 e1		bne $018e0c			bne 	CTFail
.018e2b	c8		iny				iny
.018e2c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.018e2d					AllocateTempString:
.018e2d	48		pha				pha 								; save required count.
.018e2e	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.018e30	d0 0b		bne $018e3d			bne 	_ATSInitialised
.018e32	ad 2a 04	lda $042a			lda 	StringPtr 					; set temporary string ptr 1 page below available
.018e35	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.018e37	ad 2b 04	lda $042b			lda 	StringPtr+1
.018e3a	3a		dec a				dec 	a
.018e3b	85 21		sta $21				sta 	zTempStr+1
.018e3d					_ATSInitialised:
.018e3d	68		pla				pla 								; get required count back.
.018e3e	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.018e40	1a		inc a				inc 	a
.018e41	18		clc				clc
.018e42	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.018e44	85 20		sta $20				sta 	zTempStr
.018e46	a9 ff		lda #$ff			lda 	#$FF
.018e48	65 21		adc $21				adc 	zTempStr+1
.018e4a	85 21		sta $21				sta 	zTempStr+1
.018e4c	a9 00		lda #$00			lda 	#0 							; clear temp string.
.018e4e	5a		phy				phy
.018e4f	a8		tay				tay
.018e50	91 20		sta ($20),y			sta 	(zTempStr),y
.018e52	7a		ply				ply
.018e53	1a		inc a				inc 	a 							; reset the write index.
.018e54	8d 2c 04	sta $042c			sta 	TempStringWriteIndex
.018e57	60		rts				rts
.018e58					WriteTempString:
.018e58	5a		phy				phy 								; save Y
.018e59	ac 2c 04	ldy $042c			ldy 	TempStringWriteIndex	 	; write position.
.018e5c	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.018e5e	ee 2c 04	inc $042c			inc 	TempStringWriteIndex 		; increment the write position.
.018e61	98		tya				tya 								; unchanged Y is now length
.018e62	a0 00		ldy #$00			ldy 	#0
.018e64	91 20		sta ($20),y			sta 	(zTempStr),y
.018e66	7a		ply				ply 								; restore Y and exit
.018e67	60		rts				rts
.018e68					CreateTempStringCopy:
.018e68	da		phx				phx 								; save X
.018e69	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e6b	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.018e6c	20 2d 8e	jsr $018e2d			jsr 	AllocateTempString 			; allocate memory for temporary string.
.018e6f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e71	c8		iny				iny
.018e72	3a		dec a				dec 	a 							; make the actual length in charactes
.018e73	3a		dec a				dec 	a
.018e74	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.018e76	81 20		sta ($20,x)			sta 	(zTempStr,x)
.018e78	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.018e7a	09 00		ora #$00			ora 	#0 							; if zero already, exit
.018e7c	f0 0e		beq $018e8c			beq 	_CTSCExit
.018e7e					_CTSCLoop:
.018e7e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e80	c8		iny				iny
.018e81	5a		phy				phy 								; save in Y
.018e82	e8		inx				inx 								; bump index
.018e83	da		phx				phx 								; index into Y
.018e84	7a		ply				ply
.018e85	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.018e87	7a		ply				ply 								; restore Y
.018e88	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.018e8a	d0 f2		bne $018e7e			bne 	_CTSCLoop
.018e8c					_CTSCExit:
.018e8c	fa		plx				plx 								; restore X
.018e8d	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.018e8e					VariableFind:
.018e8e	20 b7 8e	jsr $018eb7			jsr 	VariableExtract 		; find out all about it ....
.018e91					VariableClear:
.018e91	48		pha				pha 							; save registers
.018e92	da		phx				phx
.018e93	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.018e95	8a		txa				txa
.018e96	9d 3f 04	sta $043f,x	_VCLoop:sta 	HashTableBase,x
.018e99	e8		inx				inx
.018e9a	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.018e9c	d0 f8		bne $018e96			bne 	_VCLoop
.018e9e	fa		plx				plx 							; restore registers
.018e9f	68		pla				pla
.018ea0	60		rts				rts
.018ea1					VariableGet:
.018ea1	ea		nop				nop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.018ea2					VariableNameError:
.018ea2	20 26 82	jsr $018226			jsr ERR_Handler
>018ea5	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>018ead	61 62 6c 65 20 4e 61 6d 65 00
.018eb7					VariableExtract:
.018eb7	da		phx				phx 							; save X.
.018eb8	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.018eba	8d 21 04	sta $0421			sta 	Var_Type
.018ebd	8d 22 04	sta $0422			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.018ec0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ec2	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.018ec4	f0 dc		beq $018ea2			beq 	VariableNameError
.018ec6	c9 1b		cmp #$1b			cmp 	#26+1
.018ec8	b0 d8		bcs $018ea2			bcs 	VariableNameError
.018eca	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.018ecc					_VECopyBuffer:
.018ecc	e8		inx				inx
.018ecd	e0 1f		cpx #$1f			cpx 	#31 					; too long
.018ecf	f0 d1		beq $018ea2			beq 	VariableNameError
.018ed1	9d 01 04	sta $0401,x			sta 	Var_Buffer,x 			; save character
.018ed4	18		clc				clc  							; update the hash value for it.
.018ed5	6d 22 04	adc $0422			adc 	Var_Hash
.018ed8	8d 22 04	sta $0422			sta 	Var_Hash
.018edb	c8		iny				iny
.018edc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ede	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.018ee0	f0 0e		beq $018ef0			beq 	_VECopyEnd
.018ee2	30 0c		bmi $018ef0			bmi 	_VECopyEnd
.018ee4	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.018ee6	90 e4		bcc $018ecc			bcc 	_VECopyBuffer
.018ee8	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.018eea	90 04		bcc $018ef0			bcc 	_VECopyEnd
.018eec	c9 3a		cmp #$3a			cmp 	#"9"+1
.018eee	b0 dc		bcs $018ecc			bcs 	_VECopyBuffer
.018ef0					_VECopyEnd:
.018ef0	c8		iny				iny
.018ef1	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.018ef3	90 04		bcc $018ef9			bcc 	_VEDefaultRequired
.018ef5	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.018ef7	90 0b		bcc $018f04			bcc 	_VEHaveType
.018ef9					_VEDefaultRequired:
.018ef9	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.018efb	f0 04		beq $018f01			beq 	_VESetType 				; default set above.
.018efd	ce 21 04	dec $0421			dec 	Var_Type 				; this changes that default to the variable default
.018f00	88		dey				dey
.018f01					_VESetType:
.018f01	ad 21 04	lda $0421			lda 	Var_Type 				; get type ....
.018f04					_VEHaveType:
.018f04	ea		nop				nop
.018f05	8d 21 04	sta $0421			sta 	Var_Type 				; save as type.
.018f08	bd 01 04	lda $0401,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.018f0b	09 80		ora #$80			ora 	#$80
.018f0d	9d 01 04	sta $0401,x			sta 	Var_Buffer,x
.018f10	e8		inx				inx 							; offset 3 => length 4.
.018f11	8e 23 04	stx $0423			stx 	Var_Length 				; save length of variable name.
.018f14	ad 21 04	lda $0421			lda 	Var_Type 				; get offset of var type from first type token
.018f17	38		sec				sec
.018f18	e9 b5		sbc #$b5			sbc 	#token_Dollar
.018f1a	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.018f1b	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.018f1c	0a		asl a				asl 	a
.018f1d	0a		asl a				asl 	a
.018f1e	8d 24 04	sta $0424			sta 	Var_HashAddress
.018f21	ad 22 04	lda $0422			lda 	Var_Hash 				; get the hash
.018f24	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.018f26	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.018f27	6d 24 04	adc $0424			adc 	Var_HashAddress 		; add table offset.
.018f2a	69 3f		adc #$3f			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.018f2c	fa		plx				plx
.018f2d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.018f2e					MulInteger32:
.018f2e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.018f31	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.018f34	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f37	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.018f3a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f3d	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.018f40	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018f43	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.018f46	a9 00		lda #$00			lda 	#0
.018f48	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.018f4b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f4e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f51	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f54					_BFMMultiply:
.018f54	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.018f57	29 01		and #$01			and 	#1
.018f59	f0 03		beq $018f5e			beq 	_BFMNoAdd
.018f5b	20 82 89	jsr $018982			jsr 	AddInteger32
.018f5e					_BFMNoAdd:
.018f5e	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.018f61	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.018f64	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.018f67	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.018f6a	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.018f6d	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.018f70	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.018f73	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.018f76	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.018f79	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.018f7c	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.018f7f	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.018f82	d0 d0		bne $018f54			bne 	_BFMMultiply
.018f84	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.018f85					DivInteger32:
.018f85	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.018f88	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018f8b	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018f8e	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018f91	d0 14		bne $018fa7			bne 	_BFDOkay
.018f93	20 26 82	jsr $018226			jsr ERR_Handler
>018f96	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>018f9e	20 62 79 20 5a 65 72 6f 00
.018fa7					_BFDOkay:
.018fa7	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.018fa9	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.018fab	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.018fad	85 1c		sta $1c				sta 	zLTemp1+2
.018faf	85 1d		sta $1d				sta 	zLTemp1+3
.018fb1	8d 29 04	sta $0429			sta 	SignCount 					; Count of signs.
.018fb4	20 15 90	jsr $019015			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.018fb7	da		phx				phx
.018fb8	e8		inx				inx
.018fb9	e8		inx				inx
.018fba	e8		inx				inx
.018fbb	e8		inx				inx
.018fbc	e8		inx				inx
.018fbd	e8		inx				inx
.018fbe	20 15 90	jsr $019015			jsr 	CheckIntegerNegate
.018fc1	fa		plx				plx
.018fc2	5a		phy				phy 								; Y is the counter
.018fc3	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.018fc5					_BFDLoop:
.018fc5	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.018fc8	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018fcb	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018fce	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018fd1	26 1a		rol $1a				rol 	zLTemp1
.018fd3	26 1b		rol $1b				rol 	zLTemp1+1
.018fd5	26 1c		rol $1c				rol 	zLTemp1+2
.018fd7	26 1d		rol $1d				rol 	zLTemp1+3
.018fd9	38		sec				sec
.018fda	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.018fdc	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018fdf	48		pha				pha
.018fe0	a5 1b		lda $1b				lda 	zLTemp1+1
.018fe2	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018fe5	48		pha				pha
.018fe6	a5 1c		lda $1c				lda 	zLTemp1+2
.018fe8	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018feb	48		pha				pha
.018fec	a5 1d		lda $1d				lda 	zLTemp1+3
.018fee	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018ff1	90 15		bcc $019008			bcc 	_BFDNoAdd
.018ff3	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.018ff5	68		pla				pla
.018ff6	85 1c		sta $1c				sta 	zLTemp1+2
.018ff8	68		pla				pla
.018ff9	85 1b		sta $1b				sta 	zLTemp1+1
.018ffb	68		pla				pla
.018ffc	85 1a		sta $1a				sta 	zLTemp1+0
.018ffe	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019001	09 01		ora #$01			ora 	#1
.019003	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019006	80 03		bra $01900b			bra 	_BFDNext
.019008					_BFDNoAdd:
.019008	68		pla				pla 								; Throw away the intermediate calculations
.019009	68		pla				pla
.01900a	68		pla				pla
.01900b					_BFDNext:
.01900b	88		dey				dey
.01900c	d0 b7		bne $018fc5			bne 	_BFDLoop
.01900e	7a		ply				ply 								; restore Y and exit
.01900f	4e 29 04	lsr $0429			lsr 	SignCount 					; if sign count odd,
.019012	b0 07		bcs $01901b			bcs		IntegerNegateAlways 			; negate the result
.019014	60		rts				rts
.019015					CheckIntegerNegate:
.019015	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019018	30 01		bmi $01901b			bmi 	IntegerNegateAlways
.01901a	60		rts				rts
.01901b					IntegerNegateAlways:
.01901b	ee 29 04	inc $0429			inc 	SignCount
.01901e	38		sec				sec
.01901f	a9 00		lda #$00			lda 	#0
.019021	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019024	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019027	a9 00		lda #$00			lda 	#0
.019029	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.01902c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01902f	a9 00		lda #$00			lda 	#0
.019031	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019034	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019037	a9 00		lda #$00			lda 	#0
.019039	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.01903c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01903f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019040					INTToString:
.019040	48		pha				pha
.019041	5a		phy				phy
.019042	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.019045	10 08		bpl $01904f			bpl 		_ITSNotMinus
.019047	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019049	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter
.01904c	20 1b 90	jsr $01901b			jsr 		IntegerNegateAlways 	; negate the number.
.01904f					_ITSNotMinus:
.01904f	a9 00		lda #$00			lda 		#0
.019051	8d 25 04	sta $0425			sta 		NumSuppress 			; clear the suppression flag.
.019054	8a		txa				txa 								; use Y for the mantissa index.
.019055	a8		tay				tay
.019056	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019058					_ITSNextSubtractor:
.019058	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01905a	8d 26 04	sta $0426			sta 		NumConvCount
.01905d					_ITSSubtract:
.01905d	38		sec				sec
.01905e	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019061	ff c0 90 01	sbc $0190c0,x			sbc 		_ITSSubtractors+0,x
.019065	48		pha				pha
.019066	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.019069	ff c1 90 01	sbc $0190c1,x			sbc 		_ITSSubtractors+1,x
.01906d	48		pha				pha
.01906e	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.019071	ff c2 90 01	sbc $0190c2,x			sbc 		_ITSSubtractors+2,x
.019075	48		pha				pha
.019076	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.019079	ff c3 90 01	sbc $0190c3,x			sbc 		_ITSSubtractors+3,x
.01907d	90 14		bcc $019093			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01907f	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019082	68		pla				pla
.019083	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.019086	68		pla				pla
.019087	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.01908a	68		pla				pla
.01908b	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.01908e	ee 26 04	inc $0426			inc 		NumConvCount 			; bump count.
.019091	80 ca		bra $01905d			bra 		_ITSSubtract 			; go round again.
.019093					_ITSCantSubtract:
.019093	68		pla				pla 								; throw away interim answers
.019094	68		pla				pla
.019095	68		pla				pla
.019096	ad 26 04	lda $0426			lda 		NumConvCount 			; if not zero then no suppression check
.019099	c9 30		cmp #$30			cmp 		#"0"
.01909b	d0 05		bne $0190a2			bne 		_ITSOutputDigit
.01909d	ad 25 04	lda $0425			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.0190a0	10 09		bpl $0190ab			bpl	 		_ITSGoNextSubtractor
.0190a2					_ITSOutputDigit:
.0190a2	ce 25 04	dec $0425			dec 		NumSuppress 			; suppression check will be non-zero.
.0190a5	ad 26 04	lda $0426			lda 		NumConvCount 			; count of subtractions
.0190a8	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter 		; output it.
.0190ab					_ITSGoNextSubtractor:
.0190ab	e8		inx				inx 								; next dword
.0190ac	e8		inx				inx
.0190ad	e8		inx				inx
.0190ae	e8		inx				inx
.0190af	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.0190b1	d0 a5		bne $019058			bne 		_ITSNextSubtractor 		; do all the subtractors.
.0190b3	98		tya				tya 								; X is back as the mantissa index
.0190b4	aa		tax				tax
.0190b5	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.0190b8	09 30		ora #$30			ora 		#"0"
.0190ba	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter
.0190bd	7a		ply				ply 								; and exit
.0190be	68		pla				pla
.0190bf	60		rts				rts
.0190c0					_ITSSubtractors:
>0190c0	00 ca 9a 3b					.dword 		1000000000
>0190c4	00 e1 f5 05					.dword 		100000000
>0190c8	80 96 98 00					.dword 		10000000
>0190cc	40 42 0f 00					.dword 		1000000
>0190d0	a0 86 01 00					.dword 		100000
>0190d4	10 27 00 00					.dword 		10000
>0190d8	e8 03 00 00					.dword 		1000
>0190dc	64 00 00 00					.dword 		100
>0190e0	0a 00 00 00					.dword 		10
.0190e4					_ITSSubtractorsEnd:
.0190e4					ITSOutputCharacter:
.0190e4	48		pha				pha
.0190e5	da		phx				phx
.0190e6	ae 00 04	ldx $0400			ldx 	NumBufX 					; save digit
.0190e9	9d 01 04	sta $0401,x			sta 	Num_Buffer,x
.0190ec	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0190ee	9d 02 04	sta $0402,x			sta 	Num_Buffer+1,x
.0190f1	ee 00 04	inc $0400			inc 	NumBufX						; bump pointer.
.0190f4	fa		plx				plx
.0190f5	68		pla				pla
.0190f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0190f7					IntFromString:
.0190f7	a0 00		ldy #$00			ldy 	#0
.0190f9	8c 27 04	sty $0427			sty 	ExpTemp 					; this is the converted digit count.
.0190fc					IntFromStringY:
.0190fc	48		pha				pha
.0190fd	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0190ff	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019102	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019105	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019108	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01910b	a9 01		lda #$01			lda 	#1
.01910d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019110					_IFSLoop:
.019110	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019112	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019114	90 60		bcc $019176			bcc 	_IFSExit
.019116	c9 3a		cmp #$3a			cmp 	#"9"+1
.019118	b0 5c		bcs $019176			bcs 	_IFSExit
.01911a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01911d	c9 0c		cmp #$0c			cmp 	#12
.01911f	b0 5f		bcs $019180			bcs 	_IFSOverflow
.019121	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019124	48		pha				pha
.019125	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019128	48		pha				pha
.019129	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01912c	48		pha				pha
.01912d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019130	48		pha				pha
.019131	20 95 91	jsr $019195			jsr 	IFSX1ShiftLeft 				; double
.019134	20 95 91	jsr $019195			jsr 	IFSX1ShiftLeft 				; x 4
.019137	18		clc				clc 								; add saved value x 5
.019138	68		pla				pla
.019139	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.01913c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01913f	68		pla				pla
.019140	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019143	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019146	68		pla				pla
.019147	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.01914a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01914d	68		pla				pla
.01914e	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.019151	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019154	20 95 91	jsr $019195			jsr 	IFSX1ShiftLeft 				; x 10
.019157	ee 27 04	inc $0427			inc 	ExpTemp 					; bump count of digits processed.
.01915a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.01915c	29 0f		and #$0f			and 	#15
.01915e	c8		iny				iny
.01915f	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019162	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019165	90 a9		bcc $019110			bcc 	_IFSLoop
.019167	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01916a	d0 a4		bne $019110			bne 	_IFSLoop
.01916c	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.01916f	d0 9f		bne $019110			bne 	_IFSLoop
.019171	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.019174	80 9a		bra $019110			bra 	_IFSLoop
.019176					_IFSExit:
.019176	98		tya				tya 								; get offset
.019177					_IFSOkay:
.019177	38		sec				sec
.019178	ad 27 04	lda $0427			lda 	ExpTemp
.01917b	f0 01		beq $01917e			beq 	_IFSSkipFail
.01917d	18		clc				clc
.01917e					_IFSSkipFail:
.01917e	68		pla				pla 								; and exit.
.01917f	60		rts				rts
.019180					_IFSOverflow:
.019180	20 26 82	jsr $018226			jsr 	ERR_Handler
>019183	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01918b	20 6f 76 65 72 66 6c 6f 77 00
.019195					IFSX1ShiftLeft:
.019195	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.019198	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.01919b	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.01919e	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0191a1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.0191a2					FPSubtract:
.0191a2	48		pha				pha
.0191a3	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.0191a6	49 80		eor #$80			eor 	#$80
.0191a8	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0191ab	68		pla				pla 								; --- and fall through ---
.0191ac					FPAdd:
.0191ac	48		pha				pha
.0191ad	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.0191b0	d0 05		bne $0191b7			bne 	_FPA_NegativeLHS
.0191b2	20 d4 91	jsr $0191d4			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.0191b5	68		pla				pla
.0191b6	60		rts				rts
.0191b7					_FPA_NegativeLHS:
.0191b7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.0191ba	49 80		eor #$80			eor 	#$80
.0191bc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0191bf	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.0191c2	49 80		eor #$80			eor 	#$80
.0191c4	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0191c7	20 d4 91	jsr $0191d4			jsr 	FPAdd_Worker 				; do the add calculation.
.0191ca	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.0191cd	49 80		eor #$80			eor 	#$80
.0191cf	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0191d2	68		pla				pla
.0191d3	60		rts				rts
.0191d4					FPAdd_Worker:
.0191d4	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.0191d7	70 08		bvs $0191e1			bvs 	_FPAWExit 					; no change.
.0191d9	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.0191dc	50 07		bvc $0191e5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0191de	20 79 94	jsr $019479			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0191e1					_FPAWExit:
.0191e1	20 01 95	jsr $019501			jsr 	FPUNormalise 				; normalise the result.
.0191e4	60		rts				rts
.0191e5					_FPAWMakeSame:
.0191e5	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0191e8	38		sec				sec
.0191e9	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0191ec	f0 1b		beq $019209			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0191ee	da		phx				phx 								; save X
.0191ef	90 06		bcc $0191f7			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.0191f1	e8		inx				inx
.0191f2	e8		inx				inx
.0191f3	e8		inx				inx
.0191f4	e8		inx				inx
.0191f5	e8		inx				inx
.0191f6	e8		inx				inx
.0191f7					_FPAWShiftA:
.0191f7	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0191fa	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0191fd	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019200	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019203	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019206	fa		plx				plx 								; restore original X
.019207	80 dc		bra $0191e5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019209					_FPAW_DoArithmetic:
.019209	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01920c	30 39		bmi $019247			bmi 	_FPAW_BNegative
.01920e	18		clc				clc
.01920f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019212	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019215	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019218	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01921b	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.01921e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019221	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019224	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019227	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01922a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01922d	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019230	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019233	90 ac		bcc $0191e1			bcc 	_FPAWExit 					; no carry.
.019235	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019238	38		sec				sec
.019239	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.01923c	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01923f	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019242	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019245	80 9a		bra $0191e1			bra 	_FPAWExit
.019247					_FPAW_BNegative:
.019247	38		sec				sec
.019248	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01924b	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.01924e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019251	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019254	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019257	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01925a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01925d	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019260	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019263	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019266	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019269	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01926c	b0 0b		bcs $019279			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01926e	20 a6 94	jsr $0194a6			jsr 	FPUNegateInteger			; negate the mantissa
.019271	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.019274	49 80		eor #$80			eor 	#$80
.019276	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019279					_FPAWGoExit:
.019279	4c e1 91	jmp $0191e1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01927c					FPD_IsDivZero:
.01927c	20 26 82	jsr $018226			jsr ERR_Handler
>01927f	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019287	20 62 79 20 7a 65 72 6f 00
.019290					FPDivide:
.019290	48		pha				pha
.019291	5a		phy				phy
.019292	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.019295	70 e5		bvs $01927c			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019297	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01929a	f0 03		beq $01929f			beq 	_FPDCalculateExp
.01929c					_FPD_Exit:
.01929c	7a		ply				ply
.01929d	68		pla				pla
.01929e	60		rts				rts
.01929f					_FPDCalculateExp:
.01929f	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.0192a2	49 ff		eor #$ff			eor 	#$FF
.0192a4	1a		inc a				inc 	a
.0192a5	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.0192a8	20 9c 93	jsr $01939c			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.0192ab	18		clc				clc 	 							; add 1 to the resulting exponent
.0192ac	69 01		adc #$01			adc 	#1
.0192ae	b0 65		bcs $019315			bcs 	_FPD_Overflow 				; which can overflow.
.0192b0	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0192b3	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.0192b5	85 1a		sta $1a				sta 	zLTemp1+0
.0192b7	85 1b		sta $1b				sta 	zLTemp1+1
.0192b9	85 1c		sta $1c				sta 	zLTemp1+2
.0192bb	85 1d		sta $1d				sta 	zLTemp1+3
.0192bd	a0 20		ldy #$20			ldy 	#32 						; times round.
.0192bf					_FPD_Loop:
.0192bf	38		sec				sec 								; calculate X1-X2 stacking result because we might
.0192c0	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.0192c3	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.0192c6	48		pha				pha
.0192c7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192ca	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0192cd	48		pha				pha
.0192ce	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0192d1	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0192d4	48		pha				pha
.0192d5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0192d8	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0192db	90 17		bcc $0192f4			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.0192dd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.0192e0	68		pla				pla
.0192e1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0192e4	68		pla				pla
.0192e5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0192e8	68		pla				pla
.0192e9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0192ec	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.0192ee	09 80		ora #$80			ora 	#$80
.0192f0	85 1d		sta $1d				sta 	zLTemp1+3
.0192f2	80 03		bra $0192f7			bra 	_FPD_Rotates
.0192f4					_FPD_NoSubtract:
.0192f4	68		pla				pla 								; throw away unwanted results
.0192f5	68		pla				pla
.0192f6	68		pla				pla
.0192f7					_FPD_Rotates:
.0192f7	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.0192fa	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.0192fd	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.019300	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.019303	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019305	26 1b		rol $1b				rol 	zLTemp1+1
.019307	26 1c		rol $1c				rol 	zLTemp1+2
.019309	26 1d		rol $1d				rol 	zLTemp1+3
.01930b	90 02		bcc $01930f			bcc 	_FPD_NoCarry
.01930d	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01930f					_FPD_NoCarry:
.01930f	88		dey				dey 								; do 32 times
.019310	d0 ad		bne $0192bf			bne 	_FPD_Loop
.019312	4c 79 93	jmp $019379			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019315					_FPD_Overflow:
.019315	4c 76 95	jmp $019576			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019318					FPMultiply:
.019318	48		pha				pha
.019319	5a		phy				phy
.01931a	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01931d	70 08		bvs $019327			bvs 	_FPM_Exit
.01931f	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019322	50 06		bvc $01932a			bvc 	_FPM_CalcExponent
.019324	20 79 94	jsr $019479			jsr 	FPUCopyX2ToX1
.019327					_FPM_Exit:
.019327	7a		ply				ply
.019328	68		pla				pla
.019329	60		rts				rts
.01932a					_FPM_CalcExponent:
.01932a	18		clc				clc
.01932b	20 9c 93	jsr $01939c			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01932e	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.019331	a9 00		lda #$00			lda 	#0
.019333	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019335	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019337	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019339	85 1d		sta $1d				sta 	zLTemp1+3
.01933b	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01933d					_FPM_Loop:
.01933d	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019340	29 01		and #$01			and 	#1
.019342	18		clc				clc 								; clear carry for the long rotate.
.019343	f0 1d		beq $019362			beq 	_FPM_NoAddition
.019345	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019346	a5 1a		lda $1a				lda 	zLTemp1+0
.019348	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.01934b	85 1a		sta $1a				sta 	zLTemp1+0
.01934d	a5 1b		lda $1b				lda 	zLTemp1+1
.01934f	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019352	85 1b		sta $1b				sta 	zLTemp1+1
.019354	a5 1c		lda $1c				lda 	zLTemp1+2
.019356	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019359	85 1c		sta $1c				sta 	zLTemp1+2
.01935b	a5 1d		lda $1d				lda 	zLTemp1+3
.01935d	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019360	85 1d		sta $1d				sta 	zLTemp1+3
.019362					_FPM_NoAddition:
.019362	66 1d		ror $1d				ror 	3+zLTemp1
.019364	66 1c		ror $1c				ror 	2+zLTemp1
.019366	66 1b		ror $1b				ror 	1+zLTemp1
.019368	66 1a		ror $1a				ror 	0+zLTemp1
.01936a	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.01936d	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019370	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019373	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019376	88		dey				dey
.019377	d0 c4		bne $01933d			bne 	_FPM_Loop 					; do this 32 times.
.019379					FPM_CopySignNormalize:
.019379	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01937b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01937e	a5 1b		lda $1b				lda 	zLTemp1+1
.019380	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019383	a5 1c		lda $1c				lda 	zLTemp1+2
.019385	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019388	a5 1d		lda $1d				lda 	zLTemp1+3
.01938a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01938d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019390	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019393	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019396	20 01 95	jsr $019501			jsr 	FPUNormalise 				; normalise and exit.
.019399	7a		ply				ply
.01939a	68		pla				pla
.01939b	60		rts				rts
.01939c					FPCalculateExponent:
.01939c	18		clc				clc
.01939d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.0193a0	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.0193a3	b0 08		bcs $0193ad			bcs 	_FPCECarry 					; carry out ?
.0193a5	10 03		bpl $0193aa			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.0193a7	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.0193a9	60		rts				rts
.0193aa					_FPCEExpZero:
.0193aa	a9 00		lda #$00			lda 	#0
.0193ac	60		rts				rts
.0193ad					_FPCECarry:
.0193ad	30 03		bmi $0193b2			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.0193af	09 80		ora #$80			ora 	#$80 						; put in right range
.0193b1	60		rts				rts
.0193b2					_FPCEOverflow:
.0193b2	4c 76 95	jmp $019576			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.0193b5					FPFractionalPart:
.0193b5	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.0193b8	38		sec				sec 								; this flag tells us to keep the fractional part
.0193b9	30 0f		bmi $0193ca			bmi 	FPGetPart
.0193bb	60		rts				rts
.0193bc					FPIntegerPart:
.0193bc	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.0193bf	18		clc				clc 								; this flag says keep the integer part.
.0193c0	30 08		bmi $0193ca			bmi 	FPGetPart 					; -ve exponents are 0..127
.0193c2	48		pha				pha
.0193c3	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.0193c5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0193c8	68		pla				pla
.0193c9	60		rts				rts
.0193ca					FPGetPart:
.0193ca	48		pha				pha
.0193cb	5a		phy				phy 								; save Y
.0193cc	08		php				php 								; save action
.0193cd	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.0193d0	70 62		bvs $019434			bvs 	_FPGP_Exit 					; then do nothing.
.0193d2	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.0193d4	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.0193d6	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.0193d8	85 1c		sta $1c				sta 	zLTemp1+2
.0193da	85 1d		sta $1d				sta 	zLTemp1+3
.0193dc	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.0193df	38		sec				sec
.0193e0	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.0193e2	f0 12		beq $0193f6			beq 	_FPGP_NoShift 				; ... if any
.0193e4	c9 20		cmp #$20			cmp 	#32
.0193e6	90 02		bcc $0193ea			bcc 	_FPGP_NotMax
.0193e8	a9 20		lda #$20			lda 	#32 						; max of 32.
.0193ea					_FPGP_NotMax:
.0193ea	a8		tay				tay 								; Y is the mask shift count.
.0193eb					_FPGP_ShiftMask:
.0193eb	46 1d		lsr $1d				lsr 	3+zLTemp1
.0193ed	66 1c		ror $1c				ror 	2+zLTemp1
.0193ef	66 1b		ror $1b				ror 	1+zLTemp1
.0193f1	66 1a		ror $1a				ror 	0+zLTemp1
.0193f3	88		dey				dey
.0193f4	d0 f5		bne $0193eb			bne 	_FPGP_ShiftMask
.0193f6					_FPGP_NoShift:
.0193f6	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.0193f8	8e 27 04	stx $0427			stx 	ExpTemp						; save X
.0193fb					_FPGP_MaskLoop:
.0193fb	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.0193fe	28		plp				plp 								; if CC we keep the top part, so we
.0193ff	08		php				php		 							; flip the mask.
.019400	b0 02		bcs $019404			bcs		_FPGP_NoFlip
.019402	49 ff		eor #$ff			eor 	#$FF
.019404					_FPGP_NoFlip:
.019404	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019407	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01940a	e8		inx				inx
.01940b	c8		iny				iny
.01940c	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01940e	d0 eb		bne $0193fb			bne 	_FPGP_MaskLoop
.019410	ae 27 04	ldx $0427			ldx 	ExpTemp						; restore X
.019413	28		plp				plp
.019414	08		php				php 								; get action flag on the stack
.019415	90 05		bcc $01941c			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019417	a9 00		lda #$00			lda 	#0
.019419	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01941c					_FPGP_NotFractional:
.01941c	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01941f	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019422	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019425	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019428	f0 05		beq $01942f			beq 	_FPGP_Zero 					; if zero, return zero
.01942a	20 01 95	jsr $019501			jsr 	FPUNormalise
.01942d	80 05		bra $019434			bra 	_FPGP_Exit 					; and exit
.01942f					_FPGP_Zero:
.01942f	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019431	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019434					_FPGP_Exit:
.019434	68		pla				pla 								; throw saved action flag.
.019435	7a		ply				ply
.019436	68		pla				pla
.019437	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019438					FPCompare:
.019438	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01943b	48		pha				pha
.01943c	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.01943f	48		pha				pha
.019440	20 a2 91	jsr $0191a2			jsr 	FPSubtract 					; calculate X1-X2
.019443	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019446	70 2c		bvs $019474			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019448	68		pla				pla
.019449	8d 27 04	sta $0427			sta 	ExpTemp						; save first exponent in temporary reg.
.01944c	68		pla				pla
.01944d	38		sec				sec
.01944e	ed 27 04	sbc $0427			sbc 	ExpTemp 					; calculate AX-BX
.019451	70 15		bvs $019468			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019453	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019454	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019456	b0 10		bcs $019468			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019458	38		sec				sec
.019459	ad 27 04	lda $0427			lda 	ExpTemp 					; get one of the exponents back.
.01945c	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01945e	b0 02		bcs $019462			bcs 	_FPCNotRange 				; keep in range.
.019460	a9 01		lda #$01			lda 	#1
.019462					_FPCNotRange:
.019462	38		sec				sec
.019463	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019466	b0 0e		bcs $019476			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019468					_FPCNotEqual:
.019468	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01946b	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01946d	f0 02		beq $019471			beq 	_FPCNE2
.01946f	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019471	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019472	80 04		bra $019478			bra 	_FPCExit
.019474					_FPCPullZero:
.019474	68		pla				pla 								; throw saved exponents
.019475	68		pla				pla
.019476					_FPCZero:
.019476	a9 00		lda #$00			lda 	#0 							; and return zero
.019478					_FPCExit:
.019478	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019479					FPUCopyX2ToX1:
.019479	48		pha				pha
.01947a	da		phx				phx
.01947b	5a		phy				phy
.01947c	a0 08		ldy #$08			ldy 	#8
.01947e	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019481	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019484	e8		inx				inx
.019485	88		dey				dey
.019486	10 f6		bpl $01947e			bpl 	_FPUC21
.019488	7a		ply				ply
.019489	fa		plx				plx
.01948a	68		pla				pla
.01948b	60		rts				rts
.01948c					FPUSetInteger:
.01948c	48		pha				pha
.01948d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019490	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019492	10 02		bpl $019496			bpl 	_FPUSIExtend
.019494	a9 ff		lda #$ff			lda 	#$FF
.019496					_FPUSIExtend:
.019496	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019499	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01949c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01949f	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.0194a1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194a4	68		pla				pla
.0194a5	60		rts				rts
.0194a6					FPUNegateInteger:
.0194a6	48		pha				pha
.0194a7	38		sec				sec
.0194a8	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.0194aa	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0194ad	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0194b0	a9 00		lda #$00			lda 	#0
.0194b2	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0194b5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0194b8	a9 00		lda #$00			lda 	#0
.0194ba	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0194bd	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0194c0	a9 00		lda #$00			lda 	#0
.0194c2	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0194c5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0194c8	68		pla				pla
.0194c9	60		rts				rts
.0194ca					FPUToFloat:
.0194ca	48		pha				pha
.0194cb	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.0194ce	29 0f		and #$0f			and 	#$0F
.0194d0	f0 2d		beq $0194ff			beq 	_FPUFExit
.0194d2	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.0194d4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194d7	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.0194d9	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.0194dc	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.0194df	10 08		bpl $0194e9			bpl		_FPUFPositive
.0194e1	20 a6 94	jsr $0194a6			jsr 	FPUNegateInteger 			; negate the mantissa
.0194e4	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.0194e6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194e9					_FPUFPositive:
.0194e9	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.0194ec	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0194ef	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0194f2	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0194f5	d0 05		bne $0194fc			bne 	_FPUFNonZero
.0194f7	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.0194f9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0194fc					_FPUFNonZero:
.0194fc	20 01 95	jsr $019501			jsr 	FPUNormalise 				; normalise the floating point.
.0194ff					_FPUFExit:
.0194ff	68		pla				pla
.019500	60		rts				rts
.019501					FPUNormalise:
.019501	48		pha				pha
.019502	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019505	70 20		bvs $019527			bvs 	_FPUNExit
.019507	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01950a	f0 16		beq $019522			beq 	_FPUNSetZero
.01950c					_FPUNLoop:
.01950c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01950f	30 16		bmi $019527			bmi 	_FPUNExit 					; if so, we are normalised.
.019511	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019514	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019517	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.01951a	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.01951d	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019520	d0 ea		bne $01950c			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019522					_FPUNSetZero:
.019522	a9 40		lda #$40			lda 	#$40
.019524	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019527					_FPUNExit:
.019527	68		pla				pla
.019528	60		rts				rts
.019529					FPUToInteger:
.019529	48		pha				pha
.01952a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.01952d	29 01		and #$01			and 	#1
.01952f	d0 3e		bne $01956f			bne 	_FPUTOI_Exit
.019531	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019534	70 2b		bvs $019561			bvs 	_FPUTOI_Zero
.019536	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019539	10 26		bpl $019561			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01953b	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01953d	b0 37		bcs $019576			bcs 	FP_Overflow
.01953f					_FPUToIToInteger:
.01953f	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019542	c9 a0		cmp #$a0			cmp 	#128+32
.019544	f0 11		beq $019557			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019546	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019549	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.01954c	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01954f	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019552	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019555	80 e8		bra $01953f			bra 	_FPUToIToInteger 			; keep going.
.019557					_FPUToICheckSign:
.019557	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.01955a	10 13		bpl $01956f			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01955c	20 a6 94	jsr $0194a6			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01955f	80 0e		bra $01956f			bra 	_FPUTOI_Exit
.019561					_FPUTOI_Zero:
.019561	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019563	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019566	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019569	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01956c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01956f					_FPUToI_Exit:
.01956f	a9 01		lda #$01			lda 	#1 							; set type to integer
.019571	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019574	68		pla				pla
.019575	60		rts				rts
.019576					FP_Overflow:
.019576	20 26 82	jsr $018226			jsr ERR_Handler
>019579	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019581	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019591					FPUTimes10:
.019591	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019594	85 1a		sta $1a				sta 	ZLTemp1+0
.019596	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019599	85 1b		sta $1b				sta 	ZLTemp1+1
.01959b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01959e	85 1c		sta $1c				sta 	ZLTemp1+2
.0195a0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0195a3	85 1d		sta $1d				sta 	ZLTemp1+3
.0195a5	20 e9 95	jsr $0195e9			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.0195a8	20 e9 95	jsr $0195e9			jsr 	_FPUT_LSR_ZLTemp1
.0195ab	18		clc				clc
.0195ac	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.0195af	65 1a		adc $1a				adc 	ZLTemp1+0
.0195b1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0195b4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0195b7	65 1b		adc $1b				adc 	ZLTemp1+1
.0195b9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0195bc	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0195bf	65 1c		adc $1c				adc 	ZLTemp1+2
.0195c1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0195c4	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0195c7	65 1d		adc $1d				adc 	ZLTemp1+3
.0195c9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0195cc	90 0f		bcc $0195dd			bcc 	_FPUTimes10
.0195ce	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.0195d1	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0195d4	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0195d7	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0195da	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.0195dd					_FPUTimes10:
.0195dd	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.0195e0	18		clc				clc
.0195e1	69 03		adc #$03			adc 	#3
.0195e3	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0195e6	b0 8e		bcs $019576			bcs 	FP_Overflow 				; error
.0195e8	60		rts				rts
.0195e9					_FPUT_LSR_ZLTemp1:
.0195e9	46 1d		lsr $1d				lsr 	ZLTemp1+3
.0195eb	66 1c		ror $1c				ror 	ZLTemp1+2
.0195ed	66 1b		ror $1b				ror 	ZLTemp1+1
.0195ef	66 1a		ror $1a				ror 	ZLTemp1+0
.0195f1	60		rts				rts
.0195f2					FPUScale10A:
.0195f2	5a		phy				phy
.0195f3	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.0195f5	f0 3d		beq $019634			beq 	_FPUScaleExit
.0195f7	da		phx				phx 								; save X
.0195f8	e8		inx				inx
.0195f9	e8		inx				inx
.0195fa	e8		inx				inx
.0195fb	e8		inx				inx
.0195fc	e8		inx				inx
.0195fd	e8		inx				inx
.0195fe	a8		tay				tay 								; save power scalar in Y.
.0195ff	a9 00		lda #$00			lda 	#0
.019601	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019604	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019607	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01960a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01960d	a9 80		lda #$80			lda 	#$80
.01960f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019612	a9 81		lda #$81			lda 	#$81
.019614	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019617	5a		phy				phy 								; save 10^n on stack.
.019618	c0 00		cpy #$00			cpy 	#0
.01961a	10 05		bpl $019621			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01961c	98		tya				tya
.01961d	49 ff		eor #$ff			eor 	#$FF
.01961f	1a		inc a				inc 	a
.019620	a8		tay				tay
.019621					_FPUSAbs:
.019621	20 91 95	jsr $019591			jsr 	FPUTimes10
.019624	88		dey				dey
.019625	d0 fa		bne $019621			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019627	68		pla				pla 								; restore count in A
.019628	fa		plx				plx 								; restore X pointing to number to scale.
.019629	0a		asl a				asl 	a
.01962a	b0 05		bcs $019631			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01962c	20 18 93	jsr $019318			jsr 	FPMultiply 					; if clear multiply.
.01962f	80 03		bra $019634			bra		_FPUScaleExit
.019631					_FPUSDivide:
.019631	20 90 92	jsr $019290			jsr 	FPDivide
.019634					_FPUScaleExit:
.019634	7a		ply				ply
.019635	60		rts				rts
.019636					FPUCopyToNext:
.019636	a0 06		ldy #$06			ldy 		#6
.019638	da		phx				phx
.019639					_FPUCopy1:
.019639	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.01963c	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.01963f	e8		inx				inx
.019640	88		dey				dey
.019641	d0 f6		bne $019639			bne 	_FPUCopy1
.019643	fa		plx				plx
.019644	60		rts				rts
.019645					FPUCopyFromNext:
.019645	a0 06		ldy #$06			ldy 		#6
.019647	da		phx				phx
.019648					_FPUCopy1:
.019648	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.01964b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01964e	e8		inx				inx
.01964f	88		dey				dey
.019650	d0 f6		bne $019648			bne 	_FPUCopy1
.019652	fa		plx				plx
.019653	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019654					FPToString:
.019654	48		pha				pha
.019655	5a		phy				phy
.019656	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019659	50 0a		bvc $019665			bvc 		_FPTSIsFloat 			; if zero,
.01965b					_FPTSZero:
.01965b	a9 30		lda #$30			lda 		#"0"
.01965d	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter
.019660					_FPTSExit:
.019660	7a		ply				ply
.019661	68		pla				pla
.019662	60		rts				rts
.019663	80 fb		bra $019660			bra 		_FPTSExit
.019665					_FPTSIsFloat:
.019665	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019668	10 0a		bpl $019674			bpl 		_FPTSNotSigned
.01966a	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01966c	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.01966f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019671	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter
.019674					_FPTSNotSigned:
.019674	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019677	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019679	b0 09		bcs $019684			bcs 		_FPTSExponent
.01967b	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01967d	90 05		bcc $019684			bcc 		_FPTSExponent 			;
.01967f					_FPTSStandard:
.01967f	20 c8 96	jsr $0196c8			jsr 		FPTOutputBody 			; output the body.
.019682	80 dc		bra $019660			bra 		_FPTSExit
.019684					_FPTSExponent:
.019684	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019686	8d 28 04	sta $0428			sta 		ExpCount
.019689					_FPTSExponentLoop:
.019689	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01968c	10 0e		bpl $01969c			bpl 		_FPTSTimes
.01968e	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019690	90 14		bcc $0196a6			bcc 		_FPTSScaledToExp
.019692	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019694	20 f2 95	jsr $0195f2			jsr 		FPUScale10A
.019697	ee 28 04	inc $0428			inc 		ExpCount
.01969a	80 ed		bra $019689			bra 		_FPTSExponentLoop
.01969c					_FPTSTimes:
.01969c	a9 01		lda #$01			lda 		#1
.01969e	20 f2 95	jsr $0195f2			jsr 		FPUScale10A
.0196a1	ce 28 04	dec $0428			dec 		ExpCount
.0196a4	80 e3		bra $019689			bra 		_FPTSExponentLoop
.0196a6					_FPTSScaledToExp:
.0196a6	20 c8 96	jsr $0196c8			jsr 		FPTOutputBody 			; output the body.
.0196a9	a9 65		lda #$65			lda 		#"e"					; output E
.0196ab	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter
.0196ae	ad 28 04	lda $0428			lda 		ExpCount 				; get the exponent
.0196b1	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.0196b4	29 80		and #$80			and 		#$80 					; sign extend it
.0196b6	f0 02		beq $0196ba			beq 		_FPTSSExt
.0196b8	a9 ff		lda #$ff			lda 		#$FF
.0196ba					_FPTSSExt:
.0196ba	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.0196bd	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.0196c0	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.0196c3	20 40 90	jsr $019040			jsr 		INTToString 			; output the exponent.
.0196c6	80 98		bra $019660			bra			_FPTSExit 				; and exit.
.0196c8					FPTOutputBody:
.0196c8	20 36 96	jsr $019636			jsr 		FPUCopyToNext 			; copy to next slot.
.0196cb	20 29 95	jsr $019529			jsr 		FPUToInteger 			; convert to an integer
.0196ce	20 40 90	jsr $019040			jsr 		INTToString 			; output the main integer part.
.0196d1	20 45 96	jsr $019645			jsr 		FPUCopyFromNext 		; get the fractional part back.
.0196d4	20 b5 93	jsr $0193b5			jsr 		FPFractionalPart 		; get the decimal part.
.0196d7	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.0196da	70 3e		bvs $01971a			bvs 		_FPTOExit 				; if not, exit now.
.0196dc	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.0196de	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter
.0196e1					_FPOutLoop:
.0196e1	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.0196e4	70 1e		bvs $019704			bvs 		_FPStripZeros 			; strip trailing zeros
.0196e6	20 91 95	jsr $019591			jsr 		FPUTimes10 				; multiply by 10
.0196e9	20 36 96	jsr $019636			jsr 		FPUCopyToNext			; copy to next slot.
.0196ec	20 29 95	jsr $019529			jsr 		FPUToInteger 			; convert to integer
.0196ef	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.0196f2	09 30		ora #$30			ora 		#"0"
.0196f4	20 e4 90	jsr $0190e4			jsr 		ITSOutputCharacter
.0196f7	20 45 96	jsr $019645			jsr 		FPUCopyFromNext 		; get it back
.0196fa	20 b5 93	jsr $0193b5			jsr 		FPFractionalPart 		; get fractional part
.0196fd	ad 00 04	lda $0400			lda 		NumBufX 				; done 11 characters yet ?
.019700	c9 0b		cmp #$0b			cmp 	 	#11
.019702	90 dd		bcc $0196e1			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019704					_FPStripZeros:
.019704	ac 00 04	ldy $0400			ldy 		NumBufX 				; strip trailing zeros.
.019707					_FPStripLoop:
.019707	88		dey				dey 								; back one, if at start then no strip
.019708	f0 10		beq $01971a			beq 		_FPToExit
.01970a	b9 01 04	lda $0401,y			lda 		Num_Buffer,y 			; keep going if "0"
.01970d	c9 30		cmp #$30			cmp 		#"0"
.01970f	f0 f6		beq $019707			beq 		_FPStripLoop
.019711	c8		iny				iny
.019712	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019714	99 01 04	sta $0401,y			sta 		Num_Buffer,y
.019717	8c 00 04	sty $0400			sty 		NumBufX 				; update position.
.01971a					_FPTOExit:
.01971a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01971b					FPFromString:
.01971b	48		pha				pha 								; push A
.01971c	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01971e	c9 2e		cmp #$2e			cmp 	#"."
.019720	f0 03		beq $019725			beq	 	_FPFIsDecimal
.019722	4c 88 97	jmp $019788			jmp 	_FPFNotDecimal
.019725					_FPFIsDecimal:
.019725	c8		iny				iny 								; consume the decimal.
.019726	20 ca 94	jsr $0194ca			jsr 	FPUToFloat 					; convert the integer to float.
.019729	da		phx				phx 								; save X.
.01972a	5a		phy				phy 								; save decimal start position
.01972b	e8		inx				inx
.01972c	e8		inx				inx
.01972d	e8		inx				inx
.01972e	e8		inx				inx
.01972f	e8		inx				inx
.019730	e8		inx				inx
.019731	20 fc 90	jsr $0190fc			jsr 	INTFromStringY 				; get the part after the DP.
.019734	20 ca 94	jsr $0194ca			jsr 	FPUToFloat 					; convert that to a float.
.019737	68		pla				pla 								; calculate - chars consumed.
.019738	8c 27 04	sty $0427			sty 	ExpTemp
.01973b	38		sec				sec
.01973c	ed 27 04	sbc $0427			sbc 	ExpTemp 					; this is the shift amount
.01973f	20 f2 95	jsr $0195f2			jsr 	FPUScale10A 				; scale it by 10^AC
.019742	fa		plx				plx 								; restore original X
.019743	20 ac 91	jsr $0191ac			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019746	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019748	c9 45		cmp #$45			cmp 	#"E"
.01974a	f0 04		beq $019750			beq 	_FPFExponent
.01974c	c9 65		cmp #$65			cmp 	#"e"
.01974e	d0 38		bne $019788			bne 	_FPFNotDecimal 				; no, then exit normally.
.019750					_FPFExponent:
.019750	c8		iny				iny 								; skip over E symbol.
.019751	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019753	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019755	d0 01		bne $019758			bne 	_FPFGotSign
.019757	c8		iny				iny 								; if it was - skip over it.
.019758					_FPFGotSign:
.019758	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019759	da		phx				phx
.01975a	e8		inx				inx
.01975b	e8		inx				inx
.01975c	e8		inx				inx
.01975d	e8		inx				inx
.01975e	e8		inx				inx
.01975f	e8		inx				inx
.019760	20 fc 90	jsr $0190fc			jsr 	INTFromStringY 				; get the exponent
.019763	fa		plx				plx 								; restore X.
.019764	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019767	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.01976a	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.01976d	d0 1b		bne $01978a			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01976f	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019772	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019774	b0 14		bcs $01978a			bcs 	_FPFXOverflow
.019776	68		pla				pla 								; get direction
.019777	d0 09		bne $019782			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019779	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01977c	49 ff		eor #$ff			eor 	#$FF
.01977e	1a		inc a				inc 	a
.01977f	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019782					_FPFXScale:
.019782	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019785	20 f2 95	jsr $0195f2			jsr 	FPUScale10A 				; scale by the exponent.
.019788					_FPFNotDecimal:
.019788	68		pla				pla
.019789	60		rts				rts
.01978a					_FPFXOverflow:
.01978a	20 26 82	jsr $018226			jsr 	ERR_Handler
>01978d	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019795	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01979c					Unary_Rnd:
.01979c	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.01979f	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.0197a2	20 7b 8a	jsr $018a7b			jsr 	GetSignCurrent 				; get sign -1,0,1.
.0197a5	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.0197a7	30 10		bmi $0197b9			bmi 	_URSetSeed
.0197a9	f0 2c		beq $0197d7			beq 	_URMakeRandom 				; if zero return same number.
.0197ab	da		phx				phx
.0197ac	a2 00		ldx #$00			ldx 	#0
.0197ae	20 14 98	jsr $019814			jsr 	Random16
.0197b1	a2 02		ldx #$02			ldx 	#2
.0197b3	20 14 98	jsr $019814			jsr 	Random16
.0197b6	fa		plx				plx
.0197b7	80 1e		bra $0197d7			bra 	_URMakeRandom
.0197b9					_URSetSeed:
.0197b9	20 ca 94	jsr $0194ca			jsr 	FPUToFloat 					; make it a float to twiddle it.
.0197bc	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.0197bf	8d 30 04	sta $0430			sta 	RandomSeed+0
.0197c2	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0197c5	8d 31 04	sta $0431			sta 	RandomSeed+1
.0197c8	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.0197cb	8d 32 04	sta $0432			sta 	RandomSeed+2
.0197ce	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.0197d1	0a		asl a				asl 	a
.0197d2	49 db		eor #$db			eor 	#$DB
.0197d4	8d 33 04	sta $0433			sta 	RandomSeed+3
.0197d7					_URMakeRandom:
.0197d7	ad 30 04	lda $0430			lda 	RandomSeed+0 				; check if seed is zero.
.0197da	0d 31 04	ora $0431			ora 	RandomSeed+1
.0197dd	0d 32 04	ora $0432			ora 	RandomSeed+2
.0197e0	0d 33 04	ora $0433			ora 	RandomSeed+3
.0197e3	d0 0a		bne $0197ef			bne 	_URNotZero
.0197e5	a9 47		lda #$47			lda 	#$47
.0197e7	8d 31 04	sta $0431			sta 	RandomSeed+1				; if it is, make it non zero.
.0197ea	a9 3d		lda #$3d			lda 	#$3D
.0197ec	8d 33 04	sta $0433			sta 	RandomSeed+3
.0197ef					_URNotZero:
.0197ef	ad 30 04	lda $0430			lda 	RandomSeed+0 				; copy seed into mantissa.
.0197f2	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197f5	ad 31 04	lda $0431			lda 	RandomSeed+1
.0197f8	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0197fb	ad 32 04	lda $0432			lda 	RandomSeed+2
.0197fe	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019801	ad 33 04	lda $0433			lda 	RandomSeed+3
.019804	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019807	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019809	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01980c	a9 80		lda #$80			lda 	#$80
.01980e	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019811	4c 01 95	jmp $019501			jmp 	FPUNormalise
.019814					Random16:
.019814	5e 31 04	lsr $0431,x			lsr 	RandomSeed+1,x				; shift seed right
.019817	7e 30 04	ror $0430,x			ror 	RandomSeed,x
.01981a	90 08		bcc $019824			bcc 	_R16_NoXor
.01981c	bd 31 04	lda $0431,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01981f	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019821	9d 31 04	sta $0431,x			sta 	RandomSeed+1,x
.019824					_R16_NoXor:
.019824	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019825					Unary_Int:
.019825	20 8e 87	jsr $01878e			jsr 	EvaluateNumberX 			; get value
.019828	20 1d 8e	jsr $018e1d			jsr 	CheckNextRParen 			; check right bracket.
.01982b	4c 29 95	jmp $019529			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.01982e					TIM_Error:
.01982e	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.019831	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.019833	80 02		bra $019837			bra 	TIM_ShowPrompt
.019835					TIM_NewCommand:
.019835	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.019837					TIM_ShowPrompt:
.019837	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.01983a	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.01983d	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.019840	86 10		stx $10				stx 	zTemp1 						; save line read address
.019842	84 11		sty $11				sty 	zTemp1+1
.019844	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.019846	b1 10		lda ($10),y			lda 	(zTemp1),y
.019848	c9 3f		cmp #$3f			cmp 	#"?"
.01984a	f0 04		beq $019850			beq 	TIM_SkipFirst
.01984c	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01984e	d0 01		bne $019851			bne 	TIM_NotDot
.019850					TIM_SkipFirst:
.019850	c8		iny				iny
.019851					TIM_NotDot:
.019851	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.019853	c9 52		cmp #$52			cmp 	#"R"						; show registers
.019855	f0 6b		beq $0198c2			beq 	TIM_ShowRegisters
.019857	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.019859	f0 12		beq $01986d			beq 	TIM_ShowMemory
.01985b	c9 47		cmp #$47			cmp 	#"G"						; execute
.01985d	f0 49		beq $0198a8			beq 	TIM_Execute
.01985f	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.019861	f0 07		beq $01986a			beq 	TIM_GoLoadMemory
.019863	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.019865	d0 c7		bne $01982e			bne 	TIM_Error
.019867	4c e6 99	jmp $0199e6			jmp 	TIM_UpdateRegisters
.01986a					TIM_GoLoadMemory:
.01986a	4c 16 9a	jmp $019a16			jmp 	TIM_LoadMemory
.01986d					TIM_ShowMemory:
.01986d	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.019870	b0 bc		bcs $01982e			bcs 	TIM_Error
.019872	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.019874	85 12		sta $12				sta 	zTemp2
.019876	a5 15		lda $15				lda 	zTemp3+1
.019878	85 13		sta $13				sta 	zTemp2+1
.01987a	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01987d	90 08		bcc $019887			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01987f	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.019881	85 14		sta $14				sta 	zTemp3
.019883	a5 13		lda $13				lda 	zTemp2+1
.019885	85 15		sta $15				sta 	zTemp3+1
.019887					_TIMSM_Start:
.019887	20 3a 99	jsr $01993a			jsr 	TIM_WriteLine 				; write one line of hex out
.01988a	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.01988c	18		clc				clc
.01988d	69 10		adc #$10			adc 	#16
.01988f	85 12		sta $12				sta 	zTemp2
.019891	90 02		bcc $019895			bcc 	_TIMSM_NoCarry
.019893	e6 13		inc $13				inc 	zTemp2+1
.019895					_TIMSM_NoCarry:
.019895	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.019898	d0 0b		bne $0198a5			bne 	_TIMSM_Ends 				; if pressed break out.
.01989a	38		sec				sec 								; check past the end address in zTemp3
.01989b	a5 14		lda $14				lda 	zTemp3
.01989d	e5 12		sbc $12				sbc 	zTemp2
.01989f	a5 15		lda $15				lda 	zTemp3+1
.0198a1	e5 13		sbc $13				sbc 	zTemp2+1
.0198a3	10 e2		bpl $019887			bpl 	_TIMSM_Start
.0198a5					_TIMSM_Ends:
.0198a5	4c 35 98	jmp $019835			jmp 	TIM_NewCommand
.0198a8					TIM_Execute:
.0198a8	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; get the execute address
.0198ab	b0 81		bcs $01982e			bcs 	TIM_Error 					; not legitimate
.0198ad	ae 3d 04	ldx $043d			ldx 	TIM_SP 						; set up SP
.0198b0	9a		txs				txs
.0198b1	ad 38 04	lda $0438			lda 	TIM_SR 						; Status for PLP
.0198b4	48		pha				pha
.0198b5	ad 39 04	lda $0439			lda 	TIM_A 						; restore AXYZ
.0198b8	ae 3a 04	ldx $043a			ldx 	TIM_X
.0198bb	ac 3b 04	ldy $043b			ldy 	TIM_Y
.0198be	28		plp				plp 								; and PS Byte.
.0198bf	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.0198c2					TIM_Start:
.0198c2					TIM_ShowRegisters:
.0198c2	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.0198c5	8d 37 04	sta $0437			sta 	TIM_IRQ+1
.0198c8	ad ff ff	lda $ffff			lda 	$FFFF
.0198cb	8d 36 04	sta $0436			sta 	TIM_IRQ
.0198ce	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.0198d0					_TIMSR_Text:
.0198d0	bf 01 99 01	lda $019901,x			lda 	_TIMSR_Label,x
.0198d4	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0198d7	e8		inx				inx
.0198d8	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0198da	d0 f4		bne $0198d0			bne 	_TIMSR_Text
.0198dc	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0198de					_TIMSR_Skip:
.0198de	e8		inx				inx
.0198df					_TIMSR_LoopSpace:
.0198df	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0198e1	b0 04		bcs $0198e7			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0198e3	8a		txa				txa
.0198e4	4a		lsr a				lsr 	a
.0198e5	b0 05		bcs $0198ec			bcs 	_TIMSR_NoSpace
.0198e7					_TIMSR_Space:
.0198e7	a9 20		lda #$20			lda 	#" "
.0198e9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0198ec					_TIMSR_NoSpace:
.0198ec	bd 34 04	lda $0434,x			lda 	TIM_PC,x 					; output hex value.
.0198ef	20 21 99	jsr $019921			jsr 	TIM_WriteHex
.0198f2	e8		inx				inx
.0198f3	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0198f5	f0 e7		beq $0198de			beq 	_TIMSR_Skip
.0198f7	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0198f9	d0 e4		bne $0198df			bne 	_TimSR_LoopSpace
.0198fb	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0198fe	4c 35 98	jmp $019835			jmp	 	TIM_NewCommand 				; new command.
.019901					_TIMSR_Label:
>019901	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>019909	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>019919	52
>01991a	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.019921					_TIMSR_LabelEnd:
.019921					TIM_WriteHex:
.019921	48		pha				pha 								; save A
.019922	4a		lsr a				lsr 	a 							; shift MSB->LSB
.019923	4a		lsr a				lsr 	a
.019924	4a		lsr a				lsr 	a
.019925	4a		lsr a				lsr 	a
.019926	20 2a 99	jsr $01992a			jsr 	_TIMWH_Nibble 				; print MSB
.019929	68		pla				pla 								; restore and print LSB
.01992a					_TIMWH_Nibble:
.01992a	48		pha				pha
.01992b	29 0f		and #$0f			and 	#15 						; mask out
.01992d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01992f	90 02		bcc $019933			bcc 	_TIMWHNoLetter
.019931	69 06		adc #$06			adc 	#6
.019933					_TIMWHNoLetter:
.019933	69 30		adc #$30			adc 	#48
.019935	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.019938	68		pla				pla
.019939	60		rts				rts
.01993a					TIM_WriteLine:
.01993a	a9 2e		lda #$2e			lda 	#"." 						; prompt
.01993c	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01993f	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.019941	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019944	a5 13		lda $13				lda 	zTemp2+1 					; write address
.019946	20 21 99	jsr $019921			jsr 	TIM_WriteHex
.019949	a5 12		lda $12				lda 	zTemp2
.01994b	20 21 99	jsr $019921			jsr 	TIM_WriteHex
.01994e	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.019950					_TIMWL_Loop:
.019950	a9 20		lda #$20			lda 	#" "
.019952	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.019955	b1 12		lda ($12),y			lda 	(zTemp2),y
.019957	20 21 99	jsr $019921			jsr 	TIM_WriteHex
.01995a	c8		iny				iny
.01995b	c0 10		cpy #$10			cpy 	#16
.01995d	d0 f1		bne $019950			bne 	_TIMWL_Loop
.01995f	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.019962					TIM_GetHex:
.019962	c8		iny				iny
.019963	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.019965	c9 20		cmp #$20			cmp 	#32
.019967	f0 f9		beq $019962			beq 	TIM_GetHex
.019969	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.01996b	f0 f5		beq $019962			beq 	TIM_GetHex
.01996d	20 96 99	jsr $019996			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.019970	b0 23		bcs $019995			bcs 	_TIMGH_Exit					; if first bad then exit now.
.019972	a9 00		lda #$00			lda 	#0 							; zero result
.019974	85 14		sta $14				sta 	zTemp3
.019976	85 15		sta $15				sta 	zTemp3+1
.019978					_TIM_GHLoop:
.019978	20 96 99	jsr $019996			jsr 	TIM_GetHexCharacter 		; get next character
.01997b	b0 17		bcs $019994			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.01997d	c8		iny				iny 								; skip over it.
.01997e	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.019980	26 15		rol $15				rol 	zTemp3+1
.019982	06 14		asl $14				asl 	zTemp3 						; now x 2
.019984	26 15		rol $15				rol 	zTemp3+1
.019986	06 14		asl $14				asl 	zTemp3						; now x 4
.019988	26 15		rol $15				rol 	zTemp3+1
.01998a	06 14		asl $14				asl 	zTemp3 						; now x 8
.01998c	26 15		rol $15				rol 	zTemp3+1
.01998e	05 14		ora $14				ora 	zTemp3 						; OR result in
.019990	85 14		sta $14				sta 	zTemp3
.019992	80 e4		bra $019978			bra 	_TIM_GHLoop 				; loop round again.
.019994					_TIMGH_Okay:
.019994	18		clc				clc
.019995					_TIMGH_Exit:
.019995	60		rts				rts
.019996					TIM_GetHexCharacter:
.019996	b1 10		lda ($10),y			lda 	(zTemp1),y
.019998	38		sec				sec
.019999	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.01999b	90 0e		bcc $0199ab			bcc 	_TIM_GHCFail
.01999d	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01999f	90 0b		bcc $0199ac			bcc 	_TIM_GHCExit
.0199a1	c9 11		cmp #$11			cmp 	#65-48						; < A
.0199a3	90 06		bcc $0199ab			bcc		_TIM_GHCFail
.0199a5	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.0199a7	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.0199a9	90 01		bcc $0199ac			bcc		_TIM_GHCExit
.0199ab					_TIM_GHCFail:
.0199ab	38		sec				sec
.0199ac					_TIM_GHCExit:
.0199ac	60		rts				rts
.0199ad					TIM_BreakVector:
.0199ad	da		phx				phx									; save X/A on stack
.0199ae	48		pha				pha
.0199af	ba		tsx				tsx 								; X points to S
.0199b0	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.0199b3	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.0199b5	d0 03		bne $0199ba			bne 	_TIMBreak					; if set, it's BRK
.0199b7	68		pla				pla 								; abandon routine.
.0199b8	fa		plx				plx
.0199b9	40		rti				rti
.0199ba					_TIMBreak:
.0199ba	68		pla				pla 								; save A X Y and maybe Z
.0199bb	8d 39 04	sta $0439			sta 	TIM_A
.0199be	fa		plx				plx
.0199bf	8e 3a 04	stx $043a			stx 	TIM_X
.0199c2	8c 3b 04	sty $043b			sty 	TIM_Y
.0199c5	68		pla				pla 								; get Status Register
.0199c6	8d 38 04	sta $0438			sta 	TIM_SR
.0199c9	68		pla				pla
.0199ca	8d 35 04	sta $0435			sta 	TIM_PC+1 					; save calling address
.0199cd	68		pla				pla
.0199ce	8d 34 04	sta $0434			sta 	TIM_PC 						; high byte
.0199d1	ad 35 04	lda $0435			lda 	TIM_PC+1 					; dec PC to point right.
.0199d4	d0 03		bne $0199d9			bne 	_TIMDecrement 				; brk bumps it.
.0199d6	ce 34 04	dec $0434			dec 	TIM_PC
.0199d9					_TIMDecrement:
.0199d9	ce 35 04	dec $0435			dec 	TIM_PC+1
.0199dc	ba		tsx				tsx 								; and copy SP
.0199dd	8e 3d 04	stx $043d			stx 	TIM_SP
.0199e0	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0199e2	9a		txs				txs
.0199e3	4c c2 98	jmp $0198c2			jmp 	TIM_Start 					; and start up TIM monitor.
.0199e6					TIM_UpdateRegisters:
.0199e6	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; PC
.0199e9	b0 28		bcs $019a13			bcs 	_TIMURFail
.0199eb	a5 14		lda $14				lda 	zTemp3
.0199ed	8d 35 04	sta $0435			sta 	Tim_PC+1
.0199f0	a5 15		lda $15				lda 	zTemp3+1
.0199f2	8d 34 04	sta $0434			sta 	Tim_PC
.0199f5	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; ignore IRQ
.0199f8	b0 19		bcs $019a13			bcs 	_TIMURFail
.0199fa	a2 00		ldx #$00			ldx 	#0
.0199fc					_TIM_URLoop:
.0199fc	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0199fe	d0 01		bne $019a01			bne 	_TIM_1
.019a00	e8		inx				inx
.019a01					_TIM_1:
.019a01	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; registers
.019a04	b0 0d		bcs $019a13			bcs 	_TIMURFail
.019a06	a5 14		lda $14				lda 	zTemp3
.019a08	9d 38 04	sta $0438,x			sta 	Tim_SR,x
.019a0b	e8		inx				inx
.019a0c	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.019a0e	d0 ec		bne $0199fc			bne 	_TIM_URLoop
.019a10	4c 35 98	jmp $019835			jmp 	TIM_NewCommand
.019a13					_TIMURFail:
.019a13	4c 2e 98	jmp $01982e			jmp 	TIM_Error
.019a16					TIM_LoadMemory:
.019a16	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; target address => zTemp2
.019a19	a5 14		lda $14				lda 	zTemp3
.019a1b	85 12		sta $12				sta 	zTemp2
.019a1d	a5 15		lda $15				lda 	zTemp3+1
.019a1f	85 13		sta $13				sta 	zTemp2+1
.019a21					_TIM_LMLoop:
.019a21	20 62 99	jsr $019962			jsr 	TIM_GetHex 					; next byte ?
.019a24	b0 0e		bcs $019a34			bcs 	_TIMLMDone 					; no more
.019a26	a2 00		ldx #$00			ldx 	#0							; write out.
.019a28	a5 14		lda $14				lda 	zTemp3
.019a2a	81 12		sta ($12,x)			sta 	(zTemp2,x)
.019a2c	e6 12		inc $12				inc 	zTemp2 						; bump address
.019a2e	d0 f1		bne $019a21			bne 	_TIM_LMLoop
.019a30	e6 13		inc $13				inc 	zTemp2+1
.019a32	80 ed		bra $019a21			bra 	_TIM_LMLoop
.019a34					_TIMLMDone:
.019a34	4c 35 98	jmp $019835			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019a37	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
