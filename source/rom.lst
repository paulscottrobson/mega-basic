
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 22 21:09:18 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					ValSign: 	.byte ? 						; sign flag for val()
>0429					RandomSeed:	.dword ? 						; Random seed.
>042d					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042f					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>0431					Tim_SR:		.byte ? 						; Processor Status
>0432					Tim_A:		.byte ? 						; Processor Registers
>0433					Tim_X:		.byte ?
>0434					Tim_Y:		.byte ?
>0435					Tim_Z:		.byte ?
>0436					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	18 0a 00 d9 af fe 0a 46			.byte	$18,$0a,$00,$d9,$af,$fe,$0a,$46
>1008	46 46 46 46 46 46 45 bc			.byte	$46,$46,$46,$46,$46,$46,$45,$bc
>1010	be ff 06 68 69 20 21 00			.byte	$be,$ff,$06,$68,$69,$20,$21,$00
>1018	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.c000					VectorTable:
>c000	dc c5					.word BinaryOp_And         ; $80 and
>c002	04 c6					.word BinaryOp_Or          ; $81 or
>c004	2c c6					.word BinaryOp_Xor         ; $82 xor
>c006	2c c6					.word BinaryOp_Eor         ; $83 eor
>c008	6f c6					.word Binary_Equal         ; $84 =
>c00a	8e c6					.word Binary_NotEqual      ; $85 <>
>c00c	97 c6					.word Binary_Less          ; $86 <
>c00e	a0 c6					.word Binary_LessEqual     ; $87 <=
>c010	b2 c6					.word Binary_Greater       ; $88 >
>c012	a9 c6					.word Binary_GreaterEqual  ; $89 >=
>c014	47 c7					.word BinaryOp_Add         ; $8a +
>c016	67 c7					.word BinaryOp_Subtract    ; $8b -
>c018	7a c7					.word BinaryOp_Multiply    ; $8c *
>c01a	8d c7					.word BinaryOp_Divide      ; $8d /
>c01c	b2 c0					.word NotImplemented       ; $8e ^
>c01e	b2 c0					.word NotImplemented       ; $8f if
>c020	b2 c0					.word NotImplemented       ; $90 while
>c022	b2 c0					.word NotImplemented       ; $91 repeat
>c024	b2 c0					.word NotImplemented       ; $92 for
>c026	b2 c0					.word NotImplemented       ; $93 then
>c028	b2 c0					.word NotImplemented       ; $94 endif
>c02a	b2 c0					.word NotImplemented       ; $95 wend
>c02c	b2 c0					.word NotImplemented       ; $96 until
>c02e	b2 c0					.word NotImplemented       ; $97 next
>c030	b2 c0					.word NotImplemented       ; $98 not
>c032	b2 c0					.word NotImplemented       ; $99 fn(
>c034	af c8					.word Unary_Abs            ; $9a abs(
>c036	6d c9					.word Unary_Asc            ; $9b asc(
>c038	d7 d3					.word Unary_Int            ; $9c int(
>c03a	b2 c0					.word NotImplemented       ; $9d peek(
>c03c	4e d3					.word Unary_Rnd            ; $9e rnd(
>c03e	b2 c0					.word NotImplemented       ; $9f usr(
>c040	b2 c0					.word NotImplemented       ; $a0 left$(
>c042	b2 c0					.word NotImplemented       ; $a1 right$(
>c044	b2 c0					.word NotImplemented       ; $a2 mid$(
>c046	6c ca					.word Unary_Spc            ; $a3 spc(
>c048	3a c9					.word Unary_Str            ; $a4 str$(
>c04a	cd c8					.word Unary_Val            ; $a5 val(
>c04c	83 c9					.word Unary_Len            ; $a6 len(
>c04e	92 c9					.word Unary_Hex            ; $a7 hex$(
>c050	b2 c0					.word NotImplemented       ; $a8 sin(
>c052	b2 c0					.word NotImplemented       ; $a9 cos(
>c054	b2 c0					.word NotImplemented       ; $aa tan(
>c056	b2 c0					.word NotImplemented       ; $ab atn(
>c058	b2 c0					.word NotImplemented       ; $ac exp(
>c05a	b2 c0					.word NotImplemented       ; $ad log(
>c05c	b2 c0					.word NotImplemented       ; $ae sqr(
>c05e	ef c9					.word Unary_Dec            ; $af dec(
>c060	b2 c0					.word NotImplemented       ; $b0 deek(
>c062	b2 c0					.word NotImplemented       ; $b1 leek(
>c064	b2 c0					.word NotImplemented       ; $b2 mod(
>c066	5d c8					.word Unary_Sgn            ; $b3 sgn(
>c068	48 ca					.word Unary_Chr            ; $b4 chr$(
>c06a	b2 c0					.word NotImplemented       ; $b5 $(
>c06c	b2 c0					.word NotImplemented       ; $b6 $
>c06e	b2 c0					.word NotImplemented       ; $b7 #(
>c070	b2 c0					.word NotImplemented       ; $b8 #
>c072	b2 c0					.word NotImplemented       ; $b9 %(
>c074	b2 c0					.word NotImplemented       ; $ba %
>c076	b2 c0					.word NotImplemented       ; $bb (
>c078	b2 c0					.word NotImplemented       ; $bc )
>c07a	b2 c0					.word NotImplemented       ; $bd ,
>c07c	b2 c0					.word NotImplemented       ; $be :
>c07e	b2 c0					.word NotImplemented       ; $bf ;
>c080	b2 c0					.word NotImplemented       ; $c0 def
>c082	18 c4					.word CLR_Command          ; $c1 clr
>c084	b2 c0					.word NotImplemented       ; $c3 data
>c086	b2 c0					.word NotImplemented       ; $c4 read
>c088	b2 c0					.word NotImplemented       ; $c5 dim
>c08a	b2 c0					.word NotImplemented       ; $c6 to
>c08c	b2 c0					.word NotImplemented       ; $c7 step
>c08e	b2 c0					.word NotImplemented       ; $c8 gosub
>c090	b2 c0					.word NotImplemented       ; $c9 return
>c092	b2 c0					.word NotImplemented       ; $ca goto
>c094	b2 c0					.word NotImplemented       ; $cb input
>c096	b2 c0					.word NotImplemented       ; $cc let
>c098	b2 c0					.word NotImplemented       ; $cd list
>c09a	b2 c0					.word NotImplemented       ; $ce new
>c09c	b2 c0					.word NotImplemented       ; $cf old
>c09e	b2 c0					.word NotImplemented       ; $d0 on
>c0a0	b2 c0					.word NotImplemented       ; $d1 restore
>c0a2	b2 c0					.word NotImplemented       ; $d2 poke
>c0a4	b2 c0					.word NotImplemented       ; $d3 print
>c0a6	b2 c0					.word NotImplemented       ; $d4 run
>c0a8	b2 c0					.word NotImplemented       ; $d5 stop
>c0aa	b2 c0					.word NotImplemented       ; $d6 wait
>c0ac	b2 c0					.word NotImplemented       ; $d7 doke
>c0ae	b2 c0					.word NotImplemented       ; $d8 loke
>c0b0	b2 c0					.word NotImplemented       ; $d9 assert
.c0b2					NotImplemented:
.c0b2	80 fe		bra $c0b2		_error: bra _error
.c0b4					BinaryPrecedence:
>c0b4	01					.byte 1    ; $80 and
>c0b5	01					.byte 1    ; $81 or
>c0b6	01					.byte 1    ; $82 xor
>c0b7	01					.byte 1    ; $83 eor
>c0b8	02					.byte 2    ; $84 =
>c0b9	02					.byte 2    ; $85 <>
>c0ba	02					.byte 2    ; $86 <
>c0bb	02					.byte 2    ; $87 <=
>c0bc	02					.byte 2    ; $88 >
>c0bd	02					.byte 2    ; $89 >=
>c0be	03					.byte 3    ; $8a +
>c0bf	03					.byte 3    ; $8b -
>c0c0	04					.byte 4    ; $8c *
>c0c1	04					.byte 4    ; $8d /
>c0c2	05					.byte 5    ; $8e ^
.c0c3					KeywordText:
>c0c3	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0c6	4f d2					.byte $4f,$d2                          ; $81 or
>c0c8	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0cb	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0ce	bd					.byte $bd                              ; $84 =
>c0cf	3c be					.byte $3c,$be                          ; $85 <>
>c0d1	bc					.byte $bc                              ; $86 <
>c0d2	3c bd					.byte $3c,$bd                          ; $87 <=
>c0d4	be					.byte $be                              ; $88 >
>c0d5	3e bd					.byte $3e,$bd                          ; $89 >=
>c0d7	ab					.byte $ab                              ; $8a +
>c0d8	ad					.byte $ad                              ; $8b -
>c0d9	aa					.byte $aa                              ; $8c *
>c0da	af					.byte $af                              ; $8d /
>c0db	de					.byte $de                              ; $8e ^
>c0dc	49 c6					.byte $49,$c6                          ; $8f if
>c0de	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0e3	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0e9	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0ec	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0f0	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0f5	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c0f9	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c0fe	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c102	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c105	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c108	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c10c	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c110	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c114	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c119	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c11d	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c121	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c127	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c12e	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c133	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c137	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c13c	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c140	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c144	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c149	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c14d	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c151	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c155	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c159	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c15d	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c161	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c165	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c169	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c16e	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c173	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c177	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>c17b	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>c180	24 a8					.byte $24,$a8                          ; $b5 $(
>c182	a4					.byte $a4                              ; $b6 $
>c183	23 a8					.byte $23,$a8                          ; $b7 #(
>c185	a3					.byte $a3                              ; $b8 #
>c186	25 a8					.byte $25,$a8                          ; $b9 %(
>c188	a5					.byte $a5                              ; $ba %
>c189	a8					.byte $a8                              ; $bb (
>c18a	a9					.byte $a9                              ; $bc )
>c18b	ac					.byte $ac                              ; $bd ,
>c18c	ba					.byte $ba                              ; $be :
>c18d	bb					.byte $bb                              ; $bf ;
>c18e	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>c191	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>c194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>c198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>c19c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>c19f	54 cf					.byte $54,$cf                          ; $c6 to
>c1a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>c1a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>c1aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>c1b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>c1b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cb input
>c1b9	4c 45 d4				.byte $4c,$45,$d4                      ; $cc let
>c1bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cd list
>c1c0	4e 45 d7				.byte $4e,$45,$d7                      ; $ce new
>c1c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cf old
>c1c6	4f ce					.byte $4f,$ce                          ; $d0 on
>c1c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d1 restore
>c1cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d2 poke
>c1d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d3 print
>c1d8	52 55 ce				.byte $52,$55,$ce                      ; $d4 run
>c1db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d5 stop
>c1df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>c1e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>c1e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>c1eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>c1f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollarlparen = $b5
=$b6					token_dollar = $b6
=$b7					token_hashlparen = $b7
=$b8					token_hash = $b8
=$b9					token_percentlparen = $b9
=$ba					token_percent = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_input = $cb
=$cc					token_let = $cc
=$cd					token_list = $cd
=$ce					token_new = $ce
=$cf					token_old = $cf
=$d0					token_on = $d0
=$d1					token_restore = $d1
=$d2					token_poke = $d2
=$d3					token_print = $d3
=$d4					token_run = $d4
=$d5					token_stop = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/hardware/em65816.asm

.c1f2					StartROM:
.c1f2	18		clc				clc
.c1f3	fb		xce				xce
.c1f4	c2 30		rep #$30			rep 	#$30
.c1f6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f9	1b		tcs				tcs
.c1fa	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1fc	c2 30		rep #$30			rep 	#$30
.c1fe	a9 00 00	lda #$0000			lda 	#$0000
.c201	aa		tax				tax
.c202	a8		tay				tay
.c203	e2 30		sep #$30			sep 	#$30
.c205	20 a9 c3	jsr $c3a9			jsr 	IF_Reset 					; reset external interface
.c208	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen
.c20b	4c f8 c3	jmp $c3f8		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c20e					IFT_ClearScreen:
.c20e	48		pha				pha
.c20f	da		phx				phx
.c210	5a		phy				phy
.c211	20 aa c3	jsr $c3aa			jsr 	IF_Home 					; home cursor
.c214	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c216					_IFT_CS0:
.c216	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c218					_IFT_CS1:
.c218	a9 20		lda #$20			lda 	#' '						; clear line.
.c21a	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c21d	88		dey				dey
.c21e	d0 f8		bne $c218			bne 	_IFT_CS1
.c220	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; next line down
.c223	ca		dex				dex
.c224	d0 f0		bne $c216			bne 	_IFT_CS0
.c226	7a		ply				ply
.c227	fa		plx				plx
.c228	68		pla				pla
.c229					IFT_HomeCursor:
.c229	48		pha				pha
.c22a	20 aa c3	jsr $c3aa			jsr 	IF_Home
.c22d	a9 00		lda #$00			lda 	#0
.c22f	8d 00 02	sta $0200			sta 	IFT_XCursor
.c232	8d 01 02	sta $0201			sta 	IFT_YCursor
.c235	68		pla				pla
.c236	60		rts				rts
.c237					IFT_UpLine:
.c237	48		pha				pha
.c238	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c23b	3a		dec a				dec 	a 							; line above
.c23c	30 03		bmi $c241			bmi 	_IFTULExit 					; too far, abort
.c23e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos					; set to that line.
.c241					_IFTULExit:
.c241	68		pla				pla
.c242	60		rts				rts
.c243					IFT_PrintCharacter:
.c243	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c245	f0 16		beq $c25d			beq 	IFT_NewLine
.c247	48		pha				pha
.c248	20 75 c2	jsr $c275			jsr 	IFT_UpperCase 				; make upper case
.c24b	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write out.
.c24e	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c251	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c254	c9 40		cmp #$40			cmp 	#IF_Width
.c256	d0 03		bne $c25b			bne 	_IFT_PCNotEOL
.c258	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; if so do new line.
.c25b					_IFT_PCNotEOL:
.c25b	68		pla				pla
.c25c	60		rts				rts
.c25d					IFT_NewLine:
.c25d	48		pha				pha
.c25e	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; new line on actual screen.
.c261	a9 00		lda #$00			lda 	#0 							; reset x position
.c263	8d 00 02	sta $0200			sta 	IFT_XCursor
.c266	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c269	ad 01 02	lda $0201			lda 	IFT_YCursor
.c26c	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c26e	d0 03		bne $c273			bne 	_IFT_NL_NotEOS
.c270	20 80 c2	jsr $c280			jsr 	IFT_Scroll 					; scroll screen up.
.c273					_IFT_NL_NotEOS:
.c273	68		pla				pla
.c274	60		rts				rts
.c275					IFT_UpperCase:
.c275	c9 61		cmp #$61			cmp 	#"a"
.c277	90 06		bcc $c27f			bcc 	_IFT_UCExit
.c279	c9 7b		cmp #$7b			cmp 	#"z"+1
.c27b	b0 02		bcs $c27f			bcs 	_IFT_UCExit
.c27d	49 20		eor #$20			eor 	#$20
.c27f					_IFT_UCExit:
.c27f	60		rts				rts
.c280					IFT_Scroll:
.c280	48		pha				pha 								; save AXY
.c281	da		phx				phx
.c282	5a		phy				phy
.c283	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c285					_IFT_SLoop:
.c285	20 a5 c2	jsr $c2a5			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c288	e8		inx				inx
.c289	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c28b	d0 f8		bne $c285			bne 	_IFT_SLoop
.c28d	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c28f	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c292	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c294					_IFT_SBlank:
.c294	a9 20		lda #$20			lda 	#32
.c296	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c299	ca		dex				dex
.c29a	d0 f8		bne $c294			bne 	_IFT_SBlank
.c29c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c29e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2a1	7a		ply				ply
.c2a2	fa		plx				plx
.c2a3	68		pla				pla
.c2a4	60		rts				rts
.c2a5					_IFT_ScrollLine:
.c2a5	da		phx				phx
.c2a6	da		phx				phx
.c2a7	8a		txa				txa 								; copy line into buffer.
.c2a8	1a		inc a				inc 	a 							; next line down.
.c2a9	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2ac	a2 00		ldx #$00			ldx 	#0
.c2ae					_IFTScrollCopy1:
.c2ae	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c2b1	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2b4	e8		inx				inx
.c2b5	e0 40		cpx #$40			cpx 	#IF_Width
.c2b7	d0 f5		bne $c2ae			bne 	_IFTScrollCopy1
.c2b9	68		pla				pla
.c2ba	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2bd	a2 00		ldx #$00			ldx 	#0
.c2bf					_IFTScrollCopy2:
.c2bf	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2c2	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c2c5	e8		inx				inx
.c2c6	e0 40		cpx #$40			cpx 	#IF_Width
.c2c8	d0 f5		bne $c2bf			bne 	_IFTScrollCopy2
.c2ca	fa		plx				plx
.c2cb	60		rts				rts
.c2cc					IFT_SetYPos:
.c2cc	48		pha				pha
.c2cd	da		phx				phx
.c2ce	aa		tax				tax
.c2cf	20 29 c2	jsr $c229			jsr 	IFT_HomeCursor
.c2d2	e0 00		cpx #$00			cpx 	#0
.c2d4	f0 09		beq $c2df			beq 	_IFT_MOAExit
.c2d6					_IFT_MOALoop:
.c2d6	20 bd c3	jsr $c3bd			jsr 	IF_NewLine
.c2d9	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2dc	ca		dex				dex
.c2dd	d0 f7		bne $c2d6			bne		_IFT_MOALoop
.c2df					_IFT_MOAExit:
.c2df	fa		plx				plx
.c2e0	68		pla				pla
.c2e1	60		rts				rts
.c2e2					IFT_GetKeyCursor:
.c2e2	20 ea c2	jsr $c2ea			jsr 	_IFT_FlipCursor 			; reverse current
.c2e5					_IFT_GKCWait:
.c2e5	20 e7 c3	jsr $c3e7			jsr 	IF_GetKey 					; get key
.c2e8	f0 fb		beq $c2e5			beq 	_IFT_GKCWait
.c2ea					_IFT_FlipCursor:
.c2ea	48		pha				pha 								; save
.c2eb	20 cd c3	jsr $c3cd			jsr 	IF_Read 					; read
.c2ee	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f1	49 80		eor #$80			eor 	#$80 						; reverse
.c2f3	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write
.c2f6	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f9	68		pla				pla
.c2fa	60		rts				rts
.c2fb					IFT_ReadLine:
.c2fb	48		pha				pha
.c2fc					_IFT_RLLoop:
.c2fc	20 e2 c2	jsr $c2e2			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2ff	c9 0d		cmp #$0d			cmp 	#13							; return
.c301	f0 7d		beq $c380			beq 	_IFT_RLExit
.c303	c9 20		cmp #$20			cmp 	#32 						; control character
.c305	90 05		bcc $c30c			bcc 	_IFT_Control
.c307	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.c30a	80 f0		bra $c2fc			bra 	_IFT_RLLoop
.c30c					_IFT_Control:
.c30c	c9 01		cmp #$01			cmp 	#"A"-64
.c30e	f0 26		beq $c336			beq 	_IFT_Left
.c310	c9 04		cmp #$04			cmp 	#"D"-64
.c312	f0 2e		beq $c342			beq 	_IFT_Right
.c314	c9 17		cmp #$17			cmp 	#"W"-64
.c316	f0 36		beq $c34e			beq 	_IFT_Up
.c318	c9 13		cmp #$13			cmp 	#"S"-64
.c31a	f0 3e		beq $c35a			beq 	_IFT_Down
.c31c	c9 08		cmp #$08			cmp 	#"H"-64
.c31e	f0 09		beq $c329			beq 	_IFT_Backspace
.c320	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c322	d0 d8		bne $c2fc			bne 	_IFT_RLLoop
.c324	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen				; clear CTL-Z
.c327	80 d3		bra $c2fc			bra 	_IFT_RLLoop
.c329					_IFT_Backspace:
.c329	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c32c	f0 ce		beq $c2fc			beq 	_IFT_RLLoop
.c32e	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c331	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c333	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c336					_IFT_Left:
.c336	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c339	10 29		bpl $c364			bpl 	_IFT_Reposition
.c33b	a9 3f		lda #$3f			lda 	#IF_Width-1
.c33d					_IFT_SetX:
.c33d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c340	80 22		bra $c364			bra 	_IFT_Reposition
.c342					_IFT_Right:
.c342	ee 00 02	inc $0200			inc 	IFT_XCursor
.c345	ad 00 02	lda $0200			lda 	IFT_XCursor
.c348	49 40		eor #$40			eor 	#IF_Width
.c34a	f0 f1		beq $c33d			beq 	_IFT_SetX
.c34c	80 16		bra $c364			bra 	_IFT_Reposition
.c34e					_IFT_Up:
.c34e	ce 01 02	dec $0201			dec 	IFT_YCursor
.c351	10 11		bpl $c364			bpl 	_IFT_Reposition
.c353	a9 1f		lda #$1f			lda 	#IF_Height-1
.c355					_IFT_SetY:
.c355	8d 01 02	sta $0201			sta 	IFT_YCursor
.c358	80 0a		bra $c364			bra 	_IFT_Reposition
.c35a					_IFT_Down:
.c35a	ee 01 02	inc $0201			inc 	IFT_YCursor
.c35d	ad 01 02	lda $0201			lda 	IFT_YCursor
.c360	49 20		eor #$20			eor 	#IF_Height
.c362	f0 f1		beq $c355			beq 	_IFT_SetY
.c364					_IFT_Reposition:
.c364	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c367	48		pha				pha
.c368	ad 01 02	lda $0201			lda 	IFT_YCursor
.c36b	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c36e	68		pla				pla
.c36f	aa		tax				tax
.c370	e0 00		cpx #$00			cpx 	#0
.c372	f0 88		beq $c2fc			beq 	_IFT_RLLoop
.c374					_IFT_MoveRight:
.c374	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c377	ee 00 02	inc $0200			inc 	IFT_XCursor
.c37a	ca		dex				dex
.c37b	d0 f7		bne $c374			bne 	_IFT_MoveRight
.c37d	4c fc c2	jmp $c2fc			jmp 	_IFT_RLLoop
.c380					_IFT_RLExit:
.c380	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c383	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c386	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c388					_IFT_RLRead:
.c388	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c38b	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c38e	e8		inx				inx
.c38f	e0 40		cpx #$40			cpx 	#IF_Width
.c391	d0 f5		bne $c388			bne 	_IFT_RLRead
.c393					_IFT_RL_Trim:
.c393	ca		dex				dex 	 							; previous char
.c394	30 07		bmi $c39d			bmi 	_IFT_Found 					; gone too far
.c396	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c399	c9 20		cmp #$20			cmp 	#" "
.c39b	f0 f6		beq $c393			beq 	_IFT_RL_Trim
.c39d					_IFT_Found:
.c39d	e8		inx				inx 								; forward to non-space
.c39e	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c3a0	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c3a3	68		pla				pla
.c3a4	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a6	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a9					IF_Reset:
.c3a9	60		rts				rts
.c3aa					IF_Home:
.c3aa	48		pha				pha
.c3ab	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3ad	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3af	85 04		sta $04				sta 	IF_Pos
.c3b1	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3b3	85 05		sta $05				sta 	IF_Pos+1
.c3b5	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b7	85 06		sta $06				sta 	IF_Pos+2
.c3b9	64 07		stz $07				stz 	IF_Pos+3
.c3bb	68		pla				pla
.c3bc	60		rts				rts
.c3bd					IF_NewLine:
.c3bd	48		pha				pha
.c3be	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3c0	18		clc				clc 								; down one line
.c3c1	a5 04		lda $04				lda 	IF_Pos
.c3c3	69 40		adc #$40			adc 	#64
.c3c5	85 04		sta $04				sta 	IF_Pos
.c3c7	90 02		bcc $c3cb			bcc 	_IF_NoCarry 				; carry through.
.c3c9	e6 05		inc $05				inc 	IF_Pos+1
.c3cb					_IF_NoCarry:
.c3cb	68		pla				pla
.c3cc	60		rts				rts
.c3cd					IF_Read:
.c3cd	5a		phy				phy 								; save current Y
.c3ce	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3d0	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3d2	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d4	7a		ply				ply									; restore Y
.c3d5	60		rts				rts
.c3d6					IF_Write:
.c3d6	5a		phy				phy 								; save current Y
.c3d7	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d9	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3db	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3dd	7a		ply				ply									; restore Y
.c3de	60		rts				rts
.c3df					IF_LeftOne:
.c3df	c6 08		dec $08				dec 	IF_XPos
.c3e1	60		rts				rts
.c3e2					IF_CheckBreak:
.c3e2	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e6	60		rts				rts
.c3e7					IF_GetKey:
.c3e7	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3eb	f0 08		beq $c3f5			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3ed	48		pha				pha 								; key pressed, clear queue.
.c3ee	a9 00		lda #$00			lda 	#0
.c3f0	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3f4	68		pla				pla
.c3f5					_IFGK_NoKey:
.c3f5	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f8					BASIC_Start:
.c3f8	20 18 c4	jsr $c418			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c3fb	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c3fd	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c3ff	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c401	85 16		sta $16				sta 	zCodePtr+0
.c403	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c405	85 17		sta $17				sta 	zCodePtr+1
.c407	a9 00		lda #$00			lda 	#0
.c409	85 18		sta $18				sta 	zCodePtr+2
.c40b	85 19		sta $19				sta 	zCodePtr+3
.c40d	a0 03		ldy #$03			ldy 	#3
.c40f	c8		iny				iny
.c410	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c412	20 26 c4	jsr $c426			jsr 	EvaluateExpression
>c415	02						.byte 	2
.c416					SyntaxError:
.c416					ERR_Handler:
.c416	80 fe		bra $c416			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c418					CLR_Command:
.c418					ResetRunStatus:
.c418	a9 00		lda #$00			lda 	#HighMemory & $FF
.c41a	8d 26 04	sta $0426			sta 	StringPtr
.c41d	a9 80		lda #$80			lda 	#HighMemory >> 8
.c41f	8d 27 04	sta $0427			sta 	StringPtr+1
.c422	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c423					EVESyntax:
.c423	4c 16 c4	jmp $c416			jmp 	SyntaxError
.c426					EvaluateExpression:
.c426	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c428					EvaluateExpressionX:
.c428	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c42a					EvaluateExpressionXA:
.c42a	48		pha				pha 								; save precedence on stack.
.c42b	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c42d	f0 f4		beq $c423			beq 	EVESyntax 					; end of line, syntax error.
.c42f	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c431	b0 03		bcs $c436			bcs 	_EVNotVariable
.c433	4c 1e c5	jmp $c51e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c436					_EVNotVariable:
.c436	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c438	90 e9		bcc $c423			bcc 	EVESyntax
.c43a	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c43c	b0 7b		bcs $c4b9			bcs 	_EVNotInteger
.c43e	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c440	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c443	a9 00		lda #$00			lda 	#0
.c445	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c448	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c44b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c44e	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c450	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c453					_EVCheckNextInteger:
.c453	c8		iny				iny
.c454	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c456	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c458	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c45a	b0 0d		bcs $c469			bcs 	_EVCheckDecimal
.c45c	48		pha				pha 								; save it.
.c45d	20 22 c5	jsr $c522			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c460	68		pla				pla
.c461	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c464	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c467	80 ea		bra $c453			bra 	_EVCheckNextInteger
.c469					_EVCheckDecimal:
.c469	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c46b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c46d	d0 05		bne $c474			bne 	_EVGotAtom 					; no, get atom.
.c46f					_EVIsDecimal:
.c46f	20 52 c5	jsr $c552			jsr 	EVGetDecimal 				; extend to the decimal part.
.c472	80 00		bra $c474			bra 	_EVGotAtom 					; and continue to got atom.
.c474					_EVGotAtom:
.c474	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c476	10 3f		bpl $c4b7			bpl 	_EVExitDrop 				; must be a token.
.c478	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c47a	b0 3b		bcs $c4b7			bcs 	_EVExitDrop
.c47c	68		pla				pla 								; get current precedence
.c47d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c47f	da		phx				phx 								; save X
.c480	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c482	aa		tax				tax 								; put in X
.c483	bd 34 c0	lda $c034,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c486	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c488	fa		plx				plx 								; restore X
.c489	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c48b	90 2b		bcc $c4b8			bcc 	_EVExit 					; exit if too low.
.c48d	f0 29		beq $c4b8			beq 	_EVExit 					; exit if equals
.c48f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c491	48		pha				pha
.c492	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c494	48		pha				pha
.c495	c8		iny				iny
.c496	da		phx				phx 								; save current position
.c497	e8		inx				inx
.c498	e8		inx				inx
.c499	e8		inx				inx
.c49a	e8		inx				inx
.c49b	e8		inx				inx
.c49c	e8		inx				inx
.c49d	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c49f	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA 		; do the RHS.
.c4a2	fa		plx				plx 								; restore X
.c4a3	68		pla				pla 								; get the binary operator in A.
.c4a4					_EVCallA:
.c4a4	da		phx				phx 								; save X again
.c4a5	0a		asl a				asl 	a 							; double, lose the MSB.
.c4a6	aa		tax				tax									; put in X
.c4a7	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c4aa	85 1e		sta $1e				sta 	zGenPtr
.c4ac	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c4af	85 1f		sta $1f				sta 	zGenPtr+1
.c4b1	fa		plx				plx 								; restore X
.c4b2	20 1f c5	jsr $c51f			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4b5	80 bd		bra $c474			bra 	_EVGotAtom 					; and loop back.
.c4b7					_EVExitDrop:
.c4b7	68		pla				pla
.c4b8					_EVExit:
.c4b8	60		rts				rts
.c4b9					_EVNotInteger:
.c4b9	c8		iny				iny
.c4ba	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4bc	d0 19		bne $c4d7			bne 	_EVNotMinus
.c4be	20 a3 c5	jsr $c5a3			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4c1	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4c4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4c6	f0 05		beq $c4cd			beq 	_EVMinusFloat
.c4c8	20 00 cc	jsr $cc00			jsr 	IntegerNegateAlways 		; negation
.c4cb	80 a7		bra $c474			bra 	_EVGotAtom 					; and go back.
.c4cd					_EVMinusFloat:
.c4cd	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4d0	49 80		eor #$80			eor 	#$80
.c4d2	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4d5	80 9d		bra $c474			bra 	_EVGotAtom
.c4d7					_EVNotMinus:
.c4d7	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.c4d9	d0 0c		bne $c4e7			bne 	_EVNotParenthesis
.c4db	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4de	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4e0	c8		iny				iny
.c4e1	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.c4e3	f0 8f		beq $c474			beq 	_EVGotAtom
.c4e5	80 fe		bra $c4e5		_error: bra _error
.c4e7					_EVNotParenthesis:
.c4e7	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4e9	d0 0c		bne $c4f7			bne 	_EVNotNot
.c4eb	20 a3 c5	jsr $c5a3			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c4ee	20 f4 d0	jsr $d0f4			jsr 	FPUToInteger 				; make it an integer - if possible.
.c4f1	20 80 c5	jsr $c580			jsr 	NotInteger 					; do the not calculation
.c4f4	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c4f7					_EVNotNot:
.c4f7	c9 fe		cmp #$fe			cmp 	#$FE
.c4f9	d0 15		bne $c510			bne 	_EVNotString
.c4fb	20 00 cb	jsr $cb00			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c4fe	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c500	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c503	a5 21		lda $21				lda 	zTempStr+1
.c505	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c508	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c50a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c50d	4c 74 c4	jmp $c474			jmp 	_EVGotAtom
.c510					_EVNotString:
.c510	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.c512	90 04		bcc $c518			bcc 	_EVBadElement
.c514	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.c516	90 03		bcc $c51b			bcc 	_EVUnaryFunction
.c518					_EVBadElement:
.c518	4c 16 c4	jmp $c416			jmp 	SyntaxError
.c51b					_EVUnaryFunction:
.c51b	4c a4 c4	jmp $c4a4			jmp 	_EVCallA
.c51e					_EVVariableHandler:
.c51e	ea		nop				nop
.c51f					EVGoZGenPtr:
.c51f	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c522					EVShiftMantissaLeft6:
.c522	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c525	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c528	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c52b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c52e	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c531	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c534	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c537	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c53a	a9 00		lda #$00			lda 	#0
.c53c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c53f	20 42 c5	jsr $c542			jsr 	_EVSMLShift 					; call it here to do it twice
.c542					_EVSMLShift:
.c542	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c545	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c548	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c54b	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c54e	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c551	60		rts				rts
.c552					EVGetDecimal:
.c552	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c554	8d 00 04	sta $0400			sta 	Num_Buffer
.c557	da		phx				phx
.c558	c8		iny				iny
.c559	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c55b	c8		iny				iny
.c55c	3a		dec a				dec 	a								; convert to a string length.
.c55d	3a		dec a				dec 	a
.c55e	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c560					_EVGDCopy:
.c560	48		pha				pha 									; save count
.c561	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c563	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c566	e8		inx				inx 									; forward ....
.c567	c8		iny				iny
.c568	68		pla				pla 									; get count
.c569	3a		dec a				dec 	a 								; until zero
.c56a	d0 f4		bne $c560			bne 	_EVGDCopy
.c56c	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c56f	fa		plx				plx 									; restore X
.c570	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c572	85 1e		sta $1e				sta 	zGenPtr
.c574	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c576	85 1f		sta $1f				sta 	zGenPtr+1
.c578	5a		phy				phy 									; save Y
.c579	a0 00		ldy #$00			ldy 	#0 								; start position
.c57b	20 cd d2	jsr $d2cd			jsr 	FPFromString 					; convert current
.c57e	7a		ply				ply 									; restore Y
.c57f	60		rts				rts
.c580					NotInteger:
.c580	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c583	49 ff		eor #$ff			eor 	#$FF
.c585	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c588	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c58b	49 ff		eor #$ff			eor 	#$FF
.c58d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c590	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c593	49 ff		eor #$ff			eor 	#$FF
.c595	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c598	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c59b	49 ff		eor #$ff			eor 	#$FF
.c59d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5a0	60		rts				rts
.c5a1					EvaluateGetAtom:
.c5a1	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c5a3					EvaluateGetAtomX:
.c5a3	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c5a5	20 2a c4	jsr $c42a			jsr 	EvaluateExpressionXA
.c5a8	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c5ab	29 0f		and #$0f			and 	#15
.c5ad	c9 02		cmp #$02			cmp 	#2
.c5af	b0 01		bcs $c5b2			bcs 	EvaluateType
.c5b1	60		rts				rts
.c5b2					EvaluateType:
.c5b2	80 fe		bra $c5b2		_error: bra _error
.c5b4					EvaluateNumber:
.c5b4	a2 00		ldx #$00			ldx 	#0
.c5b6					EvaluateNumberX:
.c5b6	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX
.c5b9	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0/1
.c5bc	29 0f		and #$0f			and 	#15
.c5be	c9 02		cmp #$02			cmp 	#2
.c5c0	b0 f0		bcs $c5b2			bcs 	EvaluateType
.c5c2	60		rts				rts
.c5c3					EvaluateString:
.c5c3	a2 00		ldx #$00			ldx 	#0
.c5c5					EvaluateStringX:
.c5c5	20 28 c4	jsr $c428			jsr 	EvaluateExpressionX
.c5c8	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 2
.c5cb	29 0f		and #$0f			and 	#15
.c5cd	c9 02		cmp #$02			cmp 	#2
.c5cf	d0 e1		bne $c5b2			bne 	EvaluateType
.c5d1	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.c5d4	85 1e		sta $1e				sta 	zGenPtr
.c5d6	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c5d9	85 1f		sta $1f				sta 	zGenPtr+1
.c5db	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5dc					BinaryOp_And:
.c5dc	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c5df	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5e2	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5e5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5e8	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5eb	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5ee	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5f1	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5f4	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5f7	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5fa	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5fd	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c600	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c603	60		rts				rts
.c604					BinaryOp_Or:
.c604	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c607	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c60a	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c60d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c610	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c613	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c616	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c619	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c61c	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c61f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c622	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c625	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c628	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c62b	60		rts				rts
.c62c					BinaryOp_Eor:
.c62c					BinaryOp_Xor:
.c62c	20 54 c6	jsr $c654			jsr 	BinaryMakeBothInteger
.c62f	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c632	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c635	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c638	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c63b	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c63e	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c641	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c644	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c647	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c64a	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c64d	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c650	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c653	60		rts				rts
.c654					BinaryMakeBothInteger:
.c654	da		phx				phx 								; save X
.c655	e8		inx				inx
.c656	e8		inx				inx
.c657	e8		inx				inx
.c658	e8		inx				inx
.c659	e8		inx				inx
.c65a	e8		inx				inx
.c65b	20 5f c6	jsr $c65f			jsr 	BinaryMakeInteger 			; convert to integer.
.c65e	fa		plx				plx 								; restore X and fall through.
.c65f					BinaryMakeInteger:
.c65f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c662	29 0f		and #$0f			and 	#15 						; check type zero
.c664	f0 04		beq $c66a			beq 	_BMIConvert 				; if float convert to integer.
.c666	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c667	90 04		bcc $c66d			bcc 	_BMIError
.c669	60		rts				rts
.c66a					_BMIConvert:
.c66a	4c f4 d0	jmp $d0f4			jmp 	FPUToInteger 				; convert to integer
.c66d					_BMIError:
.c66d	80 fe		bra $c66d		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.c66f					Binary_Equal:
.c66f	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c672	09 00		ora #$00			ora 	#0
.c674	f0 04		beq $c67a			beq 	CCTrue
.c676	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.c678	80 02		bra $c67c			bra 	CCWrite
.c67a	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.c67c	9d 00 03	sta $0300,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.c67f	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c682	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c685	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c688	a9 01		lda #$01			lda 	#1
.c68a	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; set type to integer whatever.
.c68d	60		rts				rts
.c68e					Binary_NotEqual:
.c68e	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c691	09 00		ora #$00			ora 	#0
.c693	d0 e1		bne $c676			bne 	CCFalse
.c695	80 e3		bra $c67a			bra 	CCTrue
.c697					Binary_Less:
.c697	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c69a	09 00		ora #$00			ora 	#0
.c69c	30 dc		bmi $c67a			bmi 	CCTrue
.c69e	80 d6		bra $c676			bra 	CCFalse
.c6a0					Binary_LessEqual:
.c6a0	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6a3	c9 01		cmp #$01			cmp 	#1
.c6a5	d0 d3		bne $c67a			bne 	CCTrue
.c6a7	80 cd		bra $c676			bra 	CCFalse
.c6a9					Binary_GreaterEqual:
.c6a9	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6ac	09 00		ora #$00			ora 	#0
.c6ae	10 ca		bpl $c67a			bpl 	CCTrue
.c6b0	80 c4		bra $c676			bra 	CCFalse
.c6b2					Binary_Greater:
.c6b2	20 bb c6	jsr $c6bb			jsr 	CompareValues
.c6b5	c9 01		cmp #$01			cmp 	#1
.c6b7	d0 c1		bne $c67a			bne 	CCTrue
.c6b9	80 bb		bra $c676			bra 	CCFalse
.c6bb					CompareValues:
.c6bb	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and the types together
.c6be	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6c1	c9 02		cmp #$02			cmp 	#2
.c6c3	f0 13		beq $c6d8			beq 	_CVString
.c6c5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6c8	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6cb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6cc	90 03		bcc $c6d1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6ce	4c 1e c7	jmp $c71e			jmp 	CompareInteger32 							; so execute code at \1
.c6d1					_BCFloat:
.c6d1	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6d4	4c 03 d0	jmp $d003			jmp 	FPCompare 							; and execute code at \2
.c6d7	60		rts				rts
.c6d8					_CVString:
.c6d8	da		phx				phx 								; save XY
.c6d9	5a		phy				phy
.c6da	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c6dd	85 1a		sta $1a				sta		zLTemp1+0
.c6df	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6e2	85 1b		sta $1b				sta 	zLTemp1+1
.c6e4	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c6e7	85 1c		sta $1c				sta 	zLTemp1+2
.c6e9	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c6ec	85 1d		sta $1d				sta 	zLTemp1+3
.c6ee	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.c6f0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c6f2	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6f4	90 02		bcc $c6f8			bcc 	_CVCommon
.c6f6	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.c6f8					_CVCommon:
.c6f8	aa		tax				tax 								; put shorter string length in zero.
.c6f9	f0 0c		beq $c707			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.c6fb					_CVCompare:
.c6fb	c8		iny				iny 								; next character
.c6fc	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.c6fe	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c700	90 13		bcc $c715			bcc 	_CVReturnLess 				; <
.c702	d0 15		bne $c719			bne 	_CVReturnGreater 			; >
.c704	ca		dex				dex 								; until common length matched.
.c705	d0 f4		bne $c6fb			bne 	_CVCompare
.c707					_CVMatch:
.c707	a0 00		ldy #$00			ldy 	#0
.c709	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c70b	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c70d	90 06		bcc $c715			bcc 	_CVReturnLess 				; <
.c70f	d0 08		bne $c719			bne 	_CVReturnGreater 			; >
.c711	a9 00		lda #$00			lda 	#0
.c713	80 06		bra $c71b			bra 	_CVExit 					; same common, same length, same string
.c715					_CVReturnLess:
.c715	a9 ff		lda #$ff			lda 	#$FF
.c717	80 02		bra $c71b			bra 	_CVExit
.c719					_CVReturnGreater:
.c719	a9 01		lda #$01			lda 	#$01
.c71b					_CVExit:
.c71b	7a		ply				ply
.c71c	fa		plx				plx
.c71d	60		rts				rts
.c71e					CompareInteger32:
.c71e	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.c721	49 80		eor #$80			eor 	#$80
.c723	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c726	bd 09 03	lda $0309,x			lda 	XS2_Mantissa+3,x
.c729	49 80		eor #$80			eor 	#$80
.c72b	9d 09 03	sta $0309,x			sta 	XS2_Mantissa+3,x
.c72e	20 c6 c7	jsr $c7c6			jsr 	SubInteger32 				; subtraction
.c731	90 11		bcc $c744			bcc 	_CI32Less 					; cc return -1
.c733	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; check if zero
.c736	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c739	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c73c	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c73f	f0 02		beq $c743			beq 	_CI32Exit
.c741	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.c743					_CI32Exit:
.c743	60		rts				rts
.c744					_CI32Less:
.c744	a9 ff		lda #$ff			lda 	#$FF
.c746	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c747					BinaryOp_Add:
.c747	bd 05 03	lda $0305,x			lda 	XS_Type,x  					; and types together
.c74a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c74d	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c74f	d0 13		bne $c764			bne 	_BOAString
.c751	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c754	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c757	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c758	90 03		bcc $c75d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c75a	4c a0 c7	jmp $c7a0			jmp 	AddInteger32 							; so execute code at \1
.c75d					_BCFloat:
.c75d	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c760	4c 89 cd	jmp $cd89			jmp 	FPAdd 							; and execute code at \2
.c763	60		rts				rts
.c764					_BOAString:
.c764	4c 06 c8	jmp $c806			jmp 	ConcatenateString 			; concatenate two strings.
.c767					BinaryOp_Subtract:
.c767	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c76a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c76d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c76e	90 03		bcc $c773			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c770	4c c6 c7	jmp $c7c6			jmp 	SubInteger32 							; so execute code at \1
.c773					_BCFloat:
.c773	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c776	4c 7f cd	jmp $cd7f			jmp 	FPSubtract 							; and execute code at \2
.c779	60		rts				rts
.c77a					BinaryOp_Multiply:
.c77a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c77d	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c780	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c781	90 03		bcc $c786			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c783	4c 25 cb	jmp $cb25			jmp 	MulInteger32 							; so execute code at \1
.c786					_BCFloat:
.c786	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c789	4c e3 ce	jmp $cee3			jmp 	FPMultiply 							; and execute code at \2
.c78c	60		rts				rts
.c78d					BinaryOp_Divide:
.c78d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c790	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c793	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c794	90 03		bcc $c799			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c796	4c 7c cb	jmp $cb7c			jmp 	DivInteger32 							; so execute code at \1
.c799					_BCFloat:
.c799	20 ec c7	jsr $c7ec			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c79c	4c 5b ce	jmp $ce5b			jmp 	FPDivide 							; and execute code at \2
.c79f	60		rts				rts
.c7a0					AddInteger32:
.c7a0	18		clc				clc
.c7a1	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7a4	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c7a7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7aa	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7ad	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c7b0	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7b3	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7b6	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c7b9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7bc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7bf	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c7c2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7c5	60		rts				rts
.c7c6					SubInteger32:
.c7c6	38		sec				sec
.c7c7	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7ca	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c7cd	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7d0	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7d3	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c7d6	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7d9	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7dc	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c7df	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7e2	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7e5	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c7e8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7eb	60		rts				rts
.c7ec					BinaryMakeBothFloat:
.c7ec	da		phx				phx 								; save X
.c7ed	e8		inx				inx
.c7ee	e8		inx				inx
.c7ef	e8		inx				inx
.c7f0	e8		inx				inx
.c7f1	e8		inx				inx
.c7f2	e8		inx				inx
.c7f3	20 f7 c7	jsr $c7f7			jsr 	BinaryMakeFloat 			; convert to float.
.c7f6	fa		plx				plx 								; restore X and fall through.
.c7f7					BinaryMakeFloat:
.c7f7	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c7fa	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c7fb	b0 04		bcs $c801			bcs 	_BMFConvert
.c7fd	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c7fe	b0 04		bcs $c804			bcs 	_BMFError
.c800	60		rts				rts
.c801					_BMFConvert:
.c801	4c 95 d0	jmp $d095			jmp 	FPUToFloat 					; convert to float
.c804					_BMFError:
.c804	80 fe		bra $c804		_error: bra _error
.c806					ConcatenateString:
.c806	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c809	85 1a		sta $1a				sta		zLTemp1+0
.c80b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c80e	85 1b		sta $1b				sta 	zLTemp1+1
.c810	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c813	85 1c		sta $1c				sta 	zLTemp1+2
.c815	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c818	85 1d		sta $1d				sta 	zLTemp1+3
.c81a	5a		phy				phy
.c81b	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c81d	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c81f	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c821	7a		ply				ply
.c822	b0 37		bcs $c85b			bcs 	_CSError					; check in range.
.c824	c9 fe		cmp #$fe			cmp 	#maxString+1
.c826	b0 33		bcs $c85b			bcs 	_CSError
.c828	20 c5 ca	jsr $cac5			jsr 	AllocateTempString 			; store the result
.c82b	20 46 c8	jsr $c846			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c82e	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c831	85 1a		sta $1a				sta 	zLTemp1
.c833	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c836	85 1b		sta $1b				sta 	zLTemp1+1
.c838	20 46 c8	jsr $c846			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c83b	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c83d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c840	a5 21		lda $21				lda 	zTempStr+1
.c842	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c845	60		rts				rts
.c846					_CSCopyString:
.c846	da		phx				phx
.c847	5a		phy				phy
.c848	a0 00		ldy #$00			ldy 	#0 							; get length
.c84a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c84c	f0 0a		beq $c858			beq 	_CSCSExit 					; if zero, exit
.c84e	aa		tax				tax 								; put in X
.c84f					_CSCSLoop:
.c84f	c8		iny				iny 								; get next char
.c850	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c852	20 f0 ca	jsr $caf0			jsr		WriteTempString 			; copy out
.c855	ca		dex				dex 								; do whole string
.c856	d0 f7		bne $c84f			bne 	_CSCSLoop
.c858					_CSCSExit:
.c858	7a		ply				ply
.c859	fa		plx				plx
.c85a	60		rts				rts
.c85b					_CSError:
.c85b	80 fe		bra $c85b		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.c85d					Unary_Sgn:
.c85d	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.c860	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; check right bracket.
.c863	20 87 c8	jsr $c887			jsr 	GetSignCurrent 				; get sign.
.c866	09 00		ora #$00			ora 	#0
.c868	10 09		bpl $c873			bpl		UnarySetAInteger			; if 0,1 return that.
.c86a	80 00		bra $c86c			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.c86c					UnarySetAMinus1:
.c86c	a9 ff		lda #$ff			lda 	#$FF
.c86e	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c871	80 05		bra $c878			bra 	UnarySetAFill
.c873					UnarySetAInteger:
.c873	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c876	a9 00		lda #$00			lda 	#0
.c878					UnarySetAFill:
.c878	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c87b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c87e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c881	a9 01		lda #$01			lda 	#1
.c883	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c886	60		rts				rts
.c887					GetSignCurrent:
.c887	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; identify type.
.c88a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.c88b	90 19		bcc $c8a6			bcc 	_GSCFloat
.c88d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c890	30 11		bmi $c8a3			bmi 	_GSCMinus1
.c892	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x
.c895	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c898	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c89b	d0 03		bne $c8a0			bne 	_GSCPlus1
.c89d					_GSCZero:
.c89d	a9 00		lda #$00			lda 	#0
.c89f	60		rts				rts
.c8a0					_GSCPlus1:
.c8a0	a9 01		lda #$01			lda 	#$01
.c8a2	60		rts				rts
.c8a3					_GSCMinus1:
.c8a3	a9 ff		lda #$ff			lda 	#$FF
.c8a5	60		rts				rts
.c8a6					_GSCFloat:
.c8a6	3c 05 03	bit $0305,x			bit 	XS_Type,x
.c8a9	70 f2		bvs $c89d			bvs 	_GSCZero
.c8ab	30 f6		bmi $c8a3			bmi 	_GSCMinus1
.c8ad	80 f1		bra $c8a0			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.c8af					Unary_Abs:
.c8af	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.c8b2	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; check right bracket.
.c8b5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c8b8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c8ba	f0 08		beq $c8c4			beq 	_UAMinusFloat
.c8bc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; check MSB
.c8bf	10 0b		bpl $c8cc			bpl 	_UAExit
.c8c1	4c 00 cc	jmp $cc00			jmp 	IntegerNegateAlways 		; negation
.c8c4					_UAMinusFloat:
.c8c4	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; clear the sign bit.
.c8c7	29 7f		and #$7f			and		#$7F
.c8c9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c8cc					_UAExit:
.c8cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.c8cd					Unary_Val:
.c8cd	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; get string
.c8d0	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; check right bracket.
.c8d3	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.c8d6	85 1e		sta $1e				sta 	zGenPtr
.c8d8	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c8db	85 1f		sta $1f				sta 	zGenPtr+1
.c8dd	5a		phy				phy
.c8de	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.c8e0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.c8e2	f0 54		beq $c938			beq 	_UVBadNumber
.c8e4	48		pha				pha 								; save length.
.c8e5	1a		inc a				inc 	a 							; one for the length, one for the terminator
.c8e6	1a		inc a				inc 	a
.c8e7	20 c5 ca	jsr $cac5			jsr 	AllocateTempString
.c8ea	c8		iny				iny 								; move to the next.
.c8eb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.c8ed	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.c8ef	8d 28 04	sta $0428			sta 	ValSign
.c8f2	d0 01		bne $c8f5			bne 	_UVNotMinus
.c8f4	c8		iny				iny 								; skip over it.
.c8f5					_UVNotMinus:
.c8f5	68		pla				pla 								; this is the count.
.c8f6	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.c8f7	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c8f9	c8		iny				iny
.c8fa	20 f0 ca	jsr $caf0			jsr 	WriteTempString
.c8fd	68		pla				pla
.c8fe	3a		dec a				dec 	a
.c8ff	d0 f5		bne $c8f6			bne 	_UVCopy
.c901	20 f0 ca	jsr $caf0			jsr 	WriteTempString 			; make it ASCIIZ
.c904	18		clc				clc
.c905	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.c907	69 01		adc #$01			adc 	#1
.c909	85 1e		sta $1e				sta 	zGenPtr
.c90b	a5 21		lda $21				lda 	zTempStr+1
.c90d	69 00		adc #$00			adc 	#0
.c90f	85 1f		sta $1f				sta 	zGenPtr+1
.c911	18		clc				clc
.c912	20 d4 cc	jsr $ccd4			jsr 	IntFromString 				; first bit.
.c915	b0 21		bcs $c938			bcs 	_UVBadNumber
.c917	20 cd d2	jsr $d2cd			jsr 	FPFromString				; try for a float part.
.c91a	ad 28 04	lda $0428			lda 	ValSign 					; was it negative
.c91d	d0 13		bne $c932			bne 	_UVNotNegative
.c91f	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check if integer
.c922	4a		lsr a				lsr 	a
.c923	b0 0a		bcs $c92f			bcs 	_UVInteger
.c925	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; set sign bit
.c928	09 80		ora #$80			ora 	#$80
.c92a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c92d	80 03		bra $c932			bra 	_UVNotNegative
.c92f					_UVInteger:
.c92f	20 00 cc	jsr $cc00			jsr 	IntegerNegateAlways 		; sign it.
.c932					_UVNotNegative:
.c932	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.c934	d0 02		bne $c938			bne 	_UVBadNumber
.c936	7a		ply				ply
.c937	60		rts				rts
.c938					_UVBadNumber:
.c938	80 fe		bra $c938		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.c93a					Unary_Str:
.c93a	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.c93d	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; right bracket.
.c940	a9 00		lda #$00			lda 	#0 							; reset buffer index
.c942	8d 20 04	sta $0420			sta 	NumBufX
.c945	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c948	4a		lsr a				lsr 	a
.c949	b0 05		bcs $c950			bcs 	_USInt 						; if msb set do as integer
.c94b	20 06 d2	jsr $d206			jsr 	FPToString 					; call fp to str otherwise
.c94e	80 03		bra $c953			bra 	_USDuplicate
.c950	20 25 cc	jsr $cc25	_USInt:	jsr 	IntToString
.c953					_USDuplicate:
.c953	ad 20 04	lda $0420			lda 	NumBufX 					; chars in buffer
.c956	1a		inc a				inc 	a 							; one more for length
.c957	20 c5 ca	jsr $cac5			jsr 	AllocateTempString 			; allocate space for it.
.c95a	5a		phy				phy 								; save Y
.c95b	a0 00		ldy #$00			ldy 	#0 							; start copying
.c95d	b9 00 04	lda $0400,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.c960	20 f0 ca	jsr $caf0			jsr 	WriteTempString
.c963	c8		iny				iny
.c964	cc 20 04	cpy $0420			cpy 	NumBufX 					; done the lot
.c967	d0 f4		bne $c95d			bne 	_USCopy
.c969	7a		ply				ply 								; restore Y
.c96a	4c 9d ca	jmp $ca9d			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c96d					Unary_Asc:
.c96d	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; string parameter
.c970	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; right bracket.
.c973	5a		phy				phy 								; get the string length
.c974	a0 00		ldy #$00			ldy 	#0
.c976	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c978	f0 07		beq $c981			beq 	_UAIllegal 					; must be at least one character
.c97a	c8		iny				iny
.c97b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.c97d	7a		ply				ply
.c97e	4c 73 c8	jmp $c873			jmp 	UnarySetAInteger
.c981					_UAIllegal:
.c981	80 fe		bra $c981		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c983					Unary_Len:
.c983	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; string parameter
.c986	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; right bracket.
.c989	5a		phy				phy 								; get the string length
.c98a	a0 00		ldy #$00			ldy 	#0
.c98c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c98e	7a		ply				ply
.c98f	4c 73 c8	jmp $c873			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.c992					Unary_Hex:
.c992	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.c995	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; right bracket.
.c998	20 f4 d0	jsr $d0f4			jsr 	FPUToInteger 				; convert to integer
.c99b	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.c99d	20 c5 ca	jsr $cac5			jsr 	AllocateTempString			; allocate string space
.c9a0	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.c9a3	20 ca c9	jsr $c9ca			jsr 	_UHConvert
.c9a6	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c9a9	20 ca c9	jsr $c9ca			jsr 	_UHConvert
.c9ac	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c9af	20 ca c9	jsr $c9ca			jsr 	_UHConvert
.c9b2	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c9b5	20 ca c9	jsr $c9ca			jsr 	_UHConvert
.c9b8	5a		phy				phy 								; get length of new string
.c9b9	a0 00		ldy #$00			ldy 	#0
.c9bb	b1 20		lda ($20),y			lda 	(zTempStr),y
.c9bd	7a		ply				ply
.c9be	c9 00		cmp #$00			cmp 	#0
.c9c0	d0 05		bne $c9c7			bne 	_UHExit 					; if it was non zero okay
.c9c2	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.c9c4	20 f0 ca	jsr $caf0			jsr 	WriteTempString
.c9c7					_UHExit:
.c9c7	4c 9d ca	jmp $ca9d			jmp 	UnaryReturnTempStr 			; return new temporary string.
.c9ca					_UHConvert:
.c9ca	48		pha				pha
.c9cb	4a		lsr a				lsr 	a 							; do MSB
.c9cc	4a		lsr a				lsr 	a
.c9cd	4a		lsr a				lsr 	a
.c9ce	4a		lsr a				lsr 	a
.c9cf	20 d3 c9	jsr $c9d3			jsr 	_UHNibble
.c9d2	68		pla				pla 								; do LSB
.c9d3					_UHNibble:
.c9d3	29 0f		and #$0f			and 	#15 						; get nibble
.c9d5	d0 0c		bne $c9e3			bne 	_UHNonZero
.c9d7	5a		phy				phy									; get the length
.c9d8	a0 00		ldy #$00			ldy 	#0
.c9da	b1 20		lda ($20),y			lda 	(zTempStr),y
.c9dc	7a		ply				ply
.c9dd	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.c9df	f0 0d		beq $c9ee			beq 	_UHExit2
.c9e1	a9 00		lda #$00			lda 	#0
.c9e3					_UHNonZero:
.c9e3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c9e5	90 02		bcc $c9e9			bcc 	_UHDigit
.c9e7	69 06		adc #$06			adc 	#7-1
.c9e9					_UHDigit:
.c9e9	69 30		adc #$30			adc 	#48
.c9eb	20 f0 ca	jsr $caf0			jsr 	WriteTempString				; output.
.c9ee					_UHExit2:
.c9ee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.c9ef					Unary_Dec:
.c9ef	20 c5 c5	jsr $c5c5			jsr 	EvaluateStringX 			; string parameter
.c9f2	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; right bracket.
.c9f5	5a		phy				phy
.c9f6	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.c9f8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.c9fa	f0 3e		beq $ca3a			beq 	_UDFail 					; must fail if zero.
.c9fc	8d 25 04	sta $0425			sta 	SignCount 					; use SignCount as a counter
.c9ff	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.ca01	20 57 d0	jsr $d057			jsr 	FPUSetInteger
.ca04					_UDConvertLoop:
.ca04	5a		phy				phy 								; shift mantissa left 4
.ca05	a0 04		ldy #$04			ldy 	#4
.ca07					_UDShift:
.ca07	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.ca0a	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.ca0d	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.ca10	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.ca13	88		dey				dey
.ca14	d0 f1		bne $ca07			bne 	_UDShift
.ca16	7a		ply				ply
.ca17	c8		iny				iny 								; next character
.ca18	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.ca1a	20 3c ca	jsr $ca3c			jsr 	ConvertUpper 				; convert to U/C
.ca1d	c9 30		cmp #$30			cmp 	#"0"
.ca1f	90 19		bcc $ca3a			bcc 	_UDFail
.ca21	c9 3a		cmp #$3a			cmp 	#"9"+1
.ca23	90 06		bcc $ca2b			bcc 	_UDOkay
.ca25	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.ca27	c9 10		cmp #$10			cmp 	#16
.ca29	b0 0f		bcs $ca3a			bcs 	_UDFail
.ca2b					_UDOkay:
.ca2b	29 0f		and #$0f			and 	#15 						; nibble only
.ca2d	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x
.ca30	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca33	ce 25 04	dec $0425			dec 	SignCount 					; do it for each character
.ca36	d0 cc		bne $ca04			bne 	_UDConvertLoop
.ca38	7a		ply				ply
.ca39	60		rts				rts
.ca3a					_UDFail:
.ca3a	80 fe		bra $ca3a		_error: bra _error
.ca3c					ConvertUpper:
.ca3c	c9 61		cmp #$61			cmp 	#"a"
.ca3e	90 07		bcc $ca47			bcc 	_CUExit
.ca40	c9 7b		cmp #$7b			cmp 	#"z"+1
.ca42	b0 03		bcs $ca47			bcs 	_CUExit
.ca44	38		sec				sec
.ca45	e9 20		sbc #$20			sbc 	#32
.ca47	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.ca48					Unary_Chr:
.ca48	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.ca4b	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; right bracket.
.ca4e	20 f4 d0	jsr $d0f4			jsr 	FPUToInteger 				; make integer.
.ca51	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.ca54	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.ca57	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.ca5a	d0 0e		bne $ca6a			bne 	_UCChar
.ca5c	a9 01		lda #$01			lda 	#1 							; one character string
.ca5e	20 c5 ca	jsr $cac5			jsr 	AllocateTempString
.ca61	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.ca64	20 f0 ca	jsr $caf0			jsr 	WriteTempString
.ca67	4c 9d ca	jmp $ca9d			jmp 	UnaryReturnTempStr
.ca6a					_UCChar:
.ca6a	80 fe		bra $ca6a		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.ca6c					Unary_Spc:
.ca6c	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; numeric parameter
.ca6f	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; right bracket.
.ca72	20 f4 d0	jsr $d0f4			jsr 	FPUToInteger 				; make integer.
.ca75	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.ca78	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.ca7b	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.ca7e	d0 1b		bne $ca9b			bne 	_USSize
.ca80	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ca83	c9 fe		cmp #$fe			cmp 	#maxString+1
.ca85	b0 14		bcs $ca9b			bcs 	_USSize
.ca87	48		pha				pha 								; save length
.ca88	1a		inc a				inc 	a 							; allocate one more.
.ca89	20 c5 ca	jsr $cac5			jsr 	AllocateTempString
.ca8c	68		pla				pla 								; get length
.ca8d	f0 0e		beq $ca9d			beq 	UnaryReturnTempStr 			; return the current temp string
.ca8f					_USLoop:
.ca8f	48		pha				pha
.ca90	a9 20		lda #$20			lda 	#" "
.ca92	20 f0 ca	jsr $caf0			jsr 	WriteTempString
.ca95	68		pla				pla
.ca96	3a		dec a				dec 	a
.ca97	d0 f6		bne $ca8f			bne 	_USLoop
.ca99	80 02		bra $ca9d			bra 	UnaryReturnTempStr
.ca9b					_USSize:
.ca9b	80 fe		bra $ca9b		_error: bra _error
.ca9d					UnaryReturnTempStr:
.ca9d	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.ca9f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.caa2	a5 21		lda $21				lda 	zTempStr+1
.caa4	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.caa7	a9 02		lda #$02			lda 	#2 							; set type to string
.caa9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.caac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.caad					CheckNextToken:
.caad	d1 16		cmp ($16),y			cmp 	(zCodePtr),y
.caaf	d0 02		bne $cab3			bne 	CTFail 						; no, then fail
.cab1	c8		iny				iny
.cab2	60		rts				rts
.cab3					CTFail:
.cab3	80 fe		bra $cab3		_error: bra _error
.cab5					CheckNextRParen:
.cab5	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cab7	c9 bc		cmp #$bc			cmp 	#token_rparen
.cab9	d0 f8		bne $cab3			bne 	CTFail
.cabb	c8		iny				iny
.cabc	60		rts				rts
.cabd					CheckNextComma:
.cabd	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cabf	c9 bd		cmp #$bd			cmp 	#token_comma
.cac1	d0 f0		bne $cab3			bne 	CTFail
.cac3	c8		iny				iny
.cac4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.cac5					AllocateTempString:
.cac5	48		pha				pha 								; save required count.
.cac6	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.cac8	d0 0b		bne $cad5			bne 	_ATSInitialised
.caca	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.cacd	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.cacf	ad 27 04	lda $0427			lda 	StringPtr+1
.cad2	3a		dec a				dec 	a
.cad3	85 21		sta $21				sta 	zTempStr+1
.cad5					_ATSInitialised:
.cad5	68		pla				pla 								; get required count back.
.cad6	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.cad8	1a		inc a				inc 	a
.cad9	18		clc				clc
.cada	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.cadc	85 20		sta $20				sta 	zTempStr
.cade	a9 ff		lda #$ff			lda 	#$FF
.cae0	65 21		adc $21				adc 	zTempStr+1
.cae2	85 21		sta $21				sta 	zTempStr+1
.cae4	a9 00		lda #$00			lda 	#0 							; clear temp string.
.cae6	5a		phy				phy
.cae7	a8		tay				tay
.cae8	91 20		sta ($20),y			sta 	(zTempStr),y
.caea	7a		ply				ply
.caeb	1a		inc a				inc 	a 							; reset the write index.
.caec	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.caef	60		rts				rts
.caf0					WriteTempString:
.caf0	5a		phy				phy 								; save Y
.caf1	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.caf4	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.caf6	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.caf9	98		tya				tya 								; unchanged Y is now length
.cafa	a0 00		ldy #$00			ldy 	#0
.cafc	91 20		sta ($20),y			sta 	(zTempStr),y
.cafe	7a		ply				ply 								; restore Y and exit
.caff	60		rts				rts
.cb00					CreateTempStringCopy:
.cb00	da		phx				phx 								; save X
.cb01	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cb03	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.cb04	20 c5 ca	jsr $cac5			jsr 	AllocateTempString 			; allocate memory for temporary string.
.cb07	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cb09	c8		iny				iny
.cb0a	3a		dec a				dec 	a 							; make the actual length in charactes
.cb0b	3a		dec a				dec 	a
.cb0c	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.cb0e	81 20		sta ($20,x)			sta 	(zTempStr,x)
.cb10	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.cb12	09 00		ora #$00			ora 	#0 							; if zero already, exit
.cb14	f0 0d		beq $cb23			beq 	_CTSCExit
.cb16					_CTSCLoop:
.cb16	b1 16		lda ($16),y			lda 	(zCodePtr),y
.cb18	c8		iny				iny
.cb19	5a		phy				phy 								; save in Y
.cb1a	e8		inx				inx 								; bump index
.cb1b	9b		txy				txy 								; index into Y
.cb1c	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.cb1e	7a		ply				ply 								; restore Y
.cb1f	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.cb21	d0 f3		bne $cb16			bne 	_CTSCLoop
.cb23					_CTSCExit:
.cb23	fa		plx				plx 								; restore X
.cb24	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.cb25					MulInteger32:
.cb25	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.cb28	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.cb2b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cb2e	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.cb31	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb34	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.cb37	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb3a	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.cb3d	a9 00		lda #$00			lda 	#0
.cb3f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.cb42	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb45	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb48	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb4b					_BFMMultiply:
.cb4b	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.cb4e	29 01		and #$01			and 	#1
.cb50	f0 03		beq $cb55			beq 	_BFMNoAdd
.cb52	20 a0 c7	jsr $c7a0			jsr 	AddInteger32
.cb55					_BFMNoAdd:
.cb55	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.cb58	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.cb5b	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.cb5e	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.cb61	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.cb64	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.cb67	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.cb6a	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.cb6d	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.cb70	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.cb73	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.cb76	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.cb79	d0 d0		bne $cb4b			bne 	_BFMMultiply
.cb7b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.cb7c					DivInteger32:
.cb7c	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.cb7f	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.cb82	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.cb85	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.cb88	d0 02		bne $cb8c			bne 	_BFDOkay
.cb8a	80 fe		bra $cb8a		_error: bra _error
.cb8c					_BFDOkay:
.cb8c	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.cb8e	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.cb90	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.cb92	85 1c		sta $1c				sta 	zLTemp1+2
.cb94	85 1d		sta $1d				sta 	zLTemp1+3
.cb96	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.cb99	20 fa cb	jsr $cbfa			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.cb9c	da		phx				phx
.cb9d	e8		inx				inx
.cb9e	e8		inx				inx
.cb9f	e8		inx				inx
.cba0	e8		inx				inx
.cba1	e8		inx				inx
.cba2	e8		inx				inx
.cba3	20 fa cb	jsr $cbfa			jsr 	CheckIntegerNegate
.cba6	fa		plx				plx
.cba7	5a		phy				phy 								; Y is the counter
.cba8	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.cbaa					_BFDLoop:
.cbaa	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.cbad	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.cbb0	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.cbb3	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.cbb6	26 1a		rol $1a				rol 	zLTemp1
.cbb8	26 1b		rol $1b				rol 	zLTemp1+1
.cbba	26 1c		rol $1c				rol 	zLTemp1+2
.cbbc	26 1d		rol $1d				rol 	zLTemp1+3
.cbbe	38		sec				sec
.cbbf	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.cbc1	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.cbc4	48		pha				pha
.cbc5	a5 1b		lda $1b				lda 	zLTemp1+1
.cbc7	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cbca	48		pha				pha
.cbcb	a5 1c		lda $1c				lda 	zLTemp1+2
.cbcd	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cbd0	48		pha				pha
.cbd1	a5 1d		lda $1d				lda 	zLTemp1+3
.cbd3	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cbd6	90 15		bcc $cbed			bcc 	_BFDNoAdd
.cbd8	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.cbda	68		pla				pla
.cbdb	85 1c		sta $1c				sta 	zLTemp1+2
.cbdd	68		pla				pla
.cbde	85 1b		sta $1b				sta 	zLTemp1+1
.cbe0	68		pla				pla
.cbe1	85 1a		sta $1a				sta 	zLTemp1+0
.cbe3	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.cbe6	09 01		ora #$01			ora 	#1
.cbe8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cbeb	80 03		bra $cbf0			bra 	_BFDNext
.cbed					_BFDNoAdd:
.cbed	68		pla				pla 								; Throw away the intermediate calculations
.cbee	68		pla				pla
.cbef	68		pla				pla
.cbf0					_BFDNext:
.cbf0	88		dey				dey
.cbf1	d0 b7		bne $cbaa			bne 	_BFDLoop
.cbf3	7a		ply				ply 								; restore Y and exit
.cbf4	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.cbf7	b0 07		bcs $cc00			bcs		IntegerNegateAlways 			; negate the result
.cbf9	60		rts				rts
.cbfa					CheckIntegerNegate:
.cbfa	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cbfd	30 01		bmi $cc00			bmi 	IntegerNegateAlways
.cbff	60		rts				rts
.cc00					IntegerNegateAlways:
.cc00	ee 25 04	inc $0425			inc 	SignCount
.cc03	38		sec				sec
.cc04	a9 00		lda #$00			lda 	#0
.cc06	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cc09	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cc0c	a9 00		lda #$00			lda 	#0
.cc0e	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cc11	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cc14	a9 00		lda #$00			lda 	#0
.cc16	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cc19	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cc1c	a9 00		lda #$00			lda 	#0
.cc1e	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cc21	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cc24	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cc25					INTToString:
.cc25	48		pha				pha
.cc26	5a		phy				phy
.cc27	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.cc2a	10 08		bpl $cc34			bpl 		_ITSNotMinus
.cc2c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cc2e	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter
.cc31	20 00 cc	jsr $cc00			jsr 		IntegerNegateAlways 	; negate the number.
.cc34					_ITSNotMinus:
.cc34	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.cc36	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.cc39	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.cc3b					_ITSNextSubtractor:
.cc3b	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cc3d	8d 22 04	sta $0422			sta 		NumConvCount
.cc40					_ITSSubtract:
.cc40	38		sec				sec
.cc41	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.cc44	f9 9d cc	sbc $cc9d,y			sbc 		_ITSSubtractors+0,y
.cc47	48		pha				pha
.cc48	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.cc4b	f9 9e cc	sbc $cc9e,y			sbc 		_ITSSubtractors+1,y
.cc4e	48		pha				pha
.cc4f	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.cc52	f9 9f cc	sbc $cc9f,y			sbc 		_ITSSubtractors+2,y
.cc55	48		pha				pha
.cc56	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.cc59	f9 a0 cc	sbc $cca0,y			sbc 		_ITSSubtractors+3,y
.cc5c	90 14		bcc $cc72			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cc5e	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.cc61	68		pla				pla
.cc62	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cc65	68		pla				pla
.cc66	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cc69	68		pla				pla
.cc6a	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.cc6d	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.cc70	80 ce		bra $cc40			bra 		_ITSSubtract 			; go round again.
.cc72					_ITSCantSubtract:
.cc72	68		pla				pla 								; throw away interim answers
.cc73	68		pla				pla
.cc74	68		pla				pla
.cc75	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.cc78	c9 30		cmp #$30			cmp 		#"0"
.cc7a	d0 05		bne $cc81			bne 		_ITSOutputDigit
.cc7c	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cc7f	10 09		bpl $cc8a			bpl 		_ITSGoNextSubtractor
.cc81					_ITSOutputDigit:
.cc81	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.cc84	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.cc87	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter 		; output it.
.cc8a					_ITSGoNextSubtractor:
.cc8a	c8		iny				iny 								; next dword
.cc8b	c8		iny				iny
.cc8c	c8		iny				iny
.cc8d	c8		iny				iny
.cc8e	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.cc90	d0 a9		bne $cc3b			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cc92	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cc95	09 30		ora #$30			ora 		#"0"
.cc97	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter
.cc9a	7a		ply				ply 								; and exit
.cc9b	68		pla				pla
.cc9c	60		rts				rts
.cc9d					_ITSSubtractors:
>cc9d	00 ca 9a 3b					.dword 		1000000000
>cca1	00 e1 f5 05					.dword 		100000000
>cca5	80 96 98 00					.dword 		10000000
>cca9	40 42 0f 00					.dword 		1000000
>ccad	a0 86 01 00					.dword 		100000
>ccb1	10 27 00 00					.dword 		10000
>ccb5	e8 03 00 00					.dword 		1000
>ccb9	64 00 00 00					.dword 		100
>ccbd	0a 00 00 00					.dword 		10
.ccc1					_ITSSubtractorsEnd:
.ccc1					ITSOutputCharacter:
.ccc1	48		pha				pha
.ccc2	da		phx				phx
.ccc3	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.ccc6	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.ccc9	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cccb	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.ccce	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.ccd1	fa		plx				plx
.ccd2	68		pla				pla
.ccd3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.ccd4					IntFromString:
.ccd4	a0 00		ldy #$00			ldy 	#0
.ccd6	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.ccd9					IntFromStringY:
.ccd9	48		pha				pha
.ccda	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.ccdc	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ccdf	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cce2	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cce5	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cce8	a9 01		lda #$01			lda 	#1
.ccea	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cced					_IFSLoop:
.cced	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.ccef	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.ccf1	90 60		bcc $cd53			bcc 	_IFSExit
.ccf3	c9 3a		cmp #$3a			cmp 	#"9"+1
.ccf5	b0 5c		bcs $cd53			bcs 	_IFSExit
.ccf7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.ccfa	c9 0c		cmp #$0c			cmp 	#12
.ccfc	b0 5f		bcs $cd5d			bcs 	_IFSOverflow
.ccfe	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cd01	48		pha				pha
.cd02	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cd05	48		pha				pha
.cd06	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cd09	48		pha				pha
.cd0a	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cd0d	48		pha				pha
.cd0e	20 72 cd	jsr $cd72			jsr 	IFSX1ShiftLeft 				; double
.cd11	20 72 cd	jsr $cd72			jsr 	IFSX1ShiftLeft 				; x 4
.cd14	18		clc				clc 								; add saved value x 5
.cd15	68		pla				pla
.cd16	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cd19	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd1c	68		pla				pla
.cd1d	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.cd20	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd23	68		pla				pla
.cd24	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.cd27	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd2a	68		pla				pla
.cd2b	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.cd2e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd31	20 72 cd	jsr $cd72			jsr 	IFSX1ShiftLeft 				; x 10
.cd34	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.cd37	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.cd39	29 0f		and #$0f			and 	#15
.cd3b	c8		iny				iny
.cd3c	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cd3f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd42	90 a9		bcc $cced			bcc 	_IFSLoop
.cd44	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cd47	d0 a4		bne $cced			bne 	_IFSLoop
.cd49	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.cd4c	d0 9f		bne $cced			bne 	_IFSLoop
.cd4e	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.cd51	80 9a		bra $cced			bra 	_IFSLoop
.cd53					_IFSExit:
.cd53	98		tya				tya 								; get offset
.cd54					_IFSOkay:
.cd54	38		sec				sec
.cd55	ad 23 04	lda $0423			lda 	ExpTemp
.cd58	f0 01		beq $cd5b			beq 	_IFSSkipFail
.cd5a	18		clc				clc
.cd5b					_IFSSkipFail:
.cd5b	68		pla				pla 								; and exit.
.cd5c	60		rts				rts
.cd5d					_IFSOverflow:
.cd5d	20 16 c4	jsr $c416			jsr 	ERR_Handler
>cd60	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cd68	20 6f 76 65 72 66 6c 6f 77 00
.cd72					IFSX1ShiftLeft:
.cd72	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.cd75	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.cd78	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.cd7b	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.cd7e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.cd7f					FPSubtract:
.cd7f	48		pha				pha
.cd80	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.cd83	49 80		eor #$80			eor 	#$80
.cd85	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.cd88	68		pla				pla 								; --- and fall through ---
.cd89					FPAdd:
.cd89	48		pha				pha
.cd8a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.cd8d	d0 05		bne $cd94			bne 	_FPA_NegativeLHS
.cd8f	20 b1 cd	jsr $cdb1			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cd92	68		pla				pla
.cd93	60		rts				rts
.cd94					_FPA_NegativeLHS:
.cd94	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.cd97	49 80		eor #$80			eor 	#$80
.cd99	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd9c	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.cd9f	49 80		eor #$80			eor 	#$80
.cda1	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.cda4	20 b1 cd	jsr $cdb1			jsr 	FPAdd_Worker 				; do the add calculation.
.cda7	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.cdaa	49 80		eor #$80			eor 	#$80
.cdac	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cdaf	68		pla				pla
.cdb0	60		rts				rts
.cdb1					FPAdd_Worker:
.cdb1	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cdb4	70 08		bvs $cdbe			bvs 	_FPAWExit 					; no change.
.cdb6	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.cdb9	50 07		bvc $cdc2			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.cdbb	20 44 d0	jsr $d044			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.cdbe					_FPAWExit:
.cdbe	20 cc d0	jsr $d0cc			jsr 	FPUNormalise 				; normalise the result.
.cdc1	60		rts				rts
.cdc2					_FPAWMakeSame:
.cdc2	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.cdc5	38		sec				sec
.cdc6	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cdc9	f0 1b		beq $cde6			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cdcb	da		phx				phx 								; save X
.cdcc	90 06		bcc $cdd4			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cdce	e8		inx				inx
.cdcf	e8		inx				inx
.cdd0	e8		inx				inx
.cdd1	e8		inx				inx
.cdd2	e8		inx				inx
.cdd3	e8		inx				inx
.cdd4					_FPAWShiftA:
.cdd4	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cdd7	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cdda	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cddd	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cde0	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cde3	fa		plx				plx 								; restore original X
.cde4	80 dc		bra $cdc2			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cde6					_FPAW_DoArithmetic:
.cde6	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cde9	30 39		bmi $ce24			bmi 	_FPAW_BNegative
.cdeb	18		clc				clc
.cdec	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cdef	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cdf2	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cdf5	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cdf8	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cdfb	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cdfe	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce01	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.ce04	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce07	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ce0a	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.ce0d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce10	90 ac		bcc $cdbe			bcc 	_FPAWExit 					; no carry.
.ce12	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ce15	38		sec				sec
.ce16	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.ce19	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ce1c	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ce1f	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ce22	80 9a		bra $cdbe			bra 	_FPAWExit
.ce24					_FPAW_BNegative:
.ce24	38		sec				sec
.ce25	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ce28	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.ce2b	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce2e	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ce31	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.ce34	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce37	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce3a	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.ce3d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce40	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ce43	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.ce46	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce49	b0 0b		bcs $ce56			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.ce4b	20 71 d0	jsr $d071			jsr 	FPUNegateInteger			; negate the mantissa
.ce4e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.ce51	49 80		eor #$80			eor 	#$80
.ce53	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce56					_FPAWGoExit:
.ce56	4c be cd	jmp $cdbe			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.ce59					FPD_IsDivZero:
.ce59	80 fe		bra $ce59		_error: bra _error
.ce5b					FPDivide:
.ce5b	48		pha				pha
.ce5c	5a		phy				phy
.ce5d	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.ce60	70 f7		bvs $ce59			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.ce62	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.ce65	f0 03		beq $ce6a			beq 	_FPDCalculateExp
.ce67					_FPD_Exit:
.ce67	7a		ply				ply
.ce68	68		pla				pla
.ce69	60		rts				rts
.ce6a					_FPDCalculateExp:
.ce6a	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.ce6d	49 ff		eor #$ff			eor 	#$FF
.ce6f	1a		inc a				inc 	a
.ce70	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.ce73	20 67 cf	jsr $cf67			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.ce76	18		clc				clc 	 							; add 1 to the resulting exponent
.ce77	69 01		adc #$01			adc 	#1
.ce79	b0 65		bcs $cee0			bcs 	_FPD_Overflow 				; which can overflow.
.ce7b	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.ce7e	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.ce80	85 1a		sta $1a				sta 	zLTemp1+0
.ce82	85 1b		sta $1b				sta 	zLTemp1+1
.ce84	85 1c		sta $1c				sta 	zLTemp1+2
.ce86	85 1d		sta $1d				sta 	zLTemp1+3
.ce88	a0 20		ldy #$20			ldy 	#32 						; times round.
.ce8a					_FPD_Loop:
.ce8a	38		sec				sec 								; calculate X1-X2 stacking result because we might
.ce8b	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.ce8e	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.ce91	48		pha				pha
.ce92	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ce95	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.ce98	48		pha				pha
.ce99	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ce9c	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.ce9f	48		pha				pha
.cea0	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cea3	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cea6	90 17		bcc $cebf			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cea8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.ceab	68		pla				pla
.ceac	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ceaf	68		pla				pla
.ceb0	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ceb3	68		pla				pla
.ceb4	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ceb7	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.ceb9	09 80		ora #$80			ora 	#$80
.cebb	85 1d		sta $1d				sta 	zLTemp1+3
.cebd	80 03		bra $cec2			bra 	_FPD_Rotates
.cebf					_FPD_NoSubtract:
.cebf	68		pla				pla 								; throw away unwanted results
.cec0	68		pla				pla
.cec1	68		pla				pla
.cec2					_FPD_Rotates:
.cec2	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.cec5	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.cec8	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.cecb	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.cece	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.ced0	26 1b		rol $1b				rol 	zLTemp1+1
.ced2	26 1c		rol $1c				rol 	zLTemp1+2
.ced4	26 1d		rol $1d				rol 	zLTemp1+3
.ced6	90 02		bcc $ceda			bcc 	_FPD_NoCarry
.ced8	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.ceda					_FPD_NoCarry:
.ceda	88		dey				dey 								; do 32 times
.cedb	d0 ad		bne $ce8a			bne 	_FPD_Loop
.cedd	4c 44 cf	jmp $cf44			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cee0					_FPD_Overflow:
.cee0	4c 41 d1	jmp $d141			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cee3					FPMultiply:
.cee3	48		pha				pha
.cee4	5a		phy				phy
.cee5	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cee8	70 08		bvs $cef2			bvs 	_FPM_Exit
.ceea	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.ceed	50 06		bvc $cef5			bvc 	_FPM_CalcExponent
.ceef	20 44 d0	jsr $d044			jsr 	FPUCopyX2ToX1
.cef2					_FPM_Exit:
.cef2	7a		ply				ply
.cef3	68		pla				pla
.cef4	60		rts				rts
.cef5					_FPM_CalcExponent:
.cef5	18		clc				clc
.cef6	20 67 cf	jsr $cf67			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cef9	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.cefc	a9 00		lda #$00			lda 	#0
.cefe	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cf00	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cf02	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cf04	85 1d		sta $1d				sta 	zLTemp1+3
.cf06	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cf08					_FPM_Loop:
.cf08	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.cf0b	29 01		and #$01			and 	#1
.cf0d	18		clc				clc 								; clear carry for the long rotate.
.cf0e	f0 1d		beq $cf2d			beq 	_FPM_NoAddition
.cf10	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cf11	a5 1a		lda $1a				lda 	zLTemp1+0
.cf13	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cf16	85 1a		sta $1a				sta 	zLTemp1+0
.cf18	a5 1b		lda $1b				lda 	zLTemp1+1
.cf1a	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cf1d	85 1b		sta $1b				sta 	zLTemp1+1
.cf1f	a5 1c		lda $1c				lda 	zLTemp1+2
.cf21	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cf24	85 1c		sta $1c				sta 	zLTemp1+2
.cf26	a5 1d		lda $1d				lda 	zLTemp1+3
.cf28	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cf2b	85 1d		sta $1d				sta 	zLTemp1+3
.cf2d					_FPM_NoAddition:
.cf2d	66 1d		ror $1d				ror 	3+zLTemp1
.cf2f	66 1c		ror $1c				ror 	2+zLTemp1
.cf31	66 1b		ror $1b				ror 	1+zLTemp1
.cf33	66 1a		ror $1a				ror 	0+zLTemp1
.cf35	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cf38	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cf3b	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cf3e	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cf41	88		dey				dey
.cf42	d0 c4		bne $cf08			bne 	_FPM_Loop 					; do this 32 times.
.cf44					FPM_CopySignNormalize:
.cf44	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.cf46	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.cf49	a5 1b		lda $1b				lda 	zLTemp1+1
.cf4b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cf4e	a5 1c		lda $1c				lda 	zLTemp1+2
.cf50	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cf53	a5 1d		lda $1d				lda 	zLTemp1+3
.cf55	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cf58	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.cf5b	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.cf5e	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf61	20 cc d0	jsr $d0cc			jsr 	FPUNormalise 				; normalise and exit.
.cf64	7a		ply				ply
.cf65	68		pla				pla
.cf66	60		rts				rts
.cf67					FPCalculateExponent:
.cf67	18		clc				clc
.cf68	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.cf6b	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.cf6e	b0 08		bcs $cf78			bcs 	_FPCECarry 					; carry out ?
.cf70	10 03		bpl $cf75			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.cf72	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.cf74	60		rts				rts
.cf75					_FPCEExpZero:
.cf75	a9 00		lda #$00			lda 	#0
.cf77	60		rts				rts
.cf78					_FPCECarry:
.cf78	30 03		bmi $cf7d			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.cf7a	09 80		ora #$80			ora 	#$80 						; put in right range
.cf7c	60		rts				rts
.cf7d					_FPCEOverflow:
.cf7d	4c 41 d1	jmp $d141			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.cf80					FPFractionalPart:
.cf80	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.cf83	38		sec				sec 								; this flag tells us to keep the fractional part
.cf84	30 0f		bmi $cf95			bmi 	FPGetPart
.cf86	60		rts				rts
.cf87					FPIntegerPart:
.cf87	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.cf8a	18		clc				clc 								; this flag says keep the integer part.
.cf8b	30 08		bmi $cf95			bmi 	FPGetPart 					; -ve exponents are 0..127
.cf8d	48		pha				pha
.cf8e	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.cf90	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf93	68		pla				pla
.cf94	60		rts				rts
.cf95					FPGetPart:
.cf95	48		pha				pha
.cf96	5a		phy				phy 								; save Y
.cf97	08		php				php 								; save action
.cf98	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.cf9b	70 62		bvs $cfff			bvs 	_FPGP_Exit 					; then do nothing.
.cf9d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.cf9f	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.cfa1	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.cfa3	85 1c		sta $1c				sta 	zLTemp1+2
.cfa5	85 1d		sta $1d				sta 	zLTemp1+3
.cfa7	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.cfaa	38		sec				sec
.cfab	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.cfad	f0 12		beq $cfc1			beq 	_FPGP_NoShift 				; ... if any
.cfaf	c9 20		cmp #$20			cmp 	#32
.cfb1	90 02		bcc $cfb5			bcc 	_FPGP_NotMax
.cfb3	a9 20		lda #$20			lda 	#32 						; max of 32.
.cfb5					_FPGP_NotMax:
.cfb5	a8		tay				tay 								; Y is the mask shift count.
.cfb6					_FPGP_ShiftMask:
.cfb6	46 1d		lsr $1d				lsr 	3+zLTemp1
.cfb8	66 1c		ror $1c				ror 	2+zLTemp1
.cfba	66 1b		ror $1b				ror 	1+zLTemp1
.cfbc	66 1a		ror $1a				ror 	0+zLTemp1
.cfbe	88		dey				dey
.cfbf	d0 f5		bne $cfb6			bne 	_FPGP_ShiftMask
.cfc1					_FPGP_NoShift:
.cfc1	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.cfc3	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.cfc6					_FPGP_MaskLoop:
.cfc6	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.cfc9	28		plp				plp 								; if CC we keep the top part, so we
.cfca	08		php				php		 							; flip the mask.
.cfcb	b0 02		bcs $cfcf			bcs		_FPGP_NoFlip
.cfcd	49 ff		eor #$ff			eor 	#$FF
.cfcf					_FPGP_NoFlip:
.cfcf	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.cfd2	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cfd5	e8		inx				inx
.cfd6	c8		iny				iny
.cfd7	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.cfd9	d0 eb		bne $cfc6			bne 	_FPGP_MaskLoop
.cfdb	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.cfde	28		plp				plp
.cfdf	08		php				php 								; get action flag on the stack
.cfe0	90 05		bcc $cfe7			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.cfe2	a9 00		lda #$00			lda 	#0
.cfe4	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cfe7					_FPGP_NotFractional:
.cfe7	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.cfea	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cfed	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cff0	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cff3	f0 05		beq $cffa			beq 	_FPGP_Zero 					; if zero, return zero
.cff5	20 cc d0	jsr $d0cc			jsr 	FPUNormalise
.cff8	80 05		bra $cfff			bra 	_FPGP_Exit 					; and exit
.cffa					_FPGP_Zero:
.cffa	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cffc	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cfff					_FPGP_Exit:
.cfff	68		pla				pla 								; throw saved action flag.
.d000	7a		ply				ply
.d001	68		pla				pla
.d002	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.d003					FPCompare:
.d003	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.d006	48		pha				pha
.d007	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.d00a	48		pha				pha
.d00b	20 7f cd	jsr $cd7f			jsr 	FPSubtract 					; calculate X1-X2
.d00e	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.d011	70 2c		bvs $d03f			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.d013	68		pla				pla
.d014	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.d017	68		pla				pla
.d018	38		sec				sec
.d019	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.d01c	70 15		bvs $d033			bvs 	_FPCNotEqual				; overflow, can't be equal.
.d01e	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.d01f	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.d021	b0 10		bcs $d033			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.d023	38		sec				sec
.d024	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.d027	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.d029	b0 02		bcs $d02d			bcs 	_FPCNotRange 				; keep in range.
.d02b	a9 01		lda #$01			lda 	#1
.d02d					_FPCNotRange:
.d02d	38		sec				sec
.d02e	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.d031	b0 0e		bcs $d041			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.d033					_FPCNotEqual:
.d033	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.d036	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.d038	f0 02		beq $d03c			beq 	_FPCNE2
.d03a	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.d03c	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.d03d	80 04		bra $d043			bra 	_FPCExit
.d03f					_FPCPullZero:
.d03f	68		pla				pla 								; throw saved exponents
.d040	68		pla				pla
.d041					_FPCZero:
.d041	a9 00		lda #$00			lda 	#0 							; and return zero
.d043					_FPCExit:
.d043	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.d044					FPUCopyX2ToX1:
.d044	48		pha				pha
.d045	da		phx				phx
.d046	5a		phy				phy
.d047	a0 08		ldy #$08			ldy 	#8
.d049	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.d04c	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.d04f	e8		inx				inx
.d050	88		dey				dey
.d051	10 f6		bpl $d049			bpl 	_FPUC21
.d053	7a		ply				ply
.d054	fa		plx				plx
.d055	68		pla				pla
.d056	60		rts				rts
.d057					FPUSetInteger:
.d057	48		pha				pha
.d058	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.d05b	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.d05d	10 02		bpl $d061			bpl 	_FPUSIExtend
.d05f	a9 ff		lda #$ff			lda 	#$FF
.d061					_FPUSIExtend:
.d061	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.d064	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d067	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d06a	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.d06c	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d06f	68		pla				pla
.d070	60		rts				rts
.d071					FPUNegateInteger:
.d071	48		pha				pha
.d072	38		sec				sec
.d073	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.d075	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.d078	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d07b	a9 00		lda #$00			lda 	#0
.d07d	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.d080	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d083	a9 00		lda #$00			lda 	#0
.d085	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.d088	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d08b	a9 00		lda #$00			lda 	#0
.d08d	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.d090	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d093	68		pla				pla
.d094	60		rts				rts
.d095					FPUToFloat:
.d095	48		pha				pha
.d096	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.d099	29 0f		and #$0f			and 	#$0F
.d09b	f0 2d		beq $d0ca			beq 	_FPUFExit
.d09d	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.d09f	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d0a2	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.d0a4	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.d0a7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.d0aa	10 08		bpl $d0b4			bpl		_FPUFPositive
.d0ac	20 71 d0	jsr $d071			jsr 	FPUNegateInteger 			; negate the mantissa
.d0af	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.d0b1	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d0b4					_FPUFPositive:
.d0b4	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.d0b7	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.d0ba	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.d0bd	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.d0c0	d0 05		bne $d0c7			bne 	_FPUFNonZero
.d0c2	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.d0c4	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d0c7					_FPUFNonZero:
.d0c7	20 cc d0	jsr $d0cc			jsr 	FPUNormalise 				; normalise the floating point.
.d0ca					_FPUFExit:
.d0ca	68		pla				pla
.d0cb	60		rts				rts
.d0cc					FPUNormalise:
.d0cc	48		pha				pha
.d0cd	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.d0d0	70 20		bvs $d0f2			bvs 	_FPUNExit
.d0d2	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.d0d5	f0 16		beq $d0ed			beq 	_FPUNSetZero
.d0d7					_FPUNLoop:
.d0d7	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.d0da	30 16		bmi $d0f2			bmi 	_FPUNExit 					; if so, we are normalised.
.d0dc	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.d0df	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.d0e2	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.d0e5	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.d0e8	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.d0eb	d0 ea		bne $d0d7			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.d0ed					_FPUNSetZero:
.d0ed	a9 40		lda #$40			lda 	#$40
.d0ef	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.d0f2					_FPUNExit:
.d0f2	68		pla				pla
.d0f3	60		rts				rts
.d0f4					FPUToInteger:
.d0f4	48		pha				pha
.d0f5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.d0f8	29 01		and #$01			and 	#1
.d0fa	d0 3e		bne $d13a			bne 	_FPUTOI_Exit
.d0fc	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.d0ff	70 2b		bvs $d12c			bvs 	_FPUTOI_Zero
.d101	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.d104	10 26		bpl $d12c			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.d106	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.d108	b0 37		bcs $d141			bcs 	FP_Overflow
.d10a					_FPUToIToInteger:
.d10a	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.d10d	c9 a0		cmp #$a0			cmp 	#128+32
.d10f	f0 11		beq $d122			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.d111	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.d114	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.d117	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.d11a	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.d11d	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.d120	80 e8		bra $d10a			bra 	_FPUToIToInteger 			; keep going.
.d122					_FPUToICheckSign:
.d122	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.d125	10 13		bpl $d13a			bpl 	_FPUToI_Exit 				; exit if unsigned.
.d127	20 71 d0	jsr $d071			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.d12a	80 0e		bra $d13a			bra 	_FPUTOI_Exit
.d12c					_FPUTOI_Zero:
.d12c	a9 00		lda #$00			lda 	#0 							; return zero integer.
.d12e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d131	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d134	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d137	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d13a					_FPUToI_Exit:
.d13a	a9 01		lda #$01			lda 	#1 							; set type to integer
.d13c	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d13f	68		pla				pla
.d140	60		rts				rts
.d141					FP_Overflow:
.d141	80 fe		bra $d141		_error: bra _error
.d143					FPUTimes10:
.d143	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.d146	85 1a		sta $1a				sta 	ZLTemp1+0
.d148	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.d14b	85 1b		sta $1b				sta 	ZLTemp1+1
.d14d	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.d150	85 1c		sta $1c				sta 	ZLTemp1+2
.d152	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.d155	85 1d		sta $1d				sta 	ZLTemp1+3
.d157	20 9b d1	jsr $d19b			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.d15a	20 9b d1	jsr $d19b			jsr 	_FPUT_LSR_ZLTemp1
.d15d	18		clc				clc
.d15e	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.d161	65 1a		adc $1a				adc 	ZLTemp1+0
.d163	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d166	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.d169	65 1b		adc $1b				adc 	ZLTemp1+1
.d16b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d16e	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.d171	65 1c		adc $1c				adc 	ZLTemp1+2
.d173	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d176	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.d179	65 1d		adc $1d				adc 	ZLTemp1+3
.d17b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d17e	90 0f		bcc $d18f			bcc 	_FPUTimes10
.d180	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.d183	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.d186	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.d189	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.d18c	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.d18f					_FPUTimes10:
.d18f	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.d192	18		clc				clc
.d193	69 03		adc #$03			adc 	#3
.d195	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.d198	b0 a7		bcs $d141			bcs 	FP_Overflow 				; error
.d19a	60		rts				rts
.d19b					_FPUT_LSR_ZLTemp1:
.d19b	46 1d		lsr $1d				lsr 	ZLTemp1+3
.d19d	66 1c		ror $1c				ror 	ZLTemp1+2
.d19f	66 1b		ror $1b				ror 	ZLTemp1+1
.d1a1	66 1a		ror $1a				ror 	ZLTemp1+0
.d1a3	60		rts				rts
.d1a4					FPUScale10A:
.d1a4	5a		phy				phy
.d1a5	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.d1a7	f0 3d		beq $d1e6			beq 	_FPUScaleExit
.d1a9	da		phx				phx 								; save X
.d1aa	e8		inx				inx
.d1ab	e8		inx				inx
.d1ac	e8		inx				inx
.d1ad	e8		inx				inx
.d1ae	e8		inx				inx
.d1af	e8		inx				inx
.d1b0	a8		tay				tay 								; save power scalar in Y.
.d1b1	a9 00		lda #$00			lda 	#0
.d1b3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.d1b6	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d1b9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d1bc	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d1bf	a9 80		lda #$80			lda 	#$80
.d1c1	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d1c4	a9 81		lda #$81			lda 	#$81
.d1c6	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.d1c9	5a		phy				phy 								; save 10^n on stack.
.d1ca	c0 00		cpy #$00			cpy 	#0
.d1cc	10 05		bpl $d1d3			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.d1ce	98		tya				tya
.d1cf	49 ff		eor #$ff			eor 	#$FF
.d1d1	1a		inc a				inc 	a
.d1d2	a8		tay				tay
.d1d3					_FPUSAbs:
.d1d3	20 43 d1	jsr $d143			jsr 	FPUTimes10
.d1d6	88		dey				dey
.d1d7	d0 fa		bne $d1d3			bne 	_FPUSAbs 					; tos is now 10^|AC|
.d1d9	68		pla				pla 								; restore count in A
.d1da	fa		plx				plx 								; restore X pointing to number to scale.
.d1db	0a		asl a				asl 	a
.d1dc	b0 05		bcs $d1e3			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.d1de	20 e3 ce	jsr $cee3			jsr 	FPMultiply 					; if clear multiply.
.d1e1	80 03		bra $d1e6			bra		_FPUScaleExit
.d1e3					_FPUSDivide:
.d1e3	20 5b ce	jsr $ce5b			jsr 	FPDivide
.d1e6					_FPUScaleExit:
.d1e6	7a		ply				ply
.d1e7	60		rts				rts
.d1e8					FPUCopyToNext:
.d1e8	a0 06		ldy #$06			ldy 		#6
.d1ea	da		phx				phx
.d1eb					_FPUCopy1:
.d1eb	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.d1ee	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.d1f1	e8		inx				inx
.d1f2	88		dey				dey
.d1f3	d0 f6		bne $d1eb			bne 	_FPUCopy1
.d1f5	fa		plx				plx
.d1f6	60		rts				rts
.d1f7					FPUCopyFromNext:
.d1f7	a0 06		ldy #$06			ldy 		#6
.d1f9	da		phx				phx
.d1fa					_FPUCopy1:
.d1fa	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.d1fd	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.d200	e8		inx				inx
.d201	88		dey				dey
.d202	d0 f6		bne $d1fa			bne 	_FPUCopy1
.d204	fa		plx				plx
.d205	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.d206					FPToString:
.d206	48		pha				pha
.d207	5a		phy				phy
.d208	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.d20b	50 0a		bvc $d217			bvc 		_FPTSIsFloat 			; if zero,
.d20d					_FPTSZero:
.d20d	a9 30		lda #$30			lda 		#"0"
.d20f	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter
.d212					_FPTSExit:
.d212	7a		ply				ply
.d213	68		pla				pla
.d214	60		rts				rts
.d215	80 fb		bra $d212			bra 		_FPTSExit
.d217					_FPTSIsFloat:
.d217	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.d21a	10 0a		bpl $d226			bpl 		_FPTSNotSigned
.d21c	a9 00		lda #$00			lda 		#0 						; clear sign flag
.d21e	9d 05 03	sta $0305,x			sta 		XS_Type,x
.d221	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d223	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter
.d226					_FPTSNotSigned:
.d226	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.d229	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.d22b	b0 09		bcs $d236			bcs 		_FPTSExponent
.d22d	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.d22f	90 05		bcc $d236			bcc 		_FPTSExponent 			;
.d231					_FPTSStandard:
.d231	20 7a d2	jsr $d27a			jsr 		FPTOutputBody 			; output the body.
.d234	80 dc		bra $d212			bra 		_FPTSExit
.d236					_FPTSExponent:
.d236	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.d238	8d 24 04	sta $0424			sta 		ExpCount
.d23b					_FPTSExponentLoop:
.d23b	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.d23e	10 0e		bpl $d24e			bpl 		_FPTSTimes
.d240	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.d242	90 14		bcc $d258			bcc 		_FPTSScaledToExp
.d244	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.d246	20 a4 d1	jsr $d1a4			jsr 		FPUScale10A
.d249	ee 24 04	inc $0424			inc 		ExpCount
.d24c	80 ed		bra $d23b			bra 		_FPTSExponentLoop
.d24e					_FPTSTimes:
.d24e	a9 01		lda #$01			lda 		#1
.d250	20 a4 d1	jsr $d1a4			jsr 		FPUScale10A
.d253	ce 24 04	dec $0424			dec 		ExpCount
.d256	80 e3		bra $d23b			bra 		_FPTSExponentLoop
.d258					_FPTSScaledToExp:
.d258	20 7a d2	jsr $d27a			jsr 		FPTOutputBody 			; output the body.
.d25b	a9 65		lda #$65			lda 		#"e"					; output E
.d25d	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter
.d260	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.d263	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.d266	29 80		and #$80			and 		#$80 					; sign extend it
.d268	f0 02		beq $d26c			beq 		_FPTSSExt
.d26a	a9 ff		lda #$ff			lda 		#$FF
.d26c					_FPTSSExt:
.d26c	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.d26f	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.d272	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.d275	20 25 cc	jsr $cc25			jsr 		INTToString 			; output the exponent.
.d278	80 98		bra $d212			bra			_FPTSExit 				; and exit.
.d27a					FPTOutputBody:
.d27a	20 e8 d1	jsr $d1e8			jsr 		FPUCopyToNext 			; copy to next slot.
.d27d	20 f4 d0	jsr $d0f4			jsr 		FPUToInteger 			; convert to an integer
.d280	20 25 cc	jsr $cc25			jsr 		INTToString 			; output the main integer part.
.d283	20 f7 d1	jsr $d1f7			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d286	20 80 cf	jsr $cf80			jsr 		FPFractionalPart 		; get the decimal part.
.d289	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.d28c	70 3e		bvs $d2cc			bvs 		_FPTOExit 				; if not, exit now.
.d28e	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d290	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter
.d293					_FPOutLoop:
.d293	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.d296	70 1e		bvs $d2b6			bvs 		_FPStripZeros 			; strip trailing zeros
.d298	20 43 d1	jsr $d143			jsr 		FPUTimes10 				; multiply by 10
.d29b	20 e8 d1	jsr $d1e8			jsr 		FPUCopyToNext			; copy to next slot.
.d29e	20 f4 d0	jsr $d0f4			jsr 		FPUToInteger 			; convert to integer
.d2a1	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.d2a4	09 30		ora #$30			ora 		#"0"
.d2a6	20 c1 cc	jsr $ccc1			jsr 		ITSOutputCharacter
.d2a9	20 f7 d1	jsr $d1f7			jsr 		FPUCopyFromNext 		; get it back
.d2ac	20 80 cf	jsr $cf80			jsr 		FPFractionalPart 		; get fractional part
.d2af	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.d2b2	c9 0b		cmp #$0b			cmp 	 	#11
.d2b4	90 dd		bcc $d293			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d2b6					_FPStripZeros:
.d2b6	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.d2b9					_FPStripLoop:
.d2b9	88		dey				dey 								; back one, if at start then no strip
.d2ba	f0 10		beq $d2cc			beq 		_FPToExit
.d2bc	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.d2bf	c9 30		cmp #$30			cmp 		#"0"
.d2c1	f0 f6		beq $d2b9			beq 		_FPStripLoop
.d2c3	c8		iny				iny
.d2c4	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d2c6	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.d2c9	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.d2cc					_FPTOExit:
.d2cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d2cd					FPFromString:
.d2cd	48		pha				pha 								; push A
.d2ce	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d2d0	c9 2e		cmp #$2e			cmp 	#"."
.d2d2	f0 03		beq $d2d7			beq	 	_FPFIsDecimal
.d2d4	4c 3a d3	jmp $d33a			jmp 	_FPFNotDecimal
.d2d7					_FPFIsDecimal:
.d2d7	c8		iny				iny 								; consume the decimal.
.d2d8	20 95 d0	jsr $d095			jsr 	FPUToFloat 					; convert the integer to float.
.d2db	da		phx				phx 								; save X.
.d2dc	5a		phy				phy 								; save decimal start position
.d2dd	e8		inx				inx
.d2de	e8		inx				inx
.d2df	e8		inx				inx
.d2e0	e8		inx				inx
.d2e1	e8		inx				inx
.d2e2	e8		inx				inx
.d2e3	20 d9 cc	jsr $ccd9			jsr 	INTFromStringY 				; get the part after the DP.
.d2e6	20 95 d0	jsr $d095			jsr 	FPUToFloat 					; convert that to a float.
.d2e9	68		pla				pla 								; calculate - chars consumed.
.d2ea	8c 23 04	sty $0423			sty 	ExpTemp
.d2ed	38		sec				sec
.d2ee	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.d2f1	20 a4 d1	jsr $d1a4			jsr 	FPUScale10A 				; scale it by 10^AC
.d2f4	fa		plx				plx 								; restore original X
.d2f5	20 89 cd	jsr $cd89			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d2f8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.d2fa	c9 45		cmp #$45			cmp 	#"E"
.d2fc	f0 04		beq $d302			beq 	_FPFExponent
.d2fe	c9 65		cmp #$65			cmp 	#"e"
.d300	d0 38		bne $d33a			bne 	_FPFNotDecimal 				; no, then exit normally.
.d302					_FPFExponent:
.d302	c8		iny				iny 								; skip over E symbol.
.d303	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.d305	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d307	d0 01		bne $d30a			bne 	_FPFGotSign
.d309	c8		iny				iny 								; if it was - skip over it.
.d30a					_FPFGotSign:
.d30a	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d30b	da		phx				phx
.d30c	e8		inx				inx
.d30d	e8		inx				inx
.d30e	e8		inx				inx
.d30f	e8		inx				inx
.d310	e8		inx				inx
.d311	e8		inx				inx
.d312	20 d9 cc	jsr $ccd9			jsr 	INTFromStringY 				; get the exponent
.d315	fa		plx				plx 								; restore X.
.d316	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d319	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.d31c	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.d31f	d0 1b		bne $d33c			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d321	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d324	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d326	b0 14		bcs $d33c			bcs 	_FPFXOverflow
.d328	68		pla				pla 								; get direction
.d329	d0 09		bne $d334			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d32b	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d32e	49 ff		eor #$ff			eor 	#$FF
.d330	1a		inc a				inc 	a
.d331	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.d334					_FPFXScale:
.d334	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d337	20 a4 d1	jsr $d1a4			jsr 	FPUScale10A 				; scale by the exponent.
.d33a					_FPFNotDecimal:
.d33a	68		pla				pla
.d33b	60		rts				rts
.d33c					_FPFXOverflow:
.d33c	20 16 c4	jsr $c416			jsr 	ERR_Handler
>d33f	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d347	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.d34e					Unary_Rnd:
.d34e	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.d351	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; check right bracket.
.d354	20 87 c8	jsr $c887			jsr 	GetSignCurrent 				; get sign -1,0,1.
.d357	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.d359	30 10		bmi $d36b			bmi 	_URSetSeed
.d35b	f0 2c		beq $d389			beq 	_URMakeRandom 				; if zero return same number.
.d35d	da		phx				phx
.d35e	a2 00		ldx #$00			ldx 	#0
.d360	20 c6 d3	jsr $d3c6			jsr 	Random16
.d363	a2 02		ldx #$02			ldx 	#2
.d365	20 c6 d3	jsr $d3c6			jsr 	Random16
.d368	fa		plx				plx
.d369	80 1e		bra $d389			bra 	_URMakeRandom
.d36b					_URSetSeed:
.d36b	20 95 d0	jsr $d095			jsr 	FPUToFloat 					; make it a float to twiddle it.
.d36e	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.d371	8d 29 04	sta $0429			sta 	RandomSeed+0
.d374	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.d377	8d 2a 04	sta $042a			sta 	RandomSeed+1
.d37a	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.d37d	8d 2b 04	sta $042b			sta 	RandomSeed+2
.d380	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.d383	0a		asl a				asl 	a
.d384	49 db		eor #$db			eor 	#$DB
.d386	8d 2c 04	sta $042c			sta 	RandomSeed+3
.d389					_URMakeRandom:
.d389	ad 29 04	lda $0429			lda 	RandomSeed+0 				; check if seed is zero.
.d38c	0d 2a 04	ora $042a			ora 	RandomSeed+1
.d38f	0d 2b 04	ora $042b			ora 	RandomSeed+2
.d392	0d 2c 04	ora $042c			ora 	RandomSeed+3
.d395	d0 0a		bne $d3a1			bne 	_URNotZero
.d397	a9 47		lda #$47			lda 	#$47
.d399	8d 2a 04	sta $042a			sta 	RandomSeed+1				; if it is, make it non zero.
.d39c	a9 3d		lda #$3d			lda 	#$3D
.d39e	8d 2c 04	sta $042c			sta 	RandomSeed+3
.d3a1					_URNotZero:
.d3a1	ad 29 04	lda $0429			lda 	RandomSeed+0 				; copy seed into mantissa.
.d3a4	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.d3a7	ad 2a 04	lda $042a			lda 	RandomSeed+1
.d3aa	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.d3ad	ad 2b 04	lda $042b			lda 	RandomSeed+2
.d3b0	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.d3b3	ad 2c 04	lda $042c			lda 	RandomSeed+3
.d3b6	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.d3b9	a9 00		lda #$00			lda 	#$00 						; set type to float.
.d3bb	9d 05 03	sta $0305,x			sta 	XS_Type,x
.d3be	a9 80		lda #$80			lda 	#$80
.d3c0	9d 04 03	sta $0304,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.d3c3	4c cc d0	jmp $d0cc			jmp 	FPUNormalise
.d3c6					Random16:
.d3c6	5e 2a 04	lsr $042a,x			lsr 	RandomSeed+1,x				; shift seed right
.d3c9	7e 29 04	ror $0429,x			ror 	RandomSeed,x
.d3cc	90 08		bcc $d3d6			bcc 	_R16_NoXor
.d3ce	bd 2a 04	lda $042a,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.d3d1	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.d3d3	9d 2a 04	sta $042a,x			sta 	RandomSeed+1,x
.d3d6					_R16_NoXor:
.d3d6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.d3d7					Unary_Int:
.d3d7	20 b6 c5	jsr $c5b6			jsr 	EvaluateNumberX 			; get value
.d3da	20 b5 ca	jsr $cab5			jsr 	CheckNextRParen 			; check right bracket.
.d3dd	4c f4 d0	jmp $d0f4			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.d3e0					TIM_Error:
.d3e0	20 37 c2	jsr $c237			jsr 	IFT_UpLine 					; go up one line.
.d3e3	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.d3e5	80 02		bra $d3e9			bra 	TIM_ShowPrompt
.d3e7					TIM_NewCommand:
.d3e7	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.d3e9					TIM_ShowPrompt:
.d3e9	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.d3ec	20 fb c2	jsr $c2fb			jsr 	IFT_ReadLine	 			; get character, go to next line
.d3ef	20 5d c2	jsr $c25d			jsr 	IFT_NewLine					; go to next line.
.d3f2	86 10		stx $10				stx 	zTemp1 						; save line read address
.d3f4	84 11		sty $11				sty 	zTemp1+1
.d3f6	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.d3f8	b1 10		lda ($10),y			lda 	(zTemp1),y
.d3fa	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.d3fc	d0 01		bne $d3ff			bne 	TIM_NotDot
.d3fe	c8		iny				iny
.d3ff					TIM_NotDot:
.d3ff	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.d401	c9 52		cmp #$52			cmp 	#"R"						; show registers
.d403	f0 6b		beq $d470			beq 	TIM_ShowRegisters
.d405	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.d407	f0 12		beq $d41b			beq 	TIM_ShowMemory
.d409	c9 47		cmp #$47			cmp 	#"G"						; execute
.d40b	f0 49		beq $d456			beq 	TIM_Execute
.d40d	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.d40f	f0 07		beq $d418			beq 	TIM_GoLoadMemory
.d411	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.d413	d0 cb		bne $d3e0			bne 	TIM_Error
.d415	4c 93 d5	jmp $d593			jmp 	TIM_UpdateRegisters
.d418					TIM_GoLoadMemory:
.d418	4c c3 d5	jmp $d5c3			jmp 	TIM_LoadMemory
.d41b					TIM_ShowMemory:
.d41b	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d41e	b0 c0		bcs $d3e0			bcs 	TIM_Error
.d420	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.d422	85 12		sta $12				sta 	zTemp2
.d424	a5 15		lda $15				lda 	zTemp3+1
.d426	85 13		sta $13				sta 	zTemp2+1
.d428	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d42b	90 08		bcc $d435			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.d42d	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.d42f	85 14		sta $14				sta 	zTemp3
.d431	a5 13		lda $13				lda 	zTemp2+1
.d433	85 15		sta $15				sta 	zTemp3+1
.d435					_TIMSM_Start:
.d435	20 e7 d4	jsr $d4e7			jsr 	TIM_WriteLine 				; write one line of hex out
.d438	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.d43a	18		clc				clc
.d43b	69 10		adc #$10			adc 	#16
.d43d	85 12		sta $12				sta 	zTemp2
.d43f	90 02		bcc $d443			bcc 	_TIMSM_NoCarry
.d441	e6 13		inc $13				inc 	zTemp2+1
.d443					_TIMSM_NoCarry:
.d443	20 e2 c3	jsr $c3e2			jsr 	IF_CheckBreak 				; check CTL+C
.d446	d0 0b		bne $d453			bne 	_TIMSM_Ends 				; if pressed break out.
.d448	38		sec				sec 								; check past the end address in zTemp3
.d449	a5 14		lda $14				lda 	zTemp3
.d44b	e5 12		sbc $12				sbc 	zTemp2
.d44d	a5 15		lda $15				lda 	zTemp3+1
.d44f	e5 13		sbc $13				sbc 	zTemp2+1
.d451	10 e2		bpl $d435			bpl 	_TIMSM_Start
.d453					_TIMSM_Ends:
.d453	4c e7 d3	jmp $d3e7			jmp 	TIM_NewCommand
.d456					TIM_Execute:
.d456	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; get the execute address
.d459	b0 85		bcs $d3e0			bcs 	TIM_Error 					; not legitimate
.d45b	ae 36 04	ldx $0436			ldx 	TIM_SP 						; set up SP
.d45e	9a		txs				txs
.d45f	ad 31 04	lda $0431			lda 	TIM_SR 						; Status for PLP
.d462	48		pha				pha
.d463	ad 32 04	lda $0432			lda 	TIM_A 						; restore AXYZ
.d466	ae 33 04	ldx $0433			ldx 	TIM_X
.d469	ac 34 04	ldy $0434			ldy 	TIM_Y
.d46c	28		plp				plp 								; and PS Byte.
.d46d	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.d470					TIM_Start:
.d470					TIM_ShowRegisters:
.d470	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.d473	8d 30 04	sta $0430			sta 	TIM_IRQ+1
.d476	ad ff ff	lda $ffff			lda 	$FFFF
.d479	8d 2f 04	sta $042f			sta 	TIM_IRQ
.d47c	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.d47e					_TIMSR_Text:
.d47e	bd ae d4	lda $d4ae,x			lda 	_TIMSR_Label,x
.d481	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d484	e8		inx				inx
.d485	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.d487	d0 f5		bne $d47e			bne 	_TIMSR_Text
.d489	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.d48b					_TIMSR_Skip:
.d48b	e8		inx				inx
.d48c					_TIMSR_LoopSpace:
.d48c	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.d48e	b0 04		bcs $d494			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.d490	8a		txa				txa
.d491	4a		lsr a				lsr 	a
.d492	b0 05		bcs $d499			bcs 	_TIMSR_NoSpace
.d494					_TIMSR_Space:
.d494	a9 20		lda #$20			lda 	#" "
.d496	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d499					_TIMSR_NoSpace:
.d499	bd 2d 04	lda $042d,x			lda 	TIM_PC,x 					; output hex value.
.d49c	20 ce d4	jsr $d4ce			jsr 	TIM_WriteHex
.d49f	e8		inx				inx
.d4a0	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.d4a2	f0 e7		beq $d48b			beq 	_TIMSR_Skip
.d4a4	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.d4a6	d0 e4		bne $d48c			bne 	_TimSR_LoopSpace
.d4a8	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; new line
.d4ab	4c e7 d3	jmp $d3e7			jmp	 	TIM_NewCommand 				; new command.
.d4ae					_TIMSR_Label:
>d4ae	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>d4b6	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>d4c6	52
>d4c7	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.d4ce					_TIMSR_LabelEnd:
.d4ce					TIM_WriteHex:
.d4ce	48		pha				pha 								; save A
.d4cf	4a		lsr a				lsr 	a 							; shift MSB->LSB
.d4d0	4a		lsr a				lsr 	a
.d4d1	4a		lsr a				lsr 	a
.d4d2	4a		lsr a				lsr 	a
.d4d3	20 d7 d4	jsr $d4d7			jsr 	_TIMWH_Nibble 				; print MSB
.d4d6	68		pla				pla 								; restore and print LSB
.d4d7					_TIMWH_Nibble:
.d4d7	48		pha				pha
.d4d8	29 0f		and #$0f			and 	#15 						; mask out
.d4da	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.d4dc	90 02		bcc $d4e0			bcc 	_TIMWHNoLetter
.d4de	69 06		adc #$06			adc 	#6
.d4e0					_TIMWHNoLetter:
.d4e0	69 30		adc #$30			adc 	#48
.d4e2	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter 			; print it out.
.d4e5	68		pla				pla
.d4e6	60		rts				rts
.d4e7					TIM_WriteLine:
.d4e7	a9 2e		lda #$2e			lda 	#"." 						; prompt
.d4e9	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d4ec	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.d4ee	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d4f1	a5 13		lda $13				lda 	zTemp2+1 					; write address
.d4f3	20 ce d4	jsr $d4ce			jsr 	TIM_WriteHex
.d4f6	a5 12		lda $12				lda 	zTemp2
.d4f8	20 ce d4	jsr $d4ce			jsr 	TIM_WriteHex
.d4fb	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.d4fd					_TIMWL_Loop:
.d4fd	a9 20		lda #$20			lda 	#" "
.d4ff	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d502	b1 12		lda ($12),y			lda 	(zTemp2),y
.d504	20 ce d4	jsr $d4ce			jsr 	TIM_WriteHex
.d507	c8		iny				iny
.d508	c0 10		cpy #$10			cpy 	#16
.d50a	d0 f1		bne $d4fd			bne 	_TIMWL_Loop
.d50c	4c 5d c2	jmp $c25d			jmp 	IFT_NewLine 				; new line and exit
.d50f					TIM_GetHex:
.d50f	c8		iny				iny
.d510	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.d512	c9 20		cmp #$20			cmp 	#32
.d514	f0 f9		beq $d50f			beq 	TIM_GetHex
.d516	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.d518	f0 f5		beq $d50f			beq 	TIM_GetHex
.d51a	20 43 d5	jsr $d543			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.d51d	b0 23		bcs $d542			bcs 	_TIMGH_Exit					; if first bad then exit now.
.d51f	a9 00		lda #$00			lda 	#0 							; zero result
.d521	85 14		sta $14				sta 	zTemp3
.d523	85 15		sta $15				sta 	zTemp3+1
.d525					_TIM_GHLoop:
.d525	20 43 d5	jsr $d543			jsr 	TIM_GetHexCharacter 		; get next character
.d528	b0 17		bcs $d541			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.d52a	c8		iny				iny 								; skip over it.
.d52b	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.d52d	26 15		rol $15				rol 	zTemp3+1
.d52f	06 14		asl $14				asl 	zTemp3 						; now x 2
.d531	26 15		rol $15				rol 	zTemp3+1
.d533	06 14		asl $14				asl 	zTemp3						; now x 4
.d535	26 15		rol $15				rol 	zTemp3+1
.d537	06 14		asl $14				asl 	zTemp3 						; now x 8
.d539	26 15		rol $15				rol 	zTemp3+1
.d53b	05 14		ora $14				ora 	zTemp3 						; OR result in
.d53d	85 14		sta $14				sta 	zTemp3
.d53f	80 e4		bra $d525			bra 	_TIM_GHLoop 				; loop round again.
.d541					_TIMGH_Okay:
.d541	18		clc				clc
.d542					_TIMGH_Exit:
.d542	60		rts				rts
.d543					TIM_GetHexCharacter:
.d543	b1 10		lda ($10),y			lda 	(zTemp1),y
.d545	38		sec				sec
.d546	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d548	90 0e		bcc $d558			bcc 	_TIM_GHCFail
.d54a	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d54c	90 0b		bcc $d559			bcc 	_TIM_GHCExit
.d54e	c9 11		cmp #$11			cmp 	#65-48						; < A
.d550	90 06		bcc $d558			bcc		_TIM_GHCFail
.d552	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d554	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d556	90 01		bcc $d559			bcc		_TIM_GHCExit
.d558					_TIM_GHCFail:
.d558	38		sec				sec
.d559					_TIM_GHCExit:
.d559	60		rts				rts
.d55a					TIM_BreakVector:
.d55a	da		phx				phx									; save X/A on stack
.d55b	48		pha				pha
.d55c	ba		tsx				tsx 								; X points to S
.d55d	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d560	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d562	d0 03		bne $d567			bne 	_TIMBreak					; if set, it's BRK
.d564	68		pla				pla 								; abandon routine.
.d565	fa		plx				plx
.d566	40		rti				rti
.d567					_TIMBreak:
.d567	68		pla				pla 								; save A X Y and maybe Z
.d568	8d 32 04	sta $0432			sta 	TIM_A
.d56b	fa		plx				plx
.d56c	8e 33 04	stx $0433			stx 	TIM_X
.d56f	8c 34 04	sty $0434			sty 	TIM_Y
.d572	68		pla				pla 								; get Status Register
.d573	8d 31 04	sta $0431			sta 	TIM_SR
.d576	68		pla				pla
.d577	8d 2e 04	sta $042e			sta 	TIM_PC+1 					; save calling address
.d57a	68		pla				pla
.d57b	8d 2d 04	sta $042d			sta 	TIM_PC 						; high byte
.d57e	ad 2e 04	lda $042e			lda 	TIM_PC+1 					; dec PC to point right.
.d581	d0 03		bne $d586			bne 	_TIMDecrement 				; brk bumps it.
.d583	ce 2d 04	dec $042d			dec 	TIM_PC
.d586					_TIMDecrement:
.d586	ce 2e 04	dec $042e			dec 	TIM_PC+1
.d589	ba		tsx				tsx 								; and copy SP
.d58a	8e 36 04	stx $0436			stx 	TIM_SP
.d58d	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d58f	9a		txs				txs
.d590	4c 70 d4	jmp $d470			jmp 	TIM_Start 					; and start up TIM monitor.
.d593					TIM_UpdateRegisters:
.d593	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; PC
.d596	b0 28		bcs $d5c0			bcs 	_TIMURFail
.d598	a5 14		lda $14				lda 	zTemp3
.d59a	8d 2e 04	sta $042e			sta 	Tim_PC+1
.d59d	a5 15		lda $15				lda 	zTemp3+1
.d59f	8d 2d 04	sta $042d			sta 	Tim_PC
.d5a2	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; ignore IRQ
.d5a5	b0 19		bcs $d5c0			bcs 	_TIMURFail
.d5a7	a2 00		ldx #$00			ldx 	#0
.d5a9					_TIM_URLoop:
.d5a9	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d5ab	d0 01		bne $d5ae			bne 	_TIM_1
.d5ad	e8		inx				inx
.d5ae					_TIM_1:
.d5ae	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; registers
.d5b1	b0 0d		bcs $d5c0			bcs 	_TIMURFail
.d5b3	a5 14		lda $14				lda 	zTemp3
.d5b5	9d 31 04	sta $0431,x			sta 	Tim_SR,x
.d5b8	e8		inx				inx
.d5b9	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d5bb	d0 ec		bne $d5a9			bne 	_TIM_URLoop
.d5bd	4c e7 d3	jmp $d3e7			jmp 	TIM_NewCommand
.d5c0					_TIMURFail:
.d5c0	4c e0 d3	jmp $d3e0			jmp 	TIM_Error
.d5c3					TIM_LoadMemory:
.d5c3	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; target address => zTemp2
.d5c6	a5 14		lda $14				lda 	zTemp3
.d5c8	85 12		sta $12				sta 	zTemp2
.d5ca	a5 15		lda $15				lda 	zTemp3+1
.d5cc	85 13		sta $13				sta 	zTemp2+1
.d5ce					_TIM_LMLoop:
.d5ce	20 0f d5	jsr $d50f			jsr 	TIM_GetHex 					; next byte ?
.d5d1	b0 0e		bcs $d5e1			bcs 	_TIMLMDone 					; no more
.d5d3	a2 00		ldx #$00			ldx 	#0							; write out.
.d5d5	a5 14		lda $14				lda 	zTemp3
.d5d7	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d5d9	e6 12		inc $12				inc 	zTemp2 						; bump address
.d5db	d0 f1		bne $d5ce			bne 	_TIM_LMLoop
.d5dd	e6 13		inc $13				inc 	zTemp2+1
.d5df	80 ed		bra $d5ce			bra 	_TIM_LMLoop
.d5e1					_TIMLMDone:
.d5e1	4c e7 d3	jmp $d3e7			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d5e4	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	f2 c1						.word 	StartROM
>fffe	5a d5					.word TIM_BreakVector

;******  End of listing
