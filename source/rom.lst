
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 21 21:22:44 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/common/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0428					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>042a					Tim_SR:		.byte ? 						; Processor Status
>042b					Tim_A:		.byte ? 						; Processor Registers
>042c					Tim_X:		.byte ?
>042d					Tim_Y:		.byte ?
>042e					Tim_Z:		.byte ?
>042f					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	1b 0a 00 d7 b9 41 8a 42			.byte	$1b,$0a,$00,$d7,$b9,$41,$8a,$42
>1008	ba 8c b9 43 8a 41 64 fd			.byte	$ba,$8c,$b9,$43,$8a,$41,$64,$fd
>1010	03 32 ba bc ff 06 68 69			.byte	$03,$32,$ba,$bc,$ff,$06,$68,$69
>1018	20 21 00 00				.byte	$20,$21,$00,$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../common/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b2					lastUnaryFunction = $b2
.c000					VectorTable:
>c000	a7 c5					.word BinaryOp_And         ; $80 and
>c002	cf c5					.word BinaryOp_Or          ; $81 or
>c004	f7 c5					.word BinaryOp_Xor         ; $82 xor
>c006	f7 c5					.word BinaryOp_Eor         ; $83 eor
>c008	ae c0					.word NotImplemented       ; $84 =
>c00a	ae c0					.word NotImplemented       ; $85 <>
>c00c	ae c0					.word NotImplemented       ; $86 <
>c00e	ae c0					.word NotImplemented       ; $87 <=
>c010	ae c0					.word NotImplemented       ; $88 >
>c012	ae c0					.word NotImplemented       ; $89 >=
>c014	50 c6					.word BinaryOp_Add         ; $8a +
>c016	63 c6					.word BinaryOp_Subtract    ; $8b -
>c018	76 c6					.word BinaryOp_Multiply    ; $8c *
>c01a	89 c6					.word BinaryOp_Divide      ; $8d /
>c01c	ae c0					.word NotImplemented       ; $8e ^
>c01e	ae c0					.word NotImplemented       ; $8f if
>c020	ae c0					.word NotImplemented       ; $90 while
>c022	ae c0					.word NotImplemented       ; $91 repeat
>c024	ae c0					.word NotImplemented       ; $92 for
>c026	ae c0					.word NotImplemented       ; $93 then
>c028	ae c0					.word NotImplemented       ; $94 endif
>c02a	ae c0					.word NotImplemented       ; $95 wend
>c02c	ae c0					.word NotImplemented       ; $96 until
>c02e	ae c0					.word NotImplemented       ; $97 next
>c030	ae c0					.word NotImplemented       ; $98 not
>c032	ae c0					.word NotImplemented       ; $99 fn(
>c034	ae c0					.word NotImplemented       ; $9a abs(
>c036	ae c0					.word NotImplemented       ; $9b asc(
>c038	ae c0					.word NotImplemented       ; $9c int(
>c03a	ae c0					.word NotImplemented       ; $9d peek(
>c03c	ae c0					.word NotImplemented       ; $9e rnd(
>c03e	ae c0					.word NotImplemented       ; $9f usr(
>c040	ae c0					.word NotImplemented       ; $a0 left$(
>c042	ae c0					.word NotImplemented       ; $a1 right$(
>c044	ae c0					.word NotImplemented       ; $a2 mid$(
>c046	ae c0					.word NotImplemented       ; $a3 spc(
>c048	ae c0					.word NotImplemented       ; $a4 str$(
>c04a	ae c0					.word NotImplemented       ; $a5 val(
>c04c	ae c0					.word NotImplemented       ; $a6 len(
>c04e	ae c0					.word NotImplemented       ; $a7 hex$(
>c050	ae c0					.word NotImplemented       ; $a8 sin(
>c052	ae c0					.word NotImplemented       ; $a9 cos(
>c054	ae c0					.word NotImplemented       ; $aa tan(
>c056	ae c0					.word NotImplemented       ; $ab atn(
>c058	ae c0					.word NotImplemented       ; $ac exp(
>c05a	ae c0					.word NotImplemented       ; $ad log(
>c05c	ae c0					.word NotImplemented       ; $ae sqr(
>c05e	ae c0					.word NotImplemented       ; $af dec(
>c060	ae c0					.word NotImplemented       ; $b0 deek(
>c062	ae c0					.word NotImplemented       ; $b1 leek(
>c064	ae c0					.word NotImplemented       ; $b2 mod(
>c066	ae c0					.word NotImplemented       ; $b3 $(
>c068	ae c0					.word NotImplemented       ; $b4 $
>c06a	ae c0					.word NotImplemented       ; $b5 #(
>c06c	ae c0					.word NotImplemented       ; $b6 #
>c06e	ae c0					.word NotImplemented       ; $b7 %(
>c070	ae c0					.word NotImplemented       ; $b8 %
>c072	ae c0					.word NotImplemented       ; $b9 (
>c074	ae c0					.word NotImplemented       ; $ba )
>c076	ae c0					.word NotImplemented       ; $bb ,
>c078	ae c0					.word NotImplemented       ; $bc :
>c07a	ae c0					.word NotImplemented       ; $bd ;
>c07c	ae c0					.word NotImplemented       ; $be def
>c07e	ae c0					.word NotImplemented       ; $bf clr
>c080	ae c0					.word NotImplemented       ; $c1 data
>c082	ae c0					.word NotImplemented       ; $c2 read
>c084	ae c0					.word NotImplemented       ; $c3 dim
>c086	ae c0					.word NotImplemented       ; $c4 to
>c088	ae c0					.word NotImplemented       ; $c5 step
>c08a	ae c0					.word NotImplemented       ; $c6 gosub
>c08c	ae c0					.word NotImplemented       ; $c7 return
>c08e	ae c0					.word NotImplemented       ; $c8 goto
>c090	ae c0					.word NotImplemented       ; $c9 input
>c092	ae c0					.word NotImplemented       ; $ca let
>c094	ae c0					.word NotImplemented       ; $cb list
>c096	ae c0					.word NotImplemented       ; $cc new
>c098	ae c0					.word NotImplemented       ; $cd old
>c09a	ae c0					.word NotImplemented       ; $ce on
>c09c	ae c0					.word NotImplemented       ; $cf restore
>c09e	ae c0					.word NotImplemented       ; $d0 poke
>c0a0	ae c0					.word NotImplemented       ; $d1 print
>c0a2	ae c0					.word NotImplemented       ; $d2 run
>c0a4	ae c0					.word NotImplemented       ; $d3 stop
>c0a6	ae c0					.word NotImplemented       ; $d4 wait
>c0a8	ae c0					.word NotImplemented       ; $d5 doke
>c0aa	ae c0					.word NotImplemented       ; $d6 loke
>c0ac	ae c0					.word NotImplemented       ; $d7 assert
.c0ae					NotImplemented:
.c0ae	80 fe		bra $c0ae		_error: bra _error
>c0b0	53 79 6e 74 61 78 20 45			.text "Syntax Error",0
>c0b8	72 72 6f 72 00
.c0bd					BinaryPrecedence:
>c0bd	01					.byte 1    ; $80 and
>c0be	01					.byte 1    ; $81 or
>c0bf	01					.byte 1    ; $82 xor
>c0c0	01					.byte 1    ; $83 eor
>c0c1	02					.byte 2    ; $84 =
>c0c2	02					.byte 2    ; $85 <>
>c0c3	02					.byte 2    ; $86 <
>c0c4	02					.byte 2    ; $87 <=
>c0c5	02					.byte 2    ; $88 >
>c0c6	02					.byte 2    ; $89 >=
>c0c7	03					.byte 3    ; $8a +
>c0c8	03					.byte 3    ; $8b -
>c0c9	04					.byte 4    ; $8c *
>c0ca	04					.byte 4    ; $8d /
>c0cb	05					.byte 5    ; $8e ^
.c0cc					KeywordText:
>c0cc	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0cf	4f d2					.byte $4f,$d2                          ; $81 or
>c0d1	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0d4	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0d7	bd					.byte $bd                              ; $84 =
>c0d8	3c be					.byte $3c,$be                          ; $85 <>
>c0da	bc					.byte $bc                              ; $86 <
>c0db	3c bd					.byte $3c,$bd                          ; $87 <=
>c0dd	be					.byte $be                              ; $88 >
>c0de	3e bd					.byte $3e,$bd                          ; $89 >=
>c0e0	ab					.byte $ab                              ; $8a +
>c0e1	ad					.byte $ad                              ; $8b -
>c0e2	aa					.byte $aa                              ; $8c *
>c0e3	af					.byte $af                              ; $8d /
>c0e4	de					.byte $de                              ; $8e ^
>c0e5	49 c6					.byte $49,$c6                          ; $8f if
>c0e7	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0ec	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0f2	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0f5	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0f9	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0fe	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c102	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c107	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c10b	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c10e	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c111	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c115	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c119	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c11d	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c122	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c126	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c12a	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c130	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c137	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c13c	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c140	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c145	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c149	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c14d	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c152	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c156	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c15a	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c15e	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c162	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c166	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c16a	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c16e	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c172	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c177	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c17c	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c180	24 a8					.byte $24,$a8                          ; $b3 $(
>c182	a4					.byte $a4                              ; $b4 $
>c183	23 a8					.byte $23,$a8                          ; $b5 #(
>c185	a3					.byte $a3                              ; $b6 #
>c186	25 a8					.byte $25,$a8                          ; $b7 %(
>c188	a5					.byte $a5                              ; $b8 %
>c189	a8					.byte $a8                              ; $b9 (
>c18a	a9					.byte $a9                              ; $ba )
>c18b	ac					.byte $ac                              ; $bb ,
>c18c	ba					.byte $ba                              ; $bc :
>c18d	bb					.byte $bb                              ; $bd ;
>c18e	44 45 c6				.byte $44,$45,$c6                      ; $be def
>c191	43 4c d2				.byte $43,$4c,$d2                      ; $bf clr
>c194	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c1 data
>c198	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c2 read
>c19c	44 49 cd				.byte $44,$49,$cd                      ; $c3 dim
>c19f	54 cf					.byte $54,$cf                          ; $c4 to
>c1a1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c5 step
>c1a5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c6 gosub
>c1aa	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c7 return
>c1b0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c8 goto
>c1b4	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c9 input
>c1b9	4c 45 d4				.byte $4c,$45,$d4                      ; $ca let
>c1bc	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cb list
>c1c0	4e 45 d7				.byte $4e,$45,$d7                      ; $cc new
>c1c3	4f 4c c4				.byte $4f,$4c,$c4                      ; $cd old
>c1c6	4f ce					.byte $4f,$ce                          ; $ce on
>c1c8	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $cf restore
>c1cf	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d0 poke
>c1d3	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d1 print
>c1d8	52 55 ce				.byte $52,$55,$ce                      ; $d2 run
>c1db	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d3 stop
>c1df	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d4 wait
>c1e3	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d5 doke
>c1e7	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d6 loke
>c1eb	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d7 assert
>c1f1	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_dollarlparen = $b3
=$b4					token_dollar = $b4
=$b5					token_hashlparen = $b5
=$b6					token_hash = $b6
=$b7					token_percentlparen = $b7
=$b8					token_percent = $b8
=$b9					token_lparen = $b9
=$ba					token_rparen = $ba
=$bb					token_comma = $bb
=$bc					token_colon = $bc
=$bd					token_semicolon = $bd
=$be					token_def = $be
=$bf					token_clr = $bf
=$c1					token_data = $c1
=$c2					token_read = $c2
=$c3					token_dim = $c3
=$c4					token_to = $c4
=$c5					token_step = $c5
=$c6					token_gosub = $c6
=$c7					token_return = $c7
=$c8					token_goto = $c8
=$c9					token_input = $c9
=$ca					token_let = $ca
=$cb					token_list = $cb
=$cc					token_new = $cc
=$cd					token_old = $cd
=$ce					token_on = $ce
=$cf					token_restore = $cf
=$d0					token_poke = $d0
=$d1					token_print = $d1
=$d2					token_run = $d2
=$d3					token_stop = $d3
=$d4					token_wait = $d4
=$d5					token_doke = $d5
=$d6					token_loke = $d6
=$d7					token_assert = $d7

;******  Return to file: modules/hardware/em65816.asm

.c1f2					StartROM:
.c1f2	18		clc				clc
.c1f3	fb		xce				xce
.c1f4	c2 30		rep #$30			rep 	#$30
.c1f6	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1f9	1b		tcs				tcs
.c1fa	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1fc	c2 30		rep #$30			rep 	#$30
.c1fe	a9 00 00	lda #$0000			lda 	#$0000
.c201	aa		tax				tax
.c202	a8		tay				tay
.c203	e2 30		sep #$30			sep 	#$30
.c205	20 a9 c3	jsr $c3a9			jsr 	IF_Reset 					; reset external interface
.c208	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen
.c20b	4c f8 c3	jmp $c3f8		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c20e					IFT_ClearScreen:
.c20e	48		pha				pha
.c20f	da		phx				phx
.c210	5a		phy				phy
.c211	20 aa c3	jsr $c3aa			jsr 	IF_Home 					; home cursor
.c214	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c216					_IFT_CS0:
.c216	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c218					_IFT_CS1:
.c218	a9 20		lda #$20			lda 	#' '						; clear line.
.c21a	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c21d	88		dey				dey
.c21e	d0 f8		bne $c218			bne 	_IFT_CS1
.c220	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; next line down
.c223	ca		dex				dex
.c224	d0 f0		bne $c216			bne 	_IFT_CS0
.c226	7a		ply				ply
.c227	fa		plx				plx
.c228	68		pla				pla
.c229					IFT_HomeCursor:
.c229	48		pha				pha
.c22a	20 aa c3	jsr $c3aa			jsr 	IF_Home
.c22d	a9 00		lda #$00			lda 	#0
.c22f	8d 00 02	sta $0200			sta 	IFT_XCursor
.c232	8d 01 02	sta $0201			sta 	IFT_YCursor
.c235	68		pla				pla
.c236	60		rts				rts
.c237					IFT_UpLine:
.c237	48		pha				pha
.c238	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c23b	3a		dec a				dec 	a 							; line above
.c23c	30 03		bmi $c241			bmi 	_IFTULExit 					; too far, abort
.c23e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos					; set to that line.
.c241					_IFTULExit:
.c241	68		pla				pla
.c242	60		rts				rts
.c243					IFT_PrintCharacter:
.c243	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c245	f0 16		beq $c25d			beq 	IFT_NewLine
.c247	48		pha				pha
.c248	20 75 c2	jsr $c275			jsr 	IFT_UpperCase 				; make upper case
.c24b	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write out.
.c24e	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c251	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c254	c9 40		cmp #$40			cmp 	#IF_Width
.c256	d0 03		bne $c25b			bne 	_IFT_PCNotEOL
.c258	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; if so do new line.
.c25b					_IFT_PCNotEOL:
.c25b	68		pla				pla
.c25c	60		rts				rts
.c25d					IFT_NewLine:
.c25d	48		pha				pha
.c25e	20 bd c3	jsr $c3bd			jsr 	IF_NewLine 					; new line on actual screen.
.c261	a9 00		lda #$00			lda 	#0 							; reset x position
.c263	8d 00 02	sta $0200			sta 	IFT_XCursor
.c266	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c269	ad 01 02	lda $0201			lda 	IFT_YCursor
.c26c	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c26e	d0 03		bne $c273			bne 	_IFT_NL_NotEOS
.c270	20 80 c2	jsr $c280			jsr 	IFT_Scroll 					; scroll screen up.
.c273					_IFT_NL_NotEOS:
.c273	68		pla				pla
.c274	60		rts				rts
.c275					IFT_UpperCase:
.c275	c9 61		cmp #$61			cmp 	#"a"
.c277	90 06		bcc $c27f			bcc 	_IFT_UCExit
.c279	c9 7b		cmp #$7b			cmp 	#"z"+1
.c27b	b0 02		bcs $c27f			bcs 	_IFT_UCExit
.c27d	49 20		eor #$20			eor 	#$20
.c27f					_IFT_UCExit:
.c27f	60		rts				rts
.c280					IFT_Scroll:
.c280	48		pha				pha 								; save AXY
.c281	da		phx				phx
.c282	5a		phy				phy
.c283	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c285					_IFT_SLoop:
.c285	20 a5 c2	jsr $c2a5			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c288	e8		inx				inx
.c289	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c28b	d0 f8		bne $c285			bne 	_IFT_SLoop
.c28d	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c28f	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c292	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c294					_IFT_SBlank:
.c294	a9 20		lda #$20			lda 	#32
.c296	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c299	ca		dex				dex
.c29a	d0 f8		bne $c294			bne 	_IFT_SBlank
.c29c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c29e	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2a1	7a		ply				ply
.c2a2	fa		plx				plx
.c2a3	68		pla				pla
.c2a4	60		rts				rts
.c2a5					_IFT_ScrollLine:
.c2a5	da		phx				phx
.c2a6	da		phx				phx
.c2a7	8a		txa				txa 								; copy line into buffer.
.c2a8	1a		inc a				inc 	a 							; next line down.
.c2a9	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2ac	a2 00		ldx #$00			ldx 	#0
.c2ae					_IFTScrollCopy1:
.c2ae	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c2b1	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2b4	e8		inx				inx
.c2b5	e0 40		cpx #$40			cpx 	#IF_Width
.c2b7	d0 f5		bne $c2ae			bne 	_IFTScrollCopy1
.c2b9	68		pla				pla
.c2ba	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c2bd	a2 00		ldx #$00			ldx 	#0
.c2bf					_IFTScrollCopy2:
.c2bf	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2c2	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c2c5	e8		inx				inx
.c2c6	e0 40		cpx #$40			cpx 	#IF_Width
.c2c8	d0 f5		bne $c2bf			bne 	_IFTScrollCopy2
.c2ca	fa		plx				plx
.c2cb	60		rts				rts
.c2cc					IFT_SetYPos:
.c2cc	48		pha				pha
.c2cd	da		phx				phx
.c2ce	aa		tax				tax
.c2cf	20 29 c2	jsr $c229			jsr 	IFT_HomeCursor
.c2d2	e0 00		cpx #$00			cpx 	#0
.c2d4	f0 09		beq $c2df			beq 	_IFT_MOAExit
.c2d6					_IFT_MOALoop:
.c2d6	20 bd c3	jsr $c3bd			jsr 	IF_NewLine
.c2d9	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2dc	ca		dex				dex
.c2dd	d0 f7		bne $c2d6			bne		_IFT_MOALoop
.c2df					_IFT_MOAExit:
.c2df	fa		plx				plx
.c2e0	68		pla				pla
.c2e1	60		rts				rts
.c2e2					IFT_GetKeyCursor:
.c2e2	20 ea c2	jsr $c2ea			jsr 	_IFT_FlipCursor 			; reverse current
.c2e5					_IFT_GKCWait:
.c2e5	20 e7 c3	jsr $c3e7			jsr 	IF_GetKey 					; get key
.c2e8	f0 fb		beq $c2e5			beq 	_IFT_GKCWait
.c2ea					_IFT_FlipCursor:
.c2ea	48		pha				pha 								; save
.c2eb	20 cd c3	jsr $c3cd			jsr 	IF_Read 					; read
.c2ee	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f1	49 80		eor #$80			eor 	#$80 						; reverse
.c2f3	20 d6 c3	jsr $c3d6			jsr 	IF_Write 					; write
.c2f6	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c2f9	68		pla				pla
.c2fa	60		rts				rts
.c2fb					IFT_ReadLine:
.c2fb	48		pha				pha
.c2fc					_IFT_RLLoop:
.c2fc	20 e2 c2	jsr $c2e2			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2ff	c9 0d		cmp #$0d			cmp 	#13							; return
.c301	f0 7d		beq $c380			beq 	_IFT_RLExit
.c303	c9 20		cmp #$20			cmp 	#32 						; control character
.c305	90 05		bcc $c30c			bcc 	_IFT_Control
.c307	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.c30a	80 f0		bra $c2fc			bra 	_IFT_RLLoop
.c30c					_IFT_Control:
.c30c	c9 01		cmp #$01			cmp 	#"A"-64
.c30e	f0 26		beq $c336			beq 	_IFT_Left
.c310	c9 04		cmp #$04			cmp 	#"D"-64
.c312	f0 2e		beq $c342			beq 	_IFT_Right
.c314	c9 17		cmp #$17			cmp 	#"W"-64
.c316	f0 36		beq $c34e			beq 	_IFT_Up
.c318	c9 13		cmp #$13			cmp 	#"S"-64
.c31a	f0 3e		beq $c35a			beq 	_IFT_Down
.c31c	c9 08		cmp #$08			cmp 	#"H"-64
.c31e	f0 09		beq $c329			beq 	_IFT_Backspace
.c320	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c322	d0 d8		bne $c2fc			bne 	_IFT_RLLoop
.c324	20 0e c2	jsr $c20e			jsr 	IFT_ClearScreen				; clear CTL-Z
.c327	80 d3		bra $c2fc			bra 	_IFT_RLLoop
.c329					_IFT_Backspace:
.c329	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c32c	f0 ce		beq $c2fc			beq 	_IFT_RLLoop
.c32e	20 df c3	jsr $c3df			jsr 	IF_LeftOne
.c331	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c333	20 d6 c3	jsr $c3d6			jsr 	IF_Write
.c336					_IFT_Left:
.c336	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c339	10 29		bpl $c364			bpl 	_IFT_Reposition
.c33b	a9 3f		lda #$3f			lda 	#IF_Width-1
.c33d					_IFT_SetX:
.c33d	8d 00 02	sta $0200			sta 	IFT_XCursor
.c340	80 22		bra $c364			bra 	_IFT_Reposition
.c342					_IFT_Right:
.c342	ee 00 02	inc $0200			inc 	IFT_XCursor
.c345	ad 00 02	lda $0200			lda 	IFT_XCursor
.c348	49 40		eor #$40			eor 	#IF_Width
.c34a	f0 f1		beq $c33d			beq 	_IFT_SetX
.c34c	80 16		bra $c364			bra 	_IFT_Reposition
.c34e					_IFT_Up:
.c34e	ce 01 02	dec $0201			dec 	IFT_YCursor
.c351	10 11		bpl $c364			bpl 	_IFT_Reposition
.c353	a9 1f		lda #$1f			lda 	#IF_Height-1
.c355					_IFT_SetY:
.c355	8d 01 02	sta $0201			sta 	IFT_YCursor
.c358	80 0a		bra $c364			bra 	_IFT_Reposition
.c35a					_IFT_Down:
.c35a	ee 01 02	inc $0201			inc 	IFT_YCursor
.c35d	ad 01 02	lda $0201			lda 	IFT_YCursor
.c360	49 20		eor #$20			eor 	#IF_Height
.c362	f0 f1		beq $c355			beq 	_IFT_SetY
.c364					_IFT_Reposition:
.c364	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c367	48		pha				pha
.c368	ad 01 02	lda $0201			lda 	IFT_YCursor
.c36b	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c36e	68		pla				pla
.c36f	aa		tax				tax
.c370	e0 00		cpx #$00			cpx 	#0
.c372	f0 88		beq $c2fc			beq 	_IFT_RLLoop
.c374					_IFT_MoveRight:
.c374	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c377	ee 00 02	inc $0200			inc 	IFT_XCursor
.c37a	ca		dex				dex
.c37b	d0 f7		bne $c374			bne 	_IFT_MoveRight
.c37d	4c fc c2	jmp $c2fc			jmp 	_IFT_RLLoop
.c380					_IFT_RLExit:
.c380	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c383	20 cc c2	jsr $c2cc			jsr 	IFT_SetYPos
.c386	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c388					_IFT_RLRead:
.c388	20 cd c3	jsr $c3cd			jsr 	IF_Read
.c38b	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c38e	e8		inx				inx
.c38f	e0 40		cpx #$40			cpx 	#IF_Width
.c391	d0 f5		bne $c388			bne 	_IFT_RLRead
.c393					_IFT_RL_Trim:
.c393	ca		dex				dex 	 							; previous char
.c394	30 07		bmi $c39d			bmi 	_IFT_Found 					; gone too far
.c396	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c399	c9 20		cmp #$20			cmp 	#" "
.c39b	f0 f6		beq $c393			beq 	_IFT_RL_Trim
.c39d					_IFT_Found:
.c39d	e8		inx				inx 								; forward to non-space
.c39e	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c3a0	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c3a3	68		pla				pla
.c3a4	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c3a6	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c3a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c3a9					IF_Reset:
.c3a9	60		rts				rts
.c3aa					IF_Home:
.c3aa	48		pha				pha
.c3ab	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3ad	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3af	85 04		sta $04				sta 	IF_Pos
.c3b1	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3b3	85 05		sta $05				sta 	IF_Pos+1
.c3b5	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3b7	85 06		sta $06				sta 	IF_Pos+2
.c3b9	64 07		stz $07				stz 	IF_Pos+3
.c3bb	68		pla				pla
.c3bc	60		rts				rts
.c3bd					IF_NewLine:
.c3bd	48		pha				pha
.c3be	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3c0	18		clc				clc 								; down one line
.c3c1	a5 04		lda $04				lda 	IF_Pos
.c3c3	69 40		adc #$40			adc 	#64
.c3c5	85 04		sta $04				sta 	IF_Pos
.c3c7	90 02		bcc $c3cb			bcc 	_IF_NoCarry 				; carry through.
.c3c9	e6 05		inc $05				inc 	IF_Pos+1
.c3cb					_IF_NoCarry:
.c3cb	68		pla				pla
.c3cc	60		rts				rts
.c3cd					IF_Read:
.c3cd	5a		phy				phy 								; save current Y
.c3ce	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3d0	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3d2	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d4	7a		ply				ply									; restore Y
.c3d5	60		rts				rts
.c3d6					IF_Write:
.c3d6	5a		phy				phy 								; save current Y
.c3d7	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3d9	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3db	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3dd	7a		ply				ply									; restore Y
.c3de	60		rts				rts
.c3df					IF_LeftOne:
.c3df	c6 08		dec $08				dec 	IF_XPos
.c3e1	60		rts				rts
.c3e2					IF_CheckBreak:
.c3e2	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3e6	60		rts				rts
.c3e7					IF_GetKey:
.c3e7	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3eb	f0 08		beq $c3f5			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3ed	48		pha				pha 								; key pressed, clear queue.
.c3ee	a9 00		lda #$00			lda 	#0
.c3f0	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3f4	68		pla				pla
.c3f5					_IFGK_NoKey:
.c3f5	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3f8					BASIC_Start:
.c3f8	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c3fa	85 16		sta $16				sta 	zCodePtr+0
.c3fc	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c3fe	85 17		sta $17				sta 	zCodePtr+1
.c400	a9 00		lda #$00			lda 	#0
.c402	85 18		sta $18				sta 	zCodePtr+2
.c404	85 19		sta $19				sta 	zCodePtr+3
.c406	a0 03		ldy #$03			ldy 	#3
.c408	c8		iny				iny
.c409	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c40b	20 14 c4	jsr $c414			jsr 	EvaluateExpression
>c40e	02						.byte 	2
.c40f					SyntaxError:
.c40f					ERR_Handler:
.c40f	80 fe		bra $c40f			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c411					EVESyntax:
.c411	4c 0f c4	jmp $c40f			jmp 	SyntaxError
.c414					EvaluateExpression:
.c414	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c416					EvaluateExpressionX:
.c416	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c418					EvaluateExpressionXA:
.c418	48		pha				pha 								; save precedence on stack.
.c419	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c41b	f0 f4		beq $c411			beq 	EVESyntax 					; end of line, syntax error.
.c41d	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c41f	b0 03		bcs $c424			bcs 	_EVNotVariable
.c421	4c fe c4	jmp $c4fe			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c424					_EVNotVariable:
.c424	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c426	90 e9		bcc $c411			bcc 	EVESyntax
.c428	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c42a	b0 7b		bcs $c4a7			bcs 	_EVNotInteger
.c42c	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c42e	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c431	a9 00		lda #$00			lda 	#0
.c433	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c436	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c439	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c43c	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c43e	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c441					_EVCheckNextInteger:
.c441	c8		iny				iny
.c442	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c444	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c446	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c448	b0 0d		bcs $c457			bcs 	_EVCheckDecimal
.c44a	48		pha				pha 								; save it.
.c44b	20 02 c5	jsr $c502			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c44e	68		pla				pla
.c44f	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c452	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c455	80 ea		bra $c441			bra 	_EVCheckNextInteger
.c457					_EVCheckDecimal:
.c457	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c459	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c45b	d0 05		bne $c462			bne 	_EVGotAtom 					; no, get atom.
.c45d					_EVIsDecimal:
.c45d	20 32 c5	jsr $c532			jsr 	EVGetDecimal 				; extend to the decimal part.
.c460	80 00		bra $c462			bra 	_EVGotAtom 					; and continue to got atom.
.c462					_EVGotAtom:
.c462	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c464	10 3f		bpl $c4a5			bpl 	_EVExitDrop 				; must be a token.
.c466	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c468	b0 3b		bcs $c4a5			bcs 	_EVExitDrop
.c46a	68		pla				pla 								; get current precedence
.c46b	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c46d	da		phx				phx 								; save X
.c46e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c470	aa		tax				tax 								; put in X
.c471	bd 3d c0	lda $c03d,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c474	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c476	fa		plx				plx 								; restore X
.c477	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c479	90 2b		bcc $c4a6			bcc 	_EVExit 					; exit if too low.
.c47b	f0 29		beq $c4a6			beq 	_EVExit 					; exit if equals
.c47d	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c47f	48		pha				pha
.c480	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c482	48		pha				pha
.c483	c8		iny				iny
.c484	da		phx				phx 								; save current position
.c485	e8		inx				inx
.c486	e8		inx				inx
.c487	e8		inx				inx
.c488	e8		inx				inx
.c489	e8		inx				inx
.c48a	e8		inx				inx
.c48b	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c48d	20 18 c4	jsr $c418			jsr 	EvaluateExpressionXA 		; do the RHS.
.c490	fa		plx				plx 								; restore X
.c491	68		pla				pla 								; get the binary operator in A.
.c492	da		phx				phx 								; save X again
.c493	0a		asl a				asl 	a 							; double, lose the MSB.
.c494	aa		tax				tax									; put in X
.c495	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c498	85 1e		sta $1e				sta 	zGenPtr
.c49a	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c49d	85 1f		sta $1f				sta 	zGenPtr+1
.c49f	fa		plx				plx 								; restore X
.c4a0	20 ff c4	jsr $c4ff			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4a3	80 bd		bra $c462			bra 	_EVGotAtom 					; and loop back.
.c4a5					_EVExitDrop:
.c4a5	68		pla				pla
.c4a6					_EVExit:
.c4a6	60		rts				rts
.c4a7					_EVNotInteger:
.c4a7	c8		iny				iny
.c4a8	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4aa	d0 19		bne $c4c5			bne 	_EVNotMinus
.c4ac	20 83 c5	jsr $c583			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4af	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4b2	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4b4	f0 05		beq $c4bb			beq 	_EVMinusFloat
.c4b6	20 04 c8	jsr $c804			jsr 	IntegerNegateAlways 		; negation
.c4b9	80 a7		bra $c462			bra 	_EVGotAtom 					; and go back.
.c4bb					_EVMinusFloat:
.c4bb	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4be	49 80		eor #$80			eor 	#$80
.c4c0	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4c3	80 9d		bra $c462			bra 	_EVGotAtom
.c4c5					_EVNotMinus:
.c4c5	c9 b9		cmp #$b9			cmp 	#token_lparen 				; is it left parenthesis
.c4c7	d0 24		bne $c4ed			bne 	_EVNotParenthesis
.c4c9	20 16 c4	jsr $c416			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4cc	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4ce	c8		iny				iny
.c4cf	c9 ba		cmp #$ba			cmp 	#token_rparen 				; okay if right bracket.
.c4d1	f0 8f		beq $c462			beq 	_EVGotAtom
.c4d3	80 fe		bra $c4d3		_error: bra _error
>c4d5	4d 69 73 73 69 6e 67 20				.text	"Missing closing bracket",0
>c4dd	63 6c 6f 73 69 6e 67 20 62 72 61 63 6b 65 74 00
.c4ed					_EVNotParenthesis:
.c4ed	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4ef	d0 0c		bne $c4fd			bne 	_EVNotNot
.c4f1	20 83 c5	jsr $c583			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c4f4	20 09 cd	jsr $cd09			jsr 	FPUToInteger 				; make it an integer - if possible.
.c4f7	20 60 c5	jsr $c560			jsr 	NotInteger 					; do the not calculation
.c4fa	4c 62 c4	jmp $c462			jmp 	_EVGotAtom
.c4fd					_EVNotNot:
.c4fd	ea		nop				nop
.c4fe					_EVVariableHandler:
.c4fe	ea		nop				nop
.c4ff					EVGoZGenPtr:
.c4ff	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c502					EVShiftMantissaLeft6:
.c502	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c505	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c508	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c50b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c50e	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c511	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c514	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c517	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c51a	a9 00		lda #$00			lda 	#0
.c51c	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c51f	20 22 c5	jsr $c522			jsr 	_EVSMLShift 					; call it here to do it twice
.c522					_EVSMLShift:
.c522	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c525	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c528	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c52b	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c52e	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c531	60		rts				rts
.c532					EVGetDecimal:
.c532	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c534	8d 00 04	sta $0400			sta 	Num_Buffer
.c537	da		phx				phx
.c538	c8		iny				iny
.c539	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c53b	c8		iny				iny
.c53c	3a		dec a				dec 	a								; convert to a string length.
.c53d	3a		dec a				dec 	a
.c53e	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c540					_EVGDCopy:
.c540	48		pha				pha 									; save count
.c541	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c543	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c546	e8		inx				inx 									; forward ....
.c547	c8		iny				iny
.c548	68		pla				pla 									; get count
.c549	3a		dec a				dec 	a 								; until zero
.c54a	d0 f4		bne $c540			bne 	_EVGDCopy
.c54c	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c54f	fa		plx				plx 									; restore X
.c550	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c552	85 1e		sta $1e				sta 	zGenPtr
.c554	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c556	85 1f		sta $1f				sta 	zGenPtr+1
.c558	5a		phy				phy 									; save Y
.c559	a0 00		ldy #$00			ldy 	#0 								; start position
.c55b	20 fa ce	jsr $cefa			jsr 	FPFromString 					; convert current
.c55e	7a		ply				ply 									; restore Y
.c55f	60		rts				rts
.c560					NotInteger:
.c560	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c563	49 ff		eor #$ff			eor 	#$FF
.c565	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c568	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c56b	49 ff		eor #$ff			eor 	#$FF
.c56d	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c570	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c573	49 ff		eor #$ff			eor 	#$FF
.c575	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c578	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c57b	49 ff		eor #$ff			eor 	#$FF
.c57d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c580	60		rts				rts
.c581					EvaluateGetAtom:
.c581	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c583					EvaluateGetAtomX:
.c583	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c585	20 18 c4	jsr $c418			jsr 	EvaluateExpressionXA
.c588	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c58b	29 0f		and #$0f			and 	#15
.c58d	c9 02		cmp #$02			cmp 	#2
.c58f	b0 01		bcs $c592			bcs 	EvaluateType
.c591	60		rts				rts
.c592					EvaluateType:
.c592	80 fe		bra $c592		_error: bra _error
>c594	57 72 6f 6e 67 20 74 79				.text 	"Wrong type of data",0
>c59c	70 65 20 6f 66 20 64 61 74 61 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5a7					BinaryOp_And:
.c5a7	20 1f c6	jsr $c61f			jsr 	BinaryMakeBothInteger
.c5aa	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5ad	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5b0	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5b3	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5b6	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5b9	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5bc	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5bf	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5c2	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5c5	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5c8	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c5cb	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5ce	60		rts				rts
.c5cf					BinaryOp_Or:
.c5cf	20 1f c6	jsr $c61f			jsr 	BinaryMakeBothInteger
.c5d2	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5d5	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c5d8	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5db	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5de	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c5e1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5e4	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5e7	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c5ea	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5ed	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5f0	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c5f3	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5f6	60		rts				rts
.c5f7					BinaryOp_Eor:
.c5f7					BinaryOp_Xor:
.c5f7	20 1f c6	jsr $c61f			jsr 	BinaryMakeBothInteger
.c5fa	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5fd	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c600	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c603	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c606	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c609	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c60c	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c60f	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c612	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c615	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c618	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c61b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c61e	60		rts				rts
.c61f					BinaryMakeBothInteger:
.c61f	da		phx				phx 								; save X
.c620	e8		inx				inx
.c621	e8		inx				inx
.c622	e8		inx				inx
.c623	e8		inx				inx
.c624	e8		inx				inx
.c625	e8		inx				inx
.c626	20 2a c6	jsr $c62a			jsr 	BinaryMakeInteger 			; convert to integer.
.c629	fa		plx				plx 								; restore X and fall through.
.c62a					BinaryMakeInteger:
.c62a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c62d	29 0f		and #$0f			and 	#15 						; check type zero
.c62f	f0 04		beq $c635			beq 	_BMIConvert 				; if float convert to integer.
.c631	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c632	90 04		bcc $c638			bcc 	_BMIError
.c634	60		rts				rts
.c635					_BMIConvert:
.c635	4c 09 cd	jmp $cd09			jmp 	FPUToInteger 				; convert to integer
.c638					_BMIError:
.c638	80 fe		bra $c638		_error: bra _error
>c63a	4e 75 6d 65 72 69 63 20				.text 	"Numeric type required",0
>c642	74 79 70 65 20 72 65 71 75 69 72 65 64 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c650					BinaryOp_Add:
.c650	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c653	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c656	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c657	90 03		bcc $c65c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c659	4c 9c c6	jmp $c69c			jmp 	AddInteger32 							; so execute code at \1
.c65c					_BCFloat:
.c65c	20 e8 c6	jsr $c6e8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c65f	4c 8d c9	jmp $c98d			jmp 	FPAdd 							; and execute code at \2
.c662	60		rts				rts
.c663					BinaryOp_Subtract:
.c663	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c666	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c669	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c66a	90 03		bcc $c66f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c66c	4c c2 c6	jmp $c6c2			jmp 	SubInteger32 							; so execute code at \1
.c66f					_BCFloat:
.c66f	20 e8 c6	jsr $c6e8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c672	4c 83 c9	jmp $c983			jmp 	FPSubtract 							; and execute code at \2
.c675	60		rts				rts
.c676					BinaryOp_Multiply:
.c676	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c679	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c67c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c67d	90 03		bcc $c682			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c67f	4c 18 c7	jmp $c718			jmp 	MulInteger32 							; so execute code at \1
.c682					_BCFloat:
.c682	20 e8 c6	jsr $c6e8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c685	4c f8 ca	jmp $caf8			jmp 	FPMultiply 							; and execute code at \2
.c688	60		rts				rts
.c689					BinaryOp_Divide:
.c689	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c68c	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c68f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c690	90 03		bcc $c695			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c692	4c 6f c7	jmp $c76f			jmp 	DivInteger32 							; so execute code at \1
.c695					_BCFloat:
.c695	20 e8 c6	jsr $c6e8			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c698	4c 70 ca	jmp $ca70			jmp 	FPDivide 							; and execute code at \2
.c69b	60		rts				rts
.c69c					AddInteger32:
.c69c	18		clc				clc
.c69d	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c6a0	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c6a3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c6a6	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6a9	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c6ac	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c6af	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c6b2	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c6b5	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c6b8	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c6bb	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c6be	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c6c1	60		rts				rts
.c6c2					SubInteger32:
.c6c2	38		sec				sec
.c6c3	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c6c6	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c6c9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c6cc	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6cf	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c6d2	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c6d5	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c6d8	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c6db	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c6de	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c6e1	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c6e4	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c6e7	60		rts				rts
.c6e8					BinaryMakeBothFloat:
.c6e8	da		phx				phx 								; save X
.c6e9	e8		inx				inx
.c6ea	e8		inx				inx
.c6eb	e8		inx				inx
.c6ec	e8		inx				inx
.c6ed	e8		inx				inx
.c6ee	e8		inx				inx
.c6ef	20 f3 c6	jsr $c6f3			jsr 	BinaryMakeFloat 			; convert to float.
.c6f2	fa		plx				plx 								; restore X and fall through.
.c6f3					BinaryMakeFloat:
.c6f3	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c6f6	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c6f7	b0 04		bcs $c6fd			bcs 	_BMFConvert
.c6f9	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c6fa	b0 04		bcs $c700			bcs 	_BMFError
.c6fc	60		rts				rts
.c6fd					_BMFConvert:
.c6fd	4c aa cc	jmp $ccaa			jmp 	FPUToFloat 					; convert to float
.c700					_BMFError:
.c700	80 fe		bra $c700		_error: bra _error
>c702	4e 75 6d 65 72 69 63 20				.text 	"Numeric type required",0
>c70a	74 79 70 65 20 72 65 71 75 69 72 65 64 00

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c718					MulInteger32:
.c718	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c71b	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c71e	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c721	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c724	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c727	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c72a	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c72d	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c730	a9 00		lda #$00			lda 	#0
.c732	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c735	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c738	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c73b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c73e					_BFMMultiply:
.c73e	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c741	29 01		and #$01			and 	#1
.c743	f0 03		beq $c748			beq 	_BFMNoAdd
.c745	20 9c c6	jsr $c69c			jsr 	AddInteger32
.c748					_BFMNoAdd:
.c748	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c74b	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.c74e	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.c751	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.c754	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c757	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.c75a	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.c75d	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.c760	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c763	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.c766	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.c769	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.c76c	d0 d0		bne $c73e			bne 	_BFMMultiply
.c76e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c76f					DivInteger32:
.c76f	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c772	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c775	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c778	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c77b	d0 13		bne $c790			bne 	_BFDOkay
.c77d	80 fe		bra $c77d		_error: bra _error
>c77f	44 69 76 69 73 69 6f 6e				.text "Division by Zero",0
>c787	20 62 79 20 5a 65 72 6f 00
.c790					_BFDOkay:
.c790	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c792	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c794	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c796	85 1c		sta $1c				sta 	zLTemp1+2
.c798	85 1d		sta $1d				sta 	zLTemp1+3
.c79a	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.c79d	20 fe c7	jsr $c7fe			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c7a0	da		phx				phx
.c7a1	e8		inx				inx
.c7a2	e8		inx				inx
.c7a3	e8		inx				inx
.c7a4	e8		inx				inx
.c7a5	e8		inx				inx
.c7a6	e8		inx				inx
.c7a7	20 fe c7	jsr $c7fe			jsr 	CheckIntegerNegate
.c7aa	fa		plx				plx
.c7ab	5a		phy				phy 								; Y is the counter
.c7ac	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c7ae					_BFDLoop:
.c7ae	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c7b1	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c7b4	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c7b7	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c7ba	26 1a		rol $1a				rol 	zLTemp1
.c7bc	26 1b		rol $1b				rol 	zLTemp1+1
.c7be	26 1c		rol $1c				rol 	zLTemp1+2
.c7c0	26 1d		rol $1d				rol 	zLTemp1+3
.c7c2	38		sec				sec
.c7c3	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c7c5	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c7c8	48		pha				pha
.c7c9	a5 1b		lda $1b				lda 	zLTemp1+1
.c7cb	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c7ce	48		pha				pha
.c7cf	a5 1c		lda $1c				lda 	zLTemp1+2
.c7d1	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c7d4	48		pha				pha
.c7d5	a5 1d		lda $1d				lda 	zLTemp1+3
.c7d7	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c7da	90 15		bcc $c7f1			bcc 	_BFDNoAdd
.c7dc	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c7de	68		pla				pla
.c7df	85 1c		sta $1c				sta 	zLTemp1+2
.c7e1	68		pla				pla
.c7e2	85 1b		sta $1b				sta 	zLTemp1+1
.c7e4	68		pla				pla
.c7e5	85 1a		sta $1a				sta 	zLTemp1+0
.c7e7	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c7ea	09 01		ora #$01			ora 	#1
.c7ec	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7ef	80 03		bra $c7f4			bra 	_BFDNext
.c7f1					_BFDNoAdd:
.c7f1	68		pla				pla 								; Throw away the intermediate calculations
.c7f2	68		pla				pla
.c7f3	68		pla				pla
.c7f4					_BFDNext:
.c7f4	88		dey				dey
.c7f5	d0 b7		bne $c7ae			bne 	_BFDLoop
.c7f7	7a		ply				ply 								; restore Y and exit
.c7f8	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.c7fb	b0 07		bcs $c804			bcs		IntegerNegateAlways 			; negate the result
.c7fd	60		rts				rts
.c7fe					CheckIntegerNegate:
.c7fe	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c801	30 01		bmi $c804			bmi 	IntegerNegateAlways
.c803	60		rts				rts
.c804					IntegerNegateAlways:
.c804	ee 25 04	inc $0425			inc 	SignCount
.c807	38		sec				sec
.c808	a9 00		lda #$00			lda 	#0
.c80a	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c80d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c810	a9 00		lda #$00			lda 	#0
.c812	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c815	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c818	a9 00		lda #$00			lda 	#0
.c81a	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c81d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c820	a9 00		lda #$00			lda 	#0
.c822	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c825	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c828	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c829					INTToString:
.c829	48		pha				pha
.c82a	5a		phy				phy
.c82b	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.c82e	10 08		bpl $c838			bpl 		_ITSNotMinus
.c830	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c832	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.c835	20 04 c8	jsr $c804			jsr 		IntegerNegateAlways 	; negate the number.
.c838					_ITSNotMinus:
.c838	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.c83a	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.c83d	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.c83f					_ITSNextSubtractor:
.c83f	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c841	8d 22 04	sta $0422			sta 		NumConvCount
.c844					_ITSSubtract:
.c844	38		sec				sec
.c845	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.c848	f9 a1 c8	sbc $c8a1,y			sbc 		_ITSSubtractors+0,y
.c84b	48		pha				pha
.c84c	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.c84f	f9 a2 c8	sbc $c8a2,y			sbc 		_ITSSubtractors+1,y
.c852	48		pha				pha
.c853	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.c856	f9 a3 c8	sbc $c8a3,y			sbc 		_ITSSubtractors+2,y
.c859	48		pha				pha
.c85a	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.c85d	f9 a4 c8	sbc $c8a4,y			sbc 		_ITSSubtractors+3,y
.c860	90 14		bcc $c876			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c862	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.c865	68		pla				pla
.c866	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.c869	68		pla				pla
.c86a	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.c86d	68		pla				pla
.c86e	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.c871	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.c874	80 ce		bra $c844			bra 		_ITSSubtract 			; go round again.
.c876					_ITSCantSubtract:
.c876	68		pla				pla 								; throw away interim answers
.c877	68		pla				pla
.c878	68		pla				pla
.c879	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.c87c	c9 30		cmp #$30			cmp 		#"0"
.c87e	d0 05		bne $c885			bne 		_ITSOutputDigit
.c880	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c883	10 09		bpl $c88e			bpl 		_ITSGoNextSubtractor
.c885					_ITSOutputDigit:
.c885	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.c888	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.c88b	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter 		; output it.
.c88e					_ITSGoNextSubtractor:
.c88e	c8		iny				iny 								; next dword
.c88f	c8		iny				iny
.c890	c8		iny				iny
.c891	c8		iny				iny
.c892	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.c894	d0 a9		bne $c83f			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c896	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c899	09 30		ora #$30			ora 		#"0"
.c89b	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.c89e	7a		ply				ply 								; and exit
.c89f	68		pla				pla
.c8a0	60		rts				rts
.c8a1					_ITSSubtractors:
>c8a1	00 ca 9a 3b					.dword 		1000000000
>c8a5	00 e1 f5 05					.dword 		100000000
>c8a9	80 96 98 00					.dword 		10000000
>c8ad	40 42 0f 00					.dword 		1000000
>c8b1	a0 86 01 00					.dword 		100000
>c8b5	10 27 00 00					.dword 		10000
>c8b9	e8 03 00 00					.dword 		1000
>c8bd	64 00 00 00					.dword 		100
>c8c1	0a 00 00 00					.dword 		10
.c8c5					_ITSSubtractorsEnd:
.c8c5					ITSOutputCharacter:
.c8c5	48		pha				pha
.c8c6	da		phx				phx
.c8c7	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.c8ca	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c8cd	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c8cf	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.c8d2	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.c8d5	fa		plx				plx
.c8d6	68		pla				pla
.c8d7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c8d8					IntFromString:
.c8d8	a0 00		ldy #$00			ldy 	#0
.c8da	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.c8dd					IntFromStringY:
.c8dd	48		pha				pha
.c8de	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c8e0	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.c8e3	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c8e6	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c8e9	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c8ec	a9 01		lda #$01			lda 	#1
.c8ee	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c8f1					_IFSLoop:
.c8f1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c8f3	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c8f5	90 60		bcc $c957			bcc 	_IFSExit
.c8f7	c9 3a		cmp #$3a			cmp 	#"9"+1
.c8f9	b0 5c		bcs $c957			bcs 	_IFSExit
.c8fb	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c8fe	c9 0c		cmp #$0c			cmp 	#12
.c900	b0 5f		bcs $c961			bcs 	_IFSOverflow
.c902	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c905	48		pha				pha
.c906	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c909	48		pha				pha
.c90a	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c90d	48		pha				pha
.c90e	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c911	48		pha				pha
.c912	20 76 c9	jsr $c976			jsr 	IFSX1ShiftLeft 				; double
.c915	20 76 c9	jsr $c976			jsr 	IFSX1ShiftLeft 				; x 4
.c918	18		clc				clc 								; add saved value x 5
.c919	68		pla				pla
.c91a	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.c91d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c920	68		pla				pla
.c921	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.c924	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c927	68		pla				pla
.c928	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.c92b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c92e	68		pla				pla
.c92f	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.c932	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c935	20 76 c9	jsr $c976			jsr 	IFSX1ShiftLeft 				; x 10
.c938	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.c93b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c93d	29 0f		and #$0f			and 	#15
.c93f	c8		iny				iny
.c940	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.c943	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c946	90 a9		bcc $c8f1			bcc 	_IFSLoop
.c948	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c94b	d0 a4		bne $c8f1			bne 	_IFSLoop
.c94d	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.c950	d0 9f		bne $c8f1			bne 	_IFSLoop
.c952	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.c955	80 9a		bra $c8f1			bra 	_IFSLoop
.c957					_IFSExit:
.c957	98		tya				tya 								; get offset
.c958					_IFSOkay:
.c958	38		sec				sec
.c959	ad 23 04	lda $0423			lda 	ExpTemp
.c95c	f0 01		beq $c95f			beq 	_IFSSkipFail
.c95e	18		clc				clc
.c95f					_IFSSkipFail:
.c95f	68		pla				pla 								; and exit.
.c960	60		rts				rts
.c961					_IFSOverflow:
.c961	20 0f c4	jsr $c40f			jsr 	ERR_Handler
>c964	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c96c	20 6f 76 65 72 66 6c 6f 77 00
.c976					IFSX1ShiftLeft:
.c976	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.c979	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c97c	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c97f	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c982	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c983					FPSubtract:
.c983	48		pha				pha
.c984	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c987	49 80		eor #$80			eor 	#$80
.c989	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c98c	68		pla				pla 								; --- and fall through ---
.c98d					FPAdd:
.c98d	48		pha				pha
.c98e	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c991	d0 05		bne $c998			bne 	_FPA_NegativeLHS
.c993	20 b5 c9	jsr $c9b5			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c996	68		pla				pla
.c997	60		rts				rts
.c998					_FPA_NegativeLHS:
.c998	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c99b	49 80		eor #$80			eor 	#$80
.c99d	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9a0	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c9a3	49 80		eor #$80			eor 	#$80
.c9a5	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.c9a8	20 b5 c9	jsr $c9b5			jsr 	FPAdd_Worker 				; do the add calculation.
.c9ab	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.c9ae	49 80		eor #$80			eor 	#$80
.c9b0	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c9b3	68		pla				pla
.c9b4	60		rts				rts
.c9b5					FPAdd_Worker:
.c9b5	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c9b8	70 08		bvs $c9c2			bvs 	_FPAWExit 					; no change.
.c9ba	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c9bd	50 07		bvc $c9c6			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c9bf	20 59 cc	jsr $cc59			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c9c2					_FPAWExit:
.c9c2	20 e1 cc	jsr $cce1			jsr 	FPUNormalise 				; normalise the result.
.c9c5	60		rts				rts
.c9c6					_FPAWMakeSame:
.c9c6	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c9c9	38		sec				sec
.c9ca	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c9cd	f0 1b		beq $c9ea			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c9cf	da		phx				phx 								; save X
.c9d0	90 06		bcc $c9d8			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c9d2	e8		inx				inx
.c9d3	e8		inx				inx
.c9d4	e8		inx				inx
.c9d5	e8		inx				inx
.c9d6	e8		inx				inx
.c9d7	e8		inx				inx
.c9d8					_FPAWShiftA:
.c9d8	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c9db	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.c9de	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.c9e1	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.c9e4	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.c9e7	fa		plx				plx 								; restore original X
.c9e8	80 dc		bra $c9c6			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c9ea					_FPAW_DoArithmetic:
.c9ea	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c9ed	30 39		bmi $ca28			bmi 	_FPAW_BNegative
.c9ef	18		clc				clc
.c9f0	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c9f3	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c9f6	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c9f9	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c9fc	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c9ff	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca02	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ca05	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.ca08	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca0b	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ca0e	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.ca11	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca14	90 ac		bcc $c9c2			bcc 	_FPAWExit 					; no carry.
.ca16	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ca19	38		sec				sec
.ca1a	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.ca1d	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ca20	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ca23	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ca26	80 9a		bra $c9c2			bra 	_FPAWExit
.ca28					_FPAW_BNegative:
.ca28	38		sec				sec
.ca29	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ca2c	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.ca2f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ca32	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ca35	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.ca38	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca3b	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ca3e	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.ca41	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca44	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ca47	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.ca4a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca4d	b0 0b		bcs $ca5a			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.ca4f	20 86 cc	jsr $cc86			jsr 	FPUNegateInteger			; negate the mantissa
.ca52	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.ca55	49 80		eor #$80			eor 	#$80
.ca57	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca5a					_FPAWGoExit:
.ca5a	4c c2 c9	jmp $c9c2			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.ca5d					FPD_IsDivZero:
.ca5d	80 fe		bra $ca5d		_error: bra _error
>ca5f	44 69 76 69 73 69 6f 6e				.text 		"Division by zero",0
>ca67	20 62 79 20 7a 65 72 6f 00
.ca70					FPDivide:
.ca70	48		pha				pha
.ca71	5a		phy				phy
.ca72	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.ca75	70 e6		bvs $ca5d			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.ca77	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.ca7a	f0 03		beq $ca7f			beq 	_FPDCalculateExp
.ca7c					_FPD_Exit:
.ca7c	7a		ply				ply
.ca7d	68		pla				pla
.ca7e	60		rts				rts
.ca7f					_FPDCalculateExp:
.ca7f	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.ca82	49 ff		eor #$ff			eor 	#$FF
.ca84	1a		inc a				inc 	a
.ca85	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.ca88	20 7c cb	jsr $cb7c			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.ca8b	18		clc				clc 	 							; add 1 to the resulting exponent
.ca8c	69 01		adc #$01			adc 	#1
.ca8e	b0 65		bcs $caf5			bcs 	_FPD_Overflow 				; which can overflow.
.ca90	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.ca93	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.ca95	85 1a		sta $1a				sta 	zLTemp1+0
.ca97	85 1b		sta $1b				sta 	zLTemp1+1
.ca99	85 1c		sta $1c				sta 	zLTemp1+2
.ca9b	85 1d		sta $1d				sta 	zLTemp1+3
.ca9d	a0 20		ldy #$20			ldy 	#32 						; times round.
.ca9f					_FPD_Loop:
.ca9f	38		sec				sec 								; calculate X1-X2 stacking result because we might
.caa0	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.caa3	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.caa6	48		pha				pha
.caa7	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.caaa	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.caad	48		pha				pha
.caae	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cab1	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cab4	48		pha				pha
.cab5	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cab8	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cabb	90 17		bcc $cad4			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cabd	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cac0	68		pla				pla
.cac1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cac4	68		pla				pla
.cac5	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cac8	68		pla				pla
.cac9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cacc	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.cace	09 80		ora #$80			ora 	#$80
.cad0	85 1d		sta $1d				sta 	zLTemp1+3
.cad2	80 03		bra $cad7			bra 	_FPD_Rotates
.cad4					_FPD_NoSubtract:
.cad4	68		pla				pla 								; throw away unwanted results
.cad5	68		pla				pla
.cad6	68		pla				pla
.cad7					_FPD_Rotates:
.cad7	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.cada	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.cadd	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.cae0	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.cae3	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.cae5	26 1b		rol $1b				rol 	zLTemp1+1
.cae7	26 1c		rol $1c				rol 	zLTemp1+2
.cae9	26 1d		rol $1d				rol 	zLTemp1+3
.caeb	90 02		bcc $caef			bcc 	_FPD_NoCarry
.caed	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.caef					_FPD_NoCarry:
.caef	88		dey				dey 								; do 32 times
.caf0	d0 ad		bne $ca9f			bne 	_FPD_Loop
.caf2	4c 59 cb	jmp $cb59			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.caf5					_FPD_Overflow:
.caf5	4c 56 cd	jmp $cd56			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.caf8					FPMultiply:
.caf8	48		pha				pha
.caf9	5a		phy				phy
.cafa	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cafd	70 08		bvs $cb07			bvs 	_FPM_Exit
.caff	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cb02	50 06		bvc $cb0a			bvc 	_FPM_CalcExponent
.cb04	20 59 cc	jsr $cc59			jsr 	FPUCopyX2ToX1
.cb07					_FPM_Exit:
.cb07	7a		ply				ply
.cb08	68		pla				pla
.cb09	60		rts				rts
.cb0a					_FPM_CalcExponent:
.cb0a	18		clc				clc
.cb0b	20 7c cb	jsr $cb7c			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cb0e	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.cb11	a9 00		lda #$00			lda 	#0
.cb13	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cb15	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cb17	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cb19	85 1d		sta $1d				sta 	zLTemp1+3
.cb1b	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cb1d					_FPM_Loop:
.cb1d	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.cb20	29 01		and #$01			and 	#1
.cb22	18		clc				clc 								; clear carry for the long rotate.
.cb23	f0 1d		beq $cb42			beq 	_FPM_NoAddition
.cb25	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cb26	a5 1a		lda $1a				lda 	zLTemp1+0
.cb28	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cb2b	85 1a		sta $1a				sta 	zLTemp1+0
.cb2d	a5 1b		lda $1b				lda 	zLTemp1+1
.cb2f	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cb32	85 1b		sta $1b				sta 	zLTemp1+1
.cb34	a5 1c		lda $1c				lda 	zLTemp1+2
.cb36	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cb39	85 1c		sta $1c				sta 	zLTemp1+2
.cb3b	a5 1d		lda $1d				lda 	zLTemp1+3
.cb3d	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cb40	85 1d		sta $1d				sta 	zLTemp1+3
.cb42					_FPM_NoAddition:
.cb42	66 1d		ror $1d				ror 	3+zLTemp1
.cb44	66 1c		ror $1c				ror 	2+zLTemp1
.cb46	66 1b		ror $1b				ror 	1+zLTemp1
.cb48	66 1a		ror $1a				ror 	0+zLTemp1
.cb4a	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cb4d	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cb50	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cb53	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cb56	88		dey				dey
.cb57	d0 c4		bne $cb1d			bne 	_FPM_Loop 					; do this 32 times.
.cb59					FPM_CopySignNormalize:
.cb59	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.cb5b	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.cb5e	a5 1b		lda $1b				lda 	zLTemp1+1
.cb60	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb63	a5 1c		lda $1c				lda 	zLTemp1+2
.cb65	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb68	a5 1d		lda $1d				lda 	zLTemp1+3
.cb6a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb6d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.cb70	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.cb73	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb76	20 e1 cc	jsr $cce1			jsr 	FPUNormalise 				; normalise and exit.
.cb79	7a		ply				ply
.cb7a	68		pla				pla
.cb7b	60		rts				rts
.cb7c					FPCalculateExponent:
.cb7c	18		clc				clc
.cb7d	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.cb80	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.cb83	b0 08		bcs $cb8d			bcs 	_FPCECarry 					; carry out ?
.cb85	10 03		bpl $cb8a			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.cb87	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.cb89	60		rts				rts
.cb8a					_FPCEExpZero:
.cb8a	a9 00		lda #$00			lda 	#0
.cb8c	60		rts				rts
.cb8d					_FPCECarry:
.cb8d	30 03		bmi $cb92			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.cb8f	09 80		ora #$80			ora 	#$80 						; put in right range
.cb91	60		rts				rts
.cb92					_FPCEOverflow:
.cb92	4c 56 cd	jmp $cd56			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.cb95					FPFractionalPart:
.cb95	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.cb98	38		sec				sec 								; this flag tells us to keep the fractional part
.cb99	30 0f		bmi $cbaa			bmi 	FPGetPart
.cb9b	60		rts				rts
.cb9c					FPIntegerPart:
.cb9c	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.cb9f	18		clc				clc 								; this flag says keep the integer part.
.cba0	30 08		bmi $cbaa			bmi 	FPGetPart 					; -ve exponents are 0..127
.cba2	48		pha				pha
.cba3	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.cba5	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cba8	68		pla				pla
.cba9	60		rts				rts
.cbaa					FPGetPart:
.cbaa	48		pha				pha
.cbab	5a		phy				phy 								; save Y
.cbac	08		php				php 								; save action
.cbad	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.cbb0	70 62		bvs $cc14			bvs 	_FPGP_Exit 					; then do nothing.
.cbb2	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.cbb4	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.cbb6	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.cbb8	85 1c		sta $1c				sta 	zLTemp1+2
.cbba	85 1d		sta $1d				sta 	zLTemp1+3
.cbbc	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.cbbf	38		sec				sec
.cbc0	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.cbc2	f0 12		beq $cbd6			beq 	_FPGP_NoShift 				; ... if any
.cbc4	c9 20		cmp #$20			cmp 	#32
.cbc6	90 02		bcc $cbca			bcc 	_FPGP_NotMax
.cbc8	a9 20		lda #$20			lda 	#32 						; max of 32.
.cbca					_FPGP_NotMax:
.cbca	a8		tay				tay 								; Y is the mask shift count.
.cbcb					_FPGP_ShiftMask:
.cbcb	46 1d		lsr $1d				lsr 	3+zLTemp1
.cbcd	66 1c		ror $1c				ror 	2+zLTemp1
.cbcf	66 1b		ror $1b				ror 	1+zLTemp1
.cbd1	66 1a		ror $1a				ror 	0+zLTemp1
.cbd3	88		dey				dey
.cbd4	d0 f5		bne $cbcb			bne 	_FPGP_ShiftMask
.cbd6					_FPGP_NoShift:
.cbd6	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.cbd8	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.cbdb					_FPGP_MaskLoop:
.cbdb	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.cbde	28		plp				plp 								; if CC we keep the top part, so we
.cbdf	08		php				php		 							; flip the mask.
.cbe0	b0 02		bcs $cbe4			bcs		_FPGP_NoFlip
.cbe2	49 ff		eor #$ff			eor 	#$FF
.cbe4					_FPGP_NoFlip:
.cbe4	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.cbe7	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cbea	e8		inx				inx
.cbeb	c8		iny				iny
.cbec	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.cbee	d0 eb		bne $cbdb			bne 	_FPGP_MaskLoop
.cbf0	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.cbf3	28		plp				plp
.cbf4	08		php				php 								; get action flag on the stack
.cbf5	90 05		bcc $cbfc			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.cbf7	a9 00		lda #$00			lda 	#0
.cbf9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cbfc					_FPGP_NotFractional:
.cbfc	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.cbff	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cc02	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cc05	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cc08	f0 05		beq $cc0f			beq 	_FPGP_Zero 					; if zero, return zero
.cc0a	20 e1 cc	jsr $cce1			jsr 	FPUNormalise
.cc0d	80 05		bra $cc14			bra 	_FPGP_Exit 					; and exit
.cc0f					_FPGP_Zero:
.cc0f	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cc11	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc14					_FPGP_Exit:
.cc14	68		pla				pla 								; throw saved action flag.
.cc15	7a		ply				ply
.cc16	68		pla				pla
.cc17	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.cc18					FPCompare:
.cc18	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.cc1b	48		pha				pha
.cc1c	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.cc1f	48		pha				pha
.cc20	20 83 c9	jsr $c983			jsr 	FPSubtract 					; calculate X1-X2
.cc23	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.cc26	70 2c		bvs $cc54			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.cc28	68		pla				pla
.cc29	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.cc2c	68		pla				pla
.cc2d	38		sec				sec
.cc2e	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.cc31	70 15		bvs $cc48			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cc33	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cc34	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cc36	b0 10		bcs $cc48			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cc38	38		sec				sec
.cc39	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.cc3c	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.cc3e	b0 02		bcs $cc42			bcs 	_FPCNotRange 				; keep in range.
.cc40	a9 01		lda #$01			lda 	#1
.cc42					_FPCNotRange:
.cc42	38		sec				sec
.cc43	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cc46	b0 0e		bcs $cc56			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cc48					_FPCNotEqual:
.cc48	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cc4b	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cc4d	f0 02		beq $cc51			beq 	_FPCNE2
.cc4f	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cc51	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cc52	80 04		bra $cc58			bra 	_FPCExit
.cc54					_FPCPullZero:
.cc54	68		pla				pla 								; throw saved exponents
.cc55	68		pla				pla
.cc56					_FPCZero:
.cc56	a9 00		lda #$00			lda 	#0 							; and return zero
.cc58					_FPCExit:
.cc58	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cc59					FPUCopyX2ToX1:
.cc59	48		pha				pha
.cc5a	da		phx				phx
.cc5b	5a		phy				phy
.cc5c	a0 08		ldy #$08			ldy 	#8
.cc5e	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.cc61	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cc64	e8		inx				inx
.cc65	88		dey				dey
.cc66	10 f6		bpl $cc5e			bpl 	_FPUC21
.cc68	7a		ply				ply
.cc69	fa		plx				plx
.cc6a	68		pla				pla
.cc6b	60		rts				rts
.cc6c					FPUSetInteger:
.cc6c	48		pha				pha
.cc6d	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cc70	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cc72	10 02		bpl $cc76			bpl 	_FPUSIExtend
.cc74	a9 ff		lda #$ff			lda 	#$FF
.cc76					_FPUSIExtend:
.cc76	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cc79	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cc7c	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cc7f	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cc81	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cc84	68		pla				pla
.cc85	60		rts				rts
.cc86					FPUNegateInteger:
.cc86	48		pha				pha
.cc87	38		sec				sec
.cc88	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cc8a	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cc8d	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cc90	a9 00		lda #$00			lda 	#0
.cc92	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.cc95	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cc98	a9 00		lda #$00			lda 	#0
.cc9a	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.cc9d	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cca0	a9 00		lda #$00			lda 	#0
.cca2	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.cca5	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cca8	68		pla				pla
.cca9	60		rts				rts
.ccaa					FPUToFloat:
.ccaa	48		pha				pha
.ccab	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.ccae	29 0f		and #$0f			and 	#$0F
.ccb0	f0 2d		beq $ccdf			beq 	_FPUFExit
.ccb2	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.ccb4	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ccb7	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.ccb9	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.ccbc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.ccbf	10 08		bpl $ccc9			bpl		_FPUFPositive
.ccc1	20 86 cc	jsr $cc86			jsr 	FPUNegateInteger 			; negate the mantissa
.ccc4	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.ccc6	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ccc9					_FPUFPositive:
.ccc9	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cccc	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cccf	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.ccd2	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.ccd5	d0 05		bne $ccdc			bne 	_FPUFNonZero
.ccd7	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.ccd9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ccdc					_FPUFNonZero:
.ccdc	20 e1 cc	jsr $cce1			jsr 	FPUNormalise 				; normalise the floating point.
.ccdf					_FPUFExit:
.ccdf	68		pla				pla
.cce0	60		rts				rts
.cce1					FPUNormalise:
.cce1	48		pha				pha
.cce2	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cce5	70 20		bvs $cd07			bvs 	_FPUNExit
.cce7	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.ccea	f0 16		beq $cd02			beq 	_FPUNSetZero
.ccec					_FPUNLoop:
.ccec	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.ccef	30 16		bmi $cd07			bmi 	_FPUNExit 					; if so, we are normalised.
.ccf1	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.ccf4	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.ccf7	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.ccfa	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.ccfd	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.cd00	d0 ea		bne $ccec			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cd02					_FPUNSetZero:
.cd02	a9 40		lda #$40			lda 	#$40
.cd04	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.cd07					_FPUNExit:
.cd07	68		pla				pla
.cd08	60		rts				rts
.cd09					FPUToInteger:
.cd09	48		pha				pha
.cd0a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.cd0d	29 01		and #$01			and 	#1
.cd0f	d0 3e		bne $cd4f			bne 	_FPUTOI_Exit
.cd11	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.cd14	70 2b		bvs $cd41			bvs 	_FPUTOI_Zero
.cd16	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.cd19	10 26		bpl $cd41			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.cd1b	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.cd1d	b0 37		bcs $cd56			bcs 	FP_Overflow
.cd1f					_FPUToIToInteger:
.cd1f	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.cd22	c9 a0		cmp #$a0			cmp 	#128+32
.cd24	f0 11		beq $cd37			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.cd26	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.cd29	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cd2c	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cd2f	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cd32	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cd35	80 e8		bra $cd1f			bra 	_FPUToIToInteger 			; keep going.
.cd37					_FPUToICheckSign:
.cd37	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.cd3a	10 13		bpl $cd4f			bpl 	_FPUToI_Exit 				; exit if unsigned.
.cd3c	20 86 cc	jsr $cc86			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.cd3f	80 0e		bra $cd4f			bra 	_FPUTOI_Exit
.cd41					_FPUTOI_Zero:
.cd41	a9 00		lda #$00			lda 	#0 							; return zero integer.
.cd43	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd46	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd49	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cd4c	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cd4f					_FPUToI_Exit:
.cd4f	a9 01		lda #$01			lda 	#1 							; set type to integer
.cd51	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd54	68		pla				pla
.cd55	60		rts				rts
.cd56					FP_Overflow:
.cd56	80 fe		bra $cd56		_error: bra _error
>cd58	46 6c 6f 61 74 69 6e 67				.text 	"Floating Point overflow",0
>cd60	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.cd70					FPUTimes10:
.cd70	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.cd73	85 1a		sta $1a				sta 	ZLTemp1+0
.cd75	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cd78	85 1b		sta $1b				sta 	ZLTemp1+1
.cd7a	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cd7d	85 1c		sta $1c				sta 	ZLTemp1+2
.cd7f	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cd82	85 1d		sta $1d				sta 	ZLTemp1+3
.cd84	20 c8 cd	jsr $cdc8			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.cd87	20 c8 cd	jsr $cdc8			jsr 	_FPUT_LSR_ZLTemp1
.cd8a	18		clc				clc
.cd8b	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.cd8e	65 1a		adc $1a				adc 	ZLTemp1+0
.cd90	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cd93	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cd96	65 1b		adc $1b				adc 	ZLTemp1+1
.cd98	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cd9b	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cd9e	65 1c		adc $1c				adc 	ZLTemp1+2
.cda0	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cda3	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cda6	65 1d		adc $1d				adc 	ZLTemp1+3
.cda8	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cdab	90 0f		bcc $cdbc			bcc 	_FPUTimes10
.cdad	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cdb0	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cdb3	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cdb6	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cdb9	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.cdbc					_FPUTimes10:
.cdbc	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.cdbf	18		clc				clc
.cdc0	69 03		adc #$03			adc 	#3
.cdc2	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cdc5	b0 8f		bcs $cd56			bcs 	FP_Overflow 				; error
.cdc7	60		rts				rts
.cdc8					_FPUT_LSR_ZLTemp1:
.cdc8	46 1d		lsr $1d				lsr 	ZLTemp1+3
.cdca	66 1c		ror $1c				ror 	ZLTemp1+2
.cdcc	66 1b		ror $1b				ror 	ZLTemp1+1
.cdce	66 1a		ror $1a				ror 	ZLTemp1+0
.cdd0	60		rts				rts
.cdd1					FPUScale10A:
.cdd1	5a		phy				phy
.cdd2	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.cdd4	f0 3d		beq $ce13			beq 	_FPUScaleExit
.cdd6	da		phx				phx 								; save X
.cdd7	e8		inx				inx
.cdd8	e8		inx				inx
.cdd9	e8		inx				inx
.cdda	e8		inx				inx
.cddb	e8		inx				inx
.cddc	e8		inx				inx
.cddd	a8		tay				tay 								; save power scalar in Y.
.cdde	a9 00		lda #$00			lda 	#0
.cde0	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.cde3	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cde6	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cde9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cdec	a9 80		lda #$80			lda 	#$80
.cdee	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cdf1	a9 81		lda #$81			lda 	#$81
.cdf3	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cdf6	5a		phy				phy 								; save 10^n on stack.
.cdf7	c0 00		cpy #$00			cpy 	#0
.cdf9	10 05		bpl $ce00			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.cdfb	98		tya				tya
.cdfc	49 ff		eor #$ff			eor 	#$FF
.cdfe	1a		inc a				inc 	a
.cdff	a8		tay				tay
.ce00					_FPUSAbs:
.ce00	20 70 cd	jsr $cd70			jsr 	FPUTimes10
.ce03	88		dey				dey
.ce04	d0 fa		bne $ce00			bne 	_FPUSAbs 					; tos is now 10^|AC|
.ce06	68		pla				pla 								; restore count in A
.ce07	fa		plx				plx 								; restore X pointing to number to scale.
.ce08	0a		asl a				asl 	a
.ce09	b0 05		bcs $ce10			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.ce0b	20 f8 ca	jsr $caf8			jsr 	FPMultiply 					; if clear multiply.
.ce0e	80 03		bra $ce13			bra		_FPUScaleExit
.ce10					_FPUSDivide:
.ce10	20 70 ca	jsr $ca70			jsr 	FPDivide
.ce13					_FPUScaleExit:
.ce13	7a		ply				ply
.ce14	60		rts				rts
.ce15					FPUCopyToNext:
.ce15	a0 06		ldy #$06			ldy 		#6
.ce17	da		phx				phx
.ce18					_FPUCopy1:
.ce18	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.ce1b	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.ce1e	e8		inx				inx
.ce1f	88		dey				dey
.ce20	d0 f6		bne $ce18			bne 	_FPUCopy1
.ce22	fa		plx				plx
.ce23	60		rts				rts
.ce24					FPUCopyFromNext:
.ce24	a0 06		ldy #$06			ldy 		#6
.ce26	da		phx				phx
.ce27					_FPUCopy1:
.ce27	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.ce2a	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ce2d	e8		inx				inx
.ce2e	88		dey				dey
.ce2f	d0 f6		bne $ce27			bne 	_FPUCopy1
.ce31	fa		plx				plx
.ce32	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.ce33					FPToString:
.ce33	48		pha				pha
.ce34	5a		phy				phy
.ce35	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.ce38	50 0a		bvc $ce44			bvc 		_FPTSIsFloat 			; if zero,
.ce3a					_FPTSZero:
.ce3a	a9 30		lda #$30			lda 		#"0"
.ce3c	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.ce3f					_FPTSExit:
.ce3f	7a		ply				ply
.ce40	68		pla				pla
.ce41	60		rts				rts
.ce42	80 fb		bra $ce3f			bra 		_FPTSExit
.ce44					_FPTSIsFloat:
.ce44	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.ce47	10 0a		bpl $ce53			bpl 		_FPTSNotSigned
.ce49	a9 00		lda #$00			lda 		#0 						; clear sign flag
.ce4b	9d 05 03	sta $0305,x			sta 		XS_Type,x
.ce4e	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.ce50	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.ce53					_FPTSNotSigned:
.ce53	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.ce56	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.ce58	b0 09		bcs $ce63			bcs 		_FPTSExponent
.ce5a	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.ce5c	90 05		bcc $ce63			bcc 		_FPTSExponent 			;
.ce5e					_FPTSStandard:
.ce5e	20 a7 ce	jsr $cea7			jsr 		FPTOutputBody 			; output the body.
.ce61	80 dc		bra $ce3f			bra 		_FPTSExit
.ce63					_FPTSExponent:
.ce63	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.ce65	8d 24 04	sta $0424			sta 		ExpCount
.ce68					_FPTSExponentLoop:
.ce68	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.ce6b	10 0e		bpl $ce7b			bpl 		_FPTSTimes
.ce6d	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.ce6f	90 14		bcc $ce85			bcc 		_FPTSScaledToExp
.ce71	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.ce73	20 d1 cd	jsr $cdd1			jsr 		FPUScale10A
.ce76	ee 24 04	inc $0424			inc 		ExpCount
.ce79	80 ed		bra $ce68			bra 		_FPTSExponentLoop
.ce7b					_FPTSTimes:
.ce7b	a9 01		lda #$01			lda 		#1
.ce7d	20 d1 cd	jsr $cdd1			jsr 		FPUScale10A
.ce80	ce 24 04	dec $0424			dec 		ExpCount
.ce83	80 e3		bra $ce68			bra 		_FPTSExponentLoop
.ce85					_FPTSScaledToExp:
.ce85	20 a7 ce	jsr $cea7			jsr 		FPTOutputBody 			; output the body.
.ce88	a9 65		lda #$65			lda 		#"e"					; output E
.ce8a	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.ce8d	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.ce90	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.ce93	29 80		and #$80			and 		#$80 					; sign extend it
.ce95	f0 02		beq $ce99			beq 		_FPTSSExt
.ce97	a9 ff		lda #$ff			lda 		#$FF
.ce99					_FPTSSExt:
.ce99	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.ce9c	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.ce9f	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.cea2	20 29 c8	jsr $c829			jsr 		INTToString 			; output the exponent.
.cea5	80 98		bra $ce3f			bra			_FPTSExit 				; and exit.
.cea7					FPTOutputBody:
.cea7	20 15 ce	jsr $ce15			jsr 		FPUCopyToNext 			; copy to next slot.
.ceaa	20 09 cd	jsr $cd09			jsr 		FPUToInteger 			; convert to an integer
.cead	20 29 c8	jsr $c829			jsr 		INTToString 			; output the main integer part.
.ceb0	20 24 ce	jsr $ce24			jsr 		FPUCopyFromNext 		; get the fractional part back.
.ceb3	20 95 cb	jsr $cb95			jsr 		FPFractionalPart 		; get the decimal part.
.ceb6	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.ceb9	70 3e		bvs $cef9			bvs 		_FPTOExit 				; if not, exit now.
.cebb	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.cebd	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.cec0					_FPOutLoop:
.cec0	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.cec3	70 1e		bvs $cee3			bvs 		_FPStripZeros 			; strip trailing zeros
.cec5	20 70 cd	jsr $cd70			jsr 		FPUTimes10 				; multiply by 10
.cec8	20 15 ce	jsr $ce15			jsr 		FPUCopyToNext			; copy to next slot.
.cecb	20 09 cd	jsr $cd09			jsr 		FPUToInteger 			; convert to integer
.cece	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.ced1	09 30		ora #$30			ora 		#"0"
.ced3	20 c5 c8	jsr $c8c5			jsr 		ITSOutputCharacter
.ced6	20 24 ce	jsr $ce24			jsr 		FPUCopyFromNext 		; get it back
.ced9	20 95 cb	jsr $cb95			jsr 		FPFractionalPart 		; get fractional part
.cedc	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.cedf	c9 0b		cmp #$0b			cmp 	 	#11
.cee1	90 dd		bcc $cec0			bcc 		_FPOutLoop 				; if so, keep going till zero.
.cee3					_FPStripZeros:
.cee3	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.cee6					_FPStripLoop:
.cee6	88		dey				dey 								; back one, if at start then no strip
.cee7	f0 10		beq $cef9			beq 		_FPToExit
.cee9	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.ceec	c9 30		cmp #$30			cmp 		#"0"
.ceee	f0 f6		beq $cee6			beq 		_FPStripLoop
.cef0	c8		iny				iny
.cef1	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.cef3	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.cef6	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.cef9					_FPTOExit:
.cef9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.cefa					FPFromString:
.cefa	48		pha				pha 								; push A
.cefb	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.cefd	c9 2e		cmp #$2e			cmp 	#"."
.ceff	f0 03		beq $cf04			beq	 	_FPFIsDecimal
.cf01	4c 67 cf	jmp $cf67			jmp 	_FPFNotDecimal
.cf04					_FPFIsDecimal:
.cf04	c8		iny				iny 								; consume the decimal.
.cf05	20 aa cc	jsr $ccaa			jsr 	FPUToFloat 					; convert the integer to float.
.cf08	da		phx				phx 								; save X.
.cf09	5a		phy				phy 								; save decimal start position
.cf0a	e8		inx				inx
.cf0b	e8		inx				inx
.cf0c	e8		inx				inx
.cf0d	e8		inx				inx
.cf0e	e8		inx				inx
.cf0f	e8		inx				inx
.cf10	20 dd c8	jsr $c8dd			jsr 	INTFromStringY 				; get the part after the DP.
.cf13	20 aa cc	jsr $ccaa			jsr 	FPUToFloat 					; convert that to a float.
.cf16	68		pla				pla 								; calculate - chars consumed.
.cf17	8c 23 04	sty $0423			sty 	ExpTemp
.cf1a	38		sec				sec
.cf1b	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.cf1e	20 d1 cd	jsr $cdd1			jsr 	FPUScale10A 				; scale it by 10^AC
.cf21	fa		plx				plx 								; restore original X
.cf22	20 8d c9	jsr $c98d			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.cf25	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.cf27	c9 45		cmp #$45			cmp 	#"E"
.cf29	f0 04		beq $cf2f			beq 	_FPFExponent
.cf2b	c9 65		cmp #$65			cmp 	#"e"
.cf2d	d0 38		bne $cf67			bne 	_FPFNotDecimal 				; no, then exit normally.
.cf2f					_FPFExponent:
.cf2f	c8		iny				iny 								; skip over E symbol.
.cf30	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.cf32	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.cf34	d0 01		bne $cf37			bne 	_FPFGotSign
.cf36	c8		iny				iny 								; if it was - skip over it.
.cf37					_FPFGotSign:
.cf37	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.cf38	da		phx				phx
.cf39	e8		inx				inx
.cf3a	e8		inx				inx
.cf3b	e8		inx				inx
.cf3c	e8		inx				inx
.cf3d	e8		inx				inx
.cf3e	e8		inx				inx
.cf3f	20 dd c8	jsr $c8dd			jsr 	INTFromStringY 				; get the exponent
.cf42	fa		plx				plx 								; restore X.
.cf43	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.cf46	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.cf49	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.cf4c	d0 1b		bne $cf69			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.cf4e	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.cf51	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.cf53	b0 14		bcs $cf69			bcs 	_FPFXOverflow
.cf55	68		pla				pla 								; get direction
.cf56	d0 09		bne $cf61			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.cf58	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.cf5b	49 ff		eor #$ff			eor 	#$FF
.cf5d	1a		inc a				inc 	a
.cf5e	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.cf61					_FPFXScale:
.cf61	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.cf64	20 d1 cd	jsr $cdd1			jsr 	FPUScale10A 				; scale by the exponent.
.cf67					_FPFNotDecimal:
.cf67	68		pla				pla
.cf68	60		rts				rts
.cf69					_FPFXOverflow:
.cf69	20 0f c4	jsr $c40f			jsr 	ERR_Handler
>cf6c	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>cf74	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.cf7b					TIM_Error:
.cf7b	20 37 c2	jsr $c237			jsr 	IFT_UpLine 					; go up one line.
.cf7e	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.cf80	80 02		bra $cf84			bra 	TIM_ShowPrompt
.cf82					TIM_NewCommand:
.cf82	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.cf84					TIM_ShowPrompt:
.cf84	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.cf87	20 fb c2	jsr $c2fb			jsr 	IFT_ReadLine	 			; get character, go to next line
.cf8a	20 5d c2	jsr $c25d			jsr 	IFT_NewLine					; go to next line.
.cf8d	86 10		stx $10				stx 	zTemp1 						; save line read address
.cf8f	84 11		sty $11				sty 	zTemp1+1
.cf91	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.cf93	b1 10		lda ($10),y			lda 	(zTemp1),y
.cf95	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.cf97	d0 01		bne $cf9a			bne 	TIM_NotDot
.cf99	c8		iny				iny
.cf9a					TIM_NotDot:
.cf9a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.cf9c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.cf9e	f0 6b		beq $d00b			beq 	TIM_ShowRegisters
.cfa0	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.cfa2	f0 12		beq $cfb6			beq 	TIM_ShowMemory
.cfa4	c9 47		cmp #$47			cmp 	#"G"						; execute
.cfa6	f0 49		beq $cff1			beq 	TIM_Execute
.cfa8	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.cfaa	f0 07		beq $cfb3			beq 	TIM_GoLoadMemory
.cfac	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.cfae	d0 cb		bne $cf7b			bne 	TIM_Error
.cfb0	4c 2e d1	jmp $d12e			jmp 	TIM_UpdateRegisters
.cfb3					TIM_GoLoadMemory:
.cfb3	4c 5e d1	jmp $d15e			jmp 	TIM_LoadMemory
.cfb6					TIM_ShowMemory:
.cfb6	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.cfb9	b0 c0		bcs $cf7b			bcs 	TIM_Error
.cfbb	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.cfbd	85 12		sta $12				sta 	zTemp2
.cfbf	a5 15		lda $15				lda 	zTemp3+1
.cfc1	85 13		sta $13				sta 	zTemp2+1
.cfc3	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.cfc6	90 08		bcc $cfd0			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.cfc8	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.cfca	85 14		sta $14				sta 	zTemp3
.cfcc	a5 13		lda $13				lda 	zTemp2+1
.cfce	85 15		sta $15				sta 	zTemp3+1
.cfd0					_TIMSM_Start:
.cfd0	20 82 d0	jsr $d082			jsr 	TIM_WriteLine 				; write one line of hex out
.cfd3	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.cfd5	18		clc				clc
.cfd6	69 10		adc #$10			adc 	#16
.cfd8	85 12		sta $12				sta 	zTemp2
.cfda	90 02		bcc $cfde			bcc 	_TIMSM_NoCarry
.cfdc	e6 13		inc $13				inc 	zTemp2+1
.cfde					_TIMSM_NoCarry:
.cfde	20 e2 c3	jsr $c3e2			jsr 	IF_CheckBreak 				; check CTL+C
.cfe1	d0 0b		bne $cfee			bne 	_TIMSM_Ends 				; if pressed break out.
.cfe3	38		sec				sec 								; check past the end address in zTemp3
.cfe4	a5 14		lda $14				lda 	zTemp3
.cfe6	e5 12		sbc $12				sbc 	zTemp2
.cfe8	a5 15		lda $15				lda 	zTemp3+1
.cfea	e5 13		sbc $13				sbc 	zTemp2+1
.cfec	10 e2		bpl $cfd0			bpl 	_TIMSM_Start
.cfee					_TIMSM_Ends:
.cfee	4c 82 cf	jmp $cf82			jmp 	TIM_NewCommand
.cff1					TIM_Execute:
.cff1	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; get the execute address
.cff4	b0 85		bcs $cf7b			bcs 	TIM_Error 					; not legitimate
.cff6	ae 2f 04	ldx $042f			ldx 	TIM_SP 						; set up SP
.cff9	9a		txs				txs
.cffa	ad 2a 04	lda $042a			lda 	TIM_SR 						; Status for PLP
.cffd	48		pha				pha
.cffe	ad 2b 04	lda $042b			lda 	TIM_A 						; restore AXYZ
.d001	ae 2c 04	ldx $042c			ldx 	TIM_X
.d004	ac 2d 04	ldy $042d			ldy 	TIM_Y
.d007	28		plp				plp 								; and PS Byte.
.d008	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.d00b					TIM_Start:
.d00b					TIM_ShowRegisters:
.d00b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.d00e	8d 29 04	sta $0429			sta 	TIM_IRQ+1
.d011	ad ff ff	lda $ffff			lda 	$FFFF
.d014	8d 28 04	sta $0428			sta 	TIM_IRQ
.d017	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.d019					_TIMSR_Text:
.d019	bd 49 d0	lda $d049,x			lda 	_TIMSR_Label,x
.d01c	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d01f	e8		inx				inx
.d020	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.d022	d0 f5		bne $d019			bne 	_TIMSR_Text
.d024	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.d026					_TIMSR_Skip:
.d026	e8		inx				inx
.d027					_TIMSR_LoopSpace:
.d027	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.d029	b0 04		bcs $d02f			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.d02b	8a		txa				txa
.d02c	4a		lsr a				lsr 	a
.d02d	b0 05		bcs $d034			bcs 	_TIMSR_NoSpace
.d02f					_TIMSR_Space:
.d02f	a9 20		lda #$20			lda 	#" "
.d031	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d034					_TIMSR_NoSpace:
.d034	bd 26 04	lda $0426,x			lda 	TIM_PC,x 					; output hex value.
.d037	20 69 d0	jsr $d069			jsr 	TIM_WriteHex
.d03a	e8		inx				inx
.d03b	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.d03d	f0 e7		beq $d026			beq 	_TIMSR_Skip
.d03f	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.d041	d0 e4		bne $d027			bne 	_TimSR_LoopSpace
.d043	20 5d c2	jsr $c25d			jsr 	IFT_NewLine 				; new line
.d046	4c 82 cf	jmp $cf82			jmp	 	TIM_NewCommand 				; new command.
.d049					_TIMSR_Label:
>d049	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>d051	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>d061	52
>d062	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.d069					_TIMSR_LabelEnd:
.d069					TIM_WriteHex:
.d069	48		pha				pha 								; save A
.d06a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.d06b	4a		lsr a				lsr 	a
.d06c	4a		lsr a				lsr 	a
.d06d	4a		lsr a				lsr 	a
.d06e	20 72 d0	jsr $d072			jsr 	_TIMWH_Nibble 				; print MSB
.d071	68		pla				pla 								; restore and print LSB
.d072					_TIMWH_Nibble:
.d072	48		pha				pha
.d073	29 0f		and #$0f			and 	#15 						; mask out
.d075	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.d077	90 02		bcc $d07b			bcc 	_TIMWHNoLetter
.d079	69 06		adc #$06			adc 	#6
.d07b					_TIMWHNoLetter:
.d07b	69 30		adc #$30			adc 	#48
.d07d	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter 			; print it out.
.d080	68		pla				pla
.d081	60		rts				rts
.d082					TIM_WriteLine:
.d082	a9 2e		lda #$2e			lda 	#"." 						; prompt
.d084	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d087	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.d089	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d08c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.d08e	20 69 d0	jsr $d069			jsr 	TIM_WriteHex
.d091	a5 12		lda $12				lda 	zTemp2
.d093	20 69 d0	jsr $d069			jsr 	TIM_WriteHex
.d096	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.d098					_TIMWL_Loop:
.d098	a9 20		lda #$20			lda 	#" "
.d09a	20 43 c2	jsr $c243			jsr 	IFT_PrintCharacter
.d09d	b1 12		lda ($12),y			lda 	(zTemp2),y
.d09f	20 69 d0	jsr $d069			jsr 	TIM_WriteHex
.d0a2	c8		iny				iny
.d0a3	c0 10		cpy #$10			cpy 	#16
.d0a5	d0 f1		bne $d098			bne 	_TIMWL_Loop
.d0a7	4c 5d c2	jmp $c25d			jmp 	IFT_NewLine 				; new line and exit
.d0aa					TIM_GetHex:
.d0aa	c8		iny				iny
.d0ab	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.d0ad	c9 20		cmp #$20			cmp 	#32
.d0af	f0 f9		beq $d0aa			beq 	TIM_GetHex
.d0b1	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.d0b3	f0 f5		beq $d0aa			beq 	TIM_GetHex
.d0b5	20 de d0	jsr $d0de			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.d0b8	b0 23		bcs $d0dd			bcs 	_TIMGH_Exit					; if first bad then exit now.
.d0ba	a9 00		lda #$00			lda 	#0 							; zero result
.d0bc	85 14		sta $14				sta 	zTemp3
.d0be	85 15		sta $15				sta 	zTemp3+1
.d0c0					_TIM_GHLoop:
.d0c0	20 de d0	jsr $d0de			jsr 	TIM_GetHexCharacter 		; get next character
.d0c3	b0 17		bcs $d0dc			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.d0c5	c8		iny				iny 								; skip over it.
.d0c6	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.d0c8	26 15		rol $15				rol 	zTemp3+1
.d0ca	06 14		asl $14				asl 	zTemp3 						; now x 2
.d0cc	26 15		rol $15				rol 	zTemp3+1
.d0ce	06 14		asl $14				asl 	zTemp3						; now x 4
.d0d0	26 15		rol $15				rol 	zTemp3+1
.d0d2	06 14		asl $14				asl 	zTemp3 						; now x 8
.d0d4	26 15		rol $15				rol 	zTemp3+1
.d0d6	05 14		ora $14				ora 	zTemp3 						; OR result in
.d0d8	85 14		sta $14				sta 	zTemp3
.d0da	80 e4		bra $d0c0			bra 	_TIM_GHLoop 				; loop round again.
.d0dc					_TIMGH_Okay:
.d0dc	18		clc				clc
.d0dd					_TIMGH_Exit:
.d0dd	60		rts				rts
.d0de					TIM_GetHexCharacter:
.d0de	b1 10		lda ($10),y			lda 	(zTemp1),y
.d0e0	38		sec				sec
.d0e1	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d0e3	90 0e		bcc $d0f3			bcc 	_TIM_GHCFail
.d0e5	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d0e7	90 0b		bcc $d0f4			bcc 	_TIM_GHCExit
.d0e9	c9 11		cmp #$11			cmp 	#65-48						; < A
.d0eb	90 06		bcc $d0f3			bcc		_TIM_GHCFail
.d0ed	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d0ef	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d0f1	90 01		bcc $d0f4			bcc		_TIM_GHCExit
.d0f3					_TIM_GHCFail:
.d0f3	38		sec				sec
.d0f4					_TIM_GHCExit:
.d0f4	60		rts				rts
.d0f5					TIM_BreakVector:
.d0f5	da		phx				phx									; save X/A on stack
.d0f6	48		pha				pha
.d0f7	ba		tsx				tsx 								; X points to S
.d0f8	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d0fb	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d0fd	d0 03		bne $d102			bne 	_TIMBreak					; if set, it's BRK
.d0ff	68		pla				pla 								; abandon routine.
.d100	fa		plx				plx
.d101	40		rti				rti
.d102					_TIMBreak:
.d102	68		pla				pla 								; save A X Y and maybe Z
.d103	8d 2b 04	sta $042b			sta 	TIM_A
.d106	fa		plx				plx
.d107	8e 2c 04	stx $042c			stx 	TIM_X
.d10a	8c 2d 04	sty $042d			sty 	TIM_Y
.d10d	68		pla				pla 								; get Status Register
.d10e	8d 2a 04	sta $042a			sta 	TIM_SR
.d111	68		pla				pla
.d112	8d 27 04	sta $0427			sta 	TIM_PC+1 					; save calling address
.d115	68		pla				pla
.d116	8d 26 04	sta $0426			sta 	TIM_PC 						; high byte
.d119	ad 27 04	lda $0427			lda 	TIM_PC+1 					; dec PC to point right.
.d11c	d0 03		bne $d121			bne 	_TIMDecrement 				; brk bumps it.
.d11e	ce 26 04	dec $0426			dec 	TIM_PC
.d121					_TIMDecrement:
.d121	ce 27 04	dec $0427			dec 	TIM_PC+1
.d124	ba		tsx				tsx 								; and copy SP
.d125	8e 2f 04	stx $042f			stx 	TIM_SP
.d128	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d12a	9a		txs				txs
.d12b	4c 0b d0	jmp $d00b			jmp 	TIM_Start 					; and start up TIM monitor.
.d12e					TIM_UpdateRegisters:
.d12e	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; PC
.d131	b0 28		bcs $d15b			bcs 	_TIMURFail
.d133	a5 14		lda $14				lda 	zTemp3
.d135	8d 27 04	sta $0427			sta 	Tim_PC+1
.d138	a5 15		lda $15				lda 	zTemp3+1
.d13a	8d 26 04	sta $0426			sta 	Tim_PC
.d13d	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; ignore IRQ
.d140	b0 19		bcs $d15b			bcs 	_TIMURFail
.d142	a2 00		ldx #$00			ldx 	#0
.d144					_TIM_URLoop:
.d144	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d146	d0 01		bne $d149			bne 	_TIM_1
.d148	e8		inx				inx
.d149					_TIM_1:
.d149	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; registers
.d14c	b0 0d		bcs $d15b			bcs 	_TIMURFail
.d14e	a5 14		lda $14				lda 	zTemp3
.d150	9d 2a 04	sta $042a,x			sta 	Tim_SR,x
.d153	e8		inx				inx
.d154	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d156	d0 ec		bne $d144			bne 	_TIM_URLoop
.d158	4c 82 cf	jmp $cf82			jmp 	TIM_NewCommand
.d15b					_TIMURFail:
.d15b	4c 7b cf	jmp $cf7b			jmp 	TIM_Error
.d15e					TIM_LoadMemory:
.d15e	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; target address => zTemp2
.d161	a5 14		lda $14				lda 	zTemp3
.d163	85 12		sta $12				sta 	zTemp2
.d165	a5 15		lda $15				lda 	zTemp3+1
.d167	85 13		sta $13				sta 	zTemp2+1
.d169					_TIM_LMLoop:
.d169	20 aa d0	jsr $d0aa			jsr 	TIM_GetHex 					; next byte ?
.d16c	b0 0e		bcs $d17c			bcs 	_TIMLMDone 					; no more
.d16e	a2 00		ldx #$00			ldx 	#0							; write out.
.d170	a5 14		lda $14				lda 	zTemp3
.d172	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d174	e6 12		inc $12				inc 	zTemp2 						; bump address
.d176	d0 f1		bne $d169			bne 	_TIM_LMLoop
.d178	e6 13		inc $13				inc 	zTemp2+1
.d17a	80 ed		bra $d169			bra 	_TIM_LMLoop
.d17c					_TIMLMDone:
.d17c	4c 82 cf	jmp $cf82			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d17f	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	f2 c1						.word 	StartROM
>fffe	f5 d0					.word TIM_BreakVector

;******  End of listing
