
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Tue Sep  3 11:46:25 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=2					loadtest = 2
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testing.src

>1000	16 0a 00 dc bd 40 fd 03			.byte	$16,$0a,$00,$dc,$bd,$40,$fd,$03
>1008	30 84 43 58 77 4d fd 04			.byte	$30,$84,$43,$58,$77,$4d,$fd,$04
>1010	36 39 be 84 40 00 10 14			.byte	$36,$39,$be,$84,$40,$00,$10,$14
>1018	00 dc bd 40 87 41 6c 42			.byte	$00,$dc,$bd,$40,$87,$41,$6c,$42
>1020	70 be 84 8b 41 00 14 1e			.byte	$70,$be,$84,$8b,$41,$00,$14,$1e
>1028	00 dc bd 43 4d 6d 52 82			.byte	$00,$dc,$bd,$43,$4d,$6d,$52,$82
>1030	6e 64 4d be 84 43 63 49			.byte	$6e,$64,$4d,$be,$84,$43,$63,$49
>1038	5f 00 13 28 00 dc bd 9a			.byte	$5f,$00,$13,$28,$00,$dc,$bd,$9a
>1040	8b 41 72 6b 53 be be 84			.byte	$8b,$41,$72,$6b,$53,$be,$be,$84
>1048	41 72 6b 53 00 11 32 00			.byte	$41,$72,$6b,$53,$00,$11,$32,$00
>1050	dc bd a0 fe 03 6c bf 40			.byte	$dc,$bd,$a0,$fe,$03,$6c,$bf,$40
>1058	be be 84 fe 02 00 1d 3c			.byte	$be,$be,$84,$fe,$02,$00,$1d,$3c
>1060	00 dc bd 41 72 68 78 fd			.byte	$00,$dc,$bd,$41,$72,$68,$78,$fd
>1068	04 30 33 8b 40 fd 03 30			.byte	$04,$30,$33,$8b,$40,$fd,$03,$30
>1070	be 84 41 72 68 78 fd 04			.byte	$be,$84,$41,$72,$68,$78,$fd,$04
>1078	30 33 00 12 46 00 dc bd			.byte	$30,$33,$00,$12,$46,$00,$dc,$bd
>1080	42 5f 5e 43 89 43 70 6c			.byte	$42,$5f,$5e,$43,$89,$43,$70,$6c
>1088	6a be 84 40 00 16 50 00			.byte	$6a,$be,$84,$40,$00,$16,$50,$00
>1090	dc bd 8b 41 7b 47 67 81			.byte	$dc,$bd,$8b,$41,$7b,$47,$67,$81
>1098	8b 61 67 5d be 84 8b 61			.byte	$8b,$61,$67,$5d,$be,$84,$8b,$61
>10a0	47 45 00 0f 5a 00 dc bd			.byte	$47,$45,$00,$0f,$5a,$00,$dc,$bd
>10a8	b3 41 74 60 4a be be 84			.byte	$b3,$41,$74,$60,$4a,$be,$be,$84
>10b0	41 00 1e 64 00 dc bd a1			.byte	$41,$00,$1e,$64,$00,$dc,$bd,$a1
>10b8	fe 09 65 62 68 67 69 75			.byte	$fe,$09,$65,$62,$68,$67,$69,$75
>10c0	70 bf 47 be be 84 fe 09			.byte	$70,$bf,$47,$be,$be,$84,$fe,$09
>10c8	65 62 68 67 69 75 70 00			.byte	$65,$62,$68,$67,$69,$75,$70,$00
>10d0	15 6e 00 dc bd 40 fd 03			.byte	$15,$6e,$00,$dc,$bd,$40,$fd,$03
>10d8	30 8a 40 fd 03 30 be 84			.byte	$30,$8a,$40,$fd,$03,$30,$be,$84
>10e0	40 fd 03 30 00 12 78 00			.byte	$40,$fd,$03,$30,$00,$12,$78,$00
>10e8	dc bd 41 48 4b 43 86 8b			.byte	$dc,$bd,$41,$48,$4b,$43,$86,$8b
>10f0	6a 73 5f be 84 40 00 14			.byte	$6a,$73,$5f,$be,$84,$40,$00,$14
>10f8	82 00 dc bd 42 57 67 78			.byte	$82,$00,$dc,$bd,$42,$57,$67,$78
>1100	82 42 6a 65 71 be 84 7d			.byte	$82,$42,$6a,$65,$71,$be,$84,$7d
>1108	42 49 00 17 8c 00 dc bd			.byte	$42,$49,$00,$17,$8c,$00,$dc,$bd
>1110	a2 fe 07 69 77 65 6c 6f			.byte	$a2,$fe,$07,$69,$77,$65,$6c,$6f
>1118	bf 48 bf 4a be be 84 fe			.byte	$bf,$48,$bf,$4a,$be,$be,$84,$fe
>1120	02 00 15 96 00 dc bd 40			.byte	$02,$00,$15,$96,$00,$dc,$bd,$40
>1128	fd 03 30 8c 40 fd 03 30			.byte	$fd,$03,$30,$8c,$40,$fd,$03,$30
>1130	be 84 40 fd 03 30 00 17			.byte	$be,$84,$40,$fd,$03,$30,$00,$17
>1138	a0 00 dc bd 8b 43 4e 4b			.byte	$a0,$00,$dc,$bd,$8b,$43,$4e,$4b
>1140	75 8a 41 79 44 79 be 84			.byte	$75,$8a,$41,$79,$44,$79,$be,$84
>1148	8b 41 55 46 7c 00 18 aa			.byte	$8b,$41,$55,$46,$7c,$00,$18,$aa
>1150	00 dc bd 8b 41 45 59 66			.byte	$00,$dc,$bd,$8b,$41,$45,$59,$66
>1158	81 8b 43 5a 63 79 be 84			.byte	$81,$8b,$43,$5a,$63,$79,$be,$84
>1160	8b 41 40 41 61 00 0c b4			.byte	$8b,$41,$40,$41,$61,$00,$0c,$b4
>1168	00 dc bd 98 40 be 84 8b			.byte	$00,$dc,$bd,$98,$40,$be,$84,$8b
>1170	41 00 0f be 00 dc bd a6			.byte	$41,$00,$0f,$be,$00,$dc,$bd,$a6
>1178	fe 04 78 70 be be 84 42			.byte	$fe,$04,$78,$70,$be,$be,$84,$42
>1180	00 1b c8 00 dc bd 43 5e			.byte	$00,$1b,$c8,$00,$dc,$bd,$43,$5e
>1188	72 69 fd 04 36 38 89 43			.byte	$72,$69,$fd,$04,$36,$38,$89,$43
>1190	5e 72 69 fd 04 36 38 be			.byte	$5e,$72,$69,$fd,$04,$36,$38,$be
>1198	84 8b 41 00 14 d2 00 dc			.byte	$84,$8b,$41,$00,$14,$d2,$00,$dc
>11a0	bd 8b 4b 5e 56 85 8b 42			.byte	$bd,$8b,$4b,$5e,$56,$85,$8b,$42
>11a8	67 66 49 be 84 8b 41 00			.byte	$67,$66,$49,$be,$84,$8b,$41,$00
>11b0	15 dc 00 dc bd 43 57 6b			.byte	$15,$dc,$00,$dc,$bd,$43,$57,$6b
>11b8	4f 82 42 5f 7d 71 be 84			.byte	$4f,$82,$42,$5f,$7d,$71,$be,$84
>11c0	41 48 56 7e 00 1e e6 00			.byte	$41,$48,$56,$7e,$00,$1e,$e6,$00
>11c8	dc bd a5 a4 8b 43 4d 5d			.byte	$dc,$bd,$a5,$a4,$8b,$43,$4d,$5d
>11d0	52 fd 04 32 35 be be be			.byte	$52,$fd,$04,$32,$35,$be,$be,$be
>11d8	84 8b 43 4d 5d 52 fd 04			.byte	$84,$8b,$43,$4d,$5d,$52,$fd,$04
>11e0	32 35 00 12 f0 00 dc bd			.byte	$32,$35,$00,$12,$f0,$00,$dc,$bd
>11e8	9b fe 06 64 72 71 72 be			.byte	$9b,$fe,$06,$64,$72,$71,$72,$be
>11f0	be 84 41 64 00 25 fa 00			.byte	$be,$84,$41,$64,$00,$25,$fa,$00
>11f8	dc bd 8b 6f 54 55 fd 04			.byte	$dc,$bd,$8b,$6f,$54,$55,$fd,$04
>1200	36 38 8d 42 78 72 5e fd			.byte	$36,$38,$8d,$42,$78,$72,$5e,$fd
>1208	04 34 37 be 84 8b 40 fd			.byte	$04,$34,$37,$be,$84,$8b,$40,$fd
>1210	0a 32 35 36 30 36 34 33			.byte	$0a,$32,$35,$36,$30,$36,$34,$33
>1218	33 00 13 04 01 dc bd 8b			.byte	$33,$00,$13,$04,$01,$dc,$bd,$8b
>1220	43 60 5a 5c 88 43 63 6f			.byte	$43,$60,$5a,$5c,$88,$43,$63,$6f
>1228	5d be 84 40 00 16 0e 01			.byte	$5d,$be,$84,$40,$00,$16,$0e,$01
>1230	dc bd 8b 43 45 66 78 81			.byte	$dc,$bd,$8b,$43,$45,$66,$78,$81
>1238	7c 6b 79 be 84 8b 43 41			.byte	$7c,$6b,$79,$be,$84,$8b,$43,$41
>1240	44 47 00 13 18 01 dc bd			.byte	$44,$47,$00,$13,$18,$01,$dc,$bd
>1248	9a 8b 43 73 5a 66 be be			.byte	$9a,$8b,$43,$73,$5a,$66,$be,$be
>1250	84 43 73 5a 66 00 0e 22			.byte	$84,$43,$73,$5a,$66,$00,$0e,$22
>1258	01 dc bd b4 79 be be 84			.byte	$01,$dc,$bd,$b4,$79,$be,$be,$84
>1260	fe 03 39 00 29 2c 01 dc			.byte	$fe,$03,$39,$00,$29,$2c,$01,$dc
>1268	bd 8b 41 50 54 6b fd 04			.byte	$bd,$8b,$41,$50,$54,$6b,$fd,$04
>1270	35 36 8c 8b 41 50 54 6b			.byte	$35,$36,$8c,$8b,$41,$50,$54,$6b
>1278	fd 04 35 36 be 84 41 fd			.byte	$fd,$04,$35,$36,$be,$84,$41,$fd
>1280	0d 30 38 32 34 33 33 34			.byte	$0d,$30,$38,$32,$34,$33,$33,$34
>1288	35 65 31 31 00 12 36 01			.byte	$35,$65,$31,$31,$00,$12,$36,$01
>1290	dc bd 43 69 54 52 86 42			.byte	$dc,$bd,$43,$69,$54,$52,$86,$42
>1298	48 5a 5c be 84 40 00 17			.byte	$48,$5a,$5c,$be,$84,$40,$00,$17
>12a0	40 01 dc bd 8b 43 4c 5d			.byte	$40,$01,$dc,$bd,$8b,$43,$4c,$5d
>12a8	64 82 42 41 6e 7a be 84			.byte	$64,$82,$42,$41,$6e,$7a,$be,$84
>12b0	8b 41 4d 73 5a 00 11 4a			.byte	$8b,$41,$4d,$73,$5a,$00,$11,$4a
>12b8	01 dc bd b3 8b 41 44 59			.byte	$01,$dc,$bd,$b3,$8b,$41,$44,$59
>12c0	5a be be 84 8b 41 00 0d			.byte	$5a,$be,$be,$84,$8b,$41,$00,$0d
>12c8	54 01 dc bd a3 40 be be			.byte	$54,$01,$dc,$bd,$a3,$40,$be,$be
>12d0	84 fe 02 00 16 5e 01 dc			.byte	$84,$fe,$02,$00,$16,$5e,$01,$dc
>12d8	bd 40 fd 03 30 86 7f 5a			.byte	$bd,$40,$fd,$03,$30,$86,$7f,$5a
>12e0	71 fd 04 36 34 be 84 8b			.byte	$71,$fd,$04,$36,$34,$be,$84,$8b
>12e8	41 00 14 68 01 dc bd 8b			.byte	$41,$00,$14,$68,$01,$dc,$bd,$8b
>12f0	41 7d 50 47 85 41 64 5c			.byte	$41,$7d,$50,$47,$85,$41,$64,$5c
>12f8	46 be 84 8b 41 00 17 72			.byte	$46,$be,$84,$8b,$41,$00,$17,$72
>1300	01 dc bd 41 50 5c 70 82			.byte	$01,$dc,$bd,$41,$50,$5c,$70,$82
>1308	8b 42 7d 6d 47 be 84 8b			.byte	$8b,$42,$7d,$6d,$47,$be,$84,$8b
>1310	43 6d 71 77 00 17 7c 01			.byte	$43,$6d,$71,$77,$00,$17,$7c,$01
>1318	dc bd b2 42 40 49 5c bf			.byte	$dc,$bd,$b2,$42,$40,$49,$5c,$bf
>1320	8b 41 7b 54 49 be be 84			.byte	$8b,$41,$7b,$54,$49,$be,$be,$84
>1328	44 75 53 00 15 86 01 dc			.byte	$44,$75,$53,$00,$15,$86,$01,$dc
>1330	bd a7 42 4d 6b 7a be be			.byte	$bd,$a7,$42,$4d,$6b,$7a,$be,$be
>1338	84 fe 07 38 44 41 46 41			.byte	$84,$fe,$07,$38,$44,$41,$46,$41
>1340	00 27 90 01 dc bd 8b 72			.byte	$00,$27,$90,$01,$dc,$bd,$8b,$72
>1348	56 54 fd 03 31 8c 43 55			.byte	$56,$54,$fd,$03,$31,$8c,$43,$55
>1350	50 6b fd 04 36 39 be 84			.byte	$50,$6b,$fd,$04,$36,$39,$be,$84
>1358	8b 41 fd 0d 38 30 31 34			.byte	$8b,$41,$fd,$0d,$38,$30,$31,$34
>1360	33 34 37 39 65 31 31 00			.byte	$33,$34,$37,$39,$65,$31,$31,$00
>1368	14 9a 01 dc bd 8b 41 76			.byte	$14,$9a,$01,$dc,$bd,$8b,$41,$76
>1370	44 5c 85 43 45 55 50 be			.byte	$44,$5c,$85,$43,$45,$55,$50,$be
>1378	84 8b 41 00 0f a4 01 dc			.byte	$84,$8b,$41,$00,$0f,$a4,$01,$dc
>1380	bd 42 59 43 4a 80 40 be			.byte	$bd,$42,$59,$43,$4a,$80,$40,$be
>1388	84 40 00 12 ae 01 dc bd			.byte	$84,$40,$00,$12,$ae,$01,$dc,$bd
>1390	98 8b 43 4a 77 6c be 84			.byte	$98,$8b,$43,$4a,$77,$6c,$be,$84
>1398	43 4a 77 6b 00 15 b8 01			.byte	$43,$4a,$77,$6b,$00,$15,$b8,$01
>13a0	dc bd af fe 07 37 33 38			.byte	$dc,$bd,$af,$fe,$07,$37,$33,$38
>13a8	30 37 be be 84 41 73 60			.byte	$30,$37,$be,$be,$84,$41,$73,$60
>13b0	47 00 1b c2 01 dc bd 42			.byte	$47,$00,$1b,$c2,$01,$dc,$bd,$42
>13b8	56 4f 66 fd 04 36 35 86			.byte	$56,$4f,$66,$fd,$04,$36,$35,$86
>13c0	8b 41 68 49 72 fd 04 33			.byte	$8b,$41,$68,$49,$72,$fd,$04,$33
>13c8	31 be 84 40 00 12 cc 01			.byte	$31,$be,$84,$40,$00,$12,$cc,$01
>13d0	dc bd 73 48 58 8d 8b 43			.byte	$dc,$bd,$73,$48,$58,$8d,$8b,$43
>13d8	4b 65 50 be 84 40 00 16			.byte	$4b,$65,$50,$be,$84,$40,$00,$16
>13e0	d6 01 dc bd 8b 42 4c 56			.byte	$d6,$01,$dc,$bd,$8b,$42,$4c,$56
>13e8	4c 82 59 73 4f be 84 8b			.byte	$4c,$82,$59,$73,$4f,$be,$84,$8b
>13f0	42 55 65 45 00 0e e0 01			.byte	$42,$55,$65,$45,$00,$0e,$e0,$01
>13f8	dc bd a5 a4 40 be be be			.byte	$dc,$bd,$a5,$a4,$40,$be,$be,$be
>1400	84 40 00 1a ea 01 dc bd			.byte	$84,$40,$00,$1a,$ea,$01,$dc,$bd
>1408	a0 fe 08 62 65 70 71 7a			.byte	$a0,$fe,$08,$62,$65,$70,$71,$7a
>1410	61 bf 44 be be 84 fe 06			.byte	$61,$bf,$44,$be,$be,$84,$fe,$06
>1418	62 65 70 71 00 19 f4 01			.byte	$62,$65,$70,$71,$00,$19,$f4,$01
>1420	dc bd 4a 43 5d fd 05 32			.byte	$dc,$bd,$4a,$43,$5d,$fd,$05,$32
>1428	31 31 89 60 56 76 fd 04			.byte	$31,$31,$89,$60,$56,$76,$fd,$04
>1430	34 38 be 84 40 00 12 fe			.byte	$34,$38,$be,$84,$40,$00,$12,$fe
>1438	01 dc bd 41 79 57 77 85			.byte	$01,$dc,$bd,$41,$79,$57,$77,$85
>1440	4b 48 67 be 84 8b 41 00			.byte	$4b,$48,$67,$be,$84,$8b,$41,$00
>1448	14 08 02 dc bd 42 51 66			.byte	$14,$08,$02,$dc,$bd,$42,$51,$66
>1450	4a 82 7b 54 5c be 84 42			.byte	$4a,$82,$7b,$54,$5c,$be,$84,$42
>1458	6a 72 56 00 11 12 02 dc			.byte	$6a,$72,$56,$00,$11,$12,$02,$dc
>1460	bd 9a 8b 7f 57 4d be be			.byte	$bd,$9a,$8b,$7f,$57,$4d,$be,$be
>1468	84 7f 57 4d 00 12 1c 02			.byte	$84,$7f,$57,$4d,$00,$12,$1c,$02
>1470	dc bd a1 fe 03 65 bf 43			.byte	$dc,$bd,$a1,$fe,$03,$65,$bf,$43
>1478	be be 84 fe 03 65 00 17			.byte	$be,$be,$84,$fe,$03,$65,$00,$17
>1480	26 02 dc bd 8b 44 62 64			.byte	$26,$02,$dc,$bd,$8b,$44,$62,$64
>1488	fd 04 39 39 87 40 fd 03			.byte	$fd,$04,$39,$39,$87,$40,$fd,$03
>1490	30 be 84 8b 41 00 16 30			.byte	$30,$be,$84,$8b,$41,$00,$16,$30
>1498	02 dc bd 8b 41 68 65 5b			.byte	$02,$dc,$bd,$8b,$41,$68,$65,$5b
>14a0	8a 41 46 42 72 be 84 8b			.byte	$8a,$41,$46,$42,$72,$be,$84,$8b
>14a8	62 62 69 00 16 3a 02 dc			.byte	$62,$62,$69,$00,$16,$3a,$02,$dc
>14b0	bd 8b 42 70 5f 53 80 43			.byte	$bd,$8b,$42,$70,$5f,$53,$80,$43
>14b8	68 61 6b be 84 41 48 60			.byte	$68,$61,$6b,$be,$84,$41,$48,$60
>14c0	69 00 11 44 02 dc bd b3			.byte	$69,$00,$11,$44,$02,$dc,$bd,$b3
>14c8	8b 43 44 63 70 be be 84			.byte	$8b,$43,$44,$63,$70,$be,$be,$84
>14d0	8b 41 00 12 4e 02 dc bd			.byte	$8b,$41,$00,$12,$4e,$02,$dc,$bd
>14d8	a2 fe 02 bf 46 bf 46 be			.byte	$a2,$fe,$02,$bf,$46,$bf,$46,$be
>14e0	be 84 fe 02 00 18 58 02			.byte	$be,$84,$fe,$02,$00,$18,$58,$02
>14e8	dc bd 8b 41 51 6f 6c fd			.byte	$dc,$bd,$8b,$41,$51,$6f,$6c,$fd
>14f0	04 32 37 86 40 fd 03 30			.byte	$04,$32,$37,$86,$40,$fd,$03,$30
>14f8	be 84 8b 41 00 12 62 02			.byte	$be,$84,$8b,$41,$00,$12,$62,$02
>1500	dc bd 42 4c 48 76 84 42			.byte	$dc,$bd,$42,$4c,$48,$76,$84,$42
>1508	66 40 62 be 84 40 00 15			.byte	$66,$40,$62,$be,$84,$40,$00,$15
>1510	6c 02 dc bd 41 5c 6b 61			.byte	$6c,$02,$dc,$bd,$41,$5c,$6b,$61
>1518	80 8b 43 55 50 55 be 84			.byte	$80,$8b,$43,$55,$50,$55,$be,$84
>1520	48 6b 61 00 0e 76 02 dc			.byte	$48,$6b,$61,$00,$0e,$76,$02,$dc
>1528	bd a6 fe 03 61 be be 84			.byte	$bd,$a6,$fe,$03,$61,$be,$be,$84
>1530	41 00 28 80 02 dc bd 8b			.byte	$41,$00,$28,$80,$02,$dc,$bd,$8b
>1538	5d 73 52 fd 04 35 38 8c			.byte	$5d,$73,$52,$fd,$04,$35,$38,$8c
>1540	41 4d 51 7a fd 04 36 33			.byte	$41,$4d,$51,$7a,$fd,$04,$36,$33
>1548	be 84 8b 43 fd 0d 38 36			.byte	$be,$84,$8b,$43,$fd,$0d,$38,$36
>1550	33 38 37 38 38 30 65 31			.byte	$33,$38,$37,$38,$38,$30,$65,$31
>1558	30 00 15 8a 02 dc bd 8b			.byte	$30,$00,$15,$8a,$02,$dc,$bd,$8b
>1560	41 48 5d 58 89 8b 41 48			.byte	$41,$48,$5d,$58,$89,$8b,$41,$48
>1568	5d 58 be 84 8b 41 00 16			.byte	$5d,$58,$be,$84,$8b,$41,$00,$16
>1570	94 02 dc bd 41 65 40 7f			.byte	$94,$02,$dc,$bd,$41,$65,$40,$7f
>1578	82 8b 53 6e 71 be 84 8b			.byte	$82,$8b,$53,$6e,$71,$be,$84,$8b
>1580	41 76 6e 50 00 12 9e 02			.byte	$41,$76,$6e,$50,$00,$12,$9e,$02
>1588	dc bd 98 8b 41 60 74 6f			.byte	$dc,$bd,$98,$8b,$41,$60,$74,$6f
>1590	be 84 41 60 74 6e 00 10			.byte	$be,$84,$41,$60,$74,$6e,$00,$10
>1598	a8 02 dc bd 9b fe 04 63			.byte	$a8,$02,$dc,$bd,$9b,$fe,$04,$63
>15a0	66 be be 84 41 63 00 1c			.byte	$66,$be,$be,$84,$41,$63,$00,$1c
>15a8	b2 02 dc bd 8b 41 57 62			.byte	$b2,$02,$dc,$bd,$8b,$41,$57,$62
>15b0	7b fd 04 36 38 86 43 49			.byte	$7b,$fd,$04,$36,$38,$86,$43,$49
>15b8	6b 5d fd 04 37 36 be 84			.byte	$6b,$5d,$fd,$04,$37,$36,$be,$84
>15c0	8b 41 00 10 bc 02 dc bd			.byte	$8b,$41,$00,$10,$bc,$02,$dc,$bd
>15c8	40 84 8b 42 72 59 4d be			.byte	$40,$84,$8b,$42,$72,$59,$4d,$be
>15d0	84 40 00 12 c6 02 dc bd			.byte	$84,$40,$00,$12,$c6,$02,$dc,$bd
>15d8	41 59 51 50 82 40 be 84			.byte	$41,$59,$51,$50,$82,$40,$be,$84
>15e0	41 59 51 50 00 14 d0 02			.byte	$41,$59,$51,$50,$00,$14,$d0,$02
>15e8	dc bd a5 a4 43 6e 48 67			.byte	$dc,$bd,$a5,$a4,$43,$6e,$48,$67
>15f0	be be be 84 43 6e 48 67			.byte	$be,$be,$be,$84,$43,$6e,$48,$67
>15f8	00 0e da 02 dc bd b4 7d			.byte	$00,$0e,$da,$02,$dc,$bd,$b4,$7d
>1600	be be 84 fe 03 3d 00 19			.byte	$be,$be,$84,$fe,$03,$3d,$00,$19
>1608	e4 02 dc bd 72 55 7e fd			.byte	$e4,$02,$dc,$bd,$72,$55,$7e,$fd
>1610	04 30 39 88 43 55 63 56			.byte	$04,$30,$39,$88,$43,$55,$63,$56
>1618	fd 04 38 35 be 84 40 00			.byte	$fd,$04,$38,$35,$be,$84,$40,$00
>1620	16 ee 02 dc bd 61 74 5c			.byte	$16,$ee,$02,$dc,$bd,$61,$74,$5c
>1628	8a 8b 41 7d 5b 62 be 84			.byte	$8a,$8b,$41,$7d,$5b,$62,$be,$84
>1630	8b 41 5b 67 46 00 14 f8			.byte	$8b,$41,$5b,$67,$46,$00,$14,$f8
>1638	02 dc bd 41 69 4d 74 82			.byte	$02,$dc,$bd,$41,$69,$4d,$74,$82
>1640	6d 49 69 be 84 41 44 44			.byte	$6d,$49,$69,$be,$84,$41,$44,$44
>1648	5d 00 12 02 03 dc bd 9a			.byte	$5d,$00,$12,$02,$03,$dc,$bd,$9a
>1650	42 5f 6d 57 be be 84 42			.byte	$42,$5f,$6d,$57,$be,$be,$84,$42
>1658	5f 6d 57 00 1d 0c 03 dc			.byte	$5f,$6d,$57,$00,$1d,$0c,$03,$dc
>1660	bd a3 50 be be 84 fe 12			.byte	$bd,$a3,$50,$be,$be,$84,$fe,$12
>1668	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1670	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1678	00 18 16 03 dc bd 40 fd			.byte	$00,$18,$16,$03,$dc,$bd,$40,$fd
>1680	03 30 88 8b 41 51 67 6c			.byte	$03,$30,$88,$8b,$41,$51,$67,$6c
>1688	fd 04 30 37 be 84 8b 41			.byte	$fd,$04,$30,$37,$be,$84,$8b,$41
>1690	00 14 20 03 dc bd 43 49			.byte	$00,$14,$20,$03,$dc,$bd,$43,$49
>1698	43 5d 85 8b 42 7b 76 4c			.byte	$43,$5d,$85,$8b,$42,$7b,$76,$4c
>16a0	be 84 8b 41 00 10 2a 03			.byte	$be,$84,$8b,$41,$00,$10,$2a,$03
>16a8	dc bd 40 80 8b 43 49 49			.byte	$dc,$bd,$40,$80,$8b,$43,$49,$49
>16b0	47 be 84 40 00 10 34 03			.byte	$47,$be,$84,$40,$00,$10,$34,$03
>16b8	dc bd b3 8b 5e 64 56 be			.byte	$dc,$bd,$b3,$8b,$5e,$64,$56,$be
>16c0	be 84 8b 41 00 14 3e 03			.byte	$be,$84,$8b,$41,$00,$14,$3e,$03
>16c8	dc bd a7 79 76 44 be be			.byte	$dc,$bd,$a7,$79,$76,$44,$be,$be
>16d0	84 fe 07 33 39 44 38 34			.byte	$84,$fe,$07,$33,$39,$44,$38,$34
>16d8	00 15 48 03 dc bd 6d 4c			.byte	$00,$15,$48,$03,$dc,$bd,$6d,$4c
>16e0	7f fd 04 37 38 84 40 fd			.byte	$7f,$fd,$04,$37,$38,$84,$40,$fd
>16e8	03 30 be 84 40 00 15 52			.byte	$03,$30,$be,$84,$40,$00,$15,$52
>16f0	03 dc bd 8b 41 76 5d 7d			.byte	$03,$dc,$bd,$8b,$41,$76,$5d,$7d
>16f8	85 8b 42 6d 75 4a be 84			.byte	$85,$8b,$42,$6d,$75,$4a,$be,$84
>1700	8b 41 00 17 5c 03 dc bd			.byte	$8b,$41,$00,$17,$5c,$03,$dc,$bd
>1708	8b 53 5a 41 80 8b 43 6b			.byte	$8b,$53,$5a,$41,$80,$8b,$43,$6b
>1710	70 5c be 84 8b 43 7b 7a			.byte	$70,$5c,$be,$84,$8b,$43,$7b,$7a
>1718	5c 00 17 66 03 dc bd b2			.byte	$5c,$00,$17,$66,$03,$dc,$bd,$b2
>1720	8b 42 78 78 44 bf 8b 7f			.byte	$8b,$42,$78,$78,$44,$bf,$8b,$7f
>1728	73 4d be be 84 79 51 6a			.byte	$73,$4d,$be,$be,$84,$79,$51,$6a
>1730	00 15 70 03 dc bd af fe			.byte	$00,$15,$70,$03,$dc,$bd,$af,$fe
>1738	07 46 30 31 35 45 be be			.byte	$07,$46,$30,$31,$35,$45,$be,$be
>1740	84 43 70 45 5e 00 1c 7a			.byte	$84,$43,$70,$45,$5e,$00,$1c,$7a
>1748	03 dc bd 8b 41 7d 73 56			.byte	$03,$dc,$bd,$8b,$41,$7d,$73,$56
>1750	fd 04 33 37 84 8b 42 5b			.byte	$fd,$04,$33,$37,$84,$8b,$42,$5b
>1758	5a 6c fd 04 39 34 be 84			.byte	$5a,$6c,$fd,$04,$39,$34,$be,$84
>1760	40 00 14 84 03 dc bd 42			.byte	$40,$00,$14,$84,$03,$dc,$bd,$42
>1768	6d 43 7f 85 8b 41 4b 63			.byte	$6d,$43,$7f,$85,$8b,$41,$4b,$63
>1770	78 be 84 8b 41 00 18 8e			.byte	$78,$be,$84,$8b,$41,$00,$18,$8e
>1778	03 dc bd 8b 43 4c 57 5e			.byte	$03,$dc,$bd,$8b,$43,$4c,$57,$5e
>1780	81 8b 41 77 62 74 be 84			.byte	$81,$8b,$41,$77,$62,$74,$be,$84
>1788	8b 41 44 42 52 00 10 98			.byte	$8b,$41,$44,$42,$52,$00,$10,$98
>1790	03 dc bd 98 59 61 56 be			.byte	$03,$dc,$bd,$98,$59,$61,$56,$be
>1798	84 8b 59 61 57 00 1a a2			.byte	$84,$8b,$59,$61,$57,$00,$1a,$a2
>17a0	03 dc bd a0 fe 07 6a 72			.byte	$03,$dc,$bd,$a0,$fe,$07,$6a,$72
>17a8	6c 76 61 bf 48 be be 84			.byte	$6c,$76,$61,$bf,$48,$be,$be,$84
>17b0	fe 07 6a 72 6c 76 61 00			.byte	$fe,$07,$6a,$72,$6c,$76,$61,$00
>17b8	1c ac 03 dc bd 8b 42 6b			.byte	$1c,$ac,$03,$dc,$bd,$8b,$42,$6b
>17c0	47 74 fd 04 33 32 85 42			.byte	$47,$74,$fd,$04,$33,$32,$85,$42
>17c8	7b 7e 5e fd 04 39 39 be			.byte	$7b,$7e,$5e,$fd,$04,$39,$39,$be
>17d0	84 8b 41 00 15 b6 03 dc			.byte	$84,$8b,$41,$00,$15,$b6,$03,$dc
>17d8	bd 43 61 79 79 8a 8b 42			.byte	$bd,$43,$61,$79,$79,$8a,$8b,$42
>17e0	6b 52 4f be 84 76 67 6a			.byte	$6b,$52,$4f,$be,$84,$76,$67,$6a
>17e8	00 15 c0 03 dc bd 41 56			.byte	$00,$15,$c0,$03,$dc,$bd,$41,$56
>17f0	5b 67 81 8b 5c 6b 49 be			.byte	$5b,$67,$81,$8b,$5c,$6b,$49,$be
>17f8	84 8b 48 60 49 00 1c ca			.byte	$84,$8b,$48,$60,$49,$00,$1c,$ca
>1800	03 dc bd a5 a4 42 70 60			.byte	$03,$dc,$bd,$a5,$a4,$42,$70,$60
>1808	49 fd 04 32 36 be be be			.byte	$49,$fd,$04,$32,$36,$be,$be,$be
>1810	84 42 70 60 49 fd 04 32			.byte	$84,$42,$70,$60,$49,$fd,$04,$32
>1818	36 00 1c d4 03 dc bd a1			.byte	$36,$00,$1c,$d4,$03,$dc,$bd,$a1
>1820	fe 08 73 67 7a 6f 75 63			.byte	$fe,$08,$73,$67,$7a,$6f,$75,$63
>1828	bf 46 be be 84 fe 08 73			.byte	$bf,$46,$be,$be,$84,$fe,$08,$73
>1830	67 7a 6f 75 63 00 1a de			.byte	$67,$7a,$6f,$75,$63,$00,$1a,$de
>1838	03 dc bd 42 76 58 47 fd			.byte	$03,$dc,$bd,$42,$76,$58,$47,$fd
>1840	04 32 34 86 8b 70 76 7d			.byte	$04,$32,$34,$86,$8b,$70,$76,$7d
>1848	fd 04 37 39 be 84 40 00			.byte	$fd,$04,$37,$39,$be,$84,$40,$00
>1850	11 e8 03 dc bd 8b 49 73			.byte	$11,$e8,$03,$dc,$bd,$8b,$49,$73
>1858	47 8d 52 65 7b be 84 40			.byte	$47,$8d,$52,$65,$7b,$be,$84,$40
>1860	00 15 f2 03 dc bd 41 59			.byte	$00,$15,$f2,$03,$dc,$bd,$41,$59
>1868	6c 7f 80 8b 43 70 70 69			.byte	$6c,$7f,$80,$8b,$43,$70,$70,$69
>1870	be 84 49 4c 57 00 13 fc			.byte	$be,$84,$49,$4c,$57,$00,$13,$fc
>1878	03 dc bd 9a 8b 43 49 61			.byte	$03,$dc,$bd,$9a,$8b,$43,$49,$61
>1880	50 be be 84 43 49 61 50			.byte	$50,$be,$be,$84,$43,$49,$61,$50
>1888	00 1e 06 04 dc bd a2 fe			.byte	$00,$1e,$06,$04,$dc,$bd,$a2,$fe
>1890	08 72 6c 64 70 72 75 bf			.byte	$08,$72,$6c,$64,$70,$72,$75,$bf
>1898	41 bf 48 be be 84 fe 08			.byte	$41,$bf,$48,$be,$be,$84,$fe,$08
>18a0	72 6c 64 70 72 75 00 1b			.byte	$72,$6c,$64,$70,$72,$75,$00,$1b
>18a8	10 04 dc bd 73 75 52 fd			.byte	$10,$04,$dc,$bd,$73,$75,$52,$fd
>18b0	04 30 38 88 8b 42 6f 78			.byte	$04,$30,$38,$88,$8b,$42,$6f,$78
>18b8	70 fd 04 34 31 be 84 8b			.byte	$70,$fd,$04,$34,$31,$be,$84,$8b
>18c0	41 00 14 1a 04 dc bd 8b			.byte	$41,$00,$14,$1a,$04,$dc,$bd,$8b
>18c8	41 53 43 66 89 8b 41 4d			.byte	$41,$53,$43,$66,$89,$8b,$41,$4d
>18d0	66 6c be 84 40 00 15 24			.byte	$66,$6c,$be,$84,$40,$00,$15,$24
>18d8	04 dc bd 42 70 4a 52 81			.byte	$04,$dc,$bd,$42,$70,$4a,$52,$81
>18e0	41 69 57 47 be 84 43 79			.byte	$41,$69,$57,$47,$be,$84,$43,$79
>18e8	5f 57 00 11 2e 04 dc bd			.byte	$5f,$57,$00,$11,$2e,$04,$dc,$bd
>18f0	b3 8b 43 53 58 5b be be			.byte	$b3,$8b,$43,$53,$58,$5b,$be,$be
>18f8	84 8b 41 00 12 38 04 dc			.byte	$84,$8b,$41,$00,$12,$38,$04,$dc
>1900	bd a6 fe 07 6f 67 71 78			.byte	$bd,$a6,$fe,$07,$6f,$67,$71,$78
>1908	64 be be 84 45 00 1c 42			.byte	$64,$be,$be,$84,$45,$00,$1c,$42
>1910	04 dc bd 43 59 70 4c fd			.byte	$04,$dc,$bd,$43,$59,$70,$4c,$fd
>1918	04 30 35 89 8b 43 53 49			.byte	$04,$30,$35,$89,$8b,$43,$53,$49
>1920	50 fd 04 39 37 be 84 8b			.byte	$50,$fd,$04,$39,$37,$be,$84,$8b
>1928	41 00 14 4c 04 dc bd 42			.byte	$41,$00,$14,$4c,$04,$dc,$bd,$42
>1930	78 4d 52 8b 42 4e 59 6c			.byte	$78,$4d,$52,$8b,$42,$4e,$59,$6c
>1938	be 84 69 73 66 00 17 56			.byte	$be,$84,$69,$73,$66,$00,$17,$56
>1940	04 dc bd 42 72 7d 7d 81			.byte	$04,$dc,$bd,$42,$72,$7d,$7d,$81
>1948	8b 43 56 61 65 be 84 8b			.byte	$8b,$43,$56,$61,$65,$be,$84,$8b
>1950	41 44 40 41 00 17 60 04			.byte	$41,$44,$40,$41,$00,$17,$60,$04
>1958	dc bd b2 41 7a 5f 77 bf			.byte	$dc,$bd,$b2,$41,$7a,$5f,$77,$bf
>1960	42 63 6a 78 be be 84 41			.byte	$42,$63,$6a,$78,$be,$be,$84,$41
>1968	7a 5f 77 00 11 6a 04 dc			.byte	$7a,$5f,$77,$00,$11,$6a,$04,$dc
>1970	bd 9b fe 05 6c 73 67 be			.byte	$bd,$9b,$fe,$05,$6c,$73,$67,$be
>1978	be 84 41 6c 00 1d 74 04			.byte	$be,$84,$41,$6c,$00,$1d,$74,$04
>1980	dc bd 8b 42 77 69 7f fd			.byte	$dc,$bd,$8b,$42,$77,$69,$7f,$fd
>1988	04 32 39 88 8b 43 55 52			.byte	$04,$32,$39,$88,$8b,$43,$55,$52
>1990	77 fd 04 32 37 be 84 8b			.byte	$77,$fd,$04,$32,$37,$be,$84,$8b
>1998	41 00 13 7e 04 dc bd 8b			.byte	$41,$00,$13,$7e,$04,$dc,$bd,$8b
>19a0	41 69 5b 46 8d 75 5f 77			.byte	$41,$69,$5b,$46,$8d,$75,$5f,$77
>19a8	be 84 8b 41 00 17 88 04			.byte	$be,$84,$8b,$41,$00,$17,$88,$04
>19b0	dc bd 8b 43 46 42 59 80			.byte	$dc,$bd,$8b,$43,$46,$42,$59,$80
>19b8	8b 74 77 51 be 84 8b 43			.byte	$8b,$74,$77,$51,$be,$84,$8b,$43
>19c0	76 77 59 00 12 92 04 dc			.byte	$76,$77,$59,$00,$12,$92,$04,$dc
>19c8	bd 98 8b 42 7b 62 70 be			.byte	$bd,$98,$8b,$42,$7b,$62,$70,$be
>19d0	84 42 7b 62 6f 00 0f 9c			.byte	$84,$42,$7b,$62,$6f,$00,$0f,$9c
>19d8	04 dc bd b4 41 4f be be			.byte	$04,$dc,$bd,$b4,$41,$4f,$be,$be
>19e0	84 fe 03 4f 00 1c a6 04			.byte	$84,$fe,$03,$4f,$00,$1c,$a6,$04
>19e8	dc bd 41 70 6c 73 fd 04			.byte	$dc,$bd,$41,$70,$6c,$73,$fd,$04
>19f0	37 36 88 8b 42 4b 59 54			.byte	$37,$36,$88,$8b,$42,$4b,$59,$54
>19f8	fd 04 36 32 be 84 8b 41			.byte	$fd,$04,$36,$32,$be,$84,$8b,$41
>1a00	00 13 b0 04 dc bd 8b 42			.byte	$00,$13,$b0,$04,$dc,$bd,$8b,$42
>1a08	4e 78 56 89 42 56 5c 7d			.byte	$4e,$78,$56,$89,$42,$56,$5c,$7d
>1a10	be 84 40 00 14 ba 04 dc			.byte	$be,$84,$40,$00,$14,$ba,$04,$dc
>1a18	bd 6c 61 55 80 8b 43 56			.byte	$bd,$6c,$61,$55,$80,$8b,$43,$56
>1a20	64 59 be 84 68 41 45 00			.byte	$64,$59,$be,$84,$68,$41,$45,$00
>1a28	14 c4 04 dc bd a5 a4 41			.byte	$14,$c4,$04,$dc,$bd,$a5,$a4,$41
>1a30	73 68 4a be be be 84 41			.byte	$73,$68,$4a,$be,$be,$be,$84,$41
>1a38	73 68 4a 00 13 ce 04 dc			.byte	$73,$68,$4a,$00,$13,$ce,$04,$dc
>1a40	bd a3 46 be be 84 fe 08			.byte	$bd,$a3,$46,$be,$be,$84,$fe,$08
>1a48	20 20 20 20 20 20 00 17			.byte	$20,$20,$20,$20,$20,$20,$00,$17
>1a50	d8 04 dc bd 40 fd 03 30			.byte	$d8,$04,$dc,$bd,$40,$fd,$03,$30
>1a58	86 8b 42 69 7d 75 fd 04			.byte	$86,$8b,$42,$69,$7d,$75,$fd,$04
>1a60	32 37 be 84 40 00 12 e2			.byte	$32,$37,$be,$84,$40,$00,$12,$e2
>1a68	04 dc bd 42 65 7b 77 87			.byte	$04,$dc,$bd,$42,$65,$7b,$77,$87
>1a70	41 7c 58 7c be 84 40 00			.byte	$41,$7c,$58,$7c,$be,$84,$40,$00
>1a78	0f ec 04 dc bd 42 42 52			.byte	$0f,$ec,$04,$dc,$bd,$42,$42,$52
>1a80	66 80 40 be 84 40 00 11			.byte	$66,$80,$40,$be,$84,$40,$00,$11
>1a88	f6 04 dc bd 9a 8b 7e 7d			.byte	$f6,$04,$dc,$bd,$9a,$8b,$7e,$7d
>1a90	61 be be 84 7e 7d 61 00			.byte	$61,$be,$be,$84,$7e,$7d,$61,$00
>1a98	14 00 05 dc bd a7 75 73			.byte	$14,$00,$05,$dc,$bd,$a7,$75,$73
>1aa0	7b be be 84 fe 07 33 35			.byte	$7b,$be,$be,$84,$fe,$07,$33,$35
>1aa8	43 46 42 00 23 0a 05 dc			.byte	$43,$46,$42,$00,$23,$0a,$05,$dc
>1ab0	bd 41 7f 7e 59 fd 04 36			.byte	$bd,$41,$7f,$7e,$59,$fd,$04,$36
>1ab8	32 8d 56 5a 63 fd 05 35			.byte	$32,$8d,$56,$5a,$63,$fd,$05,$35
>1ac0	39 39 be 84 45 fd 09 37			.byte	$39,$39,$be,$84,$45,$fd,$09,$37
>1ac8	30 39 33 36 31 36 00 14			.byte	$30,$39,$33,$36,$31,$36,$00,$14
>1ad0	14 05 dc bd 8b 43 73 76			.byte	$14,$05,$dc,$bd,$8b,$43,$73,$76
>1ad8	68 87 42 69 62 4f be 84			.byte	$68,$87,$42,$69,$62,$4f,$be,$84
>1ae0	8b 41 00 14 1e 05 dc bd			.byte	$8b,$41,$00,$14,$1e,$05,$dc,$bd
>1ae8	43 52 7b 6e 82 43 56 5a			.byte	$43,$52,$7b,$6e,$82,$43,$56,$5a
>1af0	49 be 84 44 61 67 00 0e			.byte	$49,$be,$84,$44,$61,$67,$00,$0e
>1af8	28 05 dc bd b3 60 7b 6a			.byte	$28,$05,$dc,$bd,$b3,$60,$7b,$6a
>1b00	be be 84 41 00 0e 32 05			.byte	$be,$be,$84,$41,$00,$0e,$32,$05
>1b08	dc bd af fe 03 30 be be			.byte	$dc,$bd,$af,$fe,$03,$30,$be,$be
>1b10	84 40 00 24 3c 05 dc bd			.byte	$84,$40,$00,$24,$3c,$05,$dc,$bd
>1b18	41 44 7c 71 fd 03 33 8d			.byte	$41,$44,$7c,$71,$fd,$03,$33,$8d
>1b20	8b 4a 4c 62 fd 05 35 32			.byte	$8b,$4a,$4c,$62,$fd,$05,$35,$32
>1b28	31 be 84 8b 46 fd 09 37			.byte	$31,$be,$84,$8b,$46,$fd,$09,$37
>1b30	36 32 34 35 38 32 00 14			.byte	$36,$32,$34,$35,$38,$32,$00,$14
>1b38	46 05 dc bd 8b 42 56 72			.byte	$46,$05,$dc,$bd,$8b,$42,$56,$72
>1b40	6d 84 8b 41 4d 6e 73 be			.byte	$6d,$84,$8b,$41,$4d,$6e,$73,$be
>1b48	84 40 00 16 50 05 dc bd			.byte	$84,$40,$00,$16,$50,$05,$dc,$bd
>1b50	42 73 67 4a 80 8b 41 58			.byte	$42,$73,$67,$4a,$80,$8b,$41,$58
>1b58	50 63 be 84 42 63 67 48			.byte	$50,$63,$be,$84,$42,$63,$67,$48
>1b60	00 10 5a 05 dc bd b2 40			.byte	$00,$10,$5a,$05,$dc,$bd,$b2,$40
>1b68	bf 69 63 5a be be 84 40			.byte	$bf,$69,$63,$5a,$be,$be,$84,$40
>1b70	00 12 64 05 dc bd a0 fe			.byte	$00,$12,$64,$05,$dc,$bd,$a0,$fe
>1b78	03 70 bf 41 be be 84 fe			.byte	$03,$70,$bf,$41,$be,$be,$84,$fe
>1b80	03 70 00 1a 6e 05 dc bd			.byte	$03,$70,$00,$1a,$6e,$05,$dc,$bd
>1b88	42 78 61 76 fd 04 33 33			.byte	$42,$78,$61,$76,$fd,$04,$33,$33
>1b90	87 8b 5d 4d 66 fd 04 36			.byte	$87,$8b,$5d,$4d,$66,$fd,$04,$36
>1b98	35 be 84 40 00 12 78 05			.byte	$35,$be,$84,$40,$00,$12,$78,$05
>1ba0	dc bd 75 70 61 85 43 65			.byte	$dc,$bd,$75,$70,$61,$85,$43,$65
>1ba8	4e 46 be 84 8b 41 00 18			.byte	$4e,$46,$be,$84,$8b,$41,$00,$18
>1bb0	82 05 dc bd 8b 43 6b 6d			.byte	$82,$05,$dc,$bd,$8b,$43,$6b,$6d
>1bb8	40 80 8b 43 4f 5f 5b be			.byte	$40,$80,$8b,$43,$4f,$5f,$5b,$be
>1bc0	84 8b 43 70 40 40 00 10			.byte	$84,$8b,$43,$70,$40,$40,$00,$10
>1bc8	8c 05 dc bd 98 8b 6b 52			.byte	$8c,$05,$dc,$bd,$98,$8b,$6b,$52
>1bd0	44 be 84 6b 52 43 00 18			.byte	$44,$be,$84,$6b,$52,$43,$00,$18
>1bd8	96 05 dc bd a1 fe 06 6c			.byte	$96,$05,$dc,$bd,$a1,$fe,$06,$6c
>1be0	64 67 79 bf 4a be be 84			.byte	$64,$67,$79,$bf,$4a,$be,$be,$84
>1be8	fe 06 6c 64 67 79 00 27			.byte	$fe,$06,$6c,$64,$67,$79,$00,$27
>1bf0	a0 05 dc bd 43 6c 4f 52			.byte	$a0,$05,$dc,$bd,$43,$6c,$4f,$52
>1bf8	fd 04 35 38 8c 43 4a 46			.byte	$fd,$04,$35,$38,$8c,$43,$4a,$46
>1c00	7d fd 04 35 37 be 84 48			.byte	$7d,$fd,$04,$35,$37,$be,$84,$48
>1c08	fd 0d 30 31 30 34 34 32			.byte	$fd,$0d,$30,$31,$30,$34,$34,$32
>1c10	36 32 65 31 31 00 11 aa			.byte	$36,$32,$65,$31,$31,$00,$11,$aa
>1c18	05 dc bd 40 89 8b 43 52			.byte	$05,$dc,$bd,$40,$89,$8b,$43,$52
>1c20	79 71 be 84 8b 41 00 15			.byte	$79,$71,$be,$84,$8b,$41,$00,$15
>1c28	b4 05 dc bd 8b 43 64 56			.byte	$b4,$05,$dc,$bd,$8b,$43,$64,$56
>1c30	60 80 42 4b 64 60 be 84			.byte	$60,$80,$42,$4b,$64,$60,$be,$84
>1c38	4b 60 60 00 1e be 05 dc			.byte	$4b,$60,$60,$00,$1e,$be,$05,$dc
>1c40	bd a5 a4 8b 42 7f 49 4b			.byte	$bd,$a5,$a4,$8b,$42,$7f,$49,$4b
>1c48	fd 04 35 36 be be be 84			.byte	$fd,$04,$35,$36,$be,$be,$be,$84
>1c50	8b 42 7f 49 4b fd 04 35			.byte	$8b,$42,$7f,$49,$4b,$fd,$04,$35
>1c58	36 00 12 c8 05 dc bd a2			.byte	$36,$00,$12,$c8,$05,$dc,$bd,$a2
>1c60	fe 02 bf 48 bf 42 be be			.byte	$fe,$02,$bf,$48,$bf,$42,$be,$be
>1c68	84 fe 02 00 1a d2 05 dc			.byte	$84,$fe,$02,$00,$1a,$d2,$05,$dc
>1c70	bd 43 52 79 5d fd 04 38			.byte	$bd,$43,$52,$79,$5d,$fd,$04,$38
>1c78	35 84 41 7c 65 6a fd 04			.byte	$35,$84,$41,$7c,$65,$6a,$fd,$04
>1c80	39 39 be 84 40 00 13 dc			.byte	$39,$39,$be,$84,$40,$00,$13,$dc
>1c88	05 dc bd 8b 4a 5e 4f 8d			.byte	$05,$dc,$bd,$8b,$4a,$5e,$4f,$8d
>1c90	8b 43 4e 4d 53 be 84 40			.byte	$8b,$43,$4e,$4d,$53,$be,$84,$40
>1c98	00 16 e6 05 dc bd 8b 43			.byte	$00,$16,$e6,$05,$dc,$bd,$8b,$43
>1ca0	65 6a 79 82 8b 43 5d 5f			.byte	$65,$6a,$79,$82,$8b,$43,$5d,$5f
>1ca8	73 be 84 78 75 4a 00 13			.byte	$73,$be,$84,$78,$75,$4a,$00,$13
>1cb0	f0 05 dc bd 9a 8b 42 6a			.byte	$f0,$05,$dc,$bd,$9a,$8b,$42,$6a
>1cb8	7b 56 be be 84 42 6a 7b			.byte	$7b,$56,$be,$be,$84,$42,$6a,$7b
>1cc0	56 00 11 fa 05 dc bd a6			.byte	$56,$00,$11,$fa,$05,$dc,$bd,$a6
>1cc8	fe 06 74 78 65 78 be be			.byte	$fe,$06,$74,$78,$65,$78,$be,$be
>1cd0	84 44 00 1f 04 06 dc bd			.byte	$84,$44,$00,$1f,$04,$06,$dc,$bd
>1cd8	42 75 5a 51 fd 04 30 33			.byte	$42,$75,$5a,$51,$fd,$04,$30,$33
>1ce0	8a 42 46 44 6a fd 03 38			.byte	$8a,$42,$46,$44,$6a,$fd,$03,$38
>1ce8	be 84 44 7b 5e 7b fd 03			.byte	$be,$84,$44,$7b,$5e,$7b,$fd,$03
>1cf0	38 00 13 0e 06 dc bd 8b			.byte	$38,$00,$13,$0e,$06,$dc,$bd,$8b
>1cf8	43 49 5c 73 89 42 6a 66			.byte	$43,$49,$5c,$73,$89,$42,$6a,$66
>1d00	4b be 84 40 00 14 18 06			.byte	$4b,$be,$84,$40,$00,$14,$18,$06
>1d08	dc bd 41 66 72 48 82 4e			.byte	$dc,$bd,$41,$66,$72,$48,$82,$4e
>1d10	55 61 be 84 41 68 67 69			.byte	$55,$61,$be,$84,$41,$68,$67,$69
>1d18	00 0f 22 06 dc bd b3 43			.byte	$00,$0f,$22,$06,$dc,$bd,$b3,$43
>1d20	6a 6b 72 be be 84 41 00			.byte	$6a,$6b,$72,$be,$be,$84,$41,$00
>1d28	13 2c 06 dc bd 9b fe 07			.byte	$13,$2c,$06,$dc,$bd,$9b,$fe,$07
>1d30	6a 63 6f 6d 72 be be 84			.byte	$6a,$63,$6f,$6d,$72,$be,$be,$84
>1d38	41 6a 00 1b 36 06 dc bd			.byte	$41,$6a,$00,$1b,$36,$06,$dc,$bd
>1d40	8b 7a 47 43 fd 03 33 8b			.byte	$8b,$7a,$47,$43,$fd,$03,$33,$8b
>1d48	40 fd 03 30 be 84 8b 7a			.byte	$40,$fd,$03,$30,$be,$84,$8b,$7a
>1d50	47 43 fd 03 33 00 0d 40			.byte	$47,$43,$fd,$03,$33,$00,$0d,$40
>1d58	06 dc bd 40 84 40 be 84			.byte	$06,$dc,$bd,$40,$84,$40,$be,$84
>1d60	8b 41 00 12 4a 06 dc bd			.byte	$8b,$41,$00,$12,$4a,$06,$dc,$bd
>1d68	40 82 41 7d 5d 4a be 84			.byte	$40,$82,$41,$7d,$5d,$4a,$be,$84
>1d70	41 7d 5d 4a 00 17 54 06			.byte	$41,$7d,$5d,$4a,$00,$17,$54,$06
>1d78	dc bd b2 8b 41 6f 52 6c			.byte	$dc,$bd,$b2,$8b,$41,$6f,$52,$6c
>1d80	bf 8b 5f 79 71 be be 84			.byte	$bf,$8b,$5f,$79,$71,$be,$be,$84
>1d88	4f 65 59 00 0f 5e 06 dc			.byte	$4f,$65,$59,$00,$0f,$5e,$06,$dc
>1d90	bd b4 41 4a be be 84 fe			.byte	$bd,$b4,$41,$4a,$be,$be,$84,$fe
>1d98	03 4a 00 1e 68 06 dc bd			.byte	$03,$4a,$00,$1e,$68,$06,$dc,$bd
>1da0	40 fd 03 30 8b 41 73 67			.byte	$40,$fd,$03,$30,$8b,$41,$73,$67
>1da8	6b fd 04 39 31 be 84 8b			.byte	$6b,$fd,$04,$39,$31,$be,$84,$8b
>1db0	41 73 67 6b fd 04 39 31			.byte	$41,$73,$67,$6b,$fd,$04,$39,$31
>1db8	00 13 72 06 dc bd 42 69			.byte	$00,$13,$72,$06,$dc,$bd,$42,$69
>1dc0	67 6a 85 41 66 59 7a be			.byte	$67,$6a,$85,$41,$66,$59,$7a,$be
>1dc8	84 8b 41 00 14 7c 06 dc			.byte	$84,$8b,$41,$00,$14,$7c,$06,$dc
>1dd0	bd 43 47 6f 77 81 74 47			.byte	$bd,$43,$47,$6f,$77,$81,$74,$47
>1dd8	4c be 84 43 77 6f 7f 00			.byte	$4c,$be,$84,$43,$77,$6f,$7f,$00
>1de0	10 86 06 dc bd 98 69 66			.byte	$10,$86,$06,$dc,$bd,$98,$69,$66
>1de8	41 be 84 8b 69 66 42 00			.byte	$41,$be,$84,$8b,$69,$66,$42,$00
>1df0	1c 90 06 dc bd a3 4f be			.byte	$1c,$90,$06,$dc,$bd,$a3,$4f,$be
>1df8	be 84 fe 11 20 20 20 20			.byte	$be,$84,$fe,$11,$20,$20,$20,$20
>1e00	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>1e08	20 20 20 00 25 9a 06 dc			.byte	$20,$20,$20,$00,$25,$9a,$06,$dc
>1e10	bd 8b 41 5e 73 51 fd 04			.byte	$bd,$8b,$41,$5e,$73,$51,$fd,$04
>1e18	35 35 8d 41 4e 7c 58 fd			.byte	$35,$35,$8d,$41,$4e,$7c,$58,$fd
>1e20	04 35 31 be 84 8b 41 fd			.byte	$04,$35,$31,$be,$84,$8b,$41,$fd
>1e28	09 32 30 30 38 37 33 38			.byte	$09,$32,$30,$30,$38,$37,$33,$38
>1e30	00 13 a4 06 dc bd 43 57			.byte	$00,$13,$a4,$06,$dc,$bd,$43,$57
>1e38	6e 66 87 8b 43 53 76 4a			.byte	$6e,$66,$87,$8b,$43,$53,$76,$4a
>1e40	be 84 40 00 15 ae 06 dc			.byte	$be,$84,$40,$00,$15,$ae,$06,$dc
>1e48	bd 8b 76 7b 7c 81 8b 70			.byte	$bd,$8b,$76,$7b,$7c,$81,$8b,$70
>1e50	48 69 be 84 8b 70 48 69			.byte	$48,$69,$be,$84,$8b,$70,$48,$69
>1e58	00 1e b8 06 dc bd a5 a4			.byte	$00,$1e,$b8,$06,$dc,$bd,$a5,$a4
>1e60	8b 42 73 6a 45 fd 04 34			.byte	$8b,$42,$73,$6a,$45,$fd,$04,$34
>1e68	31 be be be 84 8b 42 73			.byte	$31,$be,$be,$be,$84,$8b,$42,$73
>1e70	6a 45 fd 04 34 31 00 15			.byte	$6a,$45,$fd,$04,$34,$31,$00,$15
>1e78	c2 06 dc bd a7 41 5c 55			.byte	$c2,$06,$dc,$bd,$a7,$41,$5c,$55
>1e80	7b be be 84 fe 07 35 43			.byte	$7b,$be,$be,$84,$fe,$07,$35,$43
>1e88	35 37 42 00 21 cc 06 dc			.byte	$35,$37,$42,$00,$21,$cc,$06,$dc
>1e90	bd 8b 41 70 67 64 fd 04			.byte	$bd,$8b,$41,$70,$67,$64,$fd,$04
>1e98	33 32 8a 42 66 61 7c fd			.byte	$33,$32,$8a,$42,$66,$61,$7c,$fd
>1ea0	04 30 39 be 84 75 7a 57			.byte	$04,$30,$39,$be,$84,$75,$7a,$57
>1ea8	fd 04 37 37 00 13 d6 06			.byte	$fd,$04,$37,$37,$00,$13,$d6,$06
>1eb0	dc bd 8b 43 64 61 4a 89			.byte	$dc,$bd,$8b,$43,$64,$61,$4a,$89
>1eb8	43 5e 60 5c be 84 40 00			.byte	$43,$5e,$60,$5c,$be,$84,$40,$00
>1ec0	17 e0 06 dc bd 42 7a 4c			.byte	$17,$e0,$06,$dc,$bd,$42,$7a,$4c
>1ec8	45 82 8b 43 54 6e 66 be			.byte	$45,$82,$8b,$43,$54,$6e,$66,$be
>1ed0	84 8b 41 6e 62 61 00 0c			.byte	$84,$8b,$41,$6e,$62,$61,$00,$0c
>1ed8	ea 06 dc bd 9a 40 be be			.byte	$ea,$06,$dc,$bd,$9a,$40,$be,$be
>1ee0	84 40 00 13 f4 06 dc bd			.byte	$84,$40,$00,$13,$f4,$06,$dc,$bd
>1ee8	af fe 06 43 37 35 39 be			.byte	$af,$fe,$06,$43,$37,$35,$39,$be
>1ef0	be 84 4c 5d 59 00 1c fe			.byte	$be,$84,$4c,$5d,$59,$00,$1c,$fe
>1ef8	06 dc bd 8b 41 6c 61 60			.byte	$06,$dc,$bd,$8b,$41,$6c,$61,$60
>1f00	fd 04 39 39 86 43 5b 64			.byte	$fd,$04,$39,$39,$86,$43,$5b,$64
>1f08	70 fd 04 34 37 be 84 8b			.byte	$70,$fd,$04,$34,$37,$be,$84,$8b
>1f10	41 00 11 08 07 dc bd 8b			.byte	$41,$00,$11,$08,$07,$dc,$bd,$8b
>1f18	42 43 57 77 85 40 be 84			.byte	$42,$43,$57,$77,$85,$40,$be,$84
>1f20	8b 41 00 16 12 07 dc bd			.byte	$8b,$41,$00,$16,$12,$07,$dc,$bd
>1f28	8b 42 5f 68 51 80 41 46			.byte	$8b,$42,$5f,$68,$51,$80,$41,$46
>1f30	4a 58 be 84 41 40 42 48			.byte	$4a,$58,$be,$84,$41,$40,$42,$48
>1f38	00 0e 1c 07 dc bd b3 54			.byte	$00,$0e,$1c,$07,$dc,$bd,$b3,$54
>1f40	5d 52 be be 84 41 00 18			.byte	$5d,$52,$be,$be,$84,$41,$00,$18
>1f48	26 07 dc bd a0 fe 09 77			.byte	$26,$07,$dc,$bd,$a0,$fe,$09,$77
>1f50	6e 64 73 63 6d 67 bf 41			.byte	$6e,$64,$73,$63,$6d,$67,$bf,$41
>1f58	be be 84 fe 03 77 00 29			.byte	$be,$be,$84,$fe,$03,$77,$00,$29
>1f60	30 07 dc bd 8b 42 43 70			.byte	$30,$07,$dc,$bd,$8b,$42,$43,$70
>1f68	66 fd 04 33 34 8c 48 7c			.byte	$66,$fd,$04,$33,$34,$8c,$48,$7c
>1f70	5d fd 05 37 39 33 be 84			.byte	$5d,$fd,$05,$37,$39,$33,$be,$84
>1f78	8b 41 fd 0d 39 37 37 32			.byte	$8b,$41,$fd,$0d,$39,$37,$37,$32
>1f80	39 31 36 36 65 31 30 00			.byte	$39,$31,$36,$36,$65,$31,$30,$00
>1f88	15 3a 07 dc bd 41 62 6c			.byte	$15,$3a,$07,$dc,$bd,$41,$62,$6c
>1f90	51 8b 41 68 53 63 be 84			.byte	$51,$8b,$41,$68,$53,$63,$be,$84
>1f98	8b 45 67 52 00 15 44 07			.byte	$8b,$45,$67,$52,$00,$15,$44,$07
>1fa0	dc bd 41 5b 45 51 81 8b			.byte	$dc,$bd,$41,$5b,$45,$51,$81,$8b
>1fa8	64 6a 5d be 84 8b 64 6a			.byte	$64,$6a,$5d,$be,$84,$8b,$64,$6a
>1fb0	4d 00 17 4e 07 dc bd b2			.byte	$4d,$00,$17,$4e,$07,$dc,$bd,$b2
>1fb8	8b 5d 68 4a bf 8b 42 64			.byte	$8b,$5d,$68,$4a,$bf,$8b,$42,$64
>1fc0	7c 4f be be 84 5d 68 4a			.byte	$7c,$4f,$be,$be,$84,$5d,$68,$4a
>1fc8	00 14 58 07 dc bd a1 fe			.byte	$00,$14,$58,$07,$dc,$bd,$a1,$fe
>1fd0	04 72 68 bf 44 be be 84			.byte	$04,$72,$68,$bf,$44,$be,$be,$84
>1fd8	fe 04 72 68 00 1c 62 07			.byte	$fe,$04,$72,$68,$00,$1c,$62,$07
>1fe0	dc bd 8b 42 75 47 5f fd			.byte	$dc,$bd,$8b,$42,$75,$47,$5f,$fd
>1fe8	04 39 37 85 8b 70 4d 5a			.byte	$04,$39,$37,$85,$8b,$70,$4d,$5a
>1ff0	fd 04 37 35 be 84 8b 41			.byte	$fd,$04,$37,$35,$be,$84,$8b,$41
>1ff8	00 15 6c 07 dc bd 8b 42			.byte	$00,$15,$6c,$07,$dc,$bd,$8b,$42
>2000	4f 51 6d 85 8b 43 53 68			.byte	$4f,$51,$6d,$85,$8b,$43,$53,$68
>2008	70 be 84 8b 41 00 15 76			.byte	$70,$be,$84,$8b,$41,$00,$15,$76
>2010	07 dc bd 42 79 5d 76 80			.byte	$07,$dc,$bd,$42,$79,$5d,$76,$80
>2018	42 48 6d 4f be 84 42 48			.byte	$42,$48,$6d,$4f,$be,$84,$42,$48
>2020	4d 46 00 10 80 07 dc bd			.byte	$4d,$46,$00,$10,$80,$07,$dc,$bd
>2028	98 8b 6a 7f 63 be 84 6a			.byte	$98,$8b,$6a,$7f,$63,$be,$84,$6a
>2030	7f 62 00 22 8a 07 dc bd			.byte	$7f,$62,$00,$22,$8a,$07,$dc,$bd
>2038	a2 fe 0c 62 6e 72 67 6f			.byte	$a2,$fe,$0c,$62,$6e,$72,$67,$6f
>2040	78 68 77 6e 64 bf 45 bf			.byte	$78,$68,$77,$6e,$64,$bf,$45,$bf
>2048	46 be be 84 fe 08 6f 78			.byte	$46,$be,$be,$84,$fe,$08,$6f,$78
>2050	68 77 6e 64 00 27 94 07			.byte	$68,$77,$6e,$64,$00,$27,$94,$07
>2058	dc bd 8b 61 43 45 fd 03			.byte	$dc,$bd,$8b,$61,$43,$45,$fd,$03
>2060	37 8c 8b 42 7c 65 5c fd			.byte	$37,$8c,$8b,$42,$7c,$65,$5c,$fd
>2068	04 30 39 be 84 41 fd 0d			.byte	$04,$30,$39,$be,$84,$41,$fd,$0d
>2070	30 34 35 36 32 34 33 32			.byte	$30,$34,$35,$36,$32,$34,$33,$32
>2078	65 31 31 00 11 9e 07 dc			.byte	$65,$31,$31,$00,$11,$9e,$07,$dc
>2080	bd 8b 43 70 4d 67 87 40			.byte	$bd,$8b,$43,$70,$4d,$67,$87,$40
>2088	be 84 8b 41 00 12 a8 07			.byte	$be,$84,$8b,$41,$00,$12,$a8,$07
>2090	dc bd 40 81 41 77 44 47			.byte	$dc,$bd,$40,$81,$41,$77,$44,$47
>2098	be 84 41 77 44 47 00 1c			.byte	$be,$84,$41,$77,$44,$47,$00,$1c
>20a0	b2 07 dc bd a5 a4 42 51			.byte	$b2,$07,$dc,$bd,$a5,$a4,$42,$51
>20a8	5c 6d fd 04 34 34 be be			.byte	$5c,$6d,$fd,$04,$34,$34,$be,$be
>20b0	be 84 42 51 5c 6d fd 04			.byte	$be,$84,$42,$51,$5c,$6d,$fd,$04
>20b8	34 34 00 12 bc 07 dc bd			.byte	$34,$34,$00,$12,$bc,$07,$dc,$bd
>20c0	a6 fe 07 74 7a 68 77 6d			.byte	$a6,$fe,$07,$74,$7a,$68,$77,$6d
>20c8	be be 84 45 00 1a c6 07			.byte	$be,$be,$84,$45,$00,$1a,$c6,$07
>20d0	dc bd 42 42 53 43 fd 04			.byte	$dc,$bd,$42,$42,$53,$43,$fd,$04
>20d8	34 34 86 8b 71 7e 48 fd			.byte	$34,$34,$86,$8b,$71,$7e,$48,$fd
>20e0	04 37 35 be 84 40 00 12			.byte	$04,$37,$35,$be,$84,$40,$00,$12
>20e8	d0 07 dc bd 63 72 6b 84			.byte	$d0,$07,$dc,$bd,$63,$72,$6b,$84
>20f0	8b 42 7b 60 44 be 84 40			.byte	$8b,$42,$7b,$60,$44,$be,$84,$40
>20f8	00 18 da 07 dc bd 8b 41			.byte	$00,$18,$da,$07,$dc,$bd,$8b,$41
>2100	53 66 6c 80 8b 41 64 4e			.byte	$53,$66,$6c,$80,$8b,$41,$64,$4e
>2108	72 be 84 8b 41 77 6e 7c			.byte	$72,$be,$84,$8b,$41,$77,$6e,$7c
>2110	00 12 e4 07 dc bd 9a 42			.byte	$00,$12,$e4,$07,$dc,$bd,$9a,$42
>2118	4f 5f 74 be be 84 42 4f			.byte	$4f,$5f,$74,$be,$be,$84,$42,$4f
>2120	5f 74 00 20 ee 07 dc bd			.byte	$5f,$74,$00,$20,$ee,$07,$dc,$bd
>2128	42 6d 42 63 fd 04 39 33			.byte	$42,$6d,$42,$63,$fd,$04,$39,$33
>2130	8b 8b 42 4d 5e 72 fd 03			.byte	$8b,$8b,$42,$4d,$5e,$72,$fd,$03
>2138	30 be 84 44 7a 61 55 fd			.byte	$30,$be,$84,$44,$7a,$61,$55,$fd
>2140	03 39 00 16 f8 07 dc bd			.byte	$03,$39,$00,$16,$f8,$07,$dc,$bd
>2148	42 50 4c 60 8b 8b 43 58			.byte	$42,$50,$4c,$60,$8b,$8b,$43,$58
>2150	79 7e be 84 45 69 46 5e			.byte	$79,$7e,$be,$84,$45,$69,$46,$5e
>2158	00 16 02 08 dc bd 4f 69			.byte	$00,$16,$02,$08,$dc,$bd,$4f,$69
>2160	44 81 8b 42 70 7f 70 be			.byte	$44,$81,$8b,$42,$70,$7f,$70,$be
>2168	84 8b 42 70 56 6c 00 0c			.byte	$84,$8b,$42,$70,$56,$6c,$00,$0c
>2170	0c 08 dc bd b3 40 be be			.byte	$0c,$08,$dc,$bd,$b3,$40,$be,$be
>2178	84 40 00 0f 16 08 dc bd			.byte	$84,$40,$00,$0f,$16,$08,$dc,$bd
>2180	b4 41 40 be be 84 fe 03			.byte	$b4,$41,$40,$be,$be,$84,$fe,$03
>2188	40 00 1b 20 08 dc bd 8b			.byte	$40,$00,$1b,$20,$08,$dc,$bd,$8b
>2190	42 5f 5a 45 fd 04 39 38			.byte	$42,$5f,$5a,$45,$fd,$04,$39,$38
>2198	84 8b 41 49 50 46 fd 03			.byte	$84,$8b,$41,$49,$50,$46,$fd,$03
>21a0	35 be 84 40 00 11 2a 08			.byte	$35,$be,$84,$40,$00,$11,$2a,$08
>21a8	dc bd 8b 41 51 44 4f 87			.byte	$dc,$bd,$8b,$41,$51,$44,$4f,$87
>21b0	40 be 84 8b 41 00 16 34			.byte	$40,$be,$84,$8b,$41,$00,$16,$34
>21b8	08 dc bd 8b 41 52 4c 4d			.byte	$08,$dc,$bd,$8b,$41,$52,$4c,$4d
>21c0	81 43 50 7f 49 be 84 8b			.byte	$81,$43,$50,$7f,$49,$be,$84,$8b
>21c8	42 40 45 00 16 3e 08 dc			.byte	$42,$40,$45,$00,$16,$3e,$08,$dc
>21d0	bd b2 8b 42 5a 56 44 bf			.byte	$bd,$b2,$8b,$42,$5a,$56,$44,$bf
>21d8	54 68 57 be be 84 49 7b			.byte	$54,$68,$57,$be,$be,$84,$49,$7b
>21e0	63 00 19 48 08 dc bd a3			.byte	$63,$00,$19,$48,$08,$dc,$bd,$a3
>21e8	4c be be 84 fe 0e 20 20			.byte	$4c,$be,$be,$84,$fe,$0e,$20,$20
>21f0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>21f8	20 20 00 28 52 08 dc bd			.byte	$20,$20,$00,$28,$52,$08,$dc,$bd
>2200	8b 52 74 44 fd 05 32 32			.byte	$8b,$52,$74,$44,$fd,$05,$32,$32
>2208	38 8c 8b 42 78 55 5b fd			.byte	$38,$8c,$8b,$42,$78,$55,$5b,$fd
>2210	03 34 be 84 45 fd 0d 38			.byte	$03,$34,$be,$84,$45,$fd,$0d,$38
>2218	31 38 33 32 30 30 34 65			.byte	$31,$38,$33,$32,$30,$30,$34,$65
>2220	31 30 00 15 5c 08 dc bd			.byte	$31,$30,$00,$15,$5c,$08,$dc,$bd
>2228	8b 41 59 4d 65 85 8b 43			.byte	$8b,$41,$59,$4d,$65,$85,$8b,$43
>2230	53 6a 4d be 84 8b 41 00			.byte	$53,$6a,$4d,$be,$84,$8b,$41,$00
>2238	16 66 08 dc bd 8b 43 5f			.byte	$16,$66,$08,$dc,$bd,$8b,$43,$5f
>2240	7f 6d 82 43 50 68 69 be			.byte	$7f,$6d,$82,$43,$50,$68,$69,$be
>2248	84 8b 4f 57 46 00 12 70			.byte	$84,$8b,$4f,$57,$46,$00,$12,$70
>2250	08 dc bd 98 8b 41 5f 40			.byte	$08,$dc,$bd,$98,$8b,$41,$5f,$40
>2258	6b be 84 41 5f 40 6a 00			.byte	$6b,$be,$84,$41,$5f,$40,$6a,$00
>2260	15 7a 08 dc bd a7 42 70			.byte	$15,$7a,$08,$dc,$bd,$a7,$42,$70
>2268	5f 6d be be 84 fe 07 42			.byte	$5f,$6d,$be,$be,$84,$fe,$07,$42
>2270	30 37 45 44 00 17 84 08			.byte	$30,$37,$45,$44,$00,$17,$84,$08
>2278	dc bd 42 68 6e 6e fd 04			.byte	$dc,$bd,$42,$68,$6e,$6e,$fd,$04
>2280	31 36 88 40 fd 03 30 be			.byte	$31,$36,$88,$40,$fd,$03,$30,$be
>2288	84 8b 41 00 17 8e 08 dc			.byte	$84,$8b,$41,$00,$17,$8e,$08,$dc
>2290	bd 8b 7e 62 74 8a 8b 41			.byte	$bd,$8b,$7e,$62,$74,$8a,$8b,$41
>2298	60 70 74 be 84 8b 42 5f			.byte	$60,$70,$74,$be,$84,$8b,$42,$5f
>22a0	53 68 00 16 98 08 dc bd			.byte	$53,$68,$00,$16,$98,$08,$dc,$bd
>22a8	8b 42 58 7e 7d 82 71 66			.byte	$8b,$42,$58,$7e,$7d,$82,$71,$66
>22b0	78 be 84 8b 42 69 58 45			.byte	$78,$be,$84,$8b,$42,$69,$58,$45
>22b8	00 1c a2 08 dc bd a5 a4			.byte	$00,$1c,$a2,$08,$dc,$bd,$a5,$a4
>22c0	43 6a 52 6a fd 04 35 32			.byte	$43,$6a,$52,$6a,$fd,$04,$35,$32
>22c8	be be be 84 43 6a 52 6a			.byte	$be,$be,$be,$84,$43,$6a,$52,$6a
>22d0	fd 04 35 32 00 15 ac 08			.byte	$fd,$04,$35,$32,$00,$15,$ac,$08
>22d8	dc bd af fe 07 36 41 33			.byte	$dc,$bd,$af,$fe,$07,$36,$41,$33
>22e0	33 42 be be 84 41 6a 4c			.byte	$33,$42,$be,$be,$84,$41,$6a,$4c
>22e8	7b 00 1a b6 08 dc bd 40			.byte	$7b,$00,$1a,$b6,$08,$dc,$bd,$40
>22f0	fd 03 30 8d 8b 6d 5d 45			.byte	$fd,$03,$30,$8d,$8b,$6d,$5d,$45
>22f8	fd 04 30 32 be 84 8b 40			.byte	$fd,$04,$30,$32,$be,$84,$8b,$40
>2300	fd 03 30 00 10 c0 08 dc			.byte	$fd,$03,$30,$00,$10,$c0,$08,$dc
>2308	bd 41 78 70 4a 89 40 be			.byte	$bd,$41,$78,$70,$4a,$89,$40,$be
>2310	84 8b 41 00 17 ca 08 dc			.byte	$84,$8b,$41,$00,$17,$ca,$08,$dc
>2318	bd 8b 42 6b 42 55 82 41			.byte	$bd,$8b,$42,$6b,$42,$55,$82,$41
>2320	79 78 59 be 84 8b 43 52			.byte	$79,$78,$59,$be,$84,$8b,$43,$52
>2328	7a 4e 00 12 d4 08 dc bd			.byte	$7a,$4e,$00,$12,$d4,$08,$dc,$bd
>2330	9a 42 50 55 6c be be 84			.byte	$9a,$42,$50,$55,$6c,$be,$be,$84
>2338	42 50 55 6c 00 1e de 08			.byte	$42,$50,$55,$6c,$00,$1e,$de,$08
>2340	dc bd a0 fe 0a 67 69 7a			.byte	$dc,$bd,$a0,$fe,$0a,$67,$69,$7a
>2348	65 78 68 75 70 bf 46 be			.byte	$65,$78,$68,$75,$70,$bf,$46,$be
>2350	be 84 fe 08 67 69 7a 65			.byte	$be,$84,$fe,$08,$67,$69,$7a,$65
>2358	78 68 00 1e e8 08 dc bd			.byte	$78,$68,$00,$1e,$e8,$08,$dc,$bd
>2360	40 fd 03 30 8b 8b 41 62			.byte	$40,$fd,$03,$30,$8b,$8b,$41,$62
>2368	6e 48 fd 04 36 33 be 84			.byte	$6e,$48,$fd,$04,$36,$33,$be,$84
>2370	41 62 6e 48 fd 04 36 33			.byte	$41,$62,$6e,$48,$fd,$04,$36,$33
>2378	00 12 f2 08 dc bd 41 6a			.byte	$00,$12,$f2,$08,$dc,$bd,$41,$6a
>2380	68 47 8d 41 6a 68 47 be			.byte	$68,$47,$8d,$41,$6a,$68,$47,$be
>2388	84 41 00 17 fc 08 dc bd			.byte	$84,$41,$00,$17,$fc,$08,$dc,$bd
>2390	8b 62 48 43 80 8b 43 57			.byte	$8b,$62,$48,$43,$80,$8b,$43,$57
>2398	5e 77 be 84 8b 43 77 5e			.byte	$5e,$77,$be,$84,$8b,$43,$77,$5e
>23a0	77 00 0f 06 09 dc bd b3			.byte	$77,$00,$0f,$06,$09,$dc,$bd,$b3
>23a8	43 73 63 7f be be 84 41			.byte	$43,$73,$63,$7f,$be,$be,$84,$41
>23b0	00 16 10 09 dc bd a1 fe			.byte	$00,$16,$10,$09,$dc,$bd,$a1,$fe
>23b8	07 68 73 67 79 63 bf 41			.byte	$07,$68,$73,$67,$79,$63,$bf,$41
>23c0	be be 84 fe 03 63 00 18			.byte	$be,$be,$84,$fe,$03,$63,$00,$18
>23c8	1a 09 dc bd 40 fd 03 30			.byte	$1a,$09,$dc,$bd,$40,$fd,$03,$30
>23d0	89 8b 41 4d 54 53 fd 04			.byte	$89,$8b,$41,$4d,$54,$53,$fd,$04
>23d8	34 32 be 84 8b 41 00 14			.byte	$34,$32,$be,$84,$8b,$41,$00,$14
>23e0	24 09 dc bd 8b 42 59 5f			.byte	$24,$09,$dc,$bd,$8b,$42,$59,$5f
>23e8	53 87 8b 71 6f 5f be 84			.byte	$53,$87,$8b,$71,$6f,$5f,$be,$84
>23f0	8b 41 00 14 2e 09 dc bd			.byte	$8b,$41,$00,$14,$2e,$09,$dc,$bd
>23f8	41 4e 43 4c 81 8b 4e 61			.byte	$41,$4e,$43,$4c,$81,$8b,$4e,$61
>2400	40 be 84 8b 60 74 00 17			.byte	$40,$be,$84,$8b,$60,$74,$00,$17
>2408	38 09 dc bd b2 8b 6d 41			.byte	$38,$09,$dc,$bd,$b2,$8b,$6d,$41
>2410	67 bf 8b 42 4a 43 7d be			.byte	$67,$bf,$8b,$42,$4a,$43,$7d,$be
>2418	be 84 6d 41 67 00 12 42			.byte	$be,$84,$6d,$41,$67,$00,$12,$42
>2420	09 dc bd a2 fe 02 bf 44			.byte	$09,$dc,$bd,$a2,$fe,$02,$bf,$44
>2428	bf 4a be be 84 fe 02 00			.byte	$bf,$4a,$be,$be,$84,$fe,$02,$00
>2430	1b 4c 09 dc bd 43 69 67			.byte	$1b,$4c,$09,$dc,$bd,$43,$69,$67
>2438	60 fd 04 39 39 87 43 6e			.byte	$60,$fd,$04,$39,$39,$87,$43,$6e
>2440	5a 65 fd 04 35 33 be 84			.byte	$5a,$65,$fd,$04,$35,$33,$be,$84
>2448	8b 41 00 0f 56 09 dc bd			.byte	$8b,$41,$00,$0f,$56,$09,$dc,$bd
>2450	42 65 60 44 8c 40 be 84			.byte	$42,$65,$60,$44,$8c,$40,$be,$84
>2458	40 00 13 60 09 dc bd 51			.byte	$40,$00,$13,$60,$09,$dc,$bd,$51
>2460	64 5e 80 8b 7e 7e 6b be			.byte	$64,$5e,$80,$8b,$7e,$7e,$6b,$be
>2468	84 41 40 54 00 10 6a 09			.byte	$84,$41,$40,$54,$00,$10,$6a,$09
>2470	dc bd 98 8b 59 42 44 be			.byte	$dc,$bd,$98,$8b,$59,$42,$44,$be
>2478	84 59 42 43 00 15 74 09			.byte	$84,$59,$42,$43,$00,$15,$74,$09
>2480	dc bd a6 fe 0a 77 6b 6d			.byte	$dc,$bd,$a6,$fe,$0a,$77,$6b,$6d
>2488	76 6b 74 70 6f be be 84			.byte	$76,$6b,$74,$70,$6f,$be,$be,$84
>2490	48 00 19 7e 09 dc bd 5f			.byte	$48,$00,$19,$7e,$09,$dc,$bd,$5f
>2498	6e 46 fd 04 35 38 84 41			.byte	$6e,$46,$fd,$04,$35,$38,$84,$41
>24a0	50 4e 59 fd 04 35 32 be			.byte	$50,$4e,$59,$fd,$04,$35,$32,$be
>24a8	84 40 00 15 88 09 dc bd			.byte	$84,$40,$00,$15,$88,$09,$dc,$bd
>24b0	8b 41 47 50 7b 8a 41 53			.byte	$8b,$41,$47,$50,$7b,$8a,$41,$53
>24b8	40 5a be 84 4b 6f 5f 00			.byte	$40,$5a,$be,$84,$4b,$6f,$5f,$00
>24c0	13 92 09 dc bd 6b 41 5a			.byte	$13,$92,$09,$dc,$bd,$6b,$41,$5a
>24c8	81 8b 43 50 68 be 84 8b			.byte	$81,$8b,$43,$50,$68,$be,$84,$8b
>24d0	50 66 00 16 9c 09 dc bd			.byte	$50,$66,$00,$16,$9c,$09,$dc,$bd
>24d8	a5 a4 8b 41 50 4c 79 be			.byte	$a5,$a4,$8b,$41,$50,$4c,$79,$be
>24e0	be be 84 8b 41 50 4c 79			.byte	$be,$be,$84,$8b,$41,$50,$4c,$79
>24e8	00 17 a6 09 dc bd 9b fe			.byte	$00,$17,$a6,$09,$dc,$bd,$9b,$fe
>24f0	0b 74 67 78 72 69 67 78			.byte	$0b,$74,$67,$78,$72,$69,$67,$78
>24f8	67 61 be be 84 41 74 00			.byte	$67,$61,$be,$be,$84,$41,$74,$00
>2500	1b b0 09 dc bd 4e 7c 4c			.byte	$1b,$b0,$09,$dc,$bd,$4e,$7c,$4c
>2508	fd 05 32 38 38 87 8b 41			.byte	$fd,$05,$32,$38,$38,$87,$8b,$41
>2510	52 46 63 fd 04 34 32 be			.byte	$52,$46,$63,$fd,$04,$34,$32,$be
>2518	84 40 00 15 ba 09 dc bd			.byte	$84,$40,$00,$15,$ba,$09,$dc,$bd
>2520	8b 43 56 61 7f 85 8b 43			.byte	$8b,$43,$56,$61,$7f,$85,$8b,$43
>2528	54 4b 7a be 84 8b 41 00			.byte	$54,$4b,$7a,$be,$84,$8b,$41,$00
>2530	14 c4 09 dc bd 43 60 47			.byte	$14,$c4,$09,$dc,$bd,$43,$60,$47
>2538	73 81 7b 49 47 be 84 43			.byte	$73,$81,$7b,$49,$47,$be,$84,$43
>2540	7b 4f 77 00 0c ce 09 dc			.byte	$7b,$4f,$77,$00,$0c,$ce,$09,$dc
>2548	bd 9a 40 be be 84 40 00			.byte	$bd,$9a,$40,$be,$be,$84,$40,$00
>2550	0f d8 09 dc bd b4 41 74			.byte	$0f,$d8,$09,$dc,$bd,$b4,$41,$74
>2558	be be 84 fe 03 74 00 27			.byte	$be,$be,$84,$fe,$03,$74,$00,$27
>2560	e2 09 dc bd 42 4a 76 53			.byte	$e2,$09,$dc,$bd,$42,$4a,$76,$53
>2568	fd 04 32 31 8c 41 4d 69			.byte	$fd,$04,$32,$31,$8c,$41,$4d,$69
>2570	63 fd 04 37 36 be 84 41			.byte	$63,$fd,$04,$37,$36,$be,$84,$41
>2578	fd 0d 38 30 38 38 33 34			.byte	$fd,$0d,$38,$30,$38,$38,$33,$34
>2580	31 36 65 31 31 00 13 ec			.byte	$31,$36,$65,$31,$31,$00,$13,$ec
>2588	09 dc bd 8b 42 65 42 75			.byte	$09,$dc,$bd,$8b,$42,$65,$42,$75
>2590	88 8b 6c 57 71 be 84 40			.byte	$88,$8b,$6c,$57,$71,$be,$84,$40
>2598	00 17 f6 09 dc bd 41 5e			.byte	$00,$17,$f6,$09,$dc,$bd,$41,$5e
>25a0	5e 7e 81 8b 42 56 6a 6f			.byte	$5e,$7e,$81,$8b,$42,$56,$6a,$6f
>25a8	be 84 8b 42 40 60 41 00			.byte	$be,$84,$8b,$42,$40,$60,$41,$00
>25b0	11 00 0a dc bd b3 8b 42			.byte	$11,$00,$0a,$dc,$bd,$b3,$8b,$42
>25b8	7b 6a 40 be be 84 8b 41			.byte	$7b,$6a,$40,$be,$be,$84,$8b,$41
>25c0	00 0e 0a 0a dc bd a3 41			.byte	$00,$0e,$0a,$0a,$dc,$bd,$a3,$41
>25c8	be be 84 fe 03 20 00 29			.byte	$be,$be,$84,$fe,$03,$20,$00,$29
>25d0	14 0a dc bd 8b 43 4e 4e			.byte	$14,$0a,$dc,$bd,$8b,$43,$4e,$4e
>25d8	62 fd 04 30 35 8c 8b 41			.byte	$62,$fd,$04,$30,$35,$8c,$8b,$41
>25e0	47 79 42 fd 04 34 35 be			.byte	$47,$79,$42,$fd,$04,$34,$35,$be
>25e8	84 42 fd 0d 34 38 37 33			.byte	$84,$42,$fd,$0d,$34,$38,$37,$33
>25f0	37 35 39 32 65 31 31 00			.byte	$37,$35,$39,$32,$65,$31,$31,$00
>25f8	13 1e 0a dc bd 54 72 43			.byte	$13,$1e,$0a,$dc,$bd,$54,$72,$43
>2600	89 8b 41 5e 47 7a be 84			.byte	$89,$8b,$41,$5e,$47,$7a,$be,$84
>2608	8b 41 00 17 28 0a dc bd			.byte	$8b,$41,$00,$17,$28,$0a,$dc,$bd
>2610	8b 43 5a 77 5a 80 8b 6a			.byte	$8b,$43,$5a,$77,$5a,$80,$8b,$6a
>2618	55 4a be 84 8b 43 7a 77			.byte	$55,$4a,$be,$84,$8b,$43,$7a,$77
>2620	5a 00 15 32 0a dc bd b2			.byte	$5a,$00,$15,$32,$0a,$dc,$bd,$b2
>2628	70 56 6b bf 42 4b 5b 74			.byte	$70,$56,$6b,$bf,$42,$4b,$5b,$74
>2630	be be 84 70 56 6b 00 15			.byte	$be,$be,$84,$70,$56,$6b,$00,$15
>2638	3c 0a dc bd a7 42 77 62			.byte	$3c,$0a,$dc,$bd,$a7,$42,$77,$62
>2640	60 be be 84 fe 07 42 37			.byte	$60,$be,$be,$84,$fe,$07,$42,$37
>2648	38 41 30 00 1a 46 0a dc			.byte	$38,$41,$30,$00,$1a,$46,$0a,$dc
>2650	bd 43 70 43 69 fd 03 30			.byte	$bd,$43,$70,$43,$69,$fd,$03,$30
>2658	89 8b 74 4e 6b fd 04 37			.byte	$89,$8b,$74,$4e,$6b,$fd,$04,$37
>2660	38 be 84 8b 41 00 12 50			.byte	$38,$be,$84,$8b,$41,$00,$12,$50
>2668	0a dc bd 8b 7d 6c 43 88			.byte	$0a,$dc,$bd,$8b,$7d,$6c,$43,$88
>2670	42 6c 64 4b be 84 40 00			.byte	$42,$6c,$64,$4b,$be,$84,$40,$00
>2678	15 5a 0a dc bd 42 4f 55			.byte	$15,$5a,$0a,$dc,$bd,$42,$4f,$55
>2680	79 81 41 64 64 74 be 84			.byte	$79,$81,$41,$64,$64,$74,$be,$84
>2688	43 6f 75 7d 00 12 64 0a			.byte	$43,$6f,$75,$7d,$00,$12,$64,$0a
>2690	dc bd 98 8b 43 46 70 7a			.byte	$dc,$bd,$98,$8b,$43,$46,$70,$7a
>2698	be 84 43 46 70 79 00 15			.byte	$be,$84,$43,$46,$70,$79,$00,$15
>26a0	6e 0a dc bd af fe 07 36			.byte	$6e,$0a,$dc,$bd,$af,$fe,$07,$36
>26a8	34 41 46 41 be be 84 41			.byte	$34,$41,$46,$41,$be,$be,$84,$41
>26b0	64 6b 7a 00 18 78 0a dc			.byte	$64,$6b,$7a,$00,$18,$78,$0a,$dc
>26b8	bd 40 fd 03 30 8c 79 59			.byte	$bd,$40,$fd,$03,$30,$8c,$79,$59
>26c0	78 fd 04 33 36 be 84 40			.byte	$78,$fd,$04,$33,$36,$be,$84,$40
>26c8	fd 03 30 00 12 82 0a dc			.byte	$fd,$03,$30,$00,$12,$82,$0a,$dc
>26d0	bd 73 6d 61 8b 60 61 43			.byte	$bd,$73,$6d,$61,$8b,$60,$61,$43
>26d8	be 84 53 4c 5e 00 13 8c			.byte	$be,$84,$53,$4c,$5e,$00,$13,$8c
>26e0	0a dc bd 41 6f 5f 6f 80			.byte	$0a,$dc,$bd,$41,$6f,$5f,$6f,$80
>26e8	7a 72 72 be 84 6a 52 62			.byte	$7a,$72,$72,$be,$84,$6a,$52,$62
>26f0	00 1e 96 0a dc bd a5 a4			.byte	$00,$1e,$96,$0a,$dc,$bd,$a5,$a4
>26f8	8b 41 74 68 63 fd 04 35			.byte	$8b,$41,$74,$68,$63,$fd,$04,$35
>2700	39 be be be 84 8b 41 74			.byte	$39,$be,$be,$be,$84,$8b,$41,$74
>2708	68 63 fd 04 35 39 00 16			.byte	$68,$63,$fd,$04,$35,$39,$00,$16
>2710	a0 0a dc bd a0 fe 05 74			.byte	$a0,$0a,$dc,$bd,$a0,$fe,$05,$74
>2718	75 6d bf 43 be be 84 fe			.byte	$75,$6d,$bf,$43,$be,$be,$84,$fe
>2720	05 74 75 6d 00 1b aa 0a			.byte	$05,$74,$75,$6d,$00,$1b,$aa,$0a
>2728	dc bd 41 5c 62 47 fd 04			.byte	$dc,$bd,$41,$5c,$62,$47,$fd,$04
>2730	34 36 87 8b 43 57 5d 40			.byte	$34,$36,$87,$8b,$43,$57,$5d,$40
>2738	fd 04 30 32 be 84 40 00			.byte	$fd,$04,$30,$32,$be,$84,$40,$00
>2740	12 b4 0a dc bd 42 5a 4e			.byte	$12,$b4,$0a,$dc,$bd,$42,$5a,$4e
>2748	51 87 42 49 4a 42 be 84			.byte	$51,$87,$42,$49,$4a,$42,$be,$84
>2750	40 00 18 be 0a dc bd 8b			.byte	$40,$00,$18,$be,$0a,$dc,$bd,$8b
>2758	42 76 72 61 80 8b 43 6a			.byte	$42,$76,$72,$61,$80,$8b,$43,$6a
>2760	4c 64 be 84 8b 43 7e 7e			.byte	$4c,$64,$be,$84,$8b,$43,$7e,$7e
>2768	64 00 13 c8 0a dc bd 9a			.byte	$64,$00,$13,$c8,$0a,$dc,$bd,$9a
>2770	8b 41 64 48 70 be be 84			.byte	$8b,$41,$64,$48,$70,$be,$be,$84
>2778	41 64 48 70 00 1d d2 0a			.byte	$41,$64,$48,$70,$00,$1d,$d2,$0a
>2780	dc bd a1 fe 0b 6c 65 76			.byte	$dc,$bd,$a1,$fe,$0b,$6c,$65,$76
>2788	77 6e 6b 6a 71 73 bf 44			.byte	$77,$6e,$6b,$6a,$71,$73,$bf,$44
>2790	be be 84 fe 06 6b 6a 71			.byte	$be,$be,$84,$fe,$06,$6b,$6a,$71
>2798	73 00 26 dc 0a dc bd 8b			.byte	$73,$00,$26,$dc,$0a,$dc,$bd,$8b
>27a0	42 5a 72 4e fd 04 32 37			.byte	$42,$5a,$72,$4e,$fd,$04,$32,$37
>27a8	8d 8b 43 5b 4e 76 fd 04			.byte	$8d,$8b,$43,$5b,$4e,$76,$fd,$04
>27b0	32 31 be 84 40 fd 0a 37			.byte	$32,$31,$be,$84,$40,$fd,$0a,$37
>27b8	30 36 30 33 31 37 31 00			.byte	$30,$36,$30,$33,$31,$37,$31,$00
>27c0	14 e6 0a dc bd 8b 43 59			.byte	$14,$e6,$0a,$dc,$bd,$8b,$43,$59
>27c8	48 85 8b 43 73 52 6c be			.byte	$48,$85,$8b,$43,$73,$52,$6c,$be
>27d0	84 8b 41 00 15 f0 0a dc			.byte	$84,$8b,$41,$00,$15,$f0,$0a,$dc
>27d8	bd 41 74 65 68 80 41 49			.byte	$bd,$41,$74,$65,$68,$80,$41,$49
>27e0	4f 7e be 84 41 40 45 68			.byte	$4f,$7e,$be,$84,$41,$40,$45,$68
>27e8	00 0f fa 0a dc bd b3 43			.byte	$00,$0f,$fa,$0a,$dc,$bd,$b3,$43
>27f0	44 65 4e be be 84 41 00			.byte	$44,$65,$4e,$be,$be,$84,$41,$00
>27f8	13 04 0b dc bd a2 fe 03			.byte	$13,$04,$0b,$dc,$bd,$a2,$fe,$03
>2800	74 bf 43 bf 44 be be 84			.byte	$74,$bf,$43,$bf,$44,$be,$be,$84
>2808	fe 02 00 22 0e 0b dc bd			.byte	$fe,$02,$00,$22,$0e,$0b,$dc,$bd
>2810	41 63 6d 66 fd 04 34 32			.byte	$41,$63,$6d,$66,$fd,$04,$34,$32
>2818	8a 8b 42 51 47 5e fd 04			.byte	$8a,$8b,$42,$51,$47,$5e,$fd,$04
>2820	39 36 be 84 8b 6d 59 78			.byte	$39,$36,$be,$84,$8b,$6d,$59,$78
>2828	fd 04 35 35 00 13 18 0b			.byte	$fd,$04,$35,$35,$00,$13,$18,$0b
>2830	dc bd 42 58 74 75 84 8b			.byte	$dc,$bd,$42,$58,$74,$75,$84,$8b
>2838	41 66 61 55 be 84 40 00			.byte	$41,$66,$61,$55,$be,$84,$40,$00
>2840	14 22 0b dc bd 42 49 60			.byte	$14,$22,$0b,$dc,$bd,$42,$49,$60
>2848	49 80 8b 42 5b 54 42 be			.byte	$49,$80,$8b,$42,$5b,$54,$42,$be
>2850	84 60 48 00 17 2c 0b dc			.byte	$84,$60,$48,$00,$17,$2c,$0b,$dc
>2858	bd b2 41 6b 66 63 bf 42			.byte	$bd,$b2,$41,$6b,$66,$63,$bf,$42
>2860	5b 47 5c be be 84 41 6b			.byte	$5b,$47,$5c,$be,$be,$84,$41,$6b
>2868	66 63 00 13 36 0b dc bd			.byte	$66,$63,$00,$13,$36,$0b,$dc,$bd
>2870	a6 fe 08 71 78 72 79 76			.byte	$a6,$fe,$08,$71,$78,$72,$79,$76
>2878	6b be be 84 46 00 1b 40			.byte	$6b,$be,$be,$84,$46,$00,$1b,$40
>2880	0b dc bd 43 68 67 79 fd			.byte	$0b,$dc,$bd,$43,$68,$67,$79,$fd
>2888	04 35 33 89 41 4b 64 67			.byte	$04,$35,$33,$89,$41,$4b,$64,$67
>2890	fd 04 39 39 be 84 8b 41			.byte	$fd,$04,$39,$39,$be,$84,$8b,$41
>2898	00 15 4a 0b dc bd 8b 43			.byte	$00,$15,$4a,$0b,$dc,$bd,$8b,$43
>28a0	72 5d 57 85 8b 41 71 6a			.byte	$72,$5d,$57,$85,$8b,$41,$71,$6a
>28a8	40 be 84 8b 41 00 16 54			.byte	$40,$be,$84,$8b,$41,$00,$16,$54
>28b0	0b dc bd 8b 42 5f 72 74			.byte	$0b,$dc,$bd,$8b,$42,$5f,$72,$74
>28b8	81 67 77 60 be 84 8b 42			.byte	$81,$67,$77,$60,$be,$84,$8b,$42
>28c0	58 40 54 00 12 5e 0b dc			.byte	$58,$40,$54,$00,$12,$5e,$0b,$dc
>28c8	bd 98 8b 42 64 79 75 be			.byte	$bd,$98,$8b,$42,$64,$79,$75,$be
>28d0	84 42 64 79 74 00 17 68			.byte	$84,$42,$64,$79,$74,$00,$17,$68
>28d8	0b dc bd 9b fe 0b 6c 63			.byte	$0b,$dc,$bd,$9b,$fe,$0b,$6c,$63
>28e0	75 63 62 6f 64 78 64 be			.byte	$75,$63,$62,$6f,$64,$78,$64,$be
>28e8	be 84 41 6c 00 29 72 0b			.byte	$be,$84,$41,$6c,$00,$29,$72,$0b
>28f0	dc bd 41 55 5d 49 fd 04			.byte	$dc,$bd,$41,$55,$5d,$49,$fd,$04
>28f8	39 33 8c 8b 42 5c 61 4f			.byte	$39,$33,$8c,$8b,$42,$5c,$61,$4f
>2900	fd 04 37 31 be 84 8b 42			.byte	$fd,$04,$37,$31,$be,$84,$8b,$42
>2908	fd 0d 32 34 34 30 32 39			.byte	$fd,$0d,$32,$34,$34,$30,$32,$39
>2910	32 33 65 31 31 00 12 7c			.byte	$32,$33,$65,$31,$31,$00,$12,$7c
>2918	0b dc bd 56 51 42 8d 8b			.byte	$0b,$dc,$bd,$56,$51,$42,$8d,$8b
>2920	42 46 5f 5a be 84 40 00			.byte	$42,$46,$5f,$5a,$be,$84,$40,$00
>2928	15 86 0b dc bd 8b 47 51			.byte	$15,$86,$0b,$dc,$bd,$8b,$47,$51
>2930	47 81 8b 62 44 7f be 84			.byte	$47,$81,$8b,$62,$44,$7f,$be,$84
>2938	8b 42 40 47 00 1c 90 0b			.byte	$8b,$42,$40,$47,$00,$1c,$90,$0b
>2940	dc bd a5 a4 8b 41 79 58			.byte	$dc,$bd,$a5,$a4,$8b,$41,$79,$58
>2948	5b fd 03 31 be be be 84			.byte	$5b,$fd,$03,$31,$be,$be,$be,$84
>2950	8b 41 79 58 5b fd 03 31			.byte	$8b,$41,$79,$58,$5b,$fd,$03,$31
>2958	00 0f 9a 0b dc bd b4 41			.byte	$00,$0f,$9a,$0b,$dc,$bd,$b4,$41
>2960	53 be be 84 fe 03 53 00			.byte	$53,$be,$be,$84,$fe,$03,$53,$00
>2968	18 a4 0b dc bd 40 fd 03			.byte	$18,$a4,$0b,$dc,$bd,$40,$fd,$03
>2970	30 8d 41 55 69 75 fd 03			.byte	$30,$8d,$41,$55,$69,$75,$fd,$03
>2978	37 be 84 40 fd 03 30 00			.byte	$37,$be,$84,$40,$fd,$03,$30,$00
>2980	13 ae 0b dc bd 8b 7d 49			.byte	$13,$ae,$0b,$dc,$bd,$8b,$7d,$49
>2988	70 87 41 42 52 60 be 84			.byte	$70,$87,$41,$42,$52,$60,$be,$84
>2990	8b 41 00 18 b8 0b dc bd			.byte	$8b,$41,$00,$18,$b8,$0b,$dc,$bd
>2998	8b 42 7e 71 48 80 8b 43			.byte	$8b,$42,$7e,$71,$48,$80,$8b,$43
>29a0	73 63 50 be 84 8b 43 7f			.byte	$73,$63,$50,$be,$84,$8b,$43,$7f
>29a8	73 50 00 12 c2 0b dc bd			.byte	$73,$50,$00,$12,$c2,$0b,$dc,$bd
>29b0	9a 41 4a 59 7e be be 84			.byte	$9a,$41,$4a,$59,$7e,$be,$be,$84
>29b8	41 4a 59 7e 00 21 cc 0b			.byte	$41,$4a,$59,$7e,$00,$21,$cc,$0b
>29c0	dc bd a3 54 be be 84 fe			.byte	$dc,$bd,$a3,$54,$be,$be,$84,$fe
>29c8	16 20 20 20 20 20 20 20			.byte	$16,$20,$20,$20,$20,$20,$20,$20
>29d0	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>29d8	20 20 20 20 20 00 27 d6			.byte	$20,$20,$20,$20,$20,$00,$27,$d6
>29e0	0b dc bd 42 56 6a 52 fd			.byte	$0b,$dc,$bd,$42,$56,$6a,$52,$fd
>29e8	04 36 31 8c 8b 61 7e 40			.byte	$04,$36,$31,$8c,$8b,$61,$7e,$40
>29f0	fd 03 32 be 84 8b 48 fd			.byte	$fd,$03,$32,$be,$84,$8b,$48,$fd
>29f8	0d 35 38 36 31 38 37 30			.byte	$0d,$35,$38,$36,$31,$38,$37,$30
>2a00	37 65 31 30 00 13 e0 0b			.byte	$37,$65,$31,$30,$00,$13,$e0,$0b
>2a08	dc bd 8b 42 76 73 78 89			.byte	$dc,$bd,$8b,$42,$76,$73,$78,$89
>2a10	8b 43 42 42 be 84 40 00			.byte	$8b,$43,$42,$42,$be,$84,$40,$00
>2a18	14 ea 0b dc bd 5e 54 5e			.byte	$14,$ea,$0b,$dc,$bd,$5e,$54,$5e
>2a20	80 8b 42 50 76 55 be 84			.byte	$80,$8b,$42,$50,$76,$55,$be,$84
>2a28	4e 40 4a 00 0f f4 0b dc			.byte	$4e,$40,$4a,$00,$0f,$f4,$0b,$dc
>2a30	bd b3 42 73 50 57 be be			.byte	$bd,$b3,$42,$73,$50,$57,$be,$be
>2a38	84 41 00 15 fe 0b dc bd			.byte	$84,$41,$00,$15,$fe,$0b,$dc,$bd
>2a40	a7 41 70 7c 60 be be 84			.byte	$a7,$41,$70,$7c,$60,$be,$be,$84
>2a48	fe 07 37 30 46 32 30 00			.byte	$fe,$07,$37,$30,$46,$32,$30,$00
>2a50	1b 08 0c dc bd 43 40 4b			.byte	$1b,$08,$0c,$dc,$bd,$43,$40,$4b
>2a58	57 fd 04 37 32 88 8b 7b			.byte	$57,$fd,$04,$37,$32,$88,$8b,$7b
>2a60	5f 71 fd 04 30 34 be 84			.byte	$5f,$71,$fd,$04,$30,$34,$be,$84
>2a68	8b 41 00 10 12 0c dc bd			.byte	$8b,$41,$00,$10,$12,$0c,$dc,$bd
>2a70	43 68 5c 4c 89 40 be 84			.byte	$43,$68,$5c,$4c,$89,$40,$be,$84
>2a78	8b 41 00 10 1c 0c dc bd			.byte	$8b,$41,$00,$10,$1c,$0c,$dc,$bd
>2a80	5b 7a 4b 82 40 be 84 5b			.byte	$5b,$7a,$4b,$82,$40,$be,$84,$5b
>2a88	7a 4b 00 15 26 0c dc bd			.byte	$7a,$4b,$00,$15,$26,$0c,$dc,$bd
>2a90	af fe 07 41 37 34 46 31			.byte	$af,$fe,$07,$41,$37,$34,$46,$31
>2a98	be be 84 42 67 53 71 00			.byte	$be,$be,$84,$42,$67,$53,$71,$00
>2aa0	18 30 0c dc bd 40 fd 03			.byte	$18,$30,$0c,$dc,$bd,$40,$fd,$03
>2aa8	30 8d 45 65 6f fd 04 38			.byte	$30,$8d,$45,$65,$6f,$fd,$04,$38
>2ab0	34 be 84 40 fd 03 30 00			.byte	$34,$be,$84,$40,$fd,$03,$30,$00
>2ab8	14 3a 0c dc bd 8b 43 59			.byte	$14,$3a,$0c,$dc,$bd,$8b,$43,$59
>2ac0	74 7c 84 8b 42 75 70 68			.byte	$74,$7c,$84,$8b,$42,$75,$70,$68
>2ac8	be 84 40 00 15 44 0c dc			.byte	$be,$84,$40,$00,$15,$44,$0c,$dc
>2ad0	bd 41 7d 5a 58 81 41 69			.byte	$bd,$41,$7d,$5a,$58,$81,$41,$69
>2ad8	73 48 be 84 41 7d 7b 58			.byte	$73,$48,$be,$84,$41,$7d,$7b,$58
>2ae0	00 12 4e 0c dc bd 98 8b			.byte	$00,$12,$4e,$0c,$dc,$bd,$98,$8b
>2ae8	41 7e 55 52 be 84 41 7e			.byte	$41,$7e,$55,$52,$be,$84,$41,$7e
>2af0	55 51 00 12 58 0c dc bd			.byte	$55,$51,$00,$12,$58,$0c,$dc,$bd
>2af8	a0 fe 03 69 bf 45 be be			.byte	$a0,$fe,$03,$69,$bf,$45,$be,$be
>2b00	84 fe 03 69 00 23 62 0c			.byte	$84,$fe,$03,$69,$00,$23,$62,$0c
>2b08	dc bd 8b 42 52 57 49 fd			.byte	$dc,$bd,$8b,$42,$52,$57,$49,$fd
>2b10	04 30 38 8b 41 42 47 58			.byte	$04,$30,$38,$8b,$41,$42,$47,$58
>2b18	fd 04 32 33 be 84 8b 43			.byte	$fd,$04,$32,$33,$be,$84,$8b,$43
>2b20	54 5e 61 fd 04 33 31 00			.byte	$54,$5e,$61,$fd,$04,$33,$31,$00
>2b28	14 6c 0c dc bd 8b 42 56			.byte	$14,$6c,$0c,$dc,$bd,$8b,$42,$56
>2b30	6b 69 85 8b 71 72 7f be			.byte	$6b,$69,$85,$8b,$71,$72,$7f,$be
>2b38	84 8b 41 00 17 76 0c dc			.byte	$84,$8b,$41,$00,$17,$76,$0c,$dc
>2b40	bd 8b 41 71 78 7a 80 8b			.byte	$bd,$8b,$41,$71,$78,$7a,$80,$8b
>2b48	64 51 42 be 84 8b 41 75			.byte	$64,$51,$42,$be,$84,$8b,$41,$75
>2b50	79 7a 00 1e 80 0c dc bd			.byte	$79,$7a,$00,$1e,$80,$0c,$dc,$bd
>2b58	a5 a4 8b 41 77 50 6a fd			.byte	$a5,$a4,$8b,$41,$77,$50,$6a,$fd
>2b60	04 33 33 be be be 84 8b			.byte	$04,$33,$33,$be,$be,$be,$84,$8b
>2b68	41 77 50 6a fd 04 33 33			.byte	$41,$77,$50,$6a,$fd,$04,$33,$33
>2b70	00 16 8a 0c dc bd a1 fe			.byte	$00,$16,$8a,$0c,$dc,$bd,$a1,$fe
>2b78	05 6a 6b 79 bf 45 be be			.byte	$05,$6a,$6b,$79,$bf,$45,$be,$be
>2b80	84 fe 05 6a 6b 79 00 1c			.byte	$84,$fe,$05,$6a,$6b,$79,$00,$1c
>2b88	94 0c dc bd 8b 42 5c 40			.byte	$94,$0c,$dc,$bd,$8b,$42,$5c,$40
>2b90	47 fd 04 36 35 87 8b 59			.byte	$47,$fd,$04,$36,$35,$87,$8b,$59
>2b98	6e 51 fd 04 38 32 be 84			.byte	$6e,$51,$fd,$04,$38,$32,$be,$84
>2ba0	8b 41 00 15 9e 0c dc bd			.byte	$8b,$41,$00,$15,$9e,$0c,$dc,$bd
>2ba8	43 5c 44 66 8a 43 5b 5c			.byte	$43,$5c,$44,$66,$8a,$43,$5b,$5c
>2bb0	57 be 84 46 77 60 7d 00			.byte	$57,$be,$84,$46,$77,$60,$7d,$00
>2bb8	16 a8 0c dc bd 8b 72 74			.byte	$16,$a8,$0c,$dc,$bd,$8b,$72,$74
>2bc0	5c 82 42 41 76 40 be 84			.byte	$5c,$82,$42,$41,$76,$40,$be,$84
>2bc8	8b 42 73 42 5c 00 13 b2			.byte	$8b,$42,$73,$42,$5c,$00,$13,$b2
>2bd0	0c dc bd 9a 8b 42 59 66			.byte	$0c,$dc,$bd,$9a,$8b,$42,$59,$66
>2bd8	76 be be 84 42 59 66 76			.byte	$76,$be,$be,$84,$42,$59,$66,$76
>2be0	00 12 bc 0c dc bd a2 fe			.byte	$00,$12,$bc,$0c,$dc,$bd,$a2,$fe
>2be8	02 bf 44 bf 42 be be 84			.byte	$02,$bf,$44,$bf,$42,$be,$be,$84
>2bf0	fe 02 00 1a c6 0c dc bd			.byte	$fe,$02,$00,$1a,$c6,$0c,$dc,$bd
>2bf8	7b 51 5b fd 04 33 32 86			.byte	$7b,$51,$5b,$fd,$04,$33,$32,$86
>2c00	42 7d 56 47 fd 04 34 32			.byte	$42,$7d,$56,$47,$fd,$04,$34,$32
>2c08	be 84 8b 41 00 13 d0 0c			.byte	$be,$84,$8b,$41,$00,$13,$d0,$0c
>2c10	dc bd 41 57 4a 6e 84 8b			.byte	$dc,$bd,$41,$57,$4a,$6e,$84,$8b
>2c18	42 5b 4d 51 be 84 40 00			.byte	$42,$5b,$4d,$51,$be,$84,$40,$00
>2c20	0c da 0c dc bd 40 82 40			.byte	$0c,$da,$0c,$dc,$bd,$40,$82,$40
>2c28	be 84 40 00 0c e4 0c dc			.byte	$be,$84,$40,$00,$0c,$e4,$0c,$dc
>2c30	bd b3 40 be be 84 40 00			.byte	$bd,$b3,$40,$be,$be,$84,$40,$00
>2c38	0d ee 0c dc bd a6 fe 02			.byte	$0d,$ee,$0c,$dc,$bd,$a6,$fe,$02
>2c40	be be 84 40 00 1c f8 0c			.byte	$be,$be,$84,$40,$00,$1c,$f8,$0c
>2c48	dc bd 8b 41 4c 46 73 fd			.byte	$dc,$bd,$8b,$41,$4c,$46,$73,$fd
>2c50	04 36 31 84 8b 41 47 48			.byte	$04,$36,$31,$84,$8b,$41,$47,$48
>2c58	4c fd 04 31 35 be 84 40			.byte	$4c,$fd,$04,$31,$35,$be,$84,$40
>2c60	00 14 02 0d dc bd 8b 41			.byte	$00,$14,$02,$0d,$dc,$bd,$8b,$41
>2c68	7f 68 40 8b 40 be 84 8b			.byte	$7f,$68,$40,$8b,$40,$be,$84,$8b
>2c70	41 7f 68 40 00 10 0c 0d			.byte	$41,$7f,$68,$40,$00,$10,$0c,$0d
>2c78	dc bd 8b 42 59 43 7d 80			.byte	$dc,$bd,$8b,$42,$59,$43,$7d,$80
>2c80	40 be 84 40 00 12 16 0d			.byte	$40,$be,$84,$40,$00,$12,$16,$0d
>2c88	dc bd 9b fe 06 64 66 67			.byte	$dc,$bd,$9b,$fe,$06,$64,$66,$67
>2c90	64 be be 84 41 64 00 19			.byte	$64,$be,$be,$84,$41,$64,$00,$19
>2c98	20 0d dc bd 42 76 52 66			.byte	$20,$0d,$dc,$bd,$42,$76,$52,$66
>2ca0	fd 04 37 33 84 5e 66 50			.byte	$fd,$04,$37,$33,$84,$5e,$66,$50
>2ca8	fd 04 35 33 be 84 40 00			.byte	$fd,$04,$35,$33,$be,$84,$40,$00
>2cb0	11 2a 0d dc bd 41 42 67			.byte	$11,$2a,$0d,$dc,$bd,$41,$42,$67
>2cb8	72 87 74 68 7f be 84 40			.byte	$72,$87,$74,$68,$7f,$be,$84,$40
>2cc0	00 0f 34 0d dc bd 41 70			.byte	$00,$0f,$34,$0d,$dc,$bd,$41,$70
>2cc8	69 7a 80 40 be 84 40 00			.byte	$69,$7a,$80,$40,$be,$84,$40,$00
>2cd0	0c 3e 0d dc bd 98 40 be			.byte	$0c,$3e,$0d,$dc,$bd,$98,$40,$be
>2cd8	84 8b 41 00 0e 48 0d dc			.byte	$84,$8b,$41,$00,$0e,$48,$0d,$dc
>2ce0	bd b4 64 be be 84 fe 03			.byte	$bd,$b4,$64,$be,$be,$84,$fe,$03
>2ce8	24 00 16 52 0d dc bd 40			.byte	$24,$00,$16,$52,$0d,$dc,$bd,$40
>2cf0	fd 03 30 84 42 5a 71 6c			.byte	$fd,$03,$30,$84,$42,$5a,$71,$6c
>2cf8	fd 04 34 34 be 84 40 00			.byte	$fd,$04,$34,$34,$be,$84,$40,$00
>2d00	16 5c 0d dc bd 41 7e 40			.byte	$16,$5c,$0d,$dc,$bd,$41,$7e,$40
>2d08	42 8b 8b 43 4a 5a 7f be			.byte	$42,$8b,$8b,$43,$4a,$5a,$7f,$be
>2d10	84 45 48 5b 41 00 17 66			.byte	$84,$45,$48,$5b,$41,$00,$17,$66
>2d18	0d dc bd 8b 42 4d 7c 46			.byte	$0d,$dc,$bd,$8b,$42,$4d,$7c,$46
>2d20	81 8b 41 6a 55 40 be 84			.byte	$81,$8b,$41,$6a,$55,$40,$be,$84
>2d28	8b 48 54 46 00 16 70 0d			.byte	$8b,$48,$54,$46,$00,$16,$70,$0d
>2d30	dc bd a5 a4 8b 43 4a 43			.byte	$dc,$bd,$a5,$a4,$8b,$43,$4a,$43
>2d38	76 be be be 84 8b 43 4a			.byte	$76,$be,$be,$be,$84,$8b,$43,$4a
>2d40	43 76 00 20 7a 0d dc bd			.byte	$43,$76,$00,$20,$7a,$0d,$dc,$bd
>2d48	a3 53 be be 84 fe 15 20			.byte	$a3,$53,$be,$be,$84,$fe,$15,$20
>2d50	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2d58	20 20 20 20 20 20 20 20			.byte	$20,$20,$20,$20,$20,$20,$20,$20
>2d60	20 20 00 29 84 0d d6 fe			.byte	$20,$20,$00,$29,$84,$0d,$d6,$fe
>2d68	22 50 61 73 73 65 64 20			.byte	$22,$50,$61,$73,$73,$65,$64,$20
>2d70	41 72 69 74 68 6d 65 74			.byte	$41,$72,$69,$74,$68,$6d,$65,$74
>2d78	69 63 2c 4c 6f 67 69 63			.byte	$69,$63,$2c,$4c,$6f,$67,$69,$63
>2d80	61 6c 2c 55 6e 61 72 79			.byte	$61,$6c,$2c,$55,$6e,$61,$72,$79
>2d88	2e c0 c4 00 00				.byte	$2e,$c0,$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c ce a8 01	jmp $01a8ce		jmp TokeniseTest
.c019					TIM_BreakHandler:
.c019	5c 73 83 01	jmp $018373			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a6 81	jsr $0181a6			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d2 81	jsr $0181d2			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 b9 81	jsr $0181b9			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a6 81	jsr $0181a6			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d2 81	jsr $0181d2			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 b9 81	jsr $0181b9			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d2 81	jsr $0181d2			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 c9 81	jsr $0181c9			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d2 81	jsr $0181d2			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 b9 81	jsr $0181b9			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e3 81	jsr $0181e3			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 c9 81	jsr $0181c9			jsr 	IF_Read 					; read
.0180ea	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d2 81	jsr $0181d2			jsr 	IF_Write 					; write
.0180f2	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d2 81	jsr $0181d2			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 c9 81	jsr $0181c9			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 c9 81	jsr $0181c9			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	68		pla				pla
.0181a0	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a2	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a5					IF_Reset:
.0181a5	60		rts				rts
.0181a6					IF_Home:
.0181a6	48		pha				pha
.0181a7	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181a9	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ab	85 04		sta $04				sta 	IF_Pos
.0181ad	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181af	85 05		sta $05				sta 	IF_Pos+1
.0181b1	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b3	85 06		sta $06				sta 	IF_Pos+2
.0181b5	64 07		stz $07				stz 	IF_Pos+3
.0181b7	68		pla				pla
.0181b8	60		rts				rts
.0181b9					IF_NewLine:
.0181b9	48		pha				pha
.0181ba	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bc	18		clc				clc 								; down one line
.0181bd	a5 04		lda $04				lda 	IF_Pos
.0181bf	69 40		adc #$40			adc 	#64
.0181c1	85 04		sta $04				sta 	IF_Pos
.0181c3	90 02		bcc $0181c7			bcc 	_IF_NoCarry 				; carry through.
.0181c5	e6 05		inc $05				inc 	IF_Pos+1
.0181c7					_IF_NoCarry:
.0181c7	68		pla				pla
.0181c8	60		rts				rts
.0181c9					IF_Read:
.0181c9	5a		phy				phy 								; save current Y
.0181ca	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cc	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181ce	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d0	7a		ply				ply									; restore Y
.0181d1	60		rts				rts
.0181d2					IF_Write:
.0181d2	5a		phy				phy 								; save current Y
.0181d3	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d5	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181d7	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d9	7a		ply				ply									; restore Y
.0181da	60		rts				rts
.0181db					IF_LeftOne:
.0181db	c6 08		dec $08				dec 	IF_XPos
.0181dd	60		rts				rts
.0181de					IF_CheckBreak:
.0181de	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e2	60		rts				rts
.0181e3					IF_GetKey:
.0181e3	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181e7	f0 08		beq $0181f1			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181e9	48		pha				pha 								; key pressed, clear queue.
.0181ea	a9 00		lda #$00			lda 	#0
.0181ec	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f0	68		pla				pla
.0181f1					_IFGK_NoKey:
.0181f1	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f4					TIM_Error:
.0181f4	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181f7	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181f9	80 02		bra $0181fd			bra 	TIM_ShowPrompt
.0181fb					TIM_NewCommand:
.0181fb	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181fd					TIM_ShowPrompt:
.0181fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018200	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018203	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018206	86 10		stx $10				stx 	zTemp1 						; save line read address
.018208	84 11		sty $11				sty 	zTemp1+1
.01820a	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01820e	c9 3f		cmp #$3f			cmp 	#"?"
.018210	f0 04		beq $018216			beq 	TIM_SkipFirst
.018212	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018214	d0 01		bne $018217			bne 	TIM_NotDot
.018216					TIM_SkipFirst:
.018216	c8		iny				iny
.018217					TIM_NotDot:
.018217	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.018219	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821b	f0 6b		beq $018288			beq 	TIM_ShowRegisters
.01821d	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.01821f	f0 12		beq $018233			beq 	TIM_ShowMemory
.018221	c9 47		cmp #$47			cmp 	#"G"						; execute
.018223	f0 49		beq $01826e			beq 	TIM_Execute
.018225	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.018227	f0 07		beq $018230			beq 	TIM_GoLoadMemory
.018229	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822b	d0 c7		bne $0181f4			bne 	TIM_Error
.01822d	4c ac 83	jmp $0183ac			jmp 	TIM_UpdateRegisters
.018230					TIM_GoLoadMemory:
.018230	4c dc 83	jmp $0183dc			jmp 	TIM_LoadMemory
.018233					TIM_ShowMemory:
.018233	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018236	b0 bc		bcs $0181f4			bcs 	TIM_Error
.018238	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823a	85 12		sta $12				sta 	zTemp2
.01823c	a5 15		lda $15				lda 	zTemp3+1
.01823e	85 13		sta $13				sta 	zTemp2+1
.018240	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018243	90 08		bcc $01824d			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018245	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.018247	85 14		sta $14				sta 	zTemp3
.018249	a5 13		lda $13				lda 	zTemp2+1
.01824b	85 15		sta $15				sta 	zTemp3+1
.01824d					_TIMSM_Start:
.01824d	20 00 83	jsr $018300			jsr 	TIM_WriteLine 				; write one line of hex out
.018250	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018252	18		clc				clc
.018253	69 10		adc #$10			adc 	#16
.018255	85 12		sta $12				sta 	zTemp2
.018257	90 02		bcc $01825b			bcc 	_TIMSM_NoCarry
.018259	e6 13		inc $13				inc 	zTemp2+1
.01825b					_TIMSM_NoCarry:
.01825b	20 de 81	jsr $0181de			jsr 	IF_CheckBreak 				; check CTL+C
.01825e	d0 0b		bne $01826b			bne 	_TIMSM_Ends 				; if pressed break out.
.018260	38		sec				sec 								; check past the end address in zTemp3
.018261	a5 14		lda $14				lda 	zTemp3
.018263	e5 12		sbc $12				sbc 	zTemp2
.018265	a5 15		lda $15				lda 	zTemp3+1
.018267	e5 13		sbc $13				sbc 	zTemp2+1
.018269	10 e2		bpl $01824d			bpl 	_TIMSM_Start
.01826b					_TIMSM_Ends:
.01826b	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand
.01826e					TIM_Execute:
.01826e	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get the execute address
.018271	b0 81		bcs $0181f4			bcs 	TIM_Error 					; not legitimate
.018273	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018276	9a		txs				txs
.018277	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827a	48		pha				pha
.01827b	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.01827e	ae ca 03	ldx $03ca			ldx 	TIM_X
.018281	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018284	28		plp				plp 								; and PS Byte.
.018285	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.018288					TIM_Start:
.018288					TIM_ShowRegisters:
.018288	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828b	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.01828e	ad ff ff	lda $ffff			lda 	$FFFF
.018291	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018294	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018296					_TIMSR_Text:
.018296	bf c7 82 01	lda $0182c7,x			lda 	_TIMSR_Label,x
.01829a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01829d	e8		inx				inx
.01829e	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a0	d0 f4		bne $018296			bne 	_TIMSR_Text
.0182a2	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a4					_TIMSR_Skip:
.0182a4	e8		inx				inx
.0182a5					_TIMSR_LoopSpace:
.0182a5	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182a7	b0 04		bcs $0182ad			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182a9	8a		txa				txa
.0182aa	4a		lsr a				lsr 	a
.0182ab	b0 05		bcs $0182b2			bcs 	_TIMSR_NoSpace
.0182ad					_TIMSR_Space:
.0182ad	a9 20		lda #$20			lda 	#" "
.0182af	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b2					_TIMSR_NoSpace:
.0182b2	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b5	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.0182b8	e8		inx				inx
.0182b9	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182bb	f0 e7		beq $0182a4			beq 	_TIMSR_Skip
.0182bd	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182bf	d0 e4		bne $0182a5			bne 	_TimSR_LoopSpace
.0182c1	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c4	4c fb 81	jmp $0181fb			jmp	 	TIM_NewCommand 				; new command.
.0182c7					_TIMSR_Label:
>0182c7	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182cf	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182df	52
>0182e0	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182e7					_TIMSR_LabelEnd:
.0182e7					TIM_WriteHex:
.0182e7	48		pha				pha 								; save A
.0182e8	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182e9	4a		lsr a				lsr 	a
.0182ea	4a		lsr a				lsr 	a
.0182eb	4a		lsr a				lsr 	a
.0182ec	20 f0 82	jsr $0182f0			jsr 	_TIMWH_Nibble 				; print MSB
.0182ef	68		pla				pla 								; restore and print LSB
.0182f0					_TIMWH_Nibble:
.0182f0	48		pha				pha
.0182f1	29 0f		and #$0f			and 	#15 						; mask out
.0182f3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f5	90 02		bcc $0182f9			bcc 	_TIMWHNoLetter
.0182f7	69 06		adc #$06			adc 	#6
.0182f9					_TIMWHNoLetter:
.0182f9	69 30		adc #$30			adc 	#48
.0182fb	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182fe	68		pla				pla
.0182ff	60		rts				rts
.018300					TIM_WriteLine:
.018300	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018302	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018305	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.018307	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830a	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830c	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.01830f	a5 12		lda $12				lda 	zTemp2
.018311	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.018314	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018316					_TIMWL_Loop:
.018316	a9 20		lda #$20			lda 	#" "
.018318	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01831d	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.018320	c8		iny				iny
.018321	c0 10		cpy #$10			cpy 	#16
.018323	d0 f1		bne $018316			bne 	_TIMWL_Loop
.018325	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.018328					TIM_GetHex:
.018328	c8		iny				iny
.018329	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832b	c9 20		cmp #$20			cmp 	#32
.01832d	f0 f9		beq $018328			beq 	TIM_GetHex
.01832f	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018331	f0 f5		beq $018328			beq 	TIM_GetHex
.018333	20 5c 83	jsr $01835c			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018336	b0 23		bcs $01835b			bcs 	_TIMGH_Exit					; if first bad then exit now.
.018338	a9 00		lda #$00			lda 	#0 							; zero result
.01833a	85 14		sta $14				sta 	zTemp3
.01833c	85 15		sta $15				sta 	zTemp3+1
.01833e					_TIM_GHLoop:
.01833e	20 5c 83	jsr $01835c			jsr 	TIM_GetHexCharacter 		; get next character
.018341	b0 17		bcs $01835a			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018343	c8		iny				iny 								; skip over it.
.018344	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018346	26 15		rol $15				rol 	zTemp3+1
.018348	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834a	26 15		rol $15				rol 	zTemp3+1
.01834c	06 14		asl $14				asl 	zTemp3						; now x 4
.01834e	26 15		rol $15				rol 	zTemp3+1
.018350	06 14		asl $14				asl 	zTemp3 						; now x 8
.018352	26 15		rol $15				rol 	zTemp3+1
.018354	05 14		ora $14				ora 	zTemp3 						; OR result in
.018356	85 14		sta $14				sta 	zTemp3
.018358	80 e4		bra $01833e			bra 	_TIM_GHLoop 				; loop round again.
.01835a					_TIMGH_Okay:
.01835a	18		clc				clc
.01835b					_TIMGH_Exit:
.01835b	60		rts				rts
.01835c					TIM_GetHexCharacter:
.01835c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01835e	38		sec				sec
.01835f	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018361	90 0e		bcc $018371			bcc 	_TIM_GHCFail
.018363	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018365	90 0b		bcc $018372			bcc 	_TIM_GHCExit
.018367	c9 11		cmp #$11			cmp 	#65-48						; < A
.018369	90 06		bcc $018371			bcc		_TIM_GHCFail
.01836b	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.01836d	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.01836f	90 01		bcc $018372			bcc		_TIM_GHCExit
.018371					_TIM_GHCFail:
.018371	38		sec				sec
.018372					_TIM_GHCExit:
.018372	60		rts				rts
.018373					TIM_BreakVector:
.018373	da		phx				phx									; save X/A on stack
.018374	48		pha				pha
.018375	ba		tsx				tsx 								; X points to S
.018376	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.018379	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837b	d0 03		bne $018380			bne 	_TIMBreak					; if set, it's BRK
.01837d	68		pla				pla 								; abandon routine.
.01837e	fa		plx				plx
.01837f	40		rti				rti
.018380					_TIMBreak:
.018380	68		pla				pla 								; save A X Y and maybe Z
.018381	8d c9 03	sta $03c9			sta 	TIM_A
.018384	fa		plx				plx
.018385	8e ca 03	stx $03ca			stx 	TIM_X
.018388	8c cb 03	sty $03cb			sty 	TIM_Y
.01838b	68		pla				pla 								; get Status Register
.01838c	8d c8 03	sta $03c8			sta 	TIM_SR
.01838f	68		pla				pla
.018390	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018393	68		pla				pla
.018394	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.018397	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839a	d0 03		bne $01839f			bne 	_TIMDecrement 				; brk bumps it.
.01839c	ce c4 03	dec $03c4			dec 	TIM_PC
.01839f					_TIMDecrement:
.01839f	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a2	ba		tsx				tsx 								; and copy SP
.0183a3	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a6	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183a8	9a		txs				txs
.0183a9	4c 88 82	jmp $018288			jmp 	TIM_Start 					; and start up TIM monitor.
.0183ac					TIM_UpdateRegisters:
.0183ac	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; PC
.0183af	b0 28		bcs $0183d9			bcs 	_TIMURFail
.0183b1	a5 14		lda $14				lda 	zTemp3
.0183b3	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b6	a5 15		lda $15				lda 	zTemp3+1
.0183b8	8d c4 03	sta $03c4			sta 	Tim_PC
.0183bb	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; ignore IRQ
.0183be	b0 19		bcs $0183d9			bcs 	_TIMURFail
.0183c0	a2 00		ldx #$00			ldx 	#0
.0183c2					_TIM_URLoop:
.0183c2	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c4	d0 01		bne $0183c7			bne 	_TIM_1
.0183c6	e8		inx				inx
.0183c7					_TIM_1:
.0183c7	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; registers
.0183ca	b0 0d		bcs $0183d9			bcs 	_TIMURFail
.0183cc	a5 14		lda $14				lda 	zTemp3
.0183ce	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d1	e8		inx				inx
.0183d2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d4	d0 ec		bne $0183c2			bne 	_TIM_URLoop
.0183d6	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand
.0183d9					_TIMURFail:
.0183d9	4c f4 81	jmp $0181f4			jmp 	TIM_Error
.0183dc					TIM_LoadMemory:
.0183dc	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; target address => zTemp2
.0183df	a5 14		lda $14				lda 	zTemp3
.0183e1	85 12		sta $12				sta 	zTemp2
.0183e3	a5 15		lda $15				lda 	zTemp3+1
.0183e5	85 13		sta $13				sta 	zTemp2+1
.0183e7					_TIM_LMLoop:
.0183e7	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; next byte ?
.0183ea	b0 0e		bcs $0183fa			bcs 	_TIMLMDone 					; no more
.0183ec	a2 00		ldx #$00			ldx 	#0							; write out.
.0183ee	a5 14		lda $14				lda 	zTemp3
.0183f0	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f2	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f4	d0 f1		bne $0183e7			bne 	_TIM_LMLoop
.0183f6	e6 13		inc $13				inc 	zTemp2+1
.0183f8	80 ed		bra $0183e7			bra 	_TIM_LMLoop
.0183fa					_TIMLMDone:
.0183fa	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183fd					StructureSearchSingle:
.0183fd	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.0183ff					StructureSearchDouble:
.0183ff	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.018401	86 11		stx $11				stx 	zTemp1+1
.018403	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018405	85 12		sta $12				sta 	zTemp2
.018407	80 18		bra $018421			bra 	_SSWLoop 					; jump in, start scanning from here.
.018409					_SSWNextLine:
.018409	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840b	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.01840d	18		clc				clc
.01840e	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018410	85 18		sta $18				sta 	zCodePtr
.018412	90 02		bcc $018416			bcc 	_SNLNoCarry
.018414	e6 19		inc $19				inc 	zCodePtr+1
.018416					_SNLNoCarry:
.018416	a0 00		ldy #$00			ldy 	#0
.018418	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01841a	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841c	f0 54		beq $018472			beq 	_SSWFail
.01841e	c8		iny				iny
.01841f	c8		iny				iny
.018420					_SSWNextSimple:
.018420	c8		iny				iny
.018421					_SSWLoop:
.018421	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018423	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018425	f0 e2		beq $018409			beq 	_SSWNextLine 				; if so, then next line
.018427	10 f7		bpl $018420			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.018429	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842b	d0 08		bne $018435			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.01842d	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.01842f	f0 2d		beq $01845e			beq 	_SSWFound 					; then exit.
.018431	c5 11		cmp $11				cmp 	zTemp1+1
.018433	f0 29		beq $01845e			beq 	_SSWFound
.018435					_SSWCheckUpDown:
.018435	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.018437	90 10		bcc $018449			bcc 	_SSWNext
.018439	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843b	90 08		bcc $018445			bcc 	_SSWPlus
.01843d	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.01843f	b0 08		bcs $018449			bcs 	_SSWNext
.018441	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018443	c6 12		dec $12				dec 	zTemp2
.018445					_SSWPlus:
.018445	e6 12		inc $12				inc 	zTemp2
.018447	30 16		bmi $01845f			bmi 	_SSWUnder					; error if driven -ve
.018449					_SSWNext:
.018449	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01844b	c8		iny				iny 								; skip
.01844c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01844e	90 0c		bcc $01845c			bcc 	_SEDone 					; so just skip over it.
.018450	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018452	90 07		bcc $01845b			bcc 	_SEDouble
.018454	98		tya				tya 								; this is Y + 1
.018455	18		clc				clc
.018456	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018458	a8		tay				tay 								; back in Y.
.018459	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845a	88		dey				dey
.01845b					_SEDouble:
.01845b	c8		iny				iny
.01845c					_SEDone:
.01845c	80 c3		bra $018421			bra 	_SSWLoop
.01845e					_SSWFound:
.01845e	60		rts				rts
.01845f					_SSWUnder:
.01845f	20 83 85	jsr $018583			jsr ERR_Handler
>018462	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846a	65 20 6f 72 64 65 72 00
.018472					_SSWFail:
.018472	20 83 85	jsr $018583			jsr ERR_Handler
>018475	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>01847d	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848a					SkipEndOfCommand:
.01848a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01848c	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.01848e	f0 19		beq $0184a9			beq 	_SOCExit
.018490	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018492	f0 15		beq $0184a9			beq 	_SOCExit
.018494	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018496	c8		iny				iny 								; skip
.018497	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018499	90 0c		bcc $0184a7			bcc 	_SEDone 					; so just skip over it.
.01849b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01849d	90 07		bcc $0184a6			bcc 	_SEDouble
.01849f	98		tya				tya 								; this is Y + 1
.0184a0	18		clc				clc
.0184a1	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.0184a3	a8		tay				tay 								; back in Y.
.0184a4	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a5	88		dey				dey
.0184a6					_SEDouble:
.0184a6	c8		iny				iny
.0184a7					_SEDone:
.0184a7	80 e1		bra $01848a			bra 	SkipEndOfCommand
.0184a9					_SOCExit:
.0184a9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184aa					StackReset:
.0184aa	48		pha				pha
.0184ab	5a		phy				phy
.0184ac	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.0184ae	85 28		sta $28				sta 	zBasicSP
.0184b0	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.0184b2	85 29		sta $29				sta 	zBasicSP+1
.0184b4	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b6	98		tya				tya 								; be a legal token.
.0184b7	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184b9	7a		ply				ply
.0184ba	68		pla				pla
.0184bb	60		rts				rts
.0184bc					StackPushFrame:
.0184bc	48		pha				pha
.0184bd	5a		phy				phy
.0184be	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184bf	48		pha				pha 								; save it.
.0184c0	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184c2	18		clc				clc 								; add to Basic Stack
.0184c3	65 28		adc $28				adc 	zBasicSP
.0184c5	85 28		sta $28				sta 	zBasicSP
.0184c7	90 02		bcc $0184cb			bcc 	_SPFNoBump
.0184c9	e6 29		inc $29				inc 	zBasicSP+1
.0184cb					_SPFNoBump:
.0184cb	a0 00		ldy #$00			ldy 	#0
.0184cd	68		pla				pla
.0184ce	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184d0	7a		ply				ply
.0184d1	68		pla				pla
.0184d2	60		rts				rts
.0184d3					StackPopFrame:
.0184d3	48		pha				pha
.0184d4	5a		phy				phy
.0184d5	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184d7	51 28		eor ($28),y			eor 	(zBasicSP),y
.0184d9	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184db	d0 12		bne $0184ef			bne 	SPFError 					; mixed structures
.0184dd	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.0184df	29 0f		and #$0f			and 	#$0F
.0184e1	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e3	38		sec				sec
.0184e4	65 28		adc $28				adc 	zBasicSP
.0184e6	85 28		sta $28				sta 	zBasicSP
.0184e8	b0 02		bcs $0184ec			bcs 	_SPFNoBump
.0184ea	c6 29		dec $29				dec 	zBasicSP+1
.0184ec					_SPFNoBump:
.0184ec	7a		ply				ply
.0184ed	68		pla				pla
.0184ee	60		rts				rts
.0184ef					SPFError:
.0184ef	20 83 85	jsr $018583			jsr ERR_Handler
>0184f2	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fa	72 75 63 74 75 72 65 73 00
.018503					StackSavePosition:
.018503	98		tya				tya
.018504	5a		phy				phy
.018505	a0 05		ldy #$05			ldy 	#5
.018507	91 28		sta ($28),y			sta 	(zBasicSP),y
.018509	a0 01		ldy #$01			ldy 	#1
.01850b	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.01850d	91 28		sta ($28),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+1
.018512	91 28		sta ($28),y			sta 	(zBasicSP),y
.018514	c8		iny				iny
.018515	a5 1a		lda $1a				lda 	zCodePtr+2
.018517	91 28		sta ($28),y			sta 	(zBasicSP),y
.018519	c8		iny				iny
.01851a	a5 1b		lda $1b				lda 	zCodePtr+3
.01851c	91 28		sta ($28),y			sta 	(zBasicSP),y
.01851e	7a		ply				ply
.01851f	60		rts				rts
.018520					StackRestorePosition:
.018520	5a		phy				phy
.018521	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018523	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+0
.018527	c8		iny				iny
.018528	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+1
.01852c	c8		iny				iny
.01852d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852f	85 1a		sta $1a				sta 	zCodePtr+2
.018531	c8		iny				iny
.018532	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018534	85 1b		sta $1b				sta 	zCodePtr+3
.018536	c8		iny				iny
.018537	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.018539	7a		ply				ply 								; restore Y
.01853a	a8		tay				tay
.01853b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853c					VIOCharPrint:
.01853c	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.01853f					VIOCharGet:
.01853f	20 e3 81	jsr $0181e3			jsr 	IF_GetKey
.018542	c9 00		cmp #$00			cmp 	#0
.018544	f0 02		beq $018548			beq 	_VCG0
.018546	38		sec				sec
.018547	60		rts				rts
.018548	18		clc		_VCG0:	clc
.018549	60		rts				rts
.01854a					VIOCheckBreak:
.01854a	4c de 81	jmp $0181de			jmp 	IF_CheckBreak
.01854d					VIOCharGetPosition:
.01854d	ad 00 05	lda $0500			lda 	IFT_XCursor
.018550	60		rts				rts
.018551					VIOReadLine:
.018551	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018554					SyntaxError:
.018554	20 83 85	jsr $018583			jsr 	ERR_Handler
>018557	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01855f	72 72 6f 72 00
.018564					TypeError:
.018564	20 83 85	jsr $018583			jsr 	ERR_Handler
>018567	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01856f	70 65 00
.018572					BadParamError:
.018572	20 83 85	jsr $018583			jsr 	ERR_Handler
>018575	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>01857d	6d 65 74 65 72 00
.018583					ERR_Handler:
.018583	a0 00		ldy #$00			ldy 	#0
.018585	c8		iny				iny
.018586	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018588	85 80		sta $80				sta 	XS_Mantissa
.01858a	c8		iny				iny
.01858b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01858d	85 81		sta $81				sta 	XS_Mantissa+1
.01858f	fa		plx				plx 								; address in XY
.018590	7a		ply				ply
.018591	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018592	d0 01		bne $018595			bne 	_EHNoSkip
.018594	c8		iny				iny
.018595					_EHNoSkip:
.018595	20 b4 85	jsr $0185b4			jsr 	PrintROMMessage 			; print message from ROM.
.018598	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859a	05 81		ora $81				ora 	XS_Mantissa+1
.01859c	f0 0c		beq $0185aa			beq 	_EHNoLine
.01859e	a2 af		ldx #$af			ldx 	#_EHAt & $FF 				; print " at "
.0185a0	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a2	20 b4 85	jsr $0185b4			jsr 	PrintROMMessage
.0185a5	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185a7	20 c9 85	jsr $0185c9			jsr 	Print16BitInteger
.0185aa					_EHNoLine:
.0185aa	80 fe		bra $0185aa			bra 	_EHNoLine
.0185ac	4c 3c 88	jmp $01883c			jmp 	WarmStart 					; normally warm start.
>0185af	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185b4					PrintROMMessage:
.0185b4	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.0185b6	84 1d		sty $1d				sty 	zLTemp1+1
.0185b8	4b		phk				phk 								; get current code page
.0185b9	68		pla				pla
.0185ba	85 1e		sta $1e				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185bc	a0 00		ldy #$00			ldy 	#0
.0185be					_PRMLoop:
.0185be	b7 1c		lda [$1c],y			lda 	[zLTemp1],y 				; 65816
.0185c0	f0 06		beq $0185c8			beq		_PRMExit 					; character $00 => exit
.0185c2	c8		iny				iny  								; bump Y and print it.
.0185c3	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.0185c6	80 f6		bra $0185be			bra 	_PRMLoop
.0185c8					_PRMExit:
.0185c8	60		rts				rts
.0185c9					Print16BitInteger:
.0185c9	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185cb	85 82		sta $82				sta 	XS_Mantissa+2
.0185cd	85 83		sta $83				sta 	XS_Mantissa+3
.0185cf					Print32BitInteger:
.0185cf	a9 00		lda #$00			lda 	#0
.0185d1	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185d4	aa		tax				tax 								; convert bottom level.
.0185d5	20 97 a1	jsr $01a197			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185d8	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185da	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185dd	f0 06		beq $0185e5			beq 	_P1Exit
.0185df	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.0185e2	e8		inx				inx
.0185e3	80 f5		bra $0185da			bra 	_P1Loop
.0185e5	8a		txa		_P1Exit:txa 								; return chars printed.
.0185e6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185e7					VectorTable:
>0185e7	c2 93					.word BinaryOp_And         & $FFFF ; $80 and
>0185e9	de 93					.word BinaryOp_Or          & $FFFF ; $81 or
>0185eb	fa 93					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185ed	fa 93					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185ef	31 94					.word Binary_Equal         & $FFFF ; $84 =
>0185f1	3a 94					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185f3	43 94					.word Binary_Less          & $FFFF ; $86 <
>0185f5	4c 94					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185f7	5e 94					.word Binary_Greater       & $FFFF ; $88 >
>0185f9	55 94					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185fb	f6 94					.word BinaryOp_Add         & $FFFF ; $8a +
>0185fd	12 95					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185ff	23 95					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018601	34 95					.word BinaryOp_Divide      & $FFFF ; $8d /
>018603	a5 86					.word NotImplemented       & $FFFF ; $8e ^
>018605	51 8d					.word Command_IF           & $FFFF ; $8f if
>018607	be 91					.word Command_WHILE        & $FFFF ; $90 while
>018609	e6 91					.word Command_REPEAT       & $FFFF ; $91 repeat
>01860b	a3 89					.word Command_FOR          & $FFFF ; $92 for
>01860d	a5 86					.word NotImplemented       & $FFFF ; $93 then
>01860f	ae 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018611	db 91					.word Command_WEND         & $FFFF ; $95 wend
>018613	ef 91					.word Command_UNTIL        & $FFFF ; $96 until
>018615	20 8a					.word Command_NEXT         & $FFFF ; $97 next
>018617	a5 86					.word NotImplemented       & $FFFF ; $98 not
>018619	a5 86					.word NotImplemented       & $FFFF ; $99 fn(
>01861b	39 96					.word Unary_Abs            & $FFFF ; $9a abs(
>01861d	94 97					.word Unary_Asc            & $FFFF ; $9b asc(
>01861f	c5 a8					.word Unary_Int            & $FFFF ; $9c int(
>018621	53 96					.word Unary_Peek           & $FFFF ; $9d peek(
>018623	46 a8					.word Unary_Rnd            & $FFFF ; $9e rnd(
>018625	c6 96					.word Unary_Usr            & $FFFF ; $9f usr(
>018627	d3 97					.word Unary_Left           & $FFFF ; $a0 left$(
>018629	e8 97					.word Unary_Right          & $FFFF ; $a1 right$(
>01862b	ba 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>01862d	33 99					.word Unary_Spc            & $FFFF ; $a3 spc(
>01862f	62 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018631	e7 96					.word Unary_Val            & $FFFF ; $a5 val(
>018633	ab 97					.word Unary_Len            & $FFFF ; $a6 len(
>018635	60 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018637	a5 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018639	a5 86					.word NotImplemented       & $FFFF ; $a9 cos(
>01863b	a5 86					.word NotImplemented       & $FFFF ; $aa tan(
>01863d	a5 86					.word NotImplemented       & $FFFF ; $ab atn(
>01863f	a5 86					.word NotImplemented       & $FFFF ; $ac exp(
>018641	a5 86					.word NotImplemented       & $FFFF ; $ad log(
>018643	a5 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018645	b6 98					.word Unary_Dec            & $FFFF ; $af dec(
>018647	57 96					.word Unary_Deek           & $FFFF ; $b0 deek(
>018649	5b 96					.word Unary_Leek           & $FFFF ; $b1 leek(
>01864b	93 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>01864d	f3 95					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01864f	15 99					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018651	87 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>018653	56 99					.word Unary_Tab            & $FFFF ; $b6 tab(
>018655	a5 86					.word NotImplemented       & $FFFF ; $b7 $
>018657	a5 86					.word NotImplemented       & $FFFF ; $b8 $(
>018659	a5 86					.word NotImplemented       & $FFFF ; $b9 #
>01865b	a5 86					.word NotImplemented       & $FFFF ; $ba #(
>01865d	a5 86					.word NotImplemented       & $FFFF ; $bb %
>01865f	a5 86					.word NotImplemented       & $FFFF ; $bc %(
>018661	a5 86					.word NotImplemented       & $FFFF ; $bd (
>018663	a5 86					.word NotImplemented       & $FFFF ; $be )
>018665	a5 86					.word NotImplemented       & $FFFF ; $bf ,
>018667	a2 89					.word Command_COLON        & $FFFF ; $c0 :
>018669	a5 86					.word NotImplemented       & $FFFF ; $c1 ;
>01866b	a5 86					.word NotImplemented       & $FFFF ; $c2 def
>01866d	9f 91					.word Command_CLR          & $FFFF ; $c3 clr
>01866f	b6 91					.word Command_STOP         & $FFFF ; $c4 stop
>018671	f9 8a					.word Command_DATA         & $FFFF ; $c5 data
>018673	d3 8a					.word Command_READ         & $FFFF ; $c6 read
>018675	49 88					.word Command_DIM          & $FFFF ; $c7 dim
>018677	a5 86					.word NotImplemented       & $FFFF ; $c8 to
>018679	a5 86					.word NotImplemented       & $FFFF ; $c9 step
>01867b	e5 90					.word Command_GOSUB        & $FFFF ; $ca gosub
>01867d	f5 90					.word Command_RETURN       & $FFFF ; $cb return
>01867f	dd 90					.word Command_GOTO         & $FFFF ; $cc goto
>018681	4d 8d					.word Command_END          & $FFFF ; $cd end
>018683	1c 8c					.word Command_INPUT        & $FFFF ; $ce input
>018685	97 8b					.word Command_LET          & $FFFF ; $cf let
>018687	b4 8d					.word Command_LIST         & $FFFF ; $d0 list
>018689	87 90					.word Command_NEW          & $FFFF ; $d1 new
>01868b	a3 90					.word Command_OLD          & $FFFF ; $d2 old
>01868d	fe 90					.word Command_ON           & $FFFF ; $d3 on
>01868f	fc 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018691	56 90					.word Command_POKE         & $FFFF ; $d5 poke
>018693	a8 8f					.word Command_PRINT        & $FFFF ; $d6 print
>018695	14 89					.word Command_RUN          & $FFFF ; $d7 run
>018697	d4 88					.word Command_WAIT         & $FFFF ; $d8 wait
>018699	02 8c					.word Command_SYS          & $FFFF ; $d9 sys
>01869b	5a 90					.word Command_DOKE         & $FFFF ; $da doke
>01869d	5e 90					.word Command_LOKE         & $FFFF ; $db loke
>01869f	3e 90					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a1	b8 8b					.word Command_GET          & $FFFF ; $dd get
>0186a3	a8 8d					.word Command_ELSE         & $FFFF ; $de else
.0186a5					NotImplemented:
.0186a5	20 83 85	jsr $018583			jsr ERR_Handler
>0186a8	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b0	65 6d 65 6e 74 65 64 00
.0186b8					BinaryPrecedence:
>0186b8	01					.byte 1    ; $80 and
>0186b9	01					.byte 1    ; $81 or
>0186ba	01					.byte 1    ; $82 xor
>0186bb	01					.byte 1    ; $83 eor
>0186bc	02					.byte 2    ; $84 =
>0186bd	02					.byte 2    ; $85 <>
>0186be	02					.byte 2    ; $86 <
>0186bf	02					.byte 2    ; $87 <=
>0186c0	02					.byte 2    ; $88 >
>0186c1	02					.byte 2    ; $89 >=
>0186c2	03					.byte 3    ; $8a +
>0186c3	03					.byte 3    ; $8b -
>0186c4	04					.byte 4    ; $8c *
>0186c5	04					.byte 4    ; $8d /
>0186c6	05					.byte 5    ; $8e ^
.0186c7					KeywordText:
>0186c7	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186ca	4f d2					.byte $4f,$d2                          ; $81 or
>0186cc	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186cf	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186d2	bd					.byte $bd                              ; $84 =
>0186d3	3c be					.byte $3c,$be                          ; $85 <>
>0186d5	bc					.byte $bc                              ; $86 <
>0186d6	3c bd					.byte $3c,$bd                          ; $87 <=
>0186d8	be					.byte $be                              ; $88 >
>0186d9	3e bd					.byte $3e,$bd                          ; $89 >=
>0186db	ab					.byte $ab                              ; $8a +
>0186dc	ad					.byte $ad                              ; $8b -
>0186dd	aa					.byte $aa                              ; $8c *
>0186de	af					.byte $af                              ; $8d /
>0186df	de					.byte $de                              ; $8e ^
>0186e0	49 c6					.byte $49,$c6                          ; $8f if
>0186e2	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186e7	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186ed	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f0	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186f4	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186f9	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186fd	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018702	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>018706	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018709	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>01870c	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018710	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>018714	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018718	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>01871d	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018721	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>018725	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>01872b	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018732	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018737	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>01873b	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018740	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018744	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018748	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>01874d	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018751	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018755	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018759	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01875d	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018761	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018765	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018769	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01876d	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018772	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018777	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>01877b	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01877f	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018784	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018788	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>01878c	a4					.byte $a4                              ; $b7 $
>01878d	24 a8					.byte $24,$a8                          ; $b8 $(
>01878f	a3					.byte $a3                              ; $b9 #
>018790	23 a8					.byte $23,$a8                          ; $ba #(
>018792	a5					.byte $a5                              ; $bb %
>018793	25 a8					.byte $25,$a8                          ; $bc %(
>018795	a8					.byte $a8                              ; $bd (
>018796	a9					.byte $a9                              ; $be )
>018797	ac					.byte $ac                              ; $bf ,
>018798	ba					.byte $ba                              ; $c0 :
>018799	bb					.byte $bb                              ; $c1 ;
>01879a	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>01879d	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a0	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187a4	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187a8	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187ac	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187af	54 cf					.byte $54,$cf                          ; $c8 to
>0187b1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187b5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187ba	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187c4	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187c7	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187cc	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187cf	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187d3	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187d6	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187d9	4f ce					.byte $4f,$ce                          ; $d3 on
>0187db	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187e2	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187e6	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187eb	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187ee	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187f2	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187f5	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187f9	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187fd	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>018803	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>018806	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>01880a	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.01880b					BASIC_Start:
.01880b	20 a5 81	jsr $0181a5			jsr 	IF_Reset 					; set up and clear screen.
.01880e	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018811	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018813	8d 10 03	sta $0310			sta 	LocalVector
.018816	8d 0c 03	sta $030c			sta 	UserVector
.018819	a9 d5		lda #$d5			lda 	#USRDefault & $FF 			; reset USR vector to a default
.01881b	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.01881e	a9 96		lda #$96			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.018820	8d 0e 03	sta $030e			sta 	UserVector+2
.018823	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018825	8d 0f 03	sta $030f			sta 	UserVector+3
.018828	20 9d 99	jsr $01999d			jsr 	UpdateProgramEnd 			; update the program end.
.01882b	20 9f 91	jsr $01919f			jsr 	ResetRunStatus 				; clear everything (CLR command)
.01882e	c2 30		rep #$30			rep 	#$30
.018830	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018833	1b		tcs				tcs
.018834	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018837	e2 30		sep #$30			sep 	#$30
.018839	4c 14 89	jmp $018914			jmp 	COMMAND_Run
.01883c					WarmStart:
.01883c	c2 30		rep #$30			rep 	#$30
.01883e	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018841	1b		tcs				tcs
.018842	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018845	e2 30		sep #$30			sep 	#$30
.018847	80 f3		bra $01883c			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018849					Command_DIM:
.018849	98		tya				tya
.01884a	48		pha				pha 								; push on stack.
.01884b	20 20 9d	jsr $019d20			jsr 	VariableExtract 			; get the identifier
.01884e	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018851	29 01		and #$01			and 	#1
.018853	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018855	d0 6f		bne $0188c6			bne 	_CDIError
.018857	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018859	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.01885c					_CDIGetDimension:
.01885c	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01885f	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018861	f0 63		beq $0188c6			beq 	_CDIError
.018863	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; evaluate an index size
.018866	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018868	29 80		and #$80			and 	#$80
.01886a	05 82		ora $82				ora 	XS_Mantissa+2
.01886c	05 83		ora $83				ora 	XS_Mantissa+3
.01886e	d0 56		bne $0188c6			bne 	_CDIError
.018870	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018873	18		clc				clc 								; add 1 - max index => size.
.018874	a5 80		lda $80				lda 	XS_Mantissa+0
.018876	69 01		adc #$01			adc 	#1
.018878	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.01887b	a5 81		lda $81				lda 	XS_Mantissa+1
.01887d	69 00		adc #$00			adc 	#0
.01887f	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018882	30 42		bmi $0188c6			bmi 	_CDIError 					; could be dim a(32767)
.018884	e8		inx				inx 								; bump index.
.018885	e8		inx				inx
.018886	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.018889	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01888b	c8		iny				iny
.01888c	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.01888e	f0 cc		beq $01885c			beq 	_CDIGetDimension
.018890	88		dey				dey
.018891	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; closing ) present ?
.018894	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.018897	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018899	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.01889c					_CDICopy:
.01889c	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.01889f	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188a2	ca		dex				dex
.0188a3	10 f7		bpl $01889c			bpl 	_CDICopy
.0188a5	68		pla				pla									; position of array identifier
.0188a6	85 10		sta $10				sta 	zTemp1
.0188a8	98		tya				tya
.0188a9	48		pha				pha
.0188aa	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188ac	a8		tay				tay
.0188ad	20 20 9d	jsr $019d20			jsr 	VariableExtract 			; get the identifier
.0188b0	20 b9 9f	jsr $019fb9			jsr 	VariableLocate 				; check if it exists already.
.0188b3	b0 11		bcs $0188c6			bcs 	_CDIError
.0188b5	20 ac 9d	jsr $019dac			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188b8	68		pla				pla 								; restore code position
.0188b9	a8		tay				tay
.0188ba	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188bc	c8		iny				iny
.0188bd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188bf	f0 88		beq $018849			beq 	Command_DIM
.0188c1	88		dey				dey
.0188c2	20 bb 9e	jsr $019ebb			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.0188c5	60		rts				rts
.0188c6					_CDIError:
.0188c6	20 83 85	jsr $018583			jsr ERR_Handler
>0188c9	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188d1					_CDISyntax:
.0188d1	4c 54 85	jmp $018554			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188d4					Command_WAIT:
.0188d4	20 a3 93	jsr $0193a3			jsr		EvaluateInteger 			; get address to monitor
.0188d7	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.0188d9	20 01 9a	jsr $019a01			jsr 	CheckNextComma
.0188dc	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX
.0188df	a9 00		lda #$00			lda 	#0							; set default xor value.
.0188e1	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188e3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188e5	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188e7	d0 06		bne $0188ef			bne 	_CWAXorDefault
.0188e9	c8		iny				iny
.0188ea	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.0188ec	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX
.0188ef					_CWAXorDefault:
.0188ef	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188f1	85 1c		sta $1c				sta 	zLTemp1
.0188f3	a5 81		lda $81				lda 	XS_Mantissa+1
.0188f5	85 1d		sta $1d				sta 	zLTemp1+1
.0188f7	a5 82		lda $82				lda 	XS_Mantissa+2
.0188f9	85 1e		sta $1e				sta 	zLTemp1+2
.0188fb					_CWAWaitLoop:
.0188fb	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; exit on break.
.0188fe	c9 00		cmp #$00			cmp 	#0
.018900	d0 11		bne $018913			bne 	_CWAWaitExit
.018902	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.018904	a2 00		ldx #$00			ldx 	#0
.018906	5a		phy				phy 								; this is the same routine as PEEK.
.018907	20 7b 99	jsr $01997b			jsr 	MemRead
.01890a	7a		ply				ply
.01890b	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.01890d	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.01890f	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.018911	f0 e8		beq $0188fb			beq 	_CWAWaitLoop 				; and loop if zero.
.018913					_CWAWaitExit:
.018913	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018914					Command_RUN:
.018914	20 9f 91	jsr $01919f			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018917	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018919	85 18		sta $18				sta 	zCodePtr+0
.01891b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01891d	85 19		sta $19				sta 	zCodePtr+1
.01891f	a9 00		lda #$00			lda 	#0
.018921	85 1a		sta $1a				sta 	zCodePtr+2
.018923	85 1b		sta $1b				sta 	zCodePtr+3
.018925	a0 03		ldy #$03			ldy 	#3
.018927					RUN_NewLine:
.018927	a0 00		ldy #$00			ldy 	#0
.018929	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01892b	c8		iny				iny
.01892c	c8		iny				iny
.01892d	c8		iny				iny
.01892e	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018930	d0 16		bne $018948			bne 	RUN_NextCommand
.018932	4c 4d 8d	jmp $018d4d			jmp 	Command_END 				; go do the command code.
.018935					RUN_Skip:
.018935	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018937	c8		iny				iny 								; skip
.018938	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01893a	90 0c		bcc $018948			bcc 	_SEDone 					; so just skip over it.
.01893c	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01893e	90 07		bcc $018947			bcc 	_SEDouble
.018940	98		tya				tya 								; this is Y + 1
.018941	18		clc				clc
.018942	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018944	a8		tay				tay 								; back in Y.
.018945	88		dey				dey 								; fix up, one for the +1, one for the iny
.018946	88		dey				dey
.018947					_SEDouble:
.018947	c8		iny				iny
.018948					_SEDone:
.018948					RUN_NextCommand:
.018948	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01894b	69 10		adc #$10			adc 	#16 						; one time in 16
.01894d	8d a8 03	sta $03a8			sta 	BreakCount
.018950	90 0a		bcc $01895c			bcc 	RUN_NoCheckBreak
.018952	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; check for break
.018955	c9 00		cmp #$00			cmp 	#0
.018957	f0 03		beq $01895c			beq 	RUN_NoCheckBreak
.018959	4c b6 91	jmp $0191b6			jmp 	Command_STOP 				; stop on BREAK.
.01895c					RUN_NoCheckBreak:
.01895c	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01895e	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.018960	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018962	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018964	f0 cf		beq $018935			beq 	RUN_Skip
.018966	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018968	d0 0f		bne $018979			bne 	RUN_Execute
.01896a					RUN_NextLine:
.01896a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01896c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.01896e	18		clc				clc
.01896f	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018971	85 18		sta $18				sta 	zCodePtr
.018973	90 02		bcc $018977			bcc 	_SNLNoCarry
.018975	e6 19		inc $19				inc 	zCodePtr+1
.018977					_SNLNoCarry:
.018977	80 ae		bra $018927			bra 	RUN_NewLine 				; go do the new line code
.018979					RUN_Execute:
.018979	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01897b	b0 1e		bcs $01899b			bcs 	RUN_Extension
.01897d	c8		iny				iny
.01897e	0a		asl a				asl 	a 							; double the character read.
.01897f	90 14		bcc $018995			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018981	aa		tax				tax 								; ready to look up.
.018982	bf e7 85 01	lda $0185e7,x			lda 	VectorTable,x 				; copy address into LocalVector
.018986	8d 11 03	sta $0311			sta 	LocalVector+1
.018989	bf e8 85 01	lda $0185e8,x			lda 	VectorTable+1,x
.01898d	8d 12 03	sta $0312			sta 	LocalVector+2
.018990	20 f0 92	jsr $0192f0			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018993	80 b3		bra $018948			bra 	RUN_NextCommand 			; do the next command.
.018995					RUN_Default:
.018995	88		dey				dey
.018996	20 97 8b	jsr $018b97			jsr 	Command_LET 				; and try LET.
.018999	80 ad		bra $018948			bra 	RUN_NextCommand
.01899b					RUN_Extension:
.01899b	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01899d	f0 96		beq $018935			beq 	RUN_Skip 					; skip over it.
.01899f	4c 54 85	jmp $018554			jmp 	SyntaxError
.0189a2					Command_COLON:
.0189a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189a3					Command_FOR:
.0189a3	20 97 8b	jsr $018b97			jsr 	Command_LET 				; do the A = 99 bit
.0189a6	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.0189a8	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189aa	f0 71		beq $018a1d			beq 	_CFOError
.0189ac	48		pha				pha 								; save the variable type.
.0189ad	5a		phy				phy 								; save type/variable address.
.0189ae	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189b0	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189b2	c8		iny				iny
.0189b3	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.0189b5	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189b7	c8		iny				iny
.0189b8	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.0189ba	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189bc	7a		ply				ply
.0189bd	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189bf	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189c2	a9 c8		lda #$c8			lda 	#token_TO
.0189c4	20 e2 99	jsr $0199e2			jsr 	CheckNextToken
.0189c7	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189c9	20 0d 92	jsr $01920d			jsr 	EvaluateExpression
.0189cc	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0189ce	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189d0	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189d2	d0 06		bne $0189da			bne 	_CFOStep1
.0189d4	c8		iny				iny
.0189d5	20 0f 92	jsr $01920f			jsr 	EvaluateExpressionX 		; get STEP value.
.0189d8	80 0e		bra $0189e8			bra 	_CFOHaveStep
.0189da					_CFOStep1:
.0189da	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189dc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189de	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189e0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189e2	a9 01		lda #$01			lda 	#1
.0189e4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189e6	95 85		sta $85,x			sta 	XS_Type,x
.0189e8					_CFOHaveStep:
.0189e8	68		pla				pla 								; restore variable type
.0189e9	a2 00		ldx #$00			ldx 	#0
.0189eb	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189ed	f0 0a		beq $0189f9			beq 	_CFOInteger
.0189ef	20 c6 a5	jsr $01a5c6			jsr 	FPUToFloat
.0189f2	a2 06		ldx #$06			ldx 	#6
.0189f4	20 c6 a5	jsr $01a5c6			jsr 	FPUToFloat
.0189f7	80 08		bra $018a01			bra 	_CFOEndConv
.0189f9					_CFOInteger:
.0189f9	20 12 a6	jsr $01a612			jsr 	FPUToInteger
.0189fc	a2 06		ldx #$06			ldx 	#6
.0189fe	20 12 a6	jsr $01a612			jsr 	FPUToInteger
.018a01					_CFOEndConv:
.018a01	20 03 85	jsr $018503			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a04	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a06	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push the loop address frame.
.018a09	5a		phy				phy
.018a0a	a0 00		ldy #$00			ldy 	#0
.018a0c					_CFOCopy:
.018a0c	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a0f	c8		iny				iny
.018a10	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a12	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a14	d0 f6		bne $018a0c			bne 	_CFOCopy
.018a16	7a		ply				ply
.018a17	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a19	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018a1c	60		rts				rts
.018a1d					_CFOError:
.018a1d	4c 64 85	jmp $018564			jmp 	TypeError 					; wrong type.
.018a20					Command_NEXT:
.018a20	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a22	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.018a24	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a26	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a28	f0 07		beq $018a31			beq 	_CNextNoVariable
.018a2a	c9 40		cmp #$40			cmp 	#$40
.018a2c	b0 03		bcs $018a31			bcs 	_CNextNoVariable
.018a2e	20 b5 9c	jsr $019cb5			jsr 	VariableFind
.018a31					_CNextNoVariable:
.018a31	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.018a33	48		pha				pha
.018a34	a5 29		lda $29				lda 	zBasicSP+1
.018a36	48		pha				pha
.018a37	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a39	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a3c	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a3e	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a41	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a43	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a46	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a48	f0 11		beq $018a5b			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a4a	5a		phy				phy 								; check addresses match.
.018a4b	a0 02		ldy #$02			ldy 	#2
.018a4d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a4f	c5 24		cmp $24				cmp 	zVarDataPtr
.018a51	d0 69		bne $018abc			bne 	_CNextWrong
.018a53	c8		iny				iny
.018a54	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a56	c5 25		cmp $25				cmp 	zVarDataPtr+1
.018a58	d0 62		bne $018abc			bne 	_CNextWrong
.018a5a	7a		ply				ply
.018a5b					_CNextGetTarget:
.018a5b	5a		phy				phy
.018a5c	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a5e	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a60	85 26		sta $26				sta 	zVarType
.018a62	c8		iny				iny
.018a63	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a65	85 24		sta $24				sta 	zVarDataPtr
.018a67	c8		iny				iny
.018a68	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a6a	85 25		sta $25				sta 	zVarDataPtr+1
.018a6c	a2 0c		ldx #$0c			ldx 	#12
.018a6e	20 fd 9f	jsr $019ffd			jsr 	VariableGet 				; get that variable value into expr[2]
.018a71	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a73	a0 0b		ldy #$0b			ldy 	#11
.018a75					_CNXCopy:
.018a75	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a77	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a79	e8		inx				inx
.018a7a	c8		iny				iny
.018a7b	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a7d	d0 f6		bne $018a75			bne 	_CNXCopy
.018a7f	7a		ply				ply
.018a80	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a82	20 17 96	jsr $019617			jsr 	GetSignCurrent
.018a85	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a88	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a8a	20 f6 94	jsr $0194f6			jsr 	BinaryOp_Add
.018a8d	20 4e a0	jsr $01a04e			jsr 	VariableSet					; and write variable back.
.018a90	a2 00		ldx #$00			ldx 	#0
.018a92	20 7a 94	jsr $01947a			jsr 	CompareValues
.018a95	09 00		ora #$00			ora 	#0
.018a97	f0 05		beq $018a9e			beq 	_CNXAgain 					; if true, then do it again.
.018a99	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a9c	d0 0f		bne $018aad			bne 	_CNXLoopDone
.018a9e					_CNXAgain:
.018a9e	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018aa0	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018aa3	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018aa6	68		pla				pla
.018aa7	85 29		sta $29				sta 	zBasicSP+1
.018aa9	68		pla				pla
.018aaa	85 28		sta $28				sta 	zBasicSP
.018aac					_CNXExit:
.018aac	60		rts				rts
.018aad					_CNXLoopDone:
.018aad	68		pla				pla 								; throw away saved to Basic Stack Pointer
.018aae	68		pla				pla
.018aaf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ab1	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018ab3	d0 f7		bne $018aac			bne 	_CNXExit
.018ab5	c8		iny				iny
.018ab6	20 b5 9c	jsr $019cb5			jsr 	VariableFind 				; identify the variable
.018ab9	4c 31 8a	jmp $018a31			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018abc					_CNextWrong:
.018abc	20 83 85	jsr $018583			jsr ERR_Handler
>018abf	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ac7	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ad3					Command_READ:
.018ad3	20 b5 9c	jsr $019cb5			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ad6	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018ad8	48		pha				pha
.018ad9	a5 25		lda $25				lda 	zVarDataPtr+1
.018adb	48		pha				pha
.018adc	a5 26		lda $26				lda 	zVarType
.018ade	48		pha				pha
.018adf	20 25 8b	jsr $018b25			jsr 	READGetDataItem 			; get the next data item
.018ae2	68		pla				pla 								; restore target variable information.
.018ae3	85 26		sta $26				sta 	zVarType
.018ae5	68		pla				pla
.018ae6	85 25		sta $25				sta 	zVarDataPtr+1
.018ae8	68		pla				pla
.018ae9	85 24		sta $24				sta 	zVarDataPtr
.018aeb	a2 00		ldx #$00			ldx 	#0
.018aed	20 4e a0	jsr $01a04e			jsr 	VariableSet 				; set the value out.
.018af0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018af2	c8		iny				iny
.018af3	c9 bf		cmp #$bf			cmp 	#token_Comma
.018af5	f0 dc		beq $018ad3			beq 	Command_READ 				; found, do another READ
.018af7	88		dey				dey
.018af8	60		rts				rts
.018af9					Command_DATA:
.018af9	4c 8a 84	jmp $01848a			jmp 	SkipEndOfCommand
.018afc					Command_RESTORE:
.018afc	48		pha				pha
.018afd	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018aff	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018b02	8d be 03	sta $03be			sta 	DataLPtr+1
.018b05	68		pla				pla
.018b06	60		rts				rts
.018b07					READSwapPointers:
.018b07	98		tya				tya
.018b08	48		pha				pha 								; save it
.018b09	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b0c	a8		tay				tay
.018b0d	68		pla				pla 								; get code offset and save in DataIndex
.018b0e	8d c1 03	sta $03c1			sta 	DataIndex
.018b11	da		phx				phx
.018b12	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b14					_RSWLoop:
.018b14	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b17	48		pha				pha
.018b18	b5 18		lda $18,x			lda 	zCodePtr+0,x
.018b1a	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b1d	68		pla				pla
.018b1e	95 18		sta $18,x			sta 	zCodePtr+0,x
.018b20	ca		dex				dex
.018b21	10 f1		bpl $018b14			bpl 	_RSWLoop
.018b23	fa		plx				plx
.018b24	60		rts				rts
.018b25					READGetDataItem:
.018b25	20 07 8b	jsr $018b07			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b28	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.018b2a	05 19		ora $19				ora 	zCodePtr+1
.018b2c	d0 12		bne $018b40			bne 	_RGDIIsInitialised
.018b2e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b30	85 18		sta $18				sta 	zCodePtr+0
.018b32	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b34	85 19		sta $19				sta 	zCodePtr+1
.018b36	a9 00		lda #$00			lda 	#0
.018b38	85 1a		sta $1a				sta 	zCodePtr+2
.018b3a	85 1b		sta $1b				sta 	zCodePtr+3
.018b3c	a0 03		ldy #$03			ldy 	#3
.018b3e	80 06		bra $018b46			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b40					_RGDIIsInitialised:
.018b40	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b42	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b44	f0 49		beq $018b8f			beq 	_RGDISkipEvaluateExit
.018b46					_RGDIFindData:
.018b46	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b48	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b4a	f0 19		beq $018b65			beq 	_RGDIFindNextLine
.018b4c	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b4e	f0 3f		beq $018b8f			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b50	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018b52	c8		iny				iny 								; skip
.018b53	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b55	90 0c		bcc $018b63			bcc 	_SEDone 					; so just skip over it.
.018b57	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b59	90 07		bcc $018b62			bcc 	_SEDouble
.018b5b	98		tya				tya 								; this is Y + 1
.018b5c	18		clc				clc
.018b5d	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018b5f	a8		tay				tay 								; back in Y.
.018b60	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b61	88		dey				dey
.018b62					_SEDouble:
.018b62	c8		iny				iny
.018b63					_SEDone:
.018b63	80 e1		bra $018b46			bra 	_RGDIFindData
.018b65					_RGDIFindNextLine:
.018b65	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b67	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018b69	18		clc				clc
.018b6a	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018b6c	85 18		sta $18				sta 	zCodePtr
.018b6e	90 02		bcc $018b72			bcc 	_SNLNoCarry
.018b70	e6 19		inc $19				inc 	zCodePtr+1
.018b72					_SNLNoCarry:
.018b72	a0 00		ldy #$00			ldy 	#0
.018b74	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b76	48		pha				pha
.018b77	c8		iny				iny
.018b78	c8		iny				iny
.018b79	c8		iny				iny
.018b7a	68		pla				pla
.018b7b	d0 c9		bne $018b46			bne 	_RGDIFindData 				; back to scanning.
.018b7d	20 07 8b	jsr $018b07			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b80	20 83 85	jsr $018583			jsr ERR_Handler
>018b83	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b8b	61 74 61 00
.018b8f					_RGDISkipEvaluateExit:
.018b8f	c8		iny				iny
.018b90	20 0d 92	jsr $01920d			jsr 	EvaluateExpression 			; evaluate the expression
.018b93	20 07 8b	jsr $018b07			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b96	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b97					Command_LET:
.018b97	20 b5 9c	jsr $019cb5			jsr 	VariableFind 				; get reference to one variable.
.018b9a	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b9c	20 e2 99	jsr $0199e2			jsr 	CheckNextToken
.018b9f	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018ba1	48		pha				pha
.018ba2	a5 25		lda $25				lda 	zVarDataPtr+1
.018ba4	48		pha				pha
.018ba5	a5 26		lda $26				lda 	zVarType
.018ba7	48		pha				pha
.018ba8	20 0d 92	jsr $01920d			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018bab	68		pla				pla 								; restore target variable information.
.018bac	85 26		sta $26				sta 	zVarType
.018bae	68		pla				pla
.018baf	85 25		sta $25				sta 	zVarDataPtr+1
.018bb1	68		pla				pla
.018bb2	85 24		sta $24				sta 	zVarDataPtr
.018bb4	20 4e a0	jsr $01a04e			jsr 	VariableSet 				; set the value out.
.018bb7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018bb8					Command_GET:
.018bb8					_CGLoop:
.018bb8	20 b5 9c	jsr $019cb5			jsr 	VariableFind 				; get a variable.
.018bbb	20 3f 85	jsr $01853f			jsr 	VIOCharGet 					; get character
.018bbe	b0 02		bcs $018bc2			bcs 	_CGNoKey
.018bc0	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bc2					_CGNoKey:
.018bc2	48		pha				pha
.018bc3	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.018bc5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bc7	f0 1e		beq $018be7			beq 	_CGString
.018bc9	68		pla				pla 								; put character in slot.
.018bca	85 80		sta $80				sta 	XS_Mantissa
.018bcc	a9 00		lda #$00			lda 	#0
.018bce	85 81		sta $81				sta 	XS_Mantissa+1
.018bd0	85 82		sta $82				sta 	XS_Mantissa+2
.018bd2	85 83		sta $83				sta 	XS_Mantissa+3
.018bd4	a9 01		lda #$01			lda 	#1 							; type integer
.018bd6	85 85		sta $85				sta 	XS_Type
.018bd8					_CGWriteSetNext:
.018bd8	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bda	20 4e a0	jsr $01a04e			jsr 	VariableSet
.018bdd	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018bdf	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018be1	d0 03		bne $018be6			bne 	_CGExit
.018be3	c8		iny				iny
.018be4	80 d2		bra $018bb8			bra 	_CGLoop 					; and get another.
.018be6					_CGExit:
.018be6	60		rts				rts
.018be7					_CGString:
.018be7	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018be9	20 46 9a	jsr $019a46			jsr 	AllocateTempString 			; initially empty.
.018bec	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.018bee	85 80		sta $80				sta 	XS_Mantissa
.018bf0	a5 23		lda $23				lda 	zTempStr+1
.018bf2	85 81		sta $81				sta 	XS_Mantissa+1
.018bf4	a9 02		lda #$02			lda 	#2
.018bf6	85 85		sta $85				sta 	XS_Type
.018bf8	68		pla				pla 								; get A
.018bf9	c9 00		cmp #$00			cmp 	#0
.018bfb	f0 db		beq $018bd8			beq 	_CGWriteSetNext
.018bfd	20 71 9a	jsr $019a71			jsr 	WriteTempString 			; write it into string
.018c00	80 d6		bra $018bd8			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018c02					Command_SYS:
.018c02	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; address to call.
.018c05	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c07	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c0a	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c0c	8d 11 03	sta $0311			sta 	LocalVector+1
.018c0f	a5 82		lda $82				lda 	XS_Mantissa+2
.018c11	8d 12 03	sta $0312			sta 	LocalVector+2
.018c14	22 19 8c 01	jsl $018c19			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c18	60		rts				rts
.018c19					_CSYLocalCall:
.018c19	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c1c					Command_INPUT:
.018c1c	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c1e	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c21	8d c3 03	sta $03c3		sta 	InputRetry
.018c24					_CILoop:
.018c24	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c26	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.018c28	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c2a	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c2c	d0 15		bne $018c43		bne 	_CINoPrompt
.018c2e	c8		iny				iny
.018c2f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c31	aa		tax			tax 									; into X
.018c32	c8		iny				iny
.018c33	ca		dex			dex 									; deduct marker/prompt length
.018c34	ca		dex			dex
.018c35	f0 ed		beq $018c24		beq 	_CILoop 						; nothing.
.018c37					_CIShowPrompt:
.018c37	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c39	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018c3c	c8		iny				iny
.018c3d	ca		dex			dex
.018c3e	d0 f7		bne $018c37		bne 	_CIShowPrompt
.018c40	80 e2		bra $018c24		bra 	_CILoop
.018c42					_CIAdvance:
.018c42	c8		iny				iny
.018c43					_CINoPrompt:
.018c43	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c45	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c47	f0 f9		beq $018c42		beq 	_CIAdvance
.018c49	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c4b	f0 f5		beq $018c42		beq 	_CIAdvance
.018c4d	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c4f	f0 04		beq $018c55		beq 	_CIExit
.018c51	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c53	d0 01		bne $018c56		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c55					_CIExit:
.018c55	60		rts			rts
.018c56					_CIIsVariable:
.018c56	20 b5 9c	jsr $019cb5		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c59	a5 26		lda $26			lda 	zVarType
.018c5b	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018c5d	f0 40		beq $018c9f		beq 	_CIIsString
.018c5f					_CINGetText:
.018c5f	a9 00		lda #$00		lda 	#0
.018c61	8d 14 03	sta $0314		sta 	NumBufX
.018c64					_CINSkip:
.018c64	20 fe 8c	jsr $018cfe		jsr 	CIGetCharacter 					; get character skip spaces
.018c67	c9 20		cmp #$20		cmp 	#" "
.018c69	f0 f9		beq $018c64		beq 	_CINSkip
.018c6b	c9 2c		cmp #$2c		cmp 	#","
.018c6d	f0 f5		beq $018c64		beq 	_CINSkip
.018c6f					_CINLoop:
.018c6f	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018c72	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018c75	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018c77	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018c7a	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018c7d	20 fe 8c	jsr $018cfe		jsr 	CIGetCharacter 					; get next character
.018c80	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018c82	f0 08		beq $018c8c		beq 	_CINCopied
.018c84	c9 2c		cmp #$2c		cmp 	#","
.018c86	f0 04		beq $018c8c		beq 	_CINCopied
.018c88	c9 21		cmp #$21		cmp 	#" "+1
.018c8a	b0 e3		bcs $018c6f		bcs 	_CINLoop
.018c8c					_CINCopied:
.018c8c	a2 00		ldx #$00		ldx 	#0
.018c8e	20 26 97	jsr $019726		jsr 	ConvertNumBuffer 				; convert number
.018c91	b0 05		bcs $018c98		bcs 	_CINFailed 						; didn't work.
.018c93	20 4e a0	jsr $01a04e		jsr 	VariableSet 					; set variable.
.018c96	80 8c		bra $018c24		bra 	_CILoop 						; go round again.
.018c98					_CINFailed:
.018c98	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018c9a	8d c2 03	sta $03c2		sta 	InputAvailable
.018c9d	80 c0		bra $018c5f		bra 	_CINGetText 					; and try again
.018c9f					_CIIsString:
.018c9f	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.018ca1	20 46 9a	jsr $019a46		jsr 	AllocateTempString
.018ca4	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.018ca6	8d 14 03	sta $0314		sta 	NumBufX
.018ca9					_CISSkip:
.018ca9	20 fe 8c	jsr $018cfe		jsr 	CIGetCharacter 					; get character skip spaces
.018cac	c9 20		cmp #$20		cmp 	#" "
.018cae	f0 f9		beq $018ca9		beq 	_CISSkip
.018cb0	80 03		bra $018cb5		bra 	_CISInputProcess 				; handle that as the first character
.018cb2					_CISInput:
.018cb2	20 fe 8c	jsr $018cfe		jsr 	CIGetCharacter
.018cb5					_CISInputProcess:
.018cb5	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.018cb7	f0 31		beq $018cea		beq 	_CISDone
.018cb9	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.018cbb	d0 05		bne $018cc2		bne 	_CISNotColon
.018cbd	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.018cc0	10 28		bpl $018cea		bpl 	_CISDone 						; if quote flag zero, done
.018cc2					_CISNotColon:
.018cc2	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.018cc4	f0 1a		beq $018ce0		beq 	_CISIsQuote						; if so handle that code.
.018cc6	20 71 9a	jsr $019a71		jsr 	WriteTempString 				; write to the temporary string
.018cc9	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.018ccc	10 e4		bpl $018cb2		bpl 	_CISInput
.018cce	20 83 85	jsr $018583			jsr ERR_Handler
>018cd1	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>018cd9	6f 20 6c 6f 6e 67 00
.018ce0					_CISIsQuote:
.018ce0	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.018ce3	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.018ce5	8d 14 03	sta $0314		sta 	NumBufX
.018ce8	d0 c8		bne $018cb2		bne 	_CISInput 						; if entered quote mode, get next character
.018cea					_CISDone:
.018cea	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.018cec	85 80		sta $80			sta 	XS_Mantissa+0
.018cee	a5 23		lda $23			lda 	zTempStr+1
.018cf0	85 81		sta $81			sta 	XS_Mantissa+1
.018cf2	a9 02		lda #$02		lda 	#2
.018cf4	85 85		sta $85			sta 	XS_Type
.018cf6	a2 00		ldx #$00		ldx 	#0
.018cf8	20 4e a0	jsr $01a04e		jsr 	VariableSet 					; set variable.
.018cfb	4c 24 8c	jmp $018c24		jmp 	_CILoop 						; and try again
.018cfe					CIGetCharacter:
.018cfe	5a		phy			phy
.018cff	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018d02	f0 0c		beq $018d10		beq 	_CIGCNewLine 					; no, needs a new line.
.018d04	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018d07	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018d09	f0 03		beq $018d0e		beq 	_CIGCNoInc
.018d0b	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018d0e					_CIGCNoInc:
.018d0e	7a		ply			ply
.018d0f	60		rts			rts
.018d10					_CIGCNewLine:
.018d10	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018d13	a9 3f		lda #$3f		lda 	#"?"
.018d15	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018d18	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018d1b	f0 03		beq $018d20		beq 	_CIGCPrompt 					; if so, then print ? again
.018d1d	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018d20					_CIGCPrompt:
.018d20	a0 01		ldy #$01		ldy 	#1
.018d22	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018d25					_CIGCBackOne:
.018d25	88		dey			dey
.018d26					_CIGCLoop:
.018d26	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018d28	f0 fb		beq $018d25		beq 	_CIGCBackOne
.018d2a	20 3f 85	jsr $01853f		jsr 	VIOCharGet 						; get a character
.018d2d	f0 f7		beq $018d26		beq 	_CIGCLoop 						; wait until key pressed
.018d2f	c9 08		cmp #$08		cmp 	#8 								; backspace
.018d31	f0 10		beq $018d43		beq 	_CIGCBackSpace
.018d33	20 3c 85	jsr $01853c		jsr 	VIOCharPrint 					; echo character
.018d36	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018d39	c8		iny			iny
.018d3a	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018d3c	d0 e8		bne $018d26		bne 	_CIGCLoop
.018d3e	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018d41	7a		ply			ply 									; restore Y
.018d42	60		rts			rts
.018d43					_CIGCBackSpace:
.018d43	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018d45	f0 df		beq $018d26		beq 	_CIGCLoop
.018d47	20 3c 85	jsr $01853c		jsr 	VIOCharPrint 					; echo BS
.018d4a	88		dey			dey 									; go back one.
.018d4b	80 d9		bra $018d26		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018d4d					Command_END:
>018d4d	02						.byte 	2
.018d4e	4c 3c 88	jmp $01883c			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018d51					Command_IF:
.018d51	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; check success.
.018d54	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018d56	05 81		ora $81				ora 	XS_Mantissa+1
.018d58	05 82		ora $82				ora 	XS_Mantissa+2
.018d5a	05 83		ora $83				ora 	XS_Mantissa+3
.018d5c	aa		tax				tax 								; put into X.
.018d5d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d5f	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018d61	d0 2c		bne $018d8f			bne 	_FIFExtended
.018d63	c8		iny				iny
.018d64	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018d66	f0 0b		beq $018d73			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018d68	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d6a	29 c0		and #$c0			and 	#$C0 						; is it a number
.018d6c	c9 40		cmp #$40			cmp 	#$40
.018d6e	d0 1e		bne $018d8e			bne 	_FIFContinue 				; if not, do what ever follows.
.018d70	4c dd 90	jmp $0190dd			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018d73					_FIFEndOfLine:
.018d73	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d75	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018d77	f0 15		beq $018d8e			beq 	_FIFContinue
.018d79	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018d7b	c8		iny				iny 								; skip
.018d7c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018d7e	90 0c		bcc $018d8c			bcc 	_SEDone 					; so just skip over it.
.018d80	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018d82	90 07		bcc $018d8b			bcc 	_SEDouble
.018d84	98		tya				tya 								; this is Y + 1
.018d85	18		clc				clc
.018d86	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018d88	a8		tay				tay 								; back in Y.
.018d89	88		dey				dey 								; fix up, one for the +1, one for the iny
.018d8a	88		dey				dey
.018d8b					_SEDouble:
.018d8b	c8		iny				iny
.018d8c					_SEDone:
.018d8c	80 e5		bra $018d73			bra 	_FIFEndOfLine
.018d8e					_FIFContinue:
.018d8e	60		rts				rts
.018d8f					_FIFExtended:
.018d8f	da		phx				phx 								; save result
.018d90	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018d92	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018d95	68		pla				pla 								; restore result
.018d96	f0 01		beq $018d99			beq 	_FIXSkip 					; if zero then it has failed.
.018d98	60		rts				rts 								; test passed, so continue executing
.018d99					_FIXSkip:
.018d99	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018d9b	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018d9d	20 ff 83	jsr $0183ff			jsr 	StructureSearchDouble
.018da0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018da2	c8		iny				iny
.018da3	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018da5	f0 07		beq $018dae			beq 	Command_ENDIF
.018da7	60		rts				rts
.018da8					Command_ELSE:
.018da8	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018daa	20 fd 83	jsr $0183fd			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018dad	c8		iny				iny
.018dae					Command_ENDIF:
.018dae	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018db0	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018db3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018db4					Command_LIST:
.018db4	20 41 8f	jsr $018f41			jsr 	ListGetRange				; get any parameters
.018db7	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018db9	85 18		sta $18				sta 	zCodePtr+0
.018dbb	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018dbd	85 19		sta $19				sta 	zCodePtr+1
.018dbf	a9 00		lda #$00			lda 	#0
.018dc1	85 1a		sta $1a				sta 	zCodePtr+2
.018dc3	85 1b		sta $1b				sta 	zCodePtr+3
.018dc5	a0 03		ldy #$03			ldy 	#3
.018dc7	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018dc9	8d bc 03	sta $03bc			sta 	LastListIndent
.018dcc	8d bb 03	sta $03bb			sta 	ListIndent
.018dcf					_CILLoop:
.018dcf	a0 00		ldy #$00			ldy 	#0
.018dd1	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dd3	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018dd5	f0 23		beq $018dfa			beq 	_CILExit
.018dd7	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; check break
.018dda	c9 00		cmp #$00			cmp 	#0
.018ddc	d0 1c		bne $018dfa			bne 	_CILExit
.018dde	20 88 8f	jsr $018f88			jsr 	ListCheckRange 				; check current line in range.
.018de1	b0 08		bcs $018deb			bcs		_CILNext
.018de3	a0 00		ldy #$00			ldy 	#0
.018de5	c8		iny				iny
.018de6	c8		iny				iny
.018de7	c8		iny				iny
.018de8	20 fd 8d	jsr $018dfd			jsr 	ListLine 					; list one line.
.018deb					_CILNext:
.018deb	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018ded	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018def	18		clc				clc
.018df0	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018df2	85 18		sta $18				sta 	zCodePtr
.018df4	90 02		bcc $018df8			bcc 	_SNLNoCarry
.018df6	e6 19		inc $19				inc 	zCodePtr+1
.018df8					_SNLNoCarry:
.018df8	80 d5		bra $018dcf			bra 	_CILLoop
.018dfa					_CILExit:
.018dfa	4c 3c 88	jmp $01883c			jmp 	WarmStart
.018dfd					ListLine:
.018dfd	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018e00	8d bc 03	sta $03bc			sta 	LastListIndent
.018e03					_LICountIndent:
.018e03	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e05	c9 00		cmp #$00			cmp 	#0
.018e07	f0 2f		beq $018e38			beq 	_LIDoneIndent
.018e09	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018e0b	90 16		bcc $018e23			bcc 	_LICINext
.018e0d	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e0f	b0 12		bcs $018e23			bcs 	_LICINext
.018e11	ee bb 03	inc $03bb			inc 	ListIndent
.018e14	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018e16	90 0b		bcc $018e23			bcc 	_LICINext
.018e18	ce bb 03	dec $03bb			dec 	ListIndent
.018e1b	ce bb 03	dec $03bb			dec 	ListIndent
.018e1e	10 03		bpl $018e23			bpl 	_LICINext
.018e20	ee bb 03	inc $03bb			inc 	ListIndent
.018e23					_LICINext:
.018e23	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018e25	c8		iny				iny 								; skip
.018e26	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018e28	90 0c		bcc $018e36			bcc 	_SEDone 					; so just skip over it.
.018e2a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018e2c	90 07		bcc $018e35			bcc 	_SEDouble
.018e2e	98		tya				tya 								; this is Y + 1
.018e2f	18		clc				clc
.018e30	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018e32	a8		tay				tay 								; back in Y.
.018e33	88		dey				dey 								; fix up, one for the +1, one for the iny
.018e34	88		dey				dey
.018e35					_SEDouble:
.018e35	c8		iny				iny
.018e36					_SEDone:
.018e36	80 cb		bra $018e03			bra 	_LICountIndent
.018e38					_LIDoneIndent:
.018e38	a0 00		ldy #$00			ldy 	#0
.018e3a	c8		iny				iny
.018e3b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e3d	85 80		sta $80				sta 	XS_Mantissa
.018e3f	c8		iny				iny
.018e40	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e42	85 81		sta $81				sta 	XS_Mantissa+1
.018e44	20 c9 85	jsr $0185c9			jsr 	Print16BitInteger 			; print integer.
.018e47	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018e49	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018e4c	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018e4f	90 03		bcc $018e54			bcc 	_LISmaller
.018e51	ad bc 03	lda $03bc			lda 	LastListIndent
.018e54					_LISmaller:
.018e54	0a		asl a				asl 	a 							; double indent
.018e55	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018e57	38		sec				sec
.018e58	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018e5a	aa		tax				tax 								; print spaces to column 6
.018e5b					_LISpace:
.018e5b	a9 20		lda #$20			lda 	#" "
.018e5d	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018e60	e8		inx				inx
.018e61	e0 06		cpx #$06			cpx 	#6
.018e63	d0 f6		bne $018e5b			bne 	_LISpace
.018e65					_LIDecode:
.018e65	c8		iny				iny
.018e66	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e68	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018e6a	f0 0f		beq $018e7b			beq 	_LIExit
.018e6c	30 12		bmi $018e80			bmi 	_LIToken
.018e6e	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018e70	b0 50		bcs $018ec2			bcs 	_LIInteger
.018e72	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018e74	69 20		adc #$20			adc 	#$20
.018e76	20 31 8f	jsr $018f31			jsr 	ListPrintLC 				; print in LC
.018e79	80 ea		bra $018e65			bra 	_LIDecode
.018e7b					_LIExit:
.018e7b	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018e7d	4c 31 8f	jmp $018f31			jmp 	ListPrintLC
.018e80					_LIToken:
.018e80	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018e82	90 49		bcc $018ecd			bcc		_LICommandToken
.018e84	48		pha				pha 								; save in case end
.018e85	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018e87	c9 fe		cmp #$fe			cmp 	#$FE
.018e89	f0 17		beq $018ea2			beq 	_LIPrint
.018e8b	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018e8d	c9 fd		cmp #$fd			cmp 	#$FD
.018e8f	f0 11		beq $018ea2			beq 	_LIPrint
.018e91	a9 52		lda #$52			lda 	#'R'						; must be REM
.018e93	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018e96	a9 45		lda #$45			lda 	#'E'
.018e98	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018e9b	a9 4d		lda #$4d			lda 	#'M'
.018e9d	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018ea0	a2 20		ldx #$20			ldx 	#' '
.018ea2					_LIPrint:
.018ea2	8a		txa				txa
.018ea3	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018ea6	c8		iny				iny
.018ea7	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ea9	aa		tax				tax 								; put in X
.018eaa	ca		dex				dex
.018eab					_LILoop:
.018eab	ca		dex				dex 								; exit when count reached zero.
.018eac	f0 08		beq $018eb6			beq 	_LIEnd
.018eae	c8		iny				iny
.018eaf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018eb1	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018eb4	80 f5		bra $018eab			bra 	_LILoop
.018eb6	68		pla		_LIEnd:	pla 								; get A back
.018eb7	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018eb9	d0 aa		bne $018e65			bne 	_LIDecode
.018ebb	a9 22		lda #$22			lda 	#'"'
.018ebd	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018ec0	80 a3		bra $018e65			bra 	_LIDecode
.018ec2					_LIInteger:
.018ec2	a2 00		ldx #$00			ldx 	#0
.018ec4	20 15 93	jsr $019315			jsr 	EvaluateGetInteger 			; get an atom
.018ec7	88		dey				dey
.018ec8	20 cf 85	jsr $0185cf			jsr 	Print32BitInteger 			; print integer.
.018ecb	80 98		bra $018e65			bra 	_LIDecode
.018ecd					_LICommandToken:
.018ecd	5a		phy				phy 								; save Y
.018ece	48		pha				pha 								; save token
.018ecf	a2 c7		ldx #$c7			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018ed1	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018ed3	86 1c		stx $1c				stx 	zLTemp1
.018ed5	85 1d		sta $1d				sta 	zLTemp1+1
.018ed7	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018ed9	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018edb	68		pla				pla 								; get token
.018edc	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018ede	f0 16		beq $018ef6			beq 	_LIFoundToken
.018ee0	aa		tax				tax
.018ee1					_LITokenLoop:
.018ee1	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018ee3					_LIFindEnd:
.018ee3	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018ee5	c8		iny				iny
.018ee6	0a		asl a				asl 	a
.018ee7	90 fa		bcc $018ee3			bcc 	_LIFindEnd
.018ee9	98		tya				tya 								; that is step to the next
.018eea	18		clc				clc 								; we don't bother bumping the 3rd byte
.018eeb	65 1c		adc $1c				adc 	zLTemp1 					; here.
.018eed	85 1c		sta $1c				sta 	zLTemp1
.018eef	90 02		bcc $018ef3			bcc 	_LINoBump
.018ef1	e6 1d		inc $1d				inc 	zLTemp1+1
.018ef3					_LINoBump:
.018ef3	ca		dex				dex 								; no go round again.
.018ef4	d0 eb		bne $018ee1			bne 	_LITokenLoop
.018ef6					_LIFoundToken:
.018ef6	a0 00		ldy #$00			ldy 	#0
.018ef8					_LIPrintToken:
.018ef8	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018efa	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018efc	d0 16		bne $018f14			bne 	_LINoPrefixSpace
.018efe	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018f00	90 12		bcc $018f14			bcc 	_LINoPrefixSpace
.018f02	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f04	b0 0e		bcs $018f14			bcs 	_LINoPrefixSpace
.018f06	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018f09	e0 20		cpx #$20			cpx 	#" "
.018f0b	f0 07		beq $018f14			beq 	_LINoPrefixSpace
.018f0d	48		pha				pha
.018f0e	a9 20		lda #$20			lda 	#" "
.018f10	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018f13	68		pla				pla
.018f14					_LINoPrefixSpace:
.018f14	c8		iny				iny
.018f15	48		pha				pha 								; save it
.018f16	29 7f		and #$7f			and 	#$7F
.018f18	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018f1b	68		pla				pla
.018f1c	10 da		bpl $018ef8			bpl 	_LIPrintToken 				; go back if not end
.018f1e	7a		ply				ply 								; restore Y
.018f1f	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018f21	c9 41		cmp #$41			cmp 	#"A"
.018f23	90 09		bcc $018f2e			bcc 	_LINotLetter2
.018f25	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f27	b0 05		bcs $018f2e			bcs 	_LINotLetter2
.018f29	a9 20		lda #$20			lda 	#" " 						; add spacing
.018f2b	20 31 8f	jsr $018f31			jsr 	ListPrintLC
.018f2e					_LINotLetter2:
.018f2e	4c 65 8e	jmp $018e65			jmp 	_LIDecode
.018f31					ListPrintLC:
.018f31	8d ba 03	sta $03ba			sta 	LastPrinted
.018f34	c9 41		cmp #$41			cmp 	#"A"
.018f36	90 06		bcc $018f3e			bcc 	_LPLC0
.018f38	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f3a	b0 02		bcs $018f3e			bcs 	_LPLC0
.018f3c	69 20		adc #$20			adc 	#$20
.018f3e	4c 3c 85	jmp $01853c	_LPLC0:	jmp 	VIOCharPrint
.018f41					ListGetRange:
.018f41	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018f43					_LGRClear:
.018f43	a9 00		lda #$00			lda 	#0
.018f45	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f47	ca		dex				dex
.018f48	10 f9		bpl $018f43			bpl 	_LGRClear
.018f4a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f4c	c9 00		cmp #$00			cmp 	#0 							; nothing
.018f4e	f0 21		beq $018f71			beq 	_LGRBlank
.018f50	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018f52	f0 1d		beq $018f71			beq 	_LGRBlank
.018f54	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018f56	f0 18		beq $018f70			beq 	_LGREnd 					; then it's LIST ,x
.018f58	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; get the first number into bottom
.018f5b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f5d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018f5f	f0 0f		beq $018f70			beq 	_LGREnd 					; then it is LIST a,b
.018f61	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018f63	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018f65	a5 81		lda $81				lda 	XS_Mantissa+1
.018f67	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018f69					_LGRBumpExit:
.018f69	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018f6b	d0 02		bne $018f6f			bne 	_LGRBump2
.018f6d	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018f6f					_LGRBump2:
.018f6f	60		rts				rts
.018f70					_LGREnd:
.018f70	c8		iny				iny
.018f71					_LGRBlank:
.018f71	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018f73	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018f75	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018f77	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f79	c9 00		cmp #$00			cmp 	#0
.018f7b	f0 f2		beq $018f6f			beq 	_LGRBump2
.018f7d	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018f7e	b0 ef		bcs $018f6f			bcs 	_LGRBump2
.018f80	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018f82	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX
.018f85	80 e2		bra $018f69			bra 	_LGRBumpExit
.018f87	60		rts				rts
.018f88					ListCheckRange:
.018f88	c8		iny				iny
.018f89	a2 00		ldx #$00			ldx 	#0 							; test low
.018f8b	20 98 8f	jsr $018f98			jsr 	_LCRCompare
.018f8e	90 06		bcc $018f96			bcc 	_LCRFail
.018f90	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018f92	20 98 8f	jsr $018f98			jsr 	_LCRCompare
.018f95	60		rts				rts
.018f96					_LCRFail:
.018f96	38		sec				sec
.018f97	60		rts				rts
.018f98					_LCRCompare:
.018f98	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f9a	38		sec				sec
.018f9b	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018f9d	08		php				php
.018f9e	c8		iny				iny
.018f9f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fa1	28		plp				plp
.018fa2	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018fa4	08		php				php
.018fa5	88		dey				dey
.018fa6	28		plp				plp
.018fa7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018fa8					Command_PRINT:
.018fa8					_CPR_Loop:
.018fa8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018faa	c9 00		cmp #$00			cmp 	#0 							; end
.018fac	f0 24		beq $018fd2			beq 	_CPR_GoNewLine
.018fae	c9 c0		cmp #$c0			cmp 	#token_Colon
.018fb0	f0 20		beq $018fd2			beq 	_CPR_GoNewLine
.018fb2	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018fb4	f0 74		beq $01902a			beq 	_CPR_Skip
.018fb6	c9 bf		cmp #$bf			cmp 	#token_Comma
.018fb8	f0 57		beq $019011			beq 	_CPR_Tab
.018fba	20 0d 92	jsr $01920d			jsr 	EvaluateExpression 			; get expression.
.018fbd	a5 85		lda $85				lda 	XS_Type 					; get type.
.018fbf	29 02		and #$02			and 	#2
.018fc1	d0 27		bne $018fea			bne 	_CPR_String 				; if type = 2 output as string.
.018fc3					_CPR_Number:
.018fc3	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018fc5	8d 14 03	sta $0314			sta 	NumBufX
.018fc8	a5 85		lda $85				lda 	XS_Type 					; get type
.018fca	4a		lsr a				lsr 	a
.018fcb	b0 08		bcs $018fd5			bcs 	_CPRInt 					; if msb set do as integer
.018fcd	20 11 a7	jsr $01a711			jsr 	FPToString 					; call fp to str otherwise
.018fd0	80 06		bra $018fd8			bra 	_CPRNPrint
.018fd2					_CPR_GoNewLine:
.018fd2	4c 38 90	jmp $019038			jmp 	_CPR_NewLine
.018fd5	20 97 a1	jsr $01a197	_CPRInt:jsr 	IntToString
.018fd8					_CPRNPrint:
.018fd8	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018fdb	c9 2d		cmp #$2d			cmp 	#"-"
.018fdd	f0 05		beq $018fe4			beq 	_CPRNoSpace
.018fdf	a9 20		lda #$20			lda 	#" "						; print the leading space
.018fe1	20 3c 85	jsr $01853c			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018fe4					_CPRNoSpace:
.018fe4	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018fe6	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018fe8	80 04		bra $018fee			bra 	_CPRPrint
.018fea					_CPR_String:
.018fea	a6 80		ldx $80				ldx 	XS_Mantissa
.018fec	a5 81		lda $81				lda 	XS_Mantissa+1
.018fee					_CPRPrint:
.018fee	86 20		stx $20				stx 	zGenPtr
.018ff0	85 21		sta $21				sta 	zGenPtr+1
.018ff2	5a		phy				phy
.018ff3	a0 00		ldy #$00			ldy 	#0							; get length into X
.018ff5	b1 20		lda ($20),y			lda 	(zGenPtr),y
.018ff7	aa		tax				tax
.018ff8	f0 09		beq $019003			beq 	_CPREndPrint 				; nothing to print
.018ffa					_CPRLoop:
.018ffa	c8		iny				iny
.018ffb	b1 20		lda ($20),y			lda 	(zGenPtr),y
.018ffd	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.019000	ca		dex				dex
.019001	d0 f7		bne $018ffa			bne 	_CPRLoop
.019003					_CPREndPrint:
.019003	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.019005	29 02		and #$02			and 	#2
.019007	d0 05		bne $01900e			bne 	_CPRNoTrail
.019009	a9 20		lda #$20			lda 	#" "
.01900b	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.01900e					_CPRNoTrail:
.01900e	7a		ply				ply
.01900f	80 97		bra $018fa8			bra 	_CPR_Loop
.019011					_CPR_Tab:
.019011	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.019014					_CPR_CalcSpaces:
.019014	38		sec				sec 								; calculate position mod 10.
.019015	e9 0a		sbc #$0a			sbc 	#10
.019017	b0 fb		bcs $019014			bcs 	_CPR_CalcSpaces
.019019	69 0a		adc #$0a			adc 	#10
.01901b	f0 0d		beq $01902a			beq 	_CPR_Skip 					; nothing to print
.01901d	aa		tax				tax 								; print out spaces to mod 10
.01901e					_CPRTabSpaces:
.01901e	a9 20		lda #$20			lda 	#" "
.019020	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.019023	e8		inx				inx
.019024	e0 0a		cpx #$0a			cpx 	#10
.019026	d0 f6		bne $01901e			bne 	_CPRTabSpaces
.019028	80 e7		bra $019011			bra 	_CPR_Tab
.01902a					_CPR_Skip:
.01902a	c8		iny				iny
.01902b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01902d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01902f	f0 0c		beq $01903d			beq 	_CPR_Exit
.019031	c9 00		cmp #$00			cmp 	#0
.019033	f0 08		beq $01903d			beq 	_CPR_Exit 					; if not go round again.
.019035	4c a8 8f	jmp $018fa8			jmp 	_CPR_Loop
.019038					_CPR_NewLine:
.019038	a9 0d		lda #$0d			lda 	#13
.01903a	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.01903d					_CPR_Exit:
.01903d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.01903e					Command_ASSERT:
.01903e	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.019041	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.019043	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019045	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019047	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019049	f0 01		beq $01904c			beq 	_ASFail
.01904b	60		rts				rts
.01904c					_ASFail:
.01904c	20 83 85	jsr $018583			jsr ERR_Handler
>01904f	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.019056					Command_POKE:
.019056	a9 01		lda #$01			lda 	#1 							; 1 byte
.019058	80 06		bra $019060			bra 	CmdPoke_Main
.01905a					Command_DOKE:
.01905a	a9 02		lda #$02			lda 	#2 							; 2 bytes
.01905c	80 02		bra $019060			bra 	CmdPoke_Main
.01905e					Command_LOKE:
.01905e	a9 04		lda #$04			lda 	#4							; 4 bytes
.019060					CmdPoke_Main:
.019060	48		pha				pha
.019061	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; get two parameters. First is address
.019064	e8		inx				inx
.019065	e8		inx				inx
.019066	e8		inx				inx
.019067	e8		inx				inx
.019068	e8		inx				inx
.019069	e8		inx				inx
.01906a	20 01 9a	jsr $019a01			jsr 	CheckNextComma
.01906d	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX 			; second is the data.
.019070	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.019072	85 1c		sta $1c				sta 	zLTemp1
.019074	a5 81		lda $81				lda 	XS_Mantissa+1
.019076	85 1d		sta $1d				sta 	zLTemp1+1
.019078	a5 82		lda $82				lda 	XS_Mantissa+2
.01907a	85 1e		sta $1e				sta 	zLTemp1+2
.01907c	a5 83		lda $83				lda 	XS_Mantissa+3
.01907e	85 1f		sta $1f				sta 	zLTemp1+3
.019080	68		pla				pla 								; get count
.019081	5a		phy				phy 								; save Y
.019082	20 8c 99	jsr $01998c			jsr 	MemWrite 					; write it out
.019085	7a		ply				ply 								; restore Y and done.
.019086	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.019087					Command_NEW:
.019087	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019089	85 18		sta $18				sta 	zCodePtr+0
.01908b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01908d	85 19		sta $19				sta 	zCodePtr+1
.01908f	a9 00		lda #$00			lda 	#0
.019091	85 1a		sta $1a				sta 	zCodePtr+2
.019093	85 1b		sta $1b				sta 	zCodePtr+3
.019095	a0 03		ldy #$03			ldy 	#3
.019097	a0 00		ldy #$00			ldy 	#0
.019099	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.01909b	97 18		sta [$18],y			sta 	[zCodePtr],y
.01909d	20 9d 99	jsr $01999d			jsr 	UpdateProgramEnd 			; update program end.
.0190a0	4c 3c 88	jmp $01883c			jmp 	WarmStart 					; and always warmstart, can't be running program.
.0190a3					Command_OLD:
.0190a3	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0190a5	85 18		sta $18				sta 	zCodePtr+0
.0190a7	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0190a9	85 19		sta $19				sta 	zCodePtr+1
.0190ab	a9 00		lda #$00			lda 	#0
.0190ad	85 1a		sta $1a				sta 	zCodePtr+2
.0190af	85 1b		sta $1b				sta 	zCodePtr+3
.0190b1	a0 03		ldy #$03			ldy 	#3
.0190b3					_COL_Find:
.0190b3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0190b5	c8		iny				iny
.0190b6	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.0190b8	f0 18		beq $0190d2			beq 	_COL_Found
.0190ba	98		tya				tya
.0190bb	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.0190bd	d0 f4		bne $0190b3			bne 	_COL_Find 					; can't find old EOL, give up.
.0190bf	20 83 85	jsr $018583			jsr ERR_Handler
>0190c2	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>0190ca	43 6f 72 72 75 70 74 00
.0190d2					_COL_Found:
.0190d2	98		tya				tya
.0190d3	48		pha				pha
.0190d4	a0 00		ldy #$00			ldy 	#0
.0190d6	68		pla				pla
.0190d7	97 18		sta [$18],y			sta 	[zCodePtr],y
.0190d9	20 9d 99	jsr $01999d			jsr 	UpdateProgramEnd 			; reset variable pointer
.0190dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.0190dd					Command_GOTO:
.0190dd	20 32 91	jsr $019132			jsr 	GotoGetLineNumber 			; get line number
.0190e0					CmdGOTO:
.0190e0	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.0190e2	4c 4f 91	jmp $01914f			jmp 	GotoChangeToLineNumberX
.0190e5					Command_GOSUB:
.0190e5	20 32 91	jsr $019132			jsr 	GotoGetLineNumber 			; get line number
.0190e8					CmdGOSUB:
.0190e8	20 03 85	jsr $018503			jsr 	StackSavePosition 			; save position on stack and push frame
.0190eb	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.0190ed	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.0190f0	a2 00		ldx #$00			ldx		#0 							; go to that line number
.0190f2	4c 4f 91	jmp $01914f			jmp 	GotoChangeToLineNumberX
.0190f5					Command_RETURN:
.0190f5	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.0190f7	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.0190fa	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; restore position.
.0190fd	60		rts				rts
.0190fe					Command_ON:
.0190fe	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.019100	20 4f 98	jsr $01984f			jsr 	SLIByteParameter
.019103	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019105	f0 28		beq $01912f			beq 	_CONFail 					; can't be zero, error if it is.
.019107	aa		tax				tax 								; save in X.
.019108	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01910a	c8		iny				iny
.01910b	48		pha				pha 								; so we can check what we're doing later.
.01910c	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01910e	f0 07		beq $019117			beq 	_CONOkayToken
.019110	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.019112	f0 03		beq $019117			beq 	_CONOkayToken
.019114	4c 54 85	jmp $018554			jmp 	SyntaxError
.019117					_CONOkayToken:
.019117	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019118					_CONFindNumber:
.019118	20 32 91	jsr $019132			jsr 	GotoGetLineNumber 			; get a line number.
.01911b	fa		plx				plx 								; restore count
.01911c	ca		dex				dex  								; decrement, exit if zero.
.01911d	f0 06		beq $019125			beq 	_CONFound
.01911f	da		phx				phx 								; push back
.019120	20 01 9a	jsr $019a01			jsr 	CheckNextComma				; check for comma
.019123	80 f3		bra $019118			bra 	_CONFindNumber 				; go round again.
.019125					_CONFound:
.019125	68		pla				pla 								; get token to decide what to do
.019126	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019128	f0 b6		beq $0190e0			beq		CmdGOTO 					; then just branch.
.01912a	20 8a 84	jsr $01848a			jsr 	SkipEndOfCommand 			; go to end of command
.01912d	80 b9		bra $0190e8			bra 	CmdGOSUB 					; and do a GOSUB.
.01912f					_CONFail:
.01912f	4c 72 85	jmp $018572			jmp 	BadParamError
.019132					GotoGetLineNumber:
.019132	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; get integer into mantissa.0
.019135	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019137	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.019139	d0 01		bne $01913c			bne 	_GLINError
.01913b	60		rts				rts
.01913c					_GLINError:
.01913c	20 83 85	jsr $018583			jsr ERR_Handler
>01913f	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019147	20 4e 75 6d 62 65 72 00
.01914f					GotoChangeToLineNumberX:
.01914f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.019151	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019153	f0 37		beq $01918c			beq 	_GCTLFail 					; if so, no can do.
.019155	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019157	85 18		sta $18				sta 	zCodePtr+0
.019159	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01915b	85 19		sta $19				sta 	zCodePtr+1
.01915d	a9 00		lda #$00			lda 	#0
.01915f	85 1a		sta $1a				sta 	zCodePtr+2
.019161	85 1b		sta $1b				sta 	zCodePtr+3
.019163	a0 03		ldy #$03			ldy 	#3
.019165					_GCTLLoop:
.019165	a0 00		ldy #$00			ldy 	#0
.019167	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019169	c9 00		cmp #$00			cmp 	#0
.01916b	f0 1f		beq $01918c			beq 	_GCTLFail
.01916d	c8		iny				iny
.01916e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019170	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.019172	d0 07		bne $01917b			bne 	_GCTLNext
.019174	c8		iny				iny
.019175	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019177	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.019179	f0 0f		beq $01918a			beq 	_GCTLExit
.01917b					_GCTLNext:
.01917b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01917d	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.01917f	18		clc				clc
.019180	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.019182	85 18		sta $18				sta 	zCodePtr
.019184	90 02		bcc $019188			bcc 	_SNLNoCarry
.019186	e6 19		inc $19				inc 	zCodePtr+1
.019188					_SNLNoCarry:
.019188	80 db		bra $019165			bra 	_GCTLLoop 					; try next line.
.01918a					_GCTLExit:
.01918a	c8		iny				iny
.01918b	60		rts				rts
.01918c					_GCTLFail:
.01918c	20 83 85	jsr $018583			jsr ERR_Handler
>01918f	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019197	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.01919f					Command_CLR:
.01919f					ResetRunStatus:
.01919f	20 f1 9c	jsr $019cf1			jsr 	VariableClear
.0191a2	20 aa 84	jsr $0184aa			jsr 	StackReset
.0191a5	a9 00		lda #$00			lda 	#HighMemory & $FF
.0191a7	8d 00 03	sta $0300			sta 	StringPtr
.0191aa	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0191ac	8d 01 03	sta $0301			sta 	StringPtr+1
.0191af	20 bb 9e	jsr $019ebb			jsr 	ArrayResetDefault
.0191b2	20 fc 8a	jsr $018afc			jsr 	Command_RESTORE
.0191b5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0191b6					Command_STOP:
.0191b6	20 83 85	jsr $018583			jsr ERR_Handler
>0191b9	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.0191be					Command_WHILE:
.0191be	20 03 85	jsr $018503			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.0191c1	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger 			; calculate the while loop value.
.0191c4	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.0191c6	05 81		ora $81				ora 	XS_Mantissa+1
.0191c8	05 82		ora $82				ora 	XS_Mantissa+2
.0191ca	05 83		ora $83				ora 	XS_Mantissa+3
.0191cc	f0 06		beq $0191d4			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.0191ce	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.0191d0	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on stack
.0191d3	60		rts				rts
.0191d4					_CWHSkip:
.0191d4	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.0191d6	20 fd 83	jsr $0183fd			jsr 	StructureSearchSingle
.0191d9	c8		iny				iny
.0191da	60		rts				rts
.0191db					Command_WEND:
.0191db	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.0191dd	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.0191e0	20 20 85	jsr $018520			jsr 	StackRestorePosition
.0191e3	80 d9		bra $0191be			bra 	Command_WHILE 				; and do the while again.
.0191e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.0191e6					Command_REPEAT:
.0191e6	20 03 85	jsr $018503			jsr 	StackSavePosition			; save position into stack
.0191e9	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0191eb	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on stack
.0191ee	60		rts				rts
.0191ef					Command_UNTIL:
.0191ef	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.0191f1	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.0191f4	20 a3 93	jsr $0193a3			jsr 	EvaluateInteger				; work out the UNTIL expression.
.0191f7	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.0191f9	05 81		ora $81				ora 	XS_Mantissa+1
.0191fb	05 82		ora $82				ora 	XS_Mantissa+2
.0191fd	05 83		ora $83				ora 	XS_Mantissa+3
.0191ff	d0 08		bne $019209			bne 	_CUTExit 					; if not, just exit
.019201	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; otherwise loop round again.
.019204	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019206	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.019209					_CUTExit:
.019209	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.01920a					EVESyntax:
.01920a	4c 54 85	jmp $018554			jmp 	SyntaxError
.01920d					EvaluateExpression:
.01920d	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01920f					EvaluateExpressionX:
.01920f	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.019211					EvaluateExpressionXA:
.019211	48		pha				pha 								; save precedence on stack.
.019212	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019214	f0 f4		beq $01920a			beq 	EVESyntax 					; end of line, syntax error.
.019216	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019218	b0 03		bcs $01921d			bcs 	_EVNotVariable
.01921a	4c e7 92	jmp $0192e7			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01921d					_EVNotVariable:
.01921d	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01921f	90 e9		bcc $01920a			bcc 	EVESyntax
.019221	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019223	b0 58		bcs $01927d			bcs 	_EVNotInteger
.019225	20 15 93	jsr $019315			jsr 	EvaluateGetInteger
.019228					_EVCheckDecimal:
.019228	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01922a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01922c	d0 05		bne $019233			bne 	_EVGotAtom 					; no, get atom.
.01922e					_EVIsDecimal:
.01922e	20 3b 93	jsr $01933b			jsr 	EVGetDecimal 				; extend to the decimal part.
.019231	80 00		bra $019233			bra 	_EVGotAtom 					; and continue to got atom.
.019233					_EVGotAtom:
.019233	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019235	10 44		bpl $01927b			bpl 	_EVExitDrop 				; must be a token.
.019237	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019239	b0 40		bcs $01927b			bcs 	_EVExitDrop
.01923b	68		pla				pla 								; get current precedence
.01923c	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.01923e	da		phx				phx 								; save X
.01923f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019241	aa		tax				tax 								; put in X
.019242	bf 38 86 01	lda $018638,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019246	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.019248	fa		plx				plx 								; restore X
.019249	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.01924b	90 2f		bcc $01927c			bcc 	_EVExit 					; exit if too low.
.01924d	f0 2d		beq $01927c			beq 	_EVExit 					; exit if equals
.01924f	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.019251	48		pha				pha
.019252	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019254	48		pha				pha
.019255	c8		iny				iny
.019256	da		phx				phx 								; save current position
.019257	e8		inx				inx
.019258	e8		inx				inx
.019259	e8		inx				inx
.01925a	e8		inx				inx
.01925b	e8		inx				inx
.01925c	e8		inx				inx
.01925d	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01925f	20 11 92	jsr $019211			jsr 	EvaluateExpressionXA 		; do the RHS.
.019262	fa		plx				plx 								; restore X
.019263	68		pla				pla 								; get the binary operator in A.
.019264					_EVCallA:
.019264	da		phx				phx 								; save X again
.019265	0a		asl a				asl 	a 							; double, lose the MSB.
.019266	aa		tax				tax									; put in X
.019267	bf e7 85 01	lda $0185e7,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01926b	8d 11 03	sta $0311			sta 	LocalVector+1
.01926e	bf e8 85 01	lda $0185e8,x			lda 	VectorTable+1,x
.019272	8d 12 03	sta $0312			sta 	LocalVector+2
.019275	fa		plx				plx 								; restore X
.019276	20 f0 92	jsr $0192f0			jsr 	EVCallLocalVector
.019279	80 b8		bra $019233			bra 	_EVGotAtom 					; and loop back.
.01927b					_EVExitDrop:
.01927b	68		pla				pla
.01927c					_EVExit:
.01927c	60		rts				rts
.01927d					_EVNotInteger:
.01927d	c8		iny				iny
.01927e	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019280	d0 16		bne $019298			bne 	_EVNotMinus
.019282	20 84 93	jsr $019384			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019285	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019287	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019289	f0 05		beq $019290			beq 	_EVMinusFloat
.01928b	20 7a a1	jsr $01a17a			jsr 	IntegerNegateAlways 		; negation
.01928e	80 a3		bra $019233			bra 	_EVGotAtom 					; and go back.
.019290					_EVMinusFloat:
.019290	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019292	49 80		eor #$80			eor 	#$80
.019294	95 85		sta $85,x			sta 	XS_Type,x
.019296	80 9b		bra $019233			bra 	_EVGotAtom
.019298					_EVNotMinus:
.019298	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01929a	d0 17		bne $0192b3			bne 	_EVNotParenthesis
.01929c	20 0f 92	jsr $01920f			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.01929f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192a1	c8		iny				iny
.0192a2	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0192a4	f0 8d		beq $019233			beq 	_EVGotAtom
.0192a6	20 83 85	jsr $018583			jsr ERR_Handler
>0192a9	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0192b1	29 00
.0192b3					_EVNotParenthesis:
.0192b3	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0192b5	d0 0c		bne $0192c3			bne 	_EVNotNot
.0192b7	20 84 93	jsr $019384			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0192ba	20 12 a6	jsr $01a612			jsr 	FPUToInteger 				; make it an integer - if possible.
.0192bd	20 69 93	jsr $019369			jsr 	NotInteger 					; do the not calculation
.0192c0	4c 33 92	jmp $019233			jmp 	_EVGotAtom
.0192c3					_EVNotNot:
.0192c3	c9 fe		cmp #$fe			cmp 	#$FE
.0192c5	d0 12		bne $0192d9			bne 	_EVNotString
.0192c7	20 81 9a	jsr $019a81			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0192ca	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.0192cc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192ce	a5 23		lda $23				lda 	zTempStr+1
.0192d0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192d2	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0192d4	95 85		sta $85,x			sta 	XS_Type,x
.0192d6	4c 33 92	jmp $019233			jmp 	_EVGotAtom
.0192d9					_EVNotString:
.0192d9	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0192db	90 04		bcc $0192e1			bcc 	_EVBadElement
.0192dd	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0192df	90 03		bcc $0192e4			bcc 	_EVUnaryFunction
.0192e1					_EVBadElement:
.0192e1	4c 54 85	jmp $018554			jmp 	SyntaxError
.0192e4					_EVUnaryFunction:
.0192e4	4c 64 92	jmp $019264			jmp 	_EVCallA
.0192e7					_EVVariableHandler:
.0192e7	20 b5 9c	jsr $019cb5			jsr 	VariableFind 				; locate a variable
.0192ea	20 fd 9f	jsr $019ffd			jsr 	VariableGet 				; copy into memory.
.0192ed	4c 33 92	jmp $019233			jmp 	_EVGotAtom 					; and go round.
.0192f0					EVCallLocalVector:
.0192f0	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0192f3					EVShiftMantissaLeft6:
.0192f3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0192f5	95 84		sta $84,x			sta 	XS_Exponent,x
.0192f7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0192f9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192fb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192fd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192ff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019301	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019303	a9 00		lda #$00			lda 	#0
.019305	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019307	20 0a 93	jsr $01930a			jsr 	_EVSMLShift 					; call it here to do it twice
.01930a					_EVSMLShift:
.01930a	56 84		lsr $84,x			lsr 	XS_Exponent,x
.01930c	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01930e	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019310	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019312	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019314	60		rts				rts
.019315					EvaluateGetInteger:
.019315	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019317	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019319	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.01931b	a9 00		lda #$00			lda 	#0
.01931d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01931f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019321	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019323	1a		inc a				inc 	a 							; set to type 1 (integer)
.019324	95 85		sta $85,x			sta 	XS_Type,x
.019326					_EVCheckNextInteger:
.019326	c8		iny				iny
.019327	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019329	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.01932b	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01932d	b0 0b		bcs $01933a			bcs 	_EVEndInteger
.01932f	48		pha				pha 								; save it.
.019330	20 f3 92	jsr $0192f3			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019333	68		pla				pla
.019334	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019336	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019338	80 ec		bra $019326			bra 	_EVCheckNextInteger
.01933a					_EVEndInteger:
.01933a	60		rts				rts
.01933b					EVGetDecimal:
.01933b	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01933d	8d 15 03	sta $0315			sta 	Num_Buffer
.019340	da		phx				phx
.019341	c8		iny				iny
.019342	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019344	c8		iny				iny
.019345	3a		dec a				dec 	a								; convert to a string length.
.019346	3a		dec a				dec 	a
.019347	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019349					_EVGDCopy:
.019349	48		pha				pha 									; save count
.01934a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01934c	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01934f	e8		inx				inx 									; forward ....
.019350	c8		iny				iny
.019351	68		pla				pla 									; get count
.019352	3a		dec a				dec 	a 								; until zero
.019353	d0 f4		bne $019349			bne 	_EVGDCopy
.019355	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019358	fa		plx				plx 									; restore X
.019359	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01935b	85 20		sta $20				sta 	zGenPtr
.01935d	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01935f	85 21		sta $21				sta 	zGenPtr+1
.019361	5a		phy				phy 									; save Y
.019362	a0 00		ldy #$00			ldy 	#0 								; start position
.019364	20 cc a7	jsr $01a7cc			jsr 	FPFromString 					; convert current
.019367	7a		ply				ply 									; restore Y
.019368	60		rts				rts
.019369					NotInteger:
.019369	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01936b	49 ff		eor #$ff			eor 	#$FF
.01936d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01936f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019371	49 ff		eor #$ff			eor 	#$FF
.019373	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019375	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019377	49 ff		eor #$ff			eor 	#$FF
.019379	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01937b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01937d	49 ff		eor #$ff			eor 	#$FF
.01937f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019381	60		rts				rts
.019382					EvaluateGetAtom:
.019382	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019384					EvaluateGetAtomX:
.019384	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019386	20 11 92	jsr $019211			jsr 	EvaluateExpressionXA
.019389	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01938b	29 0f		and #$0f			and 	#15
.01938d	c9 02		cmp #$02			cmp 	#2
.01938f	b0 01		bcs $019392			bcs 	EvaluateType
.019391	60		rts				rts
.019392					EvaluateType:
.019392	4c 64 85	jmp $018564			jmp 	TypeError
.019395					EvaluateNumber:
.019395	a2 00		ldx #$00			ldx 	#0
.019397					EvaluateNumberX:
.019397	20 0f 92	jsr $01920f			jsr 	EvaluateExpressionX
.01939a	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01939c	29 0f		and #$0f			and 	#15
.01939e	c9 02		cmp #$02			cmp 	#2
.0193a0	b0 f0		bcs $019392			bcs 	EvaluateType
.0193a2	60		rts				rts
.0193a3					EvaluateInteger:
.0193a3	a2 00		ldx #$00			ldx 	#0
.0193a5					EvaluateIntegerX:
.0193a5	20 97 93	jsr $019397			jsr 	EvaluateNumberX
.0193a8	20 12 a6	jsr $01a612			jsr 	FPUToInteger
.0193ab	60		rts				rts
.0193ac					EvaluateString:
.0193ac	a2 00		ldx #$00			ldx 	#0
.0193ae					EvaluateStringX:
.0193ae	20 0f 92	jsr $01920f			jsr 	EvaluateExpressionX
.0193b1	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0193b3	29 0f		and #$0f			and 	#15
.0193b5	c9 02		cmp #$02			cmp 	#2
.0193b7	d0 d9		bne $019392			bne 	EvaluateType
.0193b9	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0193bb	85 20		sta $20				sta 	zGenPtr
.0193bd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193bf	85 21		sta $21				sta 	zGenPtr+1
.0193c1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0193c2					BinaryOp_And:
.0193c2	20 16 94	jsr $019416			jsr 	BinaryMakeBothInteger
.0193c5	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193c7	35 86		and $86,x			and 	XS2_Mantissa+0,x
.0193c9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193cb	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0193cd	35 87		and $87,x			and 	XS2_Mantissa+1,x
.0193cf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193d1	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0193d3	35 88		and $88,x			and 	XS2_Mantissa+2,x
.0193d5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193d7	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0193d9	35 89		and $89,x			and 	XS2_Mantissa+3,x
.0193db	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193dd	60		rts				rts
.0193de					BinaryOp_Or:
.0193de	20 16 94	jsr $019416			jsr 	BinaryMakeBothInteger
.0193e1	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193e3	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0193e5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193e7	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0193e9	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0193eb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193ed	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0193ef	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0193f1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193f3	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0193f5	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0193f7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193f9	60		rts				rts
.0193fa					BinaryOp_Eor:
.0193fa					BinaryOp_Xor:
.0193fa	20 16 94	jsr $019416			jsr 	BinaryMakeBothInteger
.0193fd	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193ff	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019401	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019403	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019405	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019407	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019409	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01940b	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.01940d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01940f	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019411	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019413	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019415	60		rts				rts
.019416					BinaryMakeBothInteger:
.019416	da		phx				phx 								; save X
.019417	e8		inx				inx
.019418	e8		inx				inx
.019419	e8		inx				inx
.01941a	e8		inx				inx
.01941b	e8		inx				inx
.01941c	e8		inx				inx
.01941d	20 21 94	jsr $019421			jsr 	BinaryMakeInteger 			; convert to integer.
.019420	fa		plx				plx 								; restore X and fall through.
.019421					BinaryMakeInteger:
.019421	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019423	29 0f		and #$0f			and 	#15 						; check type zero
.019425	f0 04		beq $01942b			beq 	_BMIConvert 				; if float convert to integer.
.019427	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019428	90 04		bcc $01942e			bcc 	_BMIError
.01942a	60		rts				rts
.01942b					_BMIConvert:
.01942b	4c 12 a6	jmp $01a612			jmp 	FPUToInteger 				; convert to integer
.01942e					_BMIError:
.01942e	4c 64 85	jmp $018564			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019431					Binary_Equal:
.019431	20 7a 94	jsr $01947a			jsr 	CompareValues 				; compare the values
.019434	09 00		ora #$00			ora 	#0 							; true if 0
.019436	f0 33		beq $01946b			beq 	CCTrue
.019438	80 2d		bra $019467			bra 	CCFalse
.01943a					Binary_NotEqual:
.01943a	20 7a 94	jsr $01947a			jsr 	CompareValues
.01943d	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.01943f	f0 26		beq $019467			beq 	CCFalse
.019441	80 28		bra $01946b			bra 	CCTrue
.019443					Binary_Less:
.019443	20 7a 94	jsr $01947a			jsr 	CompareValues
.019446	09 00		ora #$00			ora 	#0 							; true if -1
.019448	30 21		bmi $01946b			bmi 	CCTrue
.01944a	80 1b		bra $019467			bra 	CCFalse
.01944c					Binary_LessEqual:
.01944c	20 7a 94	jsr $01947a			jsr 	CompareValues
.01944f	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.019451	d0 18		bne $01946b			bne 	CCTrue
.019453	80 12		bra $019467			bra 	CCFalse
.019455					Binary_GreaterEqual:
.019455	20 7a 94	jsr $01947a			jsr 	CompareValues
.019458	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.01945a	10 0f		bpl $01946b			bpl 	CCTrue
.01945c	80 09		bra $019467			bra 	CCFalse
.01945e					Binary_Greater:
.01945e	20 7a 94	jsr $01947a			jsr 	CompareValues 				; true if 1
.019461	c9 01		cmp #$01			cmp 	#1
.019463	f0 06		beq $01946b			beq 	CCTrue
.019465	80 00		bra $019467			bra 	CCFalse
.019467	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.019469	80 02		bra $01946d			bra 	CCWrite
.01946b	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01946d	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.01946f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019471	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019473	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019475	a9 01		lda #$01			lda 	#1
.019477	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019479	60		rts				rts
.01947a					CompareValues:
.01947a	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.01947c	35 8b		and $8b,x			and 	XS2_Type,x
.01947e	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.019480	f0 11		beq $019493			beq 	_CVString					; comparison routine.
.019482	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019484	35 8b		and $8b,x			and 	XS2_Type,x
.019486	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019487	90 03		bcc $01948c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019489	4c d5 94	jmp $0194d5			jmp 	CompareInteger32 							; so execute code at \1
.01948c					_BCFloat:
.01948c	20 79 95	jsr $019579			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01948f	4c 0b a5	jmp $01a50b			jmp 	FPCompare 							; and execute code at \2
.019492	60		rts				rts
.019493					_CVString:
.019493	da		phx				phx 								; save XY
.019494	5a		phy				phy
.019495	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019497	85 1c		sta $1c				sta		zLTemp1+0
.019499	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01949b	85 1d		sta $1d				sta 	zLTemp1+1
.01949d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01949f	85 1e		sta $1e				sta 	zLTemp1+2
.0194a1	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194a3	85 1f		sta $1f				sta 	zLTemp1+3
.0194a5	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0194a7	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194a9	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194ab	90 02		bcc $0194af			bcc 	_CVCommon
.0194ad	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.0194af					_CVCommon:
.0194af	aa		tax				tax 								; put shorter string length in zero.
.0194b0	f0 0c		beq $0194be			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0194b2					_CVCompare:
.0194b2	c8		iny				iny 								; next character
.0194b3	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.0194b5	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.0194b7	90 13		bcc $0194cc			bcc 	_CVReturnLess 				; <
.0194b9	d0 15		bne $0194d0			bne 	_CVReturnGreater 			; >
.0194bb	ca		dex				dex 								; until common length matched.
.0194bc	d0 f4		bne $0194b2			bne 	_CVCompare
.0194be					_CVMatch:
.0194be	a0 00		ldy #$00			ldy 	#0
.0194c0	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194c2	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194c4	90 06		bcc $0194cc			bcc 	_CVReturnLess 				; <
.0194c6	d0 08		bne $0194d0			bne 	_CVReturnGreater 			; >
.0194c8	a9 00		lda #$00			lda 	#0
.0194ca	80 06		bra $0194d2			bra 	_CVExit
.0194cc					_CVReturnLess:
.0194cc	a9 ff		lda #$ff			lda 	#$FF
.0194ce	80 02		bra $0194d2			bra 	_CVExit
.0194d0					_CVReturnGreater:
.0194d0	a9 01		lda #$01			lda 	#$01
.0194d2					_CVExit:
.0194d2	7a		ply				ply
.0194d3	fa		plx				plx
.0194d4	60		rts				rts
.0194d5					CompareInteger32:
.0194d5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.0194d7	49 80		eor #$80			eor 	#$80
.0194d9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194db	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.0194dd	49 80		eor #$80			eor 	#$80
.0194df	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0194e1	20 5f 95	jsr $01955f			jsr 	SubInteger32 				; subtraction
.0194e4	90 0d		bcc $0194f3			bcc 	_CI32Less 					; cc return -1
.0194e6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0194e8	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0194ea	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194ec	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0194ee	f0 02		beq $0194f2			beq 	_CI32Exit
.0194f0	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0194f2					_CI32Exit:
.0194f2	60		rts				rts
.0194f3					_CI32Less:
.0194f3	a9 ff		lda #$ff			lda 	#$FF
.0194f5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0194f6					BinaryOp_Add:
.0194f6	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0194f8	35 8b		and $8b,x			and 	XS2_Type,x
.0194fa	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0194fc	d0 11		bne $01950f			bne 	_BOAString 					; so go do the string code.
.0194fe	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019500	35 8b		and $8b,x			and 	XS2_Type,x
.019502	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019503	90 03		bcc $019508			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019505	4c 45 95	jmp $019545			jmp 	AddInteger32 							; so execute code at \1
.019508					_BCFloat:
.019508	20 79 95	jsr $019579			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01950b	4c e6 a2	jmp $01a2e6			jmp 	FPAdd 							; and execute code at \2
.01950e	60		rts				rts
.01950f					_BOAString:
.01950f	4c 93 95	jmp $019593			jmp 	ConcatenateString 			; concatenate two strings.
.019512					BinaryOp_Subtract:
.019512	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019514	35 8b		and $8b,x			and 	XS2_Type,x
.019516	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019517	90 03		bcc $01951c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019519	4c 5f 95	jmp $01955f			jmp 	SubInteger32 							; so execute code at \1
.01951c					_BCFloat:
.01951c	20 79 95	jsr $019579			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01951f	4c de a2	jmp $01a2de			jmp 	FPSubtract 							; and execute code at \2
.019522	60		rts				rts
.019523					BinaryOp_Multiply:
.019523	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019525	35 8b		and $8b,x			and 	XS2_Type,x
.019527	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019528	90 03		bcc $01952d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01952a	4c b5 a0	jmp $01a0b5			jmp 	MulInteger32 							; so execute code at \1
.01952d					_BCFloat:
.01952d	20 79 95	jsr $019579			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019530	4c 0d a4	jmp $01a40d			jmp 	FPMultiply 							; and execute code at \2
.019533	60		rts				rts
.019534					BinaryOp_Divide:
.019534	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019536	35 8b		and $8b,x			and 	XS2_Type,x
.019538	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019539	90 03		bcc $01953e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01953b	4c f3 a0	jmp $01a0f3			jmp 	DivInteger32 							; so execute code at \1
.01953e					_BCFloat:
.01953e	20 79 95	jsr $019579			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019541	4c 9a a3	jmp $01a39a			jmp 	FPDivide 							; and execute code at \2
.019544	60		rts				rts
.019545					AddInteger32:
.019545	18		clc				clc
.019546	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019548	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01954a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01954c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01954e	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019550	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019552	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019554	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019556	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019558	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01955a	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01955c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01955e	60		rts				rts
.01955f					SubInteger32:
.01955f	38		sec				sec
.019560	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019562	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019564	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019566	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019568	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01956a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01956c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01956e	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019570	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019572	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019574	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019576	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019578	60		rts				rts
.019579					BinaryMakeBothFloat:
.019579	da		phx				phx 								; save X
.01957a	e8		inx				inx
.01957b	e8		inx				inx
.01957c	e8		inx				inx
.01957d	e8		inx				inx
.01957e	e8		inx				inx
.01957f	e8		inx				inx
.019580	20 84 95	jsr $019584			jsr 	BinaryMakeFloat 			; convert to float.
.019583	fa		plx				plx 								; restore X and fall through.
.019584					BinaryMakeFloat:
.019584	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019586	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019587	b0 04		bcs $01958d			bcs 	_BMFConvert
.019589	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.01958a	b0 04		bcs $019590			bcs 	_BMFError
.01958c	60		rts				rts
.01958d					_BMFConvert:
.01958d	4c c6 a5	jmp $01a5c6			jmp 	FPUToFloat 					; convert to float, only float builds of course
.019590					_BMFError:
.019590	4c 64 85	jmp $018564			jmp 	TypeError
.019593					ConcatenateString:
.019593	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019595	85 1c		sta $1c				sta		zLTemp1+0
.019597	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019599	85 1d		sta $1d				sta 	zLTemp1+1
.01959b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01959d	85 1e		sta $1e				sta 	zLTemp1+2
.01959f	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195a1	85 1f		sta $1f				sta 	zLTemp1+3
.0195a3	5a		phy				phy
.0195a4	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0195a6	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.0195a8	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.0195aa	7a		ply				ply
.0195ab	b0 33		bcs $0195e0			bcs 	_CSError					; check in range.
.0195ad	c9 fe		cmp #$fe			cmp 	#maxString+1
.0195af	b0 2f		bcs $0195e0			bcs 	_CSError
.0195b1	20 46 9a	jsr $019a46			jsr 	AllocateTempString 			; store the result
.0195b4	20 cb 95	jsr $0195cb			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195b7	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0195b9	85 1c		sta $1c				sta 	zLTemp1
.0195bb	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195bd	85 1d		sta $1d				sta 	zLTemp1+1
.0195bf	20 cb 95	jsr $0195cb			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195c2	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.0195c4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195c6	a5 23		lda $23				lda 	zTempStr+1
.0195c8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195ca	60		rts				rts
.0195cb					_CSCopyString:
.0195cb	da		phx				phx
.0195cc	5a		phy				phy
.0195cd	a0 00		ldy #$00			ldy 	#0 							; get length
.0195cf	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0195d1	f0 0a		beq $0195dd			beq 	_CSCSExit 					; if zero, exit immediately
.0195d3	aa		tax				tax 								; put in X which is the counter.
.0195d4					_CSCSLoop:
.0195d4	c8		iny				iny 								; get next char
.0195d5	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0195d7	20 71 9a	jsr $019a71			jsr		WriteTempString 			; copy out to new string
.0195da	ca		dex				dex 								; do whole string
.0195db	d0 f7		bne $0195d4			bne 	_CSCSLoop
.0195dd					_CSCSExit:
.0195dd	7a		ply				ply
.0195de	fa		plx				plx
.0195df	60		rts				rts
.0195e0					_CSError:
.0195e0	20 83 85	jsr $018583			jsr ERR_Handler
>0195e3	53 74 72 69 6e 67 20 74			.text "String too long",0
>0195eb	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0195f3					Unary_Sgn:
.0195f3	20 97 93	jsr $019397			jsr 	EvaluateNumberX 			; get value
.0195f6	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; check right bracket.
.0195f9	20 17 96	jsr $019617			jsr 	GetSignCurrent 				; get sign.
.0195fc	09 00		ora #$00			ora 	#0
.0195fe	10 08		bpl $019608			bpl		UnarySetAInteger			; if 0,1 return that.
.019600	80 00		bra $019602			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019602					UnarySetAMinus1:
.019602	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019604	95 80		sta $80,x			sta 	XS_Mantissa,x
.019606	80 04		bra $01960c			bra 	UnarySetAFill
.019608					UnarySetAInteger:
.019608	95 80		sta $80,x			sta 	XS_Mantissa,x
.01960a	a9 00		lda #$00			lda 	#0
.01960c					UnarySetAFill:
.01960c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01960e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019610	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019612	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019614	95 85		sta $85,x			sta 	XS_Type,x
.019616	60		rts				rts
.019617					GetSignCurrent:
.019617	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019619	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01961a	90 15		bcc $019631			bcc 	_GSCFloat 					; if clear do the float code.
.01961c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.01961e	30 0e		bmi $01962e			bmi 	_GSCMinus1
.019620	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019622	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019624	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019626	d0 03		bne $01962b			bne 	_GSCPlus1 					; check if zero by oring all together.
.019628					_GSCZero:
.019628	a9 00		lda #$00			lda 	#0
.01962a	60		rts				rts
.01962b					_GSCPlus1:
.01962b	a9 01		lda #$01			lda 	#$01
.01962d	60		rts				rts
.01962e					_GSCMinus1:
.01962e	a9 ff		lda #$ff			lda 	#$FF
.019630	60		rts				rts
.019631					_GSCFloat:
.019631	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.019633	70 f3		bvs $019628			bvs 	_GSCZero 					; if zero flag set return zero
.019635	30 f7		bmi $01962e			bmi 	_GSCMinus1 					; if sign set return -1
.019637	80 f2		bra $01962b			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019639					Unary_Abs:
.019639	20 97 93	jsr $019397			jsr 	EvaluateNumberX 			; get value
.01963c	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; check right bracket.
.01963f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019641	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019643	f0 07		beq $01964c			beq 	_UAMinusFloat
.019645	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019647	10 09		bpl $019652			bpl 	_UAExit
.019649	4c 7a a1	jmp $01a17a			jmp 	IntegerNegateAlways 		; if so negate it.
.01964c					_UAMinusFloat:
.01964c	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01964e	29 7f		and #$7f			and		#$7F
.019650	95 85		sta $85,x			sta 	XS_Type,x
.019652					_UAExit:
.019652	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019653					Unary_Peek:
.019653	a9 01		lda #$01			lda 	#1 							; 1 byte
.019655	80 06		bra $01965d			bra 	UPMain
.019657					Unary_Deek:
.019657	a9 02		lda #$02			lda 	#2 							; 2 bytes
.019659	80 02		bra $01965d			bra 	UPMain
.01965b					Unary_Leek:
.01965b	a9 04		lda #$04			lda 	#4 							; 4 bytes
.01965d					UPMain:
.01965d	48		pha				pha 								; save bytes to copy.
.01965e	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.019661	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.019664	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019666	85 1c		sta $1c				sta 	zLTemp1
.019668	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01966a	85 1d		sta $1d				sta 	zLTemp1+1
.01966c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01966e	85 1e		sta $1e				sta 	zLTemp1+2
.019670	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019672	85 1f		sta $1f				sta 	zLTemp1+3
.019674	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.019676	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.019678	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01967a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01967c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01967e	68		pla				pla 								; restore bytes to copy
.01967f	da		phx				phx 								; save XY
.019680	5a		phy				phy
.019681	20 7b 99	jsr $01997b			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.019684	7a		ply				ply 								; restore and exit
.019685	fa		plx				plx
.019686	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019687					Unary_Pos:
.019687	20 97 93	jsr $019397			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.01968a	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; check right bracket.
.01968d	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; get the position
.019690	4c 08 96	jmp $019608			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019693					Unary_Mod:
.019693	20 bb 96	jsr $0196bb			jsr 	_UMParameter 				; first parameter, get |param|
.019696	20 01 9a	jsr $019a01			jsr 	CheckNextComma
.019699	da		phx				phx 								; second parameter, get |param|
.01969a	e8		inx				inx
.01969b	e8		inx				inx
.01969c	e8		inx				inx
.01969d	e8		inx				inx
.01969e	e8		inx				inx
.01969f	e8		inx				inx
.0196a0	20 bb 96	jsr $0196bb			jsr 	_UMParameter
.0196a3	fa		plx				plx
.0196a4	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen
.0196a7	20 f3 a0	jsr $01a0f3			jsr 	DivInteger32 				; divide, which handily leaves ....
.0196aa	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0196ac	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196ae	a5 1d		lda $1d				lda 	zLTemp1+1
.0196b0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196b2	a5 1e		lda $1e				lda 	zLTemp1+2
.0196b4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196b6	a5 1f		lda $1f				lda 	zLTemp1+3
.0196b8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196ba	60		rts				rts
.0196bb					_UMParameter:
.0196bb	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX 			; get value
.0196be	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.0196c0	10 03		bpl $0196c5			bpl 	_UMNotSigned
.0196c2	20 7a a1	jsr $01a17a			jsr 	IntegerNegateAlways
.0196c5					_UMNotSigned:
.0196c5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.0196c6					Unary_Usr:
.0196c6	20 97 93	jsr $019397			jsr 	EvaluateNumberX 			; numeric parameter
.0196c9	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.0196cc	da		phx				phx 								; save XY
.0196cd	5a		phy				phy
.0196ce	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.0196d2	7a		ply				ply 								; restore YX and exit with whatever the
.0196d3	fa		plx				plx 								; routine called has chosen to do with it.
.0196d4	60		rts				rts
.0196d5					USRDefault:
.0196d5	20 83 85	jsr $018583			jsr ERR_Handler
>0196d8	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0196e0	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0196e7					Unary_Val:
.0196e7	20 ae 93	jsr $0193ae			jsr 	EvaluateStringX 			; get string
.0196ea	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; check right bracket.
.0196ed	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0196ef	85 20		sta $20				sta 	zGenPtr
.0196f1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196f3	85 21		sta $21				sta 	zGenPtr+1
.0196f5	da		phx				phx
.0196f6	5a		phy				phy
.0196f7	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0196f9	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0196fb	f0 1b		beq $019718			beq 	UVBadNumber
.0196fd	aa		tax				tax
.0196fe					_UVCopy1:
.0196fe	c8		iny				iny
.0196ff	c0 18		cpy #$18			cpy 	#24 						; too long
.019701	f0 15		beq $019718			beq 	UVBadNumber
.019703	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.019705	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.019708	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.01970a	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.01970d	ca		dex				dex
.01970e	d0 ee		bne $0196fe			bne 	_UVCopy1
.019710	7a		ply				ply
.019711	fa		plx				plx
.019712	20 26 97	jsr $019726			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.019715	b0 01		bcs $019718			bcs 	UVBadNumber
.019717	60		rts				rts
.019718					UVBadNumber:
.019718	20 83 85	jsr $018583			jsr ERR_Handler
>01971b	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>019723	65 72 00
.019726					ConvertNumBuffer:
.019726	5a		phy				phy
.019727	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.019729	85 20		sta $20				sta 	zGenPtr
.01972b	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01972d	85 21		sta $21				sta 	zGenPtr+1
.01972f	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.019732	c9 2d		cmp #$2d			cmp 	#"-"
.019734	d0 02		bne $019738			bne 	_UVNotMinus1
.019736	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.019738					_UVNotMinus1:
.019738	20 4c a2	jsr $01a24c			jsr 	IntFromString 				; get integer
.01973b	b0 22		bcs $01975f			bcs 	_UVFail
.01973d	20 cc a7	jsr $01a7cc			jsr 	FPFromString 				; possibly float it.
.019740	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.019742	d0 1b		bne $01975f			bne 	_UVFail 					; no, exit.
.019744	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.019747	c9 2d		cmp #$2d			cmp 	#"-"
.019749	d0 11		bne $01975c			bne 	_UVNotMinus2
.01974b	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.01974d	29 0f		and #$0f			and 	#$0F
.01974f	f0 05		beq $019756			beq 	_UVNegateFloat
.019751	20 7a a1	jsr $01a17a			jsr 	IntegerNegateAlways
.019754	80 06		bra $01975c			bra 	_UVNotMinus2
.019756					_UVNegateFloat:
.019756	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.019758	09 80		ora #$80			ora 	#$80
.01975a	95 85		sta $85,x			sta 	XS_Type,x
.01975c					_UVNotMinus2:
.01975c	7a		ply				ply
.01975d	18		clc				clc
.01975e	60		rts				rts
.01975f	7a		ply		_UVFail:ply
.019760	38		sec				sec
.019761	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019762					Unary_Str:
.019762	20 97 93	jsr $019397			jsr 	EvaluateNumberX 			; numeric parameter
.019765	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.019768	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01976a	8d 14 03	sta $0314			sta 	NumBufX
.01976d	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01976f	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.019770	b0 05		bcs $019777			bcs 	_USInt 						; if msb set do as integer
.019772	20 11 a7	jsr $01a711			jsr 	FPToString 					; call fp to str otherwise
.019775	80 03		bra $01977a			bra 	_USDuplicate
.019777	20 97 a1	jsr $01a197	_USInt:	jsr 	IntToString					; call int to str.
.01977a					_USDuplicate:
.01977a	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01977d	1a		inc a				inc 	a 							; one more for length
.01977e	20 46 9a	jsr $019a46			jsr 	AllocateTempString 			; allocate space for it.
.019781	5a		phy				phy 								; save Y
.019782	a0 00		ldy #$00			ldy 	#0 							; start copying
.019784	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019787	20 71 9a	jsr $019a71			jsr 	WriteTempString
.01978a	c8		iny				iny
.01978b	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01978e	d0 f4		bne $019784			bne 	_USCopy
.019790	7a		ply				ply 								; restore Y
.019791	4c 6e 99	jmp $01996e			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019794					Unary_Asc:
.019794	20 ae 93	jsr $0193ae			jsr 	EvaluateStringX 			; string parameter
.019797	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.01979a	5a		phy				phy 								; get the string length
.01979b	a0 00		ldy #$00			ldy 	#0
.01979d	b1 20		lda ($20),y			lda 	(zGenPtr),y
.01979f	f0 07		beq $0197a8			beq 	_UAIllegal 					; must be at least one character, 0 => error
.0197a1	c8		iny				iny
.0197a2	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.0197a4	7a		ply				ply
.0197a5	4c 08 96	jmp $019608			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.0197a8					_UAIllegal:
.0197a8	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0197ab					Unary_Len:
.0197ab	20 ae 93	jsr $0193ae			jsr 	EvaluateStringX 			; string parameter
.0197ae	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.0197b1	5a		phy				phy 								; get the string length
.0197b2	a0 00		ldy #$00			ldy 	#0
.0197b4	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197b6	7a		ply				ply
.0197b7	4c 08 96	jmp $019608			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0197ba					Unary_Mid:
.0197ba	20 ae 93	jsr $0193ae			jsr 	EvaluateStringX 				; get string.
.0197bd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197bf	48		pha				pha
.0197c0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197c2	48		pha				pha
.0197c3	20 01 9a	jsr $019a01			jsr 	CheckNextComma 					; skip comma
.0197c6	20 4f 98	jsr $01984f			jsr 	SLIByteParameter 				; get a byte parameter (start)
.0197c9	48		pha				pha 									; and push it.
.0197ca	20 01 9a	jsr $019a01			jsr 	CheckNextComma 					; skip comma
.0197cd	20 4f 98	jsr $01984f			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.0197d0	48		pha				pha 									; and push it.
.0197d1	80 41		bra $019814			bra 	SLIProcess
.0197d3					Unary_Left:
.0197d3	20 ae 93	jsr $0193ae			jsr 	EvaluateStringX 				; get string.
.0197d6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197d8	48		pha				pha
.0197d9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197db	48		pha				pha
.0197dc	a9 01		lda #$01			lda 	#1 								; push start position (1)
.0197de	48		pha				pha
.0197df	20 01 9a	jsr $019a01			jsr 	CheckNextComma 					; skip comma
.0197e2	20 4f 98	jsr $01984f			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.0197e5	48		pha				pha 									; and push it.
.0197e6	80 2c		bra $019814			bra 	SLIProcess
.0197e8					Unary_Right:
.0197e8	20 ae 93	jsr $0193ae			jsr 	EvaluateStringX 				; get string.
.0197eb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197ed	48		pha				pha
.0197ee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197f0	48		pha				pha
.0197f1	da		phx				phx 									; get the string length and push on stack.
.0197f2	a2 00		ldx #$00			ldx 	#0
.0197f4	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.0197f6	fa		plx				plx
.0197f7	48		pha				pha
.0197f8	20 01 9a	jsr $019a01			jsr 	CheckNextComma 					; skip comma
.0197fb	20 4f 98	jsr $01984f			jsr 	SLIByteParameter 				; get a byte parameter.
.0197fe	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019801	68		pla				pla 									; restore string length.
.019802	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019803	38		sec				sec
.019804	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019807	f0 02		beq $01980b			beq 	_URStart 						; if <= 0 start from 1.
.019809	10 02		bpl $01980d			bpl 	_UROkay
.01980b					_URStart:
.01980b	a9 01		lda #$01			lda 	#1
.01980d					_UROkay:
.01980d	48		pha				pha 									; push start
.01980e	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019811	48		pha				pha
.019812	80 00		bra $019814			bra 	SLIProcess
.019814					SLIProcess:
.019814	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 				; closing right bracket.
.019817	68		pla				pla
.019818	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01981b	1a		inc a				inc 	a 								; allocate +1 for it.
.01981c	20 46 9a	jsr $019a46			jsr 	AllocateTempString
.01981f	68		pla				pla 									; pop start number off stack.
.019820	f0 3b		beq $01985d			beq 	SLIError 						; exit if start = 0
.019822	8d a1 03	sta $03a1			sta 	SliceStart
.019825	68		pla				pla  									; pop string address.
.019826	85 21		sta $21				sta 	zGenPtr+1
.019828	68		pla				pla
.019829	85 20		sta $20				sta 	zGenPtr
.01982b	da		phx				phx
.01982c	5a		phy				phy
.01982d	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01982f	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019832					_SLICopy:
.019832	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019835	f0 12		beq $019849			beq 	_SLIExit
.019837	ce a2 03	dec $03a2			dec 	SliceCount
.01983a	98		tya				tya 									; index of character
.01983b	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.01983d	f0 02		beq $019841			beq 	_SLIOk 							; if equal, okay.
.01983f	b0 08		bcs $019849			bcs 	_SLIExit 						; if past end, then exit.
.019841	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019843	c8		iny				iny
.019844	20 71 9a	jsr $019a71			jsr 	WriteTempString
.019847	80 e9		bra $019832			bra 	_SLICopy 						; go round till copied characters
.019849					_SLIExit:
.019849	7a		ply				ply 									; restore YX
.01984a	fa		plx				plx
.01984b	4c 6e 99	jmp $01996e			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01984e	ea		nop				nop
.01984f					SLIByteParameter:
.01984f	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX 				; get integer
.019852	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019854	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019856	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019858	d0 03		bne $01985d			bne 	SLIError
.01985a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01985c	60		rts				rts
.01985d					SLIError:
.01985d	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019860					Unary_Hex:
.019860	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX 			; numeric parameter
.019863	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.019866	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019868	20 46 9a	jsr $019a46			jsr 	AllocateTempString			; allocate string space
.01986b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01986d	20 91 98	jsr $019891			jsr 	_UHConvert
.019870	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019872	20 91 98	jsr $019891			jsr 	_UHConvert
.019875	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019877	20 91 98	jsr $019891			jsr 	_UHConvert
.01987a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01987c	20 91 98	jsr $019891			jsr 	_UHConvert
.01987f	5a		phy				phy 								; get length of new string
.019880	a0 00		ldy #$00			ldy 	#0
.019882	b1 22		lda ($22),y			lda 	(zTempStr),y
.019884	7a		ply				ply
.019885	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.019887	d0 05		bne $01988e			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.019889	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.01988b	20 71 9a	jsr $019a71			jsr 	WriteTempString
.01988e					_UHExit:
.01988e	4c 6e 99	jmp $01996e			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019891					_UHConvert:
.019891	48		pha				pha
.019892	4a		lsr a				lsr 	a 							; do MSB
.019893	4a		lsr a				lsr 	a
.019894	4a		lsr a				lsr 	a
.019895	4a		lsr a				lsr 	a
.019896	20 9a 98	jsr $01989a			jsr 	_UHNibble
.019899	68		pla				pla 								; do LSB
.01989a					_UHNibble:
.01989a	29 0f		and #$0f			and 	#15 						; get nibble
.01989c	d0 0c		bne $0198aa			bne 	_UHNonZero 					; if not zero, write it out anyway.
.01989e	5a		phy				phy									; get the length
.01989f	a0 00		ldy #$00			ldy 	#0
.0198a1	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198a3	7a		ply				ply
.0198a4	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.0198a6	f0 0d		beq $0198b5			beq 	_UHExit2
.0198a8	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.0198aa					_UHNonZero:
.0198aa	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0198ac	90 02		bcc $0198b0			bcc 	_UHDigit
.0198ae	69 06		adc #$06			adc 	#7-1
.0198b0					_UHDigit:
.0198b0	69 30		adc #$30			adc 	#48
.0198b2	20 71 9a	jsr $019a71			jsr 	WriteTempString				; output to temp string.
.0198b5					_UHExit2:
.0198b5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0198b6					Unary_Dec:
.0198b6	20 ae 93	jsr $0193ae			jsr 	EvaluateStringX 			; string parameter
.0198b9	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.0198bc	5a		phy				phy
.0198bd	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0198bf	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0198c1	f0 43		beq $019906			beq 	_UDFail 					; must fail if zero.
.0198c3	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.0198c6	a9 00		lda #$00			lda 	#0 							; set result to zero
.0198c8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198ca	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0198cc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0198ce	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0198d0	a9 01		lda #$01			lda 	#1 							; set type to integer.
.0198d2	95 85		sta $85,x			sta 	XS_Type,x
.0198d4					_UDConvertLoop:
.0198d4	5a		phy				phy 								; shift mantissa left 4
.0198d5	a0 04		ldy #$04			ldy 	#4
.0198d7					_UDShift:
.0198d7	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.0198d9	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0198db	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0198dd	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0198df	88		dey				dey
.0198e0	d0 f5		bne $0198d7			bne 	_UDShift
.0198e2	7a		ply				ply
.0198e3	c8		iny				iny 								; next character
.0198e4	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.0198e6	20 09 99	jsr $019909			jsr 	ConvertUpper 				; convert to U/C
.0198e9	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.0198eb	90 19		bcc $019906			bcc 	_UDFail
.0198ed	c9 3a		cmp #$3a			cmp 	#"9"+1
.0198ef	90 08		bcc $0198f9			bcc 	_UDOkay
.0198f1	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.0198f3	90 11		bcc $019906			bcc 	_UDFail 					; fails if between 9 and @
.0198f5	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.0198f7	b0 0d		bcs $019906			bcs 	_UDFail
.0198f9					_UDOkay:
.0198f9	29 0f		and #$0f			and 	#15 						; nibble only
.0198fb	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.0198fd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198ff	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.019902	d0 d0		bne $0198d4			bne 	_UDConvertLoop
.019904	7a		ply				ply
.019905	60		rts				rts
.019906					_UDFail:
.019906	4c 72 85	jmp $018572			jmp 	BadParamError
.019909					ConvertUpper:
.019909	c9 61		cmp #$61			cmp 	#"a"
.01990b	90 07		bcc $019914			bcc 	_CUExit
.01990d	c9 7b		cmp #$7b			cmp 	#"z"+1
.01990f	b0 03		bcs $019914			bcs 	_CUExit
.019911	38		sec				sec
.019912	e9 20		sbc #$20			sbc 	#32
.019914	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019915					Unary_Chr:
.019915	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.019918	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; right bracket.
.01991b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01991d	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01991f	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019921	d0 0d		bne $019930			bne 	_UCChar
.019923	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019925	20 46 9a	jsr $019a46			jsr 	AllocateTempString			; allocate it.
.019928	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01992a	20 71 9a	jsr $019a71			jsr 	WriteTempString
.01992d	4c 6e 99	jmp $01996e			jmp 	UnaryReturnTempStr 			; and return that string.
.019930					_UCChar:
.019930	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019933					Unary_Spc:
.019933	20 4f 98	jsr $01984f			jsr 	SLIByteParameter 			; get number of spaces
.019936	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; skip )
.019939	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.01993b					UnarySpcCreate:
.01993b	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.01993d	b0 14		bcs $019953			bcs 	_USSize
.01993f	48		pha				pha 								; save length
.019940	1a		inc a				inc 	a 							; allocate one more.
.019941	20 46 9a	jsr $019a46			jsr 	AllocateTempString
.019944	68		pla				pla 								; get length
.019945	f0 27		beq $01996e			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.019947					_USLoop:
.019947	48		pha				pha
.019948	a9 20		lda #$20			lda 	#" "
.01994a	20 71 9a	jsr $019a71			jsr 	WriteTempString
.01994d	68		pla				pla
.01994e	3a		dec a				dec 	a
.01994f	d0 f6		bne $019947			bne 	_USLoop
.019951	80 1b		bra $01996e			bra 	UnaryReturnTempStr 			; and return the temporary space.
.019953					_USSize:
.019953	4c 72 85	jmp $018572			jmp 	BadParamError
.019956					Unary_Tab:
.019956	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019958	20 4f 98	jsr $01984f			jsr 	SLIByteParameter
.01995b	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen
.01995e	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; were are we ?
.019961	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.019963	38		sec				sec
.019964	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.019966	e5 10		sbc $10				sbc 	zTemp1
.019968	b0 d1		bcs $01993b			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.01996a	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.01996c	80 cd		bra $01993b			bra 	UnarySpcCreate
.01996e					UnaryReturnTempStr:
.01996e	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.019970	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019972	a5 23		lda $23				lda 	zTempStr+1
.019974	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019976	a9 02		lda #$02			lda 	#2 							; set type to string
.019978	95 85		sta $85,x			sta 	XS_Type,x
.01997a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.01997b					MemRead:
.01997b	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01997e	a0 00		ldy #$00			ldy 	#0 							; start from here
.019980	b7 1c		lda [$1c],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019982	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019984	c8		iny				iny 								; next to copy
.019985	e8		inx				inx
.019986	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019989	d0 f5		bne $019980			bne 	_MLoop1
.01998b	60		rts				rts
.01998c					MemWrite:
.01998c	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01998f	a0 00		ldy #$00			ldy 	#0 							; start from here
.019991	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019993	97 1c		sta [$1c],y			sta 	[zlTemp1],y 				; write it out
.019995	c8		iny				iny 								; next to copy
.019996	e8		inx				inx
.019997	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01999a	d0 f5		bne $019991			bne 	_MLoop1
.01999c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01999d					UpdateProgramEnd:
.01999d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01999f	85 18		sta $18				sta 	zCodePtr+0
.0199a1	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0199a3	85 19		sta $19				sta 	zCodePtr+1
.0199a5	a9 00		lda #$00			lda 	#0
.0199a7	85 1a		sta $1a				sta 	zCodePtr+2
.0199a9	85 1b		sta $1b				sta 	zCodePtr+3
.0199ab	a0 03		ldy #$03			ldy 	#3
.0199ad					_UPDLoop:
.0199ad	a0 00		ldy #$00			ldy 	#0
.0199af	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199b1	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0199b3	f0 0f		beq $0199c4			beq 	_UPDFoundEnd
.0199b5	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0199b7	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0199b9	18		clc				clc
.0199ba	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0199bc	85 18		sta $18				sta 	zCodePtr
.0199be	90 02		bcc $0199c2			bcc 	_SNLNoCarry
.0199c0	e6 19		inc $19				inc 	zCodePtr+1
.0199c2					_SNLNoCarry:
.0199c2	80 e9		bra $0199ad			bra 	_UPDLoop
.0199c4					_UPDFoundEnd:
.0199c4	18		clc				clc 								; end of program 2 on.
.0199c5	a5 18		lda $18				lda 	zCodePtr
.0199c7	69 02		adc #$02			adc 	#2
.0199c9	8d 04 03	sta $0304			sta 	endOfProgram
.0199cc	a5 19		lda $19				lda 	zCodePtr+1
.0199ce	69 00		adc #$00			adc 	#0
.0199d0	8d 05 03	sta $0305			sta 	endOfProgram+1
.0199d3	a5 1a		lda $1a				lda 	zCodePtr+2
.0199d5	69 00		adc #$00			adc		#0
.0199d7	8d 06 03	sta $0306			sta 	endOfProgram+2
.0199da	a5 1b		lda $1b				lda 	zCodePtr+3
.0199dc	69 00		adc #$00			adc 	#0
.0199de	8d 07 03	sta $0307			sta 	endOfProgram+3
.0199e1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0199e2					CheckNextToken:
.0199e2	d7 18		cmp [$18],y			cmp 	[zCodePtr],y
.0199e4	d0 02		bne $0199e8			bne 	CTFail 						; no, then fail
.0199e6	c8		iny				iny
.0199e7	60		rts				rts
.0199e8					CTFail:
.0199e8	20 83 85	jsr $018583			jsr ERR_Handler
>0199eb	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0199f3	74 6f 6b 65 6e 00
.0199f9					CheckNextRParen:
.0199f9	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199fb	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.0199fd	d0 e9		bne $0199e8			bne 	CTFail 						; fail if not
.0199ff	c8		iny				iny
.019a00	60		rts				rts
.019a01					CheckNextComma:
.019a01	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a03	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.019a05	d0 e1		bne $0199e8			bne 	CTFail 						; fail if not
.019a07	c8		iny				iny
.019a08	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019a09					StringConcrete:
.019a09	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.019a0b	85 10		sta $10				sta 	zTemp1
.019a0d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a0f	85 11		sta $11				sta 	zTemp1+1
.019a11	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019a13	b1 10		lda ($10),y			lda 	(zTemp1),y
.019a15	f0 26		beq $019a3d			beq		_SCEmpty 					; concreting it wastes memory.
.019a17	18		clc				clc 								; from the string pointer
.019a18	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019a1b	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019a1d	8d 00 03	sta $0300			sta 	StringPtr
.019a20	85 12		sta $12				sta 	zTemp2
.019a22	ad 01 03	lda $0301			lda 	StringPtr+1
.019a25	e9 00		sbc #$00			sbc 	#0
.019a27	8d 01 03	sta $0301			sta 	StringPtr+1
.019a2a	85 13		sta $13				sta 	zTemp2+1
.019a2c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019a2e	1a		inc a				inc 	a
.019a2f	aa		tax				tax
.019a30	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019a32	91 12		sta ($12),y			sta 	(zTemp2),y
.019a34	c8		iny				iny
.019a35	ca		dex				dex
.019a36	d0 f8		bne $019a30			bne 	_SCCopy
.019a38	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019a3a	a6 12		ldx $12				ldx 	zTemp2
.019a3c	60		rts				rts
.019a3d					_SCEmpty:
.019a3d	a9 00		lda #$00			lda 	#0
.019a3f	85 27		sta $27				sta 	zNullString
.019a41	a9 00		lda #$00			lda 	#zNullString >> 8
.019a43	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.019a45	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019a46					AllocateTempString:
.019a46	48		pha				pha 								; save required count.
.019a47	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.019a49	d0 0b		bne $019a56			bne 	_ATSInitialised
.019a4b	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019a4e	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.019a50	ad 01 03	lda $0301			lda 	StringPtr+1
.019a53	3a		dec a				dec 	a 							; allow the page.
.019a54	85 23		sta $23				sta 	zTempStr+1
.019a56					_ATSInitialised:
.019a56	68		pla				pla 								; get required count back.
.019a57	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.019a59	1a		inc a				inc 	a
.019a5a	18		clc				clc
.019a5b	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.019a5d	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.019a5f	a9 ff		lda #$ff			lda 	#$FF
.019a61	65 23		adc $23				adc 	zTempStr+1
.019a63	85 23		sta $23				sta 	zTempStr+1
.019a65	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019a67	5a		phy				phy
.019a68	a8		tay				tay
.019a69	91 22		sta ($22),y			sta 	(zTempStr),y
.019a6b	7a		ply				ply
.019a6c	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019a6d	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019a70	60		rts				rts
.019a71					WriteTempString:
.019a71	5a		phy				phy 								; save Y
.019a72	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019a75	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.019a77	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019a7a	98		tya				tya 								; unchanged Y is now length
.019a7b	a0 00		ldy #$00			ldy 	#0
.019a7d	91 22		sta ($22),y			sta 	(zTempStr),y
.019a7f	7a		ply				ply 								; restore Y and exit
.019a80	60		rts				rts
.019a81					CreateTempStringCopy:
.019a81	da		phx				phx 								; save X
.019a82	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a84	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019a85	20 46 9a	jsr $019a46			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019a88	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a8a	c8		iny				iny
.019a8b	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019a8c	3a		dec a				dec 	a 							; for the marker and the length.
.019a8d	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019a8f	81 22		sta ($22,x)			sta 	(zTempStr,x)
.019a91	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.019a93	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019a95	f0 0e		beq $019aa5			beq 	_CTSCExit
.019a97					_CTSCLoop:
.019a97	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a99	c8		iny				iny
.019a9a	5a		phy				phy 								; save Y
.019a9b	e8		inx				inx 								; bump index
.019a9c	da		phx				phx 								; save that
.019a9d	7a		ply				ply 								; index into Y
.019a9e	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.019aa0	7a		ply				ply 								; restore Y
.019aa1	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.019aa3	d0 f2		bne $019a97			bne 	_CTSCLoop
.019aa5					_CTSCExit:
.019aa5	fa		plx				plx 								; restore X
.019aa6	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.019aa7					TokeniseKeyword:
.019aa7	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.019aa8	18		clc				clc
.019aa9	65 20		adc $20				adc 	zGenPtr
.019aab	85 20		sta $20				sta 	zGenPtr
.019aad	90 02		bcc $019ab1			bcc 	_TKWNoBump
.019aaf	e6 21		inc $21				inc 	zGenPtr+1
.019ab1					_TKWNoBump:
.019ab1	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.019ab3	da		phx				phx
.019ab4	a9 c7		lda #$c7			lda 	#KeyWordText & $FF 			; scan this table.
.019ab6	a2 86		ldx #$86			ldx 	#(KeyWordText >> 8) & $FF
.019ab8	20 c3 9a	jsr $019ac3			jsr 	TKWScanTokenTable
.019abb	fa		plx				plx
.019abc	90 04		bcc $019ac2			bcc 	_TKWNoWrite
.019abe	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.019ac1	e8		inx				inx
.019ac2					_TKWNoWrite:
.019ac2	60		rts				rts
.019ac3					TKWScanTokenTable:
.019ac3	86 1d		stx $1d				stx 	zLTemp1+1
.019ac5	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.019ac7	a9 01		lda #$01			lda 	#KeywordText >> 16 				; 24 bit addresses in the 65816
.019ac9	85 1e		sta $1e				sta 	zLTemp1+2 						; lovely.
.019acb	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.019acd	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.019acf	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019ad1	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise 					; save this in zTemp3
.019ad4	85 14		sta $14				sta 	zTemp3
.019ad6	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.019ad8	85 15		sta $15				sta 	zTemp3+1
.019ada					_TKWScanLoop:
.019ada	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019adc	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.019ade	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.019ae0	d0 26		bne $019b08			bne		_TKWNext 						; if it doesn't match, go to next.
.019ae2	20 27 9b	jsr $019b27			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019ae5	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.019ae7					_TKWCompareFull:
.019ae7	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019ae9	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.019aeb	85 16		sta $16				sta 	zTemp4
.019aed	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.019aef	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise 					; make it U/C
.019af2	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.019af4	d0 12		bne $019b08			bne 	_TKWNext 						; failed, go to next slot.
.019af6	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019af8	c8		iny				iny 									; bump pointer
.019af9	0a		asl a				asl 	a 								; shift bit 7 into C
.019afa	90 eb		bcc $019ae7			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.019afc	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.019afe	90 08		bcc $019b08			bcc 	_TKWNext 						; if shorter, the original was better
.019b00	84 12		sty $12				sty 	zTemp2							; update longest match.
.019b02	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.019b04	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.019b06	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.019b08					_TKWNext:
.019b08	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b0a	c8		iny				iny 									; next one.
.019b0b	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.019b0c	90 fa		bcc $019b08			bcc 	_TKWNext
.019b0e	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.019b10	98		tya				tya 									; has Y gone negative.
.019b11	10 03		bpl $019b16			bpl 	_TKWNoYZero
.019b13	20 27 9b	jsr $019b27			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b16					_TKWNoYZero:
.019b16	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b18	d0 c0		bne $019ada			bne 	_TKWScanLoop 					; if not, try the next one.
.019b1a	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.019b1c	f0 05		beq $019b23			beq 	_TKWFail 						; if zero, none found.
.019b1e	a8		tay				tay 									; return the token in zTemp2, length => y
.019b1f	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.019b21	38		sec				sec
.019b22	60		rts				rts
.019b23					_TKWFail:
.019b23	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.019b25	18		clc				clc
.019b26	60		rts				rts
.019b27					_TKWClearY:
.019b27	98		tya				tya
.019b28	18		clc				clc
.019b29	65 1c		adc $1c				adc 	zLTemp1
.019b2b	85 1c		sta $1c				sta 	zLTemp1
.019b2d	90 02		bcc $019b31			bcc 	_TKWCNoBump
.019b2f	e6 1d		inc $1d				inc 	zLTemp1+1
.019b31					_TKWCNoBump:
.019b31	a0 00		ldy #$00			ldy 	#0
.019b33	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.019b34					TokeniseString:
.019b34	85 20		sta $20				sta 	zGenPtr 					; save source
.019b36	86 21		stx $21				stx 	zGenPtr+1
.019b38	a0 00		ldy #$00			ldy 	#0 							; source
.019b3a	a2 00		ldx #$00			ldx 	#0 							; target
.019b3c					_TSMainLoop:
.019b3c					_TSSkipSpaces:
.019b3c	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.019b3e	c8		iny				iny
.019b3f	c9 20		cmp #$20			cmp 	#" "
.019b41	f0 f9		beq $019b3c			beq 	_TSSkipSpaces
.019b43	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.019b45	90 0a		bcc $019b51			bcc 	_TSNotConstant
.019b47	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b49	b0 06		bcs $019b51			bcs 	_TSNotConstant
.019b4b	88		dey				dey 								; point back to start
.019b4c	20 70 9c	jsr $019c70			jsr 	TokeniseConstant 			; tokenise a constant
.019b4f	80 eb		bra $019b3c			bra 	_TSMainLoop			 		; and loop back.
.019b51					_TSNotConstant:
.019b51	c9 20		cmp #$20			cmp 	#32 						; end of line.
.019b53	90 52		bcc $019ba7			bcc 	_TSExit
.019b55	c9 22		cmp #$22			cmp		#'"'						; quoted string
.019b57	f0 55		beq $019bae			beq 	_TSQuotedString
.019b59	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.019b5b	f0 56		beq $019bb3			beq 	_TSDecimal
.019b5d	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise 				; make U/C
.019b60	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.019b62	d0 05		bne $019b69			bne 	_TSNoRemCheck
.019b64	20 b8 9b	jsr $019bb8			jsr 	TOKCheckREM
.019b67	b0 d3		bcs $019b3c			bcs 	_TSMainLoop 				; and if REM okay, go back.
.019b69					_TSNoRemCheck:
.019b69	88		dey				dey 								; point to character
.019b6a	20 a7 9a	jsr $019aa7			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.019b6d	b0 cd		bcs $019b3c			bcs 	_TSMainLoop					; true if tokenised okay.
.019b6f	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.019b71	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise
.019b74	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.019b76	90 04		bcc $019b7c			bcc 	_TSSingle
.019b78	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019b7a	90 0d		bcc $019b89			bcc 	_TSAlphaNumeric
.019b7c					_TSSingle:
.019b7c	c8		iny				iny 								; skip over output
.019b7d	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.019b7f	09 80		ora #$80			ora 	#128
.019b81	f0 b9		beq $019b3c			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.019b83	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019b86	e8		inx				inx
.019b87	80 b3		bra $019b3c			bra 	_TSMainLoop
.019b89					_TSAlphaNumeric:
.019b89	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.019b8b	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise
.019b8e	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.019b90	90 aa		bcc $019b3c			bcc 	_TSMainLoop
.019b92	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b94	90 0a		bcc $019ba0			bcc 	_TSANOkay
.019b96	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.019b98	90 a2		bcc $019b3c			bcc 	_TSMainLoop
.019b9a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019b9c	b0 9e		bcs $019b3c			bcs 	_TSMainLoop
.019b9e	29 3f		and #$3f			and 	#63 						; write it out
.019ba0					_TSANOkay:
.019ba0	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019ba3	e8		inx				inx
.019ba4	c8		iny				iny
.019ba5	80 e2		bra $019b89			bra 	_TSAlphaNumeric
.019ba7	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.019ba9	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bac	8a		txa				txa 								; return length of tokenised line in bytes.
.019bad	60		rts				rts
.019bae					_TSQuotedString:
.019bae	20 0e 9c	jsr $019c0e			jsr 	TokeniseQuotedString
.019bb1	80 89		bra $019b3c			bra 	_TSMainLoop
.019bb3					_TSDecimal:
.019bb3	20 34 9c	jsr $019c34			jsr 	TokeniseDecimalString
.019bb6	80 84		bra $019b3c			bra 	_TSMainLoop
.019bb8					TOKCheckREM:
.019bb8	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.019bba	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise
.019bbd	c9 45		cmp #$45			cmp 	#"E"
.019bbf	d0 12		bne $019bd3			bne 	_TCRFail
.019bc1	c8		iny				iny
.019bc2	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.019bc4	88		dey				dey
.019bc5	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise
.019bc8	c9 4d		cmp #$4d			cmp 	#"M"
.019bca	d0 07		bne $019bd3			bne 	_TCRFail
.019bcc	c8		iny				iny									; point to first character
.019bcd	c8		iny				iny
.019bce	20 e0 9b	jsr $019be0			jsr 	TokeniseREMString 			; tokenise REM
.019bd1	38		sec				sec
.019bd2	60		rts				rts
.019bd3					_TCRFail:
.019bd3	18		clc				clc
.019bd4	60		rts				rts
.019bd5					TOKCapitalise:
.019bd5	c9 61		cmp #$61			cmp 	#"a"
.019bd7	90 06		bcc $019bdf			bcc 	_TOKCExit
.019bd9	c9 7b		cmp #$7b			cmp 	#"z"+1
.019bdb	b0 02		bcs $019bdf			bcs 	_TOKCExit
.019bdd	49 20		eor #$20			eor 	#$20
.019bdf					_TOKCExit:
.019bdf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.019be0					TokeniseREMString:
.019be0	86 10		stx $10				stx 	zTemp1 						; save position
.019be2	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019be4	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019be7	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.019bea	e8		inx				inx 								; bump, and one space for the count.
.019beb	e8		inx				inx
.019bec					_TSRSkip:
.019bec	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019bee	c8		iny				iny
.019bef	c9 20		cmp #$20			cmp 	#" "
.019bf1	f0 f9		beq $019bec			beq 	_TSRSkip
.019bf3	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.019bf5	f0 31		beq $019c28			beq 	SequenceExit 				; ... that's it.
.019bf7					_TSRCopy:
.019bf7	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.019bfa	e8		inx				inx
.019bfb	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.019bfd	f0 05		beq $019c04			beq 	_TSRExit 					; zero is exit
.019bff	c8		iny				iny 								; bump pointer
.019c00	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.019c02	d0 f3		bne $019bf7			bne 	_TSRCopy
.019c04					_TSRExit:
.019c04	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.019c07	c9 20		cmp #$20			cmp 	#" "
.019c09	d0 1d		bne $019c28			bne 	SequenceExit
.019c0b	ca		dex				dex 								; go back - will bump into $FE eventually.
.019c0c	80 f6		bra $019c04			bra 	_TSRExit
.019c0e					TokeniseQuotedString:
.019c0e	86 10		stx $10				stx 	zTemp1 						; save position
.019c10	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019c12	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c15	e8		inx				inx 								; bump, and one space for the count.
.019c16	e8		inx				inx
.019c17					_TSQCopy:
.019c17	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c19	c9 20		cmp #$20			cmp 	#" "
.019c1b	90 0b		bcc $019c28			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.019c1d	c8		iny				iny
.019c1e	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.019c20	f0 06		beq $019c28			beq 	SequenceExit
.019c22	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.019c25	e8		inx				inx
.019c26	80 ef		bra $019c17			bra 	_TSQCopy
.019c28					SequenceExit:
.019c28	8a		txa				txa 								; current position
.019c29	38		sec				sec 								; subtract start.
.019c2a	e5 10		sbc $10				sbc 	zTemp1
.019c2c	da		phx				phx 								; copy that in
.019c2d	a6 10		ldx $10				ldx 	zTemp1
.019c2f	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.019c32	fa		plx				plx
.019c33	60		rts				rts
.019c34					TokeniseDecimalString:
.019c34	86 10		stx $10				stx 	zTemp1 						; save position
.019c36	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.019c38	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c3b	e8		inx				inx 								; bump, and one space for the count.
.019c3c	e8		inx				inx
.019c3d	20 5e 9c	jsr $019c5e			jsr 	_TDSCopyNumber 				; copy a number.
.019c40	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.019c42	20 d5 9b	jsr $019bd5			jsr 	TOKCapitalise
.019c45	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.019c47	d0 df		bne $019c28			bne 	SequenceExit 				; exit now.
.019c49	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.019c4c	e8		inx				inx
.019c4d	c8		iny				iny
.019c4e	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.019c50	c9 2d		cmp #$2d			cmp 	#"-"
.019c52	d0 05		bne $019c59			bne 	_TDSNoMinusExponent
.019c54	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.019c57	e8		inx				inx
.019c58	c8		iny				iny
.019c59					_TDSNoMinusExponent:
.019c59	20 5e 9c	jsr $019c5e			jsr 	_TDSCopyNumber 				; do the exponent
.019c5c	80 ca		bra $019c28			bra 	SequenceExit
.019c5e					_TDSCopyNumber:
.019c5e	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c60	c9 30		cmp #$30			cmp 	#"0"
.019c62	90 0b		bcc $019c6f			bcc 	_TDSCNExit
.019c64	c9 3a		cmp #$3a			cmp 	#"9"+1
.019c66	b0 07		bcs $019c6f			bcs 	_TDSCNExit
.019c68	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c6b	e8		inx				inx
.019c6c	c8		iny				iny
.019c6d	80 ef		bra $019c5e			bra 	_TDSCopyNumber
.019c6f					_TDSCNExit:
.019c6f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.019c70					TokeniseConstant:
.019c70	da		phx				phx 								; save X
.019c71	a2 00		ldx #$00			ldx 	#0
.019c73	20 4e a2	jsr $01a24e			jsr 	IntFromStringY 				; get the integer out.
.019c76	b0 37		bcs $019caf			bcs 	_TCQ 						; should not happen.
.019c78	fa		plx				plx 								; restore X.
.019c79	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.019c7b	85 10		sta $10				sta 	zTemp1
.019c7d					_TCRotate:
.019c7d	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.019c7f	29 c0		and #$c0			and 	#$C0
.019c81	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.019c83	05 82		ora $82				ora 	XS_Mantissa+2
.019c85	05 83		ora $83				ora 	XS_Mantissa+3
.019c87	f0 16		beq $019c9f			beq 	_TCDone						; if so, at the bottom.
.019c89	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.019c8b	29 3f		and #$3f			and 	#$3F
.019c8d	48		pha				pha
.019c8e	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.019c90	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.019c92					_TCShiftRight:
.019c92	46 83		lsr $83				lsr 	XS_Mantissa+3
.019c94	66 82		ror $82				ror 	XS_Mantissa+2
.019c96	66 81		ror $81				ror 	XS_Mantissa+1
.019c98	66 80		ror $80				ror 	XS_Mantissa+0
.019c9a	3a		dec a				dec 	a
.019c9b	d0 f5		bne $019c92			bne 	_TCShiftRight
.019c9d	80 de		bra $019c7d			bra 	_TCRotate 					; and go round again.
.019c9f	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.019ca1					_TCWrite:
.019ca1	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.019ca3	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019ca6	e8		inx				inx
.019ca7	c6 10		dec $10				dec 	zTemp1 						; done all of them
.019ca9	30 03		bmi $019cae			bmi 	_TCExit 					; no , more to pop
.019cab	68		pla				pla
.019cac	80 f3		bra $019ca1			bra 	_TCWrite 					; until everything's off.
.019cae					_TCExit:
.019cae	60		rts				rts
.019caf					_TCQ:
.019caf	20 83 85	jsr $018583			jsr ERR_Handler
>019cb2	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019cb5					VariableFind:
.019cb5	20 20 9d	jsr $019d20			jsr 	VariableExtract 		; find out all about it ....
.019cb8	20 b9 9f	jsr $019fb9			jsr 	VariableLocate 			; does it already exist ?
.019cbb	b0 03		bcs $019cc0			bcs 	_VFExists 				; if so, use that.
.019cbd	20 ac 9d	jsr $019dac			jsr 	VariableCreate 			; otherwise create it.
.019cc0					_VFExists:
.019cc0	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.019cc2	29 01		and #$01			and 	#1
.019cc4	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019cc6	d0 28		bne $019cf0			bne 	_VFSingleElement
.019cc8					_VFNextIndex:
.019cc8	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019cca	48		pha				pha
.019ccb	a5 25		lda $25				lda 	zVarDataPtr+1
.019ccd	48		pha				pha
.019cce	a5 26		lda $26				lda 	zVarType
.019cd0	48		pha				pha
.019cd1	20 a5 93	jsr $0193a5			jsr 	EvaluateIntegerX 		; calculate the index.
.019cd4	68		pla				pla 							; restore and index.
.019cd5	85 26		sta $26				sta 	zVarType
.019cd7	68		pla				pla
.019cd8	85 25		sta $25				sta 	zVarDataPtr+1
.019cda	68		pla				pla
.019cdb	85 24		sta $24				sta 	zVarDataPtr
.019cdd	20 37 9e	jsr $019e37			jsr 	ArrayIndexFollow 		; do the index.
.019ce0	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.019ce2	29 01		and #$01			and 	#1
.019ce4	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019ce6	d0 05		bne $019ced			bne 	_VFArrayDone 			; if so then exit.
.019ce8	20 01 9a	jsr $019a01			jsr 	CheckNextComma 			; comma should follow
.019ceb	80 db		bra $019cc8			bra 	_VFNextIndex
.019ced					_VFArrayDone:
.019ced	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 		; check closing right bracket.
.019cf0					_VFSingleElement:
.019cf0	60		rts				rts
.019cf1					VariableClear:
.019cf1	48		pha				pha 							; save registers
.019cf2	da		phx				phx
.019cf3	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019cf5	8a		txa				txa
.019cf6	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019cf9	e8		inx				inx
.019cfa	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019cfc	d0 f8		bne $019cf6			bne 	_VCLoop
.019cfe	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019d00	8d 02 03	sta $0302			sta 	VarMemPtr
.019d03	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019d05	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019d08	fa		plx				plx 							; restore registers
.019d09	68		pla				pla
.019d0a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019d0b					VariableNameError:
.019d0b	20 83 85	jsr $018583			jsr ERR_Handler
>019d0e	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019d16	61 62 6c 65 20 4e 61 6d 65 00
.019d20					VariableExtract:
.019d20	da		phx				phx 							; save X.
.019d21	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019d23	8d 95 03	sta $0395			sta 	Var_Type
.019d26	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019d29	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d2b	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019d2d	f0 dc		beq $019d0b			beq 	VariableNameError
.019d2f	c9 1b		cmp #$1b			cmp 	#26+1
.019d31	b0 d8		bcs $019d0b			bcs 	VariableNameError
.019d33	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019d35					_VECopyBuffer:
.019d35	e8		inx				inx
.019d36	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019d38	f0 d1		beq $019d0b			beq 	VariableNameError
.019d3a	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019d3d	18		clc				clc  							; update the hash value for it.
.019d3e	6d 96 03	adc $0396			adc 	Var_Hash
.019d41	8d 96 03	sta $0396			sta 	Var_Hash
.019d44	c8		iny				iny
.019d45	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d47	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019d49	f0 0e		beq $019d59			beq 	_VECopyEnd
.019d4b	30 0c		bmi $019d59			bmi 	_VECopyEnd
.019d4d	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019d4f	90 e4		bcc $019d35			bcc 	_VECopyBuffer
.019d51	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019d53	90 04		bcc $019d59			bcc 	_VECopyEnd
.019d55	c9 3a		cmp #$3a			cmp 	#"9"+1
.019d57	90 dc		bcc $019d35			bcc 	_VECopyBuffer
.019d59					_VECopyEnd:
.019d59	c8		iny				iny
.019d5a	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019d5c	90 04		bcc $019d62			bcc 	_VEDefaultRequired
.019d5e	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019d60	90 0b		bcc $019d6d			bcc 	_VEHaveType
.019d62					_VEDefaultRequired:
.019d62	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019d64	f0 04		beq $019d6a			beq 	_VESetType 				; default set above.
.019d66	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019d69	88		dey				dey
.019d6a					_VESetType:
.019d6a	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019d6d					_VEHaveType:
.019d6d	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019d70	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019d73	09 80		ora #$80			ora 	#$80
.019d75	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019d78	e8		inx				inx 							; offset 3 => length 4.
.019d79	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019d7c	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019d7f	38		sec				sec
.019d80	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019d82	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019d83	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019d84	0a		asl a				asl 	a
.019d85	0a		asl a				asl 	a
.019d86	8d 98 03	sta $0398			sta 	Var_HashAddress
.019d89	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019d8c	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019d8e	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019d8f	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019d92	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019d94	8d 98 03	sta $0398			sta 	Var_HashAddress
.019d97	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019d99	ad 95 03	lda $0395			lda 	Var_Type
.019d9c	c9 b9		cmp #$b9			cmp 	#token_Hash
.019d9e	f0 07		beq $019da7			beq 	_VEHaveSize
.019da0	ca		dex				dex
.019da1	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019da3	f0 02		beq $019da7			beq 	_VEHaveSize
.019da5	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019da7					_VEHaveSize:
.019da7	8e 99 03	stx $0399			stx 	Var_DataSize
.019daa	fa		plx				plx
.019dab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019dac					VariableCreate:
.019dac	da		phx				phx
.019dad	5a		phy				phy
.019dae	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019db1	85 10		sta $10				sta 	zTemp1
.019db3	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019db6	85 11		sta $11				sta 	zTemp1+1
.019db8	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019dbb	18		clc				clc
.019dbc	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019dbf	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019dc1	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019dc4	8d 02 03	sta $0302			sta 	VarMemPtr
.019dc7	90 03		bcc $019dcc			bcc 	_VCNoCarry
.019dc9	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019dcc					_VCNoCarry:
.019dcc	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019dcf	85 12		sta $12				sta 	zTemp2
.019dd1	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019dd3	85 13		sta $13				sta 	zTemp2+1
.019dd5	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019dd7	b1 12		lda ($12),y			lda 	(zTemp2),y
.019dd9	91 10		sta ($10),y			sta 	(zTemp1),y
.019ddb	c8		iny				iny
.019ddc	b1 12		lda ($12),y			lda 	(zTemp2),y
.019dde	91 10		sta ($10),y			sta 	(zTemp1),y
.019de0	c8		iny				iny
.019de1	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019de4	91 10		sta ($10),y			sta 	(zTemp1),y
.019de6	c8		iny				iny
.019de7	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019de9					_VCCopyName:
.019de9	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019dec	91 10		sta ($10),y			sta 	(zTemp1),y
.019dee	e8		inx				inx
.019def	c8		iny				iny
.019df0	ec 97 03	cpx $0397			cpx 	Var_Length
.019df3	d0 f4		bne $019de9			bne 	_VCCopyName
.019df5	5a		phy				phy 								; save the data offset.
.019df6	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019df9	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019dfb					_VCClearData:
.019dfb	91 10		sta ($10),y			sta 	(zTemp1),y
.019dfd	c8		iny				iny
.019dfe	ca		dex				dex
.019dff	d0 fa		bne $019dfb			bne 	_VCClearData
.019e01	68		pla				pla 								; offset to the data
.019e02	18		clc				clc
.019e03	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019e05	85 24		sta $24				sta 	zVarDataPtr
.019e07	a5 11		lda $11				lda 	zTemp1+1
.019e09	69 00		adc #$00			adc 	#0
.019e0b	85 25		sta $25				sta 	zVarDataPtr+1
.019e0d	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019e10	85 26		sta $26				sta 	zVarType
.019e12	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019e14	a0 00		ldy #$00			ldy 	#0
.019e16	91 12		sta ($12),y			sta 	(zTemp2),y
.019e18	c8		iny				iny
.019e19	a5 11		lda $11				lda 	zTemp1+1
.019e1b	91 12		sta ($12),y			sta 	(zTemp2),y
.019e1d	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019e20	29 01		and #$01			and 	#1
.019e22	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019e24	d0 0e		bne $019e34			bne 	_VCNotArray
.019e26	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019e28	20 ce 9e	jsr $019ece			jsr 	ArrayCreate
.019e2b	5a		phy				phy 								; save YA at zVarDataPtr
.019e2c	a0 00		ldy #$00			ldy 	#0
.019e2e	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e30	c8		iny				iny
.019e31	68		pla				pla
.019e32	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e34					_VCNotArray:
.019e34	7a		ply				ply
.019e35	fa		plx				plx
.019e36	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019e37					ArrayIndexFollow:
.019e37	5a		phy				phy
.019e38	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019e3a	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019e3c	48		pha				pha
.019e3d	c8		iny				iny
.019e3e	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e40	85 25		sta $25				sta 	zVarDataPtr+1
.019e42	68		pla				pla
.019e43	85 24		sta $24				sta 	zVarDataPtr
.019e45	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019e47	29 80		and #$80			and 	#$80 						; must be zero.
.019e49	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e4b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e4d	d0 59		bne $019ea8			bne 	_AIFError
.019e4f	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019e51	18		clc				clc
.019e52	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e54	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e56	c8		iny				iny
.019e57	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e59	08		php				php 								; clear bit 7 retaining borrow.
.019e5a	29 7f		and #$7f			and 	#$7F
.019e5c	28		plp				plp
.019e5d	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019e5f	90 47		bcc $019ea8			bcc 	_AIFError 					; eror if size-current < 0
.019e61	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019e63	0a		asl a				asl 	a 							; (e.g. index * 2)
.019e64	85 10		sta $10				sta 	zTemp1
.019e66	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e68	2a		rol a				rol 	a
.019e69	85 11		sta $11				sta 	zTemp1+1
.019e6b	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019e6d	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019e6f	30 1d		bmi $019e8e			bmi 	_AIFCalculate
.019e71	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.019e73	a5 26		lda $26				lda 	zVarType 					; check that type
.019e75	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019e77	f0 15		beq $019e8e			beq 	_AIFCalculate
.019e79	06 10		asl $10				asl 	zTemp1			 			; double the index
.019e7b	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019e7d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019e7f	f0 0d		beq $019e8e			beq 	_AIFCalculate
.019e81	18		clc				clc 								; add the original mantissa in again
.019e82	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019e84	65 10		adc $10				adc 	zTemp1
.019e86	85 10		sta $10				sta 	zTemp1
.019e88	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e8a	65 11		adc $11				adc 	zTemp1+1
.019e8c	85 11		sta $11				sta 	zTemp1+1
.019e8e					_AIFCalculate:
.019e8e	18		clc				clc 								; add index x 2,4 or 5 to base
.019e8f	a5 24		lda $24				lda 	zVarDataPtr
.019e91	65 10		adc $10				adc 	zTemp1
.019e93	85 24		sta $24				sta 	zVarDataPtr
.019e95	a5 25		lda $25				lda 	zVarDataPtr+1
.019e97	65 11		adc $11				adc 	zTemp1+1
.019e99	85 25		sta $25				sta 	zVarDataPtr+1
.019e9b	18		clc				clc 								; add 2 more for the length prefix.
.019e9c	a5 24		lda $24				lda 	zVarDataPtr
.019e9e	69 02		adc #$02			adc 	#2
.019ea0	85 24		sta $24				sta 	zVarDataPtr
.019ea2	90 02		bcc $019ea6			bcc 	_AIFNoBump
.019ea4	e6 25		inc $25				inc 	zVarDataPtr+1
.019ea6					_AIFNoBump:
.019ea6	7a		ply				ply
.019ea7	60		rts				rts
.019ea8					_AIFError:
.019ea8	20 83 85	jsr $018583			jsr ERR_Handler
>019eab	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019eb3	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019ebb					ArrayResetDefault:
.019ebb	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019ebd	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019ec0	a9 00		lda #$00			lda 	#0
.019ec2	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019ec5	a9 ff		lda #$ff			lda 	#$FF
.019ec7	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019eca	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019ecd	60		rts				rts
.019ece					ArrayCreate:
.019ece	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019ed1	0a		asl a				asl 	a
.019ed2	85 10		sta $10				sta 	zTemp1
.019ed4	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019ed7	2a		rol a				rol 	a
.019ed8	85 11		sta $11				sta 	zTemp1+1
.019eda	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019edd	10 22		bpl $019f01			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019edf	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019ee2	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019ee4	f0 1b		beq $019f01			beq 	_ACSized
.019ee6	06 10		asl $10				asl 	zTemp1 						; double again
.019ee8	26 11		rol $11				rol 	zTemp1+1
.019eea	b0 6f		bcs $019f5b			bcs 	ArrayIndexError 			; too large.
.019eec	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019eee	f0 11		beq $019f01			beq 	_ACSized
.019ef0	18		clc				clc 								; add original value x 5 for reals.
.019ef1	a5 10		lda $10				lda 	zTemp1
.019ef3	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019ef6	85 10		sta $10				sta 	zTemp1
.019ef8	a5 11		lda $11				lda 	zTemp1+1
.019efa	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019efd	85 11		sta $11				sta 	zTemp1+1
.019eff	b0 5a		bcs $019f5b			bcs 	ArrayIndexError
.019f01					_ACSized:
.019f01	18		clc				clc
.019f02	a5 10		lda $10				lda 	zTemp1
.019f04	69 02		adc #$02			adc 	#2
.019f06	85 10		sta $10				sta 	zTemp1
.019f08	90 04		bcc $019f0e			bcc 	_ACNoBump
.019f0a	e6 10		inc $10				inc 	zTemp1
.019f0c	f0 4d		beq $019f5b			beq 	ArrayIndexError
.019f0e					_ACNoBump:
.019f0e	18		clc				clc
.019f0f	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019f12	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019f14	85 14		sta $14				sta 	zTemp3
.019f16	65 10		adc $10				adc 	zTemp1
.019f18	8d 02 03	sta $0302			sta 	VarMemPtr
.019f1b	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019f1e	85 13		sta $13				sta 	zTemp2+1
.019f20	85 15		sta $15				sta 	zTemp3+1
.019f22	65 11		adc $11				adc 	zTemp1+1
.019f24	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019f27	85 11		sta $11				sta 	zTemp1+1
.019f29	b0 30		bcs $019f5b			bcs 	ArrayIndexError
.019f2b	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019f2d					_ACClear:
.019f2d	98		tya				tya
.019f2e	91 12		sta ($12),y			sta 	(zTemp2),y
.019f30	e6 12		inc $12				inc 	zTemp2
.019f32	d0 02		bne $019f36			bne 	_ACCBump
.019f34	e6 13		inc $13				inc 	zTemp2+1
.019f36					_ACCBump:
.019f36	a5 12		lda $12				lda 	zTemp2
.019f38	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019f3b	d0 f0		bne $019f2d			bne 	_ACClear
.019f3d	a5 13		lda $13				lda 	zTemp2+1
.019f3f	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019f42	d0 e9		bne $019f2d			bne 	_ACClear
.019f44	a0 00		ldy #$00			ldy 	#0
.019f46	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019f49	91 14		sta ($14),y			sta 	(zTemp3),y
.019f4b	c8		iny				iny
.019f4c	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f4f	91 14		sta ($14),y			sta 	(zTemp3),y
.019f51	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019f54	10 18		bpl $019f6e			bpl 	ACCFillRecursive
.019f56	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019f58	a5 14		lda $14				lda 	zTemp3
.019f5a	60		rts				rts
.019f5b					ArrayIndexError:
.019f5b	20 83 85	jsr $018583			jsr ERR_Handler
>019f5e	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019f66	79 20 69 6e 64 65 78 00
.019f6e					ACCFillRecursive:
.019f6e	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019f70	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019f72	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019f74	c8		iny				iny
.019f75	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019f77	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019f79	91 14		sta ($14),y			sta 	(zTemp3),y
.019f7b	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019f7d	48		pha				pha
.019f7e	a5 15		lda $15				lda 	zTemp3+1
.019f80	48		pha				pha
.019f81					_ACCFillLoop:
.019f81	18		clc				clc
.019f82	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019f84	69 02		adc #$02			adc 	#2
.019f86	85 14		sta $14				sta 	zTemp3
.019f88	90 02		bcc $019f8c			bcc 	_ACCSkip2
.019f8a	e6 15		inc $15				inc 	zTemp3+1
.019f8c					_ACCSkip2:
.019f8c	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019f8e	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019f90	c8		iny				iny
.019f91	11 14		ora ($14),y			ora 	(zTemp3),y
.019f93	d0 21		bne $019fb6			bne 	_ACCExit
.019f95	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019f97	48		pha				pha
.019f98	a5 15		lda $15				lda 	zTemp3+1
.019f9a	48		pha				pha
.019f9b	e8		inx				inx
.019f9c	e8		inx				inx
.019f9d	20 ce 9e	jsr $019ece			jsr 	ArrayCreate 				; create array recursively.
.019fa0	ca		dex				dex
.019fa1	ca		dex				dex
.019fa2	85 12		sta $12				sta 	zTemp2 						; save A
.019fa4	68		pla				pla
.019fa5	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019fa7	68		pla				pla
.019fa8	85 14		sta $14				sta 	zTemp3
.019faa	98		tya				tya 								; write high bye from Y
.019fab	a0 01		ldy #$01			ldy 	#1
.019fad	91 14		sta ($14),y			sta 	(zTemp3),y
.019faf	88		dey				dey 								; write low byte out.
.019fb0	a5 12		lda $12				lda 	zTemp2
.019fb2	91 14		sta ($14),y			sta 	(zTemp3),y
.019fb4	80 cb		bra $019f81			bra 	_ACCFillLoop 				; and try again.
.019fb6					_ACCExit:
.019fb6	7a		ply				ply 								; restore the original address
.019fb7	68		pla				pla
.019fb8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019fb9					VariableLocate:
.019fb9	da		phx				phx
.019fba	5a		phy				phy
.019fbb	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019fbe	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019fc0	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019fc2	85 13		sta $13				sta 	zTemp2+1
.019fc4	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019fc6	b1 12		lda ($12),y			lda 	(zTemp2),y
.019fc8	aa		tax				tax
.019fc9	c8		iny				iny
.019fca	b1 12		lda ($12),y			lda 	(zTemp2),y
.019fcc	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019fce	86 12		stx $12				stx 	zTemp2
.019fd0	05 12		ora $12				ora 	zTemp2 						; got zero
.019fd2	18		clc				clc
.019fd3	f0 25		beq $019ffa			beq 	_VLExit 					; if so, then fail as end of chain.
.019fd5	c8		iny				iny 								; point to hash (offset + 2)
.019fd6	b1 12		lda ($12),y			lda 	(zTemp2),y
.019fd8	cd 96 03	cmp $0396			cmp 	Var_Hash
.019fdb	d0 e7		bne $019fc4			bne 	_VLNext 					; try next if different.
.019fdd					_VLCompare:
.019fdd	c8		iny				iny 								; next character
.019fde	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019fe0	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019fe3	d0 df		bne $019fc4			bne 	_VLNext 					; fail if different, try next.
.019fe5	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019fe6	90 f5		bcc $019fdd			bcc 	_VLCompare
.019fe8	98		tya				tya
.019fe9	38		sec				sec 								; add 1 as Y points to last character
.019fea	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019fec	85 24		sta $24				sta 	zVarDataPtr
.019fee	a5 13		lda $13				lda 	zTemp2+1
.019ff0	69 00		adc #$00			adc 	#0
.019ff2	85 25		sta $25				sta 	zVarDataPtr+1
.019ff4	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019ff7	85 26		sta $26				sta 	zVarType
.019ff9	38		sec				sec 								; return CS
.019ffa	7a		ply		_VLExit:ply
.019ffb	fa		plx				plx
.019ffc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019ffd					VariableGet:
.019ffd	5a		phy				phy
.019ffe	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01a000	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a002	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a004	c8		iny				iny
.01a005	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a007	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a009	c8		iny				iny
.01a00a	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.01a00c	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a00e	f0 2c		beq $01a03c			beq 	_VGString
.01a010	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01a012	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a014	c8		iny				iny
.01a015	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a017	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a019	c8		iny				iny
.01a01a	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01a01c	95 85		sta $85,x			sta 	XS_Type,x
.01a01e	a5 26		lda $26				lda 	zVarType
.01a020	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01a022	f0 28		beq $01a04c			beq 	_VGExit
.01a024	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01a026	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01a028	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01a02a	95 84		sta $84,x			sta 	XS_Exponent,x
.01a02c	f0 1e		beq $01a04c			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01a02e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01a030	48		pha				pha
.01a031	29 80		and #$80			and 	#$80
.01a033	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.01a035	68		pla				pla
.01a036	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.01a038	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01a03a	80 10		bra $01a04c			bra 	_VGExit
.01a03c					_VGString:
.01a03c	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01a03e	95 85		sta $85,x			sta 	XS_Type,x
.01a040	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.01a042	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a044	d0 06		bne $01a04c			bne 	_VGExit 					; if not, exit.
.01a046	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.01a048	a9 27		lda #$27			lda 	#zNullString
.01a04a	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01a04c					_VGExit:
.01a04c	7a		ply				ply
.01a04d	60		rts				rts
.01a04e					VariableSet:
.01a04e	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01a050	29 02		and #$02			and 	#2 							; if so, it has to be
.01a052	d0 4b		bne $01a09f			bne 	_VSString
.01a054	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.01a056	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a058	f0 42		beq $01a09c			beq 	_VSBadType
.01a05a	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01a05c	f0 05		beq $01a063			beq 	_VSMakeInt
.01a05e	20 c6 a5	jsr $01a5c6			jsr 	FPUToFloat
.01a061	80 03		bra $01a066			bra 	_VSCopy
.01a063					_VSMakeInt:
.01a063	20 12 a6	jsr $01a612			jsr 	FPUToInteger
.01a066					_VSCopy:
.01a066	5a		phy				phy
.01a067	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01a069	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a06b	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a06d	c8		iny				iny
.01a06e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a070	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a072	c8		iny				iny
.01a073	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a075	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a077	c8		iny				iny
.01a078	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a07a	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a07c	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.01a07e	c9 bb		cmp #$bb			cmp 	#token_Percent
.01a080	f0 18		beq $01a09a			beq 	_VSExit
.01a082	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01a084	0a		asl a				asl 	a
.01a085	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01a087	08		php				php
.01a088	0a		asl a				asl 	a
.01a089	28		plp				plp
.01a08a	6a		ror a				ror 	a
.01a08b	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a08d	c8		iny				iny
.01a08e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.01a090	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a092	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.01a094	50 04		bvc $01a09a			bvc 	_VSExit
.01a096	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.01a098	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a09a					_VSExit:
.01a09a	7a		ply				ply
.01a09b	60		rts				rts
.01a09c					_VSBadType:
.01a09c	4c 64 85	jmp $018564			jmp 	TypeError
.01a09f					_VSString:
.01a09f	a5 26		lda $26				lda 	zVarType 					; type must be $
.01a0a1	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0a3	d0 f7		bne $01a09c			bne 	_VSBadType
.01a0a5	da		phx				phx
.01a0a6	5a		phy				phy
.01a0a7	20 09 9a	jsr $019a09			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01a0aa	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01a0ac	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0ae	88		dey				dey 								; save low byte
.01a0af	8a		txa				txa
.01a0b0	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0b2	7a		ply				ply 								; and exit.
.01a0b3	fa		plx				plx
.01a0b4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01a0b5					MulInteger32:
.01a0b5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01a0b7	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01a0b9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0bb	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01a0bd	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0bf	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01a0c1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0c3	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.01a0c5	a9 00		lda #$00			lda 	#0
.01a0c7	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.01a0c9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0cb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0cd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0cf					_BFMMultiply:
.01a0cf	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01a0d1	29 01		and #$01			and 	#1
.01a0d3	f0 03		beq $01a0d8			beq 	_BFMNoAdd
.01a0d5	20 45 95	jsr $019545			jsr 	AddInteger32 					; co-opt this code
.01a0d8					_BFMNoAdd:
.01a0d8	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01a0da	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01a0dc	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01a0de	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01a0e0	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01a0e2	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.01a0e4	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01a0e6	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01a0e8	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01a0ea	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01a0ec	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01a0ee	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01a0f0	d0 dd		bne $01a0cf			bne 	_BFMMultiply
.01a0f2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01a0f3					DivInteger32:
.01a0f3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.01a0f5	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01a0f7	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a0f9	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a0fb	d0 14		bne $01a111			bne 	_BFDOkay
.01a0fd	20 83 85	jsr $018583			jsr ERR_Handler
>01a100	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01a108	20 62 79 20 5a 65 72 6f 00
.01a111					_BFDOkay:
.01a111	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01a113	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01a115	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01a117	85 1e		sta $1e				sta 	zLTemp1+2
.01a119	85 1f		sta $1f				sta 	zLTemp1+3
.01a11b	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01a11e	20 75 a1	jsr $01a175			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01a121	da		phx				phx
.01a122	e8		inx				inx
.01a123	e8		inx				inx
.01a124	e8		inx				inx
.01a125	e8		inx				inx
.01a126	e8		inx				inx
.01a127	e8		inx				inx
.01a128	20 75 a1	jsr $01a175			jsr 	CheckIntegerNegate
.01a12b	fa		plx				plx
.01a12c	5a		phy				phy 								; Y is the counter
.01a12d	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01a12f					_BFDLoop:
.01a12f	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01a131	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a133	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a135	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a137	26 1c		rol $1c				rol 	zLTemp1
.01a139	26 1d		rol $1d				rol 	zLTemp1+1
.01a13b	26 1e		rol $1e				rol 	zLTemp1+2
.01a13d	26 1f		rol $1f				rol 	zLTemp1+3
.01a13f	38		sec				sec
.01a140	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01a142	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a144	48		pha				pha
.01a145	a5 1d		lda $1d				lda 	zLTemp1+1
.01a147	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a149	48		pha				pha
.01a14a	a5 1e		lda $1e				lda 	zLTemp1+2
.01a14c	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a14e	48		pha				pha
.01a14f	a5 1f		lda $1f				lda 	zLTemp1+3
.01a151	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a153	90 13		bcc $01a168			bcc 	_BFDNoAdd
.01a155	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.01a157	68		pla				pla
.01a158	85 1e		sta $1e				sta 	zLTemp1+2
.01a15a	68		pla				pla
.01a15b	85 1d		sta $1d				sta 	zLTemp1+1
.01a15d	68		pla				pla
.01a15e	85 1c		sta $1c				sta 	zLTemp1+0
.01a160	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01a162	09 01		ora #$01			ora 	#1
.01a164	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a166	80 03		bra $01a16b			bra 	_BFDNext
.01a168					_BFDNoAdd:
.01a168	68		pla				pla 								; Throw away the intermediate calculations
.01a169	68		pla				pla
.01a16a	68		pla				pla
.01a16b					_BFDNext:
.01a16b	88		dey				dey
.01a16c	d0 c1		bne $01a12f			bne 	_BFDLoop
.01a16e	7a		ply				ply 								; restore Y
.01a16f	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.01a172	b0 06		bcs $01a17a			bcs		IntegerNegateAlways 		; negate the result
.01a174	60		rts				rts
.01a175					CheckIntegerNegate:
.01a175	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.01a177	30 01		bmi $01a17a			bmi 	IntegerNegateAlways 		; if so negate it
.01a179	60		rts				rts
.01a17a					IntegerNegateAlways:
.01a17a	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.01a17d	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.01a17e	a9 00		lda #$00			lda 	#0
.01a180	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a182	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a184	a9 00		lda #$00			lda 	#0
.01a186	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a188	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a18a	a9 00		lda #$00			lda 	#0
.01a18c	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a18e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a190	a9 00		lda #$00			lda 	#0
.01a192	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a194	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a196	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01a197					INTToString:
.01a197	48		pha				pha
.01a198	5a		phy				phy
.01a199	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01a19b	10 08		bpl $01a1a5			bpl 		_ITSNotMinus
.01a19d	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a19f	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter
.01a1a2	20 7a a1	jsr $01a17a			jsr 		IntegerNegateAlways 	; negate the number.
.01a1a5					_ITSNotMinus:
.01a1a5	a9 00		lda #$00			lda 		#0
.01a1a7	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01a1aa	8a		txa				txa 								; use Y for the mantissa index.
.01a1ab	a8		tay				tay
.01a1ac	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01a1ae					_ITSNextSubtractor:
.01a1ae	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01a1b0	8d 9b 03	sta $039b			sta 		NumConvCount
.01a1b3					_ITSSubtract:
.01a1b3	38		sec				sec
.01a1b4	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01a1b7	ff 15 a2 01	sbc $01a215,x			sbc 		_ITSSubtractors+0,x
.01a1bb	48		pha				pha
.01a1bc	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01a1bf	ff 16 a2 01	sbc $01a216,x			sbc 		_ITSSubtractors+1,x
.01a1c3	48		pha				pha
.01a1c4	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01a1c7	ff 17 a2 01	sbc $01a217,x			sbc 		_ITSSubtractors+2,x
.01a1cb	48		pha				pha
.01a1cc	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01a1cf	ff 18 a2 01	sbc $01a218,x			sbc 		_ITSSubtractors+3,x
.01a1d3	90 14		bcc $01a1e9			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01a1d5	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01a1d8	68		pla				pla
.01a1d9	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01a1dc	68		pla				pla
.01a1dd	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01a1e0	68		pla				pla
.01a1e1	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.01a1e4	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.01a1e7	80 ca		bra $01a1b3			bra 		_ITSSubtract 			; go round again.
.01a1e9					_ITSCantSubtract:
.01a1e9	68		pla				pla 								; throw away interim answers
.01a1ea	68		pla				pla
.01a1eb	68		pla				pla
.01a1ec	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01a1ef	c9 30		cmp #$30			cmp 		#"0"
.01a1f1	d0 05		bne $01a1f8			bne 		_ITSOutputDigit
.01a1f3	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01a1f6	10 09		bpl $01a201			bpl	 		_ITSGoNextSubtractor
.01a1f8					_ITSOutputDigit:
.01a1f8	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.01a1fb	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01a1fe	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter 		; output it.
.01a201					_ITSGoNextSubtractor:
.01a201	e8		inx				inx 								; next dword
.01a202	e8		inx				inx
.01a203	e8		inx				inx
.01a204	e8		inx				inx
.01a205	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01a207	d0 a5		bne $01a1ae			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01a209	98		tya				tya 								; X is back as the mantissa index
.01a20a	aa		tax				tax
.01a20b	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01a20d	09 30		ora #$30			ora 		#"0"
.01a20f	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter
.01a212	7a		ply				ply 								; and exit
.01a213	68		pla				pla
.01a214	60		rts				rts
.01a215					_ITSSubtractors:
>01a215	00 ca 9a 3b					.dword 		1000000000
>01a219	00 e1 f5 05					.dword 		100000000
>01a21d	80 96 98 00					.dword 		10000000
>01a221	40 42 0f 00					.dword 		1000000
>01a225	a0 86 01 00					.dword 		100000
>01a229	10 27 00 00					.dword 		10000
>01a22d	e8 03 00 00					.dword 		1000
>01a231	64 00 00 00					.dword 		100
>01a235	0a 00 00 00					.dword 		10
.01a239					_ITSSubtractorsEnd:
.01a239					ITSOutputCharacter:
.01a239	48		pha				pha
.01a23a	da		phx				phx
.01a23b	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01a23e	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01a241	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01a243	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.01a246	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.01a249	fa		plx				plx
.01a24a	68		pla				pla
.01a24b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01a24c					IntFromString:
.01a24c	a0 00		ldy #$00			ldy 	#0
.01a24e					IntFromStringY:
.01a24e	a9 00		lda #$00			lda 	#0
.01a250	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.01a253	48		pha				pha
.01a254	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01a256	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a258	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a25a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a25c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a25e	a9 01		lda #$01			lda 	#1
.01a260	95 85		sta $85,x			sta 	XS_Type,x
.01a262					_IFSLoop:
.01a262	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.01a264	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01a266	90 4e		bcc $01a2b6			bcc 	_IFSExit
.01a268	c9 3a		cmp #$3a			cmp 	#"9"+1
.01a26a	b0 4a		bcs $01a2b6			bcs 	_IFSExit
.01a26c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01a26e	c9 0c		cmp #$0c			cmp 	#12
.01a270	b0 4e		bcs $01a2c0			bcs 	_IFSOverflow
.01a272	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a274	48		pha				pha
.01a275	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a277	48		pha				pha
.01a278	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a27a	48		pha				pha
.01a27b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a27d	48		pha				pha
.01a27e	20 d5 a2	jsr $01a2d5			jsr 	IFSX1ShiftLeft 				; double
.01a281	20 d5 a2	jsr $01a2d5			jsr 	IFSX1ShiftLeft 				; x 4
.01a284	18		clc				clc 								; add saved value x 5
.01a285	68		pla				pla
.01a286	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a288	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a28a	68		pla				pla
.01a28b	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a28d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a28f	68		pla				pla
.01a290	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a292	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a294	68		pla				pla
.01a295	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a297	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a299	20 d5 a2	jsr $01a2d5			jsr 	IFSX1ShiftLeft 				; x 10
.01a29c	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a29f	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.01a2a1	29 0f		and #$0f			and 	#15
.01a2a3	c8		iny				iny
.01a2a4	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2a6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2a8	90 b8		bcc $01a262			bcc 	_IFSLoop
.01a2aa	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a2ac	d0 b4		bne $01a262			bne 	_IFSLoop
.01a2ae	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a2b0	d0 b0		bne $01a262			bne 	_IFSLoop
.01a2b2	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a2b4	80 ac		bra $01a262			bra 	_IFSLoop
.01a2b6					_IFSExit:
.01a2b6	98		tya				tya 								; get offset
.01a2b7					_IFSOkay:
.01a2b7	38		sec				sec
.01a2b8	ad 9c 03	lda $039c			lda 	ExpTemp
.01a2bb	f0 01		beq $01a2be			beq 	_IFSSkipFail
.01a2bd	18		clc				clc
.01a2be					_IFSSkipFail:
.01a2be	68		pla				pla 								; and exit.
.01a2bf	60		rts				rts
.01a2c0					_IFSOverflow:
.01a2c0	20 83 85	jsr $018583			jsr 	ERR_Handler
>01a2c3	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a2cb	20 6f 76 65 72 66 6c 6f 77 00
.01a2d5					IFSX1ShiftLeft:
.01a2d5	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a2d7	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a2d9	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a2db	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a2dd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a2de					FPSubtract:
.01a2de	48		pha				pha
.01a2df	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a2e1	49 80		eor #$80			eor 	#$80
.01a2e3	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a2e5	68		pla				pla 								; --- and fall through ---
.01a2e6					FPAdd:
.01a2e6	48		pha				pha
.01a2e7	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a2e9	d0 05		bne $01a2f0			bne 	_FPA_NegativeLHS
.01a2eb	20 07 a3	jsr $01a307			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a2ee	68		pla				pla
.01a2ef	60		rts				rts
.01a2f0					_FPA_NegativeLHS:
.01a2f0	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a2f2	49 80		eor #$80			eor 	#$80
.01a2f4	95 85		sta $85,x			sta 	XS_Type,x
.01a2f6	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a2f8	49 80		eor #$80			eor 	#$80
.01a2fa	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a2fc	20 07 a3	jsr $01a307			jsr 	FPAdd_Worker 				; do the add calculation.
.01a2ff	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a301	49 80		eor #$80			eor 	#$80
.01a303	95 85		sta $85,x			sta 	XS_Type,x
.01a305	68		pla				pla
.01a306	60		rts				rts
.01a307					FPAdd_Worker:
.01a307	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a309	70 07		bvs $01a312			bvs 	_FPAWExit 					; no change.
.01a30b	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a30d	50 07		bvc $01a316			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a30f	20 84 a5	jsr $01a584			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a312					_FPAWExit:
.01a312	20 f3 a5	jsr $01a5f3			jsr 	FPUNormalise 				; normalise the result.
.01a315	60		rts				rts
.01a316					_FPAWMakeSame:
.01a316	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a318	38		sec				sec
.01a319	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a31b	f0 16		beq $01a333			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a31d	da		phx				phx 								; save X
.01a31e	90 06		bcc $01a326			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a320	e8		inx				inx
.01a321	e8		inx				inx
.01a322	e8		inx				inx
.01a323	e8		inx				inx
.01a324	e8		inx				inx
.01a325	e8		inx				inx
.01a326					_FPAWShiftA:
.01a326	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a328	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a32a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a32c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a32e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a330	fa		plx				plx 								; restore original X
.01a331	80 e3		bra $01a316			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a333					_FPAW_DoArithmetic:
.01a333	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a335	30 28		bmi $01a35f			bmi 	_FPAW_BNegative
.01a337	18		clc				clc
.01a338	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a33a	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a33c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a33e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a340	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a342	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a344	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a346	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a348	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a34a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a34c	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a34e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a350	90 c0		bcc $01a312			bcc 	_FPAWExit 					; no carry.
.01a352	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a354	38		sec				sec
.01a355	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a357	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a359	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a35b	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a35d	80 b3		bra $01a312			bra 	_FPAWExit
.01a35f					_FPAW_BNegative:
.01a35f	38		sec				sec
.01a360	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a362	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a364	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a366	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a368	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a36a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a36c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a36e	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a370	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a372	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a374	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a376	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a378	b0 09		bcs $01a383			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a37a	20 aa a5	jsr $01a5aa			jsr 	FPUNegateInteger			; negate the mantissa
.01a37d	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a37f	49 80		eor #$80			eor 	#$80
.01a381	95 85		sta $85,x			sta 	XS_Type,x
.01a383					_FPAWGoExit:
.01a383	4c 12 a3	jmp $01a312			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a386					FPD_IsDivZero:
.01a386	20 83 85	jsr $018583			jsr ERR_Handler
>01a389	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a391	20 62 79 20 7a 65 72 6f 00
.01a39a					FPDivide:
.01a39a	48		pha				pha
.01a39b	5a		phy				phy
.01a39c	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a39e	70 e6		bvs $01a386			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a3a0	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a3a2	f0 03		beq $01a3a7			beq 	_FPDCalculateExp
.01a3a4					_FPD_Exit:
.01a3a4	7a		ply				ply
.01a3a5	68		pla				pla
.01a3a6	60		rts				rts
.01a3a7					_FPDCalculateExp:
.01a3a7	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a3a9	49 ff		eor #$ff			eor 	#$FF
.01a3ab	1a		inc a				inc 	a
.01a3ac	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a3ae	20 7e a4	jsr $01a47e			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a3b1	18		clc				clc 	 							; add 1 to the resulting exponent
.01a3b2	69 01		adc #$01			adc 	#1
.01a3b4	b0 54		bcs $01a40a			bcs 	_FPD_Overflow 				; which can overflow.
.01a3b6	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3b8	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a3ba	85 1c		sta $1c				sta 	zLTemp1+0
.01a3bc	85 1d		sta $1d				sta 	zLTemp1+1
.01a3be	85 1e		sta $1e				sta 	zLTemp1+2
.01a3c0	85 1f		sta $1f				sta 	zLTemp1+3
.01a3c2	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a3c4					_FPD_Loop:
.01a3c4	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a3c5	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a3c7	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a3c9	48		pha				pha
.01a3ca	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a3cc	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a3ce	48		pha				pha
.01a3cf	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a3d1	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a3d3	48		pha				pha
.01a3d4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a3d6	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a3d8	90 13		bcc $01a3ed			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a3da	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a3dc	68		pla				pla
.01a3dd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3df	68		pla				pla
.01a3e0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3e2	68		pla				pla
.01a3e3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3e5	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.01a3e7	09 80		ora #$80			ora 	#$80
.01a3e9	85 1f		sta $1f				sta 	zLTemp1+3
.01a3eb	80 03		bra $01a3f0			bra 	_FPD_Rotates
.01a3ed					_FPD_NoSubtract:
.01a3ed	68		pla				pla 								; throw away unwanted results
.01a3ee	68		pla				pla
.01a3ef	68		pla				pla
.01a3f0					_FPD_Rotates:
.01a3f0	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a3f2	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a3f4	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a3f6	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a3f8	06 1c		asl $1c				asl 	zLTemp1 					; rotate result round left
.01a3fa	26 1d		rol $1d				rol 	zLTemp1+1
.01a3fc	26 1e		rol $1e				rol 	zLTemp1+2
.01a3fe	26 1f		rol $1f				rol 	zLTemp1+3
.01a400	90 02		bcc $01a404			bcc 	_FPD_NoCarry
.01a402	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.01a404					_FPD_NoCarry:
.01a404	88		dey				dey 								; do 32 times
.01a405	d0 bd		bne $01a3c4			bne 	_FPD_Loop
.01a407	4c 62 a4	jmp $01a462			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a40a					_FPD_Overflow:
.01a40a	4c 50 a6	jmp $01a650			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a40d					FPMultiply:
.01a40d	48		pha				pha
.01a40e	5a		phy				phy
.01a40f	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a411	70 07		bvs $01a41a			bvs 	_FPM_Exit
.01a413	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a415	50 06		bvc $01a41d			bvc 	_FPM_CalcExponent
.01a417	20 84 a5	jsr $01a584			jsr 	FPUCopyX2ToX1
.01a41a					_FPM_Exit:
.01a41a	7a		ply				ply
.01a41b	68		pla				pla
.01a41c	60		rts				rts
.01a41d					_FPM_CalcExponent:
.01a41d	18		clc				clc
.01a41e	20 7e a4	jsr $01a47e			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a421	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a423	a9 00		lda #$00			lda 	#0
.01a425	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a427	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a429	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a42b	85 1f		sta $1f				sta 	zLTemp1+3
.01a42d	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a42f					_FPM_Loop:
.01a42f	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a431	29 01		and #$01			and 	#1
.01a433	18		clc				clc 								; clear carry for the long rotate.
.01a434	f0 19		beq $01a44f			beq 	_FPM_NoAddition
.01a436	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a437	a5 1c		lda $1c				lda 	zLTemp1+0
.01a439	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a43b	85 1c		sta $1c				sta 	zLTemp1+0
.01a43d	a5 1d		lda $1d				lda 	zLTemp1+1
.01a43f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a441	85 1d		sta $1d				sta 	zLTemp1+1
.01a443	a5 1e		lda $1e				lda 	zLTemp1+2
.01a445	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a447	85 1e		sta $1e				sta 	zLTemp1+2
.01a449	a5 1f		lda $1f				lda 	zLTemp1+3
.01a44b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a44d	85 1f		sta $1f				sta 	zLTemp1+3
.01a44f					_FPM_NoAddition:
.01a44f	66 1f		ror $1f				ror 	3+zLTemp1
.01a451	66 1e		ror $1e				ror 	2+zLTemp1
.01a453	66 1d		ror $1d				ror 	1+zLTemp1
.01a455	66 1c		ror $1c				ror 	0+zLTemp1
.01a457	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a459	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a45b	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a45d	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a45f	88		dey				dey
.01a460	d0 cd		bne $01a42f			bne 	_FPM_Loop 					; do this 32 times.
.01a462					FPM_CopySignNormalize:
.01a462	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a464	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a466	a5 1d		lda $1d				lda 	zLTemp1+1
.01a468	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a46a	a5 1e		lda $1e				lda 	zLTemp1+2
.01a46c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a46e	a5 1f		lda $1f				lda 	zLTemp1+3
.01a470	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a472	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a474	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a476	95 85		sta $85,x			sta 	XS_Type,x
.01a478	20 f3 a5	jsr $01a5f3			jsr 	FPUNormalise 				; normalise and exit.
.01a47b	7a		ply				ply
.01a47c	68		pla				pla
.01a47d	60		rts				rts
.01a47e					FPCalculateExponent:
.01a47e	18		clc				clc
.01a47f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a481	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a483	b0 08		bcs $01a48d			bcs 	_FPCECarry 					; carry out ?
.01a485	10 03		bpl $01a48a			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a487	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a489	60		rts				rts
.01a48a					_FPCEExpZero:
.01a48a	a9 00		lda #$00			lda 	#0
.01a48c	60		rts				rts
.01a48d					_FPCECarry:
.01a48d	30 03		bmi $01a492			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a48f	09 80		ora #$80			ora 	#$80 						; put in right range
.01a491	60		rts				rts
.01a492					_FPCEOverflow:
.01a492	4c 50 a6	jmp $01a650			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a495					FPFractionalPart:
.01a495	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a497	38		sec				sec 								; this flag tells us to keep the fractional part
.01a498	30 0d		bmi $01a4a7			bmi 	FPGetPart
.01a49a	60		rts				rts
.01a49b					FPIntegerPart:
.01a49b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a49d	18		clc				clc 								; this flag says keep the integer part.
.01a49e	30 07		bmi $01a4a7			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a4a0	48		pha				pha
.01a4a1	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a4a3	95 85		sta $85,x			sta 	XS_Type,x
.01a4a5	68		pla				pla
.01a4a6	60		rts				rts
.01a4a7					FPGetPart:
.01a4a7	48		pha				pha
.01a4a8	5a		phy				phy 								; save Y
.01a4a9	08		php				php 								; save action
.01a4aa	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a4ac	70 59		bvs $01a507			bvs 	_FPGP_Exit 					; then do nothing.
.01a4ae	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a4b0	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a4b2	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a4b4	85 1e		sta $1e				sta 	zLTemp1+2
.01a4b6	85 1f		sta $1f				sta 	zLTemp1+3
.01a4b8	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a4ba	38		sec				sec
.01a4bb	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a4bd	f0 12		beq $01a4d1			beq 	_FPGP_NoShift 				; ... if any
.01a4bf	c9 20		cmp #$20			cmp 	#32
.01a4c1	90 02		bcc $01a4c5			bcc 	_FPGP_NotMax
.01a4c3	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a4c5					_FPGP_NotMax:
.01a4c5	a8		tay				tay 								; Y is the mask shift count.
.01a4c6					_FPGP_ShiftMask:
.01a4c6	46 1f		lsr $1f				lsr 	3+zLTemp1
.01a4c8	66 1e		ror $1e				ror 	2+zLTemp1
.01a4ca	66 1d		ror $1d				ror 	1+zLTemp1
.01a4cc	66 1c		ror $1c				ror 	0+zLTemp1
.01a4ce	88		dey				dey
.01a4cf	d0 f5		bne $01a4c6			bne 	_FPGP_ShiftMask
.01a4d1					_FPGP_NoShift:
.01a4d1	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a4d3	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a4d6					_FPGP_MaskLoop:
.01a4d6	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.01a4d9	28		plp				plp 								; if CC we keep the top part, so we
.01a4da	08		php				php		 							; flip the mask.
.01a4db	b0 02		bcs $01a4df			bcs		_FPGP_NoFlip
.01a4dd	49 ff		eor #$ff			eor 	#$FF
.01a4df					_FPGP_NoFlip:
.01a4df	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a4e1	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a4e3	e8		inx				inx
.01a4e4	c8		iny				iny
.01a4e5	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a4e7	d0 ed		bne $01a4d6			bne 	_FPGP_MaskLoop
.01a4e9	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a4ec	28		plp				plp
.01a4ed	08		php				php 								; get action flag on the stack
.01a4ee	90 04		bcc $01a4f4			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a4f0	a9 00		lda #$00			lda 	#0
.01a4f2	95 85		sta $85,x			sta 	XS_Type,x
.01a4f4					_FPGP_NotFractional:
.01a4f4	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a4f6	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a4f8	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a4fa	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a4fc	f0 05		beq $01a503			beq 	_FPGP_Zero 					; if zero, return zero
.01a4fe	20 f3 a5	jsr $01a5f3			jsr 	FPUNormalise
.01a501	80 04		bra $01a507			bra 	_FPGP_Exit 					; and exit
.01a503					_FPGP_Zero:
.01a503	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a505	95 85		sta $85,x			sta 	XS_Type,x
.01a507					_FPGP_Exit:
.01a507	68		pla				pla 								; throw saved action flag.
.01a508	7a		ply				ply
.01a509	68		pla				pla
.01a50a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a50b					FPCompare:
.01a50b	20 4c a5	jsr $01a54c			jsr 	FPFastCompare 				; fast compare try first
.01a50e	b0 3b		bcs $01a54b			bcs 	_FPCExit 					; that worked.
.01a510	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a512	48		pha				pha
.01a513	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a515	48		pha				pha
.01a516	20 de a2	jsr $01a2de			jsr 	FPSubtract 					; calculate X1-X2
.01a519	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a51b	70 2a		bvs $01a547			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a51d	68		pla				pla
.01a51e	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a521	68		pla				pla
.01a522	38		sec				sec
.01a523	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a526	70 14		bvs $01a53c			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a528	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a529	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a52b	b0 0f		bcs $01a53c			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a52d	38		sec				sec
.01a52e	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a531	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a533	b0 02		bcs $01a537			bcs 	_FPCNotRange 				; keep in range.
.01a535	a9 01		lda #$01			lda 	#1
.01a537					_FPCNotRange:
.01a537	38		sec				sec
.01a538	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a53a	b0 0d		bcs $01a549			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a53c					_FPCNotEqual:
.01a53c	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a53e	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a540	f0 02		beq $01a544			beq 	_FPCNE2
.01a542	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a544	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a545	80 04		bra $01a54b			bra 	_FPCExit
.01a547					_FPCPullZero:
.01a547	68		pla				pla 								; throw saved exponents
.01a548	68		pla				pla
.01a549					_FPCZero:
.01a549	a9 00		lda #$00			lda 	#0 							; and return zero
.01a54b					_FPCExit:
.01a54b	60		rts				rts
.01a54c					FPFastCompare:
.01a54c	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a54e	70 23		bvs $01a573			bvs 	_FPFLeftZero
.01a550	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a552	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a554	70 25		bvs $01a57b			bvs 	_FPFSignBit
.01a556	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a558	0a		asl a				asl 	a 							; put in CS if different.
.01a559	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a55b	b0 1e		bcs $01a57b			bcs 	_FPFSignBit
.01a55d	38		sec				sec 								; same sign and not-zero. compare exponents
.01a55e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a560	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a562	f0 09		beq $01a56d			beq 	_FPNoFastCompare
.01a564	6a		ror a				ror 	a 							; put carry into bit 7.
.01a565	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a567	30 02		bmi $01a56b			bmi		_FPFCNotMinus
.01a569	49 80		eor #$80			eor 	#$80
.01a56b					_FPFCNotMinus:
.01a56b	80 0e		bra $01a57b			bra		_FPFSignBit
.01a56d					_FPNoFastCompare:
.01a56d	18		clc				clc
.01a56e	60		rts				rts
.01a56f					_FPFZero:
.01a56f	a9 00		lda #$00			lda 	#0
.01a571					_FPFExitSet:
.01a571	38		sec				sec
.01a572	60		rts				rts
.01a573					_FPFLeftZero:
.01a573	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a575	70 f8		bvs $01a56f			bvs 	_FPFZero
.01a577	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a579	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a57b					_FPFSignBit:
.01a57b	0a		asl a				asl 	a
.01a57c	a9 01		lda #$01			lda 	#1
.01a57e	90 f1		bcc $01a571			bcc		_FPFExitSet
.01a580	a9 ff		lda #$ff			lda 	#$FF
.01a582	38		sec				sec
.01a583	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a584					FPUCopyX2ToX1:
.01a584	48		pha				pha
.01a585	da		phx				phx
.01a586	5a		phy				phy
.01a587	a0 08		ldy #$08			ldy 	#8
.01a589	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a58b	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a58d	e8		inx				inx
.01a58e	88		dey				dey
.01a58f	10 f8		bpl $01a589			bpl 	_FPUC21
.01a591	7a		ply				ply
.01a592	fa		plx				plx
.01a593	68		pla				pla
.01a594	60		rts				rts
.01a595					FPUSetInteger:
.01a595	48		pha				pha
.01a596	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a598	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a59a	10 02		bpl $01a59e			bpl 	_FPUSIExtend
.01a59c	a9 ff		lda #$ff			lda 	#$FF
.01a59e					_FPUSIExtend:
.01a59e	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a5a0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5a2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5a4	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a5a6	95 85		sta $85,x			sta 	XS_Type,x
.01a5a8	68		pla				pla
.01a5a9	60		rts				rts
.01a5aa					FPUNegateInteger:
.01a5aa	48		pha				pha
.01a5ab	38		sec				sec
.01a5ac	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a5ae	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a5b0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a5b2	a9 00		lda #$00			lda 	#0
.01a5b4	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a5b6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a5b8	a9 00		lda #$00			lda 	#0
.01a5ba	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a5bc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5be	a9 00		lda #$00			lda 	#0
.01a5c0	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a5c2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5c4	68		pla				pla
.01a5c5	60		rts				rts
.01a5c6					FPUToFloat:
.01a5c6	48		pha				pha
.01a5c7	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a5c9	29 0f		and #$0f			and 	#$0F
.01a5cb	f0 24		beq $01a5f1			beq 	_FPUFExit
.01a5cd	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a5cf	95 85		sta $85,x			sta 	XS_Type,x
.01a5d1	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a5d3	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a5d5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a5d7	10 07		bpl $01a5e0			bpl		_FPUFPositive
.01a5d9	20 aa a5	jsr $01a5aa			jsr 	FPUNegateInteger 			; negate the mantissa
.01a5dc	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a5de	95 85		sta $85,x			sta 	XS_Type,x
.01a5e0					_FPUFPositive:
.01a5e0	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a5e2	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a5e4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a5e6	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a5e8	d0 04		bne $01a5ee			bne 	_FPUFNonZero
.01a5ea	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a5ec	95 85		sta $85,x			sta 	XS_Type,x
.01a5ee					_FPUFNonZero:
.01a5ee	20 f3 a5	jsr $01a5f3			jsr 	FPUNormalise 				; normalise the floating point.
.01a5f1					_FPUFExit:
.01a5f1	68		pla				pla
.01a5f2	60		rts				rts
.01a5f3					FPUNormalise:
.01a5f3	48		pha				pha
.01a5f4	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a5f6	70 18		bvs $01a610			bvs 	_FPUNExit
.01a5f8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a5fa	f0 10		beq $01a60c			beq 	_FPUNSetZero
.01a5fc					_FPUNLoop:
.01a5fc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a5fe	30 10		bmi $01a610			bmi 	_FPUNExit 					; if so, we are normalised.
.01a600	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a602	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a604	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a606	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a608	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a60a	d0 f0		bne $01a5fc			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a60c					_FPUNSetZero:
.01a60c	a9 40		lda #$40			lda 	#$40
.01a60e	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a610					_FPUNExit:
.01a610	68		pla				pla
.01a611	60		rts				rts
.01a612					FPUToInteger:
.01a612	48		pha				pha
.01a613	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a615	29 01		and #$01			and 	#1
.01a617	d0 31		bne $01a64a			bne 	_FPUTOI_Exit
.01a619	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a61b	70 23		bvs $01a640			bvs 	_FPUTOI_Zero
.01a61d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a61f	10 1f		bpl $01a640			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a621	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a623	b0 2b		bcs $01a650			bcs 	FP_Overflow
.01a625					_FPUToIToInteger:
.01a625	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a627	c9 a0		cmp #$a0			cmp 	#128+32
.01a629	f0 0c		beq $01a637			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a62b	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a62d	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a62f	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a631	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a633	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a635	80 ee		bra $01a625			bra 	_FPUToIToInteger 			; keep going.
.01a637					_FPUToICheckSign:
.01a637	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a639	10 0f		bpl $01a64a			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a63b	20 aa a5	jsr $01a5aa			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a63e	80 0a		bra $01a64a			bra 	_FPUTOI_Exit
.01a640					_FPUTOI_Zero:
.01a640	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a642	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a644	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a646	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a648	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a64a					_FPUToI_Exit:
.01a64a	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a64c	95 85		sta $85,x			sta 	XS_Type,x
.01a64e	68		pla				pla
.01a64f	60		rts				rts
.01a650					FP_Overflow:
.01a650	20 83 85	jsr $018583			jsr ERR_Handler
>01a653	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a65b	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a66b					FPUTimes10:
.01a66b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a66d	85 1c		sta $1c				sta 	ZLTemp1+0
.01a66f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a671	85 1d		sta $1d				sta 	ZLTemp1+1
.01a673	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a675	85 1e		sta $1e				sta 	ZLTemp1+2
.01a677	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a679	85 1f		sta $1f				sta 	ZLTemp1+3
.01a67b	20 b0 a6	jsr $01a6b0			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a67e	20 b0 a6	jsr $01a6b0			jsr 	_FPUT_LSR_ZLTemp1
.01a681	18		clc				clc
.01a682	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a684	65 1c		adc $1c				adc 	ZLTemp1+0
.01a686	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a688	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a68a	65 1d		adc $1d				adc 	ZLTemp1+1
.01a68c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a68e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a690	65 1e		adc $1e				adc 	ZLTemp1+2
.01a692	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a694	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a696	65 1f		adc $1f				adc 	ZLTemp1+3
.01a698	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a69a	90 0a		bcc $01a6a6			bcc 	_FPUTimes10
.01a69c	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a69e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a6a0	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a6a2	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a6a4	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a6a6					_FPUTimes10:
.01a6a6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a6a8	18		clc				clc
.01a6a9	69 03		adc #$03			adc 	#3
.01a6ab	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6ad	b0 a1		bcs $01a650			bcs 	FP_Overflow 				; error
.01a6af	60		rts				rts
.01a6b0					_FPUT_LSR_ZLTemp1:
.01a6b0	46 1f		lsr $1f				lsr 	ZLTemp1+3
.01a6b2	66 1e		ror $1e				ror 	ZLTemp1+2
.01a6b4	66 1d		ror $1d				ror 	ZLTemp1+1
.01a6b6	66 1c		ror $1c				ror 	ZLTemp1+0
.01a6b8	60		rts				rts
.01a6b9					FPUScale10A:
.01a6b9	5a		phy				phy
.01a6ba	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a6bc	f0 37		beq $01a6f5			beq 	_FPUScaleExit
.01a6be	da		phx				phx 								; save X
.01a6bf	e8		inx				inx
.01a6c0	e8		inx				inx
.01a6c1	e8		inx				inx
.01a6c2	e8		inx				inx
.01a6c3	e8		inx				inx
.01a6c4	e8		inx				inx
.01a6c5	a8		tay				tay 								; save power scalar in Y.
.01a6c6	a9 00		lda #$00			lda 	#0
.01a6c8	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a6ca	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a6cc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a6ce	95 85		sta $85,x			sta 	XS_Type,x
.01a6d0	a9 80		lda #$80			lda 	#$80
.01a6d2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a6d4	a9 81		lda #$81			lda 	#$81
.01a6d6	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6d8	5a		phy				phy 								; save 10^n on stack.
.01a6d9	c0 00		cpy #$00			cpy 	#0
.01a6db	10 05		bpl $01a6e2			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a6dd	98		tya				tya
.01a6de	49 ff		eor #$ff			eor 	#$FF
.01a6e0	1a		inc a				inc 	a
.01a6e1	a8		tay				tay
.01a6e2					_FPUSAbs:
.01a6e2	20 6b a6	jsr $01a66b			jsr 	FPUTimes10
.01a6e5	88		dey				dey
.01a6e6	d0 fa		bne $01a6e2			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a6e8	68		pla				pla 								; restore count in A
.01a6e9	fa		plx				plx 								; restore X pointing to number to scale.
.01a6ea	0a		asl a				asl 	a
.01a6eb	b0 05		bcs $01a6f2			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a6ed	20 0d a4	jsr $01a40d			jsr 	FPMultiply 					; if clear multiply.
.01a6f0	80 03		bra $01a6f5			bra		_FPUScaleExit
.01a6f2					_FPUSDivide:
.01a6f2	20 9a a3	jsr $01a39a			jsr 	FPDivide
.01a6f5					_FPUScaleExit:
.01a6f5	7a		ply				ply
.01a6f6	60		rts				rts
.01a6f7					FPUCopyToNext:
.01a6f7	a0 06		ldy #$06			ldy 		#6
.01a6f9	da		phx				phx
.01a6fa					_FPUCopy1:
.01a6fa	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a6fc	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a6fe	e8		inx				inx
.01a6ff	88		dey				dey
.01a700	d0 f8		bne $01a6fa			bne 	_FPUCopy1
.01a702	fa		plx				plx
.01a703	60		rts				rts
.01a704					FPUCopyFromNext:
.01a704	a0 06		ldy #$06			ldy 		#6
.01a706	da		phx				phx
.01a707					_FPUCopy1:
.01a707	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a709	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a70b	e8		inx				inx
.01a70c	88		dey				dey
.01a70d	d0 f8		bne $01a707			bne 	_FPUCopy1
.01a70f	fa		plx				plx
.01a710	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a711					FPToString:
.01a711	48		pha				pha
.01a712	5a		phy				phy
.01a713	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a715	50 0a		bvc $01a721			bvc 		_FPTSIsFloat 			; if zero,
.01a717					_FPTSZero:
.01a717	a9 30		lda #$30			lda 		#"0"
.01a719	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter
.01a71c					_FPTSExit:
.01a71c	7a		ply				ply
.01a71d	68		pla				pla
.01a71e	60		rts				rts
.01a71f	80 fb		bra $01a71c			bra 		_FPTSExit
.01a721					_FPTSIsFloat:
.01a721	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a723	10 09		bpl $01a72e			bpl 		_FPTSNotSigned
.01a725	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a727	95 85		sta $85,x			sta 		XS_Type,x
.01a729	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a72b	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter
.01a72e					_FPTSNotSigned:
.01a72e	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a730	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a732	b0 09		bcs $01a73d			bcs 		_FPTSExponent
.01a734	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a736	90 05		bcc $01a73d			bcc 		_FPTSExponent 			;
.01a738					_FPTSStandard:
.01a738	20 7c a7	jsr $01a77c			jsr 		FPTOutputBody 			; output the body.
.01a73b	80 df		bra $01a71c			bra 		_FPTSExit
.01a73d					_FPTSExponent:
.01a73d	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a73f	8d 9d 03	sta $039d			sta 		ExpCount
.01a742					_FPTSExponentLoop:
.01a742	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a744	10 0e		bpl $01a754			bpl 		_FPTSTimes
.01a746	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a748	90 14		bcc $01a75e			bcc 		_FPTSScaledToExp
.01a74a	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a74c	20 b9 a6	jsr $01a6b9			jsr 		FPUScale10A
.01a74f	ee 9d 03	inc $039d			inc 		ExpCount
.01a752	80 ee		bra $01a742			bra 		_FPTSExponentLoop
.01a754					_FPTSTimes:
.01a754	a9 01		lda #$01			lda 		#1
.01a756	20 b9 a6	jsr $01a6b9			jsr 		FPUScale10A
.01a759	ce 9d 03	dec $039d			dec 		ExpCount
.01a75c	80 e4		bra $01a742			bra 		_FPTSExponentLoop
.01a75e					_FPTSScaledToExp:
.01a75e	20 7c a7	jsr $01a77c			jsr 		FPTOutputBody 			; output the body.
.01a761	a9 65		lda #$65			lda 		#"e"					; output E
.01a763	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter
.01a766	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a769	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a76b	29 80		and #$80			and 		#$80 					; sign extend it
.01a76d	f0 02		beq $01a771			beq 		_FPTSSExt
.01a76f	a9 ff		lda #$ff			lda 		#$FF
.01a771					_FPTSSExt:
.01a771	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a773	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a775	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a777	20 97 a1	jsr $01a197			jsr 		INTToString 			; output the exponent.
.01a77a	80 a0		bra $01a71c			bra			_FPTSExit 				; and exit.
.01a77c					FPTOutputBody:
.01a77c	20 f7 a6	jsr $01a6f7			jsr 		FPUCopyToNext 			; copy to next slot.
.01a77f	20 12 a6	jsr $01a612			jsr 		FPUToInteger 			; convert to an integer
.01a782	20 97 a1	jsr $01a197			jsr 		INTToString 			; output the main integer part.
.01a785	20 04 a7	jsr $01a704			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a788	20 95 a4	jsr $01a495			jsr 		FPFractionalPart 		; get the decimal part.
.01a78b	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a78d	70 3c		bvs $01a7cb			bvs 		_FPTOExit 				; if not, exit now.
.01a78f	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a791	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter
.01a794					_FPOutLoop:
.01a794	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a796	70 1d		bvs $01a7b5			bvs 		_FPStripZeros 			; strip trailing zeros
.01a798	20 6b a6	jsr $01a66b			jsr 		FPUTimes10 				; multiply by 10
.01a79b	20 f7 a6	jsr $01a6f7			jsr 		FPUCopyToNext			; copy to next slot.
.01a79e	20 12 a6	jsr $01a612			jsr 		FPUToInteger 			; convert to integer
.01a7a1	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a7a3	09 30		ora #$30			ora 		#"0"
.01a7a5	20 39 a2	jsr $01a239			jsr 		ITSOutputCharacter
.01a7a8	20 04 a7	jsr $01a704			jsr 		FPUCopyFromNext 		; get it back
.01a7ab	20 95 a4	jsr $01a495			jsr 		FPFractionalPart 		; get fractional part
.01a7ae	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a7b1	c9 0b		cmp #$0b			cmp 	 	#11
.01a7b3	90 df		bcc $01a794			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a7b5					_FPStripZeros:
.01a7b5	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a7b8					_FPStripLoop:
.01a7b8	88		dey				dey 								; back one, if at start then no strip
.01a7b9	f0 10		beq $01a7cb			beq 		_FPToExit
.01a7bb	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a7be	c9 30		cmp #$30			cmp 		#"0"
.01a7c0	f0 f6		beq $01a7b8			beq 		_FPStripLoop
.01a7c2	c8		iny				iny
.01a7c3	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a7c5	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a7c8	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a7cb					_FPTOExit:
.01a7cb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a7cc					FPFromString:
.01a7cc	48		pha				pha 								; push A
.01a7cd	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a7cf	c9 2e		cmp #$2e			cmp 	#"."
.01a7d1	f0 03		beq $01a7d6			beq	 	_FPFIsDecimal
.01a7d3	4c 32 a8	jmp $01a832			jmp 	_FPFNotDecimal
.01a7d6					_FPFIsDecimal:
.01a7d6	c8		iny				iny 								; consume the decimal.
.01a7d7	20 c6 a5	jsr $01a5c6			jsr 	FPUToFloat 					; convert the integer to float.
.01a7da	da		phx				phx 								; save X.
.01a7db	5a		phy				phy 								; save decimal start position
.01a7dc	e8		inx				inx
.01a7dd	e8		inx				inx
.01a7de	e8		inx				inx
.01a7df	e8		inx				inx
.01a7e0	e8		inx				inx
.01a7e1	e8		inx				inx
.01a7e2	20 4e a2	jsr $01a24e			jsr 	INTFromStringY 				; get the part after the DP.
.01a7e5	20 c6 a5	jsr $01a5c6			jsr 	FPUToFloat 					; convert that to a float.
.01a7e8	68		pla				pla 								; calculate - chars consumed.
.01a7e9	8c 9c 03	sty $039c			sty 	ExpTemp
.01a7ec	38		sec				sec
.01a7ed	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a7f0	20 b9 a6	jsr $01a6b9			jsr 	FPUScale10A 				; scale it by 10^AC
.01a7f3	fa		plx				plx 								; restore original X
.01a7f4	20 e6 a2	jsr $01a2e6			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a7f7	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.01a7f9	c9 45		cmp #$45			cmp 	#"E"
.01a7fb	f0 04		beq $01a801			beq 	_FPFExponent
.01a7fd	c9 65		cmp #$65			cmp 	#"e"
.01a7ff	d0 31		bne $01a832			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a801					_FPFExponent:
.01a801	c8		iny				iny 								; skip over E symbol.
.01a802	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.01a804	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a806	d0 01		bne $01a809			bne 	_FPFGotSign
.01a808	c8		iny				iny 								; if it was - skip over it.
.01a809					_FPFGotSign:
.01a809	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a80a	da		phx				phx
.01a80b	e8		inx				inx
.01a80c	e8		inx				inx
.01a80d	e8		inx				inx
.01a80e	e8		inx				inx
.01a80f	e8		inx				inx
.01a810	e8		inx				inx
.01a811	20 4e a2	jsr $01a24e			jsr 	INTFromStringY 				; get the exponent
.01a814	fa		plx				plx 								; restore X.
.01a815	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a817	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a819	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a81b	d0 17		bne $01a834			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a81d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a81f	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a821	b0 11		bcs $01a834			bcs 	_FPFXOverflow
.01a823	68		pla				pla 								; get direction
.01a824	d0 07		bne $01a82d			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a826	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a828	49 ff		eor #$ff			eor 	#$FF
.01a82a	1a		inc a				inc 	a
.01a82b	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a82d					_FPFXScale:
.01a82d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a82f	20 b9 a6	jsr $01a6b9			jsr 	FPUScale10A 				; scale by the exponent.
.01a832					_FPFNotDecimal:
.01a832	68		pla				pla
.01a833	60		rts				rts
.01a834					_FPFXOverflow:
.01a834	20 83 85	jsr $018583			jsr 	ERR_Handler
>01a837	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a83f	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a846					Unary_Rnd:
.01a846	20 97 93	jsr $019397			jsr 	EvaluateNumberX 			; get value
.01a849	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; check right bracket.
.01a84c	20 17 96	jsr $019617			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a84f	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a851	30 10		bmi $01a863			bmi 	_URSetSeed
.01a853	f0 28		beq $01a87d			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a855	da		phx				phx
.01a856	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a858	20 b4 a8	jsr $01a8b4			jsr 	Random16
.01a85b	a2 02		ldx #$02			ldx 	#2
.01a85d	20 b4 a8	jsr $01a8b4			jsr 	Random16
.01a860	fa		plx				plx
.01a861	80 1a		bra $01a87d			bra 	_URMakeRandom
.01a863					_URSetSeed:
.01a863	20 c6 a5	jsr $01a5c6			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a866	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a868	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a86b	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a86d	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a870	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a872	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a875	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a877	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a878	49 db		eor #$db			eor 	#$DB
.01a87a	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a87d					_URMakeRandom:
.01a87d	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a880	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a883	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a886	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a889	d0 0a		bne $01a895			bne 	_URNotZero
.01a88b	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a88d	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a890	a9 3d		lda #$3d			lda 	#$3D
.01a892	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a895					_URNotZero:
.01a895	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a898	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a89a	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a89d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a89f	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a8a2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a8a4	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a8a7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a8a9	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a8ab	95 85		sta $85,x			sta 	XS_Type,x
.01a8ad	a9 80		lda #$80			lda 	#$80
.01a8af	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a8b1	4c f3 a5	jmp $01a5f3			jmp 	FPUNormalise 				; and normalise.
.01a8b4					Random16:
.01a8b4	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a8b7	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a8ba	90 08		bcc $01a8c4			bcc 	_R16_NoXor
.01a8bc	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a8bf	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a8c1	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a8c4					_R16_NoXor:
.01a8c4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a8c5					Unary_Int:
.01a8c5	20 97 93	jsr $019397			jsr 	EvaluateNumberX 			; get value
.01a8c8	20 f9 99	jsr $0199f9			jsr 	CheckNextRParen 			; check right bracket.
.01a8cb	4c 12 a6	jmp $01a612			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/testing/tokenisetest.asm

.01a8ce					TokeniseTest:
.01a8ce	c2 30		rep #$30			rep 	#$30
.01a8d0	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01a8d3	1b		tcs				tcs
.01a8d4	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01a8d7	e2 30		sep #$30			sep 	#$30
.01a8d9	a2 ff		ldx #$ff			ldx 	#255
.01a8db	e8		inx		_ttCopy:inx
.01a8dc	bf fe a8 01	lda $01a8fe,x			lda 	TokeniseTestIn,x
.01a8e0	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01a8e3	d0 f6		bne $01a8db			bne 	_ttCopy
.01a8e5	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF
.01a8e7	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.01a8e9	20 34 9b	jsr $019b34			jsr 	TokeniseString
.01a8ec	ea		nop				nop
.01a8ed	a2 00		ldx #$00			ldx 	#0
.01a8ef					_ttCompare:
.01a8ef	bd 00 04	lda $0400,x			lda 	TokeniseBuffer,x
.01a8f2	df 09 a9 01	cmp $01a909,x			cmp 	TokeniseTestOut,x
.01a8f6	d0 fe		bne $01a8f6	_ttStop:bne 	_ttStop
.01a8f8	e8		inx				inx
.01a8f9	e0 08		cpx #$08			cpx 	#TokeniseTestOutEnd-TokeniseTestOut
.01a8fb	d0 f2		bne $01a8ef			bne 	_ttCompare
>01a8fd	02						.byte 	2

;******  Processing file: modules/basic/tokenise/testing/tokentest.src

.01a8fe					TokeniseTestIn:
>01a8fe	20 72 65 6d 20 68 65 6c				.text ' rem hello',0
>01a906	6c 6f 00
.01a909					TokeniseTestOut:
>01a909	fe 07 68 65 6c 6c 6f 00				.byte 	$FE,$07,$68,$65,$6C,$6C,$6F,$00
.01a911					TokeniseTestOutEnd:

;******  Return to file: modules/basic/tokenise/testing/tokenisetest.asm


;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a911	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
