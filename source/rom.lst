
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Wed Sep  4 19:35:17 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=0					exitonend = 0
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/macros/65816/macros_32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=0					VariableMemory = 0
.1000					BasicProgram:
.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 11 88 01	jmp $018811		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ea	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f2	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; go to next line.
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.018281	ae ca 03	ldx $03ca			ldx 	TIM_X
.018284	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d c9 03	sta $03c9			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e ca 03	stx $03ca			stx 	TIM_X
.01838b	8c cb 03	sty $03cb			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d c8 03	sta $03c8			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.01839a	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce c4 03	dec $03c4			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d c4 03	sta $03c4			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018413	85 18		sta $18				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 19		inc $19				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; then exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 86 85	jsr $018586			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 86 85	jsr $018586			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848d					SkipEndOfCommand:
.01848d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01848f	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018491	f0 19		beq $0184ac			beq 	_SOCExit
.018493	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018495	f0 15		beq $0184ac			beq 	_SOCExit
.018497	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018499	c8		iny				iny 								; skip
.01849a	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01849c	90 0c		bcc $0184aa			bcc 	_SEDone 					; so just skip over it.
.01849e	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184a0	90 07		bcc $0184a9			bcc 	_SEDouble
.0184a2	98		tya				tya 								; this is Y + 1
.0184a3	18		clc				clc
.0184a4	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.0184a6	a8		tay				tay 								; back in Y.
.0184a7	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a8	88		dey				dey
.0184a9					_SEDouble:
.0184a9	c8		iny				iny
.0184aa					_SEDone:
.0184aa	80 e1		bra $01848d			bra 	SkipEndOfCommand
.0184ac					_SOCExit:
.0184ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184ad					StackReset:
.0184ad	48		pha				pha
.0184ae	5a		phy				phy
.0184af	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.0184b1	85 28		sta $28				sta 	zBasicSP
.0184b3	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.0184b5	85 29		sta $29				sta 	zBasicSP+1
.0184b7	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b9	98		tya				tya 								; be a legal token.
.0184ba	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184bc	7a		ply				ply
.0184bd	68		pla				pla
.0184be	60		rts				rts
.0184bf					StackPushFrame:
.0184bf	48		pha				pha
.0184c0	5a		phy				phy
.0184c1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184c2	48		pha				pha 								; save it.
.0184c3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184c5	18		clc				clc 								; add to Basic Stack
.0184c6	65 28		adc $28				adc 	zBasicSP
.0184c8	85 28		sta $28				sta 	zBasicSP
.0184ca	90 02		bcc $0184ce			bcc 	_SPFNoBump
.0184cc	e6 29		inc $29				inc 	zBasicSP+1
.0184ce					_SPFNoBump:
.0184ce	a0 00		ldy #$00			ldy 	#0
.0184d0	68		pla				pla
.0184d1	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184d3	7a		ply				ply
.0184d4	68		pla				pla
.0184d5	60		rts				rts
.0184d6					StackPopFrame:
.0184d6	48		pha				pha
.0184d7	5a		phy				phy
.0184d8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184da	51 28		eor ($28),y			eor 	(zBasicSP),y
.0184dc	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184de	d0 12		bne $0184f2			bne 	SPFError 					; mixed structures
.0184e0	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.0184e2	29 0f		and #$0f			and 	#$0F
.0184e4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e6	38		sec				sec
.0184e7	65 28		adc $28				adc 	zBasicSP
.0184e9	85 28		sta $28				sta 	zBasicSP
.0184eb	b0 02		bcs $0184ef			bcs 	_SPFNoBump
.0184ed	c6 29		dec $29				dec 	zBasicSP+1
.0184ef					_SPFNoBump:
.0184ef	7a		ply				ply
.0184f0	68		pla				pla
.0184f1	60		rts				rts
.0184f2					SPFError:
.0184f2	20 86 85	jsr $018586			jsr ERR_Handler
>0184f5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fd	72 75 63 74 75 72 65 73 00
.018506					StackSavePosition:
.018506	98		tya				tya
.018507	5a		phy				phy
.018508	a0 05		ldy #$05			ldy 	#5
.01850a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01850c	a0 01		ldy #$01			ldy 	#1
.01850e	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018510	91 28		sta ($28),y			sta 	(zBasicSP),y
.018512	c8		iny				iny
.018513	a5 19		lda $19				lda 	zCodePtr+1
.018515	91 28		sta ($28),y			sta 	(zBasicSP),y
.018517	c8		iny				iny
.018518	a5 1a		lda $1a				lda 	zCodePtr+2
.01851a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01851c	c8		iny				iny
.01851d	a5 1b		lda $1b				lda 	zCodePtr+3
.01851f	91 28		sta ($28),y			sta 	(zBasicSP),y
.018521	7a		ply				ply
.018522	60		rts				rts
.018523					StackRestorePosition:
.018523	5a		phy				phy
.018524	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018526	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018528	85 18		sta $18				sta 	zCodePtr+0
.01852a	c8		iny				iny
.01852b	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852d	85 19		sta $19				sta 	zCodePtr+1
.01852f	c8		iny				iny
.018530	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018532	85 1a		sta $1a				sta 	zCodePtr+2
.018534	c8		iny				iny
.018535	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018537	85 1b		sta $1b				sta 	zCodePtr+3
.018539	c8		iny				iny
.01853a	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.01853c	7a		ply				ply 								; restore Y
.01853d	a8		tay				tay
.01853e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853f					VIOCharPrint:
.01853f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018542					VIOCharGet:
.018542	20 e6 81	jsr $0181e6			jsr 	IF_GetKey
.018545	c9 00		cmp #$00			cmp 	#0
.018547	f0 02		beq $01854b			beq 	_VCG0
.018549	38		sec				sec
.01854a	60		rts				rts
.01854b	18		clc		_VCG0:	clc
.01854c	60		rts				rts
.01854d					VIOCheckBreak:
.01854d	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak
.018550					VIOCharGetPosition:
.018550	ad 00 05	lda $0500			lda 	IFT_XCursor
.018553	60		rts				rts
.018554					VIOReadLine:
.018554	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018557					SyntaxError:
.018557	20 86 85	jsr $018586			jsr 	ERR_Handler
>01855a	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018562	72 72 6f 72 00
.018567					TypeError:
.018567	20 86 85	jsr $018586			jsr 	ERR_Handler
>01856a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018572	70 65 00
.018575					BadParamError:
.018575	20 86 85	jsr $018586			jsr 	ERR_Handler
>018578	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018580	6d 65 74 65 72 00
.018586					ERR_Handler:
.018586	a0 00		ldy #$00			ldy 	#0
.018588	c8		iny				iny
.018589	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01858b	85 80		sta $80				sta 	XS_Mantissa
.01858d	c8		iny				iny
.01858e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018590	85 81		sta $81				sta 	XS_Mantissa+1
.018592	fa		plx				plx 								; address in XY
.018593	7a		ply				ply
.018594	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018595	d0 01		bne $018598			bne 	_EHNoSkip
.018597	c8		iny				iny
.018598					_EHNoSkip:
.018598	20 ba 85	jsr $0185ba			jsr 	PrintROMMessage 			; print message from ROM.
.01859b	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859d	05 81		ora $81				ora 	XS_Mantissa+1
.01859f	f0 0c		beq $0185ad			beq 	_EHNoLine
.0185a1	a2 b5		ldx #$b5			ldx 	#_EHAt & $FF 				; print " at "
.0185a3	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a5	20 ba 85	jsr $0185ba			jsr 	PrintROMMessage
.0185a8	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185aa	20 cf 85	jsr $0185cf			jsr 	Print16BitInteger
.0185ad					_EHNoLine:
.0185ad	a9 0d		lda #$0d			lda 	#13
.0185af	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185b2	4c 54 88	jmp $018854			jmp 	ErrorStart 					; normally warm start, no message.
>0185b5	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185ba					PrintROMMessage:
.0185ba	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.0185bc	84 1d		sty $1d				sty 	zLTemp1+1
.0185be	4b		phk				phk 								; get current code page
.0185bf	68		pla				pla
.0185c0	85 1e		sta $1e				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185c2	a0 00		ldy #$00			ldy 	#0
.0185c4					_PRMLoop:
.0185c4	b7 1c		lda [$1c],y			lda 	[zLTemp1],y 				; 65816
.0185c6	f0 06		beq $0185ce			beq		_PRMExit 					; character $00 => exit
.0185c8	c8		iny				iny  								; bump Y and print it.
.0185c9	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185cc	80 f6		bra $0185c4			bra 	_PRMLoop
.0185ce					_PRMExit:
.0185ce	60		rts				rts
.0185cf					Print16BitInteger:
.0185cf	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185d1	85 82		sta $82				sta 	XS_Mantissa+2
.0185d3	85 83		sta $83				sta 	XS_Mantissa+3
.0185d5					Print32BitInteger:
.0185d5	a9 00		lda #$00			lda 	#0
.0185d7	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185da	aa		tax				tax 								; convert bottom level.
.0185db	20 de a1	jsr $01a1de			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185de	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185e0	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185e3	f0 06		beq $0185eb			beq 	_P1Exit
.0185e5	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185e8	e8		inx				inx
.0185e9	80 f5		bra $0185e0			bra 	_P1Loop
.0185eb	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185ed					VectorTable:
>0185ed	08 94					.word BinaryOp_And         & $FFFF ; $80 and
>0185ef	24 94					.word BinaryOp_Or          & $FFFF ; $81 or
>0185f1	40 94					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185f3	40 94					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185f5	77 94					.word Binary_Equal         & $FFFF ; $84 =
>0185f7	80 94					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185f9	89 94					.word Binary_Less          & $FFFF ; $86 <
>0185fb	92 94					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185fd	a4 94					.word Binary_Greater       & $FFFF ; $88 >
>0185ff	9b 94					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018601	3c 95					.word BinaryOp_Add         & $FFFF ; $8a +
>018603	58 95					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018605	69 95					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018607	7a 95					.word BinaryOp_Divide      & $FFFF ; $8d /
>018609	ab 86					.word NotImplemented       & $FFFF ; $8e ^
>01860b	96 8d					.word Command_IF           & $FFFF ; $8f if
>01860d	04 92					.word Command_WHILE        & $FFFF ; $90 while
>01860f	2c 92					.word Command_REPEAT       & $FFFF ; $91 repeat
>018611	e9 89					.word Command_FOR          & $FFFF ; $92 for
>018613	ab 86					.word NotImplemented       & $FFFF ; $93 then
>018615	f3 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018617	21 92					.word Command_WEND         & $FFFF ; $95 wend
>018619	35 92					.word Command_UNTIL        & $FFFF ; $96 until
>01861b	66 8a					.word Command_NEXT         & $FFFF ; $97 next
>01861d	ab 86					.word NotImplemented       & $FFFF ; $98 not
>01861f	ab 86					.word NotImplemented       & $FFFF ; $99 fn(
>018621	75 96					.word Unary_Abs            & $FFFF ; $9a abs(
>018623	d0 97					.word Unary_Asc            & $FFFF ; $9b asc(
>018625	fc a8					.word Unary_Int            & $FFFF ; $9c int(
>018627	8f 96					.word Unary_Peek           & $FFFF ; $9d peek(
>018629	7d a8					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01862b	02 97					.word Unary_Usr            & $FFFF ; $9f usr(
>01862d	0f 98					.word Unary_Left           & $FFFF ; $a0 left$(
>01862f	24 98					.word Unary_Right          & $FFFF ; $a1 right$(
>018631	f6 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018633	6f 99					.word Unary_Spc            & $FFFF ; $a3 spc(
>018635	9e 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018637	23 97					.word Unary_Val            & $FFFF ; $a5 val(
>018639	e7 97					.word Unary_Len            & $FFFF ; $a6 len(
>01863b	9c 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01863d	ab 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01863f	ab 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018641	ab 86					.word NotImplemented       & $FFFF ; $aa tan(
>018643	ab 86					.word NotImplemented       & $FFFF ; $ab atn(
>018645	ab 86					.word NotImplemented       & $FFFF ; $ac exp(
>018647	ab 86					.word NotImplemented       & $FFFF ; $ad log(
>018649	ab 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01864b	f2 98					.word Unary_Dec            & $FFFF ; $af dec(
>01864d	93 96					.word Unary_Deek           & $FFFF ; $b0 deek(
>01864f	97 96					.word Unary_Leek           & $FFFF ; $b1 leek(
>018651	cf 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>018653	2f 96					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018655	51 99					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018657	c3 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>018659	92 99					.word Unary_Tab            & $FFFF ; $b6 tab(
>01865b	ab 86					.word NotImplemented       & $FFFF ; $b7 $
>01865d	ab 86					.word NotImplemented       & $FFFF ; $b8 $(
>01865f	ab 86					.word NotImplemented       & $FFFF ; $b9 #
>018661	ab 86					.word NotImplemented       & $FFFF ; $ba #(
>018663	ab 86					.word NotImplemented       & $FFFF ; $bb %
>018665	ab 86					.word NotImplemented       & $FFFF ; $bc %(
>018667	ab 86					.word NotImplemented       & $FFFF ; $bd (
>018669	ab 86					.word NotImplemented       & $FFFF ; $be )
>01866b	ab 86					.word NotImplemented       & $FFFF ; $bf ,
>01866d	e8 89					.word Command_COLON        & $FFFF ; $c0 :
>01866f	ab 86					.word NotImplemented       & $FFFF ; $c1 ;
>018671	ab 86					.word NotImplemented       & $FFFF ; $c2 def
>018673	e5 91					.word Command_CLR          & $FFFF ; $c3 clr
>018675	fc 91					.word Command_STOP         & $FFFF ; $c4 stop
>018677	3f 8b					.word Command_DATA         & $FFFF ; $c5 data
>018679	19 8b					.word Command_READ         & $FFFF ; $c6 read
>01867b	8f 88					.word Command_DIM          & $FFFF ; $c7 dim
>01867d	ab 86					.word NotImplemented       & $FFFF ; $c8 to
>01867f	ab 86					.word NotImplemented       & $FFFF ; $c9 step
>018681	2b 91					.word Command_GOSUB        & $FFFF ; $ca gosub
>018683	3b 91					.word Command_RETURN       & $FFFF ; $cb return
>018685	23 91					.word Command_GOTO         & $FFFF ; $cc goto
>018687	93 8d					.word Command_END          & $FFFF ; $cd end
>018689	62 8c					.word Command_INPUT        & $FFFF ; $ce input
>01868b	dd 8b					.word Command_LET          & $FFFF ; $cf let
>01868d	f9 8d					.word Command_LIST         & $FFFF ; $d0 list
>01868f	cd 90					.word Command_NEW          & $FFFF ; $d1 new
>018691	e9 90					.word Command_OLD          & $FFFF ; $d2 old
>018693	44 91					.word Command_ON           & $FFFF ; $d3 on
>018695	42 8b					.word Command_RESTORE      & $FFFF ; $d4 restore
>018697	9c 90					.word Command_POKE         & $FFFF ; $d5 poke
>018699	ed 8f					.word Command_PRINT        & $FFFF ; $d6 print
>01869b	5a 89					.word Command_RUN          & $FFFF ; $d7 run
>01869d	1a 89					.word Command_WAIT         & $FFFF ; $d8 wait
>01869f	48 8c					.word Command_SYS          & $FFFF ; $d9 sys
>0186a1	a0 90					.word Command_DOKE         & $FFFF ; $da doke
>0186a3	a4 90					.word Command_LOKE         & $FFFF ; $db loke
>0186a5	84 90					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a7	fe 8b					.word Command_GET          & $FFFF ; $dd get
>0186a9	ed 8d					.word Command_ELSE         & $FFFF ; $de else
.0186ab					NotImplemented:
.0186ab	20 86 85	jsr $018586			jsr ERR_Handler
>0186ae	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b6	65 6d 65 6e 74 65 64 00
.0186be					BinaryPrecedence:
>0186be	01					.byte 1    ; $80 and
>0186bf	01					.byte 1    ; $81 or
>0186c0	01					.byte 1    ; $82 xor
>0186c1	01					.byte 1    ; $83 eor
>0186c2	02					.byte 2    ; $84 =
>0186c3	02					.byte 2    ; $85 <>
>0186c4	02					.byte 2    ; $86 <
>0186c5	02					.byte 2    ; $87 <=
>0186c6	02					.byte 2    ; $88 >
>0186c7	02					.byte 2    ; $89 >=
>0186c8	03					.byte 3    ; $8a +
>0186c9	03					.byte 3    ; $8b -
>0186ca	04					.byte 4    ; $8c *
>0186cb	04					.byte 4    ; $8d /
>0186cc	05					.byte 5    ; $8e ^
.0186cd					KeywordText:
>0186cd	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186d0	4f d2					.byte $4f,$d2                          ; $81 or
>0186d2	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186d5	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186d8	bd					.byte $bd                              ; $84 =
>0186d9	3c be					.byte $3c,$be                          ; $85 <>
>0186db	bc					.byte $bc                              ; $86 <
>0186dc	3c bd					.byte $3c,$bd                          ; $87 <=
>0186de	be					.byte $be                              ; $88 >
>0186df	3e bd					.byte $3e,$bd                          ; $89 >=
>0186e1	ab					.byte $ab                              ; $8a +
>0186e2	ad					.byte $ad                              ; $8b -
>0186e3	aa					.byte $aa                              ; $8c *
>0186e4	af					.byte $af                              ; $8d /
>0186e5	de					.byte $de                              ; $8e ^
>0186e6	49 c6					.byte $49,$c6                          ; $8f if
>0186e8	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186ed	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186f3	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f6	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186fa	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186ff	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018703	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018708	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01870c	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>01870f	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018712	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018716	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01871a	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>01871e	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018723	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018727	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01872b	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018731	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018738	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01873d	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018741	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018746	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01874a	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01874e	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018753	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018757	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01875b	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01875f	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018763	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018767	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01876b	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01876f	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018773	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018778	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01877d	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018781	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018785	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01878a	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01878e	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018792	a4					.byte $a4                              ; $b7 $
>018793	24 a8					.byte $24,$a8                          ; $b8 $(
>018795	a3					.byte $a3                              ; $b9 #
>018796	23 a8					.byte $23,$a8                          ; $ba #(
>018798	a5					.byte $a5                              ; $bb %
>018799	25 a8					.byte $25,$a8                          ; $bc %(
>01879b	a8					.byte $a8                              ; $bd (
>01879c	a9					.byte $a9                              ; $be )
>01879d	ac					.byte $ac                              ; $bf ,
>01879e	ba					.byte $ba                              ; $c0 :
>01879f	bb					.byte $bb                              ; $c1 ;
>0187a0	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0187a3	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a6	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187aa	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187ae	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187b2	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187b5	54 cf					.byte $54,$cf                          ; $c8 to
>0187b7	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187bb	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187c0	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c6	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187ca	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187cd	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187d2	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187d5	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187d9	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187dc	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187df	4f ce					.byte $4f,$ce                          ; $d3 on
>0187e1	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187e8	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ec	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187f1	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187f4	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187f8	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187fb	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187ff	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018803	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>018809	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01880c	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018810	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018811					BASIC_Start:
.018811	c2 30		rep #$30			rep 	#$30
.018813	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018816	1b		tcs				tcs
.018817	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01881a	e2 30		sep #$30			sep 	#$30
.01881c	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.01881f	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018822	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018824	8d 10 03	sta $0310			sta 	LocalVector
.018827	8d 0c 03	sta $030c			sta 	UserVector
.01882a	a9 11		lda #$11			lda 	#USRDefault & $FF 			; reset USR vector to a default
.01882c	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.01882f	a9 97		lda #$97			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.018831	8d 0e 03	sta $030e			sta 	UserVector+2
.018834	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018836	8d 0f 03	sta $030f			sta 	UserVector+3
.018839	20 d9 99	jsr $0199d9			jsr 	UpdateProgramEnd 			; update the program end.
.01883c	20 e5 91	jsr $0191e5			jsr 	ResetRunStatus 				; clear everything (CLR command)
.01883f	c2 30		rep #$30			rep 	#$30
.018841	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018844	1b		tcs				tcs
.018845	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018848	e2 30		sep #$30			sep 	#$30
.01884a	20 cd 90	jsr $0190cd			jsr 	Command_NEW 				; new command, will not return.
.01884d					WarmStart:
.01884d	a2 85		ldx #$85			ldx 	#ReadyMsg & $FF 			; Print READY.
.01884f	a0 88		ldy #$88			ldy 	#(ReadyMsg >> 8) & $FF
.018851	20 ba 85	jsr $0185ba			jsr 	PrintROMMessage
.018854					ErrorStart:
.018854	c2 30		rep #$30			rep 	#$30
.018856	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018859	1b		tcs				tcs
.01885a	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01885d	e2 30		sep #$30			sep 	#$30
.01885f	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine 				; read line in.
.018862	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF 		; tokenise it.
.018864	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.018866	20 70 9b	jsr $019b70			jsr 	TokeniseString
.018869	ad 03 04	lda $0403			lda 	TokeniseBuffer+3 			; what is first.
.01886c	29 c0		and #$c0			and 	#$C0 						; is it a number 4000-7FFF
.01886e	c9 40		cmp #$40			cmp 	#$40
.018870	f0 1b		beq $01888d			beq 	EditLine 					; if true, go to edit line.
.018872	a9 00		lda #$00			lda 	#(TokeniseBuffer) & $FF
.018874	85 18		sta $18				sta 	zCodePtr+0
.018876	a9 04		lda #$04			lda 	#((TokeniseBuffer) >> 8)
.018878	85 19		sta $19				sta 	zCodePtr+1
.01887a	a9 00		lda #$00			lda 	#(TokeniseBuffer) >> 16
.01887c	85 1a		sta $1a				sta 	zCodePtr+2
.01887e	85 1b		sta $1b				sta 	zCodePtr+3
.018880	a0 03		ldy #$03			ldy 	#3
.018882	4c 8e 89	jmp $01898e			jmp 	RUN_NextCommand
.018885					ReadyMsg:
>018885	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0
.01888d					EditLine:
.01888d	80 fe		bra $01888d			bra 	EditLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01888f					Command_DIM:
.01888f	98		tya				tya
.018890	48		pha				pha 								; push on stack.
.018891	20 67 9d	jsr $019d67			jsr 	VariableExtract 			; get the identifier
.018894	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018897	29 01		and #$01			and 	#1
.018899	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01889b	d0 6f		bne $01890c			bne 	_CDIError
.01889d	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01889f	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0188a2					_CDIGetDimension:
.0188a2	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.0188a5	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0188a7	f0 63		beq $01890c			beq 	_CDIError
.0188a9	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; evaluate an index size
.0188ac	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.0188ae	29 80		and #$80			and 	#$80
.0188b0	05 82		ora $82				ora 	XS_Mantissa+2
.0188b2	05 83		ora $83				ora 	XS_Mantissa+3
.0188b4	d0 56		bne $01890c			bne 	_CDIError
.0188b6	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.0188b9	18		clc				clc 								; add 1 - max index => size.
.0188ba	a5 80		lda $80				lda 	XS_Mantissa+0
.0188bc	69 01		adc #$01			adc 	#1
.0188be	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.0188c1	a5 81		lda $81				lda 	XS_Mantissa+1
.0188c3	69 00		adc #$00			adc 	#0
.0188c5	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.0188c8	30 42		bmi $01890c			bmi 	_CDIError 					; could be dim a(32767)
.0188ca	e8		inx				inx 								; bump index.
.0188cb	e8		inx				inx
.0188cc	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.0188cf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188d1	c8		iny				iny
.0188d2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0188d4	f0 cc		beq $0188a2			beq 	_CDIGetDimension
.0188d6	88		dey				dey
.0188d7	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; closing ) present ?
.0188da	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.0188dd	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0188df	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.0188e2					_CDICopy:
.0188e2	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.0188e5	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188e8	ca		dex				dex
.0188e9	10 f7		bpl $0188e2			bpl 	_CDICopy
.0188eb	68		pla				pla									; position of array identifier
.0188ec	85 10		sta $10				sta 	zTemp1
.0188ee	98		tya				tya
.0188ef	48		pha				pha
.0188f0	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188f2	a8		tay				tay
.0188f3	20 67 9d	jsr $019d67			jsr 	VariableExtract 			; get the identifier
.0188f6	20 00 a0	jsr $01a000			jsr 	VariableLocate 				; check if it exists already.
.0188f9	b0 11		bcs $01890c			bcs 	_CDIError
.0188fb	20 f3 9d	jsr $019df3			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188fe	68		pla				pla 								; restore code position
.0188ff	a8		tay				tay
.018900	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018902	c8		iny				iny
.018903	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018905	f0 88		beq $01888f			beq 	Command_DIM
.018907	88		dey				dey
.018908	20 02 9f	jsr $019f02			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.01890b	60		rts				rts
.01890c					_CDIError:
.01890c	20 86 85	jsr $018586			jsr ERR_Handler
>01890f	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018917					_CDISyntax:
.018917	4c 57 85	jmp $018557			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.01891a					Command_WAIT:
.01891a	20 e9 93	jsr $0193e9			jsr		EvaluateInteger 			; get address to monitor
.01891d	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.01891f	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma
.018922	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX
.018925	a9 00		lda #$00			lda 	#0							; set default xor value.
.018927	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.018929	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01892b	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.01892d	d0 06		bne $018935			bne 	_CWAXorDefault
.01892f	c8		iny				iny
.018930	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.018932	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX
.018935					_CWAXorDefault:
.018935	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.018937	85 1c		sta $1c				sta 	zLTemp1
.018939	a5 81		lda $81				lda 	XS_Mantissa+1
.01893b	85 1d		sta $1d				sta 	zLTemp1+1
.01893d	a5 82		lda $82				lda 	XS_Mantissa+2
.01893f	85 1e		sta $1e				sta 	zLTemp1+2
.018941					_CWAWaitLoop:
.018941	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; exit on break.
.018944	c9 00		cmp #$00			cmp 	#0
.018946	d0 11		bne $018959			bne 	_CWAWaitExit
.018948	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.01894a	a2 00		ldx #$00			ldx 	#0
.01894c	5a		phy				phy 								; this is the same routine as PEEK.
.01894d	20 b7 99	jsr $0199b7			jsr 	MemRead
.018950	7a		ply				ply
.018951	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.018953	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.018955	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.018957	f0 e8		beq $018941			beq 	_CWAWaitLoop 				; and loop if zero.
.018959					_CWAWaitExit:
.018959	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.01895a					Command_RUN:
.01895a	20 e5 91	jsr $0191e5			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.01895d	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.01895f	85 18		sta $18				sta 	zCodePtr+0
.018961	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.018963	85 19		sta $19				sta 	zCodePtr+1
.018965	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.018967	85 1a		sta $1a				sta 	zCodePtr+2
.018969	85 1b		sta $1b				sta 	zCodePtr+3
.01896b	a0 03		ldy #$03			ldy 	#3
.01896d					RUN_NewLine:
.01896d	a0 00		ldy #$00			ldy 	#0
.01896f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018971	c8		iny				iny
.018972	c8		iny				iny
.018973	c8		iny				iny
.018974	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018976	d0 16		bne $01898e			bne 	RUN_NextCommand
.018978	4c 93 8d	jmp $018d93			jmp 	Command_END 				; go do the command code.
.01897b					RUN_Skip:
.01897b	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01897d	c8		iny				iny 								; skip
.01897e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018980	90 0c		bcc $01898e			bcc 	_SEDone 					; so just skip over it.
.018982	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018984	90 07		bcc $01898d			bcc 	_SEDouble
.018986	98		tya				tya 								; this is Y + 1
.018987	18		clc				clc
.018988	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01898a	a8		tay				tay 								; back in Y.
.01898b	88		dey				dey 								; fix up, one for the +1, one for the iny
.01898c	88		dey				dey
.01898d					_SEDouble:
.01898d	c8		iny				iny
.01898e					_SEDone:
.01898e					RUN_NextCommand:
.01898e	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018991	69 10		adc #$10			adc 	#16 						; one time in 16
.018993	8d a8 03	sta $03a8			sta 	BreakCount
.018996	90 0a		bcc $0189a2			bcc 	RUN_NoCheckBreak
.018998	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check for break
.01899b	c9 00		cmp #$00			cmp 	#0
.01899d	f0 03		beq $0189a2			beq 	RUN_NoCheckBreak
.01899f	4c fc 91	jmp $0191fc			jmp 	Command_STOP 				; stop on BREAK.
.0189a2					RUN_NoCheckBreak:
.0189a2	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0189a4	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.0189a6	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0189a8	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0189aa	f0 cf		beq $01897b			beq 	RUN_Skip
.0189ac	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0189ae	d0 0f		bne $0189bf			bne 	RUN_Execute
.0189b0					RUN_NextLine:
.0189b0	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0189b2	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0189b4	18		clc				clc
.0189b5	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0189b7	85 18		sta $18				sta 	zCodePtr
.0189b9	90 02		bcc $0189bd			bcc 	_SNLNoCarry
.0189bb	e6 19		inc $19				inc 	zCodePtr+1
.0189bd					_SNLNoCarry:
.0189bd	80 ae		bra $01896d			bra 	RUN_NewLine 				; go do the new line code
.0189bf					RUN_Execute:
.0189bf	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0189c1	b0 1e		bcs $0189e1			bcs 	RUN_Extension
.0189c3	c8		iny				iny
.0189c4	0a		asl a				asl 	a 							; double the character read.
.0189c5	90 14		bcc $0189db			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0189c7	aa		tax				tax 								; ready to look up.
.0189c8	bf ed 85 01	lda $0185ed,x			lda 	VectorTable,x 				; copy address into LocalVector
.0189cc	8d 11 03	sta $0311			sta 	LocalVector+1
.0189cf	bf ee 85 01	lda $0185ee,x			lda 	VectorTable+1,x
.0189d3	8d 12 03	sta $0312			sta 	LocalVector+2
.0189d6	20 36 93	jsr $019336			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0189d9	80 b3		bra $01898e			bra 	RUN_NextCommand 			; do the next command.
.0189db					RUN_Default:
.0189db	88		dey				dey
.0189dc	20 dd 8b	jsr $018bdd			jsr 	Command_LET 				; and try LET.
.0189df	80 ad		bra $01898e			bra 	RUN_NextCommand
.0189e1					RUN_Extension:
.0189e1	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0189e3	f0 96		beq $01897b			beq 	RUN_Skip 					; skip over it.
.0189e5	4c 57 85	jmp $018557			jmp 	SyntaxError
.0189e8					Command_COLON:
.0189e8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189e9					Command_FOR:
.0189e9	20 dd 8b	jsr $018bdd			jsr 	Command_LET 				; do the A = 99 bit
.0189ec	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.0189ee	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189f0	f0 71		beq $018a63			beq 	_CFOError
.0189f2	48		pha				pha 								; save the variable type.
.0189f3	5a		phy				phy 								; save type/variable address.
.0189f4	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189f6	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189f8	c8		iny				iny
.0189f9	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.0189fb	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189fd	c8		iny				iny
.0189fe	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.018a00	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a02	7a		ply				ply
.018a03	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.018a05	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018a08	a9 c8		lda #$c8			lda 	#token_TO
.018a0a	20 1e 9a	jsr $019a1e			jsr 	CheckNextToken
.018a0d	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.018a0f	20 53 92	jsr $019253			jsr 	EvaluateExpression
.018a12	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a14	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.018a16	c9 c9		cmp #$c9			cmp 	#token_STEP
.018a18	d0 06		bne $018a20			bne 	_CFOStep1
.018a1a	c8		iny				iny
.018a1b	20 55 92	jsr $019255			jsr 	EvaluateExpressionX 		; get STEP value.
.018a1e	80 0e		bra $018a2e			bra 	_CFOHaveStep
.018a20					_CFOStep1:
.018a20	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.018a22	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a24	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a26	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a28	a9 01		lda #$01			lda 	#1
.018a2a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a2c	95 85		sta $85,x			sta 	XS_Type,x
.018a2e					_CFOHaveStep:
.018a2e	68		pla				pla 								; restore variable type
.018a2f	a2 00		ldx #$00			ldx 	#0
.018a31	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.018a33	f0 0a		beq $018a3f			beq 	_CFOInteger
.018a35	20 fd a5	jsr $01a5fd			jsr 	FPUToFloat
.018a38	a2 06		ldx #$06			ldx 	#6
.018a3a	20 fd a5	jsr $01a5fd			jsr 	FPUToFloat
.018a3d	80 08		bra $018a47			bra 	_CFOEndConv
.018a3f					_CFOInteger:
.018a3f	20 49 a6	jsr $01a649			jsr 	FPUToInteger
.018a42	a2 06		ldx #$06			ldx 	#6
.018a44	20 49 a6	jsr $01a649			jsr 	FPUToInteger
.018a47					_CFOEndConv:
.018a47	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a4a	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a4c	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push the loop address frame.
.018a4f	5a		phy				phy
.018a50	a0 00		ldy #$00			ldy 	#0
.018a52					_CFOCopy:
.018a52	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a55	c8		iny				iny
.018a56	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a58	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a5a	d0 f6		bne $018a52			bne 	_CFOCopy
.018a5c	7a		ply				ply
.018a5d	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a5f	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018a62	60		rts				rts
.018a63					_CFOError:
.018a63	4c 67 85	jmp $018567			jmp 	TypeError 					; wrong type.
.018a66					Command_NEXT:
.018a66	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a68	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.018a6a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a6c	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a6e	f0 07		beq $018a77			beq 	_CNextNoVariable
.018a70	c9 40		cmp #$40			cmp 	#$40
.018a72	b0 03		bcs $018a77			bcs 	_CNextNoVariable
.018a74	20 fa 9c	jsr $019cfa			jsr 	VariableFind
.018a77					_CNextNoVariable:
.018a77	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.018a79	48		pha				pha
.018a7a	a5 29		lda $29				lda 	zBasicSP+1
.018a7c	48		pha				pha
.018a7d	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a7f	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a82	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a84	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a87	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a89	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a8c	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a8e	f0 11		beq $018aa1			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a90	5a		phy				phy 								; check addresses match.
.018a91	a0 02		ldy #$02			ldy 	#2
.018a93	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a95	c5 24		cmp $24				cmp 	zVarDataPtr
.018a97	d0 69		bne $018b02			bne 	_CNextWrong
.018a99	c8		iny				iny
.018a9a	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a9c	c5 25		cmp $25				cmp 	zVarDataPtr+1
.018a9e	d0 62		bne $018b02			bne 	_CNextWrong
.018aa0	7a		ply				ply
.018aa1					_CNextGetTarget:
.018aa1	5a		phy				phy
.018aa2	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018aa4	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aa6	85 26		sta $26				sta 	zVarType
.018aa8	c8		iny				iny
.018aa9	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aab	85 24		sta $24				sta 	zVarDataPtr
.018aad	c8		iny				iny
.018aae	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ab0	85 25		sta $25				sta 	zVarDataPtr+1
.018ab2	a2 0c		ldx #$0c			ldx 	#12
.018ab4	20 44 a0	jsr $01a044			jsr 	VariableGet 				; get that variable value into expr[2]
.018ab7	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018ab9	a0 0b		ldy #$0b			ldy 	#11
.018abb					_CNXCopy:
.018abb	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018abd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018abf	e8		inx				inx
.018ac0	c8		iny				iny
.018ac1	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018ac3	d0 f6		bne $018abb			bne 	_CNXCopy
.018ac5	7a		ply				ply
.018ac6	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018ac8	20 53 96	jsr $019653			jsr 	GetSignCurrent
.018acb	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018ace	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018ad0	20 3c 95	jsr $01953c			jsr 	BinaryOp_Add
.018ad3	20 95 a0	jsr $01a095			jsr 	VariableSet					; and write variable back.
.018ad6	a2 00		ldx #$00			ldx 	#0
.018ad8	20 c0 94	jsr $0194c0			jsr 	CompareValues
.018adb	09 00		ora #$00			ora 	#0
.018add	f0 05		beq $018ae4			beq 	_CNXAgain 					; if true, then do it again.
.018adf	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018ae2	d0 0f		bne $018af3			bne 	_CNXLoopDone
.018ae4					_CNXAgain:
.018ae4	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018ae6	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018ae9	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018aec	68		pla				pla
.018aed	85 29		sta $29				sta 	zBasicSP+1
.018aef	68		pla				pla
.018af0	85 28		sta $28				sta 	zBasicSP
.018af2					_CNXExit:
.018af2	60		rts				rts
.018af3					_CNXLoopDone:
.018af3	68		pla				pla 								; throw away saved to Basic Stack Pointer
.018af4	68		pla				pla
.018af5	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018af7	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018af9	d0 f7		bne $018af2			bne 	_CNXExit
.018afb	c8		iny				iny
.018afc	20 fa 9c	jsr $019cfa			jsr 	VariableFind 				; identify the variable
.018aff	4c 77 8a	jmp $018a77			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018b02					_CNextWrong:
.018b02	20 86 85	jsr $018586			jsr ERR_Handler
>018b05	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018b0d	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018b19					Command_READ:
.018b19	20 fa 9c	jsr $019cfa			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018b1c	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018b1e	48		pha				pha
.018b1f	a5 25		lda $25				lda 	zVarDataPtr+1
.018b21	48		pha				pha
.018b22	a5 26		lda $26				lda 	zVarType
.018b24	48		pha				pha
.018b25	20 6b 8b	jsr $018b6b			jsr 	READGetDataItem 			; get the next data item
.018b28	68		pla				pla 								; restore target variable information.
.018b29	85 26		sta $26				sta 	zVarType
.018b2b	68		pla				pla
.018b2c	85 25		sta $25				sta 	zVarDataPtr+1
.018b2e	68		pla				pla
.018b2f	85 24		sta $24				sta 	zVarDataPtr
.018b31	a2 00		ldx #$00			ldx 	#0
.018b33	20 95 a0	jsr $01a095			jsr 	VariableSet 				; set the value out.
.018b36	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b38	c8		iny				iny
.018b39	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b3b	f0 dc		beq $018b19			beq 	Command_READ 				; found, do another READ
.018b3d	88		dey				dey
.018b3e	60		rts				rts
.018b3f					Command_DATA:
.018b3f	4c 8d 84	jmp $01848d			jmp 	SkipEndOfCommand
.018b42					Command_RESTORE:
.018b42	48		pha				pha
.018b43	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018b45	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018b48	8d be 03	sta $03be			sta 	DataLPtr+1
.018b4b	68		pla				pla
.018b4c	60		rts				rts
.018b4d					READSwapPointers:
.018b4d	98		tya				tya
.018b4e	48		pha				pha 								; save it
.018b4f	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b52	a8		tay				tay
.018b53	68		pla				pla 								; get code offset and save in DataIndex
.018b54	8d c1 03	sta $03c1			sta 	DataIndex
.018b57	da		phx				phx
.018b58	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b5a					_RSWLoop:
.018b5a	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b5d	48		pha				pha
.018b5e	b5 18		lda $18,x			lda 	zCodePtr+0,x
.018b60	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b63	68		pla				pla
.018b64	95 18		sta $18,x			sta 	zCodePtr+0,x
.018b66	ca		dex				dex
.018b67	10 f1		bpl $018b5a			bpl 	_RSWLoop
.018b69	fa		plx				plx
.018b6a	60		rts				rts
.018b6b					READGetDataItem:
.018b6b	20 4d 8b	jsr $018b4d			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b6e	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.018b70	05 19		ora $19				ora 	zCodePtr+1
.018b72	d0 12		bne $018b86			bne 	_RGDIIsInitialised
.018b74	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018b76	85 18		sta $18				sta 	zCodePtr+0
.018b78	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.018b7a	85 19		sta $19				sta 	zCodePtr+1
.018b7c	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.018b7e	85 1a		sta $1a				sta 	zCodePtr+2
.018b80	85 1b		sta $1b				sta 	zCodePtr+3
.018b82	a0 03		ldy #$03			ldy 	#3
.018b84	80 06		bra $018b8c			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b86					_RGDIIsInitialised:
.018b86	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b88	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b8a	f0 49		beq $018bd5			beq 	_RGDISkipEvaluateExit
.018b8c					_RGDIFindData:
.018b8c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b8e	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b90	f0 19		beq $018bab			beq 	_RGDIFindNextLine
.018b92	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b94	f0 3f		beq $018bd5			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b96	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018b98	c8		iny				iny 								; skip
.018b99	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b9b	90 0c		bcc $018ba9			bcc 	_SEDone 					; so just skip over it.
.018b9d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b9f	90 07		bcc $018ba8			bcc 	_SEDouble
.018ba1	98		tya				tya 								; this is Y + 1
.018ba2	18		clc				clc
.018ba3	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018ba5	a8		tay				tay 								; back in Y.
.018ba6	88		dey				dey 								; fix up, one for the +1, one for the iny
.018ba7	88		dey				dey
.018ba8					_SEDouble:
.018ba8	c8		iny				iny
.018ba9					_SEDone:
.018ba9	80 e1		bra $018b8c			bra 	_RGDIFindData
.018bab					_RGDIFindNextLine:
.018bab	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018bad	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018baf	18		clc				clc
.018bb0	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018bb2	85 18		sta $18				sta 	zCodePtr
.018bb4	90 02		bcc $018bb8			bcc 	_SNLNoCarry
.018bb6	e6 19		inc $19				inc 	zCodePtr+1
.018bb8					_SNLNoCarry:
.018bb8	a0 00		ldy #$00			ldy 	#0
.018bba	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018bbc	48		pha				pha
.018bbd	c8		iny				iny
.018bbe	c8		iny				iny
.018bbf	c8		iny				iny
.018bc0	68		pla				pla
.018bc1	d0 c9		bne $018b8c			bne 	_RGDIFindData 				; back to scanning.
.018bc3	20 4d 8b	jsr $018b4d			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018bc6	20 86 85	jsr $018586			jsr ERR_Handler
>018bc9	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018bd1	61 74 61 00
.018bd5					_RGDISkipEvaluateExit:
.018bd5	c8		iny				iny
.018bd6	20 53 92	jsr $019253			jsr 	EvaluateExpression 			; evaluate the expression
.018bd9	20 4d 8b	jsr $018b4d			jsr 	ReadSwapPointers 			; swap the pointers around.
.018bdc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018bdd					Command_LET:
.018bdd	20 fa 9c	jsr $019cfa			jsr 	VariableFind 				; get reference to one variable.
.018be0	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018be2	20 1e 9a	jsr $019a1e			jsr 	CheckNextToken
.018be5	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018be7	48		pha				pha
.018be8	a5 25		lda $25				lda 	zVarDataPtr+1
.018bea	48		pha				pha
.018beb	a5 26		lda $26				lda 	zVarType
.018bed	48		pha				pha
.018bee	20 53 92	jsr $019253			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018bf1	68		pla				pla 								; restore target variable information.
.018bf2	85 26		sta $26				sta 	zVarType
.018bf4	68		pla				pla
.018bf5	85 25		sta $25				sta 	zVarDataPtr+1
.018bf7	68		pla				pla
.018bf8	85 24		sta $24				sta 	zVarDataPtr
.018bfa	20 95 a0	jsr $01a095			jsr 	VariableSet 				; set the value out.
.018bfd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018bfe					Command_GET:
.018bfe					_CGLoop:
.018bfe	20 fa 9c	jsr $019cfa			jsr 	VariableFind 				; get a variable.
.018c01	20 42 85	jsr $018542			jsr 	VIOCharGet 					; get character
.018c04	b0 02		bcs $018c08			bcs 	_CGNoKey
.018c06	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018c08					_CGNoKey:
.018c08	48		pha				pha
.018c09	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.018c0b	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018c0d	f0 1e		beq $018c2d			beq 	_CGString
.018c0f	68		pla				pla 								; put character in slot.
.018c10	85 80		sta $80				sta 	XS_Mantissa
.018c12	a9 00		lda #$00			lda 	#0
.018c14	85 81		sta $81				sta 	XS_Mantissa+1
.018c16	85 82		sta $82				sta 	XS_Mantissa+2
.018c18	85 83		sta $83				sta 	XS_Mantissa+3
.018c1a	a9 01		lda #$01			lda 	#1 							; type integer
.018c1c	85 85		sta $85				sta 	XS_Type
.018c1e					_CGWriteSetNext:
.018c1e	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018c20	20 95 a0	jsr $01a095			jsr 	VariableSet
.018c23	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c25	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018c27	d0 03		bne $018c2c			bne 	_CGExit
.018c29	c8		iny				iny
.018c2a	80 d2		bra $018bfe			bra 	_CGLoop 					; and get another.
.018c2c					_CGExit:
.018c2c	60		rts				rts
.018c2d					_CGString:
.018c2d	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018c2f	20 82 9a	jsr $019a82			jsr 	AllocateTempString 			; initially empty.
.018c32	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.018c34	85 80		sta $80				sta 	XS_Mantissa
.018c36	a5 23		lda $23				lda 	zTempStr+1
.018c38	85 81		sta $81				sta 	XS_Mantissa+1
.018c3a	a9 02		lda #$02			lda 	#2
.018c3c	85 85		sta $85				sta 	XS_Type
.018c3e	68		pla				pla 								; get A
.018c3f	c9 00		cmp #$00			cmp 	#0
.018c41	f0 db		beq $018c1e			beq 	_CGWriteSetNext
.018c43	20 ad 9a	jsr $019aad			jsr 	WriteTempString 			; write it into string
.018c46	80 d6		bra $018c1e			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018c48					Command_SYS:
.018c48	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; address to call.
.018c4b	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c4d	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c50	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c52	8d 11 03	sta $0311			sta 	LocalVector+1
.018c55	a5 82		lda $82				lda 	XS_Mantissa+2
.018c57	8d 12 03	sta $0312			sta 	LocalVector+2
.018c5a	22 5f 8c 01	jsl $018c5f			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c5e	60		rts				rts
.018c5f					_CSYLocalCall:
.018c5f	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c62					Command_INPUT:
.018c62	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c64	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c67	8d c3 03	sta $03c3		sta 	InputRetry
.018c6a					_CILoop:
.018c6a	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c6c	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.018c6e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c70	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c72	d0 15		bne $018c89		bne 	_CINoPrompt
.018c74	c8		iny				iny
.018c75	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c77	aa		tax			tax 									; into X
.018c78	c8		iny				iny
.018c79	ca		dex			dex 									; deduct marker/prompt length
.018c7a	ca		dex			dex
.018c7b	f0 ed		beq $018c6a		beq 	_CILoop 						; nothing.
.018c7d					_CIShowPrompt:
.018c7d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c7f	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018c82	c8		iny				iny
.018c83	ca		dex			dex
.018c84	d0 f7		bne $018c7d		bne 	_CIShowPrompt
.018c86	80 e2		bra $018c6a		bra 	_CILoop
.018c88					_CIAdvance:
.018c88	c8		iny				iny
.018c89					_CINoPrompt:
.018c89	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c8b	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c8d	f0 f9		beq $018c88		beq 	_CIAdvance
.018c8f	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c91	f0 f5		beq $018c88		beq 	_CIAdvance
.018c93	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c95	f0 04		beq $018c9b		beq 	_CIExit
.018c97	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c99	d0 01		bne $018c9c		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c9b					_CIExit:
.018c9b	60		rts			rts
.018c9c					_CIIsVariable:
.018c9c	20 fa 9c	jsr $019cfa		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c9f	a5 26		lda $26			lda 	zVarType
.018ca1	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018ca3	f0 40		beq $018ce5		beq 	_CIIsString
.018ca5					_CINGetText:
.018ca5	a9 00		lda #$00		lda 	#0
.018ca7	8d 14 03	sta $0314		sta 	NumBufX
.018caa					_CINSkip:
.018caa	20 44 8d	jsr $018d44		jsr 	CIGetCharacter 					; get character skip spaces
.018cad	c9 20		cmp #$20		cmp 	#" "
.018caf	f0 f9		beq $018caa		beq 	_CINSkip
.018cb1	c9 2c		cmp #$2c		cmp 	#","
.018cb3	f0 f5		beq $018caa		beq 	_CINSkip
.018cb5					_CINLoop:
.018cb5	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018cb8	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018cbb	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018cbd	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018cc0	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018cc3	20 44 8d	jsr $018d44		jsr 	CIGetCharacter 					; get next character
.018cc6	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018cc8	f0 08		beq $018cd2		beq 	_CINCopied
.018cca	c9 2c		cmp #$2c		cmp 	#","
.018ccc	f0 04		beq $018cd2		beq 	_CINCopied
.018cce	c9 21		cmp #$21		cmp 	#" "+1
.018cd0	b0 e3		bcs $018cb5		bcs 	_CINLoop
.018cd2					_CINCopied:
.018cd2	a2 00		ldx #$00		ldx 	#0
.018cd4	20 62 97	jsr $019762		jsr 	ConvertNumBuffer 				; convert number
.018cd7	b0 05		bcs $018cde		bcs 	_CINFailed 						; didn't work.
.018cd9	20 95 a0	jsr $01a095		jsr 	VariableSet 					; set variable.
.018cdc	80 8c		bra $018c6a		bra 	_CILoop 						; go round again.
.018cde					_CINFailed:
.018cde	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018ce0	8d c2 03	sta $03c2		sta 	InputAvailable
.018ce3	80 c0		bra $018ca5		bra 	_CINGetText 					; and try again
.018ce5					_CIIsString:
.018ce5	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.018ce7	20 82 9a	jsr $019a82		jsr 	AllocateTempString
.018cea	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.018cec	8d 14 03	sta $0314		sta 	NumBufX
.018cef					_CISSkip:
.018cef	20 44 8d	jsr $018d44		jsr 	CIGetCharacter 					; get character skip spaces
.018cf2	c9 20		cmp #$20		cmp 	#" "
.018cf4	f0 f9		beq $018cef		beq 	_CISSkip
.018cf6	80 03		bra $018cfb		bra 	_CISInputProcess 				; handle that as the first character
.018cf8					_CISInput:
.018cf8	20 44 8d	jsr $018d44		jsr 	CIGetCharacter
.018cfb					_CISInputProcess:
.018cfb	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.018cfd	f0 31		beq $018d30		beq 	_CISDone
.018cff	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.018d01	d0 05		bne $018d08		bne 	_CISNotColon
.018d03	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.018d06	10 28		bpl $018d30		bpl 	_CISDone 						; if quote flag zero, done
.018d08					_CISNotColon:
.018d08	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.018d0a	f0 1a		beq $018d26		beq 	_CISIsQuote						; if so handle that code.
.018d0c	20 ad 9a	jsr $019aad		jsr 	WriteTempString 				; write to the temporary string
.018d0f	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.018d12	10 e4		bpl $018cf8		bpl 	_CISInput
.018d14	20 86 85	jsr $018586			jsr ERR_Handler
>018d17	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>018d1f	6f 20 6c 6f 6e 67 00
.018d26					_CISIsQuote:
.018d26	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.018d29	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.018d2b	8d 14 03	sta $0314		sta 	NumBufX
.018d2e	d0 c8		bne $018cf8		bne 	_CISInput 						; if entered quote mode, get next character
.018d30					_CISDone:
.018d30	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.018d32	85 80		sta $80			sta 	XS_Mantissa+0
.018d34	a5 23		lda $23			lda 	zTempStr+1
.018d36	85 81		sta $81			sta 	XS_Mantissa+1
.018d38	a9 02		lda #$02		lda 	#2
.018d3a	85 85		sta $85			sta 	XS_Type
.018d3c	a2 00		ldx #$00		ldx 	#0
.018d3e	20 95 a0	jsr $01a095		jsr 	VariableSet 					; set variable.
.018d41	4c 6a 8c	jmp $018c6a		jmp 	_CILoop 						; and try again
.018d44					CIGetCharacter:
.018d44	5a		phy			phy
.018d45	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018d48	f0 0c		beq $018d56		beq 	_CIGCNewLine 					; no, needs a new line.
.018d4a	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018d4d	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018d4f	f0 03		beq $018d54		beq 	_CIGCNoInc
.018d51	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018d54					_CIGCNoInc:
.018d54	7a		ply			ply
.018d55	60		rts			rts
.018d56					_CIGCNewLine:
.018d56	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018d59	a9 3f		lda #$3f		lda 	#"?"
.018d5b	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d5e	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018d61	f0 03		beq $018d66		beq 	_CIGCPrompt 					; if so, then print ? again
.018d63	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d66					_CIGCPrompt:
.018d66	a0 01		ldy #$01		ldy 	#1
.018d68	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018d6b					_CIGCBackOne:
.018d6b	88		dey			dey
.018d6c					_CIGCLoop:
.018d6c	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018d6e	f0 fb		beq $018d6b		beq 	_CIGCBackOne
.018d70	20 42 85	jsr $018542		jsr 	VIOCharGet 						; get a character
.018d73	f0 f7		beq $018d6c		beq 	_CIGCLoop 						; wait until key pressed
.018d75	c9 08		cmp #$08		cmp 	#8 								; backspace
.018d77	f0 10		beq $018d89		beq 	_CIGCBackSpace
.018d79	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo character
.018d7c	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018d7f	c8		iny			iny
.018d80	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018d82	d0 e8		bne $018d6c		bne 	_CIGCLoop
.018d84	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018d87	7a		ply			ply 									; restore Y
.018d88	60		rts			rts
.018d89					_CIGCBackSpace:
.018d89	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018d8b	f0 df		beq $018d6c		beq 	_CIGCLoop
.018d8d	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo BS
.018d90	88		dey			dey 									; go back one.
.018d91	80 d9		bra $018d6c		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018d93					Command_END:
.018d93	4c 4d 88	jmp $01884d			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018d96					Command_IF:
.018d96	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; check success.
.018d99	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018d9b	05 81		ora $81				ora 	XS_Mantissa+1
.018d9d	05 82		ora $82				ora 	XS_Mantissa+2
.018d9f	05 83		ora $83				ora 	XS_Mantissa+3
.018da1	aa		tax				tax 								; put into X.
.018da2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018da4	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018da6	d0 2c		bne $018dd4			bne 	_FIFExtended
.018da8	c8		iny				iny
.018da9	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018dab	f0 0b		beq $018db8			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018dad	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018daf	29 c0		and #$c0			and 	#$C0 						; is it a number
.018db1	c9 40		cmp #$40			cmp 	#$40
.018db3	d0 1e		bne $018dd3			bne 	_FIFContinue 				; if not, do what ever follows.
.018db5	4c 23 91	jmp $019123			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018db8					_FIFEndOfLine:
.018db8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dba	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018dbc	f0 15		beq $018dd3			beq 	_FIFContinue
.018dbe	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018dc0	c8		iny				iny 								; skip
.018dc1	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018dc3	90 0c		bcc $018dd1			bcc 	_SEDone 					; so just skip over it.
.018dc5	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018dc7	90 07		bcc $018dd0			bcc 	_SEDouble
.018dc9	98		tya				tya 								; this is Y + 1
.018dca	18		clc				clc
.018dcb	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018dcd	a8		tay				tay 								; back in Y.
.018dce	88		dey				dey 								; fix up, one for the +1, one for the iny
.018dcf	88		dey				dey
.018dd0					_SEDouble:
.018dd0	c8		iny				iny
.018dd1					_SEDone:
.018dd1	80 e5		bra $018db8			bra 	_FIFEndOfLine
.018dd3					_FIFContinue:
.018dd3	60		rts				rts
.018dd4					_FIFExtended:
.018dd4	da		phx				phx 								; save result
.018dd5	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018dd7	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018dda	68		pla				pla 								; restore result
.018ddb	f0 01		beq $018dde			beq 	_FIXSkip 					; if zero then it has failed.
.018ddd	60		rts				rts 								; test passed, so continue executing
.018dde					_FIXSkip:
.018dde	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018de0	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018de2	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018de5	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018de7	c8		iny				iny
.018de8	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018dea	f0 07		beq $018df3			beq 	Command_ENDIF
.018dec	60		rts				rts
.018ded					Command_ELSE:
.018ded	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018def	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018df2	c8		iny				iny
.018df3					Command_ENDIF:
.018df3	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018df5	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018df8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018df9					Command_LIST:
.018df9	20 86 8f	jsr $018f86			jsr 	ListGetRange				; get any parameters
.018dfc	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018dfe	85 18		sta $18				sta 	zCodePtr+0
.018e00	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.018e02	85 19		sta $19				sta 	zCodePtr+1
.018e04	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.018e06	85 1a		sta $1a				sta 	zCodePtr+2
.018e08	85 1b		sta $1b				sta 	zCodePtr+3
.018e0a	a0 03		ldy #$03			ldy 	#3
.018e0c	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018e0e	8d bc 03	sta $03bc			sta 	LastListIndent
.018e11	8d bb 03	sta $03bb			sta 	ListIndent
.018e14					_CILLoop:
.018e14	a0 00		ldy #$00			ldy 	#0
.018e16	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e18	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018e1a	f0 23		beq $018e3f			beq 	_CILExit
.018e1c	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check break
.018e1f	c9 00		cmp #$00			cmp 	#0
.018e21	d0 1c		bne $018e3f			bne 	_CILExit
.018e23	20 cd 8f	jsr $018fcd			jsr 	ListCheckRange 				; check current line in range.
.018e26	b0 08		bcs $018e30			bcs		_CILNext
.018e28	a0 00		ldy #$00			ldy 	#0
.018e2a	c8		iny				iny
.018e2b	c8		iny				iny
.018e2c	c8		iny				iny
.018e2d	20 42 8e	jsr $018e42			jsr 	ListLine 					; list one line.
.018e30					_CILNext:
.018e30	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018e32	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018e34	18		clc				clc
.018e35	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018e37	85 18		sta $18				sta 	zCodePtr
.018e39	90 02		bcc $018e3d			bcc 	_SNLNoCarry
.018e3b	e6 19		inc $19				inc 	zCodePtr+1
.018e3d					_SNLNoCarry:
.018e3d	80 d5		bra $018e14			bra 	_CILLoop
.018e3f					_CILExit:
.018e3f	4c 4d 88	jmp $01884d			jmp 	WarmStart
.018e42					ListLine:
.018e42	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018e45	8d bc 03	sta $03bc			sta 	LastListIndent
.018e48					_LICountIndent:
.018e48	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e4a	c9 00		cmp #$00			cmp 	#0
.018e4c	f0 2f		beq $018e7d			beq 	_LIDoneIndent
.018e4e	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018e50	90 16		bcc $018e68			bcc 	_LICINext
.018e52	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e54	b0 12		bcs $018e68			bcs 	_LICINext
.018e56	ee bb 03	inc $03bb			inc 	ListIndent
.018e59	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018e5b	90 0b		bcc $018e68			bcc 	_LICINext
.018e5d	ce bb 03	dec $03bb			dec 	ListIndent
.018e60	ce bb 03	dec $03bb			dec 	ListIndent
.018e63	10 03		bpl $018e68			bpl 	_LICINext
.018e65	ee bb 03	inc $03bb			inc 	ListIndent
.018e68					_LICINext:
.018e68	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018e6a	c8		iny				iny 								; skip
.018e6b	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018e6d	90 0c		bcc $018e7b			bcc 	_SEDone 					; so just skip over it.
.018e6f	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018e71	90 07		bcc $018e7a			bcc 	_SEDouble
.018e73	98		tya				tya 								; this is Y + 1
.018e74	18		clc				clc
.018e75	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018e77	a8		tay				tay 								; back in Y.
.018e78	88		dey				dey 								; fix up, one for the +1, one for the iny
.018e79	88		dey				dey
.018e7a					_SEDouble:
.018e7a	c8		iny				iny
.018e7b					_SEDone:
.018e7b	80 cb		bra $018e48			bra 	_LICountIndent
.018e7d					_LIDoneIndent:
.018e7d	a0 00		ldy #$00			ldy 	#0
.018e7f	c8		iny				iny
.018e80	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e82	85 80		sta $80				sta 	XS_Mantissa
.018e84	c8		iny				iny
.018e85	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e87	85 81		sta $81				sta 	XS_Mantissa+1
.018e89	20 cf 85	jsr $0185cf			jsr 	Print16BitInteger 			; print integer.
.018e8c	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018e8e	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018e91	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018e94	90 03		bcc $018e99			bcc 	_LISmaller
.018e96	ad bc 03	lda $03bc			lda 	LastListIndent
.018e99					_LISmaller:
.018e99	0a		asl a				asl 	a 							; double indent
.018e9a	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018e9c	38		sec				sec
.018e9d	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018e9f	aa		tax				tax 								; print spaces to column 6
.018ea0					_LISpace:
.018ea0	a9 20		lda #$20			lda 	#" "
.018ea2	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018ea5	e8		inx				inx
.018ea6	e0 06		cpx #$06			cpx 	#6
.018ea8	d0 f6		bne $018ea0			bne 	_LISpace
.018eaa					_LIDecode:
.018eaa	c8		iny				iny
.018eab	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ead	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018eaf	f0 0f		beq $018ec0			beq 	_LIExit
.018eb1	30 12		bmi $018ec5			bmi 	_LIToken
.018eb3	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018eb5	b0 50		bcs $018f07			bcs 	_LIInteger
.018eb7	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018eb9	69 20		adc #$20			adc 	#$20
.018ebb	20 76 8f	jsr $018f76			jsr 	ListPrintLC 				; print in LC
.018ebe	80 ea		bra $018eaa			bra 	_LIDecode
.018ec0					_LIExit:
.018ec0	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018ec2	4c 76 8f	jmp $018f76			jmp 	ListPrintLC
.018ec5					_LIToken:
.018ec5	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018ec7	90 49		bcc $018f12			bcc		_LICommandToken
.018ec9	48		pha				pha 								; save in case end
.018eca	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018ecc	c9 fe		cmp #$fe			cmp 	#$FE
.018ece	f0 17		beq $018ee7			beq 	_LIPrint
.018ed0	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018ed2	c9 fd		cmp #$fd			cmp 	#$FD
.018ed4	f0 11		beq $018ee7			beq 	_LIPrint
.018ed6	a9 52		lda #$52			lda 	#'R'						; must be REM
.018ed8	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018edb	a9 45		lda #$45			lda 	#'E'
.018edd	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018ee0	a9 4d		lda #$4d			lda 	#'M'
.018ee2	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018ee5	a2 20		ldx #$20			ldx 	#' '
.018ee7					_LIPrint:
.018ee7	8a		txa				txa
.018ee8	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018eeb	c8		iny				iny
.018eec	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018eee	aa		tax				tax 								; put in X
.018eef	ca		dex				dex
.018ef0					_LILoop:
.018ef0	ca		dex				dex 								; exit when count reached zero.
.018ef1	f0 08		beq $018efb			beq 	_LIEnd
.018ef3	c8		iny				iny
.018ef4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ef6	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018ef9	80 f5		bra $018ef0			bra 	_LILoop
.018efb	68		pla		_LIEnd:	pla 								; get A back
.018efc	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018efe	d0 aa		bne $018eaa			bne 	_LIDecode
.018f00	a9 22		lda #$22			lda 	#'"'
.018f02	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018f05	80 a3		bra $018eaa			bra 	_LIDecode
.018f07					_LIInteger:
.018f07	a2 00		ldx #$00			ldx 	#0
.018f09	20 5b 93	jsr $01935b			jsr 	EvaluateGetInteger 			; get an atom
.018f0c	88		dey				dey
.018f0d	20 d5 85	jsr $0185d5			jsr 	Print32BitInteger 			; print integer.
.018f10	80 98		bra $018eaa			bra 	_LIDecode
.018f12					_LICommandToken:
.018f12	5a		phy				phy 								; save Y
.018f13	48		pha				pha 								; save token
.018f14	a2 cd		ldx #$cd			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018f16	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018f18	86 1c		stx $1c				stx 	zLTemp1
.018f1a	85 1d		sta $1d				sta 	zLTemp1+1
.018f1c	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018f1e	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018f20	68		pla				pla 								; get token
.018f21	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018f23	f0 16		beq $018f3b			beq 	_LIFoundToken
.018f25	aa		tax				tax
.018f26					_LITokenLoop:
.018f26	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018f28					_LIFindEnd:
.018f28	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f2a	c8		iny				iny
.018f2b	0a		asl a				asl 	a
.018f2c	90 fa		bcc $018f28			bcc 	_LIFindEnd
.018f2e	98		tya				tya 								; that is step to the next
.018f2f	18		clc				clc 								; we don't bother bumping the 3rd byte
.018f30	65 1c		adc $1c				adc 	zLTemp1 					; here.
.018f32	85 1c		sta $1c				sta 	zLTemp1
.018f34	90 02		bcc $018f38			bcc 	_LINoBump
.018f36	e6 1d		inc $1d				inc 	zLTemp1+1
.018f38					_LINoBump:
.018f38	ca		dex				dex 								; no go round again.
.018f39	d0 eb		bne $018f26			bne 	_LITokenLoop
.018f3b					_LIFoundToken:
.018f3b	a0 00		ldy #$00			ldy 	#0
.018f3d					_LIPrintToken:
.018f3d	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f3f	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018f41	d0 16		bne $018f59			bne 	_LINoPrefixSpace
.018f43	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018f45	90 12		bcc $018f59			bcc 	_LINoPrefixSpace
.018f47	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f49	b0 0e		bcs $018f59			bcs 	_LINoPrefixSpace
.018f4b	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018f4e	e0 20		cpx #$20			cpx 	#" "
.018f50	f0 07		beq $018f59			beq 	_LINoPrefixSpace
.018f52	48		pha				pha
.018f53	a9 20		lda #$20			lda 	#" "
.018f55	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018f58	68		pla				pla
.018f59					_LINoPrefixSpace:
.018f59	c8		iny				iny
.018f5a	48		pha				pha 								; save it
.018f5b	29 7f		and #$7f			and 	#$7F
.018f5d	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018f60	68		pla				pla
.018f61	10 da		bpl $018f3d			bpl 	_LIPrintToken 				; go back if not end
.018f63	7a		ply				ply 								; restore Y
.018f64	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018f66	c9 41		cmp #$41			cmp 	#"A"
.018f68	90 09		bcc $018f73			bcc 	_LINotLetter2
.018f6a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f6c	b0 05		bcs $018f73			bcs 	_LINotLetter2
.018f6e	a9 20		lda #$20			lda 	#" " 						; add spacing
.018f70	20 76 8f	jsr $018f76			jsr 	ListPrintLC
.018f73					_LINotLetter2:
.018f73	4c aa 8e	jmp $018eaa			jmp 	_LIDecode
.018f76					ListPrintLC:
.018f76	8d ba 03	sta $03ba			sta 	LastPrinted
.018f79	c9 41		cmp #$41			cmp 	#"A"
.018f7b	90 06		bcc $018f83			bcc 	_LPLC0
.018f7d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f7f	b0 02		bcs $018f83			bcs 	_LPLC0
.018f81	69 20		adc #$20			adc 	#$20
.018f83	4c 3f 85	jmp $01853f	_LPLC0:	jmp 	VIOCharPrint
.018f86					ListGetRange:
.018f86	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018f88					_LGRClear:
.018f88	a9 00		lda #$00			lda 	#0
.018f8a	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f8c	ca		dex				dex
.018f8d	10 f9		bpl $018f88			bpl 	_LGRClear
.018f8f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f91	c9 00		cmp #$00			cmp 	#0 							; nothing
.018f93	f0 21		beq $018fb6			beq 	_LGRBlank
.018f95	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018f97	f0 1d		beq $018fb6			beq 	_LGRBlank
.018f99	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018f9b	f0 18		beq $018fb5			beq 	_LGREnd 					; then it's LIST ,x
.018f9d	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; get the first number into bottom
.018fa0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fa2	c9 bf		cmp #$bf			cmp 	#token_Comma
.018fa4	f0 0f		beq $018fb5			beq 	_LGREnd 					; then it is LIST a,b
.018fa6	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018fa8	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018faa	a5 81		lda $81				lda 	XS_Mantissa+1
.018fac	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fae					_LGRBumpExit:
.018fae	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018fb0	d0 02		bne $018fb4			bne 	_LGRBump2
.018fb2	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018fb4					_LGRBump2:
.018fb4	60		rts				rts
.018fb5					_LGREnd:
.018fb5	c8		iny				iny
.018fb6					_LGRBlank:
.018fb6	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018fb8	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018fba	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fbc	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fbe	c9 00		cmp #$00			cmp 	#0
.018fc0	f0 f2		beq $018fb4			beq 	_LGRBump2
.018fc2	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018fc3	b0 ef		bcs $018fb4			bcs 	_LGRBump2
.018fc5	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018fc7	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX
.018fca	80 e2		bra $018fae			bra 	_LGRBumpExit
.018fcc	60		rts				rts
.018fcd					ListCheckRange:
.018fcd	c8		iny				iny
.018fce	a2 00		ldx #$00			ldx 	#0 							; test low
.018fd0	20 dd 8f	jsr $018fdd			jsr 	_LCRCompare
.018fd3	90 06		bcc $018fdb			bcc 	_LCRFail
.018fd5	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018fd7	20 dd 8f	jsr $018fdd			jsr 	_LCRCompare
.018fda	60		rts				rts
.018fdb					_LCRFail:
.018fdb	38		sec				sec
.018fdc	60		rts				rts
.018fdd					_LCRCompare:
.018fdd	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fdf	38		sec				sec
.018fe0	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018fe2	08		php				php
.018fe3	c8		iny				iny
.018fe4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fe6	28		plp				plp
.018fe7	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018fe9	08		php				php
.018fea	88		dey				dey
.018feb	28		plp				plp
.018fec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018fed					Command_PRINT:
.018fed					_CPR_Loop:
.018fed	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fef	c9 00		cmp #$00			cmp 	#0 							; end
.018ff1	f0 25		beq $019018			beq 	_CPR_GoNewLine
.018ff3	c9 c0		cmp #$c0			cmp 	#token_Colon
.018ff5	f0 21		beq $019018			beq 	_CPR_GoNewLine
.018ff7	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018ff9	f0 75		beq $019070			beq 	_CPR_Skip
.018ffb	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ffd	f0 58		beq $019057			beq 	_CPR_Tab
.018fff	20 53 92	jsr $019253			jsr 	EvaluateExpression 			; get expression.
.019002	a5 85		lda $85				lda 	XS_Type 					; get type.
.019004	29 02		and #$02			and 	#2
.019006	d0 28		bne $019030			bne 	_CPR_String 				; if type = 2 output as string.
.019008					_CPR_Number:
.019008	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01900a	8d 14 03	sta $0314			sta 	NumBufX
.01900d	aa		tax				tax
.01900e	a5 85		lda $85				lda 	XS_Type 					; get type
.019010	4a		lsr a				lsr 	a
.019011	b0 08		bcs $01901b			bcs 	_CPRInt 					; if msb set do as integer
.019013	20 48 a7	jsr $01a748			jsr 	FPToString 					; do the floa
.019016	80 06		bra $01901e			bra 	_CPRNPrint
.019018					_CPR_GoNewLine:
.019018	4c 7e 90	jmp $01907e			jmp 	_CPR_NewLine
.01901b					_CPRInt:
.01901b	20 de a1	jsr $01a1de			jsr 	IntToString
.01901e					_CPRNPrint:
.01901e	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.019021	c9 2d		cmp #$2d			cmp 	#"-"
.019023	f0 05		beq $01902a			beq 	_CPRNoSpace
.019025	a9 20		lda #$20			lda 	#" "						; print the leading space
.019027	20 3f 85	jsr $01853f			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.01902a					_CPRNoSpace:
.01902a	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.01902c	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.01902e	80 04		bra $019034			bra 	_CPRPrint
.019030					_CPR_String:
.019030	a6 80		ldx $80				ldx 	XS_Mantissa
.019032	a5 81		lda $81				lda 	XS_Mantissa+1
.019034					_CPRPrint:
.019034	86 20		stx $20				stx 	zGenPtr
.019036	85 21		sta $21				sta 	zGenPtr+1
.019038	5a		phy				phy
.019039	a0 00		ldy #$00			ldy 	#0							; get length into X
.01903b	b1 20		lda ($20),y			lda 	(zGenPtr),y
.01903d	aa		tax				tax
.01903e	f0 09		beq $019049			beq 	_CPREndPrint 				; nothing to print
.019040					_CPRLoop:
.019040	c8		iny				iny
.019041	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019043	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019046	ca		dex				dex
.019047	d0 f7		bne $019040			bne 	_CPRLoop
.019049					_CPREndPrint:
.019049	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.01904b	29 02		and #$02			and 	#2
.01904d	d0 05		bne $019054			bne 	_CPRNoTrail
.01904f	a9 20		lda #$20			lda 	#" "
.019051	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019054					_CPRNoTrail:
.019054	7a		ply				ply
.019055	80 96		bra $018fed			bra 	_CPR_Loop
.019057					_CPR_Tab:
.019057	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.01905a					_CPR_CalcSpaces:
.01905a	38		sec				sec 								; calculate position mod 10.
.01905b	e9 0a		sbc #$0a			sbc 	#10
.01905d	b0 fb		bcs $01905a			bcs 	_CPR_CalcSpaces
.01905f	69 0a		adc #$0a			adc 	#10
.019061	f0 0d		beq $019070			beq 	_CPR_Skip 					; nothing to print
.019063	aa		tax				tax 								; print out spaces to mod 10
.019064					_CPRTabSpaces:
.019064	a9 20		lda #$20			lda 	#" "
.019066	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019069	e8		inx				inx
.01906a	e0 0a		cpx #$0a			cpx 	#10
.01906c	d0 f6		bne $019064			bne 	_CPRTabSpaces
.01906e	80 e7		bra $019057			bra 	_CPR_Tab
.019070					_CPR_Skip:
.019070	c8		iny				iny
.019071	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019073	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.019075	f0 0c		beq $019083			beq 	_CPR_Exit
.019077	c9 00		cmp #$00			cmp 	#0
.019079	f0 08		beq $019083			beq 	_CPR_Exit 					; if not go round again.
.01907b	4c ed 8f	jmp $018fed			jmp 	_CPR_Loop
.01907e					_CPR_NewLine:
.01907e	a9 0d		lda #$0d			lda 	#13
.019080	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019083					_CPR_Exit:
.019083	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.019084					Command_ASSERT:
.019084	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.019087	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.019089	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01908b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01908d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01908f	f0 01		beq $019092			beq 	_ASFail
.019091	60		rts				rts
.019092					_ASFail:
.019092	20 86 85	jsr $018586			jsr ERR_Handler
>019095	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.01909c					Command_POKE:
.01909c	a9 01		lda #$01			lda 	#1 							; 1 byte
.01909e	80 06		bra $0190a6			bra 	CmdPoke_Main
.0190a0					Command_DOKE:
.0190a0	a9 02		lda #$02			lda 	#2 							; 2 bytes
.0190a2	80 02		bra $0190a6			bra 	CmdPoke_Main
.0190a4					Command_LOKE:
.0190a4	a9 04		lda #$04			lda 	#4							; 4 bytes
.0190a6					CmdPoke_Main:
.0190a6	48		pha				pha
.0190a7	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; get two parameters. First is address
.0190aa	e8		inx				inx
.0190ab	e8		inx				inx
.0190ac	e8		inx				inx
.0190ad	e8		inx				inx
.0190ae	e8		inx				inx
.0190af	e8		inx				inx
.0190b0	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma
.0190b3	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX 			; second is the data.
.0190b6	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.0190b8	85 1c		sta $1c				sta 	zLTemp1
.0190ba	a5 81		lda $81				lda 	XS_Mantissa+1
.0190bc	85 1d		sta $1d				sta 	zLTemp1+1
.0190be	a5 82		lda $82				lda 	XS_Mantissa+2
.0190c0	85 1e		sta $1e				sta 	zLTemp1+2
.0190c2	a5 83		lda $83				lda 	XS_Mantissa+3
.0190c4	85 1f		sta $1f				sta 	zLTemp1+3
.0190c6	68		pla				pla 								; get count
.0190c7	5a		phy				phy 								; save Y
.0190c8	20 c8 99	jsr $0199c8			jsr 	MemWrite 					; write it out
.0190cb	7a		ply				ply 								; restore Y and done.
.0190cc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.0190cd					Command_NEW:
.0190cd	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190cf	85 18		sta $18				sta 	zCodePtr+0
.0190d1	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.0190d3	85 19		sta $19				sta 	zCodePtr+1
.0190d5	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.0190d7	85 1a		sta $1a				sta 	zCodePtr+2
.0190d9	85 1b		sta $1b				sta 	zCodePtr+3
.0190db	a0 03		ldy #$03			ldy 	#3
.0190dd	a0 00		ldy #$00			ldy 	#0
.0190df	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.0190e1	97 18		sta [$18],y			sta 	[zCodePtr],y
.0190e3	20 d9 99	jsr $0199d9			jsr 	UpdateProgramEnd 			; update program end.
.0190e6	4c 4d 88	jmp $01884d			jmp 	WarmStart 					; and always warmstart, can't be running program.
.0190e9					Command_OLD:
.0190e9	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190eb	85 18		sta $18				sta 	zCodePtr+0
.0190ed	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.0190ef	85 19		sta $19				sta 	zCodePtr+1
.0190f1	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.0190f3	85 1a		sta $1a				sta 	zCodePtr+2
.0190f5	85 1b		sta $1b				sta 	zCodePtr+3
.0190f7	a0 03		ldy #$03			ldy 	#3
.0190f9					_COL_Find:
.0190f9	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0190fb	c8		iny				iny
.0190fc	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.0190fe	f0 18		beq $019118			beq 	_COL_Found
.019100	98		tya				tya
.019101	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.019103	d0 f4		bne $0190f9			bne 	_COL_Find 					; can't find old EOL, give up.
.019105	20 86 85	jsr $018586			jsr ERR_Handler
>019108	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>019110	43 6f 72 72 75 70 74 00
.019118					_COL_Found:
.019118	98		tya				tya
.019119	48		pha				pha
.01911a	a0 00		ldy #$00			ldy 	#0
.01911c	68		pla				pla
.01911d	97 18		sta [$18],y			sta 	[zCodePtr],y
.01911f	20 d9 99	jsr $0199d9			jsr 	UpdateProgramEnd 			; reset variable pointer
.019122	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.019123					Command_GOTO:
.019123	20 78 91	jsr $019178			jsr 	GotoGetLineNumber 			; get line number
.019126					CmdGOTO:
.019126	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.019128	4c 95 91	jmp $019195			jmp 	GotoChangeToLineNumberX
.01912b					Command_GOSUB:
.01912b	20 78 91	jsr $019178			jsr 	GotoGetLineNumber 			; get line number
.01912e					CmdGOSUB:
.01912e	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save position on stack and push frame
.019131	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.019133	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.019136	a2 00		ldx #$00			ldx		#0 							; go to that line number
.019138	4c 95 91	jmp $019195			jmp 	GotoChangeToLineNumberX
.01913b					Command_RETURN:
.01913b	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.01913d	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019140	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; restore position.
.019143	60		rts				rts
.019144					Command_ON:
.019144	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.019146	20 8b 98	jsr $01988b			jsr 	SLIByteParameter
.019149	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.01914b	f0 28		beq $019175			beq 	_CONFail 					; can't be zero, error if it is.
.01914d	aa		tax				tax 								; save in X.
.01914e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019150	c8		iny				iny
.019151	48		pha				pha 								; so we can check what we're doing later.
.019152	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.019154	f0 07		beq $01915d			beq 	_CONOkayToken
.019156	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.019158	f0 03		beq $01915d			beq 	_CONOkayToken
.01915a	4c 57 85	jmp $018557			jmp 	SyntaxError
.01915d					_CONOkayToken:
.01915d	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.01915e					_CONFindNumber:
.01915e	20 78 91	jsr $019178			jsr 	GotoGetLineNumber 			; get a line number.
.019161	fa		plx				plx 								; restore count
.019162	ca		dex				dex  								; decrement, exit if zero.
.019163	f0 06		beq $01916b			beq 	_CONFound
.019165	da		phx				phx 								; push back
.019166	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma				; check for comma
.019169	80 f3		bra $01915e			bra 	_CONFindNumber 				; go round again.
.01916b					_CONFound:
.01916b	68		pla				pla 								; get token to decide what to do
.01916c	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.01916e	f0 b6		beq $019126			beq		CmdGOTO 					; then just branch.
.019170	20 8d 84	jsr $01848d			jsr 	SkipEndOfCommand 			; go to end of command
.019173	80 b9		bra $01912e			bra 	CmdGOSUB 					; and do a GOSUB.
.019175					_CONFail:
.019175	4c 75 85	jmp $018575			jmp 	BadParamError
.019178					GotoGetLineNumber:
.019178	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; get integer into mantissa.0
.01917b	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.01917d	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.01917f	d0 01		bne $019182			bne 	_GLINError
.019181	60		rts				rts
.019182					_GLINError:
.019182	20 86 85	jsr $018586			jsr ERR_Handler
>019185	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>01918d	20 4e 75 6d 62 65 72 00
.019195					GotoChangeToLineNumberX:
.019195	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.019197	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019199	f0 37		beq $0191d2			beq 	_GCTLFail 					; if so, no can do.
.01919b	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.01919d	85 18		sta $18				sta 	zCodePtr+0
.01919f	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.0191a1	85 19		sta $19				sta 	zCodePtr+1
.0191a3	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.0191a5	85 1a		sta $1a				sta 	zCodePtr+2
.0191a7	85 1b		sta $1b				sta 	zCodePtr+3
.0191a9	a0 03		ldy #$03			ldy 	#3
.0191ab					_GCTLLoop:
.0191ab	a0 00		ldy #$00			ldy 	#0
.0191ad	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191af	c9 00		cmp #$00			cmp 	#0
.0191b1	f0 1f		beq $0191d2			beq 	_GCTLFail
.0191b3	c8		iny				iny
.0191b4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191b6	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.0191b8	d0 07		bne $0191c1			bne 	_GCTLNext
.0191ba	c8		iny				iny
.0191bb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191bd	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.0191bf	f0 0f		beq $0191d0			beq 	_GCTLExit
.0191c1					_GCTLNext:
.0191c1	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0191c3	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0191c5	18		clc				clc
.0191c6	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0191c8	85 18		sta $18				sta 	zCodePtr
.0191ca	90 02		bcc $0191ce			bcc 	_SNLNoCarry
.0191cc	e6 19		inc $19				inc 	zCodePtr+1
.0191ce					_SNLNoCarry:
.0191ce	80 db		bra $0191ab			bra 	_GCTLLoop 					; try next line.
.0191d0					_GCTLExit:
.0191d0	c8		iny				iny
.0191d1	60		rts				rts
.0191d2					_GCTLFail:
.0191d2	20 86 85	jsr $018586			jsr ERR_Handler
>0191d5	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0191dd	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0191e5					Command_CLR:
.0191e5					ResetRunStatus:
.0191e5	20 36 9d	jsr $019d36			jsr 	VariableClear
.0191e8	20 ad 84	jsr $0184ad			jsr 	StackReset
.0191eb	a9 00		lda #$00			lda 	#HighMemory & $FF
.0191ed	8d 00 03	sta $0300			sta 	StringPtr
.0191f0	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0191f2	8d 01 03	sta $0301			sta 	StringPtr+1
.0191f5	20 02 9f	jsr $019f02			jsr 	ArrayResetDefault
.0191f8	20 42 8b	jsr $018b42			jsr 	Command_RESTORE
.0191fb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0191fc					Command_STOP:
.0191fc	20 86 85	jsr $018586			jsr ERR_Handler
>0191ff	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.019204					Command_WHILE:
.019204	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019207	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 			; calculate the while loop value.
.01920a	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.01920c	05 81		ora $81				ora 	XS_Mantissa+1
.01920e	05 82		ora $82				ora 	XS_Mantissa+2
.019210	05 83		ora $83				ora 	XS_Mantissa+3
.019212	f0 06		beq $01921a			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.019214	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019216	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.019219	60		rts				rts
.01921a					_CWHSkip:
.01921a	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.01921c	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.01921f	c8		iny				iny
.019220	60		rts				rts
.019221					Command_WEND:
.019221	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.019223	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019226	20 23 85	jsr $018523			jsr 	StackRestorePosition
.019229	80 d9		bra $019204			bra 	Command_WHILE 				; and do the while again.
.01922b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.01922c					Command_REPEAT:
.01922c	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack
.01922f	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019231	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.019234	60		rts				rts
.019235					Command_UNTIL:
.019235	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.019237	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.01923a	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger				; work out the UNTIL expression.
.01923d	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.01923f	05 81		ora $81				ora 	XS_Mantissa+1
.019241	05 82		ora $82				ora 	XS_Mantissa+2
.019243	05 83		ora $83				ora 	XS_Mantissa+3
.019245	d0 08		bne $01924f			bne 	_CUTExit 					; if not, just exit
.019247	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; otherwise loop round again.
.01924a	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.01924c	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.01924f					_CUTExit:
.01924f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.019250					EVESyntax:
.019250	4c 57 85	jmp $018557			jmp 	SyntaxError
.019253					EvaluateExpression:
.019253	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.019255					EvaluateExpressionX:
.019255	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.019257					EvaluateExpressionXA:
.019257	48		pha				pha 								; save precedence on stack.
.019258	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01925a	f0 f4		beq $019250			beq 	EVESyntax 					; end of line, syntax error.
.01925c	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.01925e	b0 03		bcs $019263			bcs 	_EVNotVariable
.019260	4c 2d 93	jmp $01932d			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.019263					_EVNotVariable:
.019263	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.019265	90 e9		bcc $019250			bcc 	EVESyntax
.019267	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019269	b0 58		bcs $0192c3			bcs 	_EVNotInteger
.01926b	20 5b 93	jsr $01935b			jsr 	EvaluateGetInteger
.01926e					_EVCheckDecimal:
.01926e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019270	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.019272	d0 05		bne $019279			bne 	_EVGotAtom 					; no, get atom.
.019274					_EVIsDecimal:
.019274	20 81 93	jsr $019381			jsr 	EVGetDecimal 				; extend to the decimal part.
.019277	80 00		bra $019279			bra 	_EVGotAtom 					; and continue to got atom.
.019279					_EVGotAtom:
.019279	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01927b	10 44		bpl $0192c1			bpl 	_EVExitDrop 				; must be a token.
.01927d	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01927f	b0 40		bcs $0192c1			bcs 	_EVExitDrop
.019281	68		pla				pla 								; get current precedence
.019282	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.019284	da		phx				phx 								; save X
.019285	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019287	aa		tax				tax 								; put in X
.019288	bf 3e 86 01	lda $01863e,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.01928c	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.01928e	fa		plx				plx 								; restore X
.01928f	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.019291	90 2f		bcc $0192c2			bcc 	_EVExit 					; exit if too low.
.019293	f0 2d		beq $0192c2			beq 	_EVExit 					; exit if equals
.019295	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.019297	48		pha				pha
.019298	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01929a	48		pha				pha
.01929b	c8		iny				iny
.01929c	da		phx				phx 								; save current position
.01929d	e8		inx				inx
.01929e	e8		inx				inx
.01929f	e8		inx				inx
.0192a0	e8		inx				inx
.0192a1	e8		inx				inx
.0192a2	e8		inx				inx
.0192a3	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0192a5	20 57 92	jsr $019257			jsr 	EvaluateExpressionXA 		; do the RHS.
.0192a8	fa		plx				plx 								; restore X
.0192a9	68		pla				pla 								; get the binary operator in A.
.0192aa					_EVCallA:
.0192aa	da		phx				phx 								; save X again
.0192ab	0a		asl a				asl 	a 							; double, lose the MSB.
.0192ac	aa		tax				tax									; put in X
.0192ad	bf ed 85 01	lda $0185ed,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0192b1	8d 11 03	sta $0311			sta 	LocalVector+1
.0192b4	bf ee 85 01	lda $0185ee,x			lda 	VectorTable+1,x
.0192b8	8d 12 03	sta $0312			sta 	LocalVector+2
.0192bb	fa		plx				plx 								; restore X
.0192bc	20 36 93	jsr $019336			jsr 	EVCallLocalVector
.0192bf	80 b8		bra $019279			bra 	_EVGotAtom 					; and loop back.
.0192c1					_EVExitDrop:
.0192c1	68		pla				pla
.0192c2					_EVExit:
.0192c2	60		rts				rts
.0192c3					_EVNotInteger:
.0192c3	c8		iny				iny
.0192c4	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0192c6	d0 16		bne $0192de			bne 	_EVNotMinus
.0192c8	20 ca 93	jsr $0193ca			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0192cb	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0192cd	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0192cf	f0 05		beq $0192d6			beq 	_EVMinusFloat
.0192d1	20 c1 a1	jsr $01a1c1			jsr 	IntegerNegateAlways 		; negation
.0192d4	80 a3		bra $019279			bra 	_EVGotAtom 					; and go back.
.0192d6					_EVMinusFloat:
.0192d6	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0192d8	49 80		eor #$80			eor 	#$80
.0192da	95 85		sta $85,x			sta 	XS_Type,x
.0192dc	80 9b		bra $019279			bra 	_EVGotAtom
.0192de					_EVNotMinus:
.0192de	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0192e0	d0 17		bne $0192f9			bne 	_EVNotParenthesis
.0192e2	20 55 92	jsr $019255			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0192e5	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192e7	c8		iny				iny
.0192e8	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0192ea	f0 8d		beq $019279			beq 	_EVGotAtom
.0192ec	20 86 85	jsr $018586			jsr ERR_Handler
>0192ef	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0192f7	29 00
.0192f9					_EVNotParenthesis:
.0192f9	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0192fb	d0 0c		bne $019309			bne 	_EVNotNot
.0192fd	20 ca 93	jsr $0193ca			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.019300	20 49 a6	jsr $01a649			jsr 	FPUToInteger 				; make it an integer - if possible.
.019303	20 af 93	jsr $0193af			jsr 	NotInteger 					; do the not calculation
.019306	4c 79 92	jmp $019279			jmp 	_EVGotAtom
.019309					_EVNotNot:
.019309	c9 fe		cmp #$fe			cmp 	#$FE
.01930b	d0 12		bne $01931f			bne 	_EVNotString
.01930d	20 bd 9a	jsr $019abd			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.019310	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.019312	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019314	a5 23		lda $23				lda 	zTempStr+1
.019316	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019318	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.01931a	95 85		sta $85,x			sta 	XS_Type,x
.01931c	4c 79 92	jmp $019279			jmp 	_EVGotAtom
.01931f					_EVNotString:
.01931f	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.019321	90 04		bcc $019327			bcc 	_EVBadElement
.019323	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.019325	90 03		bcc $01932a			bcc 	_EVUnaryFunction
.019327					_EVBadElement:
.019327	4c 57 85	jmp $018557			jmp 	SyntaxError
.01932a					_EVUnaryFunction:
.01932a	4c aa 92	jmp $0192aa			jmp 	_EVCallA
.01932d					_EVVariableHandler:
.01932d	20 fa 9c	jsr $019cfa			jsr 	VariableFind 				; locate a variable
.019330	20 44 a0	jsr $01a044			jsr 	VariableGet 				; copy into memory.
.019333	4c 79 92	jmp $019279			jmp 	_EVGotAtom 					; and go round.
.019336					EVCallLocalVector:
.019336	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019339					EVShiftMantissaLeft6:
.019339	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.01933b	95 84		sta $84,x			sta 	XS_Exponent,x
.01933d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01933f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019341	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019343	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019345	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019347	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019349	a9 00		lda #$00			lda 	#0
.01934b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01934d	20 50 93	jsr $019350			jsr 	_EVSMLShift 					; call it here to do it twice
.019350					_EVSMLShift:
.019350	56 84		lsr $84,x			lsr 	XS_Exponent,x
.019352	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.019354	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019356	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019358	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.01935a	60		rts				rts
.01935b					EvaluateGetInteger:
.01935b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01935d	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.01935f	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019361	a9 00		lda #$00			lda 	#0
.019363	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019365	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019367	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019369	1a		inc a				inc 	a 							; set to type 1 (integer)
.01936a	95 85		sta $85,x			sta 	XS_Type,x
.01936c					_EVCheckNextInteger:
.01936c	c8		iny				iny
.01936d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01936f	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.019371	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.019373	b0 0b		bcs $019380			bcs 	_EVEndInteger
.019375	48		pha				pha 								; save it.
.019376	20 39 93	jsr $019339			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019379	68		pla				pla
.01937a	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.01937c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01937e	80 ec		bra $01936c			bra 	_EVCheckNextInteger
.019380					_EVEndInteger:
.019380	60		rts				rts
.019381					EVGetDecimal:
.019381	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.019383	8d 15 03	sta $0315			sta 	Num_Buffer
.019386	da		phx				phx
.019387	c8		iny				iny
.019388	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01938a	c8		iny				iny
.01938b	3a		dec a				dec 	a								; convert to a string length.
.01938c	3a		dec a				dec 	a
.01938d	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.01938f					_EVGDCopy:
.01938f	48		pha				pha 									; save count
.019390	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019392	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019395	e8		inx				inx 									; forward ....
.019396	c8		iny				iny
.019397	68		pla				pla 									; get count
.019398	3a		dec a				dec 	a 								; until zero
.019399	d0 f4		bne $01938f			bne 	_EVGDCopy
.01939b	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.01939e	fa		plx				plx 									; restore X
.01939f	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0193a1	85 20		sta $20				sta 	zGenPtr
.0193a3	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0193a5	85 21		sta $21				sta 	zGenPtr+1
.0193a7	5a		phy				phy 									; save Y
.0193a8	a0 00		ldy #$00			ldy 	#0 								; start position
.0193aa	20 03 a8	jsr $01a803			jsr 	FPFromString 					; convert current
.0193ad	7a		ply				ply 									; restore Y
.0193ae	60		rts				rts
.0193af					NotInteger:
.0193af	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193b1	49 ff		eor #$ff			eor 	#$FF
.0193b3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193b5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193b7	49 ff		eor #$ff			eor 	#$FF
.0193b9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193bb	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193bd	49 ff		eor #$ff			eor 	#$FF
.0193bf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193c1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193c3	49 ff		eor #$ff			eor 	#$FF
.0193c5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193c7	60		rts				rts
.0193c8					EvaluateGetAtom:
.0193c8	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0193ca					EvaluateGetAtomX:
.0193ca	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0193cc	20 57 92	jsr $019257			jsr 	EvaluateExpressionXA
.0193cf	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0193d1	29 0f		and #$0f			and 	#15
.0193d3	c9 02		cmp #$02			cmp 	#2
.0193d5	b0 01		bcs $0193d8			bcs 	EvaluateType
.0193d7	60		rts				rts
.0193d8					EvaluateType:
.0193d8	4c 67 85	jmp $018567			jmp 	TypeError
.0193db					EvaluateNumber:
.0193db	a2 00		ldx #$00			ldx 	#0
.0193dd					EvaluateNumberX:
.0193dd	20 55 92	jsr $019255			jsr 	EvaluateExpressionX
.0193e0	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.0193e2	29 0f		and #$0f			and 	#15
.0193e4	c9 02		cmp #$02			cmp 	#2
.0193e6	b0 f0		bcs $0193d8			bcs 	EvaluateType
.0193e8	60		rts				rts
.0193e9					EvaluateInteger:
.0193e9	a2 00		ldx #$00			ldx 	#0
.0193eb					EvaluateIntegerX:
.0193eb	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX
.0193ee	20 49 a6	jsr $01a649			jsr 	FPUToInteger
.0193f1	60		rts				rts
.0193f2					EvaluateString:
.0193f2	a2 00		ldx #$00			ldx 	#0
.0193f4					EvaluateStringX:
.0193f4	20 55 92	jsr $019255			jsr 	EvaluateExpressionX
.0193f7	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0193f9	29 0f		and #$0f			and 	#15
.0193fb	c9 02		cmp #$02			cmp 	#2
.0193fd	d0 d9		bne $0193d8			bne 	EvaluateType
.0193ff	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.019401	85 20		sta $20				sta 	zGenPtr
.019403	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019405	85 21		sta $21				sta 	zGenPtr+1
.019407	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019408					BinaryOp_And:
.019408	20 5c 94	jsr $01945c			jsr 	BinaryMakeBothInteger
.01940b	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01940d	35 86		and $86,x			and 	XS2_Mantissa+0,x
.01940f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019411	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019413	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019415	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019417	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019419	35 88		and $88,x			and 	XS2_Mantissa+2,x
.01941b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01941d	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01941f	35 89		and $89,x			and 	XS2_Mantissa+3,x
.019421	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019423	60		rts				rts
.019424					BinaryOp_Or:
.019424	20 5c 94	jsr $01945c			jsr 	BinaryMakeBothInteger
.019427	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019429	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.01942b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01942d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01942f	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019431	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019433	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019435	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019437	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019439	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01943b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01943d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01943f	60		rts				rts
.019440					BinaryOp_Eor:
.019440					BinaryOp_Xor:
.019440	20 5c 94	jsr $01945c			jsr 	BinaryMakeBothInteger
.019443	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019445	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019447	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019449	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01944b	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.01944d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01944f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019451	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.019453	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019455	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019457	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019459	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01945b	60		rts				rts
.01945c					BinaryMakeBothInteger:
.01945c	da		phx				phx 								; save X
.01945d	e8		inx				inx
.01945e	e8		inx				inx
.01945f	e8		inx				inx
.019460	e8		inx				inx
.019461	e8		inx				inx
.019462	e8		inx				inx
.019463	20 67 94	jsr $019467			jsr 	BinaryMakeInteger 			; convert to integer.
.019466	fa		plx				plx 								; restore X and fall through.
.019467					BinaryMakeInteger:
.019467	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019469	29 0f		and #$0f			and 	#15 						; check type zero
.01946b	f0 04		beq $019471			beq 	_BMIConvert 				; if float convert to integer.
.01946d	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.01946e	90 04		bcc $019474			bcc 	_BMIError
.019470	60		rts				rts
.019471					_BMIConvert:
.019471	4c 49 a6	jmp $01a649			jmp 	FPUToInteger 				; convert to integer
.019474					_BMIError:
.019474	4c 67 85	jmp $018567			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.019477					Binary_Equal:
.019477	20 c0 94	jsr $0194c0			jsr 	CompareValues 				; compare the values
.01947a	09 00		ora #$00			ora 	#0 							; true if 0
.01947c	f0 33		beq $0194b1			beq 	CCTrue
.01947e	80 2d		bra $0194ad			bra 	CCFalse
.019480					Binary_NotEqual:
.019480	20 c0 94	jsr $0194c0			jsr 	CompareValues
.019483	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.019485	f0 26		beq $0194ad			beq 	CCFalse
.019487	80 28		bra $0194b1			bra 	CCTrue
.019489					Binary_Less:
.019489	20 c0 94	jsr $0194c0			jsr 	CompareValues
.01948c	09 00		ora #$00			ora 	#0 							; true if -1
.01948e	30 21		bmi $0194b1			bmi 	CCTrue
.019490	80 1b		bra $0194ad			bra 	CCFalse
.019492					Binary_LessEqual:
.019492	20 c0 94	jsr $0194c0			jsr 	CompareValues
.019495	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.019497	d0 18		bne $0194b1			bne 	CCTrue
.019499	80 12		bra $0194ad			bra 	CCFalse
.01949b					Binary_GreaterEqual:
.01949b	20 c0 94	jsr $0194c0			jsr 	CompareValues
.01949e	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.0194a0	10 0f		bpl $0194b1			bpl 	CCTrue
.0194a2	80 09		bra $0194ad			bra 	CCFalse
.0194a4					Binary_Greater:
.0194a4	20 c0 94	jsr $0194c0			jsr 	CompareValues 				; true if 1
.0194a7	c9 01		cmp #$01			cmp 	#1
.0194a9	f0 06		beq $0194b1			beq 	CCTrue
.0194ab	80 00		bra $0194ad			bra 	CCFalse
.0194ad	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0194af	80 02		bra $0194b3			bra 	CCWrite
.0194b1	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0194b3	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0194b5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194b7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194b9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194bb	a9 01		lda #$01			lda 	#1
.0194bd	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0194bf	60		rts				rts
.0194c0					CompareValues:
.0194c0	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0194c2	35 8b		and $8b,x			and 	XS2_Type,x
.0194c4	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.0194c6	f0 11		beq $0194d9			beq 	_CVString					; comparison routine.
.0194c8	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194ca	35 8b		and $8b,x			and 	XS2_Type,x
.0194cc	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194cd	90 03		bcc $0194d2			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194cf	4c 1b 95	jmp $01951b			jmp 	CompareInteger32 							; so execute code at \1
.0194d2					_BCFloat:
.0194d2	20 b5 95	jsr $0195b5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194d5	4c 42 a5	jmp $01a542			jmp 	FPCompare 							; and execute code at \2
.0194d8	60		rts				rts
.0194d9					_CVString:
.0194d9	da		phx				phx 								; save XY
.0194da	5a		phy				phy
.0194db	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0194dd	85 1c		sta $1c				sta		zLTemp1+0
.0194df	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194e1	85 1d		sta $1d				sta 	zLTemp1+1
.0194e3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0194e5	85 1e		sta $1e				sta 	zLTemp1+2
.0194e7	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194e9	85 1f		sta $1f				sta 	zLTemp1+3
.0194eb	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0194ed	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194ef	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194f1	90 02		bcc $0194f5			bcc 	_CVCommon
.0194f3	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.0194f5					_CVCommon:
.0194f5	aa		tax				tax 								; put shorter string length in zero.
.0194f6	f0 0c		beq $019504			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0194f8					_CVCompare:
.0194f8	c8		iny				iny 								; next character
.0194f9	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.0194fb	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.0194fd	90 13		bcc $019512			bcc 	_CVReturnLess 				; <
.0194ff	d0 15		bne $019516			bne 	_CVReturnGreater 			; >
.019501	ca		dex				dex 								; until common length matched.
.019502	d0 f4		bne $0194f8			bne 	_CVCompare
.019504					_CVMatch:
.019504	a0 00		ldy #$00			ldy 	#0
.019506	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019508	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.01950a	90 06		bcc $019512			bcc 	_CVReturnLess 				; <
.01950c	d0 08		bne $019516			bne 	_CVReturnGreater 			; >
.01950e	a9 00		lda #$00			lda 	#0
.019510	80 06		bra $019518			bra 	_CVExit
.019512					_CVReturnLess:
.019512	a9 ff		lda #$ff			lda 	#$FF
.019514	80 02		bra $019518			bra 	_CVExit
.019516					_CVReturnGreater:
.019516	a9 01		lda #$01			lda 	#$01
.019518					_CVExit:
.019518	7a		ply				ply
.019519	fa		plx				plx
.01951a	60		rts				rts
.01951b					CompareInteger32:
.01951b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.01951d	49 80		eor #$80			eor 	#$80
.01951f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019521	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.019523	49 80		eor #$80			eor 	#$80
.019525	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019527	20 9b 95	jsr $01959b			jsr 	SubInteger32 				; subtraction
.01952a	90 0d		bcc $019539			bcc 	_CI32Less 					; cc return -1
.01952c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.01952e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019530	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019532	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019534	f0 02		beq $019538			beq 	_CI32Exit
.019536	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019538					_CI32Exit:
.019538	60		rts				rts
.019539					_CI32Less:
.019539	a9 ff		lda #$ff			lda 	#$FF
.01953b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.01953c					BinaryOp_Add:
.01953c	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.01953e	35 8b		and $8b,x			and 	XS2_Type,x
.019540	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.019542	d0 11		bne $019555			bne 	_BOAString 					; so go do the string code.
.019544	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019546	35 8b		and $8b,x			and 	XS2_Type,x
.019548	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019549	90 03		bcc $01954e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01954b	4c 81 95	jmp $019581			jmp 	AddInteger32 							; so execute code at \1
.01954e					_BCFloat:
.01954e	20 b5 95	jsr $0195b5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019551	4c 2d a3	jmp $01a32d			jmp 	FPAdd 							; and execute code at \2
.019554	60		rts				rts
.019555					_BOAString:
.019555	4c cf 95	jmp $0195cf			jmp 	ConcatenateString 			; concatenate two strings.
.019558					BinaryOp_Subtract:
.019558	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01955a	35 8b		and $8b,x			and 	XS2_Type,x
.01955c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01955d	90 03		bcc $019562			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01955f	4c 9b 95	jmp $01959b			jmp 	SubInteger32 							; so execute code at \1
.019562					_BCFloat:
.019562	20 b5 95	jsr $0195b5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019565	4c 25 a3	jmp $01a325			jmp 	FPSubtract 							; and execute code at \2
.019568	60		rts				rts
.019569					BinaryOp_Multiply:
.019569	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01956b	35 8b		and $8b,x			and 	XS2_Type,x
.01956d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01956e	90 03		bcc $019573			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019570	4c fc a0	jmp $01a0fc			jmp 	MulInteger32 							; so execute code at \1
.019573					_BCFloat:
.019573	20 b5 95	jsr $0195b5			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019576	4c 44 a4	jmp $01a444			jmp 	FPMultiply 							; and execute code at \2
.019579	60		rts				rts
.01957a					BinaryOp_Divide:
.01957a	20 b5 95	jsr $0195b5			jsr 	BinaryMakeBothFloat
.01957d	20 d1 a3	jsr $01a3d1			jsr 	FPDivide
.019580	60		rts				rts
.019581					AddInteger32:
.019581	18		clc				clc
.019582	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019584	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019586	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019588	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01958a	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01958c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01958e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019590	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019592	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019594	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019596	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019598	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01959a	60		rts				rts
.01959b					SubInteger32:
.01959b	38		sec				sec
.01959c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01959e	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0195a0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195a2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195a4	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0195a6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195a8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195aa	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0195ac	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195ae	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0195b0	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0195b2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195b4	60		rts				rts
.0195b5					BinaryMakeBothFloat:
.0195b5	da		phx				phx 								; save X
.0195b6	e8		inx				inx
.0195b7	e8		inx				inx
.0195b8	e8		inx				inx
.0195b9	e8		inx				inx
.0195ba	e8		inx				inx
.0195bb	e8		inx				inx
.0195bc	20 c0 95	jsr $0195c0			jsr 	BinaryMakeFloat 			; convert to float.
.0195bf	fa		plx				plx 								; restore X and fall through.
.0195c0					BinaryMakeFloat:
.0195c0	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0195c2	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0195c3	b0 04		bcs $0195c9			bcs 	_BMFConvert
.0195c5	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0195c6	b0 04		bcs $0195cc			bcs 	_BMFError
.0195c8	60		rts				rts
.0195c9					_BMFConvert:
.0195c9	4c fd a5	jmp $01a5fd			jmp 	FPUToFloat 					; convert to float, only float builds of course
.0195cc					_BMFError:
.0195cc	4c 67 85	jmp $018567			jmp 	TypeError
.0195cf					ConcatenateString:
.0195cf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0195d1	85 1c		sta $1c				sta		zLTemp1+0
.0195d3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195d5	85 1d		sta $1d				sta 	zLTemp1+1
.0195d7	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0195d9	85 1e		sta $1e				sta 	zLTemp1+2
.0195db	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195dd	85 1f		sta $1f				sta 	zLTemp1+3
.0195df	5a		phy				phy
.0195e0	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0195e2	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.0195e4	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.0195e6	7a		ply				ply
.0195e7	b0 33		bcs $01961c			bcs 	_CSError					; check in range.
.0195e9	c9 fe		cmp #$fe			cmp 	#maxString+1
.0195eb	b0 2f		bcs $01961c			bcs 	_CSError
.0195ed	20 82 9a	jsr $019a82			jsr 	AllocateTempString 			; store the result
.0195f0	20 07 96	jsr $019607			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195f3	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0195f5	85 1c		sta $1c				sta 	zLTemp1
.0195f7	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195f9	85 1d		sta $1d				sta 	zLTemp1+1
.0195fb	20 07 96	jsr $019607			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195fe	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.019600	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019602	a5 23		lda $23				lda 	zTempStr+1
.019604	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019606	60		rts				rts
.019607					_CSCopyString:
.019607	da		phx				phx
.019608	5a		phy				phy
.019609	a0 00		ldy #$00			ldy 	#0 							; get length
.01960b	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.01960d	f0 0a		beq $019619			beq 	_CSCSExit 					; if zero, exit immediately
.01960f	aa		tax				tax 								; put in X which is the counter.
.019610					_CSCSLoop:
.019610	c8		iny				iny 								; get next char
.019611	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019613	20 ad 9a	jsr $019aad			jsr		WriteTempString 			; copy out to new string
.019616	ca		dex				dex 								; do whole string
.019617	d0 f7		bne $019610			bne 	_CSCSLoop
.019619					_CSCSExit:
.019619	7a		ply				ply
.01961a	fa		plx				plx
.01961b	60		rts				rts
.01961c					_CSError:
.01961c	20 86 85	jsr $018586			jsr ERR_Handler
>01961f	53 74 72 69 6e 67 20 74			.text "String too long",0
>019627	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.01962f					Unary_Sgn:
.01962f	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX 			; get value
.019632	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; check right bracket.
.019635	20 53 96	jsr $019653			jsr 	GetSignCurrent 				; get sign.
.019638	09 00		ora #$00			ora 	#0
.01963a	10 08		bpl $019644			bpl		UnarySetAInteger			; if 0,1 return that.
.01963c	80 00		bra $01963e			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.01963e					UnarySetAMinus1:
.01963e	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019640	95 80		sta $80,x			sta 	XS_Mantissa,x
.019642	80 04		bra $019648			bra 	UnarySetAFill
.019644					UnarySetAInteger:
.019644	95 80		sta $80,x			sta 	XS_Mantissa,x
.019646	a9 00		lda #$00			lda 	#0
.019648					UnarySetAFill:
.019648	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01964a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01964c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01964e	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019650	95 85		sta $85,x			sta 	XS_Type,x
.019652	60		rts				rts
.019653					GetSignCurrent:
.019653	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019655	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.019656	90 15		bcc $01966d			bcc 	_GSCFloat 					; if clear do the float code.
.019658	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.01965a	30 0e		bmi $01966a			bmi 	_GSCMinus1
.01965c	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01965e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019660	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019662	d0 03		bne $019667			bne 	_GSCPlus1 					; check if zero by oring all together.
.019664					_GSCZero:
.019664	a9 00		lda #$00			lda 	#0
.019666	60		rts				rts
.019667					_GSCPlus1:
.019667	a9 01		lda #$01			lda 	#$01
.019669	60		rts				rts
.01966a					_GSCMinus1:
.01966a	a9 ff		lda #$ff			lda 	#$FF
.01966c	60		rts				rts
.01966d					_GSCFloat:
.01966d	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.01966f	70 f3		bvs $019664			bvs 	_GSCZero 					; if zero flag set return zero
.019671	30 f7		bmi $01966a			bmi 	_GSCMinus1 					; if sign set return -1
.019673	80 f2		bra $019667			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019675					Unary_Abs:
.019675	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX 			; get value
.019678	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; check right bracket.
.01967b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01967d	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01967f	f0 07		beq $019688			beq 	_UAMinusFloat
.019681	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019683	10 09		bpl $01968e			bpl 	_UAExit
.019685	4c c1 a1	jmp $01a1c1			jmp 	IntegerNegateAlways 		; if so negate it.
.019688					_UAMinusFloat:
.019688	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01968a	29 7f		and #$7f			and		#$7F
.01968c	95 85		sta $85,x			sta 	XS_Type,x
.01968e					_UAExit:
.01968e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.01968f					Unary_Peek:
.01968f	a9 01		lda #$01			lda 	#1 							; 1 byte
.019691	80 06		bra $019699			bra 	UPMain
.019693					Unary_Deek:
.019693	a9 02		lda #$02			lda 	#2 							; 2 bytes
.019695	80 02		bra $019699			bra 	UPMain
.019697					Unary_Leek:
.019697	a9 04		lda #$04			lda 	#4 							; 4 bytes
.019699					UPMain:
.019699	48		pha				pha 								; save bytes to copy.
.01969a	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.01969d	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.0196a0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0196a2	85 1c		sta $1c				sta 	zLTemp1
.0196a4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196a6	85 1d		sta $1d				sta 	zLTemp1+1
.0196a8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0196aa	85 1e		sta $1e				sta 	zLTemp1+2
.0196ac	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0196ae	85 1f		sta $1f				sta 	zLTemp1+3
.0196b0	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.0196b2	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.0196b4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196b6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196b8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196ba	68		pla				pla 								; restore bytes to copy
.0196bb	da		phx				phx 								; save XY
.0196bc	5a		phy				phy
.0196bd	20 b7 99	jsr $0199b7			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.0196c0	7a		ply				ply 								; restore and exit
.0196c1	fa		plx				plx
.0196c2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.0196c3					Unary_Pos:
.0196c3	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.0196c6	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; check right bracket.
.0196c9	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; get the position
.0196cc	4c 44 96	jmp $019644			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.0196cf					Unary_Mod:
.0196cf	20 f7 96	jsr $0196f7			jsr 	_UMParameter 				; first parameter, get |param|
.0196d2	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma
.0196d5	da		phx				phx 								; second parameter, get |param|
.0196d6	e8		inx				inx
.0196d7	e8		inx				inx
.0196d8	e8		inx				inx
.0196d9	e8		inx				inx
.0196da	e8		inx				inx
.0196db	e8		inx				inx
.0196dc	20 f7 96	jsr $0196f7			jsr 	_UMParameter
.0196df	fa		plx				plx
.0196e0	20 35 9a	jsr $019a35			jsr 	CheckNextRParen
.0196e3	20 3a a1	jsr $01a13a			jsr 	DivInteger32 				; divide, which handily leaves ....
.0196e6	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0196e8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196ea	a5 1d		lda $1d				lda 	zLTemp1+1
.0196ec	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196ee	a5 1e		lda $1e				lda 	zLTemp1+2
.0196f0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196f2	a5 1f		lda $1f				lda 	zLTemp1+3
.0196f4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196f6	60		rts				rts
.0196f7					_UMParameter:
.0196f7	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX 			; get value
.0196fa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.0196fc	10 03		bpl $019701			bpl 	_UMNotSigned
.0196fe	20 c1 a1	jsr $01a1c1			jsr 	IntegerNegateAlways
.019701					_UMNotSigned:
.019701	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019702					Unary_Usr:
.019702	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX 			; numeric parameter
.019705	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.019708	da		phx				phx 								; save XY
.019709	5a		phy				phy
.01970a	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.01970e	7a		ply				ply 								; restore YX and exit with whatever the
.01970f	fa		plx				plx 								; routine called has chosen to do with it.
.019710	60		rts				rts
.019711					USRDefault:
.019711	20 86 85	jsr $018586			jsr ERR_Handler
>019714	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>01971c	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019723					Unary_Val:
.019723	20 f4 93	jsr $0193f4			jsr 	EvaluateStringX 			; get string
.019726	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; check right bracket.
.019729	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.01972b	85 20		sta $20				sta 	zGenPtr
.01972d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01972f	85 21		sta $21				sta 	zGenPtr+1
.019731	da		phx				phx
.019732	5a		phy				phy
.019733	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.019735	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.019737	f0 1b		beq $019754			beq 	UVBadNumber
.019739	aa		tax				tax
.01973a					_UVCopy1:
.01973a	c8		iny				iny
.01973b	c0 18		cpy #$18			cpy 	#24 						; too long
.01973d	f0 15		beq $019754			beq 	UVBadNumber
.01973f	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.019741	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.019744	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.019746	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.019749	ca		dex				dex
.01974a	d0 ee		bne $01973a			bne 	_UVCopy1
.01974c	7a		ply				ply
.01974d	fa		plx				plx
.01974e	20 62 97	jsr $019762			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.019751	b0 01		bcs $019754			bcs 	UVBadNumber
.019753	60		rts				rts
.019754					UVBadNumber:
.019754	20 86 85	jsr $018586			jsr ERR_Handler
>019757	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>01975f	65 72 00
.019762					ConvertNumBuffer:
.019762	5a		phy				phy
.019763	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.019765	85 20		sta $20				sta 	zGenPtr
.019767	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.019769	85 21		sta $21				sta 	zGenPtr+1
.01976b	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.01976e	c9 2d		cmp #$2d			cmp 	#"-"
.019770	d0 02		bne $019774			bne 	_UVNotMinus1
.019772	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.019774					_UVNotMinus1:
.019774	20 93 a2	jsr $01a293			jsr 	IntFromString 				; get integer
.019777	b0 22		bcs $01979b			bcs 	_UVFail
.019779	20 03 a8	jsr $01a803			jsr 	FPFromString 				; possibly float it.
.01977c	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.01977e	d0 1b		bne $01979b			bne 	_UVFail 					; no, exit.
.019780	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.019783	c9 2d		cmp #$2d			cmp 	#"-"
.019785	d0 11		bne $019798			bne 	_UVNotMinus2
.019787	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.019789	29 0f		and #$0f			and 	#$0F
.01978b	f0 05		beq $019792			beq 	_UVNegateFloat
.01978d	20 c1 a1	jsr $01a1c1			jsr 	IntegerNegateAlways
.019790	80 06		bra $019798			bra 	_UVNotMinus2
.019792					_UVNegateFloat:
.019792	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.019794	09 80		ora #$80			ora 	#$80
.019796	95 85		sta $85,x			sta 	XS_Type,x
.019798					_UVNotMinus2:
.019798	7a		ply				ply
.019799	18		clc				clc
.01979a	60		rts				rts
.01979b	7a		ply		_UVFail:ply
.01979c	38		sec				sec
.01979d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.01979e					Unary_Str:
.01979e	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX 			; numeric parameter
.0197a1	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.0197a4	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0197a6	8d 14 03	sta $0314			sta 	NumBufX
.0197a9	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0197ab	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.0197ac	b0 05		bcs $0197b3			bcs 	_USInt 						; if msb set do as integer
.0197ae	20 48 a7	jsr $01a748			jsr 	FPToString 					; call fp to str otherwise
.0197b1	80 03		bra $0197b6			bra 	_USDuplicate
.0197b3	20 de a1	jsr $01a1de	_USInt:	jsr 	IntToString					; call int to str.
.0197b6					_USDuplicate:
.0197b6	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0197b9	1a		inc a				inc 	a 							; one more for length
.0197ba	20 82 9a	jsr $019a82			jsr 	AllocateTempString 			; allocate space for it.
.0197bd	5a		phy				phy 								; save Y
.0197be	a0 00		ldy #$00			ldy 	#0 							; start copying
.0197c0	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0197c3	20 ad 9a	jsr $019aad			jsr 	WriteTempString
.0197c6	c8		iny				iny
.0197c7	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0197ca	d0 f4		bne $0197c0			bne 	_USCopy
.0197cc	7a		ply				ply 								; restore Y
.0197cd	4c aa 99	jmp $0199aa			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0197d0					Unary_Asc:
.0197d0	20 f4 93	jsr $0193f4			jsr 	EvaluateStringX 			; string parameter
.0197d3	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.0197d6	5a		phy				phy 								; get the string length
.0197d7	a0 00		ldy #$00			ldy 	#0
.0197d9	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197db	f0 07		beq $0197e4			beq 	_UAIllegal 					; must be at least one character, 0 => error
.0197dd	c8		iny				iny
.0197de	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.0197e0	7a		ply				ply
.0197e1	4c 44 96	jmp $019644			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.0197e4					_UAIllegal:
.0197e4	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0197e7					Unary_Len:
.0197e7	20 f4 93	jsr $0193f4			jsr 	EvaluateStringX 			; string parameter
.0197ea	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.0197ed	5a		phy				phy 								; get the string length
.0197ee	a0 00		ldy #$00			ldy 	#0
.0197f0	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197f2	7a		ply				ply
.0197f3	4c 44 96	jmp $019644			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0197f6					Unary_Mid:
.0197f6	20 f4 93	jsr $0193f4			jsr 	EvaluateStringX 				; get string.
.0197f9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197fb	48		pha				pha
.0197fc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197fe	48		pha				pha
.0197ff	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma 					; skip comma
.019802	20 8b 98	jsr $01988b			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019805	48		pha				pha 									; and push it.
.019806	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma 					; skip comma
.019809	20 8b 98	jsr $01988b			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.01980c	48		pha				pha 									; and push it.
.01980d	80 41		bra $019850			bra 	SLIProcess
.01980f					Unary_Left:
.01980f	20 f4 93	jsr $0193f4			jsr 	EvaluateStringX 				; get string.
.019812	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019814	48		pha				pha
.019815	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019817	48		pha				pha
.019818	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01981a	48		pha				pha
.01981b	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma 					; skip comma
.01981e	20 8b 98	jsr $01988b			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019821	48		pha				pha 									; and push it.
.019822	80 2c		bra $019850			bra 	SLIProcess
.019824					Unary_Right:
.019824	20 f4 93	jsr $0193f4			jsr 	EvaluateStringX 				; get string.
.019827	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019829	48		pha				pha
.01982a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01982c	48		pha				pha
.01982d	da		phx				phx 									; get the string length and push on stack.
.01982e	a2 00		ldx #$00			ldx 	#0
.019830	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.019832	fa		plx				plx
.019833	48		pha				pha
.019834	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma 					; skip comma
.019837	20 8b 98	jsr $01988b			jsr 	SLIByteParameter 				; get a byte parameter.
.01983a	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.01983d	68		pla				pla 									; restore string length.
.01983e	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.01983f	38		sec				sec
.019840	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019843	f0 02		beq $019847			beq 	_URStart 						; if <= 0 start from 1.
.019845	10 02		bpl $019849			bpl 	_UROkay
.019847					_URStart:
.019847	a9 01		lda #$01			lda 	#1
.019849					_UROkay:
.019849	48		pha				pha 									; push start
.01984a	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.01984d	48		pha				pha
.01984e	80 00		bra $019850			bra 	SLIProcess
.019850					SLIProcess:
.019850	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 				; closing right bracket.
.019853	68		pla				pla
.019854	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.019857	1a		inc a				inc 	a 								; allocate +1 for it.
.019858	20 82 9a	jsr $019a82			jsr 	AllocateTempString
.01985b	68		pla				pla 									; pop start number off stack.
.01985c	f0 3b		beq $019899			beq 	SLIError 						; exit if start = 0
.01985e	8d a1 03	sta $03a1			sta 	SliceStart
.019861	68		pla				pla  									; pop string address.
.019862	85 21		sta $21				sta 	zGenPtr+1
.019864	68		pla				pla
.019865	85 20		sta $20				sta 	zGenPtr
.019867	da		phx				phx
.019868	5a		phy				phy
.019869	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01986b	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.01986e					_SLICopy:
.01986e	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019871	f0 12		beq $019885			beq 	_SLIExit
.019873	ce a2 03	dec $03a2			dec 	SliceCount
.019876	98		tya				tya 									; index of character
.019877	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.019879	f0 02		beq $01987d			beq 	_SLIOk 							; if equal, okay.
.01987b	b0 08		bcs $019885			bcs 	_SLIExit 						; if past end, then exit.
.01987d	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.01987f	c8		iny				iny
.019880	20 ad 9a	jsr $019aad			jsr 	WriteTempString
.019883	80 e9		bra $01986e			bra 	_SLICopy 						; go round till copied characters
.019885					_SLIExit:
.019885	7a		ply				ply 									; restore YX
.019886	fa		plx				plx
.019887	4c aa 99	jmp $0199aa			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01988a	ea		nop				nop
.01988b					SLIByteParameter:
.01988b	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX 				; get integer
.01988e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019890	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019892	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019894	d0 03		bne $019899			bne 	SLIError
.019896	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019898	60		rts				rts
.019899					SLIError:
.019899	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.01989c					Unary_Hex:
.01989c	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX 			; numeric parameter
.01989f	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.0198a2	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0198a4	20 82 9a	jsr $019a82			jsr 	AllocateTempString			; allocate string space
.0198a7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0198a9	20 cd 98	jsr $0198cd			jsr 	_UHConvert
.0198ac	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0198ae	20 cd 98	jsr $0198cd			jsr 	_UHConvert
.0198b1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198b3	20 cd 98	jsr $0198cd			jsr 	_UHConvert
.0198b6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0198b8	20 cd 98	jsr $0198cd			jsr 	_UHConvert
.0198bb	5a		phy				phy 								; get length of new string
.0198bc	a0 00		ldy #$00			ldy 	#0
.0198be	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198c0	7a		ply				ply
.0198c1	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.0198c3	d0 05		bne $0198ca			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.0198c5	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0198c7	20 ad 9a	jsr $019aad			jsr 	WriteTempString
.0198ca					_UHExit:
.0198ca	4c aa 99	jmp $0199aa			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0198cd					_UHConvert:
.0198cd	48		pha				pha
.0198ce	4a		lsr a				lsr 	a 							; do MSB
.0198cf	4a		lsr a				lsr 	a
.0198d0	4a		lsr a				lsr 	a
.0198d1	4a		lsr a				lsr 	a
.0198d2	20 d6 98	jsr $0198d6			jsr 	_UHNibble
.0198d5	68		pla				pla 								; do LSB
.0198d6					_UHNibble:
.0198d6	29 0f		and #$0f			and 	#15 						; get nibble
.0198d8	d0 0c		bne $0198e6			bne 	_UHNonZero 					; if not zero, write it out anyway.
.0198da	5a		phy				phy									; get the length
.0198db	a0 00		ldy #$00			ldy 	#0
.0198dd	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198df	7a		ply				ply
.0198e0	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.0198e2	f0 0d		beq $0198f1			beq 	_UHExit2
.0198e4	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.0198e6					_UHNonZero:
.0198e6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0198e8	90 02		bcc $0198ec			bcc 	_UHDigit
.0198ea	69 06		adc #$06			adc 	#7-1
.0198ec					_UHDigit:
.0198ec	69 30		adc #$30			adc 	#48
.0198ee	20 ad 9a	jsr $019aad			jsr 	WriteTempString				; output to temp string.
.0198f1					_UHExit2:
.0198f1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0198f2					Unary_Dec:
.0198f2	20 f4 93	jsr $0193f4			jsr 	EvaluateStringX 			; string parameter
.0198f5	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.0198f8	5a		phy				phy
.0198f9	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0198fb	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0198fd	f0 43		beq $019942			beq 	_UDFail 					; must fail if zero.
.0198ff	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019902	a9 00		lda #$00			lda 	#0 							; set result to zero
.019904	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019906	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019908	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01990a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01990c	a9 01		lda #$01			lda 	#1 							; set type to integer.
.01990e	95 85		sta $85,x			sta 	XS_Type,x
.019910					_UDConvertLoop:
.019910	5a		phy				phy 								; shift mantissa left 4
.019911	a0 04		ldy #$04			ldy 	#4
.019913					_UDShift:
.019913	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019915	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019917	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019919	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01991b	88		dey				dey
.01991c	d0 f5		bne $019913			bne 	_UDShift
.01991e	7a		ply				ply
.01991f	c8		iny				iny 								; next character
.019920	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.019922	20 45 99	jsr $019945			jsr 	ConvertUpper 				; convert to U/C
.019925	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.019927	90 19		bcc $019942			bcc 	_UDFail
.019929	c9 3a		cmp #$3a			cmp 	#"9"+1
.01992b	90 08		bcc $019935			bcc 	_UDOkay
.01992d	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.01992f	90 11		bcc $019942			bcc 	_UDFail 					; fails if between 9 and @
.019931	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.019933	b0 0d		bcs $019942			bcs 	_UDFail
.019935					_UDOkay:
.019935	29 0f		and #$0f			and 	#15 						; nibble only
.019937	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.019939	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01993b	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.01993e	d0 d0		bne $019910			bne 	_UDConvertLoop
.019940	7a		ply				ply
.019941	60		rts				rts
.019942					_UDFail:
.019942	4c 75 85	jmp $018575			jmp 	BadParamError
.019945					ConvertUpper:
.019945	c9 61		cmp #$61			cmp 	#"a"
.019947	90 07		bcc $019950			bcc 	_CUExit
.019949	c9 7b		cmp #$7b			cmp 	#"z"+1
.01994b	b0 03		bcs $019950			bcs 	_CUExit
.01994d	38		sec				sec
.01994e	e9 20		sbc #$20			sbc 	#32
.019950	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019951					Unary_Chr:
.019951	20 eb 93	jsr $0193eb			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.019954	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; right bracket.
.019957	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.019959	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01995b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01995d	d0 0d		bne $01996c			bne 	_UCChar
.01995f	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019961	20 82 9a	jsr $019a82			jsr 	AllocateTempString			; allocate it.
.019964	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019966	20 ad 9a	jsr $019aad			jsr 	WriteTempString
.019969	4c aa 99	jmp $0199aa			jmp 	UnaryReturnTempStr 			; and return that string.
.01996c					_UCChar:
.01996c	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.01996f					Unary_Spc:
.01996f	20 8b 98	jsr $01988b			jsr 	SLIByteParameter 			; get number of spaces
.019972	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; skip )
.019975	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.019977					UnarySpcCreate:
.019977	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.019979	b0 14		bcs $01998f			bcs 	_USSize
.01997b	48		pha				pha 								; save length
.01997c	1a		inc a				inc 	a 							; allocate one more.
.01997d	20 82 9a	jsr $019a82			jsr 	AllocateTempString
.019980	68		pla				pla 								; get length
.019981	f0 27		beq $0199aa			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.019983					_USLoop:
.019983	48		pha				pha
.019984	a9 20		lda #$20			lda 	#" "
.019986	20 ad 9a	jsr $019aad			jsr 	WriteTempString
.019989	68		pla				pla
.01998a	3a		dec a				dec 	a
.01998b	d0 f6		bne $019983			bne 	_USLoop
.01998d	80 1b		bra $0199aa			bra 	UnaryReturnTempStr 			; and return the temporary space.
.01998f					_USSize:
.01998f	4c 75 85	jmp $018575			jmp 	BadParamError
.019992					Unary_Tab:
.019992	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019994	20 8b 98	jsr $01988b			jsr 	SLIByteParameter
.019997	20 35 9a	jsr $019a35			jsr 	CheckNextRParen
.01999a	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; were are we ?
.01999d	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.01999f	38		sec				sec
.0199a0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.0199a2	e5 10		sbc $10				sbc 	zTemp1
.0199a4	b0 d1		bcs $019977			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.0199a6	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.0199a8	80 cd		bra $019977			bra 	UnarySpcCreate
.0199aa					UnaryReturnTempStr:
.0199aa	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.0199ac	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0199ae	a5 23		lda $23				lda 	zTempStr+1
.0199b0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0199b2	a9 02		lda #$02			lda 	#2 							; set type to string
.0199b4	95 85		sta $85,x			sta 	XS_Type,x
.0199b6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0199b7					MemRead:
.0199b7	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199ba	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199bc	b7 1c		lda [$1c],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0199be	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0199c0	c8		iny				iny 								; next to copy
.0199c1	e8		inx				inx
.0199c2	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199c5	d0 f5		bne $0199bc			bne 	_MLoop1
.0199c7	60		rts				rts
.0199c8					MemWrite:
.0199c8	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199cb	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199cd	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0199cf	97 1c		sta [$1c],y			sta 	[zlTemp1],y 				; write it out
.0199d1	c8		iny				iny 								; next to copy
.0199d2	e8		inx				inx
.0199d3	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199d6	d0 f5		bne $0199cd			bne 	_MLoop1
.0199d8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0199d9					UpdateProgramEnd:
.0199d9	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0199db	85 18		sta $18				sta 	zCodePtr+0
.0199dd	a9 10		lda #$10			lda 	#((BasicProgram) >> 8)
.0199df	85 19		sta $19				sta 	zCodePtr+1
.0199e1	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.0199e3	85 1a		sta $1a				sta 	zCodePtr+2
.0199e5	85 1b		sta $1b				sta 	zCodePtr+3
.0199e7	a0 03		ldy #$03			ldy 	#3
.0199e9					_UPDLoop:
.0199e9	a0 00		ldy #$00			ldy 	#0
.0199eb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199ed	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0199ef	f0 0f		beq $019a00			beq 	_UPDFoundEnd
.0199f1	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0199f3	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0199f5	18		clc				clc
.0199f6	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0199f8	85 18		sta $18				sta 	zCodePtr
.0199fa	90 02		bcc $0199fe			bcc 	_SNLNoCarry
.0199fc	e6 19		inc $19				inc 	zCodePtr+1
.0199fe					_SNLNoCarry:
.0199fe	80 e9		bra $0199e9			bra 	_UPDLoop
.019a00					_UPDFoundEnd:
.019a00	18		clc				clc 								; end of program 2 on.
.019a01	a5 18		lda $18				lda 	zCodePtr
.019a03	69 02		adc #$02			adc 	#2
.019a05	8d 04 03	sta $0304			sta 	endOfProgram
.019a08	a5 19		lda $19				lda 	zCodePtr+1
.019a0a	69 00		adc #$00			adc 	#0
.019a0c	8d 05 03	sta $0305			sta 	endOfProgram+1
.019a0f	a5 1a		lda $1a				lda 	zCodePtr+2
.019a11	69 00		adc #$00			adc		#0
.019a13	8d 06 03	sta $0306			sta 	endOfProgram+2
.019a16	a5 1b		lda $1b				lda 	zCodePtr+3
.019a18	69 00		adc #$00			adc 	#0
.019a1a	8d 07 03	sta $0307			sta 	endOfProgram+3
.019a1d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019a1e					CheckNextToken:
.019a1e	d7 18		cmp [$18],y			cmp 	[zCodePtr],y
.019a20	d0 02		bne $019a24			bne 	CTFail 						; no, then fail
.019a22	c8		iny				iny
.019a23	60		rts				rts
.019a24					CTFail:
.019a24	20 86 85	jsr $018586			jsr ERR_Handler
>019a27	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019a2f	74 6f 6b 65 6e 00
.019a35					CheckNextRParen:
.019a35	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a37	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.019a39	d0 e9		bne $019a24			bne 	CTFail 						; fail if not
.019a3b	c8		iny				iny
.019a3c	60		rts				rts
.019a3d					CheckNextComma:
.019a3d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a3f	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.019a41	d0 e1		bne $019a24			bne 	CTFail 						; fail if not
.019a43	c8		iny				iny
.019a44	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019a45					StringConcrete:
.019a45	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.019a47	85 10		sta $10				sta 	zTemp1
.019a49	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a4b	85 11		sta $11				sta 	zTemp1+1
.019a4d	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019a4f	b1 10		lda ($10),y			lda 	(zTemp1),y
.019a51	f0 26		beq $019a79			beq		_SCEmpty 					; concreting it wastes memory.
.019a53	18		clc				clc 								; from the string pointer
.019a54	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019a57	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019a59	8d 00 03	sta $0300			sta 	StringPtr
.019a5c	85 12		sta $12				sta 	zTemp2
.019a5e	ad 01 03	lda $0301			lda 	StringPtr+1
.019a61	e9 00		sbc #$00			sbc 	#0
.019a63	8d 01 03	sta $0301			sta 	StringPtr+1
.019a66	85 13		sta $13				sta 	zTemp2+1
.019a68	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019a6a	1a		inc a				inc 	a
.019a6b	aa		tax				tax
.019a6c	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019a6e	91 12		sta ($12),y			sta 	(zTemp2),y
.019a70	c8		iny				iny
.019a71	ca		dex				dex
.019a72	d0 f8		bne $019a6c			bne 	_SCCopy
.019a74	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019a76	a6 12		ldx $12				ldx 	zTemp2
.019a78	60		rts				rts
.019a79					_SCEmpty:
.019a79	a9 00		lda #$00			lda 	#0
.019a7b	85 27		sta $27				sta 	zNullString
.019a7d	a9 00		lda #$00			lda 	#zNullString >> 8
.019a7f	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.019a81	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019a82					AllocateTempString:
.019a82	48		pha				pha 								; save required count.
.019a83	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.019a85	d0 0b		bne $019a92			bne 	_ATSInitialised
.019a87	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019a8a	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.019a8c	ad 01 03	lda $0301			lda 	StringPtr+1
.019a8f	3a		dec a				dec 	a 							; allow the page.
.019a90	85 23		sta $23				sta 	zTempStr+1
.019a92					_ATSInitialised:
.019a92	68		pla				pla 								; get required count back.
.019a93	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.019a95	1a		inc a				inc 	a
.019a96	18		clc				clc
.019a97	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.019a99	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.019a9b	a9 ff		lda #$ff			lda 	#$FF
.019a9d	65 23		adc $23				adc 	zTempStr+1
.019a9f	85 23		sta $23				sta 	zTempStr+1
.019aa1	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019aa3	5a		phy				phy
.019aa4	a8		tay				tay
.019aa5	91 22		sta ($22),y			sta 	(zTempStr),y
.019aa7	7a		ply				ply
.019aa8	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019aa9	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019aac	60		rts				rts
.019aad					WriteTempString:
.019aad	5a		phy				phy 								; save Y
.019aae	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019ab1	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.019ab3	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019ab6	98		tya				tya 								; unchanged Y is now length
.019ab7	a0 00		ldy #$00			ldy 	#0
.019ab9	91 22		sta ($22),y			sta 	(zTempStr),y
.019abb	7a		ply				ply 								; restore Y and exit
.019abc	60		rts				rts
.019abd					CreateTempStringCopy:
.019abd	da		phx				phx 								; save X
.019abe	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ac0	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019ac1	20 82 9a	jsr $019a82			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019ac4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ac6	c8		iny				iny
.019ac7	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019ac8	3a		dec a				dec 	a 							; for the marker and the length.
.019ac9	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019acb	81 22		sta ($22,x)			sta 	(zTempStr,x)
.019acd	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.019acf	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019ad1	f0 0e		beq $019ae1			beq 	_CTSCExit
.019ad3					_CTSCLoop:
.019ad3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ad5	c8		iny				iny
.019ad6	5a		phy				phy 								; save Y
.019ad7	e8		inx				inx 								; bump index
.019ad8	da		phx				phx 								; save that
.019ad9	7a		ply				ply 								; index into Y
.019ada	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.019adc	7a		ply				ply 								; restore Y
.019add	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.019adf	d0 f2		bne $019ad3			bne 	_CTSCLoop
.019ae1					_CTSCExit:
.019ae1	fa		plx				plx 								; restore X
.019ae2	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.019ae3					TokeniseKeyword:
.019ae3	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.019ae4	18		clc				clc
.019ae5	65 20		adc $20				adc 	zGenPtr
.019ae7	85 20		sta $20				sta 	zGenPtr
.019ae9	90 02		bcc $019aed			bcc 	_TKWNoBump
.019aeb	e6 21		inc $21				inc 	zGenPtr+1
.019aed					_TKWNoBump:
.019aed	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.019aef	da		phx				phx
.019af0	a9 cd		lda #$cd			lda 	#KeyWordText & $FF 			; scan this table.
.019af2	a2 86		ldx #$86			ldx 	#(KeyWordText >> 8) & $FF
.019af4	20 ff 9a	jsr $019aff			jsr 	TKWScanTokenTable
.019af7	fa		plx				plx
.019af8	90 04		bcc $019afe			bcc 	_TKWNoWrite
.019afa	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.019afd	e8		inx				inx
.019afe					_TKWNoWrite:
.019afe	60		rts				rts
.019aff					TKWScanTokenTable:
.019aff	86 1d		stx $1d				stx 	zLTemp1+1
.019b01	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.019b03	a9 01		lda #$01			lda 	#KeywordText >> 16 				; 24 bit addresses in the 65816
.019b05	85 1e		sta $1e				sta 	zLTemp1+2 						; lovely.
.019b07	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.019b09	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.019b0b	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019b0d	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise 					; save this in zTemp3
.019b10	85 14		sta $14				sta 	zTemp3
.019b12	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.019b14	85 15		sta $15				sta 	zTemp3+1
.019b16					_TKWScanLoop:
.019b16	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b18	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.019b1a	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.019b1c	d0 26		bne $019b44			bne		_TKWNext 						; if it doesn't match, go to next.
.019b1e	20 63 9b	jsr $019b63			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b21	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.019b23					_TKWCompareFull:
.019b23	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b25	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.019b27	85 16		sta $16				sta 	zTemp4
.019b29	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.019b2b	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise 					; make it U/C
.019b2e	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.019b30	d0 12		bne $019b44			bne 	_TKWNext 						; failed, go to next slot.
.019b32	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b34	c8		iny				iny 									; bump pointer
.019b35	0a		asl a				asl 	a 								; shift bit 7 into C
.019b36	90 eb		bcc $019b23			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.019b38	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.019b3a	90 08		bcc $019b44			bcc 	_TKWNext 						; if shorter, the original was better
.019b3c	84 12		sty $12				sty 	zTemp2							; update longest match.
.019b3e	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.019b40	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.019b42	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.019b44					_TKWNext:
.019b44	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b46	c8		iny				iny 									; next one.
.019b47	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.019b48	90 fa		bcc $019b44			bcc 	_TKWNext
.019b4a	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.019b4c	98		tya				tya 									; has Y gone negative.
.019b4d	10 03		bpl $019b52			bpl 	_TKWNoYZero
.019b4f	20 63 9b	jsr $019b63			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b52					_TKWNoYZero:
.019b52	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b54	d0 c0		bne $019b16			bne 	_TKWScanLoop 					; if not, try the next one.
.019b56	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.019b58	f0 05		beq $019b5f			beq 	_TKWFail 						; if zero, none found.
.019b5a	a8		tay				tay 									; return the token in zTemp2, length => y
.019b5b	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.019b5d	38		sec				sec
.019b5e	60		rts				rts
.019b5f					_TKWFail:
.019b5f	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.019b61	18		clc				clc
.019b62	60		rts				rts
.019b63					_TKWClearY:
.019b63	98		tya				tya
.019b64	18		clc				clc
.019b65	65 1c		adc $1c				adc 	zLTemp1
.019b67	85 1c		sta $1c				sta 	zLTemp1
.019b69	90 02		bcc $019b6d			bcc 	_TKWCNoBump
.019b6b	e6 1d		inc $1d				inc 	zLTemp1+1
.019b6d					_TKWCNoBump:
.019b6d	a0 00		ldy #$00			ldy 	#0
.019b6f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.019b70					TokeniseString:
.019b70	85 20		sta $20				sta 	zGenPtr 					; save source
.019b72	86 21		stx $21				stx 	zGenPtr+1
.019b74	a0 00		ldy #$00			ldy 	#0 							; source
.019b76	a2 03		ldx #$03			ldx 	#3 							; target
.019b78	8c 00 04	sty $0400			sty 	TokeniseBuffer+0 			; write three NULLs. So it looks like
.019b7b	8c 01 04	sty $0401			sty 	TokeniseBuffer+1 			; there's a line number zero.
.019b7e	8c 02 04	sty $0402			sty 	TokeniseBuffer+2
.019b81					_TSMainLoop:
.019b81					_TSSkipSpaces:
.019b81	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.019b83	c8		iny				iny
.019b84	c9 20		cmp #$20			cmp 	#" "
.019b86	f0 f9		beq $019b81			beq 	_TSSkipSpaces
.019b88	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.019b8a	90 0a		bcc $019b96			bcc 	_TSNotConstant
.019b8c	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b8e	b0 06		bcs $019b96			bcs 	_TSNotConstant
.019b90	88		dey				dey 								; point back to start
.019b91	20 b5 9c	jsr $019cb5			jsr 	TokeniseConstant 			; tokenise a constant
.019b94	80 eb		bra $019b81			bra 	_TSMainLoop			 		; and loop back.
.019b96					_TSNotConstant:
.019b96	c9 20		cmp #$20			cmp 	#32 						; end of line.
.019b98	90 52		bcc $019bec			bcc 	_TSExit
.019b9a	c9 22		cmp #$22			cmp		#'"'						; quoted string
.019b9c	f0 55		beq $019bf3			beq 	_TSQuotedString
.019b9e	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.019ba0	f0 56		beq $019bf8			beq 	_TSDecimal
.019ba2	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise 				; make U/C
.019ba5	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.019ba7	d0 05		bne $019bae			bne 	_TSNoRemCheck
.019ba9	20 fd 9b	jsr $019bfd			jsr 	TOKCheckREM
.019bac	b0 d3		bcs $019b81			bcs 	_TSMainLoop 				; and if REM okay, go back.
.019bae					_TSNoRemCheck:
.019bae	88		dey				dey 								; point to character
.019baf	20 e3 9a	jsr $019ae3			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.019bb2	b0 cd		bcs $019b81			bcs 	_TSMainLoop					; true if tokenised okay.
.019bb4	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.019bb6	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise
.019bb9	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.019bbb	90 04		bcc $019bc1			bcc 	_TSSingle
.019bbd	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019bbf	90 0d		bcc $019bce			bcc 	_TSAlphaNumeric
.019bc1					_TSSingle:
.019bc1	c8		iny				iny 								; skip over output
.019bc2	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.019bc4	09 80		ora #$80			ora 	#128
.019bc6	f0 b9		beq $019b81			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.019bc8	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bcb	e8		inx				inx
.019bcc	80 b3		bra $019b81			bra 	_TSMainLoop
.019bce					_TSAlphaNumeric:
.019bce	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.019bd0	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise
.019bd3	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.019bd5	90 aa		bcc $019b81			bcc 	_TSMainLoop
.019bd7	c9 3a		cmp #$3a			cmp 	#"9"+1
.019bd9	90 0a		bcc $019be5			bcc 	_TSANOkay
.019bdb	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.019bdd	90 a2		bcc $019b81			bcc 	_TSMainLoop
.019bdf	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019be1	b0 9e		bcs $019b81			bcs 	_TSMainLoop
.019be3	29 3f		and #$3f			and 	#63 						; write it out
.019be5					_TSANOkay:
.019be5	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019be8	e8		inx				inx
.019be9	c8		iny				iny
.019bea	80 e2		bra $019bce			bra 	_TSAlphaNumeric
.019bec	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.019bee	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bf1	8a		txa				txa 								; return length of tokenised line in bytes.
.019bf2	60		rts				rts
.019bf3					_TSQuotedString:
.019bf3	20 53 9c	jsr $019c53			jsr 	TokeniseQuotedString
.019bf6	80 89		bra $019b81			bra 	_TSMainLoop
.019bf8					_TSDecimal:
.019bf8	20 79 9c	jsr $019c79			jsr 	TokeniseDecimalString
.019bfb	80 84		bra $019b81			bra 	_TSMainLoop
.019bfd					TOKCheckREM:
.019bfd	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.019bff	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise
.019c02	c9 45		cmp #$45			cmp 	#"E"
.019c04	d0 12		bne $019c18			bne 	_TCRFail
.019c06	c8		iny				iny
.019c07	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.019c09	88		dey				dey
.019c0a	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise
.019c0d	c9 4d		cmp #$4d			cmp 	#"M"
.019c0f	d0 07		bne $019c18			bne 	_TCRFail
.019c11	c8		iny				iny									; point to first character
.019c12	c8		iny				iny
.019c13	20 25 9c	jsr $019c25			jsr 	TokeniseREMString 			; tokenise REM
.019c16	38		sec				sec
.019c17	60		rts				rts
.019c18					_TCRFail:
.019c18	18		clc				clc
.019c19	60		rts				rts
.019c1a					TOKCapitalise:
.019c1a	c9 61		cmp #$61			cmp 	#"a"
.019c1c	90 06		bcc $019c24			bcc 	_TOKCExit
.019c1e	c9 7b		cmp #$7b			cmp 	#"z"+1
.019c20	b0 02		bcs $019c24			bcs 	_TOKCExit
.019c22	49 20		eor #$20			eor 	#$20
.019c24					_TOKCExit:
.019c24	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.019c25					TokeniseREMString:
.019c25	86 10		stx $10				stx 	zTemp1 						; save position
.019c27	a9 ff		lda #$ff			lda 	#$FF 						; write marker
.019c29	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c2c	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.019c2f	e8		inx				inx 								; bump, and one space for the count.
.019c30	e8		inx				inx
.019c31					_TSRSkip:
.019c31	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c33	c8		iny				iny
.019c34	c9 20		cmp #$20			cmp 	#" "
.019c36	f0 f9		beq $019c31			beq 	_TSRSkip
.019c38	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.019c3a	f0 31		beq $019c6d			beq 	SequenceExit 				; ... that's it.
.019c3c					_TSRCopy:
.019c3c	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.019c3f	e8		inx				inx
.019c40	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.019c42	f0 05		beq $019c49			beq 	_TSRExit 					; zero is exit
.019c44	c8		iny				iny 								; bump pointer
.019c45	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.019c47	d0 f3		bne $019c3c			bne 	_TSRCopy
.019c49					_TSRExit:
.019c49	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.019c4c	c9 20		cmp #$20			cmp 	#" "
.019c4e	d0 1d		bne $019c6d			bne 	SequenceExit
.019c50	ca		dex				dex 								; go back - will bump into $FF eventually.
.019c51	80 f6		bra $019c49			bra 	_TSRExit
.019c53					TokeniseQuotedString:
.019c53	86 10		stx $10				stx 	zTemp1 						; save position
.019c55	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019c57	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c5a	e8		inx				inx 								; bump, and one space for the count.
.019c5b	e8		inx				inx
.019c5c					_TSQCopy:
.019c5c	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c5e	c9 20		cmp #$20			cmp 	#" "
.019c60	90 0b		bcc $019c6d			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.019c62	c8		iny				iny
.019c63	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.019c65	f0 06		beq $019c6d			beq 	SequenceExit
.019c67	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.019c6a	e8		inx				inx
.019c6b	80 ef		bra $019c5c			bra 	_TSQCopy
.019c6d					SequenceExit:
.019c6d	8a		txa				txa 								; current position
.019c6e	38		sec				sec 								; subtract start.
.019c6f	e5 10		sbc $10				sbc 	zTemp1
.019c71	da		phx				phx 								; copy that in
.019c72	a6 10		ldx $10				ldx 	zTemp1
.019c74	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.019c77	fa		plx				plx
.019c78	60		rts				rts
.019c79					TokeniseDecimalString:
.019c79	86 10		stx $10				stx 	zTemp1 						; save position
.019c7b	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.019c7d	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c80	e8		inx				inx 								; bump, and one space for the count.
.019c81	e8		inx				inx
.019c82	20 a3 9c	jsr $019ca3			jsr 	_TDSCopyNumber 				; copy a number.
.019c85	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.019c87	20 1a 9c	jsr $019c1a			jsr 	TOKCapitalise
.019c8a	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.019c8c	d0 df		bne $019c6d			bne 	SequenceExit 				; exit now.
.019c8e	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.019c91	e8		inx				inx
.019c92	c8		iny				iny
.019c93	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.019c95	c9 2d		cmp #$2d			cmp 	#"-"
.019c97	d0 05		bne $019c9e			bne 	_TDSNoMinusExponent
.019c99	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.019c9c	e8		inx				inx
.019c9d	c8		iny				iny
.019c9e					_TDSNoMinusExponent:
.019c9e	20 a3 9c	jsr $019ca3			jsr 	_TDSCopyNumber 				; do the exponent
.019ca1	80 ca		bra $019c6d			bra 	SequenceExit
.019ca3					_TDSCopyNumber:
.019ca3	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019ca5	c9 30		cmp #$30			cmp 	#"0"
.019ca7	90 0b		bcc $019cb4			bcc 	_TDSCNExit
.019ca9	c9 3a		cmp #$3a			cmp 	#"9"+1
.019cab	b0 07		bcs $019cb4			bcs 	_TDSCNExit
.019cad	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019cb0	e8		inx				inx
.019cb1	c8		iny				iny
.019cb2	80 ef		bra $019ca3			bra 	_TDSCopyNumber
.019cb4					_TDSCNExit:
.019cb4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.019cb5					TokeniseConstant:
.019cb5	da		phx				phx 								; save X
.019cb6	a2 00		ldx #$00			ldx 	#0
.019cb8	20 95 a2	jsr $01a295			jsr 	IntFromStringY 				; get the integer out.
.019cbb	b0 37		bcs $019cf4			bcs 	_TCQ 						; should not happen.
.019cbd	fa		plx				plx 								; restore X.
.019cbe	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.019cc0	85 10		sta $10				sta 	zTemp1
.019cc2					_TCRotate:
.019cc2	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.019cc4	29 c0		and #$c0			and 	#$C0
.019cc6	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.019cc8	05 82		ora $82				ora 	XS_Mantissa+2
.019cca	05 83		ora $83				ora 	XS_Mantissa+3
.019ccc	f0 16		beq $019ce4			beq 	_TCDone						; if so, at the bottom.
.019cce	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.019cd0	29 3f		and #$3f			and 	#$3F
.019cd2	48		pha				pha
.019cd3	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.019cd5	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.019cd7					_TCShiftRight:
.019cd7	46 83		lsr $83				lsr 	XS_Mantissa+3
.019cd9	66 82		ror $82				ror 	XS_Mantissa+2
.019cdb	66 81		ror $81				ror 	XS_Mantissa+1
.019cdd	66 80		ror $80				ror 	XS_Mantissa+0
.019cdf	3a		dec a				dec 	a
.019ce0	d0 f5		bne $019cd7			bne 	_TCShiftRight
.019ce2	80 de		bra $019cc2			bra 	_TCRotate 					; and go round again.
.019ce4	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.019ce6					_TCWrite:
.019ce6	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.019ce8	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019ceb	e8		inx				inx
.019cec	c6 10		dec $10				dec 	zTemp1 						; done all of them
.019cee	30 03		bmi $019cf3			bmi 	_TCExit 					; no , more to pop
.019cf0	68		pla				pla
.019cf1	80 f3		bra $019ce6			bra 	_TCWrite 					; until everything's off.
.019cf3					_TCExit:
.019cf3	60		rts				rts
.019cf4					_TCQ:
.019cf4	20 86 85	jsr $018586			jsr ERR_Handler
>019cf7	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019cfa					VariableFind:
.019cfa	20 67 9d	jsr $019d67			jsr 	VariableExtract 		; find out all about it ....
.019cfd	20 00 a0	jsr $01a000			jsr 	VariableLocate 			; does it already exist ?
.019d00	b0 03		bcs $019d05			bcs 	_VFExists 				; if so, use that.
.019d02	20 f3 9d	jsr $019df3			jsr 	VariableCreate 			; otherwise create it.
.019d05					_VFExists:
.019d05	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.019d07	29 01		and #$01			and 	#1
.019d09	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d0b	d0 28		bne $019d35			bne 	_VFSingleElement
.019d0d					_VFNextIndex:
.019d0d	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019d0f	48		pha				pha
.019d10	a5 25		lda $25				lda 	zVarDataPtr+1
.019d12	48		pha				pha
.019d13	a5 26		lda $26				lda 	zVarType
.019d15	48		pha				pha
.019d16	20 e9 93	jsr $0193e9			jsr 	EvaluateInteger 		; calculate the index.
.019d19	68		pla				pla 							; restore and index.
.019d1a	85 26		sta $26				sta 	zVarType
.019d1c	68		pla				pla
.019d1d	85 25		sta $25				sta 	zVarDataPtr+1
.019d1f	68		pla				pla
.019d20	85 24		sta $24				sta 	zVarDataPtr
.019d22	20 7e 9e	jsr $019e7e			jsr 	ArrayIndexFollow 		; do the index.
.019d25	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.019d27	29 01		and #$01			and 	#1
.019d29	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d2b	d0 05		bne $019d32			bne 	_VFArrayDone 			; if so then exit.
.019d2d	20 3d 9a	jsr $019a3d			jsr 	CheckNextComma 			; comma should follow
.019d30	80 db		bra $019d0d			bra 	_VFNextIndex
.019d32					_VFArrayDone:
.019d32	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 		; check closing right bracket.
.019d35					_VFSingleElement:
.019d35	60		rts				rts
.019d36					VariableClear:
.019d36	48		pha				pha 							; save registers
.019d37	da		phx				phx
.019d38	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019d3a	8a		txa				txa
.019d3b	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019d3e	e8		inx				inx
.019d3f	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019d41	d0 f8		bne $019d3b			bne 	_VCLoop
.019d43	ad 04 03	lda $0304			lda 	endOfProgram
.019d46	8d 02 03	sta $0302			sta 	VarMemPtr
.019d49	ad 05 03	lda $0305			lda 	endOfProgram+1
.019d4c	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019d4f	fa		plx				plx 							; restore registers
.019d50	68		pla				pla
.019d51	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019d52					VariableNameError:
.019d52	20 86 85	jsr $018586			jsr ERR_Handler
>019d55	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019d5d	61 62 6c 65 20 4e 61 6d 65 00
.019d67					VariableExtract:
.019d67	da		phx				phx 							; save X.
.019d68	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019d6a	8d 95 03	sta $0395			sta 	Var_Type
.019d6d	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019d70	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d72	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019d74	f0 dc		beq $019d52			beq 	VariableNameError
.019d76	c9 1b		cmp #$1b			cmp 	#26+1
.019d78	b0 d8		bcs $019d52			bcs 	VariableNameError
.019d7a	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019d7c					_VECopyBuffer:
.019d7c	e8		inx				inx
.019d7d	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019d7f	f0 d1		beq $019d52			beq 	VariableNameError
.019d81	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019d84	18		clc				clc  							; update the hash value for it.
.019d85	6d 96 03	adc $0396			adc 	Var_Hash
.019d88	8d 96 03	sta $0396			sta 	Var_Hash
.019d8b	c8		iny				iny
.019d8c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d8e	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019d90	f0 0e		beq $019da0			beq 	_VECopyEnd
.019d92	30 0c		bmi $019da0			bmi 	_VECopyEnd
.019d94	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019d96	90 e4		bcc $019d7c			bcc 	_VECopyBuffer
.019d98	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019d9a	90 04		bcc $019da0			bcc 	_VECopyEnd
.019d9c	c9 3a		cmp #$3a			cmp 	#"9"+1
.019d9e	90 dc		bcc $019d7c			bcc 	_VECopyBuffer
.019da0					_VECopyEnd:
.019da0	c8		iny				iny
.019da1	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019da3	90 04		bcc $019da9			bcc 	_VEDefaultRequired
.019da5	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019da7	90 0b		bcc $019db4			bcc 	_VEHaveType
.019da9					_VEDefaultRequired:
.019da9	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019dab	f0 04		beq $019db1			beq 	_VESetType 				; default set above.
.019dad	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019db0	88		dey				dey
.019db1					_VESetType:
.019db1	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019db4					_VEHaveType:
.019db4	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019db7	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019dba	09 80		ora #$80			ora 	#$80
.019dbc	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019dbf	e8		inx				inx 							; offset 3 => length 4.
.019dc0	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019dc3	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019dc6	38		sec				sec
.019dc7	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019dc9	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019dca	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019dcb	0a		asl a				asl 	a
.019dcc	0a		asl a				asl 	a
.019dcd	8d 98 03	sta $0398			sta 	Var_HashAddress
.019dd0	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019dd3	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019dd5	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019dd6	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019dd9	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019ddb	8d 98 03	sta $0398			sta 	Var_HashAddress
.019dde	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019de0	ad 95 03	lda $0395			lda 	Var_Type
.019de3	c9 b9		cmp #$b9			cmp 	#token_Hash
.019de5	f0 07		beq $019dee			beq 	_VEHaveSize
.019de7	ca		dex				dex
.019de8	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019dea	f0 02		beq $019dee			beq 	_VEHaveSize
.019dec	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019dee					_VEHaveSize:
.019dee	8e 99 03	stx $0399			stx 	Var_DataSize
.019df1	fa		plx				plx
.019df2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019df3					VariableCreate:
.019df3	da		phx				phx
.019df4	5a		phy				phy
.019df5	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019df8	85 10		sta $10				sta 	zTemp1
.019dfa	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019dfd	85 11		sta $11				sta 	zTemp1+1
.019dff	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019e02	18		clc				clc
.019e03	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019e06	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019e08	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019e0b	8d 02 03	sta $0302			sta 	VarMemPtr
.019e0e	90 03		bcc $019e13			bcc 	_VCNoCarry
.019e10	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019e13					_VCNoCarry:
.019e13	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019e16	85 12		sta $12				sta 	zTemp2
.019e18	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019e1a	85 13		sta $13				sta 	zTemp2+1
.019e1c	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019e1e	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e20	91 10		sta ($10),y			sta 	(zTemp1),y
.019e22	c8		iny				iny
.019e23	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e25	91 10		sta ($10),y			sta 	(zTemp1),y
.019e27	c8		iny				iny
.019e28	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019e2b	91 10		sta ($10),y			sta 	(zTemp1),y
.019e2d	c8		iny				iny
.019e2e	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019e30					_VCCopyName:
.019e30	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019e33	91 10		sta ($10),y			sta 	(zTemp1),y
.019e35	e8		inx				inx
.019e36	c8		iny				iny
.019e37	ec 97 03	cpx $0397			cpx 	Var_Length
.019e3a	d0 f4		bne $019e30			bne 	_VCCopyName
.019e3c	5a		phy				phy 								; save the data offset.
.019e3d	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019e40	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019e42					_VCClearData:
.019e42	91 10		sta ($10),y			sta 	(zTemp1),y
.019e44	c8		iny				iny
.019e45	ca		dex				dex
.019e46	d0 fa		bne $019e42			bne 	_VCClearData
.019e48	68		pla				pla 								; offset to the data
.019e49	18		clc				clc
.019e4a	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019e4c	85 24		sta $24				sta 	zVarDataPtr
.019e4e	a5 11		lda $11				lda 	zTemp1+1
.019e50	69 00		adc #$00			adc 	#0
.019e52	85 25		sta $25				sta 	zVarDataPtr+1
.019e54	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019e57	85 26		sta $26				sta 	zVarType
.019e59	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019e5b	a0 00		ldy #$00			ldy 	#0
.019e5d	91 12		sta ($12),y			sta 	(zTemp2),y
.019e5f	c8		iny				iny
.019e60	a5 11		lda $11				lda 	zTemp1+1
.019e62	91 12		sta ($12),y			sta 	(zTemp2),y
.019e64	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019e67	29 01		and #$01			and 	#1
.019e69	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019e6b	d0 0e		bne $019e7b			bne 	_VCNotArray
.019e6d	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019e6f	20 15 9f	jsr $019f15			jsr 	ArrayCreate
.019e72	5a		phy				phy 								; save YA at zVarDataPtr
.019e73	a0 00		ldy #$00			ldy 	#0
.019e75	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e77	c8		iny				iny
.019e78	68		pla				pla
.019e79	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e7b					_VCNotArray:
.019e7b	7a		ply				ply
.019e7c	fa		plx				plx
.019e7d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019e7e					ArrayIndexFollow:
.019e7e	5a		phy				phy
.019e7f	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019e81	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019e83	48		pha				pha
.019e84	c8		iny				iny
.019e85	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e87	85 25		sta $25				sta 	zVarDataPtr+1
.019e89	68		pla				pla
.019e8a	85 24		sta $24				sta 	zVarDataPtr
.019e8c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019e8e	29 80		and #$80			and 	#$80 						; must be zero.
.019e90	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e92	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e94	d0 59		bne $019eef			bne 	_AIFError
.019e96	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019e98	18		clc				clc
.019e99	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e9b	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e9d	c8		iny				iny
.019e9e	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019ea0	08		php				php 								; clear bit 7 retaining borrow.
.019ea1	29 7f		and #$7f			and 	#$7F
.019ea3	28		plp				plp
.019ea4	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019ea6	90 47		bcc $019eef			bcc 	_AIFError 					; eror if size-current < 0
.019ea8	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019eaa	0a		asl a				asl 	a 							; (e.g. index * 2)
.019eab	85 10		sta $10				sta 	zTemp1
.019ead	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019eaf	2a		rol a				rol 	a
.019eb0	85 11		sta $11				sta 	zTemp1+1
.019eb2	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019eb4	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019eb6	30 1d		bmi $019ed5			bmi 	_AIFCalculate
.019eb8	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.019eba	a5 26		lda $26				lda 	zVarType 					; check that type
.019ebc	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019ebe	f0 15		beq $019ed5			beq 	_AIFCalculate
.019ec0	06 10		asl $10				asl 	zTemp1			 			; double the index
.019ec2	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019ec4	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019ec6	f0 0d		beq $019ed5			beq 	_AIFCalculate
.019ec8	18		clc				clc 								; add the original mantissa in again
.019ec9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019ecb	65 10		adc $10				adc 	zTemp1
.019ecd	85 10		sta $10				sta 	zTemp1
.019ecf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ed1	65 11		adc $11				adc 	zTemp1+1
.019ed3	85 11		sta $11				sta 	zTemp1+1
.019ed5					_AIFCalculate:
.019ed5	18		clc				clc 								; add index x 2,4 or 5 to base
.019ed6	a5 24		lda $24				lda 	zVarDataPtr
.019ed8	65 10		adc $10				adc 	zTemp1
.019eda	85 24		sta $24				sta 	zVarDataPtr
.019edc	a5 25		lda $25				lda 	zVarDataPtr+1
.019ede	65 11		adc $11				adc 	zTemp1+1
.019ee0	85 25		sta $25				sta 	zVarDataPtr+1
.019ee2	18		clc				clc 								; add 2 more for the length prefix.
.019ee3	a5 24		lda $24				lda 	zVarDataPtr
.019ee5	69 02		adc #$02			adc 	#2
.019ee7	85 24		sta $24				sta 	zVarDataPtr
.019ee9	90 02		bcc $019eed			bcc 	_AIFNoBump
.019eeb	e6 25		inc $25				inc 	zVarDataPtr+1
.019eed					_AIFNoBump:
.019eed	7a		ply				ply
.019eee	60		rts				rts
.019eef					_AIFError:
.019eef	20 86 85	jsr $018586			jsr ERR_Handler
>019ef2	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019efa	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019f02					ArrayResetDefault:
.019f02	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019f04	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019f07	a9 00		lda #$00			lda 	#0
.019f09	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019f0c	a9 ff		lda #$ff			lda 	#$FF
.019f0e	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019f11	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019f14	60		rts				rts
.019f15					ArrayCreate:
.019f15	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019f18	0a		asl a				asl 	a
.019f19	85 10		sta $10				sta 	zTemp1
.019f1b	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f1e	2a		rol a				rol 	a
.019f1f	85 11		sta $11				sta 	zTemp1+1
.019f21	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019f24	10 22		bpl $019f48			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019f26	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019f29	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019f2b	f0 1b		beq $019f48			beq 	_ACSized
.019f2d	06 10		asl $10				asl 	zTemp1 						; double again
.019f2f	26 11		rol $11				rol 	zTemp1+1
.019f31	b0 6f		bcs $019fa2			bcs 	ArrayIndexError 			; too large.
.019f33	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019f35	f0 11		beq $019f48			beq 	_ACSized
.019f37	18		clc				clc 								; add original value x 5 for reals.
.019f38	a5 10		lda $10				lda 	zTemp1
.019f3a	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019f3d	85 10		sta $10				sta 	zTemp1
.019f3f	a5 11		lda $11				lda 	zTemp1+1
.019f41	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019f44	85 11		sta $11				sta 	zTemp1+1
.019f46	b0 5a		bcs $019fa2			bcs 	ArrayIndexError
.019f48					_ACSized:
.019f48	18		clc				clc
.019f49	a5 10		lda $10				lda 	zTemp1
.019f4b	69 02		adc #$02			adc 	#2
.019f4d	85 10		sta $10				sta 	zTemp1
.019f4f	90 04		bcc $019f55			bcc 	_ACNoBump
.019f51	e6 10		inc $10				inc 	zTemp1
.019f53	f0 4d		beq $019fa2			beq 	ArrayIndexError
.019f55					_ACNoBump:
.019f55	18		clc				clc
.019f56	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019f59	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019f5b	85 14		sta $14				sta 	zTemp3
.019f5d	65 10		adc $10				adc 	zTemp1
.019f5f	8d 02 03	sta $0302			sta 	VarMemPtr
.019f62	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019f65	85 13		sta $13				sta 	zTemp2+1
.019f67	85 15		sta $15				sta 	zTemp3+1
.019f69	65 11		adc $11				adc 	zTemp1+1
.019f6b	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019f6e	85 11		sta $11				sta 	zTemp1+1
.019f70	b0 30		bcs $019fa2			bcs 	ArrayIndexError
.019f72	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019f74					_ACClear:
.019f74	98		tya				tya
.019f75	91 12		sta ($12),y			sta 	(zTemp2),y
.019f77	e6 12		inc $12				inc 	zTemp2
.019f79	d0 02		bne $019f7d			bne 	_ACCBump
.019f7b	e6 13		inc $13				inc 	zTemp2+1
.019f7d					_ACCBump:
.019f7d	a5 12		lda $12				lda 	zTemp2
.019f7f	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019f82	d0 f0		bne $019f74			bne 	_ACClear
.019f84	a5 13		lda $13				lda 	zTemp2+1
.019f86	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019f89	d0 e9		bne $019f74			bne 	_ACClear
.019f8b	a0 00		ldy #$00			ldy 	#0
.019f8d	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019f90	91 14		sta ($14),y			sta 	(zTemp3),y
.019f92	c8		iny				iny
.019f93	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f96	91 14		sta ($14),y			sta 	(zTemp3),y
.019f98	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019f9b	10 18		bpl $019fb5			bpl 	ACCFillRecursive
.019f9d	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019f9f	a5 14		lda $14				lda 	zTemp3
.019fa1	60		rts				rts
.019fa2					ArrayIndexError:
.019fa2	20 86 85	jsr $018586			jsr ERR_Handler
>019fa5	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019fad	79 20 69 6e 64 65 78 00
.019fb5					ACCFillRecursive:
.019fb5	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019fb7	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019fb9	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019fbb	c8		iny				iny
.019fbc	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019fbe	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019fc0	91 14		sta ($14),y			sta 	(zTemp3),y
.019fc2	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019fc4	48		pha				pha
.019fc5	a5 15		lda $15				lda 	zTemp3+1
.019fc7	48		pha				pha
.019fc8					_ACCFillLoop:
.019fc8	18		clc				clc
.019fc9	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019fcb	69 02		adc #$02			adc 	#2
.019fcd	85 14		sta $14				sta 	zTemp3
.019fcf	90 02		bcc $019fd3			bcc 	_ACCSkip2
.019fd1	e6 15		inc $15				inc 	zTemp3+1
.019fd3					_ACCSkip2:
.019fd3	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019fd5	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019fd7	c8		iny				iny
.019fd8	11 14		ora ($14),y			ora 	(zTemp3),y
.019fda	d0 21		bne $019ffd			bne 	_ACCExit
.019fdc	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019fde	48		pha				pha
.019fdf	a5 15		lda $15				lda 	zTemp3+1
.019fe1	48		pha				pha
.019fe2	e8		inx				inx
.019fe3	e8		inx				inx
.019fe4	20 15 9f	jsr $019f15			jsr 	ArrayCreate 				; create array recursively.
.019fe7	ca		dex				dex
.019fe8	ca		dex				dex
.019fe9	85 12		sta $12				sta 	zTemp2 						; save A
.019feb	68		pla				pla
.019fec	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019fee	68		pla				pla
.019fef	85 14		sta $14				sta 	zTemp3
.019ff1	98		tya				tya 								; write high bye from Y
.019ff2	a0 01		ldy #$01			ldy 	#1
.019ff4	91 14		sta ($14),y			sta 	(zTemp3),y
.019ff6	88		dey				dey 								; write low byte out.
.019ff7	a5 12		lda $12				lda 	zTemp2
.019ff9	91 14		sta ($14),y			sta 	(zTemp3),y
.019ffb	80 cb		bra $019fc8			bra 	_ACCFillLoop 				; and try again.
.019ffd					_ACCExit:
.019ffd	7a		ply				ply 								; restore the original address
.019ffe	68		pla				pla
.019fff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01a000					VariableLocate:
.01a000	da		phx				phx
.01a001	5a		phy				phy
.01a002	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01a005	85 12		sta $12				sta 	zTemp2 						; points to first address.
.01a007	a9 03		lda #$03			lda 	#HashTableBase >> 8
.01a009	85 13		sta $13				sta 	zTemp2+1
.01a00b	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.01a00d	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a00f	aa		tax				tax
.01a010	c8		iny				iny
.01a011	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a013	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01a015	86 12		stx $12				stx 	zTemp2
.01a017	05 12		ora $12				ora 	zTemp2 						; got zero
.01a019	18		clc				clc
.01a01a	f0 25		beq $01a041			beq 	_VLExit 					; if so, then fail as end of chain.
.01a01c	c8		iny				iny 								; point to hash (offset + 2)
.01a01d	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a01f	cd 96 03	cmp $0396			cmp 	Var_Hash
.01a022	d0 e7		bne $01a00b			bne 	_VLNext 					; try next if different.
.01a024					_VLCompare:
.01a024	c8		iny				iny 								; next character
.01a025	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.01a027	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.01a02a	d0 df		bne $01a00b			bne 	_VLNext 					; fail if different, try next.
.01a02c	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.01a02d	90 f5		bcc $01a024			bcc 	_VLCompare
.01a02f	98		tya				tya
.01a030	38		sec				sec 								; add 1 as Y points to last character
.01a031	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01a033	85 24		sta $24				sta 	zVarDataPtr
.01a035	a5 13		lda $13				lda 	zTemp2+1
.01a037	69 00		adc #$00			adc 	#0
.01a039	85 25		sta $25				sta 	zVarDataPtr+1
.01a03b	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.01a03e	85 26		sta $26				sta 	zVarType
.01a040	38		sec				sec 								; return CS
.01a041	7a		ply		_VLExit:ply
.01a042	fa		plx				plx
.01a043	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01a044					VariableGet:
.01a044	5a		phy				phy
.01a045	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01a047	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a049	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a04b	c8		iny				iny
.01a04c	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a04e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a050	c8		iny				iny
.01a051	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.01a053	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a055	f0 2c		beq $01a083			beq 	_VGString
.01a057	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01a059	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a05b	c8		iny				iny
.01a05c	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a05e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a060	c8		iny				iny
.01a061	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01a063	95 85		sta $85,x			sta 	XS_Type,x
.01a065	a5 26		lda $26				lda 	zVarType
.01a067	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01a069	f0 28		beq $01a093			beq 	_VGExit
.01a06b	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01a06d	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01a06f	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01a071	95 84		sta $84,x			sta 	XS_Exponent,x
.01a073	f0 1e		beq $01a093			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01a075	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01a077	48		pha				pha
.01a078	29 80		and #$80			and 	#$80
.01a07a	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.01a07c	68		pla				pla
.01a07d	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.01a07f	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01a081	80 10		bra $01a093			bra 	_VGExit
.01a083					_VGString:
.01a083	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01a085	95 85		sta $85,x			sta 	XS_Type,x
.01a087	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.01a089	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a08b	d0 06		bne $01a093			bne 	_VGExit 					; if not, exit.
.01a08d	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.01a08f	a9 27		lda #$27			lda 	#zNullString
.01a091	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01a093					_VGExit:
.01a093	7a		ply				ply
.01a094	60		rts				rts
.01a095					VariableSet:
.01a095	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01a097	29 02		and #$02			and 	#2 							; if so, it has to be
.01a099	d0 4b		bne $01a0e6			bne 	_VSString
.01a09b	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.01a09d	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a09f	f0 42		beq $01a0e3			beq 	_VSBadType
.01a0a1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01a0a3	f0 05		beq $01a0aa			beq 	_VSMakeInt
.01a0a5	20 fd a5	jsr $01a5fd			jsr 	FPUToFloat
.01a0a8	80 03		bra $01a0ad			bra 	_VSCopy
.01a0aa					_VSMakeInt:
.01a0aa	20 49 a6	jsr $01a649			jsr 	FPUToInteger
.01a0ad					_VSCopy:
.01a0ad	5a		phy				phy
.01a0ae	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01a0b0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a0b2	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0b4	c8		iny				iny
.01a0b5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0b7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0b9	c8		iny				iny
.01a0ba	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0bc	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0be	c8		iny				iny
.01a0bf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0c1	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0c3	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.01a0c5	c9 bb		cmp #$bb			cmp 	#token_Percent
.01a0c7	f0 18		beq $01a0e1			beq 	_VSExit
.01a0c9	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01a0cb	0a		asl a				asl 	a
.01a0cc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01a0ce	08		php				php
.01a0cf	0a		asl a				asl 	a
.01a0d0	28		plp				plp
.01a0d1	6a		ror a				ror 	a
.01a0d2	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0d4	c8		iny				iny
.01a0d5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.01a0d7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0d9	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.01a0db	50 04		bvc $01a0e1			bvc 	_VSExit
.01a0dd	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.01a0df	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0e1					_VSExit:
.01a0e1	7a		ply				ply
.01a0e2	60		rts				rts
.01a0e3					_VSBadType:
.01a0e3	4c 67 85	jmp $018567			jmp 	TypeError
.01a0e6					_VSString:
.01a0e6	a5 26		lda $26				lda 	zVarType 					; type must be $
.01a0e8	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0ea	d0 f7		bne $01a0e3			bne 	_VSBadType
.01a0ec	da		phx				phx
.01a0ed	5a		phy				phy
.01a0ee	20 45 9a	jsr $019a45			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01a0f1	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01a0f3	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0f5	88		dey				dey 								; save low byte
.01a0f6	8a		txa				txa
.01a0f7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0f9	7a		ply				ply 								; and exit.
.01a0fa	fa		plx				plx
.01a0fb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01a0fc					MulInteger32:
.01a0fc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01a0fe	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01a100	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a102	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01a104	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a106	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01a108	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a10a	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.01a10c	a9 00		lda #$00			lda 	#0
.01a10e	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.01a110	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a112	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a114	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a116					_BFMMultiply:
.01a116	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01a118	29 01		and #$01			and 	#1
.01a11a	f0 03		beq $01a11f			beq 	_BFMNoAdd
.01a11c	20 81 95	jsr $019581			jsr 	AddInteger32 					; co-opt this code
.01a11f					_BFMNoAdd:
.01a11f	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01a121	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01a123	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01a125	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01a127	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01a129	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.01a12b	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01a12d	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01a12f	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01a131	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01a133	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01a135	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01a137	d0 dd		bne $01a116			bne 	_BFMMultiply
.01a139	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01a13a					DivInteger32:
.01a13a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.01a13c	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01a13e	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a140	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a142	d0 14		bne $01a158			bne 	_BFDOkay
.01a144	20 86 85	jsr $018586			jsr ERR_Handler
>01a147	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01a14f	20 62 79 20 5a 65 72 6f 00
.01a158					_BFDOkay:
.01a158	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01a15a	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01a15c	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01a15e	85 1e		sta $1e				sta 	zLTemp1+2
.01a160	85 1f		sta $1f				sta 	zLTemp1+3
.01a162	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01a165	20 bc a1	jsr $01a1bc			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01a168	da		phx				phx
.01a169	e8		inx				inx
.01a16a	e8		inx				inx
.01a16b	e8		inx				inx
.01a16c	e8		inx				inx
.01a16d	e8		inx				inx
.01a16e	e8		inx				inx
.01a16f	20 bc a1	jsr $01a1bc			jsr 	CheckIntegerNegate
.01a172	fa		plx				plx
.01a173	5a		phy				phy 								; Y is the counter
.01a174	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01a176					_BFDLoop:
.01a176	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01a178	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a17a	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a17c	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a17e	26 1c		rol $1c				rol 	zLTemp1
.01a180	26 1d		rol $1d				rol 	zLTemp1+1
.01a182	26 1e		rol $1e				rol 	zLTemp1+2
.01a184	26 1f		rol $1f				rol 	zLTemp1+3
.01a186	38		sec				sec
.01a187	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01a189	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a18b	48		pha				pha
.01a18c	a5 1d		lda $1d				lda 	zLTemp1+1
.01a18e	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a190	48		pha				pha
.01a191	a5 1e		lda $1e				lda 	zLTemp1+2
.01a193	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a195	48		pha				pha
.01a196	a5 1f		lda $1f				lda 	zLTemp1+3
.01a198	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a19a	90 13		bcc $01a1af			bcc 	_BFDNoAdd
.01a19c	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.01a19e	68		pla				pla
.01a19f	85 1e		sta $1e				sta 	zLTemp1+2
.01a1a1	68		pla				pla
.01a1a2	85 1d		sta $1d				sta 	zLTemp1+1
.01a1a4	68		pla				pla
.01a1a5	85 1c		sta $1c				sta 	zLTemp1+0
.01a1a7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01a1a9	09 01		ora #$01			ora 	#1
.01a1ab	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1ad	80 03		bra $01a1b2			bra 	_BFDNext
.01a1af					_BFDNoAdd:
.01a1af	68		pla				pla 								; Throw away the intermediate calculations
.01a1b0	68		pla				pla
.01a1b1	68		pla				pla
.01a1b2					_BFDNext:
.01a1b2	88		dey				dey
.01a1b3	d0 c1		bne $01a176			bne 	_BFDLoop
.01a1b5	7a		ply				ply 								; restore Y
.01a1b6	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.01a1b9	b0 06		bcs $01a1c1			bcs		IntegerNegateAlways 		; negate the result
.01a1bb	60		rts				rts
.01a1bc					CheckIntegerNegate:
.01a1bc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.01a1be	30 01		bmi $01a1c1			bmi 	IntegerNegateAlways 		; if so negate it
.01a1c0	60		rts				rts
.01a1c1					IntegerNegateAlways:
.01a1c1	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.01a1c4	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.01a1c5	a9 00		lda #$00			lda 	#0
.01a1c7	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a1c9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1cb	a9 00		lda #$00			lda 	#0
.01a1cd	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a1cf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1d1	a9 00		lda #$00			lda 	#0
.01a1d3	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a1d5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1d7	a9 00		lda #$00			lda 	#0
.01a1d9	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a1db	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1dd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01a1de					INTToString:
.01a1de	48		pha				pha
.01a1df	5a		phy				phy
.01a1e0	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01a1e2	10 08		bpl $01a1ec			bpl 		_ITSNotMinus
.01a1e4	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a1e6	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter
.01a1e9	20 c1 a1	jsr $01a1c1			jsr 		IntegerNegateAlways 	; negate the number.
.01a1ec					_ITSNotMinus:
.01a1ec	a9 00		lda #$00			lda 		#0
.01a1ee	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01a1f1	8a		txa				txa 								; use Y for the mantissa index.
.01a1f2	a8		tay				tay
.01a1f3	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01a1f5					_ITSNextSubtractor:
.01a1f5	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01a1f7	8d 9b 03	sta $039b			sta 		NumConvCount
.01a1fa					_ITSSubtract:
.01a1fa	38		sec				sec
.01a1fb	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01a1fe	ff 5c a2 01	sbc $01a25c,x			sbc 		_ITSSubtractors+0,x
.01a202	48		pha				pha
.01a203	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01a206	ff 5d a2 01	sbc $01a25d,x			sbc 		_ITSSubtractors+1,x
.01a20a	48		pha				pha
.01a20b	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01a20e	ff 5e a2 01	sbc $01a25e,x			sbc 		_ITSSubtractors+2,x
.01a212	48		pha				pha
.01a213	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01a216	ff 5f a2 01	sbc $01a25f,x			sbc 		_ITSSubtractors+3,x
.01a21a	90 14		bcc $01a230			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01a21c	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01a21f	68		pla				pla
.01a220	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01a223	68		pla				pla
.01a224	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01a227	68		pla				pla
.01a228	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.01a22b	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.01a22e	80 ca		bra $01a1fa			bra 		_ITSSubtract 			; go round again.
.01a230					_ITSCantSubtract:
.01a230	68		pla				pla 								; throw away interim answers
.01a231	68		pla				pla
.01a232	68		pla				pla
.01a233	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01a236	c9 30		cmp #$30			cmp 		#"0"
.01a238	d0 05		bne $01a23f			bne 		_ITSOutputDigit
.01a23a	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01a23d	10 09		bpl $01a248			bpl	 		_ITSGoNextSubtractor
.01a23f					_ITSOutputDigit:
.01a23f	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.01a242	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01a245	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter 		; output it.
.01a248					_ITSGoNextSubtractor:
.01a248	e8		inx				inx 								; next dword
.01a249	e8		inx				inx
.01a24a	e8		inx				inx
.01a24b	e8		inx				inx
.01a24c	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01a24e	d0 a5		bne $01a1f5			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01a250	98		tya				tya 								; X is back as the mantissa index
.01a251	aa		tax				tax
.01a252	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01a254	09 30		ora #$30			ora 		#"0"
.01a256	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter
.01a259	7a		ply				ply 								; and exit
.01a25a	68		pla				pla
.01a25b	60		rts				rts
.01a25c					_ITSSubtractors:
>01a25c	00 ca 9a 3b					.dword 		1000000000
>01a260	00 e1 f5 05					.dword 		100000000
>01a264	80 96 98 00					.dword 		10000000
>01a268	40 42 0f 00					.dword 		1000000
>01a26c	a0 86 01 00					.dword 		100000
>01a270	10 27 00 00					.dword 		10000
>01a274	e8 03 00 00					.dword 		1000
>01a278	64 00 00 00					.dword 		100
>01a27c	0a 00 00 00					.dword 		10
.01a280					_ITSSubtractorsEnd:
.01a280					ITSOutputCharacter:
.01a280	48		pha				pha
.01a281	da		phx				phx
.01a282	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01a285	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01a288	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01a28a	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.01a28d	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.01a290	fa		plx				plx
.01a291	68		pla				pla
.01a292	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01a293					IntFromString:
.01a293	a0 00		ldy #$00			ldy 	#0
.01a295					IntFromStringY:
.01a295	a9 00		lda #$00			lda 	#0
.01a297	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.01a29a	48		pha				pha
.01a29b	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01a29d	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a29f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2a1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2a3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2a5	a9 01		lda #$01			lda 	#1
.01a2a7	95 85		sta $85,x			sta 	XS_Type,x
.01a2a9					_IFSLoop:
.01a2a9	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.01a2ab	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01a2ad	90 4e		bcc $01a2fd			bcc 	_IFSExit
.01a2af	c9 3a		cmp #$3a			cmp 	#"9"+1
.01a2b1	b0 4a		bcs $01a2fd			bcs 	_IFSExit
.01a2b3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01a2b5	c9 0c		cmp #$0c			cmp 	#12
.01a2b7	b0 4e		bcs $01a307			bcs 	_IFSOverflow
.01a2b9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a2bb	48		pha				pha
.01a2bc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a2be	48		pha				pha
.01a2bf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a2c1	48		pha				pha
.01a2c2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a2c4	48		pha				pha
.01a2c5	20 1c a3	jsr $01a31c			jsr 	IFSX1ShiftLeft 				; double
.01a2c8	20 1c a3	jsr $01a31c			jsr 	IFSX1ShiftLeft 				; x 4
.01a2cb	18		clc				clc 								; add saved value x 5
.01a2cc	68		pla				pla
.01a2cd	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2cf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2d1	68		pla				pla
.01a2d2	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a2d4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2d6	68		pla				pla
.01a2d7	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a2d9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2db	68		pla				pla
.01a2dc	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a2de	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2e0	20 1c a3	jsr $01a31c			jsr 	IFSX1ShiftLeft 				; x 10
.01a2e3	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a2e6	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.01a2e8	29 0f		and #$0f			and 	#15
.01a2ea	c8		iny				iny
.01a2eb	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2ed	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2ef	90 b8		bcc $01a2a9			bcc 	_IFSLoop
.01a2f1	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a2f3	d0 b4		bne $01a2a9			bne 	_IFSLoop
.01a2f5	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a2f7	d0 b0		bne $01a2a9			bne 	_IFSLoop
.01a2f9	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a2fb	80 ac		bra $01a2a9			bra 	_IFSLoop
.01a2fd					_IFSExit:
.01a2fd	98		tya				tya 								; get offset
.01a2fe					_IFSOkay:
.01a2fe	38		sec				sec
.01a2ff	ad 9c 03	lda $039c			lda 	ExpTemp
.01a302	f0 01		beq $01a305			beq 	_IFSSkipFail
.01a304	18		clc				clc
.01a305					_IFSSkipFail:
.01a305	68		pla				pla 								; and exit.
.01a306	60		rts				rts
.01a307					_IFSOverflow:
.01a307	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a30a	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a312	20 6f 76 65 72 66 6c 6f 77 00
.01a31c					IFSX1ShiftLeft:
.01a31c	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a31e	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a320	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a322	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a324	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a325					FPSubtract:
.01a325	48		pha				pha
.01a326	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a328	49 80		eor #$80			eor 	#$80
.01a32a	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a32c	68		pla				pla 								; --- and fall through ---
.01a32d					FPAdd:
.01a32d	48		pha				pha
.01a32e	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a330	d0 05		bne $01a337			bne 	_FPA_NegativeLHS
.01a332	20 4e a3	jsr $01a34e			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a335	68		pla				pla
.01a336	60		rts				rts
.01a337					_FPA_NegativeLHS:
.01a337	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a339	49 80		eor #$80			eor 	#$80
.01a33b	95 85		sta $85,x			sta 	XS_Type,x
.01a33d	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a33f	49 80		eor #$80			eor 	#$80
.01a341	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a343	20 4e a3	jsr $01a34e			jsr 	FPAdd_Worker 				; do the add calculation.
.01a346	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a348	49 80		eor #$80			eor 	#$80
.01a34a	95 85		sta $85,x			sta 	XS_Type,x
.01a34c	68		pla				pla
.01a34d	60		rts				rts
.01a34e					FPAdd_Worker:
.01a34e	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a350	70 07		bvs $01a359			bvs 	_FPAWExit 					; no change.
.01a352	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a354	50 07		bvc $01a35d			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a356	20 bb a5	jsr $01a5bb			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a359					_FPAWExit:
.01a359	20 2a a6	jsr $01a62a			jsr 	FPUNormalise 				; normalise the result.
.01a35c	60		rts				rts
.01a35d					_FPAWMakeSame:
.01a35d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a35f	38		sec				sec
.01a360	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a362	f0 16		beq $01a37a			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a364	da		phx				phx 								; save X
.01a365	90 06		bcc $01a36d			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a367	e8		inx				inx
.01a368	e8		inx				inx
.01a369	e8		inx				inx
.01a36a	e8		inx				inx
.01a36b	e8		inx				inx
.01a36c	e8		inx				inx
.01a36d					_FPAWShiftA:
.01a36d	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a36f	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a371	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a373	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a375	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a377	fa		plx				plx 								; restore original X
.01a378	80 e3		bra $01a35d			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a37a					_FPAW_DoArithmetic:
.01a37a	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a37c	30 20		bmi $01a39e			bmi 	_FPAW_BNegative
.01a37e	c2 30		rep #$30			rep 	#$30
.01a380	18		clc				clc
.01a381	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a383	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a385	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a387	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a389	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a38b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a38d	e2 30		sep #$30			sep 	#$30
.01a38f	90 c8		bcc $01a359			bcc 	_FPAWExit 					; no carry.
.01a391	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a393	38		sec				sec
.01a394	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a396	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a398	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a39a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a39c	80 bb		bra $01a359			bra 	_FPAWExit
.01a39e					_FPAW_BNegative:
.01a39e	c2 30		rep #$30			rep 	#$30
.01a3a0	38		sec				sec
.01a3a1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a3a3	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a3a5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3a7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a3a9	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a3ab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3ad	e2 30		sep #$30			sep 	#$30
.01a3af	b0 09		bcs $01a3ba			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a3b1	20 e1 a5	jsr $01a5e1			jsr 	FPUNegateInteger			; negate the mantissa
.01a3b4	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a3b6	49 80		eor #$80			eor 	#$80
.01a3b8	95 85		sta $85,x			sta 	XS_Type,x
.01a3ba					_FPAWGoExit:
.01a3ba	4c 59 a3	jmp $01a359			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a3bd					FPD_IsDivZero:
.01a3bd	20 86 85	jsr $018586			jsr ERR_Handler
>01a3c0	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a3c8	20 62 79 20 7a 65 72 6f 00
.01a3d1					FPDivide:
.01a3d1	48		pha				pha
.01a3d2	5a		phy				phy
.01a3d3	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a3d5	70 e6		bvs $01a3bd			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a3d7	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a3d9	f0 03		beq $01a3de			beq 	_FPDCalculateExp
.01a3db					_FPD_Exit:
.01a3db	7a		ply				ply
.01a3dc	68		pla				pla
.01a3dd	60		rts				rts
.01a3de					_FPDCalculateExp:
.01a3de	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a3e0	49 ff		eor #$ff			eor 	#$FF
.01a3e2	1a		inc a				inc 	a
.01a3e3	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a3e5	20 b5 a4	jsr $01a4b5			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a3e8	18		clc				clc 	 							; add 1 to the resulting exponent
.01a3e9	69 01		adc #$01			adc 	#1
.01a3eb	b0 54		bcs $01a441			bcs 	_FPD_Overflow 				; which can overflow.
.01a3ed	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3ef	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a3f1	85 1c		sta $1c				sta 	zLTemp1+0
.01a3f3	85 1d		sta $1d				sta 	zLTemp1+1
.01a3f5	85 1e		sta $1e				sta 	zLTemp1+2
.01a3f7	85 1f		sta $1f				sta 	zLTemp1+3
.01a3f9	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a3fb					_FPD_Loop:
.01a3fb	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a3fc	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a3fe	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a400	48		pha				pha
.01a401	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a403	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a405	48		pha				pha
.01a406	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a408	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a40a	48		pha				pha
.01a40b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a40d	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a40f	90 13		bcc $01a424			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a411	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a413	68		pla				pla
.01a414	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a416	68		pla				pla
.01a417	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a419	68		pla				pla
.01a41a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a41c	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.01a41e	09 80		ora #$80			ora 	#$80
.01a420	85 1f		sta $1f				sta 	zLTemp1+3
.01a422	80 03		bra $01a427			bra 	_FPD_Rotates
.01a424					_FPD_NoSubtract:
.01a424	68		pla				pla 								; throw away unwanted results
.01a425	68		pla				pla
.01a426	68		pla				pla
.01a427					_FPD_Rotates:
.01a427	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a429	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a42b	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a42d	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a42f	06 1c		asl $1c				asl 	0+zLTemp1
.01a431	26 1d		rol $1d				rol 	1+zLTemp1
.01a433	26 1e		rol $1e				rol 	2+zLTemp1
.01a435	26 1f		rol $1f				rol 	3+zLTemp1
.01a437	90 02		bcc $01a43b			bcc 	_FPD_NoCarry
.01a439	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.01a43b					_FPD_NoCarry:
.01a43b	88		dey				dey 								; do 32 times
.01a43c	d0 bd		bne $01a3fb			bne 	_FPD_Loop
.01a43e	4c 99 a4	jmp $01a499			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a441					_FPD_Overflow:
.01a441	4c 87 a6	jmp $01a687			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a444					FPMultiply:
.01a444	48		pha				pha
.01a445	5a		phy				phy
.01a446	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a448	70 07		bvs $01a451			bvs 	_FPM_Exit
.01a44a	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a44c	50 06		bvc $01a454			bvc 	_FPM_CalcExponent
.01a44e	20 bb a5	jsr $01a5bb			jsr 	FPUCopyX2ToX1
.01a451					_FPM_Exit:
.01a451	7a		ply				ply
.01a452	68		pla				pla
.01a453	60		rts				rts
.01a454					_FPM_CalcExponent:
.01a454	18		clc				clc
.01a455	20 b5 a4	jsr $01a4b5			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a458	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a45a	a9 00		lda #$00			lda 	#0
.01a45c	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a45e	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a460	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a462	85 1f		sta $1f				sta 	zLTemp1+3
.01a464	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a466					_FPM_Loop:
.01a466	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a468	29 01		and #$01			and 	#1
.01a46a	18		clc				clc 								; clear carry for the long rotate.
.01a46b	f0 19		beq $01a486			beq 	_FPM_NoAddition
.01a46d	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a46e	a5 1c		lda $1c				lda 	zLTemp1+0
.01a470	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a472	85 1c		sta $1c				sta 	zLTemp1+0
.01a474	a5 1d		lda $1d				lda 	zLTemp1+1
.01a476	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a478	85 1d		sta $1d				sta 	zLTemp1+1
.01a47a	a5 1e		lda $1e				lda 	zLTemp1+2
.01a47c	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a47e	85 1e		sta $1e				sta 	zLTemp1+2
.01a480	a5 1f		lda $1f				lda 	zLTemp1+3
.01a482	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a484	85 1f		sta $1f				sta 	zLTemp1+3
.01a486					_FPM_NoAddition:
.01a486	66 1f		ror $1f				ror 	3+zLTemp1
.01a488	66 1e		ror $1e				ror 	2+zLTemp1
.01a48a	66 1d		ror $1d				ror 	1+zLTemp1
.01a48c	66 1c		ror $1c				ror 	0+zLTemp1
.01a48e	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a490	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a492	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a494	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a496	88		dey				dey
.01a497	d0 cd		bne $01a466			bne 	_FPM_Loop 					; do this 32 times.
.01a499					FPM_CopySignNormalize:
.01a499	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a49b	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a49d	a5 1d		lda $1d				lda 	zLTemp1+1
.01a49f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a4a1	a5 1e		lda $1e				lda 	zLTemp1+2
.01a4a3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a4a5	a5 1f		lda $1f				lda 	zLTemp1+3
.01a4a7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a4a9	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a4ab	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a4ad	95 85		sta $85,x			sta 	XS_Type,x
.01a4af	20 2a a6	jsr $01a62a			jsr 	FPUNormalise 				; normalise and exit.
.01a4b2	7a		ply				ply
.01a4b3	68		pla				pla
.01a4b4	60		rts				rts
.01a4b5					FPCalculateExponent:
.01a4b5	18		clc				clc
.01a4b6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a4b8	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a4ba	b0 08		bcs $01a4c4			bcs 	_FPCECarry 					; carry out ?
.01a4bc	10 03		bpl $01a4c1			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a4be	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a4c0	60		rts				rts
.01a4c1					_FPCEExpZero:
.01a4c1	a9 00		lda #$00			lda 	#0
.01a4c3	60		rts				rts
.01a4c4					_FPCECarry:
.01a4c4	30 03		bmi $01a4c9			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a4c6	09 80		ora #$80			ora 	#$80 						; put in right range
.01a4c8	60		rts				rts
.01a4c9					_FPCEOverflow:
.01a4c9	4c 87 a6	jmp $01a687			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a4cc					FPFractionalPart:
.01a4cc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a4ce	38		sec				sec 								; this flag tells us to keep the fractional part
.01a4cf	30 0d		bmi $01a4de			bmi 	FPGetPart
.01a4d1	60		rts				rts
.01a4d2					FPIntegerPart:
.01a4d2	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a4d4	18		clc				clc 								; this flag says keep the integer part.
.01a4d5	30 07		bmi $01a4de			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a4d7	48		pha				pha
.01a4d8	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a4da	95 85		sta $85,x			sta 	XS_Type,x
.01a4dc	68		pla				pla
.01a4dd	60		rts				rts
.01a4de					FPGetPart:
.01a4de	48		pha				pha
.01a4df	5a		phy				phy 								; save Y
.01a4e0	08		php				php 								; save action
.01a4e1	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a4e3	70 59		bvs $01a53e			bvs 	_FPGP_Exit 					; then do nothing.
.01a4e5	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a4e7	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a4e9	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a4eb	85 1e		sta $1e				sta 	zLTemp1+2
.01a4ed	85 1f		sta $1f				sta 	zLTemp1+3
.01a4ef	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a4f1	38		sec				sec
.01a4f2	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a4f4	f0 12		beq $01a508			beq 	_FPGP_NoShift 				; ... if any
.01a4f6	c9 20		cmp #$20			cmp 	#32
.01a4f8	90 02		bcc $01a4fc			bcc 	_FPGP_NotMax
.01a4fa	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a4fc					_FPGP_NotMax:
.01a4fc	a8		tay				tay 								; Y is the mask shift count.
.01a4fd					_FPGP_ShiftMask:
.01a4fd	46 1f		lsr $1f				lsr 	3+zLTemp1
.01a4ff	66 1e		ror $1e				ror 	2+zLTemp1
.01a501	66 1d		ror $1d				ror 	1+zLTemp1
.01a503	66 1c		ror $1c				ror 	0+zLTemp1
.01a505	88		dey				dey
.01a506	d0 f5		bne $01a4fd			bne 	_FPGP_ShiftMask
.01a508					_FPGP_NoShift:
.01a508	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a50a	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a50d					_FPGP_MaskLoop:
.01a50d	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.01a510	28		plp				plp 								; if CC we keep the top part, so we
.01a511	08		php				php		 							; flip the mask.
.01a512	b0 02		bcs $01a516			bcs		_FPGP_NoFlip
.01a514	49 ff		eor #$ff			eor 	#$FF
.01a516					_FPGP_NoFlip:
.01a516	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a518	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a51a	e8		inx				inx
.01a51b	c8		iny				iny
.01a51c	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a51e	d0 ed		bne $01a50d			bne 	_FPGP_MaskLoop
.01a520	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a523	28		plp				plp
.01a524	08		php				php 								; get action flag on the stack
.01a525	90 04		bcc $01a52b			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a527	a9 00		lda #$00			lda 	#0
.01a529	95 85		sta $85,x			sta 	XS_Type,x
.01a52b					_FPGP_NotFractional:
.01a52b	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a52d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a52f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a531	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a533	f0 05		beq $01a53a			beq 	_FPGP_Zero 					; if zero, return zero
.01a535	20 2a a6	jsr $01a62a			jsr 	FPUNormalise
.01a538	80 04		bra $01a53e			bra 	_FPGP_Exit 					; and exit
.01a53a					_FPGP_Zero:
.01a53a	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a53c	95 85		sta $85,x			sta 	XS_Type,x
.01a53e					_FPGP_Exit:
.01a53e	68		pla				pla 								; throw saved action flag.
.01a53f	7a		ply				ply
.01a540	68		pla				pla
.01a541	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a542					FPCompare:
.01a542	20 83 a5	jsr $01a583			jsr 	FPFastCompare 				; fast compare try first
.01a545	b0 3b		bcs $01a582			bcs 	_FPCExit 					; that worked.
.01a547	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a549	48		pha				pha
.01a54a	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a54c	48		pha				pha
.01a54d	20 25 a3	jsr $01a325			jsr 	FPSubtract 					; calculate X1-X2
.01a550	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a552	70 2a		bvs $01a57e			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exponents
.01a554	68		pla				pla
.01a555	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a558	68		pla				pla
.01a559	38		sec				sec
.01a55a	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a55d	70 14		bvs $01a573			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a55f	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a560	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a562	b0 0f		bcs $01a573			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a564	38		sec				sec
.01a565	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a568	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a56a	b0 02		bcs $01a56e			bcs 	_FPCNotRange 				; keep in range.
.01a56c	a9 01		lda #$01			lda 	#1
.01a56e					_FPCNotRange:
.01a56e	38		sec				sec
.01a56f	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a571	b0 0d		bcs $01a580			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a573					_FPCNotEqual:
.01a573	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a575	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a577	f0 02		beq $01a57b			beq 	_FPCNE2
.01a579	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a57b	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a57c	80 04		bra $01a582			bra 	_FPCExit
.01a57e					_FPCPullZero:
.01a57e	68		pla				pla 								; throw saved exponents
.01a57f	68		pla				pla
.01a580					_FPCZero:
.01a580	a9 00		lda #$00			lda 	#0 							; and return zero
.01a582					_FPCExit:
.01a582	60		rts				rts
.01a583					FPFastCompare:
.01a583	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a585	70 23		bvs $01a5aa			bvs 	_FPFLeftZero 				; return invert sign of n2 (0-n2)
.01a587	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero ?
.01a589	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of n1 (n1-0)
.01a58b	70 25		bvs $01a5b2			bvs 	_FPFSignBit
.01a58d	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a58f	0a		asl a				asl 	a 							; put in CS if different.
.01a590	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a592	b0 1e		bcs $01a5b2			bcs 	_FPFSignBit
.01a594	38		sec				sec 								; same sign and not-zero. compare exponents
.01a595	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a597	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a599	f0 09		beq $01a5a4			beq 	_FPNoFastCompare
.01a59b	6a		ror a				ror 	a 							; put carry into bit 7.
.01a59c	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a59e	30 02		bmi $01a5a2			bmi		_FPFCNotMinus
.01a5a0	49 80		eor #$80			eor 	#$80
.01a5a2					_FPFCNotMinus:
.01a5a2	80 0e		bra $01a5b2			bra		_FPFSignBit
.01a5a4					_FPNoFastCompare:
.01a5a4	18		clc				clc
.01a5a5	60		rts				rts
.01a5a6					_FPFZero:
.01a5a6	a9 00		lda #$00			lda 	#0
.01a5a8					_FPFExitSet:
.01a5a8	38		sec				sec
.01a5a9	60		rts				rts
.01a5aa					_FPFLeftZero:
.01a5aa	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a5ac	70 f8		bvs $01a5a6			bvs 	_FPFZero
.01a5ae	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a5b0	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a5b2					_FPFSignBit:
.01a5b2	0a		asl a				asl 	a
.01a5b3	a9 01		lda #$01			lda 	#1
.01a5b5	90 f1		bcc $01a5a8			bcc		_FPFExitSet
.01a5b7	a9 ff		lda #$ff			lda 	#$FF
.01a5b9	38		sec				sec
.01a5ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a5bb					FPUCopyX2ToX1:
.01a5bb	48		pha				pha									; save AXY
.01a5bc	da		phx				phx
.01a5bd	5a		phy				phy
.01a5be	a0 08		ldy #$08			ldy 	#8 							; copy the whole mantissa
.01a5c0	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a5c2	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a5c4	e8		inx				inx
.01a5c5	88		dey				dey
.01a5c6	10 f8		bpl $01a5c0			bpl 	_FPUC21
.01a5c8	7a		ply				ply 								; restore and exit
.01a5c9	fa		plx				plx
.01a5ca	68		pla				pla
.01a5cb	60		rts				rts
.01a5cc					FPUSetInteger:
.01a5cc	48		pha				pha
.01a5cd	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a5cf	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a5d1	10 02		bpl $01a5d5			bpl 	_FPUSIExtend 				; so sign extend it into the mantissa
.01a5d3	a9 ff		lda #$ff			lda 	#$FF
.01a5d5					_FPUSIExtend:
.01a5d5	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a5d7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5d9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5db	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a5dd	95 85		sta $85,x			sta 	XS_Type,x
.01a5df	68		pla				pla
.01a5e0	60		rts				rts
.01a5e1					FPUNegateInteger:
.01a5e1	48		pha				pha
.01a5e2	38		sec				sec
.01a5e3	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a5e5	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a5e7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a5e9	a9 00		lda #$00			lda 	#0
.01a5eb	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a5ed	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a5ef	a9 00		lda #$00			lda 	#0
.01a5f1	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a5f3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5f5	a9 00		lda #$00			lda 	#0
.01a5f7	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a5f9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5fb	68		pla				pla
.01a5fc	60		rts				rts
.01a5fd					FPUToFloat:
.01a5fd	48		pha				pha
.01a5fe	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a600	29 0f		and #$0f			and 	#$0F 						; (e.g. type is zero)
.01a602	f0 24		beq $01a628			beq 	_FPUFExit
.01a604	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a606	95 85		sta $85,x			sta 	XS_Type,x
.01a608	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a60a	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a60c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a60e	10 07		bpl $01a617			bpl		_FPUFPositive
.01a610	20 e1 a5	jsr $01a5e1			jsr 	FPUNegateInteger 			; negate the mantissa
.01a613	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a615	95 85		sta $85,x			sta 	XS_Type,x
.01a617					_FPUFPositive:
.01a617	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a619	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a61b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a61d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a61f	d0 04		bne $01a625			bne 	_FPUFNonZero
.01a621	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a623	95 85		sta $85,x			sta 	XS_Type,x
.01a625					_FPUFNonZero:
.01a625	20 2a a6	jsr $01a62a			jsr 	FPUNormalise 				; normalise the floating point.
.01a628					_FPUFExit:
.01a628	68		pla				pla
.01a629	60		rts				rts
.01a62a					FPUNormalise:
.01a62a	48		pha				pha
.01a62b	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a62d	70 18		bvs $01a647			bvs 	_FPUNExit
.01a62f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a631	f0 10		beq $01a643			beq 	_FPUNSetZero 				; (e.g. the float value zero)
.01a633					_FPUNLoop:
.01a633	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a635	30 10		bmi $01a647			bmi 	_FPUNExit 					; if so, we are normalised.
.01a637	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a639	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a63b	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a63d	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a63f	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a641	d0 f0		bne $01a633			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a643					_FPUNSetZero:
.01a643	a9 40		lda #$40			lda 	#$40
.01a645	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a647					_FPUNExit:
.01a647	68		pla				pla
.01a648	60		rts				rts
.01a649					FPUToInteger:
.01a649	48		pha				pha
.01a64a	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a64c	29 01		and #$01			and 	#1
.01a64e	d0 31		bne $01a681			bne 	_FPUTOI_Exit
.01a650	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a652	70 23		bvs $01a677			bvs 	_FPUTOI_Zero
.01a654	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a656	10 1f		bpl $01a677			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a658	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a65a	b0 2b		bcs $01a687			bcs 	FP_Overflow 				; can't cope with that as an integer.
.01a65c					_FPUToIToInteger:
.01a65c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a65e	c9 a0		cmp #$a0			cmp 	#128+32
.01a660	f0 0c		beq $01a66e			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a662	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a664	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a666	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a668	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a66a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a66c	80 ee		bra $01a65c			bra 	_FPUToIToInteger 			; keep going.
.01a66e					_FPUToICheckSign:
.01a66e	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a670	10 0f		bpl $01a681			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a672	20 e1 a5	jsr $01a5e1			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a675	80 0a		bra $01a681			bra 	_FPUTOI_Exit
.01a677					_FPUTOI_Zero:
.01a677	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a679	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a67b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a67d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a67f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a681					_FPUToI_Exit:
.01a681	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a683	95 85		sta $85,x			sta 	XS_Type,x
.01a685	68		pla				pla
.01a686	60		rts				rts
.01a687					FP_Overflow:
.01a687	20 86 85	jsr $018586			jsr ERR_Handler
>01a68a	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a692	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a6a2					FPUTimes10:
.01a6a2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a6a4	85 1c		sta $1c				sta 	ZLTemp1+0
.01a6a6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6a8	85 1d		sta $1d				sta 	ZLTemp1+1
.01a6aa	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6ac	85 1e		sta $1e				sta 	ZLTemp1+2
.01a6ae	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6b0	85 1f		sta $1f				sta 	ZLTemp1+3
.01a6b2	20 e7 a6	jsr $01a6e7			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a6b5	20 e7 a6	jsr $01a6e7			jsr 	_FPUT_LSR_ZLTemp1
.01a6b8	18		clc				clc
.01a6b9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a6bb	65 1c		adc $1c				adc 	ZLTemp1+0
.01a6bd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a6bf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6c1	65 1d		adc $1d				adc 	ZLTemp1+1
.01a6c3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a6c5	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6c7	65 1e		adc $1e				adc 	ZLTemp1+2
.01a6c9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a6cb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6cd	65 1f		adc $1f				adc 	ZLTemp1+3
.01a6cf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a6d1	90 0a		bcc $01a6dd			bcc 	_FPUTimes10
.01a6d3	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a6d5	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a6d7	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a6d9	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a6db	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a6dd					_FPUTimes10:
.01a6dd	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a6df	18		clc				clc
.01a6e0	69 03		adc #$03			adc 	#3
.01a6e2	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6e4	b0 a1		bcs $01a687			bcs 	FP_Overflow 				; error
.01a6e6	60		rts				rts
.01a6e7					_FPUT_LSR_ZLTemp1:
.01a6e7	46 1f		lsr $1f				lsr 	ZLTemp1+3
.01a6e9	66 1e		ror $1e				ror 	ZLTemp1+2
.01a6eb	66 1d		ror $1d				ror 	ZLTemp1+1
.01a6ed	66 1c		ror $1c				ror 	ZLTemp1+0
.01a6ef	60		rts				rts
.01a6f0					FPUScale10A:
.01a6f0	5a		phy				phy
.01a6f1	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a6f3	f0 37		beq $01a72c			beq 	_FPUScaleExit
.01a6f5	da		phx				phx 								; save X
.01a6f6	e8		inx				inx
.01a6f7	e8		inx				inx
.01a6f8	e8		inx				inx
.01a6f9	e8		inx				inx
.01a6fa	e8		inx				inx
.01a6fb	e8		inx				inx
.01a6fc	a8		tay				tay 								; save power scalar in Y.
.01a6fd	a9 00		lda #$00			lda 	#0
.01a6ff	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0 in float.
.01a701	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a703	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a705	95 85		sta $85,x			sta 	XS_Type,x
.01a707	a9 80		lda #$80			lda 	#$80
.01a709	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a70b	a9 81		lda #$81			lda 	#$81
.01a70d	95 84		sta $84,x			sta 	XS_Exponent,x
.01a70f	5a		phy				phy 								; save 10^n (e.g. the scalar) on stack.
.01a710	c0 00		cpy #$00			cpy 	#0
.01a712	10 05		bpl $01a719			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a714	98		tya				tya
.01a715	49 ff		eor #$ff			eor 	#$FF
.01a717	1a		inc a				inc 	a
.01a718	a8		tay				tay
.01a719					_FPUSAbs:
.01a719	20 a2 a6	jsr $01a6a2			jsr 	FPUTimes10
.01a71c	88		dey				dey
.01a71d	d0 fa		bne $01a719			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a71f	68		pla				pla 								; restore count in A
.01a720	fa		plx				plx 								; restore X pointing to number to scale.
.01a721	0a		asl a				asl 	a
.01a722	b0 05		bcs $01a729			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a724	20 44 a4	jsr $01a444			jsr 	FPMultiply 					; if clear multiply.
.01a727	80 03		bra $01a72c			bra		_FPUScaleExit
.01a729					_FPUSDivide:
.01a729	20 d1 a3	jsr $01a3d1			jsr 	FPDivide
.01a72c					_FPUScaleExit:
.01a72c	7a		ply				ply
.01a72d	60		rts				rts
.01a72e					FPUCopyToNext:
.01a72e	a0 06		ldy #$06			ldy 		#6
.01a730	da		phx				phx
.01a731					_FPUCopy1:
.01a731	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a733	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a735	e8		inx				inx
.01a736	88		dey				dey
.01a737	d0 f8		bne $01a731			bne 	_FPUCopy1
.01a739	fa		plx				plx
.01a73a	60		rts				rts
.01a73b					FPUCopyFromNext:
.01a73b	a0 06		ldy #$06			ldy 		#6
.01a73d	da		phx				phx
.01a73e					_FPUCopy1:
.01a73e	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a740	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a742	e8		inx				inx
.01a743	88		dey				dey
.01a744	d0 f8		bne $01a73e			bne 	_FPUCopy1
.01a746	fa		plx				plx
.01a747	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a748					FPToString:
.01a748	48		pha				pha
.01a749	5a		phy				phy
.01a74a	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a74c	50 0a		bvc $01a758			bvc 		_FPTSIsFloat 			; if zero,
.01a74e					_FPTSZero:
.01a74e	a9 30		lda #$30			lda 		#"0"
.01a750	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter
.01a753					_FPTSExit:
.01a753	7a		ply				ply
.01a754	68		pla				pla
.01a755	60		rts				rts
.01a756	80 fb		bra $01a753			bra 		_FPTSExit
.01a758					_FPTSIsFloat:
.01a758	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a75a	10 09		bpl $01a765			bpl 		_FPTSNotSigned
.01a75c	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a75e	95 85		sta $85,x			sta 		XS_Type,x
.01a760	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a762	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter
.01a765					_FPTSNotSigned:
.01a765	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a767	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a769	b0 09		bcs $01a774			bcs 		_FPTSExponent
.01a76b	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a76d	90 05		bcc $01a774			bcc 		_FPTSExponent 			;
.01a76f					_FPTSStandard:
.01a76f	20 b3 a7	jsr $01a7b3			jsr 		FPTOutputBody 			; output the body.
.01a772	80 df		bra $01a753			bra 		_FPTSExit
.01a774					_FPTSExponent:
.01a774	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a776	8d 9d 03	sta $039d			sta 		ExpCount
.01a779					_FPTSExponentLoop:
.01a779	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a77b	10 0e		bpl $01a78b			bpl 		_FPTSTimes
.01a77d	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a77f	90 14		bcc $01a795			bcc 		_FPTSScaledToExp
.01a781	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a783	20 f0 a6	jsr $01a6f0			jsr 		FPUScale10A
.01a786	ee 9d 03	inc $039d			inc 		ExpCount
.01a789	80 ee		bra $01a779			bra 		_FPTSExponentLoop
.01a78b					_FPTSTimes:
.01a78b	a9 01		lda #$01			lda 		#1
.01a78d	20 f0 a6	jsr $01a6f0			jsr 		FPUScale10A
.01a790	ce 9d 03	dec $039d			dec 		ExpCount
.01a793	80 e4		bra $01a779			bra 		_FPTSExponentLoop
.01a795					_FPTSScaledToExp:
.01a795	20 b3 a7	jsr $01a7b3			jsr 		FPTOutputBody 			; output the body.
.01a798	a9 65		lda #$65			lda 		#"e"					; output E
.01a79a	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter
.01a79d	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a7a0	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a7a2	29 80		and #$80			and 		#$80 					; sign extend it
.01a7a4	f0 02		beq $01a7a8			beq 		_FPTSSExt
.01a7a6	a9 ff		lda #$ff			lda 		#$FF
.01a7a8					_FPTSSExt:
.01a7a8	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a7aa	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a7ac	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a7ae	20 de a1	jsr $01a1de			jsr 		INTToString 			; output the exponent.
.01a7b1	80 a0		bra $01a753			bra			_FPTSExit 				; and exit.
.01a7b3					FPTOutputBody:
.01a7b3	20 2e a7	jsr $01a72e			jsr 		FPUCopyToNext 			; copy to next slot.
.01a7b6	20 49 a6	jsr $01a649			jsr 		FPUToInteger 			; convert to an integer
.01a7b9	20 de a1	jsr $01a1de			jsr 		INTToString 			; output the main integer part.
.01a7bc	20 3b a7	jsr $01a73b			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a7bf	20 cc a4	jsr $01a4cc			jsr 		FPFractionalPart 		; get the decimal part.
.01a7c2	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a7c4	70 3c		bvs $01a802			bvs 		_FPTOExit 				; if not, exit now.
.01a7c6	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a7c8	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter
.01a7cb					_FPOutLoop:
.01a7cb	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a7cd	70 1d		bvs $01a7ec			bvs 		_FPStripZeros 			; strip trailing zeros
.01a7cf	20 a2 a6	jsr $01a6a2			jsr 		FPUTimes10 				; multiply by 10
.01a7d2	20 2e a7	jsr $01a72e			jsr 		FPUCopyToNext			; copy to next slot.
.01a7d5	20 49 a6	jsr $01a649			jsr 		FPUToInteger 			; convert to integer
.01a7d8	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a7da	09 30		ora #$30			ora 		#"0"
.01a7dc	20 80 a2	jsr $01a280			jsr 		ITSOutputCharacter
.01a7df	20 3b a7	jsr $01a73b			jsr 		FPUCopyFromNext 		; get it back
.01a7e2	20 cc a4	jsr $01a4cc			jsr 		FPFractionalPart 		; get fractional part
.01a7e5	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a7e8	c9 0b		cmp #$0b			cmp 	 	#11
.01a7ea	90 df		bcc $01a7cb			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a7ec					_FPStripZeros:
.01a7ec	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a7ef					_FPStripLoop:
.01a7ef	88		dey				dey 								; back one, if at start then no strip
.01a7f0	f0 10		beq $01a802			beq 		_FPToExit
.01a7f2	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a7f5	c9 30		cmp #$30			cmp 		#"0"
.01a7f7	f0 f6		beq $01a7ef			beq 		_FPStripLoop
.01a7f9	c8		iny				iny
.01a7fa	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a7fc	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a7ff	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a802					_FPTOExit:
.01a802	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a803					FPFromString:
.01a803	48		pha				pha 								; push A
.01a804	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a806	c9 2e		cmp #$2e			cmp 	#"."
.01a808	f0 03		beq $01a80d			beq	 	_FPFIsDecimal
.01a80a	4c 69 a8	jmp $01a869			jmp 	_FPFNotDecimal
.01a80d					_FPFIsDecimal:
.01a80d	c8		iny				iny 								; consume the decimal.
.01a80e	20 fd a5	jsr $01a5fd			jsr 	FPUToFloat 					; convert the integer to float.
.01a811	da		phx				phx 								; save X.
.01a812	5a		phy				phy 								; save decimal start position
.01a813	e8		inx				inx
.01a814	e8		inx				inx
.01a815	e8		inx				inx
.01a816	e8		inx				inx
.01a817	e8		inx				inx
.01a818	e8		inx				inx
.01a819	20 95 a2	jsr $01a295			jsr 	INTFromStringY 				; get the part after the DP.
.01a81c	20 fd a5	jsr $01a5fd			jsr 	FPUToFloat 					; convert that to a float.
.01a81f	68		pla				pla 								; calculate - chars consumed.
.01a820	8c 9c 03	sty $039c			sty 	ExpTemp
.01a823	38		sec				sec
.01a824	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a827	20 f0 a6	jsr $01a6f0			jsr 	FPUScale10A 				; scale it by 10^AC
.01a82a	fa		plx				plx 								; restore original X
.01a82b	20 2d a3	jsr $01a32d			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a82e	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.01a830	c9 45		cmp #$45			cmp 	#"E"
.01a832	f0 04		beq $01a838			beq 	_FPFExponent
.01a834	c9 65		cmp #$65			cmp 	#"e"
.01a836	d0 31		bne $01a869			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a838					_FPFExponent:
.01a838	c8		iny				iny 								; skip over E symbol.
.01a839	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.01a83b	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a83d	d0 01		bne $01a840			bne 	_FPFGotSign
.01a83f	c8		iny				iny 								; if it was - skip over it.
.01a840					_FPFGotSign:
.01a840	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a841	da		phx				phx
.01a842	e8		inx				inx
.01a843	e8		inx				inx
.01a844	e8		inx				inx
.01a845	e8		inx				inx
.01a846	e8		inx				inx
.01a847	e8		inx				inx
.01a848	20 95 a2	jsr $01a295			jsr 	INTFromStringY 				; get the exponent
.01a84b	fa		plx				plx 								; restore X.
.01a84c	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a84e	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a850	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a852	d0 17		bne $01a86b			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a854	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a856	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a858	b0 11		bcs $01a86b			bcs 	_FPFXOverflow
.01a85a	68		pla				pla 								; get direction
.01a85b	d0 07		bne $01a864			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a85d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a85f	49 ff		eor #$ff			eor 	#$FF
.01a861	1a		inc a				inc 	a
.01a862	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a864					_FPFXScale:
.01a864	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a866	20 f0 a6	jsr $01a6f0			jsr 	FPUScale10A 				; scale by the exponent.
.01a869					_FPFNotDecimal:
.01a869	68		pla				pla
.01a86a	60		rts				rts
.01a86b					_FPFXOverflow:
.01a86b	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a86e	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a876	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a87d					Unary_Rnd:
.01a87d	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX 			; get value
.01a880	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; check right bracket.
.01a883	20 53 96	jsr $019653			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a886	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a888	30 10		bmi $01a89a			bmi 	_URSetSeed
.01a88a	f0 28		beq $01a8b4			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a88c	da		phx				phx
.01a88d	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a88f	20 eb a8	jsr $01a8eb			jsr 	Random16
.01a892	a2 02		ldx #$02			ldx 	#2
.01a894	20 eb a8	jsr $01a8eb			jsr 	Random16
.01a897	fa		plx				plx
.01a898	80 1a		bra $01a8b4			bra 	_URMakeRandom
.01a89a					_URSetSeed:
.01a89a	20 fd a5	jsr $01a5fd			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a89d	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a89f	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a8a2	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a8a4	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a8a7	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a8a9	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a8ac	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a8ae	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a8af	49 db		eor #$db			eor 	#$DB
.01a8b1	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8b4					_URMakeRandom:
.01a8b4	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a8b7	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a8ba	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a8bd	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a8c0	d0 0a		bne $01a8cc			bne 	_URNotZero
.01a8c2	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a8c4	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a8c7	a9 3d		lda #$3d			lda 	#$3D
.01a8c9	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8cc					_URNotZero:
.01a8cc	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a8cf	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a8d1	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a8d4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a8d6	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a8d9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a8db	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a8de	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a8e0	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a8e2	95 85		sta $85,x			sta 	XS_Type,x
.01a8e4	a9 80		lda #$80			lda 	#$80
.01a8e6	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a8e8	4c 2a a6	jmp $01a62a			jmp 	FPUNormalise 				; and normalise.
.01a8eb					Random16:
.01a8eb	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a8ee	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a8f1	90 08		bcc $01a8fb			bcc 	_R16_NoXor
.01a8f3	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a8f6	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a8f8	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a8fb					_R16_NoXor:
.01a8fb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a8fc					Unary_Int:
.01a8fc	20 dd 93	jsr $0193dd			jsr 	EvaluateNumberX 			; get value
.01a8ff	20 35 9a	jsr $019a35			jsr 	CheckNextRParen 			; check right bracket.
.01a902	4c 49 a6	jmp $01a649			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a905	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
