
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 13:50:06 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					endOfProgram: .word ? 						; End of Program Memory.
>0406					NumBufX 	.byte 	?						; buffer index position
>0407					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0427					HashTableBase:
>0427								.fill	HashTableCount * HashTableSize * 2
.0487					HashTableEnd:
=$407					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0487					Var_Type    .byte ? 						; type of variable (as a type token)
>0488					Var_Hash 	.byte ? 						; hash of identifier name.
>0489					Var_Length 	.byte ? 						; length of variable name
>048a					Var_HashAddress .byte ?						; low byte of hash table entry.
>048b					Var_DataSize .byte ?						; size of one element.
>048c					NumSuppress	.byte 	?						; leading zero suppression flag
>048d					NumConvCount .byte 	? 						; count for conversions.
>048e					ExpTemp:	.byte ?							; Working temp for exponents.
>048f					ExpCount:	.byte ? 						; Count of decimal exponents.
>0490					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0491					TempStringWriteIndex: .byte ? 				; Write offset.
>0492					ValSign: 	.byte ? 						; sign flag for val()
>0493					SliceStart:	.byte ? 						; string slice parts
>0494					SliceCount:	.byte ?
>0495					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0499					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>04a1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>04a9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>04aa					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04ac					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04ae					Tim_SR:		.byte ? 						; Processor Status
>04af					Tim_A:		.byte ? 						; Processor Registers
>04b0					Tim_X:		.byte ?
>04b1					Tim_Y:		.byte ?
>04b2					Tim_Z:		.byte ?
>04b3					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=0					VariableMemory = 0							; i.e. put it after BASIC code.
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	07 05 00 01 84 40 00 09			.byte	$07,$05,$00,$01,$84,$40,$00,$09
>1008	0a 00 01 84 01 8a 41 00			.byte	$0a,$00,$01,$84,$01,$8a,$41,$00
>1010	06 14 00 d6 01 00 06 1e			.byte	$06,$14,$00,$d6,$01,$00,$06,$1e
>1018	00 cc 4a 00 05 1f 00 c4			.byte	$00,$cc,$4a,$00,$05,$1f,$00,$c4
>1020	00 00					.byte	$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c b4 86 01	jmp $0186b4		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae b3 04	ldx $04b3			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad ae 04	lda $04ae			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad af 04	lda $04af			lda 	TIM_A 						; restore AXYZ
.018281	ae b0 04	ldx $04b0			ldx 	TIM_X
.018284	ac b1 04	ldy $04b1			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d ad 04	sta $04ad			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d ac 04	sta $04ac			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd aa 04	lda $04aa,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d af 04	sta $04af			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e b0 04	stx $04b0			stx 	TIM_X
.01838b	8c b1 04	sty $04b1			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d ae 04	sta $04ae			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d ab 04	sta $04ab			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d aa 04	sta $04aa			sta 	TIM_PC 						; high byte
.01839a	ad ab 04	lda $04ab			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce aa 04	dec $04aa			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce ab 04	dec $04ab			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e b3 04	stx $04b3			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d ab 04	sta $04ab			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d aa 04	sta $04aa			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d ae 04	sta $04ae,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	8d 08 03	sta $0308			sta 	XS_Mantissa
.018437	c8		iny				iny
.018438	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01843a	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01843d	fa		plx				plx 								; address in XY
.01843e	7a		ply				ply
.01843f	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018440	d0 01		bne $018443			bne 	_EHNoSkip
.018442	c8		iny				iny
.018443					_EHNoSkip:
.018443	20 64 84	jsr $018464			jsr 	PrintROMMessage 			; print message from ROM.
.018446	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018449	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01844c	f0 0c		beq $01845a			beq 	_EHNoLine
.01844e	a2 5f		ldx #$5f			ldx 	#_EHAt & $FF 				; print " at "
.018450	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018452	20 64 84	jsr $018464			jsr 	PrintROMMessage
.018455	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018457	20 79 84	jsr $018479			jsr 	Print16BitInteger
.01845a					_EHNoLine:
.01845a	80 fe		bra $01845a			bra 	_EHNoLine
.01845c	4c d7 86	jmp $0186d7			jmp 	WarmStart
>01845f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018464					PrintROMMessage:
.018464	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018466	84 1b		sty $1b				sty 	zLTemp1+1
.018468	4b		phk				phk
.018469	68		pla				pla
.01846a	85 1c		sta $1c				sta 	ZLTemp1+2
.01846c	a0 00		ldy #$00			ldy 	#0
.01846e					_PRMLoop:
.01846e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018470	f0 06		beq $018478			beq		_PRMExit
.018472	c8		iny				iny
.018473	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018476	80 f6		bra $01846e			bra 	_PRMLoop
.018478					_PRMExit:
.018478	60		rts				rts
.018479					Print16BitInteger:
.018479	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01847b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.01847e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018481	8d 06 04	sta $0406			sta 	NumBufX 					; reset the conversion pointer
.018484	aa		tax				tax 								; convert bottom level.
.018485	20 7b 97	jsr $01977b			jsr 	INTToString 				; make string
.018488	a2 00		ldx #$00			ldx 	#0 							; print buffer
.01848a	bd 07 04	lda $0407,x	_P1Loop:lda 	Num_Buffer,x
.01848d	f0 06		beq $018495			beq 	_P1Exit
.01848f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018492	e8		inx				inx
.018493	80 f5		bra $01848a			bra 	_P1Loop
.018495	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.018496					VectorTable:
>018496	0d 8b					.word BinaryOp_And         & $FFFF ; $80 and
>018498	35 8b					.word BinaryOp_Or          & $FFFF ; $81 or
>01849a	5d 8b					.word BinaryOp_Xor         & $FFFF ; $82 xor
>01849c	5d 8b					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01849e	a1 8b					.word Binary_Equal         & $FFFF ; $84 =
>0184a0	c0 8b					.word Binary_NotEqual      & $FFFF ; $85 <>
>0184a2	c9 8b					.word Binary_Less          & $FFFF ; $86 <
>0184a4	d2 8b					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a6	e4 8b					.word Binary_Greater       & $FFFF ; $88 >
>0184a8	db 8b					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184aa	79 8c					.word BinaryOp_Add         & $FFFF ; $8a +
>0184ac	99 8c					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184ae	ac 8c					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184b0	bf 8c					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184b2	52 85					.word NotImplemented       & $FFFF ; $8e ^
>0184b4	52 85					.word NotImplemented       & $FFFF ; $8f if
>0184b6	52 85					.word NotImplemented       & $FFFF ; $90 while
>0184b8	52 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184ba	52 85					.word NotImplemented       & $FFFF ; $92 for
>0184bc	52 85					.word NotImplemented       & $FFFF ; $93 then
>0184be	52 85					.word NotImplemented       & $FFFF ; $94 endif
>0184c0	52 85					.word NotImplemented       & $FFFF ; $95 wend
>0184c2	52 85					.word NotImplemented       & $FFFF ; $96 until
>0184c4	52 85					.word NotImplemented       & $FFFF ; $97 next
>0184c6	52 85					.word NotImplemented       & $FFFF ; $98 not
>0184c8	52 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184ca	f3 8d					.word Unary_Abs            & $FFFF ; $9a abs(
>0184cc	4b 8f					.word Unary_Asc            & $FFFF ; $9b asc(
>0184ce	60 9f					.word Unary_Int            & $FFFF ; $9c int(
>0184d0	11 8e					.word Unary_Peek           & $FFFF ; $9d peek(
>0184d2	d7 9e					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184d4	85 8e					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d6	8c 8f					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d8	a3 8f					.word Unary_Right          & $FFFF ; $a1 right$(
>0184da	71 8f					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184dc	05 91					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184de	18 8f					.word Unary_Str            & $FFFF ; $a4 str$(
>0184e0	a7 8e					.word Unary_Val            & $FFFF ; $a5 val(
>0184e2	62 8f					.word Unary_Len            & $FFFF ; $a6 len(
>0184e4	21 90					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e6	52 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e8	52 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184ea	52 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184ec	52 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184ee	52 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184f0	52 85					.word NotImplemented       & $FFFF ; $ad log(
>0184f2	52 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184f4	7b 90					.word Unary_Dec            & $FFFF ; $af dec(
>0184f6	15 8e					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f8	19 8e					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184fa	4d 8e					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184fc	a1 8d					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184fe	e3 90					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018500	52 85					.word NotImplemented       & $FFFF ; $b5 pos(
>018502	52 85					.word NotImplemented       & $FFFF ; $b6 tab(
>018504	52 85					.word NotImplemented       & $FFFF ; $b7 $
>018506	52 85					.word NotImplemented       & $FFFF ; $b8 $(
>018508	52 85					.word NotImplemented       & $FFFF ; $b9 #
>01850a	52 85					.word NotImplemented       & $FFFF ; $ba #(
>01850c	52 85					.word NotImplemented       & $FFFF ; $bb %
>01850e	52 85					.word NotImplemented       & $FFFF ; $bc %(
>018510	52 85					.word NotImplemented       & $FFFF ; $bd (
>018512	52 85					.word NotImplemented       & $FFFF ; $be )
>018514	52 85					.word NotImplemented       & $FFFF ; $bf ,
>018516	ec 87					.word Command_COLON        & $FFFF ; $c0 :
>018518	52 85					.word NotImplemented       & $FFFF ; $c1 ;
>01851a	52 85					.word NotImplemented       & $FFFF ; $c2 def
>01851c	1a 89					.word Command_CLR          & $FFFF ; $c3 clr
>01851e	2b 89					.word Command_STOP         & $FFFF ; $c4 stop
>018520	52 85					.word NotImplemented       & $FFFF ; $c5 data
>018522	52 85					.word NotImplemented       & $FFFF ; $c6 read
>018524	e5 86					.word Command_DIM          & $FFFF ; $c7 dim
>018526	52 85					.word NotImplemented       & $FFFF ; $c8 to
>018528	52 85					.word NotImplemented       & $FFFF ; $c9 step
>01852a	52 85					.word NotImplemented       & $FFFF ; $ca gosub
>01852c	52 85					.word NotImplemented       & $FFFF ; $cb return
>01852e	a1 88					.word Command_GOTO         & $FFFF ; $cc goto
>018530	0e 88					.word Command_END          & $FFFF ; $cd end
>018532	52 85					.word NotImplemented       & $FFFF ; $ce input
>018534	ed 87					.word Command_LET          & $FFFF ; $cf let
>018536	52 85					.word NotImplemented       & $FFFF ; $d0 list
>018538	52 85					.word NotImplemented       & $FFFF ; $d1 new
>01853a	52 85					.word NotImplemented       & $FFFF ; $d2 old
>01853c	52 85					.word NotImplemented       & $FFFF ; $d3 on
>01853e	52 85					.word NotImplemented       & $FFFF ; $d4 restore
>018540	52 85					.word NotImplemented       & $FFFF ; $d5 poke
>018542	12 88					.word Command_PRINT        & $FFFF ; $d6 print
>018544	72 87					.word Command_RUN          & $FFFF ; $d7 run
>018546	52 85					.word NotImplemented       & $FFFF ; $d8 wait
>018548	52 85					.word NotImplemented       & $FFFF ; $d9 sys
>01854a	52 85					.word NotImplemented       & $FFFF ; $da doke
>01854c	52 85					.word NotImplemented       & $FFFF ; $db loke
>01854e	85 88					.word Command_ASSERT       & $FFFF ; $dc assert
>018550	52 85					.word NotImplemented       & $FFFF ; $dd get
.018552					NotImplemented:
.018552	20 2f 84	jsr $01842f			jsr ERR_Handler
>018555	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01855d	65 6d 65 6e 74 65 64 00
.018565					BinaryPrecedence:
>018565	01					.byte 1    ; $80 and
>018566	01					.byte 1    ; $81 or
>018567	01					.byte 1    ; $82 xor
>018568	01					.byte 1    ; $83 eor
>018569	02					.byte 2    ; $84 =
>01856a	02					.byte 2    ; $85 <>
>01856b	02					.byte 2    ; $86 <
>01856c	02					.byte 2    ; $87 <=
>01856d	02					.byte 2    ; $88 >
>01856e	02					.byte 2    ; $89 >=
>01856f	03					.byte 3    ; $8a +
>018570	03					.byte 3    ; $8b -
>018571	04					.byte 4    ; $8c *
>018572	04					.byte 4    ; $8d /
>018573	05					.byte 5    ; $8e ^
.018574					KeywordText:
>018574	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018577	4f d2					.byte $4f,$d2                          ; $81 or
>018579	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01857c	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01857f	bd					.byte $bd                              ; $84 =
>018580	3c be					.byte $3c,$be                          ; $85 <>
>018582	bc					.byte $bc                              ; $86 <
>018583	3c bd					.byte $3c,$bd                          ; $87 <=
>018585	be					.byte $be                              ; $88 >
>018586	3e bd					.byte $3e,$bd                          ; $89 >=
>018588	ab					.byte $ab                              ; $8a +
>018589	ad					.byte $ad                              ; $8b -
>01858a	aa					.byte $aa                              ; $8c *
>01858b	af					.byte $af                              ; $8d /
>01858c	de					.byte $de                              ; $8e ^
>01858d	49 c6					.byte $49,$c6                          ; $8f if
>01858f	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>018594	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>01859a	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>01859d	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0185a1	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0185a6	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185aa	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185af	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185b3	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185b6	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b9	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185bd	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185c1	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185c5	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185ca	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185ce	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185d2	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d8	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185df	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185e4	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e8	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185ed	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185f1	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185f5	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185fa	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185fe	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018602	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018606	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01860a	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01860e	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018612	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018616	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01861a	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01861f	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018624	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018628	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01862c	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018631	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018635	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018639	a4					.byte $a4                              ; $b7 $
>01863a	24 a8					.byte $24,$a8                          ; $b8 $(
>01863c	a3					.byte $a3                              ; $b9 #
>01863d	23 a8					.byte $23,$a8                          ; $ba #(
>01863f	a5					.byte $a5                              ; $bb %
>018640	25 a8					.byte $25,$a8                          ; $bc %(
>018642	a8					.byte $a8                              ; $bd (
>018643	a9					.byte $a9                              ; $be )
>018644	ac					.byte $ac                              ; $bf ,
>018645	ba					.byte $ba                              ; $c0 :
>018646	bb					.byte $bb                              ; $c1 ;
>018647	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>01864a	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01864d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>018651	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018655	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018659	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01865c	54 cf					.byte $54,$cf                          ; $c8 to
>01865e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018662	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>018667	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>01866d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018671	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>018674	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018679	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>01867c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>018680	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>018683	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>018686	4f ce					.byte $4f,$ce                          ; $d3 on
>018688	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>01868f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>018693	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>018698	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>01869b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>01869f	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0186a2	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0186a6	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0186aa	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0186b0	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0186b3	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.0186b4					BASIC_Start:
.0186b4	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186b7	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186ba	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186bc	8d 04 03	sta $0304			sta 	LocalVector
.0186bf	8d 00 03	sta $0300			sta 	UserVector
.0186c2	a9 95		lda #$95			lda 	#USRDefault & $FF 			; reset USR vector
.0186c4	8d 01 03	sta $0301			sta 	UserVector+1
.0186c7	a9 8e		lda #$8e			lda 	#(USRDefault >> 8) & $FF
.0186c9	8d 02 03	sta $0302			sta 	UserVector+2
.0186cc	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186ce	8d 03 03	sta $0303			sta 	UserVector+3
.0186d1	20 56 91	jsr $019156			jsr 	UpdateProgramEnd 			; update the program end.
.0186d4	20 1a 89	jsr $01891a			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186d7					WarmStart:
.0186d7	c2 30		rep #$30			rep 	#$30
.0186d9	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186dc	1b		tcs				tcs
.0186dd	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186e0	e2 30		sep #$30			sep 	#$30
.0186e2	4c 72 87	jmp $018772			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.0186e5					Command_DIM:
.0186e5	98		tya				tya
.0186e6	48		pha				pha 								; push on stack.
.0186e7	20 b4 92	jsr $0192b4			jsr 	VariableExtract 			; get the identifier
.0186ea	ad 87 04	lda $0487			lda 	Var_Type 					; check it is an array
.0186ed	29 01		and #$01			and 	#1
.0186ef	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0186f1	d0 71		bne $018764			bne 	_CDIError
.0186f3	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.0186f5	8d a9 04	sta $04a9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0186f8					_CDIGetDimension:
.0186f8	ad a9 04	lda $04a9			lda 	UsrArrayIdx 				; done too many ?
.0186fb	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0186fd	f0 65		beq $018764			beq 	_CDIError
.0186ff	20 eb 8a	jsr $018aeb			jsr 	EvaluateInteger 			; evaluate an index size
.018702	ad 09 03	lda $0309			lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018705	29 80		and #$80			and 	#$80
.018707	0d 0a 03	ora $030a			ora 	XS_Mantissa+2
.01870a	0d 0b 03	ora $030b			ora 	XS_Mantissa+3
.01870d	d0 55		bne $018764			bne 	_CDIError
.01870f	ae a9 04	ldx $04a9			ldx 	UsrArrayIdx 				; copy into the array table.
.018712	18		clc				clc 								; add 1 - max index => size.
.018713	ad 08 03	lda $0308			lda 	XS_Mantissa+0
.018716	69 01		adc #$01			adc 	#1
.018718	9d a1 04	sta $04a1,x			sta 	UsrArrayDef+0,x
.01871b	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.01871e	69 00		adc #$00			adc 	#0
.018720	9d a2 04	sta $04a2,x			sta 	UsrArrayDef+1,x
.018723	30 3f		bmi $018764			bmi 	_CDIError 					; could be dim a(32767)
.018725	e8		inx				inx 								; bump index.
.018726	e8		inx				inx
.018727	8e a9 04	stx $04a9			stx 	UsrArrayIdx
.01872a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01872c	c8		iny				iny
.01872d	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.01872f	f0 c7		beq $0186f8			beq 	_CDIGetDimension
.018731	88		dey				dey
.018732	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; closing ) present ?
.018735	ae a9 04	ldx $04a9			ldx 	UsrArrayIdx 				; copy USR array to default
.018738	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01873a	9d 9a 04	sta $049a,x			sta 	ArrayDef+1,x
.01873d					_CDICopy:
.01873d	bd a1 04	lda $04a1,x			lda 	UsrArrayDef,x
.018740	9d 99 04	sta $0499,x			sta 	ArrayDef,x
.018743	ca		dex				dex
.018744	10 f7		bpl $01873d			bpl 	_CDICopy
.018746	68		pla				pla									; position of array identifier
.018747	85 10		sta $10				sta 	zTemp1
.018749	98		tya				tya
.01874a	48		pha				pha
.01874b	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.01874d	a8		tay				tay
.01874e	20 b4 92	jsr $0192b4			jsr 	VariableExtract 			; get the identifier
.018751	20 56 95	jsr $019556			jsr 	VariableLocate 				; check if it exists already.
.018754	b0 0e		bcs $018764			bcs 	_CDIError
.018756	20 40 93	jsr $019340			jsr 	VariableCreate 				; create it using the current ArrayDef
.018759	68		pla				pla 								; restore code position
.01875a	a8		tay				tay
.01875b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01875d	c8		iny				iny
.01875e	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018760	f0 83		beq $0186e5			beq 	Command_DIM
.018762	88		dey				dey
.018763	60		rts				rts
.018764					_CDIError:
.018764	20 2f 84	jsr $01842f			jsr ERR_Handler
>018767	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.01876f					_CDISyntax:
.01876f	4c 00 84	jmp $018400			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018772					Command_RUN:
.018772	20 1a 89	jsr $01891a			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018775	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018777	85 16		sta $16				sta 	zCodePtr+0
.018779	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01877b	85 17		sta $17				sta 	zCodePtr+1
.01877d	a9 00		lda #$00			lda 	#0
.01877f	85 18		sta $18				sta 	zCodePtr+2
.018781	85 19		sta $19				sta 	zCodePtr+3
.018783	a0 03		ldy #$03			ldy 	#3
.018785					RUN_NewLine:
.018785	a0 00		ldy #$00			ldy 	#0
.018787	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018789	c8		iny				iny
.01878a	c8		iny				iny
.01878b	c8		iny				iny
.01878c	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.01878e	d0 16		bne $0187a6			bne 	RUN_NextCommand
.018790	4c 2b 89	jmp $01892b			jmp 	Command_STOP 				; go do the command code.
.018793					RUN_Skip:
.018793	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018795	c8		iny				iny 								; skip
.018796	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018798	90 0c		bcc $0187a6			bcc 	_SEDone 					; so just skip over it.
.01879a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01879c	90 07		bcc $0187a5			bcc 	_SEDouble
.01879e	98		tya				tya 								; this is Y + 1
.01879f	18		clc				clc
.0187a0	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0187a2	a8		tay				tay 								; back in Y.
.0187a3	88		dey				dey 								; fix up, one for the +1, one for the iny
.0187a4	88		dey				dey
.0187a5					_SEDouble:
.0187a5	c8		iny				iny
.0187a6					_SEDone:
.0187a6					RUN_NextCommand:
.0187a6	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0187a8	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.0187aa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187ac	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0187ae	f0 e3		beq $018793			beq 	RUN_Skip
.0187b0	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0187b2	d0 0f		bne $0187c3			bne 	RUN_Execute
.0187b4					RUN_NextLine:
.0187b4	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0187b6	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0187b8	18		clc				clc
.0187b9	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0187bb	85 16		sta $16				sta 	zCodePtr
.0187bd	90 02		bcc $0187c1			bcc 	_SNLNoCarry
.0187bf	e6 17		inc $17				inc 	zCodePtr+1
.0187c1					_SNLNoCarry:
.0187c1	80 c2		bra $018785			bra 	RUN_NewLine 				; go do the new line code
.0187c3					RUN_Execute:
.0187c3	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0187c5	b0 1e		bcs $0187e5			bcs 	RUN_Extension
.0187c7	c8		iny				iny
.0187c8	0a		asl a				asl 	a 							; double the character read.
.0187c9	90 14		bcc $0187df			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0187cb	aa		tax				tax 								; ready to look up.
.0187cc	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into LocalVector
.0187d0	8d 05 03	sta $0305			sta 	LocalVector+1
.0187d3	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0187d7	8d 06 03	sta $0306			sta 	LocalVector+2
.0187da	20 46 8a	jsr $018a46			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0187dd	80 c7		bra $0187a6			bra 	RUN_NextCommand 			; do the next command.
.0187df					RUN_Default:
.0187df	88		dey				dey
.0187e0	20 ed 87	jsr $0187ed			jsr 	Command_LET 				; and try LET.
.0187e3	80 c1		bra $0187a6			bra 	RUN_NextCommand
.0187e5					RUN_Extension:
.0187e5	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0187e7	f0 aa		beq $018793			beq 	RUN_Skip 					; skip over it.
.0187e9	4c 00 84	jmp $018400			jmp 	SyntaxError
.0187ec					Command_COLON:
.0187ec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.0187ed					Command_LET:
.0187ed	20 47 92	jsr $019247			jsr 	VariableFind 				; get reference to one variable.
.0187f0	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.0187f2	20 8d 91	jsr $01918d			jsr 	CheckNextToken
.0187f5	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.0187f7	48		pha				pha
.0187f8	a5 23		lda $23				lda 	zVarDataPtr+1
.0187fa	48		pha				pha
.0187fb	a5 24		lda $24				lda 	zVarType
.0187fd	48		pha				pha
.0187fe	20 36 89	jsr $018936			jsr 	EvaluateExpression 			; evaluate the RHS.
.018801	68		pla				pla 								; restore target variable information.
.018802	85 24		sta $24				sta 	zVarType
.018804	68		pla				pla
.018805	85 23		sta $23				sta 	zVarDataPtr+1
.018807	68		pla				pla
.018808	85 22		sta $22				sta 	zVarDataPtr
.01880a	20 f9 95	jsr $0195f9			jsr 	VariableSet 				; set the value out.
.01880d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.01880e					Command_END:
>01880e	02						.byte 	2
.01880f	4c d7 86	jmp $0186d7			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018812					Command_PRINT:
.018812	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018814	c9 00		cmp #$00			cmp 	#0 							; end
.018816	f0 69		beq $018881			beq 	_CPR_NewLine
.018818	c9 c0		cmp #$c0			cmp 	#token_Colon
.01881a	f0 65		beq $018881			beq 	_CPR_NewLine
.01881c	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.01881e	f0 54		beq $018874			beq 	_CPR_Skip
.018820	c9 bf		cmp #$bf			cmp 	#token_Comma
.018822	f0 4d		beq $018871			beq 	_CPR_Tab
.018824	20 36 89	jsr $018936			jsr 	EvaluateExpression 			; get expression.
.018827	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.01882a	29 02		and #$02			and 	#2
.01882c	d0 25		bne $018853			bne 	_CPR_String 				; if type = 2 output as string.
.01882e					_CPR_Number:
.01882e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018830	8d 06 04	sta $0406			sta 	NumBufX
.018833	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018836	4a		lsr a				lsr 	a
.018837	b0 05		bcs $01883e			bcs 	_CPRInt 					; if msb set do as integer
.018839	20 8f 9d	jsr $019d8f			jsr 	FPToString 					; call fp to str otherwise
.01883c	80 03		bra $018841			bra 	_CPRNPrint
.01883e	20 7b 97	jsr $01977b	_CPRInt:jsr 	IntToString
.018841					_CPRNPrint:
.018841	ad 07 04	lda $0407			lda 	Num_Buffer 					; is first character -
.018844	c9 2d		cmp #$2d			cmp 	#"-"
.018846	f0 05		beq $01884d			beq 	_CPRNoSpace
.018848	a9 20		lda #$20			lda 	#" "						; print the leading space
.01884a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.01884d					_CPRNoSpace:
.01884d	a2 06		ldx #$06			ldx 	#(Num_Buffer-1) & $FF
.01884f	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.018851	80 06		bra $018859			bra 	_CPRPrint
.018853					_CPR_String:
.018853	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.018856	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.018859					_CPRPrint:
.018859	86 1e		stx $1e				stx 	zGenPtr
.01885b	85 1f		sta $1f				sta 	zGenPtr+1
.01885d	5a		phy				phy
.01885e	a0 00		ldy #$00			ldy 	#0							; get length into X
.018860	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018862	aa		tax				tax
.018863	f0 09		beq $01886e			beq 	_CPREndPrint 				; nothing to print
.018865					_CPRLoop:
.018865	c8		iny				iny
.018866	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018868	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01886b	ca		dex				dex
.01886c	d0 f7		bne $018865			bne 	_CPRLoop
.01886e					_CPREndPrint:
.01886e	7a		ply				ply
.01886f	80 a1		bra $018812			bra 	Command_Print
.018871					_CPR_Tab:
.018871	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018874					_CPR_Skip:
.018874	c8		iny				iny
.018875	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018877	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018879	f0 09		beq $018884			beq 	_CPR_Exit
.01887b	c9 00		cmp #$00			cmp 	#0
.01887d	d0 93		bne $018812			bne 	Command_PRINT 				; if not go round again.
.01887f	80 03		bra $018884			bra 	_CPR_Exit
.018881					_CPR_NewLine:
.018881	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018884					_CPR_Exit:
.018884	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018885					Command_ASSERT:
.018885	20 dc 8a	jsr $018adc			jsr 	EvaluateNumber 				; calculate thing being asserted
.018888	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.01888b	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01888e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018891	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018894	f0 01		beq $018897			beq 	_ASFail
.018896	60		rts				rts
.018897					_ASFail:
.018897	20 2f 84	jsr $01842f			jsr ERR_Handler
>01889a	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.0188a1					Command_GOTO:
.0188a1	20 a7 88	jsr $0188a7			jsr 	GotoGetLineNumber
.0188a4	4c c6 88	jmp $0188c6			jmp 	GotoChangeToLineNumber
.0188a7					GotoGetLineNumber:
.0188a7	20 eb 8a	jsr $018aeb			jsr 	EvaluateInteger
.0188aa	ad 0a 03	lda $030a			lda 	XS_Mantissa+2 				; check range
.0188ad	0d 0b 03	ora $030b			ora 	XS_Mantissa+3
.0188b0	d0 01		bne $0188b3			bne 	_GLINError
.0188b2	60		rts				rts
.0188b3					_GLINError:
.0188b3	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188b6	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0188be	20 4e 75 6d 62 65 72 00
.0188c6					GotoChangeToLineNumber:
.0188c6	ad 08 03	lda $0308			lda 	XS_Mantissa+0 				; check line number not zero
.0188c9	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.0188cc	f0 39		beq $018907			beq 	_GCTLFail
.0188ce	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188d0	85 16		sta $16				sta 	zCodePtr+0
.0188d2	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188d4	85 17		sta $17				sta 	zCodePtr+1
.0188d6	a9 00		lda #$00			lda 	#0
.0188d8	85 18		sta $18				sta 	zCodePtr+2
.0188da	85 19		sta $19				sta 	zCodePtr+3
.0188dc	a0 03		ldy #$03			ldy 	#3
.0188de					_GCTLLoop:
.0188de	a0 00		ldy #$00			ldy 	#0
.0188e0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188e2	c9 00		cmp #$00			cmp 	#0
.0188e4	f0 21		beq $018907			beq 	_GCTLFail
.0188e6	c8		iny				iny
.0188e7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188e9	cd 08 03	cmp $0308			cmp 	XS_Mantissa+0
.0188ec	d0 08		bne $0188f6			bne 	_GCTLNext
.0188ee	c8		iny				iny
.0188ef	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188f1	cd 09 03	cmp $0309			cmp 	XS_Mantissa+1
.0188f4	f0 0f		beq $018905			beq 	_GCTLExit
.0188f6					_GCTLNext:
.0188f6	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0188f8	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.0188fa	18		clc				clc
.0188fb	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.0188fd	85 16		sta $16				sta 	zCodePtr
.0188ff	90 02		bcc $018903			bcc 	_SNLNoCarry
.018901	e6 17		inc $17				inc 	zCodePtr+1
.018903					_SNLNoCarry:
.018903	80 d9		bra $0188de			bra 	_GCTLLoop 					; try next line.
.018905					_GCTLExit:
.018905	c8		iny				iny
.018906	60		rts				rts
.018907					_GCTLFail:
.018907	20 2f 84	jsr $01842f			jsr ERR_Handler
>01890a	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018912	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.01891a					Command_CLR:
.01891a					ResetRunStatus:
.01891a	20 83 92	jsr $019283			jsr 	VariableClear
.01891d	a9 00		lda #$00			lda 	#HighMemory & $FF
.01891f	8d 00 04	sta $0400			sta 	StringPtr
.018922	a9 80		lda #$80			lda 	#HighMemory >> 8
.018924	8d 01 04	sta $0401			sta 	StringPtr+1
.018927	20 58 94	jsr $019458			jsr 	ArrayResetDefault
.01892a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.01892b					Command_STOP:
.01892b	20 2f 84	jsr $01842f			jsr ERR_Handler
>01892e	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018933					EVESyntax:
.018933	4c 00 84	jmp $018400			jmp 	SyntaxError
.018936					EvaluateExpression:
.018936	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018938					EvaluateExpressionX:
.018938	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01893a					EvaluateExpressionXA:
.01893a	48		pha				pha 								; save precedence on stack.
.01893b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01893d	f0 f4		beq $018933			beq 	EVESyntax 					; end of line, syntax error.
.01893f	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018941	b0 03		bcs $018946			bcs 	_EVNotVariable
.018943	4c 3d 8a	jmp $018a3d			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018946					_EVNotVariable:
.018946	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018948	90 e9		bcc $018933			bcc 	EVESyntax
.01894a	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01894c	b0 7f		bcs $0189cd			bcs 	_EVNotInteger
.01894e	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018950	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018953	a9 00		lda #$00			lda 	#0
.018955	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018958	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01895b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01895e	1a		inc a				inc 	a 							; set to type 1 (integer)
.01895f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018962					_EVCheckNextInteger:
.018962	c8		iny				iny
.018963	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018965	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018967	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018969	b0 0d		bcs $018978			bcs 	_EVCheckDecimal
.01896b	48		pha				pha 								; save it.
.01896c	20 49 8a	jsr $018a49			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01896f	68		pla				pla
.018970	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018973	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018976	80 ea		bra $018962			bra 	_EVCheckNextInteger
.018978					_EVCheckDecimal:
.018978	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01897a	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01897c	d0 05		bne $018983			bne 	_EVGotAtom 					; no, get atom.
.01897e					_EVIsDecimal:
.01897e	20 79 8a	jsr $018a79			jsr 	EVGetDecimal 				; extend to the decimal part.
.018981	80 00		bra $018983			bra 	_EVGotAtom 					; and continue to got atom.
.018983					_EVGotAtom:
.018983	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018985	10 44		bpl $0189cb			bpl 	_EVExitDrop 				; must be a token.
.018987	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018989	b0 40		bcs $0189cb			bcs 	_EVExitDrop
.01898b	68		pla				pla 								; get current precedence
.01898c	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01898e	da		phx				phx 								; save X
.01898f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018991	aa		tax				tax 								; put in X
.018992	bf e5 84 01	lda $0184e5,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018996	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018998	fa		plx				plx 								; restore X
.018999	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01899b	90 2f		bcc $0189cc			bcc 	_EVExit 					; exit if too low.
.01899d	f0 2d		beq $0189cc			beq 	_EVExit 					; exit if equals
.01899f	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.0189a1	48		pha				pha
.0189a2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189a4	48		pha				pha
.0189a5	c8		iny				iny
.0189a6	da		phx				phx 								; save current position
.0189a7	e8		inx				inx
.0189a8	e8		inx				inx
.0189a9	e8		inx				inx
.0189aa	e8		inx				inx
.0189ab	e8		inx				inx
.0189ac	e8		inx				inx
.0189ad	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0189af	20 3a 89	jsr $01893a			jsr 	EvaluateExpressionXA 		; do the RHS.
.0189b2	fa		plx				plx 								; restore X
.0189b3	68		pla				pla 								; get the binary operator in A.
.0189b4					_EVCallA:
.0189b4	da		phx				phx 								; save X again
.0189b5	0a		asl a				asl 	a 							; double, lose the MSB.
.0189b6	aa		tax				tax									; put in X
.0189b7	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0189bb	8d 05 03	sta $0305			sta 	LocalVector+1
.0189be	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0189c2	8d 06 03	sta $0306			sta 	LocalVector+2
.0189c5	fa		plx				plx 								; restore X
.0189c6	20 46 8a	jsr $018a46			jsr 	EVCallLocalVector
.0189c9	80 b8		bra $018983			bra 	_EVGotAtom 					; and loop back.
.0189cb					_EVExitDrop:
.0189cb	68		pla				pla
.0189cc					_EVExit:
.0189cc	60		rts				rts
.0189cd					_EVNotInteger:
.0189cd	c8		iny				iny
.0189ce	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0189d0	d0 19		bne $0189eb			bne 	_EVNotMinus
.0189d2	20 ca 8a	jsr $018aca			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0189d5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0189d8	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0189da	f0 05		beq $0189e1			beq 	_EVMinusFloat
.0189dc	20 56 97	jsr $019756			jsr 	IntegerNegateAlways 		; negation
.0189df	80 a2		bra $018983			bra 	_EVGotAtom 					; and go back.
.0189e1					_EVMinusFloat:
.0189e1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.0189e4	49 80		eor #$80			eor 	#$80
.0189e6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0189e9	80 98		bra $018983			bra 	_EVGotAtom
.0189eb					_EVNotMinus:
.0189eb	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0189ed	d0 17		bne $018a06			bne 	_EVNotParenthesis
.0189ef	20 38 89	jsr $018938			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0189f2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189f4	c8		iny				iny
.0189f5	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0189f7	f0 8a		beq $018983			beq 	_EVGotAtom
.0189f9	20 2f 84	jsr $01842f			jsr ERR_Handler
>0189fc	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018a04	29 00
.018a06					_EVNotParenthesis:
.018a06	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.018a08	d0 0c		bne $018a16			bne 	_EVNotNot
.018a0a	20 ca 8a	jsr $018aca			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018a0d	20 64 9c	jsr $019c64			jsr 	FPUToInteger 				; make it an integer - if possible.
.018a10	20 a7 8a	jsr $018aa7			jsr 	NotInteger 					; do the not calculation
.018a13	4c 83 89	jmp $018983			jmp 	_EVGotAtom
.018a16					_EVNotNot:
.018a16	c9 fe		cmp #$fe			cmp 	#$FE
.018a18	d0 15		bne $018a2f			bne 	_EVNotString
.018a1a	20 21 92	jsr $019221			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.018a1d	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018a1f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a22	a5 21		lda $21				lda 	zTempStr+1
.018a24	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a27	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018a29	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018a2c	4c 83 89	jmp $018983			jmp 	_EVGotAtom
.018a2f					_EVNotString:
.018a2f	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018a31	90 04		bcc $018a37			bcc 	_EVBadElement
.018a33	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.018a35	90 03		bcc $018a3a			bcc 	_EVUnaryFunction
.018a37					_EVBadElement:
.018a37	4c 00 84	jmp $018400			jmp 	SyntaxError
.018a3a					_EVUnaryFunction:
.018a3a	4c b4 89	jmp $0189b4			jmp 	_EVCallA
.018a3d					_EVVariableHandler:
.018a3d	20 47 92	jsr $019247			jsr 	VariableFind 				; locate a variable
.018a40	20 9a 95	jsr $01959a			jsr 	VariableGet 				; copy into memory.
.018a43	4c 83 89	jmp $018983			jmp 	_EVGotAtom 					; and go round.
.018a46					EVCallLocalVector:
.018a46	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.018a49					EVShiftMantissaLeft6:
.018a49	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018a4c	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.018a4f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018a52	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a55	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018a58	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a5b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018a5e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a61	a9 00		lda #$00			lda 	#0
.018a63	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a66	20 69 8a	jsr $018a69			jsr 	_EVSMLShift 					; call it here to do it twice
.018a69					_EVSMLShift:
.018a69	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.018a6c	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.018a6f	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018a72	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018a75	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018a78	60		rts				rts
.018a79					EVGetDecimal:
.018a79	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018a7b	8d 07 04	sta $0407			sta 	Num_Buffer
.018a7e	da		phx				phx
.018a7f	c8		iny				iny
.018a80	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a82	c8		iny				iny
.018a83	3a		dec a				dec 	a								; convert to a string length.
.018a84	3a		dec a				dec 	a
.018a85	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018a87					_EVGDCopy:
.018a87	48		pha				pha 									; save count
.018a88	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a8a	9d 07 04	sta $0407,x			sta 	Num_Buffer,x
.018a8d	e8		inx				inx 									; forward ....
.018a8e	c8		iny				iny
.018a8f	68		pla				pla 									; get count
.018a90	3a		dec a				dec 	a 								; until zero
.018a91	d0 f4		bne $018a87			bne 	_EVGDCopy
.018a93	9d 07 04	sta $0407,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018a96	fa		plx				plx 									; restore X
.018a97	a9 07		lda #$07			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018a99	85 1e		sta $1e				sta 	zGenPtr
.018a9b	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.018a9d	85 1f		sta $1f				sta 	zGenPtr+1
.018a9f	5a		phy				phy 									; save Y
.018aa0	a0 00		ldy #$00			ldy 	#0 								; start position
.018aa2	20 56 9e	jsr $019e56			jsr 	FPFromString 					; convert current
.018aa5	7a		ply				ply 									; restore Y
.018aa6	60		rts				rts
.018aa7					NotInteger:
.018aa7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018aaa	49 ff		eor #$ff			eor 	#$FF
.018aac	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018aaf	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018ab2	49 ff		eor #$ff			eor 	#$FF
.018ab4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ab7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018aba	49 ff		eor #$ff			eor 	#$FF
.018abc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018abf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018ac2	49 ff		eor #$ff			eor 	#$FF
.018ac4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ac7	60		rts				rts
.018ac8					EvaluateGetAtom:
.018ac8	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018aca					EvaluateGetAtomX:
.018aca	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018acc	20 3a 89	jsr $01893a			jsr 	EvaluateExpressionXA
.018acf	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018ad2	29 0f		and #$0f			and 	#15
.018ad4	c9 02		cmp #$02			cmp 	#2
.018ad6	b0 01		bcs $018ad9			bcs 	EvaluateType
.018ad8	60		rts				rts
.018ad9					EvaluateType:
.018ad9	4c 10 84	jmp $018410			jmp 	TypeError
.018adc					EvaluateNumber:
.018adc	a2 00		ldx #$00			ldx 	#0
.018ade					EvaluateNumberX:
.018ade	20 38 89	jsr $018938			jsr 	EvaluateExpressionX
.018ae1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.018ae4	29 0f		and #$0f			and 	#15
.018ae6	c9 02		cmp #$02			cmp 	#2
.018ae8	b0 ef		bcs $018ad9			bcs 	EvaluateType
.018aea	60		rts				rts
.018aeb					EvaluateInteger:
.018aeb	a2 00		ldx #$00			ldx 	#0
.018aed					EvaluateIntegerX:
.018aed	20 de 8a	jsr $018ade			jsr 	EvaluateNumberX
.018af0	20 64 9c	jsr $019c64			jsr 	FPUToInteger
.018af3	60		rts				rts
.018af4					EvaluateString:
.018af4	a2 00		ldx #$00			ldx 	#0
.018af6					EvaluateStringX:
.018af6	20 38 89	jsr $018938			jsr 	EvaluateExpressionX
.018af9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.018afc	29 0f		and #$0f			and 	#15
.018afe	c9 02		cmp #$02			cmp 	#2
.018b00	d0 d7		bne $018ad9			bne 	EvaluateType
.018b02	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018b05	85 1e		sta $1e				sta 	zGenPtr
.018b07	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018b0a	85 1f		sta $1f				sta 	zGenPtr+1
.018b0c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018b0d					BinaryOp_And:
.018b0d	20 85 8b	jsr $018b85			jsr 	BinaryMakeBothInteger
.018b10	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018b13	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.018b16	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b19	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018b1c	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.018b1f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b22	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018b25	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018b28	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b2b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018b2e	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018b31	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b34	60		rts				rts
.018b35					BinaryOp_Or:
.018b35	20 85 8b	jsr $018b85			jsr 	BinaryMakeBothInteger
.018b38	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018b3b	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018b3e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b41	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018b44	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018b47	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b4a	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018b4d	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018b50	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b53	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018b56	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018b59	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b5c	60		rts				rts
.018b5d					BinaryOp_Eor:
.018b5d					BinaryOp_Xor:
.018b5d	20 85 8b	jsr $018b85			jsr 	BinaryMakeBothInteger
.018b60	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018b63	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018b66	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018b69	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018b6c	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018b6f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018b72	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018b75	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018b78	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018b7b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018b7e	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018b81	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b84	60		rts				rts
.018b85					BinaryMakeBothInteger:
.018b85	da		phx				phx 								; save X
.018b86	e8		inx				inx
.018b87	e8		inx				inx
.018b88	e8		inx				inx
.018b89	e8		inx				inx
.018b8a	e8		inx				inx
.018b8b	e8		inx				inx
.018b8c	20 90 8b	jsr $018b90			jsr 	BinaryMakeInteger 			; convert to integer.
.018b8f	fa		plx				plx 								; restore X and fall through.
.018b90					BinaryMakeInteger:
.018b90	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018b93	29 0f		and #$0f			and 	#15 						; check type zero
.018b95	f0 04		beq $018b9b			beq 	_BMIConvert 				; if float convert to integer.
.018b97	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018b98	90 04		bcc $018b9e			bcc 	_BMIError
.018b9a	60		rts				rts
.018b9b					_BMIConvert:
.018b9b	4c 64 9c	jmp $019c64			jmp 	FPUToInteger 				; convert to integer
.018b9e					_BMIError:
.018b9e	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018ba1					Binary_Equal:
.018ba1	20 ed 8b	jsr $018bed			jsr 	CompareValues
.018ba4	09 00		ora #$00			ora 	#0
.018ba6	f0 04		beq $018bac			beq 	CCTrue
.018ba8	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018baa	80 02		bra $018bae			bra 	CCWrite
.018bac	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018bae	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018bb1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018bb4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018bb7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bba	a9 01		lda #$01			lda 	#1
.018bbc	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018bbf	60		rts				rts
.018bc0					Binary_NotEqual:
.018bc0	20 ed 8b	jsr $018bed			jsr 	CompareValues
.018bc3	09 00		ora #$00			ora 	#0
.018bc5	f0 e1		beq $018ba8			beq 	CCFalse
.018bc7	80 e3		bra $018bac			bra 	CCTrue
.018bc9					Binary_Less:
.018bc9	20 ed 8b	jsr $018bed			jsr 	CompareValues
.018bcc	09 00		ora #$00			ora 	#0
.018bce	30 dc		bmi $018bac			bmi 	CCTrue
.018bd0	80 d6		bra $018ba8			bra 	CCFalse
.018bd2					Binary_LessEqual:
.018bd2	20 ed 8b	jsr $018bed			jsr 	CompareValues
.018bd5	c9 01		cmp #$01			cmp 	#1
.018bd7	d0 d3		bne $018bac			bne 	CCTrue
.018bd9	80 cd		bra $018ba8			bra 	CCFalse
.018bdb					Binary_GreaterEqual:
.018bdb	20 ed 8b	jsr $018bed			jsr 	CompareValues
.018bde	09 00		ora #$00			ora 	#0
.018be0	10 ca		bpl $018bac			bpl 	CCTrue
.018be2	80 c4		bra $018ba8			bra 	CCFalse
.018be4					Binary_Greater:
.018be4	20 ed 8b	jsr $018bed			jsr 	CompareValues
.018be7	c9 01		cmp #$01			cmp 	#1
.018be9	f0 c1		beq $018bac			beq 	CCTrue
.018beb	80 bb		bra $018ba8			bra 	CCFalse
.018bed					CompareValues:
.018bed	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018bf0	3d 13 03	and $0313,x			and 	XS2_Type,x
.018bf3	c9 02		cmp #$02			cmp 	#2
.018bf5	f0 13		beq $018c0a			beq 	_CVString
.018bf7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018bfa	3d 13 03	and $0313,x			and 	XS2_Type,x
.018bfd	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018bfe	90 03		bcc $018c03			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c00	4c 50 8c	jmp $018c50			jmp 	CompareInteger32 							; so execute code at \1
.018c03					_BCFloat:
.018c03	20 1e 8d	jsr $018d1e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c06	4c 73 9b	jmp $019b73			jmp 	FPCompare 							; and execute code at \2
.018c09	60		rts				rts
.018c0a					_CVString:
.018c0a	da		phx				phx 								; save XY
.018c0b	5a		phy				phy
.018c0c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018c0f	85 1a		sta $1a				sta		zLTemp1+0
.018c11	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c14	85 1b		sta $1b				sta 	zLTemp1+1
.018c16	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018c19	85 1c		sta $1c				sta 	zLTemp1+2
.018c1b	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018c1e	85 1d		sta $1d				sta 	zLTemp1+3
.018c20	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018c22	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c24	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018c26	90 02		bcc $018c2a			bcc 	_CVCommon
.018c28	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018c2a					_CVCommon:
.018c2a	aa		tax				tax 								; put shorter string length in zero.
.018c2b	f0 0c		beq $018c39			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018c2d					_CVCompare:
.018c2d	c8		iny				iny 								; next character
.018c2e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018c30	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018c32	90 13		bcc $018c47			bcc 	_CVReturnLess 				; <
.018c34	d0 15		bne $018c4b			bne 	_CVReturnGreater 			; >
.018c36	ca		dex				dex 								; until common length matched.
.018c37	d0 f4		bne $018c2d			bne 	_CVCompare
.018c39					_CVMatch:
.018c39	a0 00		ldy #$00			ldy 	#0
.018c3b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c3d	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018c3f	90 06		bcc $018c47			bcc 	_CVReturnLess 				; <
.018c41	d0 08		bne $018c4b			bne 	_CVReturnGreater 			; >
.018c43	a9 00		lda #$00			lda 	#0
.018c45	80 06		bra $018c4d			bra 	_CVExit 					; same common, same length, same string
.018c47					_CVReturnLess:
.018c47	a9 ff		lda #$ff			lda 	#$FF
.018c49	80 02		bra $018c4d			bra 	_CVExit
.018c4b					_CVReturnGreater:
.018c4b	a9 01		lda #$01			lda 	#$01
.018c4d					_CVExit:
.018c4d	7a		ply				ply
.018c4e	fa		plx				plx
.018c4f	60		rts				rts
.018c50					CompareInteger32:
.018c50	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018c53	49 80		eor #$80			eor 	#$80
.018c55	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018c58	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018c5b	49 80		eor #$80			eor 	#$80
.018c5d	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018c60	20 f8 8c	jsr $018cf8			jsr 	SubInteger32 				; subtraction
.018c63	90 11		bcc $018c76			bcc 	_CI32Less 					; cc return -1
.018c65	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018c68	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018c6b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018c6e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018c71	f0 02		beq $018c75			beq 	_CI32Exit
.018c73	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018c75					_CI32Exit:
.018c75	60		rts				rts
.018c76					_CI32Less:
.018c76	a9 ff		lda #$ff			lda 	#$FF
.018c78	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018c79					BinaryOp_Add:
.018c79	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018c7c	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c7f	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018c81	d0 13		bne $018c96			bne 	_BOAString
.018c83	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c86	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c89	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018c8a	90 03		bcc $018c8f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018c8c	4c d2 8c	jmp $018cd2			jmp 	AddInteger32 							; so execute code at \1
.018c8f					_BCFloat:
.018c8f	20 1e 8d	jsr $018d1e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018c92	4c e7 98	jmp $0198e7			jmp 	FPAdd 							; and execute code at \2
.018c95	60		rts				rts
.018c96					_BOAString:
.018c96	4c 39 8d	jmp $018d39			jmp 	ConcatenateString 			; concatenate two strings.
.018c99					BinaryOp_Subtract:
.018c99	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018c9c	3d 13 03	and $0313,x			and 	XS2_Type,x
.018c9f	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018ca0	90 03		bcc $018ca5			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ca2	4c f8 8c	jmp $018cf8			jmp 	SubInteger32 							; so execute code at \1
.018ca5					_BCFloat:
.018ca5	20 1e 8d	jsr $018d1e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ca8	4c dd 98	jmp $0198dd			jmp 	FPSubtract 							; and execute code at \2
.018cab	60		rts				rts
.018cac					BinaryOp_Multiply:
.018cac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018caf	3d 13 03	and $0313,x			and 	XS2_Type,x
.018cb2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018cb3	90 03		bcc $018cb8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018cb5	4c 69 96	jmp $019669			jmp 	MulInteger32 							; so execute code at \1
.018cb8					_BCFloat:
.018cb8	20 1e 8d	jsr $018d1e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018cbb	4c 53 9a	jmp $019a53			jmp 	FPMultiply 							; and execute code at \2
.018cbe	60		rts				rts
.018cbf					BinaryOp_Divide:
.018cbf	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018cc2	3d 13 03	and $0313,x			and 	XS2_Type,x
.018cc5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018cc6	90 03		bcc $018ccb			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018cc8	4c c0 96	jmp $0196c0			jmp 	DivInteger32 							; so execute code at \1
.018ccb					_BCFloat:
.018ccb	20 1e 8d	jsr $018d1e			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018cce	4c cb 99	jmp $0199cb			jmp 	FPDivide 							; and execute code at \2
.018cd1	60		rts				rts
.018cd2					AddInteger32:
.018cd2	18		clc				clc
.018cd3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018cd6	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018cd9	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018cdc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018cdf	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018ce2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ce5	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018ce8	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018ceb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018cee	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018cf1	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018cf4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018cf7	60		rts				rts
.018cf8					SubInteger32:
.018cf8	38		sec				sec
.018cf9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018cfc	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018cff	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d02	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d05	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018d08	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d0b	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018d0e	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018d11	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d14	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d17	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018d1a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d1d	60		rts				rts
.018d1e					BinaryMakeBothFloat:
.018d1e	da		phx				phx 								; save X
.018d1f	e8		inx				inx
.018d20	e8		inx				inx
.018d21	e8		inx				inx
.018d22	e8		inx				inx
.018d23	e8		inx				inx
.018d24	e8		inx				inx
.018d25	20 29 8d	jsr $018d29			jsr 	BinaryMakeFloat 			; convert to float.
.018d28	fa		plx				plx 								; restore X and fall through.
.018d29					BinaryMakeFloat:
.018d29	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018d2c	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018d2d	b0 04		bcs $018d33			bcs 	_BMFConvert
.018d2f	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018d30	b0 04		bcs $018d36			bcs 	_BMFError
.018d32	60		rts				rts
.018d33					_BMFConvert:
.018d33	4c 05 9c	jmp $019c05			jmp 	FPUToFloat 					; convert to float
.018d36					_BMFError:
.018d36	4c 10 84	jmp $018410			jmp 	TypeError
.018d39					ConcatenateString:
.018d39	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018d3c	85 1a		sta $1a				sta		zLTemp1+0
.018d3e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d41	85 1b		sta $1b				sta 	zLTemp1+1
.018d43	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018d46	85 1c		sta $1c				sta 	zLTemp1+2
.018d48	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018d4b	85 1d		sta $1d				sta 	zLTemp1+3
.018d4d	5a		phy				phy
.018d4e	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018d50	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018d52	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018d54	7a		ply				ply
.018d55	b0 37		bcs $018d8e			bcs 	_CSError					; check in range.
.018d57	c9 fe		cmp #$fe			cmp 	#maxString+1
.018d59	b0 33		bcs $018d8e			bcs 	_CSError
.018d5b	20 e6 91	jsr $0191e6			jsr 	AllocateTempString 			; store the result
.018d5e	20 79 8d	jsr $018d79			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018d61	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018d64	85 1a		sta $1a				sta 	zLTemp1
.018d66	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018d69	85 1b		sta $1b				sta 	zLTemp1+1
.018d6b	20 79 8d	jsr $018d79			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018d6e	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018d70	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d73	a5 21		lda $21				lda 	zTempStr+1
.018d75	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d78	60		rts				rts
.018d79					_CSCopyString:
.018d79	da		phx				phx
.018d7a	5a		phy				phy
.018d7b	a0 00		ldy #$00			ldy 	#0 							; get length
.018d7d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018d7f	f0 0a		beq $018d8b			beq 	_CSCSExit 					; if zero, exit
.018d81	aa		tax				tax 								; put in X
.018d82					_CSCSLoop:
.018d82	c8		iny				iny 								; get next char
.018d83	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018d85	20 11 92	jsr $019211			jsr		WriteTempString 			; copy out
.018d88	ca		dex				dex 								; do whole string
.018d89	d0 f7		bne $018d82			bne 	_CSCSLoop
.018d8b					_CSCSExit:
.018d8b	7a		ply				ply
.018d8c	fa		plx				plx
.018d8d	60		rts				rts
.018d8e					_CSError:
.018d8e	20 2f 84	jsr $01842f			jsr ERR_Handler
>018d91	53 74 72 69 6e 67 20 74			.text "String too long",0
>018d99	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018da1					Unary_Sgn:
.018da1	20 de 8a	jsr $018ade			jsr 	EvaluateNumberX 			; get value
.018da4	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; check right bracket.
.018da7	20 cb 8d	jsr $018dcb			jsr 	GetSignCurrent 				; get sign.
.018daa	09 00		ora #$00			ora 	#0
.018dac	10 09		bpl $018db7			bpl		UnarySetAInteger			; if 0,1 return that.
.018dae	80 00		bra $018db0			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018db0					UnarySetAMinus1:
.018db0	a9 ff		lda #$ff			lda 	#$FF
.018db2	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018db5	80 05		bra $018dbc			bra 	UnarySetAFill
.018db7					UnarySetAInteger:
.018db7	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018dba	a9 00		lda #$00			lda 	#0
.018dbc					UnarySetAFill:
.018dbc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018dbf	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018dc2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018dc5	a9 01		lda #$01			lda 	#1
.018dc7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018dca	60		rts				rts
.018dcb					GetSignCurrent:
.018dcb	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018dce	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018dcf	90 19		bcc $018dea			bcc 	_GSCFloat
.018dd1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018dd4	30 11		bmi $018de7			bmi 	_GSCMinus1
.018dd6	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018dd9	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018ddc	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ddf	d0 03		bne $018de4			bne 	_GSCPlus1
.018de1					_GSCZero:
.018de1	a9 00		lda #$00			lda 	#0
.018de3	60		rts				rts
.018de4					_GSCPlus1:
.018de4	a9 01		lda #$01			lda 	#$01
.018de6	60		rts				rts
.018de7					_GSCMinus1:
.018de7	a9 ff		lda #$ff			lda 	#$FF
.018de9	60		rts				rts
.018dea					_GSCFloat:
.018dea	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018ded	70 f2		bvs $018de1			bvs 	_GSCZero
.018def	30 f6		bmi $018de7			bmi 	_GSCMinus1
.018df1	80 f1		bra $018de4			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018df3					Unary_Abs:
.018df3	20 de 8a	jsr $018ade			jsr 	EvaluateNumberX 			; get value
.018df6	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; check right bracket.
.018df9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018dfc	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018dfe	f0 08		beq $018e08			beq 	_UAMinusFloat
.018e00	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018e03	10 0b		bpl $018e10			bpl 	_UAExit
.018e05	4c 56 97	jmp $019756			jmp 	IntegerNegateAlways 		; negation
.018e08					_UAMinusFloat:
.018e08	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018e0b	29 7f		and #$7f			and		#$7F
.018e0d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018e10					_UAExit:
.018e10	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018e11					Unary_Peek:
.018e11	a9 01		lda #$01			lda 	#1
.018e13	80 06		bra $018e1b			bra 	UPMain
.018e15					Unary_Deek:
.018e15	a9 02		lda #$02			lda 	#2
.018e17	80 02		bra $018e1b			bra 	UPMain
.018e19					Unary_Leek:
.018e19	a9 04		lda #$04			lda 	#4
.018e1b					UPMain:
.018e1b	48		pha				pha 								; set bytes to copy.
.018e1c	20 ed 8a	jsr $018aed			jsr 	EvaluateIntegerX 			; numeric parameter
.018e1f	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.018e22	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018e25	85 1a		sta $1a				sta 	zLTemp1
.018e27	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e2a	85 1b		sta $1b				sta 	zLTemp1+1
.018e2c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018e2f	85 1c		sta $1c				sta 	zLTemp1+2
.018e31	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018e34	85 1d		sta $1d				sta 	zLTemp1+3
.018e36	a9 00		lda #$00			lda 	#0 							; clear target area
.018e38	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018e3b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018e3e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018e41	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018e44	68		pla				pla 								; restore bytes to copy
.018e45	da		phx				phx 								; save XY
.018e46	5a		phy				phy
.018e47	20 44 91	jsr $019144			jsr 	MemRead 					; read the bytes in
.018e4a	7a		ply				ply 								; restore and exit
.018e4b	fa		plx				plx
.018e4c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018e4d					Unary_Mod:
.018e4d	20 79 8e	jsr $018e79			jsr 	_UMParameter 				; first parameter
.018e50	20 ac 91	jsr $0191ac			jsr 	CheckNextComma
.018e53	da		phx				phx 								; second parameter
.018e54	e8		inx				inx
.018e55	e8		inx				inx
.018e56	e8		inx				inx
.018e57	e8		inx				inx
.018e58	e8		inx				inx
.018e59	e8		inx				inx
.018e5a	20 79 8e	jsr $018e79			jsr 	_UMParameter
.018e5d	fa		plx				plx
.018e5e	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen
.018e61	20 c0 96	jsr $0196c0			jsr 	DivInteger32 				; divide
.018e64	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018e66	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018e69	a5 1b		lda $1b				lda 	zLTemp1+1
.018e6b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018e6e	a5 1c		lda $1c				lda 	zLTemp1+2
.018e70	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018e73	a5 1d		lda $1d				lda 	zLTemp1+3
.018e75	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018e78	60		rts				rts
.018e79					_UMParameter:
.018e79	20 ed 8a	jsr $018aed			jsr 	EvaluateIntegerX 			; get value
.018e7c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018e7f	10 03		bpl $018e84			bpl 	_UMNotSigned
.018e81	20 56 97	jsr $019756			jsr 	IntegerNegateAlways
.018e84					_UMNotSigned:
.018e84	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018e85					Unary_Usr:
.018e85	20 de 8a	jsr $018ade			jsr 	EvaluateNumberX 			; numeric parameter
.018e88	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.018e8b	da		phx				phx 								; save XY
.018e8c	5a		phy				phy
.018e8d	ea		nop				nop
.018e8e	22 00 03 00	jsl $000300			jsl 	UserVector
.018e92	7a		ply				ply 								; and exit
.018e93	fa		plx				plx
.018e94	60		rts				rts
.018e95					USRDefault:
.018e95	20 2f 84	jsr $01842f			jsr ERR_Handler
>018e98	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018ea0	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018ea7					Unary_Val:
.018ea7	20 f6 8a	jsr $018af6			jsr 	EvaluateStringX 			; get string
.018eaa	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; check right bracket.
.018ead	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018eb0	85 1e		sta $1e				sta 	zGenPtr
.018eb2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018eb5	85 1f		sta $1f				sta 	zGenPtr+1
.018eb7	5a		phy				phy
.018eb8	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018eba	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018ebc	f0 57		beq $018f15			beq 	_UVBadNumber
.018ebe	48		pha				pha 								; save length.
.018ebf	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018ec0	1a		inc a				inc 	a
.018ec1	20 e6 91	jsr $0191e6			jsr 	AllocateTempString
.018ec4	c8		iny				iny 								; move to the next.
.018ec5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018ec7	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018ec9	8d 92 04	sta $0492			sta 	ValSign
.018ecc	d0 04		bne $018ed2			bne 	_UVNotMinus
.018ece	c8		iny				iny 								; skip over it.
.018ecf	68		pla				pla 								; decrement character count.
.018ed0	3a		dec a				dec 	a
.018ed1	48		pha				pha
.018ed2					_UVNotMinus:
.018ed2	68		pla				pla 								; this is the count.
.018ed3	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018ed4	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018ed6	c8		iny				iny
.018ed7	20 11 92	jsr $019211			jsr 	WriteTempString
.018eda	68		pla				pla
.018edb	3a		dec a				dec 	a
.018edc	d0 f5		bne $018ed3			bne 	_UVCopy
.018ede	20 11 92	jsr $019211			jsr 	WriteTempString 			; make it ASCIIZ
.018ee1	18		clc				clc
.018ee2	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018ee4	69 01		adc #$01			adc 	#1
.018ee6	85 1e		sta $1e				sta 	zGenPtr
.018ee8	a5 21		lda $21				lda 	zTempStr+1
.018eea	69 00		adc #$00			adc 	#0
.018eec	85 1f		sta $1f				sta 	zGenPtr+1
.018eee	18		clc				clc
.018eef	20 32 98	jsr $019832			jsr 	IntFromString 				; first bit.
.018ef2	b0 21		bcs $018f15			bcs 	_UVBadNumber
.018ef4	20 56 9e	jsr $019e56			jsr 	FPFromString				; try for a float part.
.018ef7	ad 92 04	lda $0492			lda 	ValSign 					; was it negative
.018efa	d0 13		bne $018f0f			bne 	_UVNotNegative
.018efc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018eff	4a		lsr a				lsr 	a
.018f00	b0 0a		bcs $018f0c			bcs 	_UVInteger
.018f02	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018f05	09 80		ora #$80			ora 	#$80
.018f07	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018f0a	80 03		bra $018f0f			bra 	_UVNotNegative
.018f0c					_UVInteger:
.018f0c	20 56 97	jsr $019756			jsr 	IntegerNegateAlways 		; sign it.
.018f0f					_UVNotNegative:
.018f0f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018f11	d0 02		bne $018f15			bne 	_UVBadNumber
.018f13	7a		ply				ply
.018f14	60		rts				rts
.018f15					_UVBadNumber:
.018f15	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018f18					Unary_Str:
.018f18	20 de 8a	jsr $018ade			jsr 	EvaluateNumberX 			; numeric parameter
.018f1b	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.018f1e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018f20	8d 06 04	sta $0406			sta 	NumBufX
.018f23	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018f26	4a		lsr a				lsr 	a
.018f27	b0 05		bcs $018f2e			bcs 	_USInt 						; if msb set do as integer
.018f29	20 8f 9d	jsr $019d8f			jsr 	FPToString 					; call fp to str otherwise
.018f2c	80 03		bra $018f31			bra 	_USDuplicate
.018f2e	20 7b 97	jsr $01977b	_USInt:	jsr 	IntToString
.018f31					_USDuplicate:
.018f31	ad 06 04	lda $0406			lda 	NumBufX 					; chars in buffer
.018f34	1a		inc a				inc 	a 							; one more for length
.018f35	20 e6 91	jsr $0191e6			jsr 	AllocateTempString 			; allocate space for it.
.018f38	5a		phy				phy 								; save Y
.018f39	a0 00		ldy #$00			ldy 	#0 							; start copying
.018f3b	b9 07 04	lda $0407,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018f3e	20 11 92	jsr $019211			jsr 	WriteTempString
.018f41	c8		iny				iny
.018f42	cc 06 04	cpy $0406			cpy 	NumBufX 					; done the lot
.018f45	d0 f4		bne $018f3b			bne 	_USCopy
.018f47	7a		ply				ply 								; restore Y
.018f48	4c 34 91	jmp $019134			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018f4b					Unary_Asc:
.018f4b	20 f6 8a	jsr $018af6			jsr 	EvaluateStringX 			; string parameter
.018f4e	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.018f51	5a		phy				phy 								; get the string length
.018f52	a0 00		ldy #$00			ldy 	#0
.018f54	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f56	f0 07		beq $018f5f			beq 	_UAIllegal 					; must be at least one character
.018f58	c8		iny				iny
.018f59	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018f5b	7a		ply				ply
.018f5c	4c b7 8d	jmp $018db7			jmp 	UnarySetAInteger
.018f5f					_UAIllegal:
.018f5f	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018f62					Unary_Len:
.018f62	20 f6 8a	jsr $018af6			jsr 	EvaluateStringX 			; string parameter
.018f65	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.018f68	5a		phy				phy 								; get the string length
.018f69	a0 00		ldy #$00			ldy 	#0
.018f6b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f6d	7a		ply				ply
.018f6e	4c b7 8d	jmp $018db7			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018f71					Unary_Mid:
.018f71	20 f6 8a	jsr $018af6			jsr 	EvaluateStringX 				; get string.
.018f74	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f77	48		pha				pha
.018f78	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f7b	48		pha				pha
.018f7c	20 ac 91	jsr $0191ac			jsr 	CheckNextComma 					; skip comma
.018f7f	20 0c 90	jsr $01900c			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018f82	48		pha				pha 									; and push it.
.018f83	20 ac 91	jsr $0191ac			jsr 	CheckNextComma 					; skip comma
.018f86	20 0c 90	jsr $01900c			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018f89	48		pha				pha 									; and push it.
.018f8a	80 45		bra $018fd1			bra 	SLIProcess
.018f8c					Unary_Left:
.018f8c	20 f6 8a	jsr $018af6			jsr 	EvaluateStringX 				; get string.
.018f8f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018f92	48		pha				pha
.018f93	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f96	48		pha				pha
.018f97	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018f99	48		pha				pha
.018f9a	20 ac 91	jsr $0191ac			jsr 	CheckNextComma 					; skip comma
.018f9d	20 0c 90	jsr $01900c			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018fa0	48		pha				pha 									; and push it.
.018fa1	80 2e		bra $018fd1			bra 	SLIProcess
.018fa3					Unary_Right:
.018fa3	20 f6 8a	jsr $018af6			jsr 	EvaluateStringX 				; get string.
.018fa6	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018fa9	48		pha				pha
.018faa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018fad	48		pha				pha
.018fae	da		phx				phx 									; get the string length and push on stack.
.018faf	a2 00		ldx #$00			ldx 	#0
.018fb1	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018fb3	fa		plx				plx
.018fb4	48		pha				pha
.018fb5	20 ac 91	jsr $0191ac			jsr 	CheckNextComma 					; skip comma
.018fb8	20 0c 90	jsr $01900c			jsr 	SLIByteParameter 				; get a byte parameter.
.018fbb	8d 90 04	sta $0490			sta 	SignCount 						; save in temporary.
.018fbe	68		pla				pla 									; restore string length.
.018fbf	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018fc0	38		sec				sec
.018fc1	ed 90 04	sbc $0490			sbc 	SignCount 						; subtract characters needed, gives start position.
.018fc4	f0 02		beq $018fc8			beq 	_URStart 						; if <= 0 start from 1.
.018fc6	10 02		bpl $018fca			bpl 	_UROkay
.018fc8					_URStart:
.018fc8	a9 01		lda #$01			lda 	#1
.018fca					_UROkay:
.018fca	48		pha				pha 									; push start
.018fcb	ad 90 04	lda $0490			lda 	SignCount 						; push count of characters
.018fce	48		pha				pha
.018fcf	80 00		bra $018fd1			bra 	SLIProcess
.018fd1					SLIProcess:
.018fd1	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 				; closing right bracket.
.018fd4	68		pla				pla
.018fd5	8d 94 04	sta $0494			sta 	SliceCount 						; count in signcount
.018fd8	1a		inc a				inc 	a 								; allocate +1 for it.
.018fd9	20 e6 91	jsr $0191e6			jsr 	AllocateTempString
.018fdc	68		pla				pla 									; pop start number off stack.
.018fdd	f0 3f		beq $01901e			beq 	SLIError 						; exit if start = 0
.018fdf	8d 93 04	sta $0493			sta 	SliceStart
.018fe2	68		pla				pla  									; pop string address.
.018fe3	85 1f		sta $1f				sta 	zGenPtr+1
.018fe5	68		pla				pla
.018fe6	85 1e		sta $1e				sta 	zGenPtr
.018fe8	da		phx				phx
.018fe9	5a		phy				phy
.018fea	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018fec	ac 93 04	ldy $0493			ldy 	SliceStart 						; start of the string (+1 for count)
.018fef					_SLICopy:
.018fef	ad 94 04	lda $0494			lda 	SliceCount 						; done count characters
.018ff2	f0 12		beq $019006			beq 	_SLIExit
.018ff4	ce 94 04	dec $0494			dec 	SliceCount
.018ff7	98		tya				tya 									; index of character
.018ff8	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018ffa	f0 02		beq $018ffe			beq 	_SLIOk 							; if equal, okay.
.018ffc	b0 08		bcs $019006			bcs 	_SLIExit 						; if past end, then exit.
.018ffe	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019000	c8		iny				iny
.019001	20 11 92	jsr $019211			jsr 	WriteTempString
.019004	80 e9		bra $018fef			bra 	_SLICopy 						; go round till copied characters
.019006					_SLIExit:
.019006	7a		ply				ply 									; restore YX
.019007	fa		plx				plx
.019008	4c 34 91	jmp $019134			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01900b	ea		nop				nop
.01900c					SLIByteParameter:
.01900c	20 ed 8a	jsr $018aed			jsr 	EvaluateIntegerX 				; get integer
.01900f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019012	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019015	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019018	d0 04		bne $01901e			bne 	SLIError
.01901a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01901d	60		rts				rts
.01901e					SLIError:
.01901e	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019021					Unary_Hex:
.019021	20 ed 8a	jsr $018aed			jsr 	EvaluateIntegerX 			; numeric parameter
.019024	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.019027	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019029	20 e6 91	jsr $0191e6			jsr 	AllocateTempString			; allocate string space
.01902c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01902f	20 56 90	jsr $019056			jsr 	_UHConvert
.019032	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019035	20 56 90	jsr $019056			jsr 	_UHConvert
.019038	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01903b	20 56 90	jsr $019056			jsr 	_UHConvert
.01903e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019041	20 56 90	jsr $019056			jsr 	_UHConvert
.019044	5a		phy				phy 								; get length of new string
.019045	a0 00		ldy #$00			ldy 	#0
.019047	b1 20		lda ($20),y			lda 	(zTempStr),y
.019049	7a		ply				ply
.01904a	c9 00		cmp #$00			cmp 	#0
.01904c	d0 05		bne $019053			bne 	_UHExit 					; if it was non zero okay
.01904e	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019050	20 11 92	jsr $019211			jsr 	WriteTempString
.019053					_UHExit:
.019053	4c 34 91	jmp $019134			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019056					_UHConvert:
.019056	48		pha				pha
.019057	4a		lsr a				lsr 	a 							; do MSB
.019058	4a		lsr a				lsr 	a
.019059	4a		lsr a				lsr 	a
.01905a	4a		lsr a				lsr 	a
.01905b	20 5f 90	jsr $01905f			jsr 	_UHNibble
.01905e	68		pla				pla 								; do LSB
.01905f					_UHNibble:
.01905f	29 0f		and #$0f			and 	#15 						; get nibble
.019061	d0 0c		bne $01906f			bne 	_UHNonZero
.019063	5a		phy				phy									; get the length
.019064	a0 00		ldy #$00			ldy 	#0
.019066	b1 20		lda ($20),y			lda 	(zTempStr),y
.019068	7a		ply				ply
.019069	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.01906b	f0 0d		beq $01907a			beq 	_UHExit2
.01906d	a9 00		lda #$00			lda 	#0
.01906f					_UHNonZero:
.01906f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.019071	90 02		bcc $019075			bcc 	_UHDigit
.019073	69 06		adc #$06			adc 	#7-1
.019075					_UHDigit:
.019075	69 30		adc #$30			adc 	#48
.019077	20 11 92	jsr $019211			jsr 	WriteTempString				; output.
.01907a					_UHExit2:
.01907a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.01907b					Unary_Dec:
.01907b	20 f6 8a	jsr $018af6			jsr 	EvaluateStringX 			; string parameter
.01907e	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.019081	5a		phy				phy
.019082	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019084	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019086	f0 4c		beq $0190d4			beq 	_UDFail 					; must fail if zero.
.019088	8d 90 04	sta $0490			sta 	SignCount 					; use SignCount as a counter
.01908b	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.01908d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019090	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019093	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019096	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019099	a9 01		lda #$01			lda 	#1
.01909b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01909e					_UDConvertLoop:
.01909e	5a		phy				phy 								; shift mantissa left 4
.01909f	a0 04		ldy #$04			ldy 	#4
.0190a1					_UDShift:
.0190a1	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.0190a4	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.0190a7	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.0190aa	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0190ad	88		dey				dey
.0190ae	d0 f1		bne $0190a1			bne 	_UDShift
.0190b0	7a		ply				ply
.0190b1	c8		iny				iny 								; next character
.0190b2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.0190b4	20 d7 90	jsr $0190d7			jsr 	ConvertUpper 				; convert to U/C
.0190b7	c9 30		cmp #$30			cmp 	#"0"
.0190b9	90 19		bcc $0190d4			bcc 	_UDFail
.0190bb	c9 3a		cmp #$3a			cmp 	#"9"+1
.0190bd	90 06		bcc $0190c5			bcc 	_UDOkay
.0190bf	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.0190c1	c9 10		cmp #$10			cmp 	#16
.0190c3	b0 0f		bcs $0190d4			bcs 	_UDFail
.0190c5					_UDOkay:
.0190c5	29 0f		and #$0f			and 	#15 						; nibble only
.0190c7	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.0190ca	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0190cd	ce 90 04	dec $0490			dec 	SignCount 					; do it for each character
.0190d0	d0 cc		bne $01909e			bne 	_UDConvertLoop
.0190d2	7a		ply				ply
.0190d3	60		rts				rts
.0190d4					_UDFail:
.0190d4	4c 1e 84	jmp $01841e			jmp 	BadParamError
.0190d7					ConvertUpper:
.0190d7	c9 61		cmp #$61			cmp 	#"a"
.0190d9	90 07		bcc $0190e2			bcc 	_CUExit
.0190db	c9 7b		cmp #$7b			cmp 	#"z"+1
.0190dd	b0 03		bcs $0190e2			bcs 	_CUExit
.0190df	38		sec				sec
.0190e0	e9 20		sbc #$20			sbc 	#32
.0190e2	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0190e3					Unary_Chr:
.0190e3	20 ed 8a	jsr $018aed			jsr 	EvaluateIntegerX			; numeric parameter
.0190e6	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.0190e9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0190ec	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0190ef	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0190f2	d0 0e		bne $019102			bne 	_UCChar
.0190f4	a9 01		lda #$01			lda 	#1 							; one character string
.0190f6	20 e6 91	jsr $0191e6			jsr 	AllocateTempString
.0190f9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0190fc	20 11 92	jsr $019211			jsr 	WriteTempString
.0190ff	4c 34 91	jmp $019134			jmp 	UnaryReturnTempStr
.019102					_UCChar:
.019102	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019105					Unary_Spc:
.019105	20 ed 8a	jsr $018aed			jsr 	EvaluateIntegerX 			; numeric parameter
.019108	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; right bracket.
.01910b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01910e	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019111	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019114	d0 1b		bne $019131			bne 	_USSize
.019116	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019119	c9 fe		cmp #$fe			cmp 	#maxString+1
.01911b	b0 14		bcs $019131			bcs 	_USSize
.01911d	48		pha				pha 								; save length
.01911e	1a		inc a				inc 	a 							; allocate one more.
.01911f	20 e6 91	jsr $0191e6			jsr 	AllocateTempString
.019122	68		pla				pla 								; get length
.019123	f0 0f		beq $019134			beq 	UnaryReturnTempStr 			; return the current temp string
.019125					_USLoop:
.019125	48		pha				pha
.019126	a9 20		lda #$20			lda 	#" "
.019128	20 11 92	jsr $019211			jsr 	WriteTempString
.01912b	68		pla				pla
.01912c	3a		dec a				dec 	a
.01912d	d0 f6		bne $019125			bne 	_USLoop
.01912f	80 03		bra $019134			bra 	UnaryReturnTempStr
.019131					_USSize:
.019131	4c 1e 84	jmp $01841e			jmp 	BadParamError
.019134					UnaryReturnTempStr:
.019134	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019136	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019139	a5 21		lda $21				lda 	zTempStr+1
.01913b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01913e	a9 02		lda #$02			lda 	#2 							; set type to string
.019140	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019143	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019144					MemRead:
.019144	8d 90 04	sta $0490			sta 	SignCount 					; save count
.019147	a0 00		ldy #$00			ldy 	#0 							; start from here
.019149	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01914b	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.01914e	c8		iny				iny 								; next to copy
.01914f	e8		inx				inx
.019150	cc 90 04	cpy $0490			cpy 	SignCount 					; do required # of bytes.
.019153	d0 f4		bne $019149			bne 	_MLoop1
.019155	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.019156					UpdateProgramEnd:
.019156	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019158	85 16		sta $16				sta 	zCodePtr+0
.01915a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01915c	85 17		sta $17				sta 	zCodePtr+1
.01915e	a9 00		lda #$00			lda 	#0
.019160	85 18		sta $18				sta 	zCodePtr+2
.019162	85 19		sta $19				sta 	zCodePtr+3
.019164	a0 03		ldy #$03			ldy 	#3
.019166					_UPDLoop:
.019166	a0 00		ldy #$00			ldy 	#0
.019168	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01916a	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.01916c	f0 0f		beq $01917d			beq 	_UPDFoundEnd
.01916e	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019170	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019172	18		clc				clc
.019173	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019175	85 16		sta $16				sta 	zCodePtr
.019177	90 02		bcc $01917b			bcc 	_SNLNoCarry
.019179	e6 17		inc $17				inc 	zCodePtr+1
.01917b					_SNLNoCarry:
.01917b	80 e9		bra $019166			bra 	_UPDLoop
.01917d					_UPDFoundEnd:
.01917d	18		clc				clc 								; end of program 2 on.
.01917e	a5 16		lda $16				lda 	zCodePtr
.019180	69 02		adc #$02			adc 	#2
.019182	8d 04 04	sta $0404			sta 	endOfProgram
.019185	a5 17		lda $17				lda 	zCodePtr+1
.019187	69 00		adc #$00			adc 	#0
.019189	8d 05 04	sta $0405			sta 	endOfProgram+1
.01918c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.01918d					CheckNextToken:
.01918d	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.01918f	d0 02		bne $019193			bne 	CTFail 						; no, then fail
.019191	c8		iny				iny
.019192	60		rts				rts
.019193					CTFail:
.019193	20 2f 84	jsr $01842f			jsr ERR_Handler
>019196	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>01919e	74 6f 6b 65 6e 00
.0191a4					CheckNextRParen:
.0191a4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191a6	c9 be		cmp #$be			cmp 	#token_rparen
.0191a8	d0 e9		bne $019193			bne 	CTFail
.0191aa	c8		iny				iny
.0191ab	60		rts				rts
.0191ac					CheckNextComma:
.0191ac	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191ae	c9 bf		cmp #$bf			cmp 	#token_comma
.0191b0	d0 e1		bne $019193			bne 	CTFail
.0191b2	c8		iny				iny
.0191b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0191b4					StringConcrete:
.0191b4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.0191b7	85 10		sta $10				sta 	zTemp1
.0191b9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0191bc	85 11		sta $11				sta 	zTemp1+1
.0191be	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.0191c0	18		clc				clc 								; from the string pointer
.0191c1	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.0191c4	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0191c6	8d 00 04	sta $0400			sta 	StringPtr
.0191c9	85 12		sta $12				sta 	zTemp2
.0191cb	ad 01 04	lda $0401			lda 	StringPtr+1
.0191ce	e9 00		sbc #$00			sbc 	#0
.0191d0	8d 01 04	sta $0401			sta 	StringPtr+1
.0191d3	85 13		sta $13				sta 	zTemp2+1
.0191d5	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0191d7	1a		inc a				inc 	a
.0191d8	aa		tax				tax
.0191d9	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0191db	91 12		sta ($12),y			sta 	(zTemp2),y
.0191dd	c8		iny				iny
.0191de	ca		dex				dex
.0191df	d0 f8		bne $0191d9			bne 	_SCCopy
.0191e1	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0191e3	a6 12		ldx $12				ldx 	zTemp2
.0191e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0191e6					AllocateTempString:
.0191e6	48		pha				pha 								; save required count.
.0191e7	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0191e9	d0 0b		bne $0191f6			bne 	_ATSInitialised
.0191eb	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0191ee	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0191f0	ad 01 04	lda $0401			lda 	StringPtr+1
.0191f3	3a		dec a				dec 	a
.0191f4	85 21		sta $21				sta 	zTempStr+1
.0191f6					_ATSInitialised:
.0191f6	68		pla				pla 								; get required count back.
.0191f7	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0191f9	1a		inc a				inc 	a
.0191fa	18		clc				clc
.0191fb	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0191fd	85 20		sta $20				sta 	zTempStr
.0191ff	a9 ff		lda #$ff			lda 	#$FF
.019201	65 21		adc $21				adc 	zTempStr+1
.019203	85 21		sta $21				sta 	zTempStr+1
.019205	a9 00		lda #$00			lda 	#0 							; clear temp string.
.019207	5a		phy				phy
.019208	a8		tay				tay
.019209	91 20		sta ($20),y			sta 	(zTempStr),y
.01920b	7a		ply				ply
.01920c	1a		inc a				inc 	a 							; reset the write index.
.01920d	8d 91 04	sta $0491			sta 	TempStringWriteIndex
.019210	60		rts				rts
.019211					WriteTempString:
.019211	5a		phy				phy 								; save Y
.019212	ac 91 04	ldy $0491			ldy 	TempStringWriteIndex	 	; write position.
.019215	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019217	ee 91 04	inc $0491			inc 	TempStringWriteIndex 		; increment the write position.
.01921a	98		tya				tya 								; unchanged Y is now length
.01921b	a0 00		ldy #$00			ldy 	#0
.01921d	91 20		sta ($20),y			sta 	(zTempStr),y
.01921f	7a		ply				ply 								; restore Y and exit
.019220	60		rts				rts
.019221					CreateTempStringCopy:
.019221	da		phx				phx 								; save X
.019222	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019224	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019225	20 e6 91	jsr $0191e6			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019228	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01922a	c8		iny				iny
.01922b	3a		dec a				dec 	a 							; make the actual length in charactes
.01922c	3a		dec a				dec 	a
.01922d	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.01922f	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019231	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019233	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019235	f0 0e		beq $019245			beq 	_CTSCExit
.019237					_CTSCLoop:
.019237	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019239	c8		iny				iny
.01923a	5a		phy				phy 								; save in Y
.01923b	e8		inx				inx 								; bump index
.01923c	da		phx				phx 								; index into Y
.01923d	7a		ply				ply
.01923e	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019240	7a		ply				ply 								; restore Y
.019241	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019243	d0 f2		bne $019237			bne 	_CTSCLoop
.019245					_CTSCExit:
.019245	fa		plx				plx 								; restore X
.019246	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019247					VariableFind:
.019247	20 b4 92	jsr $0192b4			jsr 	VariableExtract 		; find out all about it ....
.01924a	20 56 95	jsr $019556			jsr 	VariableLocate 			; does it already exist ?
.01924d	b0 03		bcs $019252			bcs 	_VFExists 				; if so, use that.
.01924f	20 40 93	jsr $019340			jsr 	VariableCreate 			; otherwise create it.
.019252					_VFExists:
.019252	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019254	29 01		and #$01			and 	#1
.019256	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019258	d0 28		bne $019282			bne 	_VFSingleElement
.01925a					_VFNextIndex:
.01925a	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01925c	48		pha				pha
.01925d	a5 23		lda $23				lda 	zVarDataPtr+1
.01925f	48		pha				pha
.019260	a5 24		lda $24				lda 	zVarType
.019262	48		pha				pha
.019263	20 ed 8a	jsr $018aed			jsr 	EvaluateIntegerX 		; calculate the index.
.019266	68		pla				pla 							; restore and index.
.019267	85 24		sta $24				sta 	zVarType
.019269	68		pla				pla
.01926a	85 23		sta $23				sta 	zVarDataPtr+1
.01926c	68		pla				pla
.01926d	85 22		sta $22				sta 	zVarDataPtr
.01926f	20 cb 93	jsr $0193cb			jsr 	ArrayIndexFollow 		; do the index.
.019272	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019274	29 01		and #$01			and 	#1
.019276	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019278	d0 05		bne $01927f			bne 	_VFArrayDone 			; if so then exit.
.01927a	20 ac 91	jsr $0191ac			jsr 	CheckNextComma 			; comma should follow
.01927d	80 db		bra $01925a			bra 	_VFNextIndex
.01927f					_VFArrayDone:
.01927f	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 		; check closing right bracket.
.019282					_VFSingleElement:
.019282	60		rts				rts
.019283					VariableClear:
.019283	48		pha				pha 							; save registers
.019284	da		phx				phx
.019285	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019287	8a		txa				txa
.019288	9d 27 04	sta $0427,x	_VCLoop:sta 	HashTableBase,x
.01928b	e8		inx				inx
.01928c	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01928e	d0 f8		bne $019288			bne 	_VCLoop
.019290	ad 04 04	lda $0404			lda 	endOfProgram
.019293	8d 02 04	sta $0402			sta 	VarMemPtr
.019296	ad 05 04	lda $0405			lda 	endOfProgram+1
.019299	8d 03 04	sta $0403			sta 	VarMemPtr+1
.01929c	fa		plx				plx 							; restore registers
.01929d	68		pla				pla
.01929e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.01929f					VariableNameError:
.01929f	20 2f 84	jsr $01842f			jsr ERR_Handler
>0192a2	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>0192aa	61 62 6c 65 20 4e 61 6d 65 00
.0192b4					VariableExtract:
.0192b4	da		phx				phx 							; save X.
.0192b5	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.0192b7	8d 87 04	sta $0487			sta 	Var_Type
.0192ba	8d 88 04	sta $0488			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.0192bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0192bf	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.0192c1	f0 dc		beq $01929f			beq 	VariableNameError
.0192c3	c9 1b		cmp #$1b			cmp 	#26+1
.0192c5	b0 d8		bcs $01929f			bcs 	VariableNameError
.0192c7	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.0192c9					_VECopyBuffer:
.0192c9	e8		inx				inx
.0192ca	e0 1f		cpx #$1f			cpx 	#31 					; too long
.0192cc	f0 d1		beq $01929f			beq 	VariableNameError
.0192ce	9d 07 04	sta $0407,x			sta 	Var_Buffer,x 			; save character
.0192d1	18		clc				clc  							; update the hash value for it.
.0192d2	6d 88 04	adc $0488			adc 	Var_Hash
.0192d5	8d 88 04	sta $0488			sta 	Var_Hash
.0192d8	c8		iny				iny
.0192d9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0192db	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.0192dd	f0 0e		beq $0192ed			beq 	_VECopyEnd
.0192df	30 0c		bmi $0192ed			bmi 	_VECopyEnd
.0192e1	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0192e3	90 e4		bcc $0192c9			bcc 	_VECopyBuffer
.0192e5	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0192e7	90 04		bcc $0192ed			bcc 	_VECopyEnd
.0192e9	c9 3a		cmp #$3a			cmp 	#"9"+1
.0192eb	90 dc		bcc $0192c9			bcc 	_VECopyBuffer
.0192ed					_VECopyEnd:
.0192ed	c8		iny				iny
.0192ee	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0192f0	90 04		bcc $0192f6			bcc 	_VEDefaultRequired
.0192f2	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.0192f4	90 0b		bcc $019301			bcc 	_VEHaveType
.0192f6					_VEDefaultRequired:
.0192f6	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0192f8	f0 04		beq $0192fe			beq 	_VESetType 				; default set above.
.0192fa	ce 87 04	dec $0487			dec 	Var_Type 				; this changes that default to the variable default
.0192fd	88		dey				dey
.0192fe					_VESetType:
.0192fe	ad 87 04	lda $0487			lda 	Var_Type 				; get type ....
.019301					_VEHaveType:
.019301	8d 87 04	sta $0487			sta 	Var_Type 				; save as type.
.019304	bd 07 04	lda $0407,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019307	09 80		ora #$80			ora 	#$80
.019309	9d 07 04	sta $0407,x			sta 	Var_Buffer,x
.01930c	e8		inx				inx 							; offset 3 => length 4.
.01930d	8e 89 04	stx $0489			stx 	Var_Length 				; save length of variable name.
.019310	ad 87 04	lda $0487			lda 	Var_Type 				; get offset of var type from first type token
.019313	38		sec				sec
.019314	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019316	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019317	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019318	0a		asl a				asl 	a
.019319	0a		asl a				asl 	a
.01931a	8d 8a 04	sta $048a			sta 	Var_HashAddress
.01931d	ad 88 04	lda $0488			lda 	Var_Hash 				; get the hash
.019320	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019322	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019323	6d 8a 04	adc $048a			adc 	Var_HashAddress 		; add table offset.
.019326	69 27		adc #$27			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019328	8d 8a 04	sta $048a			sta 	Var_HashAddress
.01932b	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.01932d	ad 87 04	lda $0487			lda 	Var_Type
.019330	c9 b9		cmp #$b9			cmp 	#token_Hash
.019332	f0 07		beq $01933b			beq 	_VEHaveSize
.019334	ca		dex				dex
.019335	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019337	f0 02		beq $01933b			beq 	_VEHaveSize
.019339	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.01933b					_VEHaveSize:
.01933b	8e 8b 04	stx $048b			stx 	Var_DataSize
.01933e	fa		plx				plx
.01933f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019340					VariableCreate:
.019340	da		phx				phx
.019341	5a		phy				phy
.019342	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.019345	85 10		sta $10				sta 	zTemp1
.019347	ad 03 04	lda $0403			lda 	VarMemPtr+1
.01934a	85 11		sta $11				sta 	zTemp1+1
.01934c	ad 8b 04	lda $048b			lda 	Var_DataSize 				; bytes for the data bit
.01934f	18		clc				clc
.019350	6d 89 04	adc $0489			adc 	Var_Length 					; add the length of the name
.019353	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019355	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.019358	8d 02 04	sta $0402			sta 	VarMemPtr
.01935b	90 03		bcc $019360			bcc 	_VCNoCarry
.01935d	ee 03 04	inc $0403			inc 	VarMemPtr+1
.019360					_VCNoCarry:
.019360	ad 8a 04	lda $048a			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019363	85 12		sta $12				sta 	zTemp2
.019365	a9 04		lda #$04			lda 	#HashTableBase >> 8
.019367	85 13		sta $13				sta 	zTemp2+1
.019369	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.01936b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01936d	91 10		sta ($10),y			sta 	(zTemp1),y
.01936f	c8		iny				iny
.019370	b1 12		lda ($12),y			lda 	(zTemp2),y
.019372	91 10		sta ($10),y			sta 	(zTemp1),y
.019374	c8		iny				iny
.019375	ad 88 04	lda $0488			lda 	Var_Hash 					; write the hash out.
.019378	91 10		sta ($10),y			sta 	(zTemp1),y
.01937a	c8		iny				iny
.01937b	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.01937d					_VCCopyName:
.01937d	bd 07 04	lda $0407,x			lda 	Var_Buffer,x
.019380	91 10		sta ($10),y			sta 	(zTemp1),y
.019382	e8		inx				inx
.019383	c8		iny				iny
.019384	ec 89 04	cpx $0489			cpx 	Var_Length
.019387	d0 f4		bne $01937d			bne 	_VCCopyName
.019389	5a		phy				phy 								; save the data offset.
.01938a	ae 8b 04	ldx $048b			ldx 	Var_DataSize 				; and write the data out.
.01938d	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.01938f					_VCClearData:
.01938f	91 10		sta ($10),y			sta 	(zTemp1),y
.019391	c8		iny				iny
.019392	ca		dex				dex
.019393	d0 fa		bne $01938f			bne 	_VCClearData
.019395	68		pla				pla 								; offset to the data
.019396	18		clc				clc
.019397	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019399	85 22		sta $22				sta 	zVarDataPtr
.01939b	a5 11		lda $11				lda 	zTemp1+1
.01939d	69 00		adc #$00			adc 	#0
.01939f	85 23		sta $23				sta 	zVarDataPtr+1
.0193a1	ad 87 04	lda $0487			lda 	Var_Type 					; and set the type.
.0193a4	85 24		sta $24				sta 	zVarType
.0193a6	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.0193a8	a0 00		ldy #$00			ldy 	#0
.0193aa	91 12		sta ($12),y			sta 	(zTemp2),y
.0193ac	c8		iny				iny
.0193ad	a5 11		lda $11				lda 	zTemp1+1
.0193af	91 12		sta ($12),y			sta 	(zTemp2),y
.0193b1	ad 87 04	lda $0487			lda 	Var_Type 					; array ? if so create the empty one.
.0193b4	29 01		and #$01			and 	#1
.0193b6	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0193b8	d0 0e		bne $0193c8			bne 	_VCNotArray
.0193ba	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.0193bc	20 6b 94	jsr $01946b			jsr 	ArrayCreate
.0193bf	5a		phy				phy 								; save YA at zVarDataPtr
.0193c0	a0 00		ldy #$00			ldy 	#0
.0193c2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193c4	c8		iny				iny
.0193c5	68		pla				pla
.0193c6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193c8					_VCNotArray:
.0193c8	7a		ply				ply
.0193c9	fa		plx				plx
.0193ca	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.0193cb					ArrayIndexFollow:
.0193cb	5a		phy				phy
.0193cc	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.0193ce	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.0193d0	48		pha				pha
.0193d1	c8		iny				iny
.0193d2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0193d4	85 23		sta $23				sta 	zVarDataPtr+1
.0193d6	68		pla				pla
.0193d7	85 22		sta $22				sta 	zVarDataPtr
.0193d9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.0193dc	29 80		and #$80			and 	#$80 						; must be zero.
.0193de	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0193e1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0193e4	d0 5f		bne $019445			bne 	_AIFError
.0193e6	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.0193e8	18		clc				clc
.0193e9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0193eb	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.0193ee	c8		iny				iny
.0193ef	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0193f1	08		php				php 								; clear bit 7 retaining borrow.
.0193f2	29 7f		and #$7f			and 	#$7F
.0193f4	28		plp				plp
.0193f5	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0193f8	90 4b		bcc $019445			bcc 	_AIFError 					; eror if size-current < 0
.0193fa	bd 08 03	lda $0308,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.0193fd	0a		asl a				asl 	a 							; (e.g. index * 2)
.0193fe	85 10		sta $10				sta 	zTemp1
.019400	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019403	2a		rol a				rol 	a
.019404	85 11		sta $11				sta 	zTemp1+1
.019406	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019408	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.01940a	30 1f		bmi $01942b			bmi 	_AIFCalculate
.01940c	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.01940e	a5 24		lda $24				lda 	zVarType 					; check that type
.019410	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019412	f0 17		beq $01942b			beq 	_AIFCalculate
.019414	06 10		asl $10				asl 	zTemp1			 			; double the index
.019416	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019418	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.01941a	f0 0f		beq $01942b			beq 	_AIFCalculate
.01941c	18		clc				clc 								; add the original mantissa in again
.01941d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019420	65 10		adc $10				adc 	zTemp1
.019422	85 10		sta $10				sta 	zTemp1
.019424	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019427	65 11		adc $11				adc 	zTemp1+1
.019429	85 11		sta $11				sta 	zTemp1+1
.01942b					_AIFCalculate:
.01942b	18		clc				clc 								; add index x 2,4 or 5 to base
.01942c	a5 22		lda $22				lda 	zVarDataPtr
.01942e	65 10		adc $10				adc 	zTemp1
.019430	85 22		sta $22				sta 	zVarDataPtr
.019432	a5 23		lda $23				lda 	zVarDataPtr+1
.019434	65 11		adc $11				adc 	zTemp1+1
.019436	85 23		sta $23				sta 	zVarDataPtr+1
.019438	18		clc				clc 								; add 2 more for the length prefix.
.019439	a5 22		lda $22				lda 	zVarDataPtr
.01943b	69 02		adc #$02			adc 	#2
.01943d	85 22		sta $22				sta 	zVarDataPtr
.01943f	90 02		bcc $019443			bcc 	_AIFNoBump
.019441	e6 23		inc $23				inc 	zVarDataPtr+1
.019443					_AIFNoBump:
.019443	7a		ply				ply
.019444	60		rts				rts
.019445					_AIFError:
.019445	20 2f 84	jsr $01842f			jsr ERR_Handler
>019448	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019450	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019458					ArrayResetDefault:
.019458	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.01945a	8d 99 04	sta $0499			sta 	ArrayDef+0
.01945d	a9 00		lda #$00			lda 	#0
.01945f	8d 9a 04	sta $049a			sta 	ArrayDef+1
.019462	a9 ff		lda #$ff			lda 	#$FF
.019464	8d 9b 04	sta $049b			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019467	8d 9c 04	sta $049c			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.01946a	60		rts				rts
.01946b					ArrayCreate:
.01946b	bd 99 04	lda $0499,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.01946e	0a		asl a				asl 	a
.01946f	85 10		sta $10				sta 	zTemp1
.019471	bd 9a 04	lda $049a,x			lda 	ArrayDef+1,x
.019474	2a		rol a				rol 	a
.019475	85 11		sta $11				sta 	zTemp1+1
.019477	bd 9c 04	lda $049c,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.01947a	10 22		bpl $01949e			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.01947c	ad 87 04	lda $0487			lda 	Var_Type 					; check the type
.01947f	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019481	f0 1b		beq $01949e			beq 	_ACSized
.019483	06 10		asl $10				asl 	zTemp1 						; double again
.019485	26 11		rol $11				rol 	zTemp1+1
.019487	b0 6f		bcs $0194f8			bcs 	ArrayIndexError 			; too large.
.019489	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.01948b	f0 11		beq $01949e			beq 	_ACSized
.01948d	18		clc				clc 								; add original value x 5 for reals.
.01948e	a5 10		lda $10				lda 	zTemp1
.019490	7d 99 04	adc $0499,x			adc 	ArrayDef+0,x
.019493	85 10		sta $10				sta 	zTemp1
.019495	a5 11		lda $11				lda 	zTemp1+1
.019497	7d 9a 04	adc $049a,x			adc 	ArrayDef+1,x
.01949a	85 11		sta $11				sta 	zTemp1+1
.01949c	b0 5a		bcs $0194f8			bcs 	ArrayIndexError
.01949e					_ACSized:
.01949e	18		clc				clc
.01949f	a5 10		lda $10				lda 	zTemp1
.0194a1	69 02		adc #$02			adc 	#2
.0194a3	85 10		sta $10				sta 	zTemp1
.0194a5	90 04		bcc $0194ab			bcc 	_ACNoBump
.0194a7	e6 10		inc $10				inc 	zTemp1
.0194a9	f0 4d		beq $0194f8			beq 	ArrayIndexError
.0194ab					_ACNoBump:
.0194ab	18		clc				clc
.0194ac	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.0194af	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.0194b1	85 14		sta $14				sta 	zTemp3
.0194b3	65 10		adc $10				adc 	zTemp1
.0194b5	8d 02 04	sta $0402			sta 	VarMemPtr
.0194b8	ad 03 04	lda $0403			lda 	VarMemPtr+1
.0194bb	85 13		sta $13				sta 	zTemp2+1
.0194bd	85 15		sta $15				sta 	zTemp3+1
.0194bf	65 11		adc $11				adc 	zTemp1+1
.0194c1	8d 03 04	sta $0403			sta 	VarMemPtr+1
.0194c4	85 11		sta $11				sta 	zTemp1+1
.0194c6	b0 30		bcs $0194f8			bcs 	ArrayIndexError
.0194c8	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.0194ca					_ACClear:
.0194ca	98		tya				tya
.0194cb	91 12		sta ($12),y			sta 	(zTemp2),y
.0194cd	e6 12		inc $12				inc 	zTemp2
.0194cf	d0 02		bne $0194d3			bne 	_ACCBump
.0194d1	e6 13		inc $13				inc 	zTemp2+1
.0194d3					_ACCBump:
.0194d3	a5 12		lda $12				lda 	zTemp2
.0194d5	cd 02 04	cmp $0402			cmp 	VarMemPtr
.0194d8	d0 f0		bne $0194ca			bne 	_ACClear
.0194da	a5 13		lda $13				lda 	zTemp2+1
.0194dc	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.0194df	d0 e9		bne $0194ca			bne 	_ACClear
.0194e1	a0 00		ldy #$00			ldy 	#0
.0194e3	bd 99 04	lda $0499,x			lda 	ArrayDef+0,x 				; copy the size into the start
.0194e6	91 14		sta ($14),y			sta 	(zTemp3),y
.0194e8	c8		iny				iny
.0194e9	bd 9a 04	lda $049a,x			lda 	ArrayDef+1,x
.0194ec	91 14		sta ($14),y			sta 	(zTemp3),y
.0194ee	bd 9c 04	lda $049c,x			lda 	ArrayDef+3,x 				; have we reached the end
.0194f1	10 18		bpl $01950b			bpl 	ACCFillRecursive
.0194f3	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.0194f5	a5 14		lda $14				lda 	zTemp3
.0194f7	60		rts				rts
.0194f8					ArrayIndexError:
.0194f8	20 2f 84	jsr $01842f			jsr ERR_Handler
>0194fb	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019503	79 20 69 6e 64 65 78 00
.01950b					ACCFillRecursive:
.01950b	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.01950d	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.01950f	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019511	c8		iny				iny
.019512	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019514	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019516	91 14		sta ($14),y			sta 	(zTemp3),y
.019518	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.01951a	48		pha				pha
.01951b	a5 15		lda $15				lda 	zTemp3+1
.01951d	48		pha				pha
.01951e					_ACCFillLoop:
.01951e	18		clc				clc
.01951f	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019521	69 02		adc #$02			adc 	#2
.019523	85 14		sta $14				sta 	zTemp3
.019525	90 02		bcc $019529			bcc 	_ACCSkip2
.019527	e6 14		inc $14				inc 	zTemp3
.019529					_ACCSkip2:
.019529	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.01952b	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.01952d	c8		iny				iny
.01952e	11 14		ora ($14),y			ora 	(zTemp3),y
.019530	d0 21		bne $019553			bne 	_ACCExit
.019532	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019534	48		pha				pha
.019535	a5 15		lda $15				lda 	zTemp3+1
.019537	48		pha				pha
.019538	e8		inx				inx
.019539	e8		inx				inx
.01953a	20 6b 94	jsr $01946b			jsr 	ArrayCreate 				; create array recursively.
.01953d	ca		dex				dex
.01953e	ca		dex				dex
.01953f	85 12		sta $12				sta 	zTemp2 						; save A
.019541	68		pla				pla
.019542	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019544	68		pla				pla
.019545	85 14		sta $14				sta 	zTemp3
.019547	98		tya				tya 								; write high bye from Y
.019548	a0 01		ldy #$01			ldy 	#1
.01954a	91 14		sta ($14),y			sta 	(zTemp3),y
.01954c	88		dey				dey 								; write low byte out.
.01954d	a5 12		lda $12				lda 	zTemp2
.01954f	91 14		sta ($14),y			sta 	(zTemp3),y
.019551	80 cb		bra $01951e			bra 	_ACCFillLoop 				; and try again.
.019553					_ACCExit:
.019553	7a		ply				ply 								; restore the original address
.019554	68		pla				pla
.019555	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019556					VariableLocate:
.019556	da		phx				phx
.019557	5a		phy				phy
.019558	ad 8a 04	lda $048a			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01955b	85 12		sta $12				sta 	zTemp2 						; points to first address.
.01955d	a9 04		lda #$04			lda 	#HashTableBase >> 8
.01955f	85 13		sta $13				sta 	zTemp2+1
.019561	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019563	b1 12		lda ($12),y			lda 	(zTemp2),y
.019565	aa		tax				tax
.019566	c8		iny				iny
.019567	b1 12		lda ($12),y			lda 	(zTemp2),y
.019569	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01956b	86 12		stx $12				stx 	zTemp2
.01956d	05 12		ora $12				ora 	zTemp2 						; got zero
.01956f	18		clc				clc
.019570	f0 25		beq $019597			beq 	_VLExit 					; if so, then fail as end of chain.
.019572	c8		iny				iny 								; point to hash (offset + 2)
.019573	b1 12		lda ($12),y			lda 	(zTemp2),y
.019575	cd 88 04	cmp $0488			cmp 	Var_Hash
.019578	d0 e7		bne $019561			bne 	_VLNext 					; try next if different.
.01957a					_VLCompare:
.01957a	c8		iny				iny 								; next character
.01957b	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.01957d	d9 04 04	cmp $0404,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019580	d0 df		bne $019561			bne 	_VLNext 					; fail if different, try next.
.019582	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019583	90 f5		bcc $01957a			bcc 	_VLCompare
.019585	98		tya				tya
.019586	38		sec				sec 								; add 1 as Y points to last character
.019587	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019589	85 22		sta $22				sta 	zVarDataPtr
.01958b	a5 13		lda $13				lda 	zTemp2+1
.01958d	69 00		adc #$00			adc 	#0
.01958f	85 23		sta $23				sta 	zVarDataPtr+1
.019591	ad 87 04	lda $0487			lda 	Var_Type 					; and set the type.
.019594	85 24		sta $24				sta 	zVarType
.019596	38		sec				sec 								; return CS
.019597	7a		ply		_VLExit:ply
.019598	fa		plx				plx
.019599	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01959a					VariableGet:
.01959a	5a		phy				phy
.01959b	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01959d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01959f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0195a2	c8		iny				iny
.0195a3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0195a5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0195a8	c8		iny				iny
.0195a9	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.0195ab	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0195ad	f0 34		beq $0195e3			beq 	_VGString
.0195af	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.0195b1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0195b4	c8		iny				iny
.0195b5	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0195b7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0195ba	c8		iny				iny
.0195bb	a9 01		lda #$01			lda 	#1 							; set type to 1.
.0195bd	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195c0	a5 24		lda $24				lda 	zVarType
.0195c2	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.0195c4	f0 31		beq $0195f7			beq 	_VGExit
.0195c6	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.0195c8	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.0195cb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.0195cd	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0195d0	f0 25		beq $0195f7			beq 	_VGExit 					; if exponent is zero ... it's zero.
.0195d2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.0195d5	48		pha				pha
.0195d6	29 80		and #$80			and 	#$80
.0195d8	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.0195db	68		pla				pla
.0195dc	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.0195de	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.0195e1	80 14		bra $0195f7			bra 	_VGExit
.0195e3					_VGString:
.0195e3	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.0195e5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195e8	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.0195eb	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0195ee	d0 07		bne $0195f7			bne 	_VGExit 					; if not, exit.
.0195f0	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.0195f2	a9 25		lda #$25			lda 	#zNullString
.0195f4	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.0195f7					_VGExit:
.0195f7	7a		ply				ply
.0195f8	60		rts				rts
.0195f9					VariableSet:
.0195f9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.0195fc	29 02		and #$02			and 	#2 							; if so, it has to be
.0195fe	d0 53		bne $019653			bne 	_VSString
.019600	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019602	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019604	f0 4a		beq $019650			beq 	_VSBadType
.019606	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019608	f0 05		beq $01960f			beq 	_VSMakeInt
.01960a	20 05 9c	jsr $019c05			jsr 	FPUToFloat
.01960d	80 03		bra $019612			bra 	_VSCopy
.01960f					_VSMakeInt:
.01960f	20 64 9c	jsr $019c64			jsr 	FPUToInteger
.019612					_VSCopy:
.019612	5a		phy				phy
.019613	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019615	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019618	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01961a	c8		iny				iny
.01961b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01961e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019620	c8		iny				iny
.019621	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019624	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019626	c8		iny				iny
.019627	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01962a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01962c	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.01962e	c9 bb		cmp #$bb			cmp 	#token_Percent
.019630	f0 1c		beq $01964e			beq 	_VSExit
.019632	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019635	0a		asl a				asl 	a
.019636	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019639	08		php				php
.01963a	0a		asl a				asl 	a
.01963b	28		plp				plp
.01963c	6a		ror a				ror 	a
.01963d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01963f	c8		iny				iny
.019640	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.019643	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019645	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.019648	50 04		bvc $01964e			bvc 	_VSExit
.01964a	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.01964c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01964e					_VSExit:
.01964e	7a		ply				ply
.01964f	60		rts				rts
.019650					_VSBadType:
.019650	4c 10 84	jmp $018410			jmp 	TypeError
.019653					_VSString:
.019653	a5 24		lda $24				lda 	zVarType 					; type must be $
.019655	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019657	d0 f7		bne $019650			bne 	_VSBadType
.019659	da		phx				phx
.01965a	5a		phy				phy
.01965b	20 b4 91	jsr $0191b4			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01965e	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019660	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019662	88		dey				dey 								; save low byte
.019663	8a		txa				txa
.019664	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019666	7a		ply				ply 								; and exit.
.019667	fa		plx				plx
.019668	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019669					MulInteger32:
.019669	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01966c	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.01966f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019672	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.019675	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019678	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.01967b	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01967e	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.019681	a9 00		lda #$00			lda 	#0
.019683	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.019686	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019689	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01968c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01968f					_BFMMultiply:
.01968f	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019692	29 01		and #$01			and 	#1
.019694	f0 03		beq $019699			beq 	_BFMNoAdd
.019696	20 d2 8c	jsr $018cd2			jsr 	AddInteger32
.019699					_BFMNoAdd:
.019699	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01969c	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.01969f	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.0196a2	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.0196a5	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.0196a8	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.0196ab	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.0196ae	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.0196b1	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.0196b4	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.0196b7	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.0196ba	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.0196bd	d0 d0		bne $01968f			bne 	_BFMMultiply
.0196bf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.0196c0					DivInteger32:
.0196c0	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.0196c3	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.0196c6	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.0196c9	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.0196cc	d0 14		bne $0196e2			bne 	_BFDOkay
.0196ce	20 2f 84	jsr $01842f			jsr ERR_Handler
>0196d1	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>0196d9	20 62 79 20 5a 65 72 6f 00
.0196e2					_BFDOkay:
.0196e2	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.0196e4	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.0196e6	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.0196e8	85 1c		sta $1c				sta 	zLTemp1+2
.0196ea	85 1d		sta $1d				sta 	zLTemp1+3
.0196ec	8d 90 04	sta $0490			sta 	SignCount 					; Count of signs.
.0196ef	20 50 97	jsr $019750			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.0196f2	da		phx				phx
.0196f3	e8		inx				inx
.0196f4	e8		inx				inx
.0196f5	e8		inx				inx
.0196f6	e8		inx				inx
.0196f7	e8		inx				inx
.0196f8	e8		inx				inx
.0196f9	20 50 97	jsr $019750			jsr 	CheckIntegerNegate
.0196fc	fa		plx				plx
.0196fd	5a		phy				phy 								; Y is the counter
.0196fe	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019700					_BFDLoop:
.019700	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019703	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019706	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019709	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.01970c	26 1a		rol $1a				rol 	zLTemp1
.01970e	26 1b		rol $1b				rol 	zLTemp1+1
.019710	26 1c		rol $1c				rol 	zLTemp1+2
.019712	26 1d		rol $1d				rol 	zLTemp1+3
.019714	38		sec				sec
.019715	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019717	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.01971a	48		pha				pha
.01971b	a5 1b		lda $1b				lda 	zLTemp1+1
.01971d	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019720	48		pha				pha
.019721	a5 1c		lda $1c				lda 	zLTemp1+2
.019723	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019726	48		pha				pha
.019727	a5 1d		lda $1d				lda 	zLTemp1+3
.019729	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01972c	90 15		bcc $019743			bcc 	_BFDNoAdd
.01972e	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019730	68		pla				pla
.019731	85 1c		sta $1c				sta 	zLTemp1+2
.019733	68		pla				pla
.019734	85 1b		sta $1b				sta 	zLTemp1+1
.019736	68		pla				pla
.019737	85 1a		sta $1a				sta 	zLTemp1+0
.019739	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01973c	09 01		ora #$01			ora 	#1
.01973e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019741	80 03		bra $019746			bra 	_BFDNext
.019743					_BFDNoAdd:
.019743	68		pla				pla 								; Throw away the intermediate calculations
.019744	68		pla				pla
.019745	68		pla				pla
.019746					_BFDNext:
.019746	88		dey				dey
.019747	d0 b7		bne $019700			bne 	_BFDLoop
.019749	7a		ply				ply 								; restore Y and exit
.01974a	4e 90 04	lsr $0490			lsr 	SignCount 					; if sign count odd,
.01974d	b0 07		bcs $019756			bcs		IntegerNegateAlways 			; negate the result
.01974f	60		rts				rts
.019750					CheckIntegerNegate:
.019750	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019753	30 01		bmi $019756			bmi 	IntegerNegateAlways
.019755	60		rts				rts
.019756					IntegerNegateAlways:
.019756	ee 90 04	inc $0490			inc 	SignCount
.019759	38		sec				sec
.01975a	a9 00		lda #$00			lda 	#0
.01975c	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.01975f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019762	a9 00		lda #$00			lda 	#0
.019764	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019767	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01976a	a9 00		lda #$00			lda 	#0
.01976c	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.01976f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019772	a9 00		lda #$00			lda 	#0
.019774	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019777	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01977a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01977b					INTToString:
.01977b	48		pha				pha
.01977c	5a		phy				phy
.01977d	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.019780	10 08		bpl $01978a			bpl 		_ITSNotMinus
.019782	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019784	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter
.019787	20 56 97	jsr $019756			jsr 		IntegerNegateAlways 	; negate the number.
.01978a					_ITSNotMinus:
.01978a	a9 00		lda #$00			lda 		#0
.01978c	8d 8c 04	sta $048c			sta 		NumSuppress 			; clear the suppression flag.
.01978f	8a		txa				txa 								; use Y for the mantissa index.
.019790	a8		tay				tay
.019791	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019793					_ITSNextSubtractor:
.019793	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019795	8d 8d 04	sta $048d			sta 		NumConvCount
.019798					_ITSSubtract:
.019798	38		sec				sec
.019799	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01979c	ff fb 97 01	sbc $0197fb,x			sbc 		_ITSSubtractors+0,x
.0197a0	48		pha				pha
.0197a1	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.0197a4	ff fc 97 01	sbc $0197fc,x			sbc 		_ITSSubtractors+1,x
.0197a8	48		pha				pha
.0197a9	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.0197ac	ff fd 97 01	sbc $0197fd,x			sbc 		_ITSSubtractors+2,x
.0197b0	48		pha				pha
.0197b1	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.0197b4	ff fe 97 01	sbc $0197fe,x			sbc 		_ITSSubtractors+3,x
.0197b8	90 14		bcc $0197ce			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.0197ba	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.0197bd	68		pla				pla
.0197be	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.0197c1	68		pla				pla
.0197c2	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.0197c5	68		pla				pla
.0197c6	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.0197c9	ee 8d 04	inc $048d			inc 		NumConvCount 			; bump count.
.0197cc	80 ca		bra $019798			bra 		_ITSSubtract 			; go round again.
.0197ce					_ITSCantSubtract:
.0197ce	68		pla				pla 								; throw away interim answers
.0197cf	68		pla				pla
.0197d0	68		pla				pla
.0197d1	ad 8d 04	lda $048d			lda 		NumConvCount 			; if not zero then no suppression check
.0197d4	c9 30		cmp #$30			cmp 		#"0"
.0197d6	d0 05		bne $0197dd			bne 		_ITSOutputDigit
.0197d8	ad 8c 04	lda $048c			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.0197db	10 09		bpl $0197e6			bpl	 		_ITSGoNextSubtractor
.0197dd					_ITSOutputDigit:
.0197dd	ce 8c 04	dec $048c			dec 		NumSuppress 			; suppression check will be non-zero.
.0197e0	ad 8d 04	lda $048d			lda 		NumConvCount 			; count of subtractions
.0197e3	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter 		; output it.
.0197e6					_ITSGoNextSubtractor:
.0197e6	e8		inx				inx 								; next dword
.0197e7	e8		inx				inx
.0197e8	e8		inx				inx
.0197e9	e8		inx				inx
.0197ea	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.0197ec	d0 a5		bne $019793			bne 		_ITSNextSubtractor 		; do all the subtractors.
.0197ee	98		tya				tya 								; X is back as the mantissa index
.0197ef	aa		tax				tax
.0197f0	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.0197f3	09 30		ora #$30			ora 		#"0"
.0197f5	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter
.0197f8	7a		ply				ply 								; and exit
.0197f9	68		pla				pla
.0197fa	60		rts				rts
.0197fb					_ITSSubtractors:
>0197fb	00 ca 9a 3b					.dword 		1000000000
>0197ff	00 e1 f5 05					.dword 		100000000
>019803	80 96 98 00					.dword 		10000000
>019807	40 42 0f 00					.dword 		1000000
>01980b	a0 86 01 00					.dword 		100000
>01980f	10 27 00 00					.dword 		10000
>019813	e8 03 00 00					.dword 		1000
>019817	64 00 00 00					.dword 		100
>01981b	0a 00 00 00					.dword 		10
.01981f					_ITSSubtractorsEnd:
.01981f					ITSOutputCharacter:
.01981f	48		pha				pha
.019820	da		phx				phx
.019821	ae 06 04	ldx $0406			ldx 	NumBufX 					; save digit
.019824	9d 07 04	sta $0407,x			sta 	Num_Buffer,x
.019827	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019829	9d 08 04	sta $0408,x			sta 	Num_Buffer+1,x
.01982c	ee 06 04	inc $0406			inc 	NumBufX						; bump pointer.
.01982f	fa		plx				plx
.019830	68		pla				pla
.019831	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019832					IntFromString:
.019832	a0 00		ldy #$00			ldy 	#0
.019834	8c 8e 04	sty $048e			sty 	ExpTemp 					; this is the converted digit count.
.019837					IntFromStringY:
.019837	48		pha				pha
.019838	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01983a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01983d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019840	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019843	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019846	a9 01		lda #$01			lda 	#1
.019848	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01984b					_IFSLoop:
.01984b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.01984d	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01984f	90 60		bcc $0198b1			bcc 	_IFSExit
.019851	c9 3a		cmp #$3a			cmp 	#"9"+1
.019853	b0 5c		bcs $0198b1			bcs 	_IFSExit
.019855	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019858	c9 0c		cmp #$0c			cmp 	#12
.01985a	b0 5f		bcs $0198bb			bcs 	_IFSOverflow
.01985c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01985f	48		pha				pha
.019860	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019863	48		pha				pha
.019864	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019867	48		pha				pha
.019868	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01986b	48		pha				pha
.01986c	20 d0 98	jsr $0198d0			jsr 	IFSX1ShiftLeft 				; double
.01986f	20 d0 98	jsr $0198d0			jsr 	IFSX1ShiftLeft 				; x 4
.019872	18		clc				clc 								; add saved value x 5
.019873	68		pla				pla
.019874	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019877	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01987a	68		pla				pla
.01987b	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.01987e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019881	68		pla				pla
.019882	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.019885	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019888	68		pla				pla
.019889	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.01988c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01988f	20 d0 98	jsr $0198d0			jsr 	IFSX1ShiftLeft 				; x 10
.019892	ee 8e 04	inc $048e			inc 	ExpTemp 					; bump count of digits processed.
.019895	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019897	29 0f		and #$0f			and 	#15
.019899	c8		iny				iny
.01989a	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.01989d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0198a0	90 a9		bcc $01984b			bcc 	_IFSLoop
.0198a2	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.0198a5	d0 a4		bne $01984b			bne 	_IFSLoop
.0198a7	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.0198aa	d0 9f		bne $01984b			bne 	_IFSLoop
.0198ac	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.0198af	80 9a		bra $01984b			bra 	_IFSLoop
.0198b1					_IFSExit:
.0198b1	98		tya				tya 								; get offset
.0198b2					_IFSOkay:
.0198b2	38		sec				sec
.0198b3	ad 8e 04	lda $048e			lda 	ExpTemp
.0198b6	f0 01		beq $0198b9			beq 	_IFSSkipFail
.0198b8	18		clc				clc
.0198b9					_IFSSkipFail:
.0198b9	68		pla				pla 								; and exit.
.0198ba	60		rts				rts
.0198bb					_IFSOverflow:
.0198bb	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>0198be	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>0198c6	20 6f 76 65 72 66 6c 6f 77 00
.0198d0					IFSX1ShiftLeft:
.0198d0	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.0198d3	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.0198d6	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.0198d9	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0198dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.0198dd					FPSubtract:
.0198dd	48		pha				pha
.0198de	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.0198e1	49 80		eor #$80			eor 	#$80
.0198e3	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0198e6	68		pla				pla 								; --- and fall through ---
.0198e7					FPAdd:
.0198e7	48		pha				pha
.0198e8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.0198eb	d0 05		bne $0198f2			bne 	_FPA_NegativeLHS
.0198ed	20 0f 99	jsr $01990f			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.0198f0	68		pla				pla
.0198f1	60		rts				rts
.0198f2					_FPA_NegativeLHS:
.0198f2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.0198f5	49 80		eor #$80			eor 	#$80
.0198f7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0198fa	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.0198fd	49 80		eor #$80			eor 	#$80
.0198ff	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019902	20 0f 99	jsr $01990f			jsr 	FPAdd_Worker 				; do the add calculation.
.019905	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.019908	49 80		eor #$80			eor 	#$80
.01990a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01990d	68		pla				pla
.01990e	60		rts				rts
.01990f					FPAdd_Worker:
.01990f	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019912	70 08		bvs $01991c			bvs 	_FPAWExit 					; no change.
.019914	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019917	50 07		bvc $019920			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019919	20 b4 9b	jsr $019bb4			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01991c					_FPAWExit:
.01991c	20 3c 9c	jsr $019c3c			jsr 	FPUNormalise 				; normalise the result.
.01991f	60		rts				rts
.019920					_FPAWMakeSame:
.019920	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019923	38		sec				sec
.019924	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019927	f0 1b		beq $019944			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019929	da		phx				phx 								; save X
.01992a	90 06		bcc $019932			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01992c	e8		inx				inx
.01992d	e8		inx				inx
.01992e	e8		inx				inx
.01992f	e8		inx				inx
.019930	e8		inx				inx
.019931	e8		inx				inx
.019932					_FPAWShiftA:
.019932	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019935	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019938	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01993b	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01993e	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019941	fa		plx				plx 								; restore original X
.019942	80 dc		bra $019920			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019944					_FPAW_DoArithmetic:
.019944	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019947	30 39		bmi $019982			bmi 	_FPAW_BNegative
.019949	18		clc				clc
.01994a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01994d	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019950	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019953	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019956	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019959	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01995c	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01995f	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019962	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019965	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019968	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.01996b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01996e	90 ac		bcc $01991c			bcc 	_FPAWExit 					; no carry.
.019970	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019973	38		sec				sec
.019974	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019977	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01997a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01997d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019980	80 9a		bra $01991c			bra 	_FPAWExit
.019982					_FPAW_BNegative:
.019982	38		sec				sec
.019983	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019986	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.019989	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01998c	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01998f	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019992	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019995	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019998	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.01999b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01999e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0199a1	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0199a4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0199a7	b0 0b		bcs $0199b4			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.0199a9	20 e1 9b	jsr $019be1			jsr 	FPUNegateInteger			; negate the mantissa
.0199ac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.0199af	49 80		eor #$80			eor 	#$80
.0199b1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0199b4					_FPAWGoExit:
.0199b4	4c 1c 99	jmp $01991c			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.0199b7					FPD_IsDivZero:
.0199b7	20 2f 84	jsr $01842f			jsr ERR_Handler
>0199ba	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>0199c2	20 62 79 20 7a 65 72 6f 00
.0199cb					FPDivide:
.0199cb	48		pha				pha
.0199cc	5a		phy				phy
.0199cd	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.0199d0	70 e5		bvs $0199b7			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.0199d2	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.0199d5	f0 03		beq $0199da			beq 	_FPDCalculateExp
.0199d7					_FPD_Exit:
.0199d7	7a		ply				ply
.0199d8	68		pla				pla
.0199d9	60		rts				rts
.0199da					_FPDCalculateExp:
.0199da	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.0199dd	49 ff		eor #$ff			eor 	#$FF
.0199df	1a		inc a				inc 	a
.0199e0	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.0199e3	20 d7 9a	jsr $019ad7			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.0199e6	18		clc				clc 	 							; add 1 to the resulting exponent
.0199e7	69 01		adc #$01			adc 	#1
.0199e9	b0 65		bcs $019a50			bcs 	_FPD_Overflow 				; which can overflow.
.0199eb	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0199ee	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.0199f0	85 1a		sta $1a				sta 	zLTemp1+0
.0199f2	85 1b		sta $1b				sta 	zLTemp1+1
.0199f4	85 1c		sta $1c				sta 	zLTemp1+2
.0199f6	85 1d		sta $1d				sta 	zLTemp1+3
.0199f8	a0 20		ldy #$20			ldy 	#32 						; times round.
.0199fa					_FPD_Loop:
.0199fa	38		sec				sec 								; calculate X1-X2 stacking result because we might
.0199fb	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.0199fe	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.019a01	48		pha				pha
.019a02	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019a05	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019a08	48		pha				pha
.019a09	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019a0c	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019a0f	48		pha				pha
.019a10	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019a13	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019a16	90 17		bcc $019a2f			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019a18	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019a1b	68		pla				pla
.019a1c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019a1f	68		pla				pla
.019a20	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019a23	68		pla				pla
.019a24	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019a27	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019a29	09 80		ora #$80			ora 	#$80
.019a2b	85 1d		sta $1d				sta 	zLTemp1+3
.019a2d	80 03		bra $019a32			bra 	_FPD_Rotates
.019a2f					_FPD_NoSubtract:
.019a2f	68		pla				pla 								; throw away unwanted results
.019a30	68		pla				pla
.019a31	68		pla				pla
.019a32					_FPD_Rotates:
.019a32	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.019a35	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.019a38	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.019a3b	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.019a3e	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019a40	26 1b		rol $1b				rol 	zLTemp1+1
.019a42	26 1c		rol $1c				rol 	zLTemp1+2
.019a44	26 1d		rol $1d				rol 	zLTemp1+3
.019a46	90 02		bcc $019a4a			bcc 	_FPD_NoCarry
.019a48	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019a4a					_FPD_NoCarry:
.019a4a	88		dey				dey 								; do 32 times
.019a4b	d0 ad		bne $0199fa			bne 	_FPD_Loop
.019a4d	4c b4 9a	jmp $019ab4			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019a50					_FPD_Overflow:
.019a50	4c b1 9c	jmp $019cb1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019a53					FPMultiply:
.019a53	48		pha				pha
.019a54	5a		phy				phy
.019a55	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019a58	70 08		bvs $019a62			bvs 	_FPM_Exit
.019a5a	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019a5d	50 06		bvc $019a65			bvc 	_FPM_CalcExponent
.019a5f	20 b4 9b	jsr $019bb4			jsr 	FPUCopyX2ToX1
.019a62					_FPM_Exit:
.019a62	7a		ply				ply
.019a63	68		pla				pla
.019a64	60		rts				rts
.019a65					_FPM_CalcExponent:
.019a65	18		clc				clc
.019a66	20 d7 9a	jsr $019ad7			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019a69	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.019a6c	a9 00		lda #$00			lda 	#0
.019a6e	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019a70	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019a72	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019a74	85 1d		sta $1d				sta 	zLTemp1+3
.019a76	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019a78					_FPM_Loop:
.019a78	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019a7b	29 01		and #$01			and 	#1
.019a7d	18		clc				clc 								; clear carry for the long rotate.
.019a7e	f0 1d		beq $019a9d			beq 	_FPM_NoAddition
.019a80	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019a81	a5 1a		lda $1a				lda 	zLTemp1+0
.019a83	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019a86	85 1a		sta $1a				sta 	zLTemp1+0
.019a88	a5 1b		lda $1b				lda 	zLTemp1+1
.019a8a	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019a8d	85 1b		sta $1b				sta 	zLTemp1+1
.019a8f	a5 1c		lda $1c				lda 	zLTemp1+2
.019a91	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019a94	85 1c		sta $1c				sta 	zLTemp1+2
.019a96	a5 1d		lda $1d				lda 	zLTemp1+3
.019a98	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019a9b	85 1d		sta $1d				sta 	zLTemp1+3
.019a9d					_FPM_NoAddition:
.019a9d	66 1d		ror $1d				ror 	3+zLTemp1
.019a9f	66 1c		ror $1c				ror 	2+zLTemp1
.019aa1	66 1b		ror $1b				ror 	1+zLTemp1
.019aa3	66 1a		ror $1a				ror 	0+zLTemp1
.019aa5	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019aa8	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019aab	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019aae	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019ab1	88		dey				dey
.019ab2	d0 c4		bne $019a78			bne 	_FPM_Loop 					; do this 32 times.
.019ab4					FPM_CopySignNormalize:
.019ab4	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019ab6	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019ab9	a5 1b		lda $1b				lda 	zLTemp1+1
.019abb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019abe	a5 1c		lda $1c				lda 	zLTemp1+2
.019ac0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019ac3	a5 1d		lda $1d				lda 	zLTemp1+3
.019ac5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019ac8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019acb	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019ace	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019ad1	20 3c 9c	jsr $019c3c			jsr 	FPUNormalise 				; normalise and exit.
.019ad4	7a		ply				ply
.019ad5	68		pla				pla
.019ad6	60		rts				rts
.019ad7					FPCalculateExponent:
.019ad7	18		clc				clc
.019ad8	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019adb	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019ade	b0 08		bcs $019ae8			bcs 	_FPCECarry 					; carry out ?
.019ae0	10 03		bpl $019ae5			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019ae2	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019ae4	60		rts				rts
.019ae5					_FPCEExpZero:
.019ae5	a9 00		lda #$00			lda 	#0
.019ae7	60		rts				rts
.019ae8					_FPCECarry:
.019ae8	30 03		bmi $019aed			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019aea	09 80		ora #$80			ora 	#$80 						; put in right range
.019aec	60		rts				rts
.019aed					_FPCEOverflow:
.019aed	4c b1 9c	jmp $019cb1			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019af0					FPFractionalPart:
.019af0	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019af3	38		sec				sec 								; this flag tells us to keep the fractional part
.019af4	30 0f		bmi $019b05			bmi 	FPGetPart
.019af6	60		rts				rts
.019af7					FPIntegerPart:
.019af7	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019afa	18		clc				clc 								; this flag says keep the integer part.
.019afb	30 08		bmi $019b05			bmi 	FPGetPart 					; -ve exponents are 0..127
.019afd	48		pha				pha
.019afe	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019b00	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b03	68		pla				pla
.019b04	60		rts				rts
.019b05					FPGetPart:
.019b05	48		pha				pha
.019b06	5a		phy				phy 								; save Y
.019b07	08		php				php 								; save action
.019b08	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019b0b	70 62		bvs $019b6f			bvs 	_FPGP_Exit 					; then do nothing.
.019b0d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019b0f	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019b11	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019b13	85 1c		sta $1c				sta 	zLTemp1+2
.019b15	85 1d		sta $1d				sta 	zLTemp1+3
.019b17	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.019b1a	38		sec				sec
.019b1b	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019b1d	f0 12		beq $019b31			beq 	_FPGP_NoShift 				; ... if any
.019b1f	c9 20		cmp #$20			cmp 	#32
.019b21	90 02		bcc $019b25			bcc 	_FPGP_NotMax
.019b23	a9 20		lda #$20			lda 	#32 						; max of 32.
.019b25					_FPGP_NotMax:
.019b25	a8		tay				tay 								; Y is the mask shift count.
.019b26					_FPGP_ShiftMask:
.019b26	46 1d		lsr $1d				lsr 	3+zLTemp1
.019b28	66 1c		ror $1c				ror 	2+zLTemp1
.019b2a	66 1b		ror $1b				ror 	1+zLTemp1
.019b2c	66 1a		ror $1a				ror 	0+zLTemp1
.019b2e	88		dey				dey
.019b2f	d0 f5		bne $019b26			bne 	_FPGP_ShiftMask
.019b31					_FPGP_NoShift:
.019b31	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019b33	8e 8e 04	stx $048e			stx 	ExpTemp						; save X
.019b36					_FPGP_MaskLoop:
.019b36	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019b39	28		plp				plp 								; if CC we keep the top part, so we
.019b3a	08		php				php		 							; flip the mask.
.019b3b	b0 02		bcs $019b3f			bcs		_FPGP_NoFlip
.019b3d	49 ff		eor #$ff			eor 	#$FF
.019b3f					_FPGP_NoFlip:
.019b3f	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019b42	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019b45	e8		inx				inx
.019b46	c8		iny				iny
.019b47	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019b49	d0 eb		bne $019b36			bne 	_FPGP_MaskLoop
.019b4b	ae 8e 04	ldx $048e			ldx 	ExpTemp						; restore X
.019b4e	28		plp				plp
.019b4f	08		php				php 								; get action flag on the stack
.019b50	90 05		bcc $019b57			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019b52	a9 00		lda #$00			lda 	#0
.019b54	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b57					_FPGP_NotFractional:
.019b57	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019b5a	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019b5d	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019b60	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019b63	f0 05		beq $019b6a			beq 	_FPGP_Zero 					; if zero, return zero
.019b65	20 3c 9c	jsr $019c3c			jsr 	FPUNormalise
.019b68	80 05		bra $019b6f			bra 	_FPGP_Exit 					; and exit
.019b6a					_FPGP_Zero:
.019b6a	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019b6c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b6f					_FPGP_Exit:
.019b6f	68		pla				pla 								; throw saved action flag.
.019b70	7a		ply				ply
.019b71	68		pla				pla
.019b72	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019b73					FPCompare:
.019b73	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019b76	48		pha				pha
.019b77	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019b7a	48		pha				pha
.019b7b	20 dd 98	jsr $0198dd			jsr 	FPSubtract 					; calculate X1-X2
.019b7e	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019b81	70 2c		bvs $019baf			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019b83	68		pla				pla
.019b84	8d 8e 04	sta $048e			sta 	ExpTemp						; save first exponent in temporary reg.
.019b87	68		pla				pla
.019b88	38		sec				sec
.019b89	ed 8e 04	sbc $048e			sbc 	ExpTemp 					; calculate AX-BX
.019b8c	70 15		bvs $019ba3			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019b8e	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019b8f	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019b91	b0 10		bcs $019ba3			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019b93	38		sec				sec
.019b94	ad 8e 04	lda $048e			lda 	ExpTemp 					; get one of the exponents back.
.019b97	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019b99	b0 02		bcs $019b9d			bcs 	_FPCNotRange 				; keep in range.
.019b9b	a9 01		lda #$01			lda 	#1
.019b9d					_FPCNotRange:
.019b9d	38		sec				sec
.019b9e	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019ba1	b0 0e		bcs $019bb1			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019ba3					_FPCNotEqual:
.019ba3	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019ba6	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019ba8	f0 02		beq $019bac			beq 	_FPCNE2
.019baa	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019bac	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019bad	80 04		bra $019bb3			bra 	_FPCExit
.019baf					_FPCPullZero:
.019baf	68		pla				pla 								; throw saved exponents
.019bb0	68		pla				pla
.019bb1					_FPCZero:
.019bb1	a9 00		lda #$00			lda 	#0 							; and return zero
.019bb3					_FPCExit:
.019bb3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019bb4					FPUCopyX2ToX1:
.019bb4	48		pha				pha
.019bb5	da		phx				phx
.019bb6	5a		phy				phy
.019bb7	a0 08		ldy #$08			ldy 	#8
.019bb9	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019bbc	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019bbf	e8		inx				inx
.019bc0	88		dey				dey
.019bc1	10 f6		bpl $019bb9			bpl 	_FPUC21
.019bc3	7a		ply				ply
.019bc4	fa		plx				plx
.019bc5	68		pla				pla
.019bc6	60		rts				rts
.019bc7					FPUSetInteger:
.019bc7	48		pha				pha
.019bc8	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019bcb	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019bcd	10 02		bpl $019bd1			bpl 	_FPUSIExtend
.019bcf	a9 ff		lda #$ff			lda 	#$FF
.019bd1					_FPUSIExtend:
.019bd1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019bd4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019bd7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019bda	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019bdc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019bdf	68		pla				pla
.019be0	60		rts				rts
.019be1					FPUNegateInteger:
.019be1	48		pha				pha
.019be2	38		sec				sec
.019be3	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019be5	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019be8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019beb	a9 00		lda #$00			lda 	#0
.019bed	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019bf0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019bf3	a9 00		lda #$00			lda 	#0
.019bf5	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019bf8	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019bfb	a9 00		lda #$00			lda 	#0
.019bfd	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019c00	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019c03	68		pla				pla
.019c04	60		rts				rts
.019c05					FPUToFloat:
.019c05	48		pha				pha
.019c06	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019c09	29 0f		and #$0f			and 	#$0F
.019c0b	f0 2d		beq $019c3a			beq 	_FPUFExit
.019c0d	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019c0f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019c12	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019c14	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019c17	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019c1a	10 08		bpl $019c24			bpl		_FPUFPositive
.019c1c	20 e1 9b	jsr $019be1			jsr 	FPUNegateInteger 			; negate the mantissa
.019c1f	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019c21	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019c24					_FPUFPositive:
.019c24	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019c27	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019c2a	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019c2d	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019c30	d0 05		bne $019c37			bne 	_FPUFNonZero
.019c32	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019c34	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019c37					_FPUFNonZero:
.019c37	20 3c 9c	jsr $019c3c			jsr 	FPUNormalise 				; normalise the floating point.
.019c3a					_FPUFExit:
.019c3a	68		pla				pla
.019c3b	60		rts				rts
.019c3c					FPUNormalise:
.019c3c	48		pha				pha
.019c3d	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019c40	70 20		bvs $019c62			bvs 	_FPUNExit
.019c42	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019c45	f0 16		beq $019c5d			beq 	_FPUNSetZero
.019c47					_FPUNLoop:
.019c47	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019c4a	30 16		bmi $019c62			bmi 	_FPUNExit 					; if so, we are normalised.
.019c4c	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019c4f	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019c52	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019c55	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019c58	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019c5b	d0 ea		bne $019c47			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019c5d					_FPUNSetZero:
.019c5d	a9 40		lda #$40			lda 	#$40
.019c5f	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019c62					_FPUNExit:
.019c62	68		pla				pla
.019c63	60		rts				rts
.019c64					FPUToInteger:
.019c64	48		pha				pha
.019c65	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019c68	29 01		and #$01			and 	#1
.019c6a	d0 3e		bne $019caa			bne 	_FPUTOI_Exit
.019c6c	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019c6f	70 2b		bvs $019c9c			bvs 	_FPUTOI_Zero
.019c71	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019c74	10 26		bpl $019c9c			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019c76	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019c78	b0 37		bcs $019cb1			bcs 	FP_Overflow
.019c7a					_FPUToIToInteger:
.019c7a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019c7d	c9 a0		cmp #$a0			cmp 	#128+32
.019c7f	f0 11		beq $019c92			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019c81	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019c84	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019c87	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019c8a	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019c8d	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019c90	80 e8		bra $019c7a			bra 	_FPUToIToInteger 			; keep going.
.019c92					_FPUToICheckSign:
.019c92	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019c95	10 13		bpl $019caa			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019c97	20 e1 9b	jsr $019be1			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019c9a	80 0e		bra $019caa			bra 	_FPUTOI_Exit
.019c9c					_FPUTOI_Zero:
.019c9c	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019c9e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019ca1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019ca4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019ca7	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019caa					_FPUToI_Exit:
.019caa	a9 01		lda #$01			lda 	#1 							; set type to integer
.019cac	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019caf	68		pla				pla
.019cb0	60		rts				rts
.019cb1					FP_Overflow:
.019cb1	20 2f 84	jsr $01842f			jsr ERR_Handler
>019cb4	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019cbc	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019ccc					FPUTimes10:
.019ccc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019ccf	85 1a		sta $1a				sta 	ZLTemp1+0
.019cd1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019cd4	85 1b		sta $1b				sta 	ZLTemp1+1
.019cd6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019cd9	85 1c		sta $1c				sta 	ZLTemp1+2
.019cdb	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019cde	85 1d		sta $1d				sta 	ZLTemp1+3
.019ce0	20 24 9d	jsr $019d24			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019ce3	20 24 9d	jsr $019d24			jsr 	_FPUT_LSR_ZLTemp1
.019ce6	18		clc				clc
.019ce7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019cea	65 1a		adc $1a				adc 	ZLTemp1+0
.019cec	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019cef	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019cf2	65 1b		adc $1b				adc 	ZLTemp1+1
.019cf4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019cf7	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019cfa	65 1c		adc $1c				adc 	ZLTemp1+2
.019cfc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019cff	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019d02	65 1d		adc $1d				adc 	ZLTemp1+3
.019d04	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019d07	90 0f		bcc $019d18			bcc 	_FPUTimes10
.019d09	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019d0c	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019d0f	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019d12	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019d15	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019d18					_FPUTimes10:
.019d18	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019d1b	18		clc				clc
.019d1c	69 03		adc #$03			adc 	#3
.019d1e	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019d21	b0 8e		bcs $019cb1			bcs 	FP_Overflow 				; error
.019d23	60		rts				rts
.019d24					_FPUT_LSR_ZLTemp1:
.019d24	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019d26	66 1c		ror $1c				ror 	ZLTemp1+2
.019d28	66 1b		ror $1b				ror 	ZLTemp1+1
.019d2a	66 1a		ror $1a				ror 	ZLTemp1+0
.019d2c	60		rts				rts
.019d2d					FPUScale10A:
.019d2d	5a		phy				phy
.019d2e	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019d30	f0 3d		beq $019d6f			beq 	_FPUScaleExit
.019d32	da		phx				phx 								; save X
.019d33	e8		inx				inx
.019d34	e8		inx				inx
.019d35	e8		inx				inx
.019d36	e8		inx				inx
.019d37	e8		inx				inx
.019d38	e8		inx				inx
.019d39	a8		tay				tay 								; save power scalar in Y.
.019d3a	a9 00		lda #$00			lda 	#0
.019d3c	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019d3f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019d42	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019d45	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019d48	a9 80		lda #$80			lda 	#$80
.019d4a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019d4d	a9 81		lda #$81			lda 	#$81
.019d4f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019d52	5a		phy				phy 								; save 10^n on stack.
.019d53	c0 00		cpy #$00			cpy 	#0
.019d55	10 05		bpl $019d5c			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019d57	98		tya				tya
.019d58	49 ff		eor #$ff			eor 	#$FF
.019d5a	1a		inc a				inc 	a
.019d5b	a8		tay				tay
.019d5c					_FPUSAbs:
.019d5c	20 cc 9c	jsr $019ccc			jsr 	FPUTimes10
.019d5f	88		dey				dey
.019d60	d0 fa		bne $019d5c			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019d62	68		pla				pla 								; restore count in A
.019d63	fa		plx				plx 								; restore X pointing to number to scale.
.019d64	0a		asl a				asl 	a
.019d65	b0 05		bcs $019d6c			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019d67	20 53 9a	jsr $019a53			jsr 	FPMultiply 					; if clear multiply.
.019d6a	80 03		bra $019d6f			bra		_FPUScaleExit
.019d6c					_FPUSDivide:
.019d6c	20 cb 99	jsr $0199cb			jsr 	FPDivide
.019d6f					_FPUScaleExit:
.019d6f	7a		ply				ply
.019d70	60		rts				rts
.019d71					FPUCopyToNext:
.019d71	a0 06		ldy #$06			ldy 		#6
.019d73	da		phx				phx
.019d74					_FPUCopy1:
.019d74	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019d77	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019d7a	e8		inx				inx
.019d7b	88		dey				dey
.019d7c	d0 f6		bne $019d74			bne 	_FPUCopy1
.019d7e	fa		plx				plx
.019d7f	60		rts				rts
.019d80					FPUCopyFromNext:
.019d80	a0 06		ldy #$06			ldy 		#6
.019d82	da		phx				phx
.019d83					_FPUCopy1:
.019d83	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019d86	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019d89	e8		inx				inx
.019d8a	88		dey				dey
.019d8b	d0 f6		bne $019d83			bne 	_FPUCopy1
.019d8d	fa		plx				plx
.019d8e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019d8f					FPToString:
.019d8f	48		pha				pha
.019d90	5a		phy				phy
.019d91	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019d94	50 0a		bvc $019da0			bvc 		_FPTSIsFloat 			; if zero,
.019d96					_FPTSZero:
.019d96	a9 30		lda #$30			lda 		#"0"
.019d98	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter
.019d9b					_FPTSExit:
.019d9b	7a		ply				ply
.019d9c	68		pla				pla
.019d9d	60		rts				rts
.019d9e	80 fb		bra $019d9b			bra 		_FPTSExit
.019da0					_FPTSIsFloat:
.019da0	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019da3	10 0a		bpl $019daf			bpl 		_FPTSNotSigned
.019da5	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019da7	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019daa	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019dac	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter
.019daf					_FPTSNotSigned:
.019daf	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019db2	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019db4	b0 09		bcs $019dbf			bcs 		_FPTSExponent
.019db6	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019db8	90 05		bcc $019dbf			bcc 		_FPTSExponent 			;
.019dba					_FPTSStandard:
.019dba	20 03 9e	jsr $019e03			jsr 		FPTOutputBody 			; output the body.
.019dbd	80 dc		bra $019d9b			bra 		_FPTSExit
.019dbf					_FPTSExponent:
.019dbf	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019dc1	8d 8f 04	sta $048f			sta 		ExpCount
.019dc4					_FPTSExponentLoop:
.019dc4	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019dc7	10 0e		bpl $019dd7			bpl 		_FPTSTimes
.019dc9	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019dcb	90 14		bcc $019de1			bcc 		_FPTSScaledToExp
.019dcd	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019dcf	20 2d 9d	jsr $019d2d			jsr 		FPUScale10A
.019dd2	ee 8f 04	inc $048f			inc 		ExpCount
.019dd5	80 ed		bra $019dc4			bra 		_FPTSExponentLoop
.019dd7					_FPTSTimes:
.019dd7	a9 01		lda #$01			lda 		#1
.019dd9	20 2d 9d	jsr $019d2d			jsr 		FPUScale10A
.019ddc	ce 8f 04	dec $048f			dec 		ExpCount
.019ddf	80 e3		bra $019dc4			bra 		_FPTSExponentLoop
.019de1					_FPTSScaledToExp:
.019de1	20 03 9e	jsr $019e03			jsr 		FPTOutputBody 			; output the body.
.019de4	a9 65		lda #$65			lda 		#"e"					; output E
.019de6	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter
.019de9	ad 8f 04	lda $048f			lda 		ExpCount 				; get the exponent
.019dec	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019def	29 80		and #$80			and 		#$80 					; sign extend it
.019df1	f0 02		beq $019df5			beq 		_FPTSSExt
.019df3	a9 ff		lda #$ff			lda 		#$FF
.019df5					_FPTSSExt:
.019df5	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019df8	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019dfb	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019dfe	20 7b 97	jsr $01977b			jsr 		INTToString 			; output the exponent.
.019e01	80 98		bra $019d9b			bra			_FPTSExit 				; and exit.
.019e03					FPTOutputBody:
.019e03	20 71 9d	jsr $019d71			jsr 		FPUCopyToNext 			; copy to next slot.
.019e06	20 64 9c	jsr $019c64			jsr 		FPUToInteger 			; convert to an integer
.019e09	20 7b 97	jsr $01977b			jsr 		INTToString 			; output the main integer part.
.019e0c	20 80 9d	jsr $019d80			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019e0f	20 f0 9a	jsr $019af0			jsr 		FPFractionalPart 		; get the decimal part.
.019e12	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019e15	70 3e		bvs $019e55			bvs 		_FPTOExit 				; if not, exit now.
.019e17	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019e19	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter
.019e1c					_FPOutLoop:
.019e1c	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019e1f	70 1e		bvs $019e3f			bvs 		_FPStripZeros 			; strip trailing zeros
.019e21	20 cc 9c	jsr $019ccc			jsr 		FPUTimes10 				; multiply by 10
.019e24	20 71 9d	jsr $019d71			jsr 		FPUCopyToNext			; copy to next slot.
.019e27	20 64 9c	jsr $019c64			jsr 		FPUToInteger 			; convert to integer
.019e2a	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019e2d	09 30		ora #$30			ora 		#"0"
.019e2f	20 1f 98	jsr $01981f			jsr 		ITSOutputCharacter
.019e32	20 80 9d	jsr $019d80			jsr 		FPUCopyFromNext 		; get it back
.019e35	20 f0 9a	jsr $019af0			jsr 		FPFractionalPart 		; get fractional part
.019e38	ad 06 04	lda $0406			lda 		NumBufX 				; done 11 characters yet ?
.019e3b	c9 0b		cmp #$0b			cmp 	 	#11
.019e3d	90 dd		bcc $019e1c			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019e3f					_FPStripZeros:
.019e3f	ac 06 04	ldy $0406			ldy 		NumBufX 				; strip trailing zeros.
.019e42					_FPStripLoop:
.019e42	88		dey				dey 								; back one, if at start then no strip
.019e43	f0 10		beq $019e55			beq 		_FPToExit
.019e45	b9 07 04	lda $0407,y			lda 		Num_Buffer,y 			; keep going if "0"
.019e48	c9 30		cmp #$30			cmp 		#"0"
.019e4a	f0 f6		beq $019e42			beq 		_FPStripLoop
.019e4c	c8		iny				iny
.019e4d	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019e4f	99 07 04	sta $0407,y			sta 		Num_Buffer,y
.019e52	8c 06 04	sty $0406			sty 		NumBufX 				; update position.
.019e55					_FPTOExit:
.019e55	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019e56					FPFromString:
.019e56	48		pha				pha 								; push A
.019e57	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019e59	c9 2e		cmp #$2e			cmp 	#"."
.019e5b	f0 03		beq $019e60			beq	 	_FPFIsDecimal
.019e5d	4c c3 9e	jmp $019ec3			jmp 	_FPFNotDecimal
.019e60					_FPFIsDecimal:
.019e60	c8		iny				iny 								; consume the decimal.
.019e61	20 05 9c	jsr $019c05			jsr 	FPUToFloat 					; convert the integer to float.
.019e64	da		phx				phx 								; save X.
.019e65	5a		phy				phy 								; save decimal start position
.019e66	e8		inx				inx
.019e67	e8		inx				inx
.019e68	e8		inx				inx
.019e69	e8		inx				inx
.019e6a	e8		inx				inx
.019e6b	e8		inx				inx
.019e6c	20 37 98	jsr $019837			jsr 	INTFromStringY 				; get the part after the DP.
.019e6f	20 05 9c	jsr $019c05			jsr 	FPUToFloat 					; convert that to a float.
.019e72	68		pla				pla 								; calculate - chars consumed.
.019e73	8c 8e 04	sty $048e			sty 	ExpTemp
.019e76	38		sec				sec
.019e77	ed 8e 04	sbc $048e			sbc 	ExpTemp 					; this is the shift amount
.019e7a	20 2d 9d	jsr $019d2d			jsr 	FPUScale10A 				; scale it by 10^AC
.019e7d	fa		plx				plx 								; restore original X
.019e7e	20 e7 98	jsr $0198e7			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019e81	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019e83	c9 45		cmp #$45			cmp 	#"E"
.019e85	f0 04		beq $019e8b			beq 	_FPFExponent
.019e87	c9 65		cmp #$65			cmp 	#"e"
.019e89	d0 38		bne $019ec3			bne 	_FPFNotDecimal 				; no, then exit normally.
.019e8b					_FPFExponent:
.019e8b	c8		iny				iny 								; skip over E symbol.
.019e8c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019e8e	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019e90	d0 01		bne $019e93			bne 	_FPFGotSign
.019e92	c8		iny				iny 								; if it was - skip over it.
.019e93					_FPFGotSign:
.019e93	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019e94	da		phx				phx
.019e95	e8		inx				inx
.019e96	e8		inx				inx
.019e97	e8		inx				inx
.019e98	e8		inx				inx
.019e99	e8		inx				inx
.019e9a	e8		inx				inx
.019e9b	20 37 98	jsr $019837			jsr 	INTFromStringY 				; get the exponent
.019e9e	fa		plx				plx 								; restore X.
.019e9f	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019ea2	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019ea5	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019ea8	d0 1b		bne $019ec5			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019eaa	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019ead	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019eaf	b0 14		bcs $019ec5			bcs 	_FPFXOverflow
.019eb1	68		pla				pla 								; get direction
.019eb2	d0 09		bne $019ebd			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019eb4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019eb7	49 ff		eor #$ff			eor 	#$FF
.019eb9	1a		inc a				inc 	a
.019eba	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019ebd					_FPFXScale:
.019ebd	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019ec0	20 2d 9d	jsr $019d2d			jsr 	FPUScale10A 				; scale by the exponent.
.019ec3					_FPFNotDecimal:
.019ec3	68		pla				pla
.019ec4	60		rts				rts
.019ec5					_FPFXOverflow:
.019ec5	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019ec8	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019ed0	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019ed7					Unary_Rnd:
.019ed7	20 de 8a	jsr $018ade			jsr 	EvaluateNumberX 			; get value
.019eda	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; check right bracket.
.019edd	20 cb 8d	jsr $018dcb			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019ee0	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019ee2	30 10		bmi $019ef4			bmi 	_URSetSeed
.019ee4	f0 2c		beq $019f12			beq 	_URMakeRandom 				; if zero return same number.
.019ee6	da		phx				phx
.019ee7	a2 00		ldx #$00			ldx 	#0
.019ee9	20 4f 9f	jsr $019f4f			jsr 	Random16
.019eec	a2 02		ldx #$02			ldx 	#2
.019eee	20 4f 9f	jsr $019f4f			jsr 	Random16
.019ef1	fa		plx				plx
.019ef2	80 1e		bra $019f12			bra 	_URMakeRandom
.019ef4					_URSetSeed:
.019ef4	20 05 9c	jsr $019c05			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019ef7	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019efa	8d 95 04	sta $0495			sta 	RandomSeed+0
.019efd	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019f00	8d 96 04	sta $0496			sta 	RandomSeed+1
.019f03	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019f06	8d 97 04	sta $0497			sta 	RandomSeed+2
.019f09	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019f0c	0a		asl a				asl 	a
.019f0d	49 db		eor #$db			eor 	#$DB
.019f0f	8d 98 04	sta $0498			sta 	RandomSeed+3
.019f12					_URMakeRandom:
.019f12	ad 95 04	lda $0495			lda 	RandomSeed+0 				; check if seed is zero.
.019f15	0d 96 04	ora $0496			ora 	RandomSeed+1
.019f18	0d 97 04	ora $0497			ora 	RandomSeed+2
.019f1b	0d 98 04	ora $0498			ora 	RandomSeed+3
.019f1e	d0 0a		bne $019f2a			bne 	_URNotZero
.019f20	a9 47		lda #$47			lda 	#$47
.019f22	8d 96 04	sta $0496			sta 	RandomSeed+1				; if it is, make it non zero.
.019f25	a9 3d		lda #$3d			lda 	#$3D
.019f27	8d 98 04	sta $0498			sta 	RandomSeed+3
.019f2a					_URNotZero:
.019f2a	ad 95 04	lda $0495			lda 	RandomSeed+0 				; copy seed into mantissa.
.019f2d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019f30	ad 96 04	lda $0496			lda 	RandomSeed+1
.019f33	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019f36	ad 97 04	lda $0497			lda 	RandomSeed+2
.019f39	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019f3c	ad 98 04	lda $0498			lda 	RandomSeed+3
.019f3f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019f42	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019f44	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019f47	a9 80		lda #$80			lda 	#$80
.019f49	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019f4c	4c 3c 9c	jmp $019c3c			jmp 	FPUNormalise
.019f4f					Random16:
.019f4f	5e 96 04	lsr $0496,x			lsr 	RandomSeed+1,x				; shift seed right
.019f52	7e 95 04	ror $0495,x			ror 	RandomSeed,x
.019f55	90 08		bcc $019f5f			bcc 	_R16_NoXor
.019f57	bd 96 04	lda $0496,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019f5a	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019f5c	9d 96 04	sta $0496,x			sta 	RandomSeed+1,x
.019f5f					_R16_NoXor:
.019f5f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019f60					Unary_Int:
.019f60	20 de 8a	jsr $018ade			jsr 	EvaluateNumberX 			; get value
.019f63	20 a4 91	jsr $0191a4			jsr 	CheckNextRParen 			; check right bracket.
.019f66	4c 64 9c	jmp $019c64			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019f69	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
