
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Sat Sep  7 16:50:55 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					autorun = 1
=3					loadtest = 3
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/macros/4510/macros_32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=0					VariableMemory = 0
=$2000					BasicProgram = $2000
.8000					BasicProgramStart:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>8000	0c 0a 00 c7 18 34 06 13			.byte	$0c,$0a,$00,$c7,$18,$34,$06,$13
>8008	ba 42 be 00 09 14 00 c7			.byte	$ba,$42,$be,$00,$09,$14,$00,$c7
>8010	11 bd 42 be 00 0d 1e 00			.byte	$11,$bd,$42,$be,$00,$0d,$1e,$00
>8018	c7 03 30 0b 0b 10 bd 42			.byte	$c7,$03,$30,$0b,$0b,$10,$bd,$42
>8020	be 00 0d 28 00 c7 02 38			.byte	$be,$00,$0d,$28,$00,$c7,$02,$38
>8028	07 10 13 ba 42 be 00 0e			.byte	$07,$10,$13,$ba,$42,$be,$00,$0e
>8030	32 00 c7 19 33 11 0e bc			.byte	$32,$00,$c7,$19,$33,$11,$0e,$bc
>8038	41 bf 42 be 00 0d 3c 00			.byte	$41,$bf,$42,$be,$00,$0d,$3c,$00
>8040	c7 04 30 15 07 16 bc 42			.byte	$c7,$04,$30,$15,$07,$16,$bc,$42
>8048	be 00 0f 46 00 c7 18 30			.byte	$be,$00,$0f,$46,$00,$c7,$18,$30
>8050	1a 15 0a b8 42 bf 42 be			.byte	$1a,$15,$0a,$b8,$42,$bf,$42,$be
>8058	00 0d 50 00 c7 18 34 14			.byte	$00,$0d,$50,$00,$c7,$18,$34,$14
>8060	ba 42 bf 42 be 00 0b 5a			.byte	$ba,$42,$bf,$42,$be,$00,$0b,$5a
>8068	00 c7 03 35 06 b8 42 be			.byte	$00,$c7,$03,$35,$06,$b8,$42,$be
>8070	00 09 64 00 c7 0d bc 42			.byte	$00,$09,$64,$00,$c7,$0d,$bc,$42
>8078	be 00 0d 6e 00 c7 06 30			.byte	$be,$00,$0d,$6e,$00,$c7,$06,$30
>8080	18 16 09 bc 41 be 00 0b			.byte	$18,$16,$09,$bc,$41,$be,$00,$0b
>8088	78 00 c7 1a 37 1a bc 42			.byte	$78,$00,$c7,$1a,$37,$1a,$bc,$42
>8090	be 00 12 82 00 cf 07 35			.byte	$be,$00,$12,$82,$00,$cf,$07,$35
>8098	0c b9 84 48 72 fd 06 34			.byte	$0c,$b9,$84,$48,$72,$fd,$06,$34
>80a0	33 37 35 00 12 8c 00 cf			.byte	$33,$37,$35,$00,$12,$8c,$00,$cf
>80a8	12 37 1a 84 8b 42 66 fd			.byte	$12,$37,$1a,$84,$8b,$42,$66,$fd
>80b0	06 39 33 37 35 00 11 96			.byte	$06,$39,$33,$37,$35,$00,$11,$96
>80b8	00 cf 06 30 18 16 09 bc			.byte	$00,$cf,$06,$30,$18,$16,$09,$bc
>80c0	40 be 84 8b 4e 41 00 14			.byte	$40,$be,$84,$8b,$4e,$41,$00,$14
>80c8	a0 00 cf 03 30 0b 0b 10			.byte	$a0,$00,$cf,$03,$30,$0b,$0b,$10
>80d0	bd 41 be 84 45 45 fd 04			.byte	$bd,$41,$be,$84,$45,$45,$fd,$04
>80d8	32 35 00 0f aa 00 cf 07			.byte	$32,$35,$00,$0f,$aa,$00,$cf,$07
>80e0	b7 84 fe 07 4f 34 59 4f			.byte	$b7,$84,$fe,$07,$4f,$34,$59,$4f
>80e8	55 00 0e b4 00 cf 13 35			.byte	$55,$00,$0e,$b4,$00,$cf,$13,$35
>80f0	04 18 bb 84 8b 49 55 00			.byte	$04,$18,$bb,$84,$8b,$49,$55,$00
>80f8	14 be 00 cf 07 36 02 14			.byte	$14,$be,$00,$cf,$07,$36,$02,$14
>8100	14 b9 84 8b 5b fd 06 39			.byte	$14,$b9,$84,$8b,$5b,$fd,$06,$39
>8108	33 37 35 00 13 c8 00 cf			.byte	$33,$37,$35,$00,$13,$c8,$00,$cf
>8110	13 36 0b 01 84 8b 49 57			.byte	$13,$36,$0b,$01,$84,$8b,$49,$57
>8118	fd 06 39 33 37 35 00 17			.byte	$fd,$06,$39,$33,$37,$35,$00,$17
>8120	d2 00 cf 18 30 1a 15 0a			.byte	$d2,$00,$cf,$18,$30,$1a,$15,$0a
>8128	b8 40 bf 42 be 84 fe 07			.byte	$b8,$40,$bf,$42,$be,$84,$fe,$07
>8130	57 37 43 58 52 00 0e dc			.byte	$57,$37,$43,$58,$52,$00,$0e,$dc
>8138	00 cf 14 39 14 1a b7 84			.byte	$00,$cf,$14,$39,$14,$1a,$b7,$84
>8140	fe 03 4f 00 12 e6 00 cf			.byte	$fe,$03,$4f,$00,$12,$e6,$00,$cf
>8148	04 32 06 14 b7 84 fe 07			.byte	$04,$32,$06,$14,$b7,$84,$fe,$07
>8150	49 33 47 41 48 00 12 f0			.byte	$49,$33,$47,$41,$48,$00,$12,$f0
>8158	00 cf 04 30 14 1a 06 b7			.byte	$00,$cf,$04,$30,$14,$1a,$06,$b7
>8160	84 fe 06 51 31 53 56 00			.byte	$84,$fe,$06,$51,$31,$53,$56,$00
>8168	0d fa 00 cf 16 39 06 b7			.byte	$0d,$fa,$00,$cf,$16,$39,$06,$b7
>8170	84 fe 03 4a 00 0b 04 01			.byte	$84,$fe,$03,$4a,$00,$0b,$04,$01
>8178	cf 19 bb 84 8b 44 42 00			.byte	$cf,$19,$bb,$84,$8b,$44,$42,$00
>8180	0b 0e 01 cf 02 b7 84 fe			.byte	$0b,$0e,$01,$cf,$02,$b7,$84,$fe
>8188	03 56 00 0f 18 01 cf 04			.byte	$03,$56,$00,$0f,$18,$01,$cf,$04
>8190	37 09 17 05 b7 84 fe 03			.byte	$37,$09,$17,$05,$b7,$84,$fe,$03
>8198	46 00 12 22 01 cf 16 38			.byte	$46,$00,$12,$22,$01,$cf,$16,$38
>81a0	16 84 8b 45 6a fd 06 38			.byte	$16,$84,$8b,$45,$6a,$fd,$06,$38
>81a8	31 32 35 00 0d 2c 01 cf			.byte	$31,$32,$35,$00,$0d,$2c,$01,$cf
>81b0	05 30 06 bb 84 8b 46 66			.byte	$05,$30,$06,$bb,$84,$8b,$46,$66
>81b8	00 0f 36 01 cf 10 84 44			.byte	$00,$0f,$36,$01,$cf,$10,$84,$44
>81c0	78 fd 06 35 36 32 35 00			.byte	$78,$fd,$06,$35,$36,$32,$35,$00
>81c8	0b 40 01 cf 0e b7 84 fe			.byte	$0b,$40,$01,$cf,$0e,$b7,$84,$fe
>81d0	03 52 00 0e 4a 01 cf 0e			.byte	$03,$52,$00,$0e,$4a,$01,$cf,$0e
>81d8	b7 84 fe 06 53 32 53 50			.byte	$b7,$84,$fe,$06,$53,$32,$53,$50
>81e0	00 0c 54 01 cf 0e 38 14			.byte	$00,$0c,$54,$01,$cf,$0e,$38,$14
>81e8	bb 84 4c 4b 00 11 5e 01			.byte	$bb,$84,$4c,$4b,$00,$11,$5e,$01
>81f0	cf 15 33 0e 84 42 75 fd			.byte	$cf,$15,$33,$0e,$84,$42,$75,$fd
>81f8	06 33 31 32 35 00 14 68			.byte	$06,$33,$31,$32,$35,$00,$14,$68
>8200	01 cf 05 34 19 03 b9 84			.byte	$01,$cf,$05,$34,$19,$03,$b9,$84
>8208	8b 48 4f fd 06 31 38 37			.byte	$8b,$48,$4f,$fd,$06,$31,$38,$37
>8210	35 00 11 72 01 cf 16 39			.byte	$35,$00,$11,$72,$01,$cf,$16,$39
>8218	06 b7 84 fe 07 54 34 51			.byte	$06,$b7,$84,$fe,$07,$54,$34,$51
>8220	5a 51 00 13 7c 01 cf 05			.byte	$5a,$51,$00,$13,$7c,$01,$cf,$05
>8228	34 19 03 b9 84 46 42 fd			.byte	$34,$19,$03,$b9,$84,$46,$42,$fd
>8230	06 38 31 32 35 00 10 86			.byte	$06,$38,$31,$32,$35,$00,$10,$86
>8238	01 cf 04 30 15 07 16 bc			.byte	$01,$cf,$04,$30,$15,$07,$16,$bc
>8240	40 be 84 8b 50 00 11 90			.byte	$40,$be,$84,$8b,$50,$00,$11,$90
>8248	01 cf 02 34 17 b9 84 8b			.byte	$01,$cf,$02,$34,$17,$b9,$84,$8b
>8250	49 56 fd 04 37 35 00 10			.byte	$49,$56,$fd,$04,$37,$35,$00,$10
>8258	9a 01 cf 09 84 8b 46 4d			.byte	$9a,$01,$cf,$09,$84,$8b,$46,$4d
>8260	fd 06 36 38 37 35 00 0b			.byte	$fd,$06,$36,$38,$37,$35,$00,$0b
>8268	a4 01 cf 08 bb 84 8b 4a			.byte	$a4,$01,$cf,$08,$bb,$84,$8b,$4a
>8270	4b 00 0d ae 01 cf 0e 38			.byte	$4b,$00,$0d,$ae,$01,$cf,$0e,$38
>8278	14 bb 84 8b 41 4a 00 16			.byte	$14,$bb,$84,$8b,$41,$4a,$00,$16
>8280	b8 01 cf 18 30 1a 15 0a			.byte	$b8,$01,$cf,$18,$30,$1a,$15,$0a
>8288	b8 42 bf 42 be 84 fe 06			.byte	$b8,$42,$bf,$42,$be,$84,$fe,$06
>8290	46 36 53 42 00 11 c2 01			.byte	$46,$36,$53,$42,$00,$11,$c2,$01
>8298	cf 08 37 07 07 84 41 54			.byte	$cf,$08,$37,$07,$07,$84,$41,$54
>82a0	fd 05 36 32 35 00 0d cc			.byte	$fd,$05,$36,$32,$35,$00,$0d,$cc
>82a8	01 cf 05 30 06 bb 84 8b			.byte	$01,$cf,$05,$30,$06,$bb,$84,$8b
>82b0	4d 5e 00 10 d6 01 cf 01			.byte	$4d,$5e,$00,$10,$d6,$01,$cf,$01
>82b8	b9 84 43 45 fd 06 35 36			.byte	$b9,$84,$43,$45,$fd,$06,$35,$36
>82c0	32 35 00 0d e0 01 cf 0e			.byte	$32,$35,$00,$0d,$e0,$01,$cf,$0e
>82c8	31 08 bb 84 8b 4d 4c 00			.byte	$31,$08,$bb,$84,$8b,$4d,$4c,$00
>82d0	11 ea 01 cf 11 37 0b 17			.byte	$11,$ea,$01,$cf,$11,$37,$0b,$17
>82d8	16 b7 84 fe 05 43 38 46			.byte	$16,$b7,$84,$fe,$05,$43,$38,$46
>82e0	00 0e f4 01 cf 16 39 06			.byte	$00,$0e,$f4,$01,$cf,$16,$39,$06
>82e8	b7 84 fe 04 47 35 00 0b			.byte	$b7,$84,$fe,$04,$47,$35,$00,$0b
>82f0	fe 01 cf 10 84 6e fd 03			.byte	$fe,$01,$cf,$10,$84,$6e,$fd,$03
>82f8	35 00 13 08 02 cf 08 37			.byte	$35,$00,$13,$08,$02,$cf,$08,$37
>8300	07 07 84 8b 46 45 fd 06			.byte	$07,$07,$84,$8b,$46,$45,$fd,$06
>8308	36 38 37 35 00 0f 12 02			.byte	$36,$38,$37,$35,$00,$0f,$12,$02
>8310	cf 10 84 43 4a fd 06 36			.byte	$cf,$10,$84,$43,$4a,$fd,$06,$36
>8318	38 37 35 00 0f 1c 02 cf			.byte	$38,$37,$35,$00,$0f,$1c,$02,$cf
>8320	18 31 15 02 05 bb 84 8b			.byte	$18,$31,$15,$02,$05,$bb,$84,$8b
>8328	4e 45 00 0d 26 02 cf 0d			.byte	$4e,$45,$00,$0d,$26,$02,$cf,$0d
>8330	bc 41 be 84 8b 45 49 00			.byte	$bc,$41,$be,$84,$8b,$45,$49,$00
>8338	0d 30 02 cf 0a 33 0e 0e			.byte	$0d,$30,$02,$cf,$0a,$33,$0e,$0e
>8340	bb 84 48 69 00 13 3a 02			.byte	$bb,$84,$48,$69,$00,$13,$3a,$02
>8348	cf 17 33 03 b9 84 8b 48			.byte	$cf,$17,$33,$03,$b9,$84,$8b,$48
>8350	79 fd 06 34 33 37 35 00			.byte	$79,$fd,$06,$34,$33,$37,$35,$00
>8358	10 44 02 cf 15 33 0e 84			.byte	$10,$44,$02,$cf,$15,$33,$0e,$84
>8360	49 56 fd 05 36 32 35 00			.byte	$49,$56,$fd,$05,$36,$32,$35,$00
>8368	0f 4e 02 cf 02 b7 84 fe			.byte	$0f,$4e,$02,$cf,$02,$b7,$84,$fe
>8370	07 41 35 51 5a 56 00 0e			.byte	$07,$41,$35,$51,$5a,$56,$00,$0e
>8378	58 02 cf 0c 39 12 11 b7			.byte	$58,$02,$cf,$0c,$39,$12,$11,$b7
>8380	84 fe 03 52 00 0d 62 02			.byte	$84,$fe,$03,$52,$00,$0d,$62,$02
>8388	cf 0a 33 0e 0e bb 84 4b			.byte	$cf,$0a,$33,$0e,$0e,$bb,$84,$4b
>8390	52 00 11 6c 02 cf 16 38			.byte	$52,$00,$11,$6c,$02,$cf,$16,$38
>8398	16 84 8b 46 41 fd 05 38			.byte	$16,$84,$8b,$46,$41,$fd,$05,$38
>83a0	37 35 00 0a 76 02 cf 08			.byte	$37,$35,$00,$0a,$76,$02,$cf,$08
>83a8	bb 84 41 52 00 0b 80 02			.byte	$bb,$84,$41,$52,$00,$0b,$80,$02
>83b0	cf 06 32 02 bb 84 45 00			.byte	$cf,$06,$32,$02,$bb,$84,$45,$00
>83b8	0d 8a 02 cf 07 33 0f b7			.byte	$0d,$8a,$02,$cf,$07,$33,$0f,$b7
>83c0	84 fe 03 53 00 0f 94 02			.byte	$84,$fe,$03,$53,$00,$0f,$94,$02
>83c8	cf 09 84 8b 50 fd 06 35			.byte	$cf,$09,$84,$8b,$50,$fd,$06,$35
>83d0	36 32 35 00 13 9e 02 cf			.byte	$36,$32,$35,$00,$13,$9e,$02,$cf
>83d8	02 37 0e 1a b9 84 46 7d			.byte	$02,$37,$0e,$1a,$b9,$84,$46,$7d
>83e0	fd 06 31 38 37 35 00 0d			.byte	$fd,$06,$31,$38,$37,$35,$00,$0d
>83e8	a8 02 cf 0d bc 42 be 84			.byte	$a8,$02,$cf,$0d,$bc,$42,$be,$84
>83f0	8b 49 54 00 11 b2 02 cf			.byte	$8b,$49,$54,$00,$11,$b2,$02,$cf
>83f8	14 30 0e b9 84 46 55 fd			.byte	$14,$30,$0e,$b9,$84,$46,$55,$fd
>8400	05 31 32 35 00 13 bc 02			.byte	$05,$31,$32,$35,$00,$13,$bc,$02
>8408	cf 17 31 0e b9 84 8b 48			.byte	$cf,$17,$31,$0e,$b9,$84,$8b,$48
>8410	6f fd 06 34 33 37 35 00			.byte	$6f,$fd,$06,$34,$33,$37,$35,$00
>8418	15 c6 02 cf 10 36 04 16			.byte	$15,$c6,$02,$cf,$10,$36,$04,$16
>8420	09 b9 84 8b 47 71 fd 06			.byte	$09,$b9,$84,$8b,$47,$71,$fd,$06
>8428	36 38 37 35 00 0b d0 02			.byte	$36,$38,$37,$35,$00,$0b,$d0,$02
>8430	cf 09 84 57 fd 03 30 00			.byte	$cf,$09,$84,$57,$fd,$03,$30,$00
>8438	12 da 02 cf 06 37 17 84			.byte	$12,$da,$02,$cf,$06,$37,$17,$84
>8440	8b 46 73 fd 06 30 36 32			.byte	$8b,$46,$73,$fd,$06,$30,$36,$32
>8448	35 00 0d e4 02 cf 13 35			.byte	$35,$00,$0d,$e4,$02,$cf,$13,$35
>8450	04 18 bb 84 4e 64 00 0d			.byte	$04,$18,$bb,$84,$4e,$64,$00,$0d
>8458	ee 02 cf 0a b7 84 fe 05			.byte	$ee,$02,$cf,$0a,$b7,$84,$fe,$05
>8460	42 36 4d 00 12 f8 02 cf			.byte	$42,$36,$4d,$00,$12,$f8,$02,$cf
>8468	12 38 16 84 8b 48 64 fd			.byte	$12,$38,$16,$84,$8b,$48,$64,$fd
>8470	06 36 38 37 35 00 11 02			.byte	$06,$36,$38,$37,$35,$00,$11,$02
>8478	03 cf 04 30 14 1a 06 b7			.byte	$03,$cf,$04,$30,$14,$1a,$06,$b7
>8480	84 fe 05 43 36 46 00 0d			.byte	$84,$fe,$05,$43,$36,$46,$00,$0d
>8488	0c 03 cf 05 30 06 bb 84			.byte	$0c,$03,$cf,$05,$30,$06,$bb,$84
>8490	8b 41 6f 00 0c 16 03 cf			.byte	$8b,$41,$6f,$00,$0c,$16,$03,$cf
>8498	1a 36 17 bb 84 41 62 00			.byte	$1a,$36,$17,$bb,$84,$41,$62,$00
>84a0	11 20 03 cf 07 36 11 05			.byte	$11,$20,$03,$cf,$07,$36,$11,$05
>84a8	84 8b 44 5d fd 04 32 35			.byte	$84,$8b,$44,$5d,$fd,$04,$32,$35
>84b0	00 0e 2a 03 cf 07 b7 84			.byte	$00,$0e,$2a,$03,$cf,$07,$b7,$84
>84b8	fe 06 47 32 4d 52 00 0c			.byte	$fe,$06,$47,$32,$4d,$52,$00,$0c
>84c0	34 03 cf 02 33 17 16 bb			.byte	$34,$03,$cf,$02,$33,$17,$16,$bb
>84c8	84 53 00 11 3e 03 cf 12			.byte	$84,$53,$00,$11,$3e,$03,$cf,$12
>84d0	33 12 b9 84 41 4e fd 05			.byte	$33,$12,$b9,$84,$41,$4e,$fd,$05
>84d8	36 32 35 00 0f 48 03 cf			.byte	$36,$32,$35,$00,$0f,$48,$03,$cf
>84e0	01 b9 84 8b 42 5d fd 04			.byte	$01,$b9,$84,$8b,$42,$5d,$fd,$04
>84e8	32 35 00 13 52 03 cf 07			.byte	$32,$35,$00,$13,$52,$03,$cf,$07
>84f0	35 0c b9 84 8b 41 60 fd			.byte	$35,$0c,$b9,$84,$8b,$41,$60,$fd
>84f8	06 33 31 32 35 00 0e 5c			.byte	$06,$33,$31,$32,$35,$00,$0e,$5c
>8500	03 cf 1a 37 1a bc 41 be			.byte	$03,$cf,$1a,$37,$1a,$bc,$41,$be
>8508	84 48 6c 00 12 66 03 cf			.byte	$84,$48,$6c,$00,$12,$66,$03,$cf
>8510	17 33 03 b9 84 46 7a fd			.byte	$17,$33,$03,$b9,$84,$46,$7a,$fd
>8518	06 34 33 37 35 00 13 70			.byte	$06,$34,$33,$37,$35,$00,$13,$70
>8520	03 cf 14 34 04 01 84 8b			.byte	$03,$cf,$14,$34,$04,$01,$84,$8b
>8528	48 5a fd 06 39 33 37 35			.byte	$48,$5a,$fd,$06,$39,$33,$37,$35
>8530	00 0b 7a 03 cf 07 b7 84			.byte	$00,$0b,$7a,$03,$cf,$07,$b7,$84
>8538	fe 03 48 00 0e 84 03 cf			.byte	$fe,$03,$48,$00,$0e,$84,$03,$cf
>8540	1a 37 1a bc 42 be 84 4b			.byte	$1a,$37,$1a,$bc,$42,$be,$84,$4b
>8548	65 00 12 8e 03 cf 13 36			.byte	$65,$00,$12,$8e,$03,$cf,$13,$36
>8550	0e b9 84 43 6e fd 06 39			.byte	$0e,$b9,$84,$43,$6e,$fd,$06,$39
>8558	33 37 35 00 12 98 03 cf			.byte	$33,$37,$35,$00,$12,$98,$03,$cf
>8560	18 30 0b 07 b7 84 fe 07			.byte	$18,$30,$0b,$07,$b7,$84,$fe,$07
>8568	41 34 50 4a 47 00 13 a2			.byte	$41,$34,$50,$4a,$47,$00,$13,$a2
>8570	03 cf 19 32 02 12 84 8b			.byte	$03,$cf,$19,$32,$02,$12,$84,$8b
>8578	41 48 fd 06 34 33 37 35			.byte	$41,$48,$fd,$06,$34,$33,$37,$35
>8580	00 0b ac 03 cf 19 bb 84			.byte	$00,$0b,$ac,$03,$cf,$19,$bb,$84
>8588	8b 46 66 00 12 b6 03 cf			.byte	$8b,$46,$66,$00,$12,$b6,$03,$cf
>8590	04 30 14 1a 06 b7 84 fe			.byte	$04,$30,$14,$1a,$06,$b7,$84,$fe
>8598	06 59 37 47 42 00 0d c0			.byte	$06,$59,$37,$47,$42,$00,$0d,$c0
>85a0	03 cf 16 35 04 13 bb 84			.byte	$03,$cf,$16,$35,$04,$13,$bb,$84
>85a8	44 48 00 0e ca 03 cf 06			.byte	$44,$48,$00,$0e,$ca,$03,$cf,$06
>85b0	b7 84 fe 06 42 34 4c 56			.byte	$b7,$84,$fe,$06,$42,$34,$4c,$56
>85b8	00 11 d4 03 cf 08 37 07			.byte	$00,$11,$d4,$03,$cf,$08,$37,$07
>85c0	07 84 43 75 fd 05 36 32			.byte	$07,$84,$43,$75,$fd,$05,$36,$32
>85c8	35 00 0d de 03 cf 05 30			.byte	$35,$00,$0d,$de,$03,$cf,$05,$30
>85d0	06 bb 84 8b 4c 58 00 13			.byte	$06,$bb,$84,$8b,$4c,$58,$00,$13
>85d8	e8 03 cf 03 36 0c 07 b9			.byte	$e8,$03,$cf,$03,$36,$0c,$07,$b9
>85e0	84 43 47 fd 06 39 33 37			.byte	$84,$43,$47,$fd,$06,$39,$33,$37
>85e8	35 00 12 f2 03 cf 08 37			.byte	$35,$00,$12,$f2,$03,$cf,$08,$37
>85f0	07 07 84 43 5c fd 06 39			.byte	$07,$07,$84,$43,$5c,$fd,$06,$39
>85f8	33 37 35 00 0c fc 03 cf			.byte	$33,$37,$35,$00,$0c,$fc,$03,$cf
>8600	1a 38 09 b7 84 fe 02 00			.byte	$1a,$38,$09,$b7,$84,$fe,$02,$00
>8608	0d 06 04 cf 0a 33 0e 0e			.byte	$0d,$06,$04,$cf,$0a,$33,$0e,$0e
>8610	bb 84 41 7e 00 0c 10 04			.byte	$bb,$84,$41,$7e,$00,$0c,$10,$04
>8618	cf 0e 38 14 bb 84 4f 44			.byte	$cf,$0e,$38,$14,$bb,$84,$4f,$44
>8620	00 0b 1a 04 cf 16 bb 84			.byte	$00,$0b,$1a,$04,$cf,$16,$bb,$84
>8628	8b 43 40 00 13 24 04 cf			.byte	$8b,$43,$40,$00,$13,$24,$04,$cf
>8630	05 34 19 03 b9 84 46 69			.byte	$05,$34,$19,$03,$b9,$84,$46,$69
>8638	fd 06 30 36 32 35 00 0d			.byte	$fd,$06,$30,$36,$32,$35,$00,$0d
>8640	2e 04 cf 01 b9 84 5c fd			.byte	$2e,$04,$cf,$01,$b9,$84,$5c,$fd
>8648	04 37 35 00 0e 38 04 cf			.byte	$04,$37,$35,$00,$0e,$38,$04,$cf
>8650	16 39 06 b7 84 fe 04 58			.byte	$16,$39,$06,$b7,$84,$fe,$04,$58
>8658	30 00 11 42 04 cf 02 39			.byte	$30,$00,$11,$42,$04,$cf,$02,$39
>8660	05 b7 84 fe 07 58 33 50			.byte	$05,$b7,$84,$fe,$07,$58,$33,$50
>8668	47 41 00 13 4c 04 cf 0f			.byte	$47,$41,$00,$13,$4c,$04,$cf,$0f
>8670	36 0a 17 84 8b 45 4b fd			.byte	$36,$0a,$17,$84,$8b,$45,$4b,$fd
>8678	06 38 31 32 35 00 0c 56			.byte	$06,$38,$31,$32,$35,$00,$0c,$56
>8680	04 cf 02 b7 84 fe 04 4b			.byte	$04,$cf,$02,$b7,$84,$fe,$04,$4b
>8688	37 00 11 60 04 cf 04 37			.byte	$37,$00,$11,$60,$04,$cf,$04,$37
>8690	09 17 05 b7 84 fe 05 4e			.byte	$09,$17,$05,$b7,$84,$fe,$05,$4e
>8698	39 41 00 0b 6a 04 cf 19			.byte	$39,$41,$00,$0b,$6a,$04,$cf,$19
>86a0	bb 84 8b 46 74 00 11 74			.byte	$bb,$84,$8b,$46,$74,$00,$11,$74
>86a8	04 cf 02 39 05 b7 84 fe			.byte	$04,$cf,$02,$39,$05,$b7,$84,$fe
>86b0	07 44 38 5a 47 4d 00 0b			.byte	$07,$44,$38,$5a,$47,$4d,$00,$0b
>86b8	7e 04 cf 08 bb 84 8b 47			.byte	$7e,$04,$cf,$08,$bb,$84,$8b,$47
>86c0	5b 00 10 88 04 cf 14 30			.byte	$5b,$00,$10,$88,$04,$cf,$14,$30
>86c8	0e b9 84 8b 45 68 fd 03			.byte	$0e,$b9,$84,$8b,$45,$68,$fd,$03
>86d0	35 00 12 92 04 cf 18 30			.byte	$35,$00,$12,$92,$04,$cf,$18,$30
>86d8	0b 07 b7 84 fe 07 50 34			.byte	$0b,$07,$b7,$84,$fe,$07,$50,$34
>86e0	44 51 41 00 0f 9c 04 cf			.byte	$44,$51,$41,$00,$0f,$9c,$04,$cf
>86e8	15 30 0d 84 8b 48 72 fd			.byte	$15,$30,$0d,$84,$8b,$48,$72,$fd
>86f0	03 30 00 12 a6 04 cf 11			.byte	$03,$30,$00,$12,$a6,$04,$cf,$11
>86f8	32 07 18 1a b9 84 8b 48			.byte	$32,$07,$18,$1a,$b9,$84,$8b,$48
>8700	41 fd 03 35 00 11 b0 04			.byte	$41,$fd,$03,$35,$00,$11,$b0,$04
>8708	cf 17 31 0e b9 84 44 79			.byte	$cf,$17,$31,$0e,$b9,$84,$44,$79
>8710	fd 05 31 32 35 00 0e ba			.byte	$fd,$05,$31,$32,$35,$00,$0e,$ba
>8718	04 cf 16 35 04 13 bb 84			.byte	$04,$cf,$16,$35,$04,$13,$bb,$84
>8720	8b 4d 79 00 0d c4 04 cf			.byte	$8b,$4d,$79,$00,$0d,$c4,$04,$cf
>8728	0a 33 0e 0e bb 84 4c 6a			.byte	$0a,$33,$0e,$0e,$bb,$84,$4c,$6a
>8730	00 0d ce 04 cf 16 35 04			.byte	$00,$0d,$ce,$04,$cf,$16,$35,$04
>8738	13 bb 84 46 55 00 12 d8			.byte	$13,$bb,$84,$46,$55,$00,$12,$d8
>8740	04 cf 13 36 0b 01 84 8b			.byte	$04,$cf,$13,$36,$0b,$01,$84,$8b
>8748	57 fd 06 38 31 32 35 00			.byte	$57,$fd,$06,$38,$31,$32,$35,$00
>8750	13 e2 04 cf 11 37 0b 17			.byte	$13,$e2,$04,$cf,$11,$37,$0b,$17
>8758	16 b7 84 fe 07 43 30 57			.byte	$16,$b7,$84,$fe,$07,$43,$30,$57
>8760	4c 58 00 0e ec 04 cf 17			.byte	$4c,$58,$00,$0e,$ec,$04,$cf,$17
>8768	b7 84 fe 06 49 36 51 46			.byte	$b7,$84,$fe,$06,$49,$36,$51,$46
>8770	00 12 f6 04 cf 02 34 17			.byte	$00,$12,$f6,$04,$cf,$02,$34,$17
>8778	b9 84 8b 45 5f fd 05 31			.byte	$b9,$84,$8b,$45,$5f,$fd,$05,$31
>8780	32 35 00 0b 00 05 cf 0d			.byte	$32,$35,$00,$0b,$00,$05,$cf,$0d
>8788	bc 40 be 84 65 00 13 0a			.byte	$bc,$40,$be,$84,$65,$00,$13,$0a
>8790	05 cf 02 34 17 b9 84 8b			.byte	$05,$cf,$02,$34,$17,$b9,$84,$8b
>8798	45 7a fd 06 34 33 37 35			.byte	$45,$7a,$fd,$06,$34,$33,$37,$35
>87a0	00 13 14 05 cf 18 30 1a			.byte	$00,$13,$14,$05,$cf,$18,$30,$1a
>87a8	15 0a b8 42 bf 40 be 84			.byte	$15,$0a,$b8,$42,$bf,$40,$be,$84
>87b0	fe 03 57 00 0c 1e 05 cf			.byte	$fe,$03,$57,$00,$0c,$1e,$05,$cf
>87b8	0d bc 40 be 84 8b 49 00			.byte	$0d,$bc,$40,$be,$84,$8b,$49,$00
>87c0	0d 28 05 cf 02 39 05 b7			.byte	$0d,$28,$05,$cf,$02,$39,$05,$b7
>87c8	84 fe 03 56 00 12 32 05			.byte	$84,$fe,$03,$56,$00,$12,$32,$05
>87d0	cf 14 39 14 1a b7 84 fe			.byte	$cf,$14,$39,$14,$1a,$b7,$84,$fe
>87d8	07 43 31 4f 4a 55 00 0e			.byte	$07,$43,$31,$4f,$4a,$55,$00,$0e
>87e0	3c 05 cf 01 b9 84 8b 46			.byte	$3c,$05,$cf,$01,$b9,$84,$8b,$46
>87e8	54 fd 03 35 00 0d 46 05			.byte	$54,$fd,$03,$35,$00,$0d,$46,$05
>87f0	cf 11 34 02 bb 84 8b 41			.byte	$cf,$11,$34,$02,$bb,$84,$8b,$41
>87f8	65 00 0d 50 05 cf 16 39			.byte	$65,$00,$0d,$50,$05,$cf,$16,$39
>8800	06 b7 84 fe 03 5a 00 0b			.byte	$06,$b7,$84,$fe,$03,$5a,$00,$0b
>8808	5a 05 cf 0f b7 84 fe 03			.byte	$5a,$05,$cf,$0f,$b7,$84,$fe,$03
>8810	55 00 15 64 05 cf 18 34			.byte	$55,$00,$15,$64,$05,$cf,$18,$34
>8818	06 13 ba 41 be 84 48 42			.byte	$06,$13,$ba,$41,$be,$84,$48,$42
>8820	fd 06 38 31 32 35 00 11			.byte	$fd,$06,$38,$31,$32,$35,$00,$11
>8828	6e 05 cf 12 38 19 84 48			.byte	$6e,$05,$cf,$12,$38,$19,$84,$48
>8830	44 fd 06 31 38 37 35 00			.byte	$44,$fd,$06,$31,$38,$37,$35,$00
>8838	11 78 05 cf 04 32 06 14			.byte	$11,$78,$05,$cf,$04,$32,$06,$14
>8840	b7 84 fe 06 49 33 47 41			.byte	$b7,$84,$fe,$06,$49,$33,$47,$41
>8848	00 11 82 05 cf 04 30 15			.byte	$00,$11,$82,$05,$cf,$04,$30,$15
>8850	07 16 bc 42 be 84 8b 47			.byte	$07,$16,$bc,$42,$be,$84,$8b,$47
>8858	65 00 12 8c 05 cf 07 36			.byte	$65,$00,$12,$8c,$05,$cf,$07,$36
>8860	02 14 14 b9 84 47 59 fd			.byte	$02,$14,$14,$b9,$84,$47,$59,$fd
>8868	04 37 35 00 12 96 05 cf			.byte	$04,$37,$35,$00,$12,$96,$05,$cf
>8870	0c 39 12 11 b7 84 fe 07			.byte	$0c,$39,$12,$11,$b7,$84,$fe,$07
>8878	54 31 4b 44 53 00 11 a0			.byte	$54,$31,$4b,$44,$53,$00,$11,$a0
>8880	05 cf 08 30 14 06 11 84			.byte	$05,$cf,$08,$30,$14,$06,$11,$84
>8888	42 45 fd 04 32 35 00 10			.byte	$42,$45,$fd,$04,$32,$35,$00,$10
>8890	aa 05 cf 0c 34 05 b7 84			.byte	$aa,$05,$cf,$0c,$34,$05,$b7,$84
>8898	fe 06 43 38 4d 58 00 0d			.byte	$fe,$06,$43,$38,$4d,$58,$00,$0d
>88a0	b4 05 cf 17 35 15 bb 84			.byte	$b4,$05,$cf,$17,$35,$15,$bb,$84
>88a8	8b 49 5d 00 10 be 05 cf			.byte	$8b,$49,$5d,$00,$10,$be,$05,$cf
>88b0	13 36 0b 01 84 45 61 fd			.byte	$13,$36,$0b,$01,$84,$45,$61,$fd
>88b8	04 37 35 00 10 c8 05 cf			.byte	$04,$37,$35,$00,$10,$c8,$05,$cf
>88c0	04 30 15 07 16 bc 42 be			.byte	$04,$30,$15,$07,$16,$bc,$42,$be
>88c8	84 4a 7e 00 0f d2 05 cf			.byte	$84,$4a,$7e,$00,$0f,$d2,$05,$cf
>88d0	1a 37 1a bc 40 be 84 8b			.byte	$1a,$37,$1a,$bc,$40,$be,$84,$8b
>88d8	48 4b 00 0c dc 05 cf 16			.byte	$48,$4b,$00,$0c,$dc,$05,$cf,$16
>88e0	35 04 13 bb 84 7f 00 16			.byte	$35,$04,$13,$bb,$84,$7f,$00,$16
>88e8	e6 05 cf 03 30 0b 0b 10			.byte	$e6,$05,$cf,$03,$30,$0b,$0b,$10
>88f0	bd 42 be 84 46 7c fd 06			.byte	$bd,$42,$be,$84,$46,$7c,$fd,$06
>88f8	30 36 32 35 00 0f f0 05			.byte	$30,$36,$32,$35,$00,$0f,$f0,$05
>8900	cf 10 84 8b 42 44 fd 05			.byte	$cf,$10,$84,$8b,$42,$44,$fd,$05
>8908	31 32 35 00 0e fa 05 cf			.byte	$31,$32,$35,$00,$0e,$fa,$05,$cf
>8910	17 39 1a 07 bb 84 8b 41			.byte	$17,$39,$1a,$07,$bb,$84,$8b,$41
>8918	74 00 0e 04 06 cf 0a 33			.byte	$74,$00,$0e,$04,$06,$cf,$0a,$33
>8920	0e 0e bb 84 8b 41 47 00			.byte	$0e,$0e,$bb,$84,$8b,$41,$47,$00
>8928	11 0e 06 cf 11 37 0b 17			.byte	$11,$0e,$06,$cf,$11,$37,$0b,$17
>8930	16 b7 84 fe 05 56 31 54			.byte	$16,$b7,$84,$fe,$05,$56,$31,$54
>8938	00 13 18 06 cf 05 30 07			.byte	$00,$13,$18,$06,$cf,$05,$30,$07
>8940	18 b9 84 43 50 fd 06 31			.byte	$18,$b9,$84,$43,$50,$fd,$06,$31
>8948	38 37 35 00 0b 22 06 cf			.byte	$38,$37,$35,$00,$0b,$22,$06,$cf
>8950	17 b7 84 fe 03 4e 00 0b			.byte	$17,$b7,$84,$fe,$03,$4e,$00,$0b
>8958	2c 06 cf 0e b7 84 fe 03			.byte	$2c,$06,$cf,$0e,$b7,$84,$fe,$03
>8960	4f 00 12 36 06 cf 08 30			.byte	$4f,$00,$12,$36,$06,$cf,$08,$30
>8968	14 06 11 84 43 60 fd 05			.byte	$14,$06,$11,$84,$43,$60,$fd,$05
>8970	36 32 35 00 12 40 06 cf			.byte	$36,$32,$35,$00,$12,$40,$06,$cf
>8978	13 36 0e 08 b7 84 fe 07			.byte	$13,$36,$0e,$08,$b7,$84,$fe,$07
>8980	47 34 45 4f 51 00 11 4a			.byte	$47,$34,$45,$4f,$51,$00,$11,$4a
>8988	06 cf 08 35 16 03 b7 84			.byte	$06,$cf,$08,$35,$16,$03,$b7,$84
>8990	fe 06 45 31 4a 45 00 11			.byte	$fe,$06,$45,$31,$4a,$45,$00,$11
>8998	54 06 cf 0a 30 10 05 07			.byte	$54,$06,$cf,$0a,$30,$10,$05,$07
>89a0	b7 84 fe 05 55 34 55 00			.byte	$b7,$84,$fe,$05,$55,$34,$55,$00
>89a8	13 5e 06 cf 11 bd 40 be			.byte	$13,$5e,$06,$cf,$11,$bd,$40,$be
>89b0	84 8b 48 43 fd 06 33 31			.byte	$84,$8b,$48,$43,$fd,$06,$33,$31
>89b8	32 35 00 11 68 06 cf 06			.byte	$32,$35,$00,$11,$68,$06,$cf,$06
>89c0	30 18 16 09 bc 41 be 84			.byte	$30,$18,$16,$09,$bc,$41,$be,$84
>89c8	8b 49 50 00 0d 72 06 cf			.byte	$8b,$49,$50,$00,$0d,$72,$06,$cf
>89d0	0f 36 15 b7 84 fe 03 55			.byte	$0f,$36,$15,$b7,$84,$fe,$03,$55
>89d8	00 13 7c 06 cf 06 33 07			.byte	$00,$13,$7c,$06,$cf,$06,$33,$07
>89e0	0c b9 84 42 47 fd 06 30			.byte	$0c,$b9,$84,$42,$47,$fd,$06,$30
>89e8	36 32 35 00 0e 86 06 cf			.byte	$36,$32,$35,$00,$0e,$86,$06,$cf
>89f0	13 35 04 18 bb 84 8b 46			.byte	$13,$35,$04,$18,$bb,$84,$8b,$46
>89f8	7f 00 0c 90 06 cf 06 32			.byte	$7f,$00,$0c,$90,$06,$cf,$06,$32
>8a00	02 bb 84 45 46 00 0d 9a			.byte	$02,$bb,$84,$45,$46,$00,$0d,$9a
>8a08	06 cf 15 b9 84 45 5c fd			.byte	$06,$cf,$15,$b9,$84,$45,$5c,$fd
>8a10	03 30 00 14 a4 06 cf 0f			.byte	$03,$30,$00,$14,$a4,$06,$cf,$0f
>8a18	37 16 14 0a b9 84 41 7e			.byte	$37,$16,$14,$0a,$b9,$84,$41,$7e
>8a20	fd 06 39 33 37 35 00 11			.byte	$fd,$06,$39,$33,$37,$35,$00,$11
>8a28	ae 06 cf 17 33 03 b9 84			.byte	$ae,$06,$cf,$17,$33,$03,$b9,$84
>8a30	45 45 fd 05 33 37 35 00			.byte	$45,$45,$fd,$05,$33,$37,$35,$00
>8a38	0d b8 06 cf 17 b7 84 fe			.byte	$0d,$b8,$06,$cf,$17,$b7,$84,$fe
>8a40	05 56 37 55 00 11 c2 06			.byte	$05,$56,$37,$55,$00,$11,$c2,$06
>8a48	cf 14 30 0e b9 84 42 fd			.byte	$cf,$14,$30,$0e,$b9,$84,$42,$fd
>8a50	06 33 31 32 35 00 0f cc			.byte	$06,$33,$31,$32,$35,$00,$0f,$cc
>8a58	06 cf 17 31 0e b9 84 48			.byte	$06,$cf,$17,$31,$0e,$b9,$84,$48
>8a60	45 fd 03 35 00 15 d6 06			.byte	$45,$fd,$03,$35,$00,$15,$d6,$06
>8a68	cf 03 30 0b 0b 10 bd 40			.byte	$cf,$03,$30,$0b,$0b,$10,$bd,$40
>8a70	be 84 48 43 fd 05 31 32			.byte	$be,$84,$48,$43,$fd,$05,$31,$32
>8a78	35 00 10 e0 06 cf 04 32			.byte	$35,$00,$10,$e0,$06,$cf,$04,$32
>8a80	0a b7 84 fe 06 54 32 45			.byte	$0a,$b7,$84,$fe,$06,$54,$32,$45
>8a88	4f 00 11 ea 06 cf 09 33			.byte	$4f,$00,$11,$ea,$06,$cf,$09,$33
>8a90	07 b7 84 fe 07 52 35 59			.byte	$07,$b7,$84,$fe,$07,$52,$35,$59
>8a98	57 41 00 13 f4 06 cf 03			.byte	$57,$41,$00,$13,$f4,$06,$cf,$03
>8aa0	30 0b 0b 10 bd 40 be 84			.byte	$30,$0b,$0b,$10,$bd,$40,$be,$84
>8aa8	46 5b fd 03 30 00 0f fe			.byte	$46,$5b,$fd,$03,$30,$00,$0f,$fe
>8ab0	06 cf 17 32 04 b7 84 fe			.byte	$06,$cf,$17,$32,$04,$b7,$84,$fe
>8ab8	05 47 33 42 00 10 08 07			.byte	$05,$47,$33,$42,$00,$10,$08,$07
>8ac0	cf 10 84 8b 41 61 fd 06			.byte	$cf,$10,$84,$8b,$41,$61,$fd,$06
>8ac8	31 38 37 35 00 0e 12 07			.byte	$31,$38,$37,$35,$00,$0e,$12,$07
>8ad0	cf 0a b7 84 fe 06 49 32			.byte	$cf,$0a,$b7,$84,$fe,$06,$49,$32
>8ad8	56 41 00 0f 1c 07 cf 0f			.byte	$56,$41,$00,$0f,$1c,$07,$cf,$0f
>8ae0	36 15 b7 84 fe 05 47 35			.byte	$36,$15,$b7,$84,$fe,$05,$47,$35
>8ae8	4c 00 12 26 07 cf 12 38			.byte	$4c,$00,$12,$26,$07,$cf,$12,$38
>8af0	16 84 8b 41 4f fd 06 34			.byte	$16,$84,$8b,$41,$4f,$fd,$06,$34
>8af8	33 37 35 00 0e 30 07 cf			.byte	$33,$37,$35,$00,$0e,$30,$07,$cf
>8b00	0a 33 0e 0e bb 84 8b 4e			.byte	$0a,$33,$0e,$0e,$bb,$84,$8b,$4e
>8b08	6f 00 0f 3a 07 cf 12 31			.byte	$6f,$00,$0f,$3a,$07,$cf,$12,$31
>8b10	17 11 0c bb 84 8b 43 44			.byte	$17,$11,$0c,$bb,$84,$8b,$43,$44
>8b18	00 0c 44 07 cf 0e 38 14			.byte	$00,$0c,$44,$07,$cf,$0e,$38,$14
>8b20	bb 84 4e 53 00 11 4e 07			.byte	$bb,$84,$4e,$53,$00,$11,$4e,$07
>8b28	cf 0c 39 12 11 b7 84 fe			.byte	$cf,$0c,$39,$12,$11,$b7,$84,$fe
>8b30	06 44 34 50 44 00 0f 58			.byte	$06,$44,$34,$50,$44,$00,$0f,$58
>8b38	07 cf 04 30 14 1a 06 b7			.byte	$07,$cf,$04,$30,$14,$1a,$06,$b7
>8b40	84 fe 03 4a 00 0e 62 07			.byte	$84,$fe,$03,$4a,$00,$0e,$62,$07
>8b48	cf 15 b9 84 45 72 fd 04			.byte	$cf,$15,$b9,$84,$45,$72,$fd,$04
>8b50	32 35 00 17 6c 07 cf 18			.byte	$32,$35,$00,$17,$6c,$07,$cf,$18
>8b58	34 14 ba 40 bf 40 be 84			.byte	$34,$14,$ba,$40,$bf,$40,$be,$84
>8b60	8b 44 73 fd 06 35 36 32			.byte	$8b,$44,$73,$fd,$06,$35,$36,$32
>8b68	35 00 15 76 07 cf 07 36			.byte	$35,$00,$15,$76,$07,$cf,$07,$36
>8b70	02 14 14 b9 84 8b 45 69			.byte	$02,$14,$14,$b9,$84,$8b,$45,$69
>8b78	fd 06 36 38 37 35 00 0d			.byte	$fd,$06,$36,$38,$37,$35,$00,$0d
>8b80	80 07 cf 01 b9 84 48 52			.byte	$80,$07,$cf,$01,$b9,$84,$48,$52
>8b88	fd 03 35 00 0d 8a 07 cf			.byte	$fd,$03,$35,$00,$0d,$8a,$07,$cf
>8b90	1a 36 17 bb 84 8b 46 48			.byte	$1a,$36,$17,$bb,$84,$8b,$46,$48
>8b98	00 12 94 07 cf 0a 30 0d			.byte	$00,$12,$94,$07,$cf,$0a,$30,$0d
>8ba0	01 01 84 8b 41 49 fd 04			.byte	$01,$01,$84,$8b,$41,$49,$fd,$04
>8ba8	37 35 00 14 9e 07 cf 13			.byte	$37,$35,$00,$14,$9e,$07,$cf,$13
>8bb0	38 07 0b 18 b9 84 44 69			.byte	$38,$07,$0b,$18,$b9,$84,$44,$69
>8bb8	fd 06 34 33 37 35 00 0d			.byte	$fd,$06,$34,$33,$37,$35,$00,$0d
>8bc0	a8 07 cf 0c 39 12 11 b7			.byte	$a8,$07,$cf,$0c,$39,$12,$11,$b7
>8bc8	84 fe 02 00 0e b2 07 cf			.byte	$84,$fe,$02,$00,$0e,$b2,$07,$cf
>8bd0	0e b7 84 fe 06 44 34 54			.byte	$0e,$b7,$84,$fe,$06,$44,$34,$54
>8bd8	52 00 12 bc 07 cf 12 33			.byte	$52,$00,$12,$bc,$07,$cf,$12,$33
>8be0	12 b9 84 8b 43 40 fd 05			.byte	$12,$b9,$84,$8b,$43,$40,$fd,$05
>8be8	38 37 35 00 0e c6 07 cf			.byte	$38,$37,$35,$00,$0e,$c6,$07,$cf
>8bf0	12 38 16 84 8b 7d fd 03			.byte	$12,$38,$16,$84,$8b,$7d,$fd,$03
>8bf8	35 00 11 d0 07 cf 14 39			.byte	$35,$00,$11,$d0,$07,$cf,$14,$39
>8c00	14 1a b7 84 fe 06 52 33			.byte	$14,$1a,$b7,$84,$fe,$06,$52,$33
>8c08	51 56 00 0c da 07 cf 11			.byte	$51,$56,$00,$0c,$da,$07,$cf,$11
>8c10	34 02 bb 84 4c 7b 00 0d			.byte	$34,$02,$bb,$84,$4c,$7b,$00,$0d
>8c18	e4 07 cf 05 30 06 bb 84			.byte	$e4,$07,$cf,$05,$30,$06,$bb,$84
>8c20	8b 43 76 00 0d ee 07 cf			.byte	$8b,$43,$76,$00,$0d,$ee,$07,$cf
>8c28	02 33 17 16 bb 84 41 4a			.byte	$02,$33,$17,$16,$bb,$84,$41,$4a
>8c30	00 11 f8 07 cf 04 30 15			.byte	$00,$11,$f8,$07,$cf,$04,$30,$15
>8c38	07 16 bc 41 be 84 8b 45			.byte	$07,$16,$bc,$41,$be,$84,$8b,$45
>8c40	45 00 12 02 08 cf 13 36			.byte	$45,$00,$12,$02,$08,$cf,$13,$36
>8c48	0b 01 84 42 5e fd 06 31			.byte	$0b,$01,$84,$42,$5e,$fd,$06,$31
>8c50	38 37 35 00 0d 0c 08 cf			.byte	$38,$37,$35,$00,$0d,$0c,$08,$cf
>8c58	02 33 17 16 bb 84 4b 45			.byte	$02,$33,$17,$16,$bb,$84,$4b,$45
>8c60	00 0f 16 08 cf 11 bd 41			.byte	$00,$0f,$16,$08,$cf,$11,$bd,$41
>8c68	be 84 44 55 fd 03 35 00			.byte	$be,$84,$44,$55,$fd,$03,$35,$00
>8c70	12 20 08 cf 0b 34 09 b9			.byte	$12,$20,$08,$cf,$0b,$34,$09,$b9
>8c78	84 46 7c fd 06 35 36 32			.byte	$84,$46,$7c,$fd,$06,$35,$36,$32
>8c80	35 00 0d 2a 08 cf 06 32			.byte	$35,$00,$0d,$2a,$08,$cf,$06,$32
>8c88	02 bb 84 8b 41 52 00 10			.byte	$02,$bb,$84,$8b,$41,$52,$00,$10
>8c90	34 08 cf 19 32 02 12 84			.byte	$34,$08,$cf,$19,$32,$02,$12,$84
>8c98	8b 48 64 fd 03 30 00 13			.byte	$8b,$48,$64,$fd,$03,$30,$00,$13
>8ca0	3e 08 cf 07 36 11 05 84			.byte	$3e,$08,$cf,$07,$36,$11,$05,$84
>8ca8	8b 46 45 fd 06 36 38 37			.byte	$8b,$46,$45,$fd,$06,$36,$38,$37
>8cb0	35 00 0b 48 08 cf 0f b7			.byte	$35,$00,$0b,$48,$08,$cf,$0f,$b7
>8cb8	84 fe 03 44 00 12 52 08			.byte	$84,$fe,$03,$44,$00,$12,$52,$08
>8cc0	dc 13 36 0e 08 b7 84 fe			.byte	$dc,$13,$36,$0e,$08,$b7,$84,$fe
>8cc8	07 47 34 45 4f 51 00 0d			.byte	$07,$47,$34,$45,$4f,$51,$00,$0d
>8cd0	5c 08 dc 02 39 05 b7 84			.byte	$5c,$08,$dc,$02,$39,$05,$b7,$84
>8cd8	fe 03 56 00 0e 66 08 dc			.byte	$fe,$03,$56,$00,$0e,$66,$08,$dc
>8ce0	06 b7 84 fe 06 42 34 4c			.byte	$06,$b7,$84,$fe,$06,$42,$34,$4c
>8ce8	56 00 0f 70 08 dc 12 31			.byte	$56,$00,$0f,$70,$08,$dc,$12,$31
>8cf0	17 11 0c bb 84 8b 43 44			.byte	$17,$11,$0c,$bb,$84,$8b,$43,$44
>8cf8	00 0e 7a 08 dc 0e b7 84			.byte	$00,$0e,$7a,$08,$dc,$0e,$b7,$84
>8d00	fe 06 44 34 54 52 00 12			.byte	$fe,$06,$44,$34,$54,$52,$00,$12
>8d08	84 08 dc 0b 34 09 b9 84			.byte	$84,$08,$dc,$0b,$34,$09,$b9,$84
>8d10	46 7c fd 06 35 36 32 35			.byte	$46,$7c,$fd,$06,$35,$36,$32,$35
>8d18	00 0d 8e 08 dc 05 30 06			.byte	$00,$0d,$8e,$08,$dc,$05,$30,$06
>8d20	bb 84 8b 43 76 00 13 98			.byte	$bb,$84,$8b,$43,$76,$00,$13,$98
>8d28	08 dc 14 34 04 01 84 8b			.byte	$08,$dc,$14,$34,$04,$01,$84,$8b
>8d30	48 5a fd 06 39 33 37 35			.byte	$48,$5a,$fd,$06,$39,$33,$37,$35
>8d38	00 0b a2 08 dc 0f b7 84			.byte	$00,$0b,$a2,$08,$dc,$0f,$b7,$84
>8d40	fe 03 44 00 0c ac 08 dc			.byte	$fe,$03,$44,$00,$0c,$ac,$08,$dc
>8d48	0f 37 15 0b bb 84 40 00			.byte	$0f,$37,$15,$0b,$bb,$84,$40,$00
>8d50	0d b6 08 dc 01 b9 84 48			.byte	$0d,$b6,$08,$dc,$01,$b9,$84,$48
>8d58	52 fd 03 35 00 12 c0 08			.byte	$52,$fd,$03,$35,$00,$12,$c0,$08
>8d60	dc 11 32 07 18 1a b9 84			.byte	$dc,$11,$32,$07,$18,$1a,$b9,$84
>8d68	8b 48 41 fd 03 35 00 11			.byte	$8b,$48,$41,$fd,$03,$35,$00,$11
>8d70	ca 08 dc 17 33 03 b9 84			.byte	$ca,$08,$dc,$17,$33,$03,$b9,$84
>8d78	45 45 fd 05 33 37 35 00			.byte	$45,$45,$fd,$05,$33,$37,$35,$00
>8d80	09 d4 08 dc 04 bb 84 40			.byte	$09,$d4,$08,$dc,$04,$bb,$84,$40
>8d88	00 0d de 08 dc 1a 36 17			.byte	$00,$0d,$de,$08,$dc,$1a,$36,$17
>8d90	bb 84 8b 46 48 00 0c e8			.byte	$bb,$84,$8b,$46,$48,$00,$0c,$e8
>8d98	08 dc 02 b7 84 fe 04 4b			.byte	$08,$dc,$02,$b7,$84,$fe,$04,$4b
>8da0	37 00 0b f2 08 dc 07 b7			.byte	$37,$00,$0b,$f2,$08,$dc,$07,$b7
>8da8	84 fe 03 48 00 11 fc 08			.byte	$84,$fe,$03,$48,$00,$11,$fc,$08
>8db0	dc 09 33 07 b7 84 fe 07			.byte	$dc,$09,$33,$07,$b7,$84,$fe,$07
>8db8	52 35 59 57 41 00 0c 06			.byte	$52,$35,$59,$57,$41,$00,$0c,$06
>8dc0	09 dc 04 34 07 b7 84 fe			.byte	$09,$dc,$04,$34,$07,$b7,$84,$fe
>8dc8	02 00 12 10 09 dc 12 37			.byte	$02,$00,$12,$10,$09,$dc,$12,$37
>8dd0	1a 84 8b 42 66 fd 06 39			.byte	$1a,$84,$8b,$42,$66,$fd,$06,$39
>8dd8	33 37 35 00 0b 1a 09 dc			.byte	$33,$37,$35,$00,$0b,$1a,$09,$dc
>8de0	0f 39 0c b9 84 40 00 12			.byte	$0f,$39,$0c,$b9,$84,$40,$00,$12
>8de8	24 09 dc 13 36 0b 01 84			.byte	$24,$09,$dc,$13,$36,$0b,$01,$84
>8df0	42 5e fd 06 31 38 37 35			.byte	$42,$5e,$fd,$06,$31,$38,$37,$35
>8df8	00 11 2e 09 dc 08 35 16			.byte	$00,$11,$2e,$09,$dc,$08,$35,$16
>8e00	03 b7 84 fe 06 45 31 4a			.byte	$03,$b7,$84,$fe,$06,$45,$31,$4a
>8e08	45 00 0c 38 09 dc 03 32			.byte	$45,$00,$0c,$38,$09,$dc,$03,$32
>8e10	0c b7 84 fe 02 00 0e 42			.byte	$0c,$b7,$84,$fe,$02,$00,$0e,$42
>8e18	09 dc 13 35 04 18 bb 84			.byte	$09,$dc,$13,$35,$04,$18,$bb,$84
>8e20	8b 46 7f 00 09 4c 09 dc			.byte	$8b,$46,$7f,$00,$09,$4c,$09,$dc
>8e28	13 bb 84 40 00 0b 56 09			.byte	$13,$bb,$84,$40,$00,$0b,$56,$09
>8e30	dc 06 30 02 b9 84 40 00			.byte	$dc,$06,$30,$02,$b9,$84,$40,$00
>8e38	0d 60 09 dc 06 32 02 bb			.byte	$0d,$60,$09,$dc,$06,$32,$02,$bb
>8e40	84 8b 41 52 00 11 6a 09			.byte	$84,$8b,$41,$52,$00,$11,$6a,$09
>8e48	dc 14 30 0e b9 84 42 fd			.byte	$dc,$14,$30,$0e,$b9,$84,$42,$fd
>8e50	06 33 31 32 35 00 0b 74			.byte	$06,$33,$31,$32,$35,$00,$0b,$74
>8e58	09 dc 08 30 02 05 84 40			.byte	$09,$dc,$08,$30,$02,$05,$84,$40
>8e60	00 11 7e 09 dc 0a 30 10			.byte	$00,$11,$7e,$09,$dc,$0a,$30,$10
>8e68	05 07 b7 84 fe 05 55 34			.byte	$05,$07,$b7,$84,$fe,$05,$55,$34
>8e70	55 00 10 88 09 dc 0c 34			.byte	$55,$00,$10,$88,$09,$dc,$0c,$34
>8e78	05 b7 84 fe 06 43 38 4d			.byte	$05,$b7,$84,$fe,$06,$43,$38,$4d
>8e80	58 00 10 92 09 dc 10 84			.byte	$58,$00,$10,$92,$09,$dc,$10,$84
>8e88	8b 41 61 fd 06 31 38 37			.byte	$8b,$41,$61,$fd,$06,$31,$38,$37
>8e90	35 00 0d 9c 09 dc 06 38			.byte	$35,$00,$0d,$9c,$09,$dc,$06,$38
>8e98	18 1a 02 bb 84 40 00 11			.byte	$18,$1a,$02,$bb,$84,$40,$00,$11
>8ea0	a6 09 dc 04 37 09 17 05			.byte	$a6,$09,$dc,$04,$37,$09,$17,$05
>8ea8	b7 84 fe 05 4e 39 41 00			.byte	$b7,$84,$fe,$05,$4e,$39,$41,$00
>8eb0	0e b0 09 dc 17 39 1a 07			.byte	$0e,$b0,$09,$dc,$17,$39,$1a,$07
>8eb8	bb 84 8b 41 74 00 0c ba			.byte	$bb,$84,$8b,$41,$74,$00,$0c,$ba
>8ec0	09 dc 11 34 02 bb 84 4c			.byte	$09,$dc,$11,$34,$02,$bb,$84,$4c
>8ec8	7b 00 10 c4 09 dc 19 32			.byte	$7b,$00,$10,$c4,$09,$dc,$19,$32
>8ed0	02 12 84 8b 48 64 fd 03			.byte	$02,$12,$84,$8b,$48,$64,$fd,$03
>8ed8	30 00 0e ce 09 dc 0a 33			.byte	$30,$00,$0e,$ce,$09,$dc,$0a,$33
>8ee0	0e 0e bb 84 8b 4e 6f 00			.byte	$0e,$0e,$bb,$84,$8b,$4e,$6f,$00
>8ee8	0c d8 09 dc 0e 38 14 bb			.byte	$0c,$d8,$09,$dc,$0e,$38,$14,$bb
>8ef0	84 4e 53 00 13 e2 09 dc			.byte	$84,$4e,$53,$00,$13,$e2,$09,$dc
>8ef8	07 36 11 05 84 8b 46 45			.byte	$07,$36,$11,$05,$84,$8b,$46,$45
>8f00	fd 06 36 38 37 35 00 0b			.byte	$fd,$06,$36,$38,$37,$35,$00,$0b
>8f08	ec 09 dc 06 33 01 b9 84			.byte	$ec,$09,$dc,$06,$33,$01,$b9,$84
>8f10	40 00 0b f6 09 dc 09 34			.byte	$40,$00,$0b,$f6,$09,$dc,$09,$34
>8f18	19 bb 84 40 00 0d 00 0a			.byte	$19,$bb,$84,$40,$00,$0d,$00,$0a
>8f20	dc 0c 39 12 11 b7 84 fe			.byte	$dc,$0c,$39,$12,$11,$b7,$84,$fe
>8f28	02 00 0e 0a 0a dc 12 38			.byte	$02,$00,$0e,$0a,$0a,$dc,$12,$38
>8f30	16 84 8b 7d fd 03 35 00			.byte	$16,$84,$8b,$7d,$fd,$03,$35,$00
>8f38	0b 14 0a dc 08 bb 84 8b			.byte	$0b,$14,$0a,$dc,$08,$bb,$84,$8b
>8f40	47 5b 00 10 1e 0a dc 15			.byte	$47,$5b,$00,$10,$1e,$0a,$dc,$15
>8f48	33 0e 84 49 56 fd 05 36			.byte	$33,$0e,$84,$49,$56,$fd,$05,$36
>8f50	32 35 00 0b 28 0a dc 19			.byte	$32,$35,$00,$0b,$28,$0a,$dc,$19
>8f58	bb 84 8b 46 74 00 0c 32			.byte	$bb,$84,$8b,$46,$74,$00,$0c,$32
>8f60	0a dc 10 30 18 14 b9 84			.byte	$0a,$dc,$10,$30,$18,$14,$b9,$84
>8f68	40 00 13 3c 0a dc 02 37			.byte	$40,$00,$13,$3c,$0a,$dc,$02,$37
>8f70	0e 1a b9 84 46 7d fd 06			.byte	$0e,$1a,$b9,$84,$46,$7d,$fd,$06
>8f78	31 38 37 35 00 13 46 0a			.byte	$31,$38,$37,$35,$00,$13,$46,$0a
>8f80	dc 02 34 17 b9 84 8b 45			.byte	$dc,$02,$34,$17,$b9,$84,$8b,$45
>8f88	7a fd 06 34 33 37 35 00			.byte	$7a,$fd,$06,$34,$33,$37,$35,$00
>8f90	0d 50 0a dc 17 b7 84 fe			.byte	$0d,$50,$0a,$dc,$17,$b7,$84,$fe
>8f98	05 56 37 55 00 0d 5a 0a			.byte	$05,$56,$37,$55,$00,$0d,$5a,$0a
>8fa0	dc 0b 38 18 07 12 b9 84			.byte	$dc,$0b,$38,$18,$07,$12,$b9,$84
>8fa8	40 00 12 64 0a dc 08 30			.byte	$40,$00,$12,$64,$0a,$dc,$08,$30
>8fb0	14 06 11 84 43 60 fd 05			.byte	$14,$06,$11,$84,$43,$60,$fd,$05
>8fb8	36 32 35 00 13 6e 0a dc			.byte	$36,$32,$35,$00,$13,$6e,$0a,$dc
>8fc0	06 33 07 0c b9 84 42 47			.byte	$06,$33,$07,$0c,$b9,$84,$42,$47
>8fc8	fd 06 30 36 32 35 00 0c			.byte	$fd,$06,$30,$36,$32,$35,$00,$0c
>8fd0	78 0a dc 16 35 04 13 bb			.byte	$78,$0a,$dc,$16,$35,$04,$13,$bb
>8fd8	84 7f 00 10 82 0a dc 04			.byte	$84,$7f,$00,$10,$82,$0a,$dc,$04
>8fe0	32 0a b7 84 fe 06 54 32			.byte	$32,$0a,$b7,$84,$fe,$06,$54,$32
>8fe8	45 4f 00 15 8c 0a dc 07			.byte	$45,$4f,$00,$15,$8c,$0a,$dc,$07
>8ff0	36 02 14 14 b9 84 8b 45			.byte	$36,$02,$14,$14,$b9,$84,$8b,$45
>8ff8	69 fd 06 36 38 37 35 00			.byte	$69,$fd,$06,$36,$38,$37,$35,$00
>9000	11 96 0a dc 11 37 0b 17			.byte	$11,$96,$0a,$dc,$11,$37,$0b,$17
>9008	16 b7 84 fe 05 56 31 54			.byte	$16,$b7,$84,$fe,$05,$56,$31,$54
>9010	00 13 a0 0a dc 05 30 07			.byte	$00,$13,$a0,$0a,$dc,$05,$30,$07
>9018	18 b9 84 43 50 fd 06 31			.byte	$18,$b9,$84,$43,$50,$fd,$06,$31
>9020	38 37 35 00 0e aa 0a dc			.byte	$38,$37,$35,$00,$0e,$aa,$0a,$dc
>9028	15 b9 84 45 72 fd 04 32			.byte	$15,$b9,$84,$45,$72,$fd,$04,$32
>9030	35 00 0a b4 0a dc 05 b7			.byte	$35,$00,$0a,$b4,$0a,$dc,$05,$b7
>9038	84 fe 02 00 13 be 0a dc			.byte	$84,$fe,$02,$00,$13,$be,$0a,$dc
>9040	07 35 0c b9 84 8b 41 60			.byte	$07,$35,$0c,$b9,$84,$8b,$41,$60
>9048	fd 06 33 31 32 35 00 0d			.byte	$fd,$06,$33,$31,$32,$35,$00,$0d
>9050	c8 0a dc 0e 34 0c 04 0e			.byte	$c8,$0a,$dc,$0e,$34,$0c,$04,$0e
>9058	bb 84 40 00 12 d2 0a dc			.byte	$bb,$84,$40,$00,$12,$d2,$0a,$dc
>9060	18 30 0b 07 b7 84 fe 07			.byte	$18,$30,$0b,$07,$b7,$84,$fe,$07
>9068	50 34 44 51 41 00 0d dc			.byte	$50,$34,$44,$51,$41,$00,$0d,$dc
>9070	0a dc 16 39 06 b7 84 fe			.byte	$0a,$dc,$16,$39,$06,$b7,$84,$fe
>9078	03 5a 00 13 e6 0a dc 0f			.byte	$03,$5a,$00,$13,$e6,$0a,$dc,$0f
>9080	36 0a 17 84 8b 45 4b fd			.byte	$36,$0a,$17,$84,$8b,$45,$4b,$fd
>9088	06 38 31 32 35 00 0f f0			.byte	$06,$38,$31,$32,$35,$00,$0f,$f0
>9090	0a dc 17 32 04 b7 84 fe			.byte	$0a,$dc,$17,$32,$04,$b7,$84,$fe
>9098	05 47 33 42 00 0e fa 0a			.byte	$05,$47,$33,$42,$00,$0e,$fa,$0a
>90a0	dc 0a b7 84 fe 06 49 32			.byte	$dc,$0a,$b7,$84,$fe,$06,$49,$32
>90a8	56 41 00 0d 04 0b dc 10			.byte	$56,$41,$00,$0d,$04,$0b,$dc,$10
>90b0	32 11 0f b7 84 fe 02 00			.byte	$32,$11,$0f,$b7,$84,$fe,$02,$00
>90b8	0f 0e 0b dc 18 31 15 02			.byte	$0f,$0e,$0b,$dc,$18,$31,$15,$02
>90c0	05 bb 84 8b 4e 45 00 0b			.byte	$05,$bb,$84,$8b,$4e,$45,$00,$0b
>90c8	18 0b dc 16 bb 84 8b 43			.byte	$18,$0b,$dc,$16,$bb,$84,$8b,$43
>90d0	40 00 12 22 0b dc 0a 30			.byte	$40,$00,$12,$22,$0b,$dc,$0a,$30
>90d8	0d 01 01 84 8b 41 49 fd			.byte	$0d,$01,$01,$84,$8b,$41,$49,$fd
>90e0	04 37 35 00 0d 2c 0b dc			.byte	$04,$37,$35,$00,$0d,$2c,$0b,$dc
>90e8	11 32 09 0b b7 84 fe 02			.byte	$11,$32,$09,$0b,$b7,$84,$fe,$02
>90f0	00 11 36 0b dc 14 39 14			.byte	$00,$11,$36,$0b,$dc,$14,$39,$14
>90f8	1a b7 84 fe 06 52 33 51			.byte	$1a,$b7,$84,$fe,$06,$52,$33,$51
>9100	56 00 13 40 0b dc 05 34			.byte	$56,$00,$13,$40,$0b,$dc,$05,$34
>9108	19 03 b9 84 46 69 fd 06			.byte	$19,$03,$b9,$84,$46,$69,$fd,$06
>9110	30 36 32 35 00 12 4a 0b			.byte	$30,$36,$32,$35,$00,$12,$4a,$0b
>9118	dc 12 33 12 b9 84 8b 43			.byte	$dc,$12,$33,$12,$b9,$84,$8b,$43
>9120	40 fd 05 38 37 35 00 0f			.byte	$40,$fd,$05,$38,$37,$35,$00,$0f
>9128	54 0b dc 17 31 0e b9 84			.byte	$54,$0b,$dc,$17,$31,$0e,$b9,$84
>9130	48 45 fd 03 35 00 15 5e			.byte	$48,$45,$fd,$03,$35,$00,$15,$5e
>9138	0b dc 10 36 04 16 09 b9			.byte	$0b,$dc,$10,$36,$04,$16,$09,$b9
>9140	84 8b 47 71 fd 06 36 38			.byte	$84,$8b,$47,$71,$fd,$06,$36,$38
>9148	37 35 00 12 68 0b dc 06			.byte	$37,$35,$00,$12,$68,$0b,$dc,$06
>9150	37 17 84 8b 46 73 fd 06			.byte	$37,$17,$84,$8b,$46,$73,$fd,$06
>9158	30 36 32 35 00 11 72 0b			.byte	$30,$36,$32,$35,$00,$11,$72,$0b
>9160	dc 12 38 19 84 48 44 fd			.byte	$dc,$12,$38,$19,$84,$48,$44,$fd
>9168	06 31 38 37 35 00 13 7c			.byte	$06,$31,$38,$37,$35,$00,$13,$7c
>9170	0b dc 03 36 0c 07 b9 84			.byte	$0b,$dc,$03,$36,$0c,$07,$b9,$84
>9178	43 47 fd 06 39 33 37 35			.byte	$43,$47,$fd,$06,$39,$33,$37,$35
>9180	00 0d 86 0b dc 07 33 0f			.byte	$00,$0d,$86,$0b,$dc,$07,$33,$0f
>9188	b7 84 fe 03 53 00 0f 90			.byte	$b7,$84,$fe,$03,$53,$00,$0f,$90
>9190	0b dc 15 30 0d 84 8b 48			.byte	$0b,$dc,$15,$30,$0d,$84,$8b,$48
>9198	72 fd 03 30 00 12 9a 0b			.byte	$72,$fd,$03,$30,$00,$12,$9a,$0b
>91a0	dc 08 37 07 07 84 43 5c			.byte	$dc,$08,$37,$07,$07,$84,$43,$5c
>91a8	fd 06 39 33 37 35 00 11			.byte	$fd,$06,$39,$33,$37,$35,$00,$11
>91b0	a4 0b dc 04 32 06 14 b7			.byte	$a4,$0b,$dc,$04,$32,$06,$14,$b7
>91b8	84 fe 06 49 33 47 41 00			.byte	$84,$fe,$06,$49,$33,$47,$41,$00
>91c0	0f ae 0b dc 04 30 14 1a			.byte	$0f,$ae,$0b,$dc,$04,$30,$14,$1a
>91c8	06 b7 84 fe 03 4a 00 0c			.byte	$06,$b7,$84,$fe,$03,$4a,$00,$0c
>91d0	b8 0b dc 13 37 10 b7 84			.byte	$b8,$0b,$dc,$13,$37,$10,$b7,$84
>91d8	fe 02 00 0f c2 0b dc 0f			.byte	$fe,$02,$00,$0f,$c2,$0b,$dc,$0f
>91e0	36 15 b7 84 fe 05 47 35			.byte	$36,$15,$b7,$84,$fe,$05,$47,$35
>91e8	4c 00 0c cc 0b dc 1a 38			.byte	$4c,$00,$0c,$cc,$0b,$dc,$1a,$38
>91f0	09 b7 84 fe 02 00 11 d6			.byte	$09,$b7,$84,$fe,$02,$00,$11,$d6
>91f8	0b dc 16 38 16 84 8b 46			.byte	$0b,$dc,$16,$38,$16,$84,$8b,$46
>9200	41 fd 05 38 37 35 00 0d			.byte	$41,$fd,$05,$38,$37,$35,$00,$0d
>9208	e0 0b dc 17 35 15 bb 84			.byte	$e0,$0b,$dc,$17,$35,$15,$bb,$84
>9210	8b 49 5d 00 0d ea 0b dc			.byte	$8b,$49,$5d,$00,$0d,$ea,$0b,$dc
>9218	02 33 17 16 bb 84 4b 45			.byte	$02,$33,$17,$16,$bb,$84,$4b,$45
>9220	00 12 f4 0b dc 13 36 0e			.byte	$00,$12,$f4,$0b,$dc,$13,$36,$0e
>9228	b9 84 43 6e fd 06 39 33			.byte	$b9,$84,$43,$6e,$fd,$06,$39,$33
>9230	37 35 00 0d fe 0b dc 05			.byte	$37,$35,$00,$0d,$fe,$0b,$dc,$05
>9238	34 15 16 13 b9 84 40 00			.byte	$34,$15,$16,$13,$b9,$84,$40,$00
>9240	14 08 0c dc 0f 37 16 14			.byte	$14,$08,$0c,$dc,$0f,$37,$16,$14
>9248	0a b9 84 41 7e fd 06 39			.byte	$0a,$b9,$84,$41,$7e,$fd,$06,$39
>9250	33 37 35 00 0b 12 0c dc			.byte	$33,$37,$35,$00,$0b,$12,$0c,$dc
>9258	01 32 11 09 84 40 00 0d			.byte	$01,$32,$11,$09,$84,$40,$00,$0d
>9260	1c 0c dc 0e 31 08 bb 84			.byte	$1c,$0c,$dc,$0e,$31,$08,$bb,$84
>9268	8b 4d 4c 00 0b 26 0c dc			.byte	$8b,$4d,$4c,$00,$0b,$26,$0c,$dc
>9270	09 84 57 fd 03 30 00 14			.byte	$09,$84,$57,$fd,$03,$30,$00,$14
>9278	30 0c dc 13 38 07 0b 18			.byte	$30,$0c,$dc,$13,$38,$07,$0b,$18
>9280	b9 84 44 69 fd 06 34 33			.byte	$b9,$84,$44,$69,$fd,$06,$34,$33
>9288	37 35 00 2b 3a 0c dc 18			.byte	$37,$35,$00,$2b,$3a,$0c,$dc,$18
>9290	34 06 13 ba 40 be 84 40			.byte	$34,$06,$13,$ba,$40,$be,$84,$40
>9298	c0 dc 18 34 06 13 ba 41			.byte	$c0,$dc,$18,$34,$06,$13,$ba,$41
>92a0	be 84 48 42 fd 06 38 31			.byte	$be,$84,$48,$42,$fd,$06,$38,$31
>92a8	32 35 c0 dc 18 34 06 13			.byte	$32,$35,$c0,$dc,$18,$34,$06,$13
>92b0	ba 42 be 84 40 00 27 44			.byte	$ba,$42,$be,$84,$40,$00,$27,$44
>92b8	0c dc 11 bd 40 be 84 8b			.byte	$0c,$dc,$11,$bd,$40,$be,$84,$8b
>92c0	48 43 fd 06 33 31 32 35			.byte	$48,$43,$fd,$06,$33,$31,$32,$35
>92c8	c0 dc 11 bd 41 be 84 44			.byte	$c0,$dc,$11,$bd,$41,$be,$84,$44
>92d0	55 fd 03 35 c0 dc 11 bd			.byte	$55,$fd,$03,$35,$c0,$dc,$11,$bd
>92d8	42 be 84 40 00 37 4e 0c			.byte	$42,$be,$84,$40,$00,$37,$4e,$0c
>92e0	dc 03 30 0b 0b 10 bd 40			.byte	$dc,$03,$30,$0b,$0b,$10,$bd,$40
>92e8	be 84 46 5b fd 03 30 c0			.byte	$be,$84,$46,$5b,$fd,$03,$30,$c0
>92f0	dc 03 30 0b 0b 10 bd 41			.byte	$dc,$03,$30,$0b,$0b,$10,$bd,$41
>92f8	be 84 45 45 fd 04 32 35			.byte	$be,$84,$45,$45,$fd,$04,$32,$35
>9300	c0 dc 03 30 0b 0b 10 bd			.byte	$c0,$dc,$03,$30,$0b,$0b,$10,$bd
>9308	42 be 84 46 7c fd 06 30			.byte	$42,$be,$84,$46,$7c,$fd,$06,$30
>9310	36 32 35 00 27 58 0c dc			.byte	$36,$32,$35,$00,$27,$58,$0c,$dc
>9318	02 38 07 10 13 ba 40 be			.byte	$02,$38,$07,$10,$13,$ba,$40,$be
>9320	84 40 c0 dc 02 38 07 10			.byte	$84,$40,$c0,$dc,$02,$38,$07,$10
>9328	13 ba 41 be 84 40 c0 dc			.byte	$13,$ba,$41,$be,$84,$40,$c0,$dc
>9330	02 38 07 10 13 ba 42 be			.byte	$02,$38,$07,$10,$13,$ba,$42,$be
>9338	84 40 00 51 62 0c dc 19			.byte	$84,$40,$00,$51,$62,$0c,$dc,$19
>9340	33 11 0e bc 40 bf 40 be			.byte	$33,$11,$0e,$bc,$40,$bf,$40,$be
>9348	84 40 c0 dc 19 33 11 0e			.byte	$84,$40,$c0,$dc,$19,$33,$11,$0e
>9350	bc 40 bf 41 be 84 40 c0			.byte	$bc,$40,$bf,$41,$be,$84,$40,$c0
>9358	dc 19 33 11 0e bc 40 bf			.byte	$dc,$19,$33,$11,$0e,$bc,$40,$bf
>9360	42 be 84 40 c0 dc 19 33			.byte	$42,$be,$84,$40,$c0,$dc,$19,$33
>9368	11 0e bc 41 bf 40 be 84			.byte	$11,$0e,$bc,$41,$bf,$40,$be,$84
>9370	40 c0 dc 19 33 11 0e bc			.byte	$40,$c0,$dc,$19,$33,$11,$0e,$bc
>9378	41 bf 41 be 84 40 c0 dc			.byte	$41,$bf,$41,$be,$84,$40,$c0,$dc
>9380	19 33 11 0e bc 41 bf 42			.byte	$19,$33,$11,$0e,$bc,$41,$bf,$42
>9388	be 84 40 00 2b 6c 0c dc			.byte	$be,$84,$40,$00,$2b,$6c,$0c,$dc
>9390	04 30 15 07 16 bc 40 be			.byte	$04,$30,$15,$07,$16,$bc,$40,$be
>9398	84 8b 50 c0 dc 04 30 15			.byte	$84,$8b,$50,$c0,$dc,$04,$30,$15
>93a0	07 16 bc 41 be 84 8b 45			.byte	$07,$16,$bc,$41,$be,$84,$8b,$45
>93a8	45 c0 dc 04 30 15 07 16			.byte	$45,$c0,$dc,$04,$30,$15,$07,$16
>93b0	bc 42 be 84 4a 7e 00 94			.byte	$bc,$42,$be,$84,$4a,$7e,$00,$94
>93b8	76 0c dc 18 30 1a 15 0a			.byte	$76,$0c,$dc,$18,$30,$1a,$15,$0a
>93c0	b8 40 bf 40 be 84 fe 02			.byte	$b8,$40,$bf,$40,$be,$84,$fe,$02
>93c8	c0 dc 18 30 1a 15 0a b8			.byte	$c0,$dc,$18,$30,$1a,$15,$0a,$b8
>93d0	40 bf 41 be 84 fe 02 c0			.byte	$40,$bf,$41,$be,$84,$fe,$02,$c0
>93d8	dc 18 30 1a 15 0a b8 40			.byte	$dc,$18,$30,$1a,$15,$0a,$b8,$40
>93e0	bf 42 be 84 fe 07 57 37			.byte	$bf,$42,$be,$84,$fe,$07,$57,$37
>93e8	43 58 52 c0 dc 18 30 1a			.byte	$43,$58,$52,$c0,$dc,$18,$30,$1a
>93f0	15 0a b8 41 bf 40 be 84			.byte	$15,$0a,$b8,$41,$bf,$40,$be,$84
>93f8	fe 02 c0 dc 18 30 1a 15			.byte	$fe,$02,$c0,$dc,$18,$30,$1a,$15
>9400	0a b8 41 bf 41 be 84 fe			.byte	$0a,$b8,$41,$bf,$41,$be,$84,$fe
>9408	02 c0 dc 18 30 1a 15 0a			.byte	$02,$c0,$dc,$18,$30,$1a,$15,$0a
>9410	b8 41 bf 42 be 84 fe 02			.byte	$b8,$41,$bf,$42,$be,$84,$fe,$02
>9418	c0 dc 18 30 1a 15 0a b8			.byte	$c0,$dc,$18,$30,$1a,$15,$0a,$b8
>9420	42 bf 40 be 84 fe 03 57			.byte	$42,$bf,$40,$be,$84,$fe,$03,$57
>9428	c0 dc 18 30 1a 15 0a b8			.byte	$c0,$dc,$18,$30,$1a,$15,$0a,$b8
>9430	42 bf 41 be 84 fe 02 c0			.byte	$42,$bf,$41,$be,$84,$fe,$02,$c0
>9438	dc 18 30 1a 15 0a b8 42			.byte	$dc,$18,$30,$1a,$15,$0a,$b8,$42
>9440	bf 42 be 84 fe 06 46 36			.byte	$bf,$42,$be,$84,$fe,$06,$46,$36
>9448	53 42 00 77 80 0c dc 18			.byte	$53,$42,$00,$77,$80,$0c,$dc,$18
>9450	34 14 ba 40 bf 40 be 84			.byte	$34,$14,$ba,$40,$bf,$40,$be,$84
>9458	8b 44 73 fd 06 35 36 32			.byte	$8b,$44,$73,$fd,$06,$35,$36,$32
>9460	35 c0 dc 18 34 14 ba 40			.byte	$35,$c0,$dc,$18,$34,$14,$ba,$40
>9468	bf 41 be 84 40 c0 dc 18			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$18
>9470	34 14 ba 40 bf 42 be 84			.byte	$34,$14,$ba,$40,$bf,$42,$be,$84
>9478	40 c0 dc 18 34 14 ba 41			.byte	$40,$c0,$dc,$18,$34,$14,$ba,$41
>9480	bf 40 be 84 40 c0 dc 18			.byte	$bf,$40,$be,$84,$40,$c0,$dc,$18
>9488	34 14 ba 41 bf 41 be 84			.byte	$34,$14,$ba,$41,$bf,$41,$be,$84
>9490	40 c0 dc 18 34 14 ba 41			.byte	$40,$c0,$dc,$18,$34,$14,$ba,$41
>9498	bf 42 be 84 40 c0 dc 18			.byte	$bf,$42,$be,$84,$40,$c0,$dc,$18
>94a0	34 14 ba 42 bf 40 be 84			.byte	$34,$14,$ba,$42,$bf,$40,$be,$84
>94a8	40 c0 dc 18 34 14 ba 42			.byte	$40,$c0,$dc,$18,$34,$14,$ba,$42
>94b0	bf 41 be 84 40 c0 dc 18			.byte	$bf,$41,$be,$84,$40,$c0,$dc,$18
>94b8	34 14 ba 42 bf 42 be 84			.byte	$34,$14,$ba,$42,$bf,$42,$be,$84
>94c0	40 00 24 8a 0c dc 03 35			.byte	$40,$00,$24,$8a,$0c,$dc,$03,$35
>94c8	06 b8 40 be 84 fe 02 c0			.byte	$06,$b8,$40,$be,$84,$fe,$02,$c0
>94d0	dc 03 35 06 b8 41 be 84			.byte	$dc,$03,$35,$06,$b8,$41,$be,$84
>94d8	fe 02 c0 dc 03 35 06 b8			.byte	$fe,$02,$c0,$dc,$03,$35,$06,$b8
>94e0	42 be 84 fe 02 00 20 94			.byte	$42,$be,$84,$fe,$02,$00,$20,$94
>94e8	0c dc 0d bc 40 be 84 8b			.byte	$0c,$dc,$0d,$bc,$40,$be,$84,$8b
>94f0	49 c0 dc 0d bc 41 be 84			.byte	$49,$c0,$dc,$0d,$bc,$41,$be,$84
>94f8	8b 45 49 c0 dc 0d bc 42			.byte	$8b,$45,$49,$c0,$dc,$0d,$bc,$42
>9500	be 84 8b 49 54 00 1f 9e			.byte	$be,$84,$8b,$49,$54,$00,$1f,$9e
>9508	0c dc 06 30 18 16 09 bc			.byte	$0c,$dc,$06,$30,$18,$16,$09,$bc
>9510	40 be 84 8b 4e 41 c0 dc			.byte	$40,$be,$84,$8b,$4e,$41,$c0,$dc
>9518	06 30 18 16 09 bc 41 be			.byte	$06,$30,$18,$16,$09,$bc,$41,$be
>9520	84 8b 49 50 00 25 a8 0c			.byte	$84,$8b,$49,$50,$00,$25,$a8,$0c
>9528	dc 1a 37 1a bc 40 be 84			.byte	$dc,$1a,$37,$1a,$bc,$40,$be,$84
>9530	8b 48 4b c0 dc 1a 37 1a			.byte	$8b,$48,$4b,$c0,$dc,$1a,$37,$1a
>9538	bc 41 be 84 48 6c c0 dc			.byte	$bc,$41,$be,$84,$48,$6c,$c0,$dc
>9540	1a 37 1a bc 42 be 84 4b			.byte	$1a,$37,$1a,$bc,$42,$be,$84,$4b
>9548	65 00 1b b2 0c d6 fe 14			.byte	$65,$00,$1b,$b2,$0c,$d6,$fe,$14
>9550	50 61 73 73 65 64 20 41			.byte	$50,$61,$73,$73,$65,$64,$20,$41
>9558	73 73 69 67 6e 6d 65 6e			.byte	$73,$73,$69,$67,$6e,$6d,$65,$6e
>9560	74 2e c0 c4 00 00			.byte	$74,$2e,$c0,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.9566					BasicProgramEnd:
.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 82 a2	jsr $a282			jsr 	IF_Reset 					; reset external interface
.a006	20 41 a0	jsr $a041			jsr 	IFT_ClearScreen
.a009	20 0f a0	jsr $a00f			jsr 	CopyProgram
.a00c	4c 6b b1	jmp $b16b		jmp BASIC_Start
.a00f					CopyProgram:
.a00f	a9 00		lda #$00			lda 	#BasicProgramStart & $FF
.a011	85 1c		sta $1c				sta 	zLTemp1+0
.a013	a9 80		lda #$80			lda 	#(BasicProgramStart >> 8) & $FF
.a015	85 1d		sta $1d				sta 	zLTemp1+1
.a017	a9 02		lda #$02			lda 	#2
.a019	85 1e		sta $1e				sta 	zLTemp1+2
.a01b	a9 00		lda #$00			lda 	#0
.a01d	85 1f		sta $1f				sta 	zLTemp1+3
.a01f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.a021	85 10		sta $10				sta 	zTemp1
.a023	a9 20		lda #$20			lda 	#BasicProgram >> 8
.a025	85 11		sta $11				sta 	zTemp1+1
.a027	a3 00		ldz #$00			ldz 	#0
.a029	a0 00		ldy #$00			ldy 	#0
.a02b	ea		nop		_Copy1:	nop
.a02c	b2 1c		lda ($1c),z			lda 	(zLTemp1),z
.a02e	91 10		sta ($10),y			sta 	(zTemp1),y
.a030	c8		iny				iny
.a031	1b		inz				inz
.a032	d0 f7		bne $a02b			bne 	_Copy1
.a034	e6 1d		inc $1d				inc 	zLTemp1+1
.a036	e6 11		inc $11				inc 	zTemp1+1
.a038	a5 1d		lda $1d				lda 	zLTemp1+1
.a03a	c9 95		cmp #$95			cmp 	#(BasicProgramEnd >> 8) & $FF
.a03c	90 ed		bcc $a02b			bcc 	_Copy1
.a03e	f0 eb		beq $a02b			beq 	_Copy1
.a040	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a041					IFT_ClearScreen:
.a041	48		pha				pha
.a042	da		phx				phx
.a043	5a		phy				phy
.a044	20 e9 a1	jsr $a1e9			jsr 	IF_Home 					; home cursor
.a047	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a049					_IFT_CS0:
.a049	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a04b					_IFT_CS1:
.a04b	a9 20		lda #$20			lda 	#' '						; clear line.
.a04d	20 18 a2	jsr $a218			jsr 	IF_Write
.a050	88		dey				dey
.a051	d0 f8		bne $a04b			bne 	_IFT_CS1
.a053	20 f8 a1	jsr $a1f8			jsr 	IF_NewLine 					; next line down
.a056	ca		dex				dex
.a057	d0 f0		bne $a049			bne 	_IFT_CS0
.a059	7a		ply				ply
.a05a	fa		plx				plx
.a05b	68		pla				pla
.a05c					IFT_HomeCursor:
.a05c	48		pha				pha
.a05d	20 e9 a1	jsr $a1e9			jsr 	IF_Home
.a060	a9 00		lda #$00			lda 	#0
.a062	8d 00 05	sta $0500			sta 	IFT_XCursor
.a065	8d 01 05	sta $0501			sta 	IFT_YCursor
.a068	68		pla				pla
.a069	60		rts				rts
.a06a					IFT_UpLine:
.a06a	48		pha				pha
.a06b	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a06e	3a		dec a				dec 	a 							; line above
.a06f	30 03		bmi $a074			bmi 	_IFTULExit 					; too far, abort
.a071	20 09 a1	jsr $a109			jsr 	IFT_SetYPos					; set to that line.
.a074					_IFTULExit:
.a074	68		pla				pla
.a075	60		rts				rts
.a076					IFT_PrintCharacter:
.a076	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a078	f0 20		beq $a09a			beq 	IFT_NewLine
.a07a	c9 08		cmp #$08			cmp 	#8
.a07c	f0 16		beq $a094			beq 	_IFT_Left
.a07e	48		pha				pha
.a07f	20 b2 a0	jsr $a0b2			jsr 	IFT_UpperCase 				; make upper case
.a082	20 18 a2	jsr $a218			jsr 	IF_Write 					; write out.
.a085	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a088	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a08b	c9 50		cmp #$50			cmp 	#IF_Width
.a08d	d0 03		bne $a092			bne 	_IFT_PCNotEOL
.a08f	20 9a a0	jsr $a09a			jsr 	IFT_NewLine 				; if so do new line.
.a092					_IFT_PCNotEOL:
.a092	68		pla				pla
.a093	60		rts				rts
.a094					_IFT_Left:
.a094	48		pha				pha
.a095	20 23 a2	jsr $a223			jsr 	IF_LeftOne
.a098	68		pla				pla
.a099	60		rts				rts
.a09a					IFT_NewLine:
.a09a	48		pha				pha
.a09b	20 f8 a1	jsr $a1f8			jsr 	IF_NewLine 					; new line on actual screen.
.a09e	a9 00		lda #$00			lda 	#0 							; reset x position
.a0a0	8d 00 05	sta $0500			sta 	IFT_XCursor
.a0a3	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a0a6	ad 01 05	lda $0501			lda 	IFT_YCursor
.a0a9	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a0ab	d0 03		bne $a0b0			bne 	_IFT_NL_NotEOS
.a0ad	20 bd a0	jsr $a0bd			jsr 	IFT_Scroll 					; scroll screen up.
.a0b0					_IFT_NL_NotEOS:
.a0b0	68		pla				pla
.a0b1	60		rts				rts
.a0b2					IFT_UpperCase:
.a0b2	c9 61		cmp #$61			cmp 	#"a"
.a0b4	90 06		bcc $a0bc			bcc 	_IFT_UCExit
.a0b6	c9 7b		cmp #$7b			cmp 	#"z"+1
.a0b8	b0 02		bcs $a0bc			bcs 	_IFT_UCExit
.a0ba	49 20		eor #$20			eor 	#$20
.a0bc					_IFT_UCExit:
.a0bc	60		rts				rts
.a0bd					IFT_Scroll:
.a0bd	48		pha				pha 								; save AXY
.a0be	da		phx				phx
.a0bf	5a		phy				phy
.a0c0	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a0c2					_IFT_SLoop:
.a0c2	20 e2 a0	jsr $a0e2			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a0c5	e8		inx				inx
.a0c6	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a0c8	d0 f8		bne $a0c2			bne 	_IFT_SLoop
.a0ca	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0cc	20 09 a1	jsr $a109			jsr 	IFT_SetYPos
.a0cf	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a0d1					_IFT_SBlank:
.a0d1	a9 20		lda #$20			lda 	#32
.a0d3	20 18 a2	jsr $a218			jsr 	IF_Write
.a0d6	ca		dex				dex
.a0d7	d0 f8		bne $a0d1			bne 	_IFT_SBlank
.a0d9	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0db	20 09 a1	jsr $a109			jsr 	IFT_SetYPos
.a0de	7a		ply				ply
.a0df	fa		plx				plx
.a0e0	68		pla				pla
.a0e1	60		rts				rts
.a0e2					_IFT_ScrollLine:
.a0e2	da		phx				phx
.a0e3	da		phx				phx
.a0e4	8a		txa				txa 								; copy line into buffer.
.a0e5	1a		inc a				inc 	a 							; next line down.
.a0e6	20 09 a1	jsr $a109			jsr 	IFT_SetYPos
.a0e9	a2 00		ldx #$00			ldx 	#0
.a0eb					_IFTScrollCopy1:
.a0eb	20 0a a2	jsr $a20a			jsr 	IF_Read
.a0ee	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0f1	e8		inx				inx
.a0f2	e0 50		cpx #$50			cpx 	#IF_Width
.a0f4	d0 f5		bne $a0eb			bne 	_IFTScrollCopy1
.a0f6	68		pla				pla
.a0f7	20 09 a1	jsr $a109			jsr 	IFT_SetYPos
.a0fa	a2 00		ldx #$00			ldx 	#0
.a0fc					_IFTScrollCopy2:
.a0fc	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0ff	20 18 a2	jsr $a218			jsr 	IF_Write
.a102	e8		inx				inx
.a103	e0 50		cpx #$50			cpx 	#IF_Width
.a105	d0 f5		bne $a0fc			bne 	_IFTScrollCopy2
.a107	fa		plx				plx
.a108	60		rts				rts
.a109					IFT_SetYPos:
.a109	48		pha				pha
.a10a	da		phx				phx
.a10b	aa		tax				tax
.a10c	20 5c a0	jsr $a05c			jsr 	IFT_HomeCursor
.a10f	e0 00		cpx #$00			cpx 	#0
.a111	f0 09		beq $a11c			beq 	_IFT_MOAExit
.a113					_IFT_MOALoop:
.a113	20 f8 a1	jsr $a1f8			jsr 	IF_NewLine
.a116	ee 01 05	inc $0501			inc 	IFT_YCursor
.a119	ca		dex				dex
.a11a	d0 f7		bne $a113			bne		_IFT_MOALoop
.a11c					_IFT_MOAExit:
.a11c	fa		plx				plx
.a11d	68		pla				pla
.a11e	60		rts				rts
.a11f					IFT_GetKeyCursor:
.a11f	20 27 a1	jsr $a127			jsr 	_IFT_FlipCursor 			; reverse current
.a122					_IFT_GKCWait:
.a122	20 3b a2	jsr $a23b			jsr 	IF_GetKey 					; get key
.a125	f0 fb		beq $a122			beq 	_IFT_GKCWait
.a127					_IFT_FlipCursor:
.a127	48		pha				pha 								; save
.a128	20 0a a2	jsr $a20a			jsr 	IF_Read 					; read
.a12b	20 23 a2	jsr $a223			jsr 	IF_LeftOne
.a12e	49 80		eor #$80			eor 	#$80 						; reverse
.a130	20 18 a2	jsr $a218			jsr 	IF_Write 					; write
.a133	20 23 a2	jsr $a223			jsr 	IF_LeftOne
.a136	68		pla				pla
.a137	60		rts				rts
.a138					IFT_ReadLine:
.a138	48		pha				pha
.a139					_IFT_RLLoop:
.a139	20 1f a1	jsr $a11f			jsr 	IFT_GetKeyCursor 			; get keystroke
.a13c	c9 0d		cmp #$0d			cmp 	#13							; return
.a13e	f0 7d		beq $a1bd			beq 	_IFT_RLExit
.a140	c9 20		cmp #$20			cmp 	#32 						; control character
.a142	90 05		bcc $a149			bcc 	_IFT_Control
.a144	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter
.a147	80 f0		bra $a139			bra 	_IFT_RLLoop
.a149					_IFT_Control:
.a149	c9 01		cmp #$01			cmp 	#"A"-64
.a14b	f0 26		beq $a173			beq 	_IFT_Left
.a14d	c9 04		cmp #$04			cmp 	#"D"-64
.a14f	f0 2e		beq $a17f			beq 	_IFT_Right
.a151	c9 17		cmp #$17			cmp 	#"W"-64
.a153	f0 36		beq $a18b			beq 	_IFT_Up
.a155	c9 13		cmp #$13			cmp 	#"S"-64
.a157	f0 3e		beq $a197			beq 	_IFT_Down
.a159	c9 08		cmp #$08			cmp 	#"H"-64
.a15b	f0 09		beq $a166			beq 	_IFT_Backspace
.a15d	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a15f	d0 d8		bne $a139			bne 	_IFT_RLLoop
.a161	20 41 a0	jsr $a041			jsr 	IFT_ClearScreen				; clear CTL-Z
.a164	80 d3		bra $a139			bra 	_IFT_RLLoop
.a166					_IFT_Backspace:
.a166	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a169	f0 ce		beq $a139			beq 	_IFT_RLLoop
.a16b	20 23 a2	jsr $a223			jsr 	IF_LeftOne
.a16e	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a170	20 18 a2	jsr $a218			jsr 	IF_Write
.a173					_IFT_Left:
.a173	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a176	10 29		bpl $a1a1			bpl 	_IFT_Reposition
.a178	a9 4f		lda #$4f			lda 	#IF_Width-1
.a17a					_IFT_SetX:
.a17a	8d 00 05	sta $0500			sta 	IFT_XCursor
.a17d	80 22		bra $a1a1			bra 	_IFT_Reposition
.a17f					_IFT_Right:
.a17f	ee 00 05	inc $0500			inc 	IFT_XCursor
.a182	ad 00 05	lda $0500			lda 	IFT_XCursor
.a185	49 50		eor #$50			eor 	#IF_Width
.a187	f0 f1		beq $a17a			beq 	_IFT_SetX
.a189	80 16		bra $a1a1			bra 	_IFT_Reposition
.a18b					_IFT_Up:
.a18b	ce 01 05	dec $0501			dec 	IFT_YCursor
.a18e	10 11		bpl $a1a1			bpl 	_IFT_Reposition
.a190	a9 18		lda #$18			lda 	#IF_Height-1
.a192					_IFT_SetY:
.a192	8d 01 05	sta $0501			sta 	IFT_YCursor
.a195	80 0a		bra $a1a1			bra 	_IFT_Reposition
.a197					_IFT_Down:
.a197	ee 01 05	inc $0501			inc 	IFT_YCursor
.a19a	ad 01 05	lda $0501			lda 	IFT_YCursor
.a19d	49 19		eor #$19			eor 	#IF_Height
.a19f	f0 f1		beq $a192			beq 	_IFT_SetY
.a1a1					_IFT_Reposition:
.a1a1	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a1a4	48		pha				pha
.a1a5	ad 01 05	lda $0501			lda 	IFT_YCursor
.a1a8	20 09 a1	jsr $a109			jsr 	IFT_SetYPos
.a1ab	68		pla				pla
.a1ac	aa		tax				tax
.a1ad	e0 00		cpx #$00			cpx 	#0
.a1af	f0 88		beq $a139			beq 	_IFT_RLLoop
.a1b1					_IFT_MoveRight:
.a1b1	20 0a a2	jsr $a20a			jsr 	IF_Read
.a1b4	ee 00 05	inc $0500			inc 	IFT_XCursor
.a1b7	ca		dex				dex
.a1b8	d0 f7		bne $a1b1			bne 	_IFT_MoveRight
.a1ba	4c 39 a1	jmp $a139			jmp 	_IFT_RLLoop
.a1bd					_IFT_RLExit:
.a1bd	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a1c0	20 09 a1	jsr $a109			jsr 	IFT_SetYPos
.a1c3	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a1c5					_IFT_RLRead:
.a1c5	20 0a a2	jsr $a20a			jsr 	IF_Read
.a1c8	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1cb	e8		inx				inx
.a1cc	e0 50		cpx #$50			cpx 	#IF_Width
.a1ce	d0 f5		bne $a1c5			bne 	_IFT_RLRead
.a1d0					_IFT_RL_Trim:
.a1d0	ca		dex				dex 	 							; previous char
.a1d1	30 07		bmi $a1da			bmi 	_IFT_Found 					; gone too far
.a1d3	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1d6	c9 20		cmp #$20			cmp 	#" "
.a1d8	f0 f6		beq $a1d0			beq 	_IFT_RL_Trim
.a1da					_IFT_Found:
.a1da	e8		inx				inx 								; forward to non-space
.a1db	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1dd	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1e0	20 9a a0	jsr $a09a			jsr 	IFT_NewLine 				; go to next line.
.a1e3	68		pla				pla
.a1e4	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1e6	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1e8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1e9					IF_Home:
.a1e9	48		pha				pha 								; reset cursor position
.a1ea	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1ec	85 04		sta $04				sta 	IF_Pos
.a1ee	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1f0	85 05		sta $05				sta 	IF_Pos+1
.a1f2	a9 00		lda #$00			lda 	#0
.a1f4	85 06		sta $06				sta 	IF_XPos
.a1f6	68		pla				pla
.a1f7	60		rts				rts
.a1f8					IF_NewLine:
.a1f8	48		pha				pha
.a1f9	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1fb	85 06		sta $06				sta 	IF_XPos
.a1fd	18		clc				clc 								; down one line
.a1fe	a5 04		lda $04				lda 	IF_Pos
.a200	69 50		adc #$50			adc 	#80
.a202	85 04		sta $04				sta 	IF_Pos
.a204	90 02		bcc $a208			bcc 	_IF_NoCarry 				; carry through.
.a206	e6 05		inc $05				inc 	IF_Pos+1
.a208					_IF_NoCarry:
.a208	68		pla				pla
.a209	60		rts				rts
.a20a					IF_Read:
.a20a	5a		phy				phy 								; save current Y
.a20b	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a20d	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a20f	49 20		eor #$20			eor 	#$20
.a211	18		clc				clc
.a212	69 20		adc #$20			adc 	#$20
.a214	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a216	7a		ply				ply									; restore Y
.a217	60		rts				rts
.a218					IF_Write:
.a218	5a		phy				phy 								; save current Y
.a219	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a21b	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a21d	91 04		sta ($04),y			sta 	(IF_Pos),y
.a21f	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a221	7a		ply				ply									; restore Y
.a222	60		rts				rts
.a223					IF_LeftOne:
.a223	c6 06		dec $06				dec 	IF_XPos
.a225	60		rts				rts
.a226					IF_CheckBreak:
.a226	db		phz				phz
.a227	20 6f a2	jsr $a26f			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a22a	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a22c	ea		nop				nop 								; read modifiers.
.a22d	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a22f	fb		plz				plz 								; restore Z
.a230	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a232	c9 05		cmp #$05			cmp 	#5
.a234	f0 02		beq $a238			beq 	_IF_CBExit
.a236	a9 00		lda #$00			lda 	#0
.a238					_IF_CBExit:
.a238	c9 00		cmp #$00			cmp 	#0
.a23a	60		rts				rts
.a23b					IF_GetKey:
.a23b	db		phz				phz
.a23c	20 6f a2	jsr $a26f			jsr 	IF_SetupKeyAddress
.a23f	ea		nop				nop 								; read keyboard
.a240	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a242	c9 14		cmp #$14			cmp 	#20
.a244	d0 02		bne $a248			bne 	_KMNo
.a246	a9 08		lda #$08			lda 	#"H"-64
.a248					_KMNo:
.a248	c9 91		cmp #$91			cmp 	#145
.a24a	d0 02		bne $a24e			bne 	_KMNo
.a24c	a9 17		lda #$17			lda 	#"W"-64
.a24e					_KMNo:
.a24e	c9 11		cmp #$11			cmp 	#17
.a250	d0 02		bne $a254			bne 	_KMNo
.a252	a9 13		lda #$13			lda 	#"S"-64
.a254					_KMNo:
.a254	c9 9d		cmp #$9d			cmp 	#157
.a256	d0 02		bne $a25a			bne 	_KMNo
.a258	a9 01		lda #$01			lda 	#"A"-64
.a25a					_KMNo:
.a25a	c9 1d		cmp #$1d			cmp 	#29
.a25c	d0 02		bne $a260			bne 	_KMNo
.a25e	a9 04		lda #$04			lda 	#"D"-64
.a260					_KMNo:
.a260	c9 00		cmp #$00			cmp 	#0
.a262	f0 07		beq $a26b			beq 	_IFGKEmpty
.a264	48		pha				pha
.a265	a9 00		lda #$00			lda 	#0
.a267	ea		nop				nop
.a268	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26a	68		pla				pla
.a26b					_IFGKEmpty:
.a26b	fb		plz				plz
.a26c	c9 00		cmp #$00			cmp 	#0 							; set Z
.a26e	60		rts				rts
.a26f					IF_SetupKeyAddress:
.a26f	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a271	85 0b		sta $0b				sta 	IF_FarPtr+3
.a273	a9 fd		lda #$fd			lda 	#$FD
.a275	85 0a		sta $0a				sta 	IF_FarPtr+2
.a277	a9 36		lda #$36			lda 	#$36
.a279	85 09		sta $09				sta 	IF_FarPtr+1
.a27b	a9 10		lda #$10			lda 	#$10
.a27d	85 08		sta $08				sta 	IF_FarPtr+0
.a27f	a3 00		ldz #$00			ldz 	#0
.a281	60		rts				rts
.a282					IF_Reset:
.a282	48		pha				pha 								; save registers
.a283	da		phx				phx
.a284	5a		phy				phy
.a285	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a287	85 0b		sta $0b				sta 	IF_FarPtr+3
.a289	a9 fd		lda #$fd			lda 	#$FD
.a28b	85 0a		sta $0a				sta 	IF_FarPtr+2
.a28d	a9 30		lda #$30			lda 	#$30
.a28f	85 09		sta $09				sta 	IF_FarPtr+1
.a291	a9 00		lda #$00			lda 	#$00
.a293	85 08		sta $08				sta 	IF_FarPtr+0
.a295	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a297	a9 47		lda #$47			lda 	#$47
.a299	ea		nop				nop
.a29a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29c	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a29e	a9 53		lda #$53			lda 	#$53
.a2a0	ea		nop				nop
.a2a1	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a3	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a2a5	a9 40		lda #$40			lda 	#$40
.a2a7	ea		nop				nop
.a2a8	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2aa	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a2ac	a9 c0		lda #$c0			lda 	#$80+$40
.a2ae	ea		nop				nop
.a2af	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b1	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a2b3	a9 00		lda #$00			lda 	#0
.a2b5	ea		nop				nop
.a2b6	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b8	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a2ba	a9 00		lda #$00			lda 	#0
.a2bc	ea		nop				nop
.a2bd	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2bf	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a2c1	a9 40		lda #$40			lda 	#$40
.a2c3	ea		nop				nop
.a2c4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2c6	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a2c8	a9 ff		lda #$ff			lda 	#$FF
.a2ca	ea		nop				nop
.a2cb	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cd	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a2cf	a9 ff		lda #$ff			lda 	#$FF
.a2d1	ea		nop				nop
.a2d2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2d4	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2d6	a9 cc		lda #$cc			lda 	#$CC
.a2d8	ea		nop				nop
.a2d9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2db	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2dd	a9 42		lda #$42			lda 	#$42
.a2df	ea		nop				nop
.a2e0	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2e2	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2e4	a9 1b		lda #$1b			lda 	#$1B
.a2e6	ea		nop				nop
.a2e7	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2e9	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2eb	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2ed	a9 01		lda #$01			lda 	#$01
.a2ef	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2f1	a9 f8		lda #$f8			lda 	#$F8
.a2f3	85 09		sta $09				sta 	IF_FarPtr+1
.a2f5	a9 00		lda #$00			lda 	#$00
.a2f7	85 08		sta $08				sta 	IF_FarPtr+0
.a2f9	a3 00		ldz #$00			ldz 	#0
.a2fb					_EXTClearColorRam:
.a2fb	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2fd	ea		nop				nop
.a2fe	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a300	3b		dez				dez
.a301	d0 f8		bne $a2fb			bne 	_EXTClearColorRam
.a303	e6 09		inc $09				inc 	IF_FarPtr+1
.a305	d0 f4		bne $a2fb			bne 	_EXTClearColorRam
.a307	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a309					_EXTCopyCBMFont:
.a309	bd 4a a3	lda $a34a,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a30c	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a30f	49 ff		eor #$ff			eor 	#$FF
.a311	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a314	bd 4a a4	lda $a44a,x			lda 	IF_CBMFont+$100,x
.a317	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a31a	49 ff		eor #$ff			eor 	#$FF
.a31c	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a31f	bd 4a a5	lda $a54a,x			lda 	IF_CBMFont+$200,x
.a322	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a325	49 ff		eor #$ff			eor 	#$FF
.a327	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a32a	bd 4a a6	lda $a64a,x			lda 	IF_CBMFont+$300,x
.a32d	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a330	49 ff		eor #$ff			eor 	#$FF
.a332	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a335	ca		dex				dex
.a336	d0 d1		bne $a309			bne 	_EXTCopyCBMFont
.a338	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a33a	85 01		sta $01				sta 	$01
.a33c	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a33e	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a340	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a342	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a344	5c		map				map
.a345	ea		nop				eom
.a346	7a		ply				ply 								; restore and exit.
.a347	fa		plx				plx
.a348	68		pla				pla
.a349	60		rts				rts
.a34a					IF_CBMFont:
>a34a	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a352	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a362	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a372	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a382	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a392	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a3a2	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a3b2	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a3c2	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a3d2	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3e2	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3f2	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a402	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a412	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a422	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a432	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a442	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a452	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a462	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a472	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a482	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a492	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a4a2	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a4b2	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a4c2	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a4d2	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4e2	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4f2	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a502	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a512	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a522	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a532	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a542	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a552	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a562	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a572	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a582	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a592	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a5a2	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a5b2	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a5c2	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a5d2	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5e2	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5f2	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a602	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a612	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a622	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a632	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a642	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a652	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a662	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a672	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a682	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a692	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a6a2	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a6b2	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a6c2	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a6d2	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6e2	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6f2	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a702	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a712	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a722	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a732	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a742	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a752	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a762	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a772	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a782	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a792	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a7a2	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a7b2	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a7c2	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a7d2	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7e2	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7f2	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a802	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a812	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a822	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a832	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a842	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a852	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a862	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a872	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a882	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a892	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a8a2	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a8b2	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a8c2	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a8d2	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8e2	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8f2	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a902	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a912	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a922	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a932	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a942	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a952	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a962	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a972	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a982	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a992	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a9a2	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a9b2	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a9c2	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a9d2	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9e2	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9f2	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>aa02	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>aa12	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>aa22	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>aa32	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa42	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa52	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa62	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa72	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa82	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa92	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aaa2	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aab2	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aac2	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aad2	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aae2	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aaf2	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>ab02	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>ab12	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>ab22	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>ab32	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab42	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab4a					TIM_Error:
.ab4a	20 6a a0	jsr $a06a			jsr 	IFT_UpLine 					; go up one line.
.ab4d	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab4f	80 02		bra $ab53			bra 	TIM_ShowPrompt
.ab51					TIM_NewCommand:
.ab51	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab53					TIM_ShowPrompt:
.ab53	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab56	20 38 a1	jsr $a138			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab59	20 9a a0	jsr $a09a			jsr 	IFT_NewLine					; go to next line.
.ab5c	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab5e	84 11		sty $11				sty 	zTemp1+1
.ab60	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab62	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab64	c9 3f		cmp #$3f			cmp 	#"?"
.ab66	f0 04		beq $ab6c			beq 	TIM_SkipFirst
.ab68	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab6a	d0 01		bne $ab6d			bne 	TIM_NotDot
.ab6c					TIM_SkipFirst:
.ab6c	c8		iny				iny
.ab6d					TIM_NotDot:
.ab6d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab6f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab71	f0 6e		beq $abe1			beq 	TIM_ShowRegisters
.ab73	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab75	f0 12		beq $ab89			beq 	TIM_ShowMemory
.ab77	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab79	f0 49		beq $abc4			beq 	TIM_Execute
.ab7b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab7d	f0 07		beq $ab86			beq 	TIM_GoLoadMemory
.ab7f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab81	d0 c7		bne $ab4a			bne 	TIM_Error
.ab83	4c 06 ad	jmp $ad06			jmp 	TIM_UpdateRegisters
.ab86					TIM_GoLoadMemory:
.ab86	4c 31 ad	jmp $ad31			jmp 	TIM_LoadMemory
.ab89					TIM_ShowMemory:
.ab89	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab8c	b0 bc		bcs $ab4a			bcs 	TIM_Error
.ab8e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab90	85 12		sta $12				sta 	zTemp2
.ab92	a5 15		lda $15				lda 	zTemp3+1
.ab94	85 13		sta $13				sta 	zTemp2+1
.ab96	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab99	90 08		bcc $aba3			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab9b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab9d	85 14		sta $14				sta 	zTemp3
.ab9f	a5 13		lda $13				lda 	zTemp2+1
.aba1	85 15		sta $15				sta 	zTemp3+1
.aba3					_TIMSM_Start:
.aba3	20 57 ac	jsr $ac57			jsr 	TIM_WriteLine 				; write one line of hex out
.aba6	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.aba8	18		clc				clc
.aba9	69 10		adc #$10			adc 	#16
.abab	85 12		sta $12				sta 	zTemp2
.abad	90 02		bcc $abb1			bcc 	_TIMSM_NoCarry
.abaf	e6 13		inc $13				inc 	zTemp2+1
.abb1					_TIMSM_NoCarry:
.abb1	20 26 a2	jsr $a226			jsr 	IF_CheckBreak 				; check CTL+C
.abb4	d0 0b		bne $abc1			bne 	_TIMSM_Ends 				; if pressed break out.
.abb6	38		sec				sec 								; check past the end address in zTemp3
.abb7	a5 14		lda $14				lda 	zTemp3
.abb9	e5 12		sbc $12				sbc 	zTemp2
.abbb	a5 15		lda $15				lda 	zTemp3+1
.abbd	e5 13		sbc $13				sbc 	zTemp2+1
.abbf	10 e2		bpl $aba3			bpl 	_TIMSM_Start
.abc1					_TIMSM_Ends:
.abc1	4c 51 ab	jmp $ab51			jmp 	TIM_NewCommand
.abc4					TIM_Execute:
.abc4	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; get the execute address
.abc7	b0 81		bcs $ab4a			bcs 	TIM_Error 					; not legitimate
.abc9	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.abcc	9a		txs				txs
.abcd	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.abd0	48		pha				pha
.abd1	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.abd4	ae ca 03	ldx $03ca			ldx 	TIM_X
.abd7	ac cb 03	ldy $03cb			ldy 	TIM_Y
.abda	ab cc 03	ldz $03cc			ldz 	TIM_Z
.abdd	28		plp				plp 								; and PS Byte.
.abde	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abe1					TIM_Start:
.abe1					TIM_ShowRegisters:
.abe1	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abe4	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.abe7	ad ff ff	lda $ffff			lda 	$FFFF
.abea	8d c6 03	sta $03c6			sta 	TIM_IRQ
.abed	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abef					_TIMSR_Text:
.abef	bd 1b ac	lda $ac1b,x			lda 	_TIMSR_Label,x
.abf2	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter
.abf5	e8		inx				inx
.abf6	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abf8	d0 f5		bne $abef			bne 	_TIMSR_Text
.abfa	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abfc					_TIMSR_Skip:
.abfc	e8		inx				inx
.abfd					_TIMSR_LoopSpace:
.abfd	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abff	b0 04		bcs $ac05			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.ac01	8a		txa				txa
.ac02	4a		lsr a				lsr 	a
.ac03	b0 05		bcs $ac0a			bcs 	_TIMSR_NoSpace
.ac05					_TIMSR_Space:
.ac05	a9 20		lda #$20			lda 	#" "
.ac07	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter
.ac0a					_TIMSR_NoSpace:
.ac0a	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.ac0d	20 3e ac	jsr $ac3e			jsr 	TIM_WriteHex
.ac10	e8		inx				inx
.ac11	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.ac13	d0 e8		bne $abfd			bne 	_TimSR_LoopSpace
.ac15	20 9a a0	jsr $a09a			jsr 	IFT_NewLine 				; new line
.ac18	4c 51 ab	jmp $ab51			jmp	 	TIM_NewCommand 				; new command.
.ac1b					_TIMSR_Label:
>ac1b	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>ac23	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>ac33	52
>ac34	20 5a 52					.text 	" ZR"
>ac37	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac3e					_TIMSR_LabelEnd:
.ac3e					TIM_WriteHex:
.ac3e	48		pha				pha 								; save A
.ac3f	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac40	4a		lsr a				lsr 	a
.ac41	4a		lsr a				lsr 	a
.ac42	4a		lsr a				lsr 	a
.ac43	20 47 ac	jsr $ac47			jsr 	_TIMWH_Nibble 				; print MSB
.ac46	68		pla				pla 								; restore and print LSB
.ac47					_TIMWH_Nibble:
.ac47	48		pha				pha
.ac48	29 0f		and #$0f			and 	#15 						; mask out
.ac4a	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac4c	90 02		bcc $ac50			bcc 	_TIMWHNoLetter
.ac4e	69 06		adc #$06			adc 	#6
.ac50					_TIMWHNoLetter:
.ac50	69 30		adc #$30			adc 	#48
.ac52	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter 			; print it out.
.ac55	68		pla				pla
.ac56	60		rts				rts
.ac57					TIM_WriteLine:
.ac57	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac59	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter
.ac5c	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac5e	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter
.ac61	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac63	20 3e ac	jsr $ac3e			jsr 	TIM_WriteHex
.ac66	a5 12		lda $12				lda 	zTemp2
.ac68	20 3e ac	jsr $ac3e			jsr 	TIM_WriteHex
.ac6b	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac6d					_TIMWL_Loop:
.ac6d	a9 20		lda #$20			lda 	#" "
.ac6f	20 76 a0	jsr $a076			jsr 	IFT_PrintCharacter
.ac72	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac74	20 3e ac	jsr $ac3e			jsr 	TIM_WriteHex
.ac77	c8		iny				iny
.ac78	c0 10		cpy #$10			cpy 	#16
.ac7a	d0 f1		bne $ac6d			bne 	_TIMWL_Loop
.ac7c	4c 9a a0	jmp $a09a			jmp 	IFT_NewLine 				; new line and exit
.ac7f					TIM_GetHex:
.ac7f	c8		iny				iny
.ac80	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac82	c9 20		cmp #$20			cmp 	#32
.ac84	f0 f9		beq $ac7f			beq 	TIM_GetHex
.ac86	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac88	f0 f5		beq $ac7f			beq 	TIM_GetHex
.ac8a	20 b3 ac	jsr $acb3			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac8d	b0 23		bcs $acb2			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac8f	a9 00		lda #$00			lda 	#0 							; zero result
.ac91	85 14		sta $14				sta 	zTemp3
.ac93	85 15		sta $15				sta 	zTemp3+1
.ac95					_TIM_GHLoop:
.ac95	20 b3 ac	jsr $acb3			jsr 	TIM_GetHexCharacter 		; get next character
.ac98	b0 17		bcs $acb1			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac9a	c8		iny				iny 								; skip over it.
.ac9b	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac9d	26 15		rol $15				rol 	zTemp3+1
.ac9f	06 14		asl $14				asl 	zTemp3 						; now x 2
.aca1	26 15		rol $15				rol 	zTemp3+1
.aca3	06 14		asl $14				asl 	zTemp3						; now x 4
.aca5	26 15		rol $15				rol 	zTemp3+1
.aca7	06 14		asl $14				asl 	zTemp3 						; now x 8
.aca9	26 15		rol $15				rol 	zTemp3+1
.acab	05 14		ora $14				ora 	zTemp3 						; OR result in
.acad	85 14		sta $14				sta 	zTemp3
.acaf	80 e4		bra $ac95			bra 	_TIM_GHLoop 				; loop round again.
.acb1					_TIMGH_Okay:
.acb1	18		clc				clc
.acb2					_TIMGH_Exit:
.acb2	60		rts				rts
.acb3					TIM_GetHexCharacter:
.acb3	b1 10		lda ($10),y			lda 	(zTemp1),y
.acb5	38		sec				sec
.acb6	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.acb8	90 0e		bcc $acc8			bcc 	_TIM_GHCFail
.acba	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.acbc	90 0b		bcc $acc9			bcc 	_TIM_GHCExit
.acbe	c9 11		cmp #$11			cmp 	#65-48						; < A
.acc0	90 06		bcc $acc8			bcc		_TIM_GHCFail
.acc2	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.acc4	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.acc6	90 01		bcc $acc9			bcc		_TIM_GHCExit
.acc8					_TIM_GHCFail:
.acc8	38		sec				sec
.acc9					_TIM_GHCExit:
.acc9	60		rts				rts
.acca					TIM_BreakVector:
.acca	da		phx				phx									; save X/A on stack
.accb	48		pha				pha
.accc	ba		tsx				tsx 								; X points to S
.accd	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.acd0	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.acd2	d0 03		bne $acd7			bne 	_TIMBreak					; if set, it's BRK
.acd4	68		pla				pla 								; abandon routine.
.acd5	fa		plx				plx
.acd6	40		rti				rti
.acd7					_TIMBreak:
.acd7	68		pla				pla 								; save A X Y and maybe Z
.acd8	8d c9 03	sta $03c9			sta 	TIM_A
.acdb	fa		plx				plx
.acdc	8e ca 03	stx $03ca			stx 	TIM_X
.acdf	8c cb 03	sty $03cb			sty 	TIM_Y
.ace2	9c cc 03	stz $03cc			stz 	TIM_Z
.ace5	68		pla				pla 								; get Status Register
.ace6	8d c8 03	sta $03c8			sta 	TIM_SR
.ace9	68		pla				pla
.acea	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.aced	68		pla				pla
.acee	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.acf1	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.acf4	d0 03		bne $acf9			bne 	_TIMDecrement 				; brk bumps it.
.acf6	ce c4 03	dec $03c4			dec 	TIM_PC
.acf9					_TIMDecrement:
.acf9	ce c5 03	dec $03c5			dec 	TIM_PC+1
.acfc	ba		tsx				tsx 								; and copy SP
.acfd	8e cd 03	stx $03cd			stx 	TIM_SP
.ad00	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.ad02	9a		txs				txs
.ad03	4c e1 ab	jmp $abe1			jmp 	TIM_Start 					; and start up TIM monitor.
.ad06					TIM_UpdateRegisters:
.ad06	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; PC
.ad09	b0 23		bcs $ad2e			bcs 	_TIMURFail
.ad0b	a5 14		lda $14				lda 	zTemp3
.ad0d	8d c5 03	sta $03c5			sta 	Tim_PC+1
.ad10	a5 15		lda $15				lda 	zTemp3+1
.ad12	8d c4 03	sta $03c4			sta 	Tim_PC
.ad15	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; ignore IRQ
.ad18	b0 14		bcs $ad2e			bcs 	_TIMURFail
.ad1a	a2 00		ldx #$00			ldx 	#0
.ad1c					_TIM_URLoop:
.ad1c	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; registers
.ad1f	b0 0d		bcs $ad2e			bcs 	_TIMURFail
.ad21	a5 14		lda $14				lda 	zTemp3
.ad23	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.ad26	e8		inx				inx
.ad27	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.ad29	d0 f1		bne $ad1c			bne 	_TIM_URLoop
.ad2b	4c 51 ab	jmp $ab51			jmp 	TIM_NewCommand
.ad2e					_TIMURFail:
.ad2e	4c 4a ab	jmp $ab4a			jmp 	TIM_Error
.ad31					TIM_LoadMemory:
.ad31	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; target address => zTemp2
.ad34	a5 14		lda $14				lda 	zTemp3
.ad36	85 12		sta $12				sta 	zTemp2
.ad38	a5 15		lda $15				lda 	zTemp3+1
.ad3a	85 13		sta $13				sta 	zTemp2+1
.ad3c					_TIM_LMLoop:
.ad3c	20 7f ac	jsr $ac7f			jsr 	TIM_GetHex 					; next byte ?
.ad3f	b0 0e		bcs $ad4f			bcs 	_TIMLMDone 					; no more
.ad41	a2 00		ldx #$00			ldx 	#0							; write out.
.ad43	a5 14		lda $14				lda 	zTemp3
.ad45	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad47	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad49	d0 f1		bne $ad3c			bne 	_TIM_LMLoop
.ad4b	e6 13		inc $13				inc 	zTemp2+1
.ad4d	80 ed		bra $ad3c			bra 	_TIM_LMLoop
.ad4f					_TIMLMDone:
.ad4f	4c 51 ab	jmp $ab51			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.ad52					StructureSearchSingle:
.ad52	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.ad54					StructureSearchDouble:
.ad54	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.ad56	86 11		stx $11				stx 	zTemp1+1
.ad58	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.ad5a	85 12		sta $12				sta 	zTemp2
.ad5c	80 1a		bra $ad78			bra 	_SSWLoop 					; jump in, start scanning from here.
.ad5e					_SSWNextLine:
.ad5e	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ad60	ea		nop				nop
.ad61	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.ad63	18		clc				clc
.ad64	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.ad66	85 18		sta $18				sta 	zCodePtr
.ad68	90 02		bcc $ad6c			bcc 	_SNLNoCarry
.ad6a	e6 19		inc $19				inc 	zCodePtr+1
.ad6c					_SNLNoCarry:
.ad6c	a3 00		ldz #$00			ldz 	#0
.ad6e	ea		nop				nop
.ad6f	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ad71	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.ad73	f0 57		beq $adcc			beq 	_SSWFail
.ad75	1b		inz				inz
.ad76	1b		inz				inz
.ad77					_SSWNextSimple:
.ad77	1b		inz				inz
.ad78					_SSWLoop:
.ad78	ea		nop				nop
.ad79	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ad7b	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.ad7d	f0 df		beq $ad5e			beq 	_SSWNextLine 				; if so, then next line
.ad7f	10 f6		bpl $ad77			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.ad81	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.ad83	d0 08		bne $ad8d			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.ad85	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.ad87	f0 2f		beq $adb8			beq 	_SSWFound 					; then exit.
.ad89	c5 11		cmp $11				cmp 	zTemp1+1
.ad8b	f0 2b		beq $adb8			beq 	_SSWFound
.ad8d					_SSWCheckUpDown:
.ad8d	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.ad8f	90 10		bcc $ada1			bcc 	_SSWNext
.ad91	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.ad93	90 08		bcc $ad9d			bcc 	_SSWPlus
.ad95	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.ad97	b0 08		bcs $ada1			bcs 	_SSWNext
.ad99	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.ad9b	c6 12		dec $12				dec 	zTemp2
.ad9d					_SSWPlus:
.ad9d	e6 12		inc $12				inc 	zTemp2
.ad9f	30 18		bmi $adb9			bmi 	_SSWUnder					; error if driven -ve
.ada1					_SSWNext:
.ada1	ea		nop				nop
.ada2	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.ada4	1b		inz				inz 								; skip
.ada5	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ada7	90 0d		bcc $adb6			bcc 	_SEDone 					; so just skip over it.
.ada9	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adab	90 08		bcc $adb5			bcc 	_SEDouble
.adad	6b		tza				tza 								; this is Y + 1
.adae	18		clc				clc
.adaf	ea		nop				nop
.adb0	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.adb2	4b		taz				taz 								; back in Y.
.adb3	3b		dez				dez 								; fix up, one for the +1, one for the iny
.adb4	3b		dez				dez
.adb5					_SEDouble:
.adb5	1b		inz				inz
.adb6					_SEDone:
.adb6	80 c0		bra $ad78			bra 	_SSWLoop
.adb8					_SSWFound:
.adb8	60		rts				rts
.adb9					_SSWUnder:
.adb9	20 e0 ae	jsr $aee0			jsr ERR_Handler
>adbc	53 74 72 75 63 74 75 72			.text "Structure order",0
>adc4	65 20 6f 72 64 65 72 00
.adcc					_SSWFail:
.adcc	20 e0 ae	jsr $aee0			jsr ERR_Handler
>adcf	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>add7	6e 64 20 73 74 72 75 63 74 75 72 65 00
.ade4					SkipEndOfCommand:
.ade4	ea		nop				nop
.ade5	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ade7	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.ade9	f0 1b		beq $ae06			beq 	_SOCExit
.adeb	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.aded	f0 17		beq $ae06			beq 	_SOCExit
.adef	ea		nop				nop
.adf0	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.adf2	1b		inz				inz 								; skip
.adf3	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adf5	90 0d		bcc $ae04			bcc 	_SEDone 					; so just skip over it.
.adf7	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adf9	90 08		bcc $ae03			bcc 	_SEDouble
.adfb	6b		tza				tza 								; this is Y + 1
.adfc	18		clc				clc
.adfd	ea		nop				nop
.adfe	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.ae00	4b		taz				taz 								; back in Y.
.ae01	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ae02	3b		dez				dez
.ae03					_SEDouble:
.ae03	1b		inz				inz
.ae04					_SEDone:
.ae04	80 de		bra $ade4			bra 	SkipEndOfCommand
.ae06					_SOCExit:
.ae06	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.ae07					StackReset:
.ae07	48		pha				pha
.ae08	5a		phy				phy
.ae09	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.ae0b	85 28		sta $28				sta 	zBasicSP
.ae0d	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.ae0f	85 29		sta $29				sta 	zBasicSP+1
.ae11	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.ae13	98		tya				tya 								; be a legal token, so any attempt to
.ae14	91 28		sta ($28),y			sta 	(zBasicSP),y 				; test it will cause an error.
.ae16	7a		ply				ply
.ae17	68		pla				pla
.ae18	60		rts				rts
.ae19					StackPushFrame:
.ae19	48		pha				pha
.ae1a	5a		phy				phy
.ae1b	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.ae1c	48		pha				pha 								; save it the framing byte.
.ae1d	29 0f		and #$0f			and 	#$0F 						; lower 4 bits, which is the length.
.ae1f	18		clc				clc 								; add to Basic Stack Pointer
.ae20	65 28		adc $28				adc 	zBasicSP
.ae22	85 28		sta $28				sta 	zBasicSP
.ae24	90 02		bcc $ae28			bcc 	_SPFNoBump
.ae26	e6 29		inc $29				inc 	zBasicSP+1
.ae28					_SPFNoBump:
.ae28	a0 00		ldy #$00			ldy 	#0
.ae2a	68		pla				pla
.ae2b	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae2d	7a		ply				ply
.ae2e	68		pla				pla
.ae2f	60		rts				rts
.ae30					StackPopFrame:
.ae30	48		pha				pha
.ae31	5a		phy				phy
.ae32	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.ae34	51 28		eor ($28),y			eor 	(zBasicSP),y
.ae36	29 f0		and #$f0			and 	#$F0 						; matches if the top 4 bits zero
.ae38	d0 12		bne $ae4c			bne 	SPFError 					; mixed structures 	(helpful message ...)
.ae3a	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.ae3c	29 0f		and #$0f			and 	#$0F
.ae3e	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ae40	38		sec				sec		 							; add to stack pointer.
.ae41	65 28		adc $28				adc 	zBasicSP
.ae43	85 28		sta $28				sta 	zBasicSP
.ae45	b0 02		bcs $ae49			bcs 	_SPFNoBump
.ae47	c6 29		dec $29				dec 	zBasicSP+1
.ae49					_SPFNoBump:
.ae49	7a		ply				ply
.ae4a	68		pla				pla
.ae4b	60		rts				rts
.ae4c					SPFError:
.ae4c	20 e0 ae	jsr $aee0			jsr ERR_Handler
>ae4f	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ae57	72 75 63 74 75 72 65 73 00
.ae60					StackSavePosition:
.ae60	6b		tza				tza
.ae61	5a		phy				phy
.ae62	a0 05		ldy #$05			ldy 	#5
.ae64	91 28		sta ($28),y			sta 	(zBasicSP),y 				; save offset
.ae66	a0 01		ldy #$01			ldy 	#1
.ae68	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ae6a	91 28		sta ($28),y			sta 	(zBasicSP),y 				; this is the physical memory position.
.ae6c	c8		iny				iny
.ae6d	a5 19		lda $19				lda 	zCodePtr+1
.ae6f	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae71	c8		iny				iny
.ae72	a5 1a		lda $1a				lda 	zCodePtr+2
.ae74	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae76	c8		iny				iny
.ae77	a5 1b		lda $1b				lda 	zCodePtr+3
.ae79	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae7b	7a		ply				ply
.ae7c	60		rts				rts
.ae7d					StackRestorePosition:
.ae7d	5a		phy				phy
.ae7e	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ae80	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae82	85 18		sta $18				sta 	zCodePtr+0
.ae84	c8		iny				iny
.ae85	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae87	85 19		sta $19				sta 	zCodePtr+1
.ae89	c8		iny				iny
.ae8a	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae8c	85 1a		sta $1a				sta 	zCodePtr+2
.ae8e	c8		iny				iny
.ae8f	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae91	85 1b		sta $1b				sta 	zCodePtr+3
.ae93	c8		iny				iny
.ae94	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; restore offset
.ae96	7a		ply				ply 								; restore Y
.ae97	4b		taz				taz
.ae98	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.ae99					VIOCharPrint:
.ae99	4c 76 a0	jmp $a076			jmp 	IFT_PrintCharacter
.ae9c					VIOCharGet:
.ae9c	20 3b a2	jsr $a23b			jsr 	IF_GetKey
.ae9f	c9 00		cmp #$00			cmp 	#0
.aea1	f0 02		beq $aea5			beq 	_VCG0
.aea3	38		sec				sec
.aea4	60		rts				rts
.aea5	18		clc		_VCG0:	clc
.aea6	60		rts				rts
.aea7					VIOCheckBreak:
.aea7	4c 26 a2	jmp $a226			jmp 	IF_CheckBreak
.aeaa					VIOCharGetPosition:
.aeaa	ad 00 05	lda $0500			lda 	IFT_XCursor
.aead	60		rts				rts
.aeae					VIOReadLine:
.aeae	4c 38 a1	jmp $a138			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.aeb1					SyntaxError:
.aeb1	20 e0 ae	jsr $aee0			jsr 	ERR_Handler
>aeb4	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>aebc	72 72 6f 72 00
.aec1					TypeError:
.aec1	20 e0 ae	jsr $aee0			jsr 	ERR_Handler
>aec4	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>aecc	70 65 00
.aecf					BadParamError:
.aecf	20 e0 ae	jsr $aee0			jsr 	ERR_Handler
>aed2	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>aeda	6d 65 74 65 72 00
.aee0					ERR_Handler:
.aee0	a3 00		ldz #$00			ldz 	#0
.aee2	1b		inz				inz
.aee3	ea		nop				nop
.aee4	b2 18		lda ($18),z			lda 	(zCodePtr),z
.aee6	85 80		sta $80				sta 	XS_Mantissa
.aee8	1b		inz				inz
.aee9	ea		nop				nop
.aeea	b2 18		lda ($18),z			lda 	(zCodePtr),z
.aeec	85 81		sta $81				sta 	XS_Mantissa+1
.aeee	fa		plx				plx 								; address in XY
.aeef	7a		ply				ply
.aef0	e8		inx				inx 								; bump, because of RTS/JSR address -1
.aef1	d0 01		bne $aef4			bne 	_EHNoSkip
.aef3	c8		iny				iny
.aef4					_EHNoSkip:
.aef4	20 18 af	jsr $af18			jsr 	PrintROMMessage 			; print message from ROM.
.aef7	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.aef9	05 81		ora $81				ora 	XS_Mantissa+1
.aefb	f0 0c		beq $af09			beq 	_EHNoLine
.aefd	a2 13		ldx #$13			ldx 	#_EHAt & $FF 				; print " at "
.aeff	a0 af		ldy #$af			ldy 	#(_EHAt >> 8) & $FF
.af01	20 18 af	jsr $af18			jsr 	PrintROMMessage
.af04	a2 00		ldx #$00			ldx 	#0 							; Print line number
.af06	20 29 af	jsr $af29			jsr 	Print16BitInteger
.af09					_EHNoLine:
.af09	80 fe		bra $af09			bra 	_EHNoLine
.af0b	a9 0d		lda #$0d			lda 	#13
.af0d	20 99 ae	jsr $ae99			jsr 	VIOCharPrint
.af10	4c a1 b1	jmp $b1a1			jmp 	ErrorStart 					; normally warm start, no message.
>af13	20 61 74 20 00			_EHAt:	.text 	" at ",0
.af18					PrintROMMessage:
.af18	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.af1a	84 1d		sty $1d				sty 	zLTemp1+1
.af1c	a0 00		ldy #$00			ldy 	#0
.af1e					_PRMLoop:
.af1e	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; 6502/4510
.af20	f0 06		beq $af28			beq		_PRMExit 					; character $00 => exit
.af22	c8		iny				iny  								; bump Y and print it.
.af23	20 99 ae	jsr $ae99			jsr 	VIOCharPrint
.af26	80 f6		bra $af1e			bra 	_PRMLoop
.af28					_PRMExit:
.af28	60		rts				rts
.af29					Print16BitInteger:
.af29	a9 00		lda #$00			lda 	#0 							; make 32 bit
.af2b	85 82		sta $82				sta 	XS_Mantissa+2
.af2d	85 83		sta $83				sta 	XS_Mantissa+3
.af2f					Print32BitInteger:
.af2f	a9 00		lda #$00			lda 	#0
.af31	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.af34	aa		tax				tax 								; convert bottom level.
.af35	20 7a cb	jsr $cb7a			jsr 	INTToString 				; make string from integer in Num_Buffer
.af38	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.af3a	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.af3d	f0 06		beq $af45			beq 	_P1Exit
.af3f	20 99 ae	jsr $ae99			jsr 	VIOCharPrint
.af42	e8		inx				inx
.af43	80 f5		bra $af3a			bra 	_P1Loop
.af45	8a		txa		_P1Exit:txa 								; return chars printed.
.af46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.af47					VectorTable:
>af47	97 bd					.word BinaryOp_And         & $FFFF ; $80 and
>af49	b3 bd					.word BinaryOp_Or          & $FFFF ; $81 or
>af4b	cf bd					.word BinaryOp_Xor         & $FFFF ; $82 xor
>af4d	cf bd					.word BinaryOp_Eor         & $FFFF ; $83 eor
>af4f	06 be					.word Binary_Equal         & $FFFF ; $84 =
>af51	0f be					.word Binary_NotEqual      & $FFFF ; $85 <>
>af53	18 be					.word Binary_Less          & $FFFF ; $86 <
>af55	21 be					.word Binary_LessEqual     & $FFFF ; $87 <=
>af57	33 be					.word Binary_Greater       & $FFFF ; $88 >
>af59	2a be					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>af5b	cb be					.word BinaryOp_Add         & $FFFF ; $8a +
>af5d	e7 be					.word BinaryOp_Subtract    & $FFFF ; $8b -
>af5f	f8 be					.word BinaryOp_Multiply    & $FFFF ; $8c *
>af61	09 bf					.word BinaryOp_Divide      & $FFFF ; $8d /
>af63	05 b0					.word NotImplemented       & $FFFF ; $8e ^
>af65	f7 b6					.word Command_IF           & $FFFF ; $8f if
>af67	8c bb					.word Command_WHILE        & $FFFF ; $90 while
>af69	b4 bb					.word Command_REPEAT       & $FFFF ; $91 repeat
>af6b	38 b3					.word Command_FOR          & $FFFF ; $92 for
>af6d	05 b0					.word NotImplemented       & $FFFF ; $93 then
>af6f	5a b7					.word Command_ENDIF        & $FFFF ; $94 endif
>af71	a9 bb					.word Command_WEND         & $FFFF ; $95 wend
>af73	bd bb					.word Command_UNTIL        & $FFFF ; $96 until
>af75	b6 b3					.word Command_NEXT         & $FFFF ; $97 next
>af77	05 b0					.word NotImplemented       & $FFFF ; $98 not
>af79	05 b0					.word NotImplemented       & $FFFF ; $99 fn(
>af7b	04 c0					.word Unary_Abs            & $FFFF ; $9a abs(
>af7d	5e c1					.word Unary_Asc            & $FFFF ; $9b asc(
>af7f	a4 d2					.word Unary_Int            & $FFFF ; $9c int(
>af81	1e c0					.word Unary_Peek           & $FFFF ; $9d peek(
>af83	25 d2					.word Unary_Rnd            & $FFFF ; $9e rnd(
>af85	91 c0					.word Unary_Usr            & $FFFF ; $9f usr(
>af87	9d c1					.word Unary_Left           & $FFFF ; $a0 left$(
>af89	b2 c1					.word Unary_Right          & $FFFF ; $a1 right$(
>af8b	84 c1					.word Unary_Mid            & $FFFF ; $a2 mid$(
>af8d	fd c2					.word Unary_Spc            & $FFFF ; $a3 spc(
>af8f	2c c1					.word Unary_Str            & $FFFF ; $a4 str$(
>af91	b1 c0					.word Unary_Val            & $FFFF ; $a5 val(
>af93	75 c1					.word Unary_Len            & $FFFF ; $a6 len(
>af95	2a c2					.word Unary_Hex            & $FFFF ; $a7 hex$(
>af97	05 b0					.word NotImplemented       & $FFFF ; $a8 sin(
>af99	05 b0					.word NotImplemented       & $FFFF ; $a9 cos(
>af9b	05 b0					.word NotImplemented       & $FFFF ; $aa tan(
>af9d	05 b0					.word NotImplemented       & $FFFF ; $ab atn(
>af9f	05 b0					.word NotImplemented       & $FFFF ; $ac exp(
>afa1	05 b0					.word NotImplemented       & $FFFF ; $ad log(
>afa3	05 b0					.word NotImplemented       & $FFFF ; $ae sqr(
>afa5	80 c2					.word Unary_Dec            & $FFFF ; $af dec(
>afa7	22 c0					.word Unary_Deek           & $FFFF ; $b0 deek(
>afa9	26 c0					.word Unary_Leek           & $FFFF ; $b1 leek(
>afab	5e c0					.word Unary_Mod            & $FFFF ; $b2 mod(
>afad	be bf					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>afaf	df c2					.word Unary_Chr            & $FFFF ; $b4 chr$(
>afb1	52 c0					.word Unary_Pos            & $FFFF ; $b5 pos(
>afb3	20 c3					.word Unary_Tab            & $FFFF ; $b6 tab(
>afb5	05 b0					.word NotImplemented       & $FFFF ; $b7 $
>afb7	05 b0					.word NotImplemented       & $FFFF ; $b8 $(
>afb9	05 b0					.word NotImplemented       & $FFFF ; $b9 #
>afbb	05 b0					.word NotImplemented       & $FFFF ; $ba #(
>afbd	05 b0					.word NotImplemented       & $FFFF ; $bb %
>afbf	05 b0					.word NotImplemented       & $FFFF ; $bc %(
>afc1	05 b0					.word NotImplemented       & $FFFF ; $bd (
>afc3	05 b0					.word NotImplemented       & $FFFF ; $be )
>afc5	05 b0					.word NotImplemented       & $FFFF ; $bf ,
>afc7	37 b3					.word Command_COLON        & $FFFF ; $c0 :
>afc9	05 b0					.word NotImplemented       & $FFFF ; $c1 ;
>afcb	05 b0					.word NotImplemented       & $FFFF ; $c2 def
>afcd	6d bb					.word Command_CLR          & $FFFF ; $c3 clr
>afcf	84 bb					.word Command_STOP         & $FFFF ; $c4 stop
>afd1	92 b4					.word Command_DATA         & $FFFF ; $c5 data
>afd3	6b b4					.word Command_READ         & $FFFF ; $c6 read
>afd5	d6 b1					.word Command_DIM          & $FFFF ; $c7 dim
>afd7	05 b0					.word NotImplemented       & $FFFF ; $c8 to
>afd9	05 b0					.word NotImplemented       & $FFFF ; $c9 step
>afdb	ac ba					.word Command_GOSUB        & $FFFF ; $ca gosub
>afdd	bc ba					.word Command_RETURN       & $FFFF ; $cb return
>afdf	a4 ba					.word Command_GOTO         & $FFFF ; $cc goto
>afe1	f2 b6					.word Command_END          & $FFFF ; $cd end
>afe3	bd b5					.word Command_INPUT        & $FFFF ; $ce input
>afe5	38 b5					.word Command_LET          & $FFFF ; $cf let
>afe7	60 b7					.word Command_LIST         & $FFFF ; $d0 list
>afe9	47 ba					.word Command_NEW          & $FFFF ; $d1 new
>afeb	66 ba					.word Command_OLD          & $FFFF ; $d2 old
>afed	c5 ba					.word Command_ON           & $FFFF ; $d3 on
>afef	95 b4					.word Command_RESTORE      & $FFFF ; $d4 restore
>aff1	16 ba					.word Command_POKE         & $FFFF ; $d5 poke
>aff3	65 b9					.word Command_PRINT        & $FFFF ; $d6 print
>aff5	a4 b2					.word Command_RUN          & $FFFF ; $d7 run
>aff7	63 b2					.word Command_WAIT         & $FFFF ; $d8 wait
>aff9	a4 b5					.word Command_SYS          & $FFFF ; $d9 sys
>affb	1a ba					.word Command_DOKE         & $FFFF ; $da doke
>affd	1e ba					.word Command_LOKE         & $FFFF ; $db loke
>afff	fe b9					.word Command_ASSERT       & $FFFF ; $dc assert
>b001	59 b5					.word Command_GET          & $FFFF ; $dd get
>b003	54 b7					.word Command_ELSE         & $FFFF ; $de else
.b005					NotImplemented:
.b005	20 e0 ae	jsr $aee0			jsr ERR_Handler
>b008	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>b010	65 6d 65 6e 74 65 64 00
.b018					BinaryPrecedence:
>b018	01					.byte 1    ; $80 and
>b019	01					.byte 1    ; $81 or
>b01a	01					.byte 1    ; $82 xor
>b01b	01					.byte 1    ; $83 eor
>b01c	02					.byte 2    ; $84 =
>b01d	02					.byte 2    ; $85 <>
>b01e	02					.byte 2    ; $86 <
>b01f	02					.byte 2    ; $87 <=
>b020	02					.byte 2    ; $88 >
>b021	02					.byte 2    ; $89 >=
>b022	03					.byte 3    ; $8a +
>b023	03					.byte 3    ; $8b -
>b024	04					.byte 4    ; $8c *
>b025	04					.byte 4    ; $8d /
>b026	05					.byte 5    ; $8e ^
.b027					KeywordText:
>b027	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>b02a	4f d2					.byte $4f,$d2                          ; $81 or
>b02c	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>b02f	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>b032	bd					.byte $bd                              ; $84 =
>b033	3c be					.byte $3c,$be                          ; $85 <>
>b035	bc					.byte $bc                              ; $86 <
>b036	3c bd					.byte $3c,$bd                          ; $87 <=
>b038	be					.byte $be                              ; $88 >
>b039	3e bd					.byte $3e,$bd                          ; $89 >=
>b03b	ab					.byte $ab                              ; $8a +
>b03c	ad					.byte $ad                              ; $8b -
>b03d	aa					.byte $aa                              ; $8c *
>b03e	af					.byte $af                              ; $8d /
>b03f	de					.byte $de                              ; $8e ^
>b040	49 c6					.byte $49,$c6                          ; $8f if
>b042	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>b047	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>b04d	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>b050	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>b054	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>b059	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>b05d	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>b062	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>b066	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>b069	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>b06c	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>b070	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>b074	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>b078	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>b07d	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>b081	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>b085	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>b08b	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>b092	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>b097	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>b09b	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>b0a0	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>b0a4	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>b0a8	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>b0ad	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>b0b1	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>b0b5	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>b0b9	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>b0bd	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>b0c1	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>b0c5	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>b0c9	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>b0cd	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>b0d2	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>b0d7	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>b0db	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>b0df	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>b0e4	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>b0e8	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>b0ec	a4					.byte $a4                              ; $b7 $
>b0ed	24 a8					.byte $24,$a8                          ; $b8 $(
>b0ef	a3					.byte $a3                              ; $b9 #
>b0f0	23 a8					.byte $23,$a8                          ; $ba #(
>b0f2	a5					.byte $a5                              ; $bb %
>b0f3	25 a8					.byte $25,$a8                          ; $bc %(
>b0f5	a8					.byte $a8                              ; $bd (
>b0f6	a9					.byte $a9                              ; $be )
>b0f7	ac					.byte $ac                              ; $bf ,
>b0f8	ba					.byte $ba                              ; $c0 :
>b0f9	bb					.byte $bb                              ; $c1 ;
>b0fa	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>b0fd	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>b100	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b104	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b108	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b10c	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b10f	54 cf					.byte $54,$cf                          ; $c8 to
>b111	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b115	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b11a	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b120	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b124	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b127	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b12c	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b12f	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b133	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b136	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b139	4f ce					.byte $4f,$ce                          ; $d3 on
>b13b	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b142	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b146	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b14b	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b14e	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b152	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b155	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b159	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b15d	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b163	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b166	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>b16a	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.b16b					BASIC_Start:
.b16b	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b16d	9a		txs				txs
.b16e	20 82 a2	jsr $a282			jsr 	IF_Reset 					; set up and clear screen.
.b171	20 41 a0	jsr $a041			jsr 	IFT_ClearScreen
.b174	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b176	8d 10 03	sta $0310			sta 	LocalVector
.b179	8d 0c 03	sta $030c			sta 	UserVector
.b17c	a9 9f		lda #$9f			lda 	#USRDefault & $FF 			; reset USR vector to a default
.b17e	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.b181	a9 c0		lda #$c0			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.b183	8d 0e 03	sta $030e			sta 	UserVector+2
.b186	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b188	8d 0f 03	sta $030f			sta 	UserVector+3
.b18b	20 6d c3	jsr $c36d			jsr 	UpdateProgramEnd 			; update the program end.
.b18e	20 6d bb	jsr $bb6d			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b191	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b193	9a		txs				txs
.b194	4c a4 b2	jmp $b2a4			jmp 	COMMAND_Run
.b197	20 47 ba	jsr $ba47			jsr 	Command_NEW 				; new command, will not return.
.b19a					WarmStart:
.b19a	a2 cc		ldx #$cc			ldx 	#ReadyMsg & $FF 			; Print READY.
.b19c	a0 b1		ldy #$b1			ldy 	#(ReadyMsg >> 8) & $FF
.b19e	20 18 af	jsr $af18			jsr 	PrintROMMessage
.b1a1					ErrorStart:
.b1a1	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b1a3	9a		txs				txs
.b1a4	20 38 a1	jsr $a138			jsr 	IFT_ReadLine 				; read line in.
.b1a7	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF 		; tokenise it.
.b1a9	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.b1ab	20 0a c5	jsr $c50a			jsr 	TokeniseString
.b1ae	ad 03 04	lda $0403			lda 	TokeniseBuffer+3 			; what is first.
.b1b1	29 c0		and #$c0			and 	#$C0 						; is it a number 4000-7FFF
.b1b3	c9 40		cmp #$40			cmp 	#$40
.b1b5	f0 1d		beq $b1d4			beq 	EditLine 					; if true, go to edit line.
.b1b7	a9 00		lda #$00			lda 	#(TokeniseBuffer) & $FF
.b1b9	85 18		sta $18				sta 	zCodePtr+0
.b1bb	a9 04		lda #$04			lda 	#((TokeniseBuffer) >> 8) & $FF
.b1bd	85 19		sta $19				sta 	zCodePtr+1
.b1bf	a9 00		lda #$00			lda 	#(TokeniseBuffer) >> 16
.b1c1	85 1a		sta $1a				sta 	zCodePtr+2
.b1c3	a9 00		lda #$00			lda 	#0
.b1c5	85 1b		sta $1b				sta 	zCodePtr+3
.b1c7	a3 03		ldz #$03			ldz 	#3
.b1c9	4c dd b2	jmp $b2dd			jmp 	RUN_NextCommand
.b1cc					ReadyMsg:
>b1cc	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0
.b1d4					EditLine:
.b1d4	80 fe		bra $b1d4			bra 	EditLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b1d6					Command_DIM:
.b1d6	6b		tza				tza
.b1d7	48		pha				pha 								; push on stack.
.b1d8	20 01 c7	jsr $c701			jsr 	VariableExtract 			; get the identifier
.b1db	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b1de	29 01		and #$01			and 	#1
.b1e0	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b1e2	d0 71		bne $b255			bne 	_CDIError
.b1e4	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b1e6	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b1e9					_CDIGetDimension:
.b1e9	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.b1ec	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b1ee	f0 65		beq $b255			beq 	_CDIError
.b1f0	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; evaluate an index size
.b1f3	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b1f5	29 80		and #$80			and 	#$80
.b1f7	05 82		ora $82				ora 	XS_Mantissa+2
.b1f9	05 83		ora $83				ora 	XS_Mantissa+3
.b1fb	d0 58		bne $b255			bne 	_CDIError
.b1fd	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.b200	18		clc				clc 								; add 1 - max index => size.
.b201	a5 80		lda $80				lda 	XS_Mantissa+0
.b203	69 01		adc #$01			adc 	#1
.b205	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.b208	a5 81		lda $81				lda 	XS_Mantissa+1
.b20a	69 00		adc #$00			adc 	#0
.b20c	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.b20f	30 44		bmi $b255			bmi 	_CDIError 					; could be dim a(32767)
.b211	e8		inx				inx 								; bump index.
.b212	e8		inx				inx
.b213	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.b216	ea		nop				nop
.b217	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b219	1b		inz				inz
.b21a	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b21c	f0 cb		beq $b1e9			beq 	_CDIGetDimension
.b21e	3b		dez				dez
.b21f	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; closing ) present ?
.b222	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.b225	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b227	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.b22a					_CDICopy:
.b22a	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.b22d	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.b230	ca		dex				dex
.b231	10 f7		bpl $b22a			bpl 	_CDICopy
.b233	68		pla				pla									; position of array identifier
.b234	85 10		sta $10				sta 	zTemp1
.b236	6b		tza				tza
.b237	48		pha				pha
.b238	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b23a	4b		taz				taz
.b23b	20 01 c7	jsr $c701			jsr 	VariableExtract 			; get the identifier
.b23e	20 9c c9	jsr $c99c			jsr 	VariableLocate 				; check if it exists already.
.b241	b0 12		bcs $b255			bcs 	_CDIError
.b243	20 8f c7	jsr $c78f			jsr 	VariableCreate 				; create it using the current ArrayDef
.b246	68		pla				pla 								; restore code position
.b247	4b		taz				taz
.b248	ea		nop				nop
.b249	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b24b	1b		inz				inz
.b24c	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b24e	f0 86		beq $b1d6			beq 	Command_DIM
.b250	3b		dez				dez
.b251	20 9e c8	jsr $c89e			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.b254	60		rts				rts
.b255					_CDIError:
.b255	20 e0 ae	jsr $aee0			jsr ERR_Handler
>b258	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b260					_CDISyntax:
.b260	4c b1 ae	jmp $aeb1			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.b263					Command_WAIT:
.b263	20 78 bd	jsr $bd78			jsr		EvaluateInteger 			; get address to monitor
.b266	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.b268	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma
.b26b	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX
.b26e	a9 00		lda #$00			lda 	#0							; set default xor value.
.b270	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.b272	ea		nop				nop
.b273	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b275	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.b277	d0 06		bne $b27f			bne 	_CWAXorDefault
.b279	1b		inz				inz
.b27a	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.b27c	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX
.b27f					_CWAXorDefault:
.b27f	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.b281	85 1c		sta $1c				sta 	zLTemp1
.b283	a5 81		lda $81				lda 	XS_Mantissa+1
.b285	85 1d		sta $1d				sta 	zLTemp1+1
.b287	a5 82		lda $82				lda 	XS_Mantissa+2
.b289	85 1e		sta $1e				sta 	zLTemp1+2
.b28b					_CWAWaitLoop:
.b28b	20 a7 ae	jsr $aea7			jsr 	VIOCheckBreak 				; exit on break.
.b28e	c9 00		cmp #$00			cmp 	#0
.b290	d0 11		bne $b2a3			bne 	_CWAWaitExit
.b292	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.b294	a2 00		ldx #$00			ldx 	#0
.b296	5a		phy				phy 								; this is the same routine as PEEK.
.b297	20 45 c3	jsr $c345			jsr 	MemRead
.b29a	7a		ply				ply
.b29b	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.b29d	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.b29f	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.b2a1	f0 e8		beq $b28b			beq 	_CWAWaitLoop 				; and loop if zero.
.b2a3					_CWAWaitExit:
.b2a3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b2a4					Command_RUN:
.b2a4	20 6d bb	jsr $bb6d			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b2a7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.b2a9	85 18		sta $18				sta 	zCodePtr+0
.b2ab	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.b2ad	85 19		sta $19				sta 	zCodePtr+1
.b2af	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.b2b1	85 1a		sta $1a				sta 	zCodePtr+2
.b2b3	a9 00		lda #$00			lda 	#0
.b2b5	85 1b		sta $1b				sta 	zCodePtr+3
.b2b7	a3 03		ldz #$03			ldz 	#3
.b2b9					RUN_NewLine:
.b2b9	a3 00		ldz #$00			ldz 	#0
.b2bb	ea		nop				nop
.b2bc	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b2be	1b		inz				inz
.b2bf	1b		inz				inz
.b2c0	1b		inz				inz
.b2c1	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b2c3	d0 18		bne $b2dd			bne 	RUN_NextCommand
.b2c5	4c f2 b6	jmp $b6f2			jmp 	Command_END 				; go do the command code.
.b2c8					RUN_Skip:
.b2c8	ea		nop				nop
.b2c9	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b2cb	1b		inz				inz 								; skip
.b2cc	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b2ce	90 0d		bcc $b2dd			bcc 	_SEDone 					; so just skip over it.
.b2d0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b2d2	90 08		bcc $b2dc			bcc 	_SEDouble
.b2d4	6b		tza				tza 								; this is Y + 1
.b2d5	18		clc				clc
.b2d6	ea		nop				nop
.b2d7	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b2d9	4b		taz				taz 								; back in Y.
.b2da	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b2db	3b		dez				dez
.b2dc					_SEDouble:
.b2dc	1b		inz				inz
.b2dd					_SEDone:
.b2dd					RUN_NextCommand:
.b2dd	ad a8 03	lda $03a8			lda 	BreakCount 					; check the break counter
.b2e0	69 10		adc #$10			adc 	#16 						; one time in 16
.b2e2	8d a8 03	sta $03a8			sta 	BreakCount
.b2e5	90 0a		bcc $b2f1			bcc 	RUN_NoCheckBreak
.b2e7	20 a7 ae	jsr $aea7			jsr 	VIOCheckBreak 				; check for break
.b2ea	c9 00		cmp #$00			cmp 	#0
.b2ec	f0 03		beq $b2f1			beq 	RUN_NoCheckBreak
.b2ee	4c 84 bb	jmp $bb84			jmp 	Command_STOP 				; stop on BREAK.
.b2f1					RUN_NoCheckBreak:
.b2f1	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b2f3	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.b2f5	ea		nop				nop
.b2f6	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b2f8	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b2fa	f0 cc		beq $b2c8			beq 	RUN_Skip
.b2fc	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b2fe	d0 10		bne $b310			bne 	RUN_Execute		 			; zero => end of the current line.
.b300					RUN_NextLine:
.b300	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b302	ea		nop				nop
.b303	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b305	18		clc				clc
.b306	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b308	85 18		sta $18				sta 	zCodePtr
.b30a	90 02		bcc $b30e			bcc 	_SNLNoCarry
.b30c	e6 19		inc $19				inc 	zCodePtr+1
.b30e					_SNLNoCarry:
.b30e	80 a9		bra $b2b9			bra 	RUN_NewLine 				; go do the new line code
.b310					RUN_Execute:
.b310	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b312	b0 1c		bcs $b330			bcs 	RUN_Extension
.b314	1b		inz				inz
.b315	0a		asl a				asl 	a 							; double the character read.
.b316	90 12		bcc $b32a			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b318	aa		tax				tax 								; ready to look up.
.b319	bd 47 af	lda $af47,x			lda 	VectorTable,x 				; copy address into LocalVector
.b31c	8d 11 03	sta $0311			sta 	LocalVector+1
.b31f	bd 48 af	lda $af48,x			lda 	VectorTable+1,x
.b322	8d 12 03	sta $0312			sta 	LocalVector+2
.b325	20 c1 bc	jsr $bcc1			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b328	80 b3		bra $b2dd			bra 	RUN_NextCommand 			; do the next command.
.b32a					RUN_Default:
.b32a	3b		dez				dez
.b32b	20 38 b5	jsr $b538			jsr 	Command_LET 				; and try LET.
.b32e	80 ad		bra $b2dd			bra 	RUN_NextCommand
.b330					RUN_Extension:
.b330	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b332	f0 94		beq $b2c8			beq 	RUN_Skip 					; skip over it
.b334	4c b1 ae	jmp $aeb1			jmp 	SyntaxError
.b337					Command_COLON:
.b337	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.b338					Command_FOR:
.b338	20 38 b5	jsr $b538			jsr 	Command_LET 				; do the A = 99 bit
.b33b	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.b33d	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b33f	f0 72		beq $b3b3			beq 	_CFOError
.b341	48		pha				pha 								; save the variable type.
.b342	5a		phy				phy 								; save type/variable address.
.b343	a0 01		ldy #$01			ldy 	#1							; type at + 1
.b345	91 28		sta ($28),y			sta 	(zBasicSP),y
.b347	c8		iny				iny
.b348	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.b34a	91 28		sta ($28),y			sta 	(zBasicSP),y
.b34c	c8		iny				iny
.b34d	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.b34f	91 28		sta ($28),y			sta 	(zBasicSP),y
.b351	7a		ply				ply
.b352	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.b354	20 19 ae	jsr $ae19			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.b357	a9 c8		lda #$c8			lda 	#token_TO
.b359	20 b6 c3	jsr $c3b6			jsr 	CheckNextToken
.b35c	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.b35e	20 db bb	jsr $bbdb			jsr 	EvaluateExpression
.b361	ea		nop				nop
.b362	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b364	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.b366	c9 c9		cmp #$c9			cmp 	#token_STEP
.b368	d0 06		bne $b370			bne 	_CFOStep1
.b36a	1b		inz				inz
.b36b	20 dd bb	jsr $bbdd			jsr 	EvaluateExpressionX 		; get STEP value.
.b36e	80 0e		bra $b37e			bra 	_CFOHaveStep
.b370					_CFOStep1:
.b370	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.b372	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b374	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b376	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b378	a9 01		lda #$01			lda 	#1
.b37a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b37c	95 85		sta $85,x			sta 	XS_Type,x
.b37e					_CFOHaveStep:
.b37e	68		pla				pla 								; restore variable type
.b37f	a2 00		ldx #$00			ldx 	#0
.b381	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.b383	f0 0a		beq $b38f			beq 	_CFOInteger
.b385	20 a5 cf	jsr $cfa5			jsr 	FPUToFloat
.b388	a2 06		ldx #$06			ldx 	#6
.b38a	20 a5 cf	jsr $cfa5			jsr 	FPUToFloat
.b38d	80 08		bra $b397			bra 	_CFOEndConv
.b38f					_CFOInteger:
.b38f	20 f1 cf	jsr $cff1			jsr 	FPUToInteger
.b392	a2 06		ldx #$06			ldx 	#6
.b394	20 f1 cf	jsr $cff1			jsr 	FPUToInteger
.b397					_CFOEndConv:
.b397	20 60 ae	jsr $ae60			jsr 	StackSavePosition 			; save the loop position at 1-5
.b39a	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.b39c	20 19 ae	jsr $ae19			jsr 	StackPushFrame 				; push the loop address frame.
.b39f	5a		phy				phy
.b3a0	a0 00		ldy #$00			ldy 	#0
.b3a2					_CFOCopy:
.b3a2	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.b3a5	c8		iny				iny
.b3a6	91 28		sta ($28),y			sta 	(zBasicSP),y
.b3a8	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.b3aa	d0 f6		bne $b3a2			bne 	_CFOCopy
.b3ac	7a		ply				ply
.b3ad	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.b3af	20 19 ae	jsr $ae19			jsr 	StackPushFrame
.b3b2	60		rts				rts
.b3b3					_CFOError:
.b3b3	4c c1 ae	jmp $aec1			jmp 	TypeError 					; wrong type.
.b3b6					Command_NEXT:
.b3b6	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.b3b8	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.b3ba	ea		nop				nop
.b3bb	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b3bd	c9 00		cmp #$00			cmp 	#0 							; EOL
.b3bf	f0 07		beq $b3c8			beq 	_CNextNoVariable
.b3c1	c9 40		cmp #$40			cmp 	#$40
.b3c3	b0 03		bcs $b3c8			bcs 	_CNextNoVariable
.b3c5	20 94 c6	jsr $c694			jsr 	VariableFind
.b3c8					_CNextNoVariable:
.b3c8	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.b3ca	48		pha				pha
.b3cb	a5 29		lda $29				lda 	zBasicSP+1
.b3cd	48		pha				pha
.b3ce	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.b3d0	20 30 ae	jsr $ae30			jsr 	StackPopFrame
.b3d3	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.b3d5	20 30 ae	jsr $ae30			jsr 	StackPopFrame
.b3d8	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.b3da	20 30 ae	jsr $ae30			jsr 	StackPopFrame
.b3dd	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.b3df	f0 11		beq $b3f2			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.b3e1	5a		phy				phy 								; check addresses match.
.b3e2	a0 02		ldy #$02			ldy 	#2
.b3e4	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3e6	c5 24		cmp $24				cmp 	zVarDataPtr
.b3e8	d0 6a		bne $b454			bne 	_CNextWrong
.b3ea	c8		iny				iny
.b3eb	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3ed	c5 25		cmp $25				cmp 	zVarDataPtr+1
.b3ef	d0 63		bne $b454			bne 	_CNextWrong
.b3f1	7a		ply				ply
.b3f2					_CNextGetTarget:
.b3f2	5a		phy				phy
.b3f3	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.b3f5	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3f7	85 26		sta $26				sta 	zVarType
.b3f9	c8		iny				iny
.b3fa	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b3fc	85 24		sta $24				sta 	zVarDataPtr
.b3fe	c8		iny				iny
.b3ff	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b401	85 25		sta $25				sta 	zVarDataPtr+1
.b403	a2 0c		ldx #$0c			ldx 	#12
.b405	20 e0 c9	jsr $c9e0			jsr 	VariableGet 				; get that variable value into expr[2]
.b408	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.b40a	a0 0b		ldy #$0b			ldy 	#11
.b40c					_CNXCopy:
.b40c	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b40e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b410	e8		inx				inx
.b411	c8		iny				iny
.b412	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.b414	d0 f6		bne $b40c			bne 	_CNXCopy
.b416	7a		ply				ply
.b417	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.b419	20 e2 bf	jsr $bfe2			jsr 	GetSignCurrent
.b41c	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.b41f	a2 06		ldx #$06			ldx 	#6 							; add them, however
.b421	20 cb be	jsr $becb			jsr 	BinaryOp_Add
.b424	20 31 ca	jsr $ca31			jsr 	VariableSet					; and write variable back.
.b427	a2 00		ldx #$00			ldx 	#0
.b429	20 4f be	jsr $be4f			jsr 	CompareValues
.b42c	09 00		ora #$00			ora 	#0
.b42e	f0 05		beq $b435			beq 	_CNXAgain 					; if true, then do it again.
.b430	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.b433	d0 0f		bne $b444			bne 	_CNXLoopDone
.b435					_CNXAgain:
.b435	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.b437	20 19 ae	jsr $ae19			jsr 	StackPushFrame
.b43a	20 7d ae	jsr $ae7d			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.b43d	68		pla				pla
.b43e	85 29		sta $29				sta 	zBasicSP+1
.b440	68		pla				pla
.b441	85 28		sta $28				sta 	zBasicSP
.b443					_CNXExit:
.b443	60		rts				rts
.b444					_CNXLoopDone:
.b444	68		pla				pla 								; throw away saved to Basic Stack Pointer
.b445	68		pla				pla
.b446	ea		nop				nop
.b447	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b449	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.b44b	d0 f6		bne $b443			bne 	_CNXExit
.b44d	1b		inz				inz
.b44e	20 94 c6	jsr $c694			jsr 	VariableFind 				; identify the variable
.b451	4c c8 b3	jmp $b3c8			jmp 	_CNextNoVariable 			; go back with variable pre-found
.b454					_CNextWrong:
.b454	20 e0 ae	jsr $aee0			jsr ERR_Handler
>b457	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>b45f	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.b46b					Command_READ:
.b46b	20 94 c6	jsr $c694			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.b46e	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.b470	48		pha				pha
.b471	a5 25		lda $25				lda 	zVarDataPtr+1
.b473	48		pha				pha
.b474	a5 26		lda $26				lda 	zVarType
.b476	48		pha				pha
.b477	20 be b4	jsr $b4be			jsr 	READGetDataItem 			; get the next data item
.b47a	68		pla				pla 								; restore target variable information.
.b47b	85 26		sta $26				sta 	zVarType
.b47d	68		pla				pla
.b47e	85 25		sta $25				sta 	zVarDataPtr+1
.b480	68		pla				pla
.b481	85 24		sta $24				sta 	zVarDataPtr
.b483	a2 00		ldx #$00			ldx 	#0
.b485	20 31 ca	jsr $ca31			jsr 	VariableSet 				; set the value out.
.b488	ea		nop				nop
.b489	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b48b	1b		inz				inz
.b48c	c9 bf		cmp #$bf			cmp 	#token_Comma
.b48e	f0 db		beq $b46b			beq 	Command_READ 				; found, do another READ
.b490	3b		dez				dez
.b491	60		rts				rts
.b492					Command_DATA:
.b492	4c e4 ad	jmp $ade4			jmp 	SkipEndOfCommand
.b495					Command_RESTORE:
.b495	48		pha				pha
.b496	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.b498	8d bd 03	sta $03bd			sta 	DataLPtr+0
.b49b	8d be 03	sta $03be			sta 	DataLPtr+1
.b49e	68		pla				pla
.b49f	60		rts				rts
.b4a0					READSwapPointers:
.b4a0	6b		tza				tza
.b4a1	48		pha				pha 								; save it
.b4a2	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.b4a5	4b		taz				taz
.b4a6	68		pla				pla 								; get code offset and save in DataIndex
.b4a7	8d c1 03	sta $03c1			sta 	DataIndex
.b4aa	da		phx				phx
.b4ab	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.b4ad					_RSWLoop:
.b4ad	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.b4b0	48		pha				pha
.b4b1	b5 18		lda $18,x			lda 	zCodePtr+0,x
.b4b3	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.b4b6	68		pla				pla
.b4b7	95 18		sta $18,x			sta 	zCodePtr+0,x
.b4b9	ca		dex				dex
.b4ba	10 f1		bpl $b4ad			bpl 	_RSWLoop
.b4bc	fa		plx				plx
.b4bd	60		rts				rts
.b4be					READGetDataItem:
.b4be	20 a0 b4	jsr $b4a0			jsr 	ReadSwapPointers 			; swap code and data pointer.
.b4c1	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.b4c3	05 19		ora $19				ora 	zCodePtr+1
.b4c5	d0 14		bne $b4db			bne 	_RGDIIsInitialised
.b4c7	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.b4c9	85 18		sta $18				sta 	zCodePtr+0
.b4cb	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.b4cd	85 19		sta $19				sta 	zCodePtr+1
.b4cf	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.b4d1	85 1a		sta $1a				sta 	zCodePtr+2
.b4d3	a9 00		lda #$00			lda 	#0
.b4d5	85 1b		sta $1b				sta 	zCodePtr+3
.b4d7	a3 03		ldz #$03			ldz 	#3
.b4d9	80 07		bra $b4e2			bra 	_RGDIFindData 				; locate next data from start and read that.
.b4db					_RGDIIsInitialised:
.b4db	ea		nop				nop
.b4dc	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b4de	c9 bf		cmp #$bf			cmp 	#token_Comma
.b4e0	f0 4e		beq $b530			beq 	_RGDISkipEvaluateExit
.b4e2					_RGDIFindData:
.b4e2	ea		nop				nop
.b4e3	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b4e5	c9 00		cmp #$00			cmp 	#0 							; end of line
.b4e7	f0 1b		beq $b504			beq 	_RGDIFindNextLine
.b4e9	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.b4eb	f0 43		beq $b530			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.b4ed	ea		nop				nop
.b4ee	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b4f0	1b		inz				inz 								; skip
.b4f1	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b4f3	90 0d		bcc $b502			bcc 	_SEDone 					; so just skip over it.
.b4f5	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b4f7	90 08		bcc $b501			bcc 	_SEDouble
.b4f9	6b		tza				tza 								; this is Y + 1
.b4fa	18		clc				clc
.b4fb	ea		nop				nop
.b4fc	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b4fe	4b		taz				taz 								; back in Y.
.b4ff	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b500	3b		dez				dez
.b501					_SEDouble:
.b501	1b		inz				inz
.b502					_SEDone:
.b502	80 de		bra $b4e2			bra 	_RGDIFindData
.b504					_RGDIFindNextLine:
.b504	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b506	ea		nop				nop
.b507	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b509	18		clc				clc
.b50a	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b50c	85 18		sta $18				sta 	zCodePtr
.b50e	90 02		bcc $b512			bcc 	_SNLNoCarry
.b510	e6 19		inc $19				inc 	zCodePtr+1
.b512					_SNLNoCarry:
.b512	a3 00		ldz #$00			ldz 	#0
.b514	ea		nop				nop
.b515	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b517	48		pha				pha
.b518	1b		inz				inz
.b519	1b		inz				inz
.b51a	1b		inz				inz
.b51b	68		pla				pla
.b51c	d0 c4		bne $b4e2			bne 	_RGDIFindData 				; back to scanning.
.b51e	20 a0 b4	jsr $b4a0			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.b521	20 e0 ae	jsr $aee0			jsr ERR_Handler
>b524	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>b52c	61 74 61 00
.b530					_RGDISkipEvaluateExit:
.b530	1b		inz				inz
.b531	20 db bb	jsr $bbdb			jsr 	EvaluateExpression 			; evaluate the expression
.b534	20 a0 b4	jsr $b4a0			jsr 	ReadSwapPointers 			; swap the pointers around.
.b537	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b538					Command_LET:
.b538	20 94 c6	jsr $c694			jsr 	VariableFind 				; get reference to one variable.
.b53b	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b53d	20 b6 c3	jsr $c3b6			jsr 	CheckNextToken
.b540	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.b542	48		pha				pha
.b543	a5 25		lda $25				lda 	zVarDataPtr+1
.b545	48		pha				pha
.b546	a5 26		lda $26				lda 	zVarType
.b548	48		pha				pha
.b549	20 db bb	jsr $bbdb			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.b54c	68		pla				pla 								; restore target variable information.
.b54d	85 26		sta $26				sta 	zVarType
.b54f	68		pla				pla
.b550	85 25		sta $25				sta 	zVarDataPtr+1
.b552	68		pla				pla
.b553	85 24		sta $24				sta 	zVarDataPtr
.b555	20 31 ca	jsr $ca31			jsr 	VariableSet 				; set the value out.
.b558	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.b559					Command_GET:
.b559					_CGLoop:
.b559	20 94 c6	jsr $c694			jsr 	VariableFind 				; get a variable - that we'll GET into.
.b55c	20 9c ae	jsr $ae9c			jsr 	VIOCharGet 					; get character
.b55f	b0 02		bcs $b563			bcs 	_CGNoKey
.b561	a9 00		lda #$00			lda 	#0 							; if no character return zero
.b563					_CGNoKey:
.b563	48		pha				pha
.b564	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.b566	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b568	f0 1f		beq $b589			beq 	_CGString
.b56a	68		pla				pla 								; put character in slot.
.b56b	85 80		sta $80				sta 	XS_Mantissa
.b56d	a9 00		lda #$00			lda 	#0 							; rest is zero.
.b56f	85 81		sta $81				sta 	XS_Mantissa+1
.b571	85 82		sta $82				sta 	XS_Mantissa+2
.b573	85 83		sta $83				sta 	XS_Mantissa+3
.b575	a9 01		lda #$01			lda 	#1 							; type integer
.b577	85 85		sta $85				sta 	XS_Type
.b579					_CGWriteSetNext:
.b579	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.b57b	20 31 ca	jsr $ca31			jsr 	VariableSet
.b57e	ea		nop				nop
.b57f	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b581	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.b583	d0 03		bne $b588			bne 	_CGExit
.b585	1b		inz				inz
.b586	80 d1		bra $b559			bra 	_CGLoop 					; and get another.
.b588					_CGExit:
.b588	60		rts				rts
.b589					_CGString:
.b589	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2 (char/size)
.b58b	20 1d c4	jsr $c41d			jsr 	AllocateTempString 			; initially empty.
.b58e	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.b590	85 80		sta $80				sta 	XS_Mantissa
.b592	a5 23		lda $23				lda 	zTempStr+1
.b594	85 81		sta $81				sta 	XS_Mantissa+1
.b596	a9 02		lda #$02			lda 	#2 							; as a string
.b598	85 85		sta $85				sta 	XS_Type
.b59a	68		pla				pla 								; get A
.b59b	c9 00		cmp #$00			cmp 	#0 							; if nothing received, return null string.
.b59d	f0 da		beq $b579			beq 	_CGWriteSetNext
.b59f	20 48 c4	jsr $c448			jsr 	WriteTempString 			; write it into string and return it.
.b5a2	80 d5		bra $b579			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.b5a4					Command_SYS:
.b5a4	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; address to call.
.b5a7	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.b5a9	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.b5ac	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.b5ae	8d 11 03	sta $0311			sta 	LocalVector+1
.b5b1	a5 82		lda $82				lda 	XS_Mantissa+2
.b5b3	8d 12 03	sta $0312			sta 	LocalVector+2
.b5b6	20 ba b5	jsr $b5ba			jsr 	_CSYLocalCall
.b5b9	60		rts				rts
.b5ba					_CSYLocalCall:
.b5ba	6c 10 03	jmp ($0310)			jmp 	(LocalVector)

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.b5bd					Command_INPUT:
.b5bd	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.b5bf	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.b5c2	8d c3 03	sta $03c3		sta 	InputRetry
.b5c5					_CILoop:
.b5c5	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.b5c7	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.b5c9	ea		nop				nop
.b5ca	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b5cc	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.b5ce	d0 17		bne $b5e7		bne 	_CINoPrompt
.b5d0	1b		inz				inz
.b5d1	ea		nop				nop
.b5d2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b5d4	aa		tax			tax 									; into X
.b5d5	1b		inz				inz
.b5d6	ca		dex			dex 									; deduct marker/prompt length
.b5d7	ca		dex			dex
.b5d8	f0 eb		beq $b5c5		beq 	_CILoop 						; nothing.
.b5da					_CIShowPrompt:
.b5da	ea		nop				nop
.b5db	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b5dd	20 99 ae	jsr $ae99		jsr 	VIOCharPrint
.b5e0	1b		inz				inz
.b5e1	ca		dex			dex
.b5e2	d0 f6		bne $b5da		bne 	_CIShowPrompt
.b5e4	80 df		bra $b5c5		bra 	_CILoop
.b5e6					_CIAdvance:
.b5e6	1b		inz				inz
.b5e7					_CINoPrompt:
.b5e7	ea		nop				nop
.b5e8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b5ea	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.b5ec	f0 f8		beq $b5e6		beq 	_CIAdvance
.b5ee	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.b5f0	f0 f4		beq $b5e6		beq 	_CIAdvance
.b5f2	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.b5f4	f0 04		beq $b5fa		beq 	_CIExit
.b5f6	c9 c0		cmp #$c0		cmp 	#token_Colon
.b5f8	d0 01		bne $b5fb		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.b5fa					_CIExit:
.b5fa	60		rts			rts
.b5fb					_CIIsVariable:
.b5fb	20 94 c6	jsr $c694		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.b5fe	a5 26		lda $26			lda 	zVarType
.b600	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.b602	f0 40		beq $b644		beq 	_CIIsString
.b604					_CINGetText:
.b604	a9 00		lda #$00		lda 	#0
.b606	8d 14 03	sta $0314		sta 	NumBufX
.b609					_CINSkip:
.b609	20 a3 b6	jsr $b6a3		jsr 	CIGetCharacter 					; get character skip spaces
.b60c	c9 20		cmp #$20		cmp 	#" "
.b60e	f0 f9		beq $b609		beq 	_CINSkip
.b610	c9 2c		cmp #$2c		cmp 	#","
.b612	f0 f5		beq $b609		beq 	_CINSkip
.b614					_CINLoop:
.b614	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.b617	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.b61a	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.b61c	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.b61f	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.b622	20 a3 b6	jsr $b6a3		jsr 	CIGetCharacter 					; get next character
.b625	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.b627	f0 08		beq $b631		beq 	_CINCopied
.b629	c9 2c		cmp #$2c		cmp 	#","
.b62b	f0 04		beq $b631		beq 	_CINCopied
.b62d	c9 21		cmp #$21		cmp 	#" "+1
.b62f	b0 e3		bcs $b614		bcs 	_CINLoop
.b631					_CINCopied:
.b631	a2 00		ldx #$00		ldx 	#0
.b633	20 f0 c0	jsr $c0f0		jsr 	ConvertNumBuffer 				; convert number
.b636	b0 05		bcs $b63d		bcs 	_CINFailed 						; didn't work.
.b638	20 31 ca	jsr $ca31		jsr 	VariableSet 					; set variable.
.b63b	80 88		bra $b5c5		bra 	_CILoop 						; go round again.
.b63d					_CINFailed:
.b63d	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.b63f	8d c2 03	sta $03c2		sta 	InputAvailable
.b642	80 c0		bra $b604		bra 	_CINGetText 					; and try again
.b644					_CIIsString:
.b644	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.b646	20 1d c4	jsr $c41d		jsr 	AllocateTempString
.b649	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.b64b	8d 14 03	sta $0314		sta 	NumBufX
.b64e					_CISSkip:
.b64e	20 a3 b6	jsr $b6a3		jsr 	CIGetCharacter 					; get character skip spaces
.b651	c9 20		cmp #$20		cmp 	#" "
.b653	f0 f9		beq $b64e		beq 	_CISSkip
.b655	80 03		bra $b65a		bra 	_CISInputProcess 				; handle that as the first character
.b657					_CISInput:
.b657	20 a3 b6	jsr $b6a3		jsr 	CIGetCharacter
.b65a					_CISInputProcess:
.b65a	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.b65c	f0 31		beq $b68f		beq 	_CISDone
.b65e	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.b660	d0 05		bne $b667		bne 	_CISNotColon
.b662	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.b665	10 28		bpl $b68f		bpl 	_CISDone 						; if quote flag zero, done
.b667					_CISNotColon:
.b667	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.b669	f0 1a		beq $b685		beq 	_CISIsQuote						; if so handle that code.
.b66b	20 48 c4	jsr $c448		jsr 	WriteTempString 				; write to the temporary string
.b66e	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.b671	10 e4		bpl $b657		bpl 	_CISInput
.b673	20 e0 ae	jsr $aee0			jsr ERR_Handler
>b676	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>b67e	6f 20 6c 6f 6e 67 00
.b685					_CISIsQuote:
.b685	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.b688	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.b68a	8d 14 03	sta $0314		sta 	NumBufX
.b68d	d0 c8		bne $b657		bne 	_CISInput 						; if entered quote mode, get next character
.b68f					_CISDone:
.b68f	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.b691	85 80		sta $80			sta 	XS_Mantissa+0
.b693	a5 23		lda $23			lda 	zTempStr+1
.b695	85 81		sta $81			sta 	XS_Mantissa+1
.b697	a9 02		lda #$02		lda 	#2
.b699	85 85		sta $85			sta 	XS_Type
.b69b	a2 00		ldx #$00		ldx 	#0
.b69d	20 31 ca	jsr $ca31		jsr 	VariableSet 					; set variable.
.b6a0	4c c5 b5	jmp $b5c5		jmp 	_CILoop 						; and try again
.b6a3					CIGetCharacter:
.b6a3	5a		phy			phy
.b6a4	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.b6a7	f0 0c		beq $b6b5		beq 	_CIGCNewLine 					; no, needs a new line.
.b6a9	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.b6ac	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.b6ae	f0 03		beq $b6b3		beq 	_CIGCNoInc
.b6b0	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.b6b3					_CIGCNoInc:
.b6b3	7a		ply			ply
.b6b4	60		rts			rts
.b6b5					_CIGCNewLine:
.b6b5	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.b6b8	a9 3f		lda #$3f		lda 	#"?"
.b6ba	20 99 ae	jsr $ae99		jsr 	VIOCharPrint
.b6bd	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.b6c0	f0 03		beq $b6c5		beq 	_CIGCPrompt 					; if so, then print ? again
.b6c2	20 99 ae	jsr $ae99		jsr 	VIOCharPrint
.b6c5					_CIGCPrompt:
.b6c5	a0 01		ldy #$01		ldy 	#1
.b6c7	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.b6ca					_CIGCBackOne:
.b6ca	88		dey			dey
.b6cb					_CIGCLoop:
.b6cb	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.b6cd	f0 fb		beq $b6ca		beq 	_CIGCBackOne
.b6cf	20 9c ae	jsr $ae9c		jsr 	VIOCharGet 						; get a character
.b6d2	f0 f7		beq $b6cb		beq 	_CIGCLoop 						; wait until key pressed
.b6d4	c9 08		cmp #$08		cmp 	#8 								; backspace
.b6d6	f0 10		beq $b6e8		beq 	_CIGCBackSpace
.b6d8	20 99 ae	jsr $ae99		jsr 	VIOCharPrint 					; echo character
.b6db	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.b6de	c8		iny			iny
.b6df	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.b6e1	d0 e8		bne $b6cb		bne 	_CIGCLoop
.b6e3	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.b6e6	7a		ply			ply 									; restore Y
.b6e7	60		rts			rts
.b6e8					_CIGCBackSpace:
.b6e8	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.b6ea	f0 df		beq $b6cb		beq 	_CIGCLoop
.b6ec	20 99 ae	jsr $ae99		jsr 	VIOCharPrint 					; echo BS
.b6ef	88		dey			dey 									; go back one.
.b6f0	80 d9		bra $b6cb		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b6f2					Command_END:
.b6f2	80 fe		bra $b6f2	_halt:	bra 		_halt
.b6f4	4c 9a b1	jmp $b19a			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.b6f7					Command_IF:
.b6f7	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; check success.
.b6fa	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b6fc	05 81		ora $81				ora 	XS_Mantissa+1
.b6fe	05 82		ora $82				ora 	XS_Mantissa+2
.b700	05 83		ora $83				ora 	XS_Mantissa+3
.b702	aa		tax				tax 								; put into X.
.b703	ea		nop				nop
.b704	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b706	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.b708	d0 30		bne $b73a			bne 	_FIFExtended
.b70a	1b		inz				inz
.b70b	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.b70d	f0 0c		beq $b71b			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.b70f	ea		nop				nop
.b710	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b712	29 c0		and #$c0			and 	#$C0 						; is it a number
.b714	c9 40		cmp #$40			cmp 	#$40
.b716	d0 21		bne $b739			bne 	_FIFContinue 				; if not, do what ever follows.
.b718	4c a4 ba	jmp $baa4			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.b71b					_FIFEndOfLine:
.b71b	ea		nop				nop
.b71c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b71e	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.b720	f0 17		beq $b739			beq 	_FIFContinue
.b722	ea		nop				nop
.b723	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b725	1b		inz				inz 								; skip
.b726	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b728	90 0d		bcc $b737			bcc 	_SEDone 					; so just skip over it.
.b72a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b72c	90 08		bcc $b736			bcc 	_SEDouble
.b72e	6b		tza				tza 								; this is Y + 1
.b72f	18		clc				clc
.b730	ea		nop				nop
.b731	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b733	4b		taz				taz 								; back in Y.
.b734	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b735	3b		dez				dez
.b736					_SEDouble:
.b736	1b		inz				inz
.b737					_SEDone:
.b737	80 e2		bra $b71b			bra 	_FIFEndOfLine
.b739					_FIFContinue:
.b739	60		rts				rts
.b73a					_FIFExtended:
.b73a	da		phx				phx 								; save result
.b73b	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.b73d	20 19 ae	jsr $ae19			jsr 	StackPushFrame
.b740	68		pla				pla 								; restore result
.b741	f0 01		beq $b744			beq 	_FIXSkip 					; if zero then it has failed.
.b743	60		rts				rts 								; test passed, so continue executing
.b744					_FIXSkip:
.b744	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.b746	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.b748	20 54 ad	jsr $ad54			jsr 	StructureSearchDouble
.b74b	ea		nop				nop
.b74c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b74e	1b		inz				inz
.b74f	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.b751	f0 07		beq $b75a			beq 	Command_ENDIF
.b753	60		rts				rts
.b754					Command_ELSE:
.b754	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.b756	20 52 ad	jsr $ad52			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.b759	1b		inz				inz
.b75a					Command_ENDIF:
.b75a	a9 40		lda #$40			lda 	#(SMark_If << 4)
.b75c	20 30 ae	jsr $ae30			jsr 	StackPopFrame
.b75f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b760					Command_LIST:
.b760	20 f9 b8	jsr $b8f9			jsr 	ListGetRange				; get any parameters
.b763	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.b765	85 18		sta $18				sta 	zCodePtr+0
.b767	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.b769	85 19		sta $19				sta 	zCodePtr+1
.b76b	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.b76d	85 1a		sta $1a				sta 	zCodePtr+2
.b76f	a9 00		lda #$00			lda 	#0
.b771	85 1b		sta $1b				sta 	zCodePtr+3
.b773	a3 03		ldz #$03			ldz 	#3
.b775	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.b777	8d bc 03	sta $03bc			sta 	LastListIndent
.b77a	8d bb 03	sta $03bb			sta 	ListIndent
.b77d					_CILLoop:
.b77d	a3 00		ldz #$00			ldz 	#0
.b77f	ea		nop				nop
.b780	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b782	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b784	f0 24		beq $b7aa			beq 	_CILExit
.b786	20 a7 ae	jsr $aea7			jsr 	VIOCheckBreak 				; check break
.b789	c9 00		cmp #$00			cmp 	#0
.b78b	d0 1d		bne $b7aa			bne 	_CILExit
.b78d	20 43 b9	jsr $b943			jsr 	ListCheckRange 				; check current line in range.
.b790	b0 08		bcs $b79a			bcs		_CILNext
.b792	a3 00		ldz #$00			ldz 	#0
.b794	1b		inz				inz
.b795	1b		inz				inz
.b796	1b		inz				inz
.b797	20 ad b7	jsr $b7ad			jsr 	ListLine 					; list one line.
.b79a					_CILNext:
.b79a	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b79c	ea		nop				nop
.b79d	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b79f	18		clc				clc
.b7a0	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b7a2	85 18		sta $18				sta 	zCodePtr
.b7a4	90 02		bcc $b7a8			bcc 	_SNLNoCarry
.b7a6	e6 19		inc $19				inc 	zCodePtr+1
.b7a8					_SNLNoCarry:
.b7a8	80 d3		bra $b77d			bra 	_CILLoop
.b7aa					_CILExit:
.b7aa	4c 9a b1	jmp $b19a			jmp 	WarmStart
.b7ad					ListLine:
.b7ad	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.b7b0	8d bc 03	sta $03bc			sta 	LastListIndent
.b7b3					_LICountIndent:
.b7b3	ea		nop				nop
.b7b4	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7b6	c9 00		cmp #$00			cmp 	#0
.b7b8	f0 31		beq $b7eb			beq 	_LIDoneIndent
.b7ba	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.b7bc	90 16		bcc $b7d4			bcc 	_LICINext
.b7be	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b7c0	b0 12		bcs $b7d4			bcs 	_LICINext
.b7c2	ee bb 03	inc $03bb			inc 	ListIndent
.b7c5	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.b7c7	90 0b		bcc $b7d4			bcc 	_LICINext
.b7c9	ce bb 03	dec $03bb			dec 	ListIndent
.b7cc	ce bb 03	dec $03bb			dec 	ListIndent
.b7cf	10 03		bpl $b7d4			bpl 	_LICINext
.b7d1	ee bb 03	inc $03bb			inc 	ListIndent
.b7d4					_LICINext:
.b7d4	ea		nop				nop
.b7d5	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b7d7	1b		inz				inz 								; skip
.b7d8	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b7da	90 0d		bcc $b7e9			bcc 	_SEDone 					; so just skip over it.
.b7dc	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b7de	90 08		bcc $b7e8			bcc 	_SEDouble
.b7e0	6b		tza				tza 								; this is Y + 1
.b7e1	18		clc				clc
.b7e2	ea		nop				nop
.b7e3	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b7e5	4b		taz				taz 								; back in Y.
.b7e6	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b7e7	3b		dez				dez
.b7e8					_SEDouble:
.b7e8	1b		inz				inz
.b7e9					_SEDone:
.b7e9	80 c8		bra $b7b3			bra 	_LICountIndent
.b7eb					_LIDoneIndent:
.b7eb	a3 00		ldz #$00			ldz 	#0
.b7ed	1b		inz				inz
.b7ee	ea		nop				nop
.b7ef	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7f1	85 80		sta $80				sta 	XS_Mantissa
.b7f3	1b		inz				inz
.b7f4	ea		nop				nop
.b7f5	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7f7	85 81		sta $81				sta 	XS_Mantissa+1
.b7f9	20 29 af	jsr $af29			jsr 	Print16BitInteger 			; print integer.
.b7fc	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.b7fe	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.b801	cd bc 03	cmp $03bc			cmp 	LastListIndent
.b804	90 03		bcc $b809			bcc 	_LISmaller
.b806	ad bc 03	lda $03bc			lda 	LastListIndent
.b809					_LISmaller:
.b809	0a		asl a				asl 	a 							; double indent
.b80a	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.b80c	38		sec				sec
.b80d	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.b80f	aa		tax				tax 								; print spaces to column 6
.b810					_LISpace:
.b810	a9 20		lda #$20			lda 	#" "
.b812	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b815	e8		inx				inx
.b816	e0 06		cpx #$06			cpx 	#6
.b818	d0 f6		bne $b810			bne 	_LISpace
.b81a					_LIDecode:
.b81a	1b		inz				inz
.b81b	ea		nop				nop
.b81c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b81e	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b820	f0 0f		beq $b831			beq 	_LIExit
.b822	30 12		bmi $b836			bmi 	_LIToken
.b824	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b826	b0 52		bcs $b87a			bcs 	_LIInteger
.b828	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b82a	69 20		adc #$20			adc 	#$20
.b82c	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC 				; print in LC
.b82f	80 e9		bra $b81a			bra 	_LIDecode
.b831					_LIExit:
.b831	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b833	4c e9 b8	jmp $b8e9			jmp 	ListPrintLC
.b836					_LIToken:
.b836	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b838	90 4b		bcc $b885			bcc		_LICommandToken
.b83a	48		pha				pha 								; save in case end
.b83b	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b83d	c9 fe		cmp #$fe			cmp 	#$FE
.b83f	f0 17		beq $b858			beq 	_LIPrint
.b841	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b843	c9 fd		cmp #$fd			cmp 	#$FD
.b845	f0 11		beq $b858			beq 	_LIPrint
.b847	a9 52		lda #$52			lda 	#'R'						; must be REM
.b849	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b84c	a9 45		lda #$45			lda 	#'E'
.b84e	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b851	a9 4d		lda #$4d			lda 	#'M'
.b853	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b856	a2 20		ldx #$20			ldx 	#' '
.b858					_LIPrint:
.b858	8a		txa				txa
.b859	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b85c	1b		inz				inz
.b85d	ea		nop				nop
.b85e	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b860	aa		tax				tax 								; put in X
.b861	ca		dex				dex
.b862					_LILoop:
.b862	ca		dex				dex 								; exit when count reached zero.
.b863	f0 09		beq $b86e			beq 	_LIEnd
.b865	1b		inz				inz
.b866	ea		nop				nop
.b867	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b869	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b86c	80 f4		bra $b862			bra 	_LILoop
.b86e	68		pla		_LIEnd:	pla 								; get A back
.b86f	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b871	d0 a7		bne $b81a			bne 	_LIDecode
.b873	a9 22		lda #$22			lda 	#'"'
.b875	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b878	80 a0		bra $b81a			bra 	_LIDecode
.b87a					_LIInteger:
.b87a	a2 00		ldx #$00			ldx 	#0
.b87c	20 e6 bc	jsr $bce6			jsr 	EvaluateGetInteger 			; get an atom
.b87f	3b		dez				dez
.b880	20 2f af	jsr $af2f			jsr 	Print32BitInteger 			; print integer.
.b883	80 95		bra $b81a			bra 	_LIDecode
.b885					_LICommandToken:
.b885	5a		phy				phy 								; save Y
.b886	48		pha				pha 								; save token
.b887	a2 27		ldx #$27			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b889	a9 b0		lda #$b0			lda 	(#KeywordText >> 8) & $FF
.b88b	86 1c		stx $1c				stx 	zLTemp1
.b88d	85 1d		sta $1d				sta 	zLTemp1+1
.b88f	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b891	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b893	68		pla				pla 								; get token
.b894	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.b896	f0 16		beq $b8ae			beq 	_LIFoundToken
.b898	aa		tax				tax
.b899					_LITokenLoop:
.b899	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.b89b					_LIFindEnd:
.b89b	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.b89d	c8		iny				iny
.b89e	0a		asl a				asl 	a
.b89f	90 fa		bcc $b89b			bcc 	_LIFindEnd
.b8a1	98		tya				tya 								; that is step to the next
.b8a2	18		clc				clc 								; we don't bother bumping the 3rd byte
.b8a3	65 1c		adc $1c				adc 	zLTemp1 					; here.
.b8a5	85 1c		sta $1c				sta 	zLTemp1
.b8a7	90 02		bcc $b8ab			bcc 	_LINoBump
.b8a9	e6 1d		inc $1d				inc 	zLTemp1+1
.b8ab					_LINoBump:
.b8ab	ca		dex				dex 								; no go round again.
.b8ac	d0 eb		bne $b899			bne 	_LITokenLoop
.b8ae					_LIFoundToken:
.b8ae	a0 00		ldy #$00			ldy 	#0
.b8b0					_LIPrintToken:
.b8b0	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.b8b2	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.b8b4	d0 16		bne $b8cc			bne 	_LINoPrefixSpace
.b8b6	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.b8b8	90 12		bcc $b8cc			bcc 	_LINoPrefixSpace
.b8ba	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b8bc	b0 0e		bcs $b8cc			bcs 	_LINoPrefixSpace
.b8be	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.b8c1	e0 20		cpx #$20			cpx 	#" "
.b8c3	f0 07		beq $b8cc			beq 	_LINoPrefixSpace
.b8c5	48		pha				pha
.b8c6	a9 20		lda #$20			lda 	#" "
.b8c8	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b8cb	68		pla				pla
.b8cc					_LINoPrefixSpace:
.b8cc	c8		iny				iny
.b8cd	48		pha				pha 								; save it
.b8ce	29 7f		and #$7f			and 	#$7F
.b8d0	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b8d3	68		pla				pla
.b8d4	10 da		bpl $b8b0			bpl 	_LIPrintToken 				; go back if not end
.b8d6	7a		ply				ply 								; restore Y
.b8d7	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b8d9	c9 41		cmp #$41			cmp 	#"A"
.b8db	90 09		bcc $b8e6			bcc 	_LINotLetter2
.b8dd	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b8df	b0 05		bcs $b8e6			bcs 	_LINotLetter2
.b8e1	a9 20		lda #$20			lda 	#" " 						; add spacing
.b8e3	20 e9 b8	jsr $b8e9			jsr 	ListPrintLC
.b8e6					_LINotLetter2:
.b8e6	4c 1a b8	jmp $b81a			jmp 	_LIDecode
.b8e9					ListPrintLC:
.b8e9	8d ba 03	sta $03ba			sta 	LastPrinted
.b8ec	c9 41		cmp #$41			cmp 	#"A"
.b8ee	90 06		bcc $b8f6			bcc 	_LPLC0
.b8f0	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b8f2	b0 02		bcs $b8f6			bcs 	_LPLC0
.b8f4	69 20		adc #$20			adc 	#$20
.b8f6	4c 99 ae	jmp $ae99	_LPLC0:	jmp 	VIOCharPrint
.b8f9					ListGetRange:
.b8f9	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.b8fb					_LGRClear:
.b8fb	a9 00		lda #$00			lda 	#0
.b8fd	95 80		sta $80,x			sta 	XS_Mantissa,x
.b8ff	ca		dex				dex
.b900	10 f9		bpl $b8fb			bpl 	_LGRClear
.b902	ea		nop				nop
.b903	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b905	c9 00		cmp #$00			cmp 	#0 							; nothing
.b907	f0 22		beq $b92b			beq 	_LGRBlank
.b909	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.b90b	f0 1e		beq $b92b			beq 	_LGRBlank
.b90d	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.b90f	f0 19		beq $b92a			beq 	_LGREnd 					; then it's LIST ,x
.b911	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; get the first number into bottom
.b914	ea		nop				nop
.b915	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b917	c9 bf		cmp #$bf			cmp 	#token_Comma
.b919	f0 0f		beq $b92a			beq 	_LGREnd 					; then it is LIST a,b
.b91b	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.b91d	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.b91f	a5 81		lda $81				lda 	XS_Mantissa+1
.b921	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b923					_LGRBumpExit:
.b923	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.b925	d0 02		bne $b929			bne 	_LGRBump2
.b927	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.b929					_LGRBump2:
.b929	60		rts				rts
.b92a					_LGREnd:
.b92a	1b		inz				inz
.b92b					_LGRBlank:
.b92b	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.b92d	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.b92f	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b931	ea		nop				nop
.b932	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b934	c9 00		cmp #$00			cmp 	#0
.b936	f0 f1		beq $b929			beq 	_LGRBump2
.b938	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.b939	b0 ee		bcs $b929			bcs 	_LGRBump2
.b93b	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.b93d	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX
.b940	80 e1		bra $b923			bra 	_LGRBumpExit
.b942	60		rts				rts
.b943					ListCheckRange:
.b943	1b		inz				inz
.b944	a2 00		ldx #$00			ldx 	#0 							; test low
.b946	20 53 b9	jsr $b953			jsr 	_LCRCompare
.b949	90 06		bcc $b951			bcc 	_LCRFail
.b94b	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.b94d	20 53 b9	jsr $b953			jsr 	_LCRCompare
.b950	60		rts				rts
.b951					_LCRFail:
.b951	38		sec				sec
.b952	60		rts				rts
.b953					_LCRCompare:
.b953	ea		nop				nop
.b954	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b956	38		sec				sec
.b957	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.b959	08		php				php
.b95a	1b		inz				inz
.b95b	ea		nop				nop
.b95c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b95e	28		plp				plp
.b95f	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.b961	08		php				php
.b962	3b		dez				dez
.b963	28		plp				plp
.b964	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b965					Command_PRINT:
.b965					_CPR_Loop:
.b965	ea		nop				nop
.b966	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b968	c9 00		cmp #$00			cmp 	#0 							; end
.b96a	f0 25		beq $b991			beq 	_CPR_GoNewLine
.b96c	c9 c0		cmp #$c0			cmp 	#token_Colon
.b96e	f0 21		beq $b991			beq 	_CPR_GoNewLine
.b970	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b972	f0 75		beq $b9e9			beq 	_CPR_Skip
.b974	c9 bf		cmp #$bf			cmp 	#token_Comma
.b976	f0 58		beq $b9d0			beq 	_CPR_Tab
.b978	20 db bb	jsr $bbdb			jsr 	EvaluateExpression 			; get expression.
.b97b	a5 85		lda $85				lda 	XS_Type 					; get type.
.b97d	29 02		and #$02			and 	#2
.b97f	d0 28		bne $b9a9			bne 	_CPR_String 				; if type = 2 output as string.
.b981					_CPR_Number:
.b981	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b983	8d 14 03	sta $0314			sta 	NumBufX
.b986	aa		tax				tax
.b987	a5 85		lda $85				lda 	XS_Type 					; get type
.b989	4a		lsr a				lsr 	a
.b98a	b0 08		bcs $b994			bcs 	_CPRInt 					; if msb set do as integer
.b98c	20 f0 d0	jsr $d0f0			jsr 	FPToString 					; do the floa
.b98f	80 06		bra $b997			bra 	_CPRNPrint
.b991					_CPR_GoNewLine:
.b991	4c f8 b9	jmp $b9f8			jmp 	_CPR_NewLine
.b994					_CPRInt:
.b994	20 7a cb	jsr $cb7a			jsr 	IntToString
.b997					_CPRNPrint:
.b997	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b99a	c9 2d		cmp #$2d			cmp 	#"-"
.b99c	f0 05		beq $b9a3			beq 	_CPRNoSpace
.b99e	a9 20		lda #$20			lda 	#" "						; print the leading space
.b9a0	20 99 ae	jsr $ae99			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.b9a3					_CPRNoSpace:
.b9a3	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b9a5	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b9a7	80 04		bra $b9ad			bra 	_CPRPrint
.b9a9					_CPR_String:
.b9a9	a6 80		ldx $80				ldx 	XS_Mantissa
.b9ab	a5 81		lda $81				lda 	XS_Mantissa+1
.b9ad					_CPRPrint:
.b9ad	86 20		stx $20				stx 	zGenPtr
.b9af	85 21		sta $21				sta 	zGenPtr+1
.b9b1	5a		phy				phy
.b9b2	a0 00		ldy #$00			ldy 	#0							; get length into X
.b9b4	b1 20		lda ($20),y			lda 	(zGenPtr),y
.b9b6	aa		tax				tax
.b9b7	f0 09		beq $b9c2			beq 	_CPREndPrint 				; nothing to print
.b9b9					_CPRLoop:
.b9b9	c8		iny				iny
.b9ba	b1 20		lda ($20),y			lda 	(zGenPtr),y
.b9bc	20 99 ae	jsr $ae99			jsr 	VIOCharPrint
.b9bf	ca		dex				dex
.b9c0	d0 f7		bne $b9b9			bne 	_CPRLoop
.b9c2					_CPREndPrint:
.b9c2	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.b9c4	29 02		and #$02			and 	#2
.b9c6	d0 05		bne $b9cd			bne 	_CPRNoTrail
.b9c8	a9 20		lda #$20			lda 	#" "
.b9ca	20 99 ae	jsr $ae99			jsr 	VIOCharPrint
.b9cd					_CPRNoTrail:
.b9cd	7a		ply				ply
.b9ce	80 95		bra $b965			bra 	_CPR_Loop
.b9d0					_CPR_Tab:
.b9d0	20 aa ae	jsr $aeaa			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.b9d3					_CPR_CalcSpaces:
.b9d3	38		sec				sec 								; calculate position mod 10.
.b9d4	e9 0a		sbc #$0a			sbc 	#10
.b9d6	b0 fb		bcs $b9d3			bcs 	_CPR_CalcSpaces
.b9d8	69 0a		adc #$0a			adc 	#10
.b9da	f0 0d		beq $b9e9			beq 	_CPR_Skip 					; nothing to print
.b9dc	aa		tax				tax 								; print out spaces to mod 10
.b9dd					_CPRTabSpaces:
.b9dd	a9 20		lda #$20			lda 	#" "
.b9df	20 99 ae	jsr $ae99			jsr 	VIOCharPrint
.b9e2	e8		inx				inx
.b9e3	e0 0a		cpx #$0a			cpx 	#10
.b9e5	d0 f6		bne $b9dd			bne 	_CPRTabSpaces
.b9e7	80 e7		bra $b9d0			bra 	_CPR_Tab
.b9e9					_CPR_Skip:
.b9e9	1b		inz				inz
.b9ea	ea		nop				nop
.b9eb	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b9ed	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b9ef	f0 0c		beq $b9fd			beq 	_CPR_Exit
.b9f1	c9 00		cmp #$00			cmp 	#0
.b9f3	f0 08		beq $b9fd			beq 	_CPR_Exit 					; if not go round again.
.b9f5	4c 65 b9	jmp $b965			jmp 	_CPR_Loop
.b9f8					_CPR_NewLine:
.b9f8	a9 0d		lda #$0d			lda 	#13
.b9fa	20 99 ae	jsr $ae99			jsr 	VIOCharPrint
.b9fd					_CPR_Exit:
.b9fd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b9fe					Command_ASSERT:
.b9fe	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.ba01	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.ba03	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.ba05	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ba07	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.ba09	f0 01		beq $ba0c			beq 	_ASFail
.ba0b	60		rts				rts
.ba0c					_ASFail:
.ba0c	20 e0 ae	jsr $aee0			jsr ERR_Handler
>ba0f	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.ba16					Command_POKE:
.ba16	a9 01		lda #$01			lda 	#1 							; 1 byte
.ba18	80 06		bra $ba20			bra 	CmdPoke_Main
.ba1a					Command_DOKE:
.ba1a	a9 02		lda #$02			lda 	#2 							; 2 bytes
.ba1c	80 02		bra $ba20			bra 	CmdPoke_Main
.ba1e					Command_LOKE:
.ba1e	a9 04		lda #$04			lda 	#4							; 4 bytes
.ba20					CmdPoke_Main:
.ba20	48		pha				pha
.ba21	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; get two parameters. First is address
.ba24	e8		inx				inx
.ba25	e8		inx				inx
.ba26	e8		inx				inx
.ba27	e8		inx				inx
.ba28	e8		inx				inx
.ba29	e8		inx				inx
.ba2a	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma
.ba2d	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX 			; second is the data.
.ba30	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.ba32	85 1c		sta $1c				sta 	zLTemp1
.ba34	a5 81		lda $81				lda 	XS_Mantissa+1
.ba36	85 1d		sta $1d				sta 	zLTemp1+1
.ba38	a5 82		lda $82				lda 	XS_Mantissa+2
.ba3a	85 1e		sta $1e				sta 	zLTemp1+2
.ba3c	a5 83		lda $83				lda 	XS_Mantissa+3
.ba3e	85 1f		sta $1f				sta 	zLTemp1+3
.ba40	68		pla				pla 								; get count
.ba41	5a		phy				phy 								; save Y
.ba42	20 59 c3	jsr $c359			jsr 	MemWrite 					; write it out
.ba45	7a		ply				ply 								; restore Y and done.
.ba46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.ba47					Command_NEW:
.ba47	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.ba49	85 18		sta $18				sta 	zCodePtr+0
.ba4b	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.ba4d	85 19		sta $19				sta 	zCodePtr+1
.ba4f	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.ba51	85 1a		sta $1a				sta 	zCodePtr+2
.ba53	a9 00		lda #$00			lda 	#0
.ba55	85 1b		sta $1b				sta 	zCodePtr+3
.ba57	a3 03		ldz #$03			ldz 	#3
.ba59	a3 00		ldz #$00			ldz 	#0
.ba5b	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.ba5d	ea		nop				nop
.ba5e	92 18		sta ($18),z			sta 	(zCodePtr),z
.ba60	20 6d c3	jsr $c36d			jsr 	UpdateProgramEnd 			; update program end.
.ba63	4c 9a b1	jmp $b19a			jmp 	WarmStart 					; and always warmstart, can't be running program.
.ba66					Command_OLD:
.ba66	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.ba68	85 18		sta $18				sta 	zCodePtr+0
.ba6a	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.ba6c	85 19		sta $19				sta 	zCodePtr+1
.ba6e	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.ba70	85 1a		sta $1a				sta 	zCodePtr+2
.ba72	a9 00		lda #$00			lda 	#0
.ba74	85 1b		sta $1b				sta 	zCodePtr+3
.ba76	a3 03		ldz #$03			ldz 	#3
.ba78					_COL_Find:
.ba78	ea		nop				nop
.ba79	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ba7b	1b		inz				inz
.ba7c	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.ba7e	f0 18		beq $ba98			beq 	_COL_Found
.ba80	6b		tza				tza
.ba81	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.ba83	d0 f3		bne $ba78			bne 	_COL_Find 					; can't find old EOL, give up.
.ba85	20 e0 ae	jsr $aee0			jsr ERR_Handler
>ba88	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>ba90	43 6f 72 72 75 70 74 00
.ba98					_COL_Found:
.ba98	6b		tza				tza
.ba99	48		pha				pha
.ba9a	a3 00		ldz #$00			ldz 	#0
.ba9c	68		pla				pla
.ba9d	ea		nop				nop
.ba9e	92 18		sta ($18),z			sta 	(zCodePtr),z
.baa0	20 6d c3	jsr $c36d			jsr 	UpdateProgramEnd 			; reset variable pointer
.baa3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.baa4					Command_GOTO:
.baa4	20 fa ba	jsr $bafa			jsr 	GotoGetLineNumber 			; get line number
.baa7					CmdGOTO:
.baa7	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.baa9	4c 17 bb	jmp $bb17			jmp 	GotoChangeToLineNumberX
.baac					Command_GOSUB:
.baac	20 fa ba	jsr $bafa			jsr 	GotoGetLineNumber 			; get line number
.baaf					CmdGOSUB:
.baaf	20 60 ae	jsr $ae60			jsr 	StackSavePosition 			; save position on stack and push frame
.bab2	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.bab4	20 19 ae	jsr $ae19			jsr 	StackPushFrame
.bab7	a2 00		ldx #$00			ldx		#0 							; go to that line number
.bab9	4c 17 bb	jmp $bb17			jmp 	GotoChangeToLineNumberX
.babc					Command_RETURN:
.babc	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.babe	20 30 ae	jsr $ae30			jsr 	StackPopFrame
.bac1	20 7d ae	jsr $ae7d			jsr 	StackRestorePosition 		; restore position.
.bac4	60		rts				rts
.bac5					Command_ON:
.bac5	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.bac7	20 19 c2	jsr $c219			jsr 	SLIByteParameter
.baca	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.bacc	f0 29		beq $baf7			beq 	_CONFail 					; can't be zero, error if it is.
.bace	aa		tax				tax 								; save in X.
.bacf	ea		nop				nop
.bad0	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bad2	1b		inz				inz
.bad3	48		pha				pha 								; so we can check what we're doing later.
.bad4	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.bad6	f0 07		beq $badf			beq 	_CONOkayToken
.bad8	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.bada	f0 03		beq $badf			beq 	_CONOkayToken
.badc	4c b1 ae	jmp $aeb1			jmp 	SyntaxError
.badf					_CONOkayToken:
.badf	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.bae0					_CONFindNumber:
.bae0	20 fa ba	jsr $bafa			jsr 	GotoGetLineNumber 			; get a line number.
.bae3	fa		plx				plx 								; restore count
.bae4	ca		dex				dex  								; decrement, exit if zero.
.bae5	f0 06		beq $baed			beq 	_CONFound
.bae7	da		phx				phx 								; push back
.bae8	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma				; check for comma
.baeb	80 f3		bra $bae0			bra 	_CONFindNumber 				; go round again.
.baed					_CONFound:
.baed	68		pla				pla 								; get token to decide what to do
.baee	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.baf0	f0 b5		beq $baa7			beq		CmdGOTO 					; then just branch.
.baf2	20 e4 ad	jsr $ade4			jsr 	SkipEndOfCommand 			; go to end of command
.baf5	80 b8		bra $baaf			bra 	CmdGOSUB 					; and do a GOSUB.
.baf7					_CONFail:
.baf7	4c cf ae	jmp $aecf			jmp 	BadParamError
.bafa					GotoGetLineNumber:
.bafa	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; get integer into mantissa.0
.bafd	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.baff	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.bb01	d0 01		bne $bb04			bne 	_GLINError
.bb03	60		rts				rts
.bb04					_GLINError:
.bb04	20 e0 ae	jsr $aee0			jsr ERR_Handler
>bb07	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>bb0f	20 4e 75 6d 62 65 72 00
.bb17					GotoChangeToLineNumberX:
.bb17	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.bb19	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.bb1b	f0 3d		beq $bb5a			beq 	_GCTLFail 					; if so, no can do.
.bb1d	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.bb1f	85 18		sta $18				sta 	zCodePtr+0
.bb21	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.bb23	85 19		sta $19				sta 	zCodePtr+1
.bb25	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.bb27	85 1a		sta $1a				sta 	zCodePtr+2
.bb29	a9 00		lda #$00			lda 	#0
.bb2b	85 1b		sta $1b				sta 	zCodePtr+3
.bb2d	a3 03		ldz #$03			ldz 	#3
.bb2f					_GCTLLoop:
.bb2f	a3 00		ldz #$00			ldz 	#0
.bb31	ea		nop				nop
.bb32	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb34	c9 00		cmp #$00			cmp 	#0
.bb36	f0 22		beq $bb5a			beq 	_GCTLFail
.bb38	1b		inz				inz
.bb39	ea		nop				nop
.bb3a	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb3c	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.bb3e	d0 08		bne $bb48			bne 	_GCTLNext
.bb40	1b		inz				inz
.bb41	ea		nop				nop
.bb42	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb44	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.bb46	f0 10		beq $bb58			beq 	_GCTLExit
.bb48					_GCTLNext:
.bb48	a3 00		ldz #$00			ldz 	#0 							; point to offset
.bb4a	ea		nop				nop
.bb4b	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.bb4d	18		clc				clc
.bb4e	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.bb50	85 18		sta $18				sta 	zCodePtr
.bb52	90 02		bcc $bb56			bcc 	_SNLNoCarry
.bb54	e6 19		inc $19				inc 	zCodePtr+1
.bb56					_SNLNoCarry:
.bb56	80 d7		bra $bb2f			bra 	_GCTLLoop 					; try next line.
.bb58					_GCTLExit:
.bb58	1b		inz				inz
.bb59	60		rts				rts
.bb5a					_GCTLFail:
.bb5a	20 e0 ae	jsr $aee0			jsr ERR_Handler
>bb5d	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>bb65	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.bb6d					Command_CLR:
.bb6d					ResetRunStatus:
.bb6d	20 d0 c6	jsr $c6d0			jsr 	VariableClear
.bb70	20 07 ae	jsr $ae07			jsr 	StackReset
.bb73	a9 00		lda #$00			lda 	#HighMemory & $FF
.bb75	8d 00 03	sta $0300			sta 	StringPtr
.bb78	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.bb7a	8d 01 03	sta $0301			sta 	StringPtr+1
.bb7d	20 9e c8	jsr $c89e			jsr 	ArrayResetDefault
.bb80	20 95 b4	jsr $b495			jsr 	Command_RESTORE
.bb83	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.bb84					Command_STOP:
.bb84	20 e0 ae	jsr $aee0			jsr ERR_Handler
>bb87	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.bb8c					Command_WHILE:
.bb8c	20 60 ae	jsr $ae60			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.bb8f	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 			; calculate the while loop value.
.bb92	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.bb94	05 81		ora $81				ora 	XS_Mantissa+1
.bb96	05 82		ora $82				ora 	XS_Mantissa+2
.bb98	05 83		ora $83				ora 	XS_Mantissa+3
.bb9a	f0 06		beq $bba2			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.bb9c	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.bb9e	20 19 ae	jsr $ae19			jsr 	StackPushFrame 				; push on stack
.bba1	60		rts				rts
.bba2					_CWHSkip:
.bba2	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.bba4	20 52 ad	jsr $ad52			jsr 	StructureSearchSingle
.bba7	1b		inz				inz
.bba8	60		rts				rts
.bba9					Command_WEND:
.bba9	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.bbab	20 30 ae	jsr $ae30			jsr 	StackPopFrame
.bbae	20 7d ae	jsr $ae7d			jsr 	StackRestorePosition
.bbb1	80 d9		bra $bb8c			bra 	Command_WHILE 				; and do the while again.
.bbb3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.bbb4					Command_REPEAT:
.bbb4	20 60 ae	jsr $ae60			jsr 	StackSavePosition			; save position into stack
.bbb7	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.bbb9	20 19 ae	jsr $ae19			jsr 	StackPushFrame 				; push on stack
.bbbc	60		rts				rts
.bbbd					Command_UNTIL:
.bbbd	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.bbbf	20 30 ae	jsr $ae30			jsr 	StackPopFrame
.bbc2	20 78 bd	jsr $bd78			jsr 	EvaluateInteger				; work out the UNTIL expression.
.bbc5	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.bbc7	05 81		ora $81				ora 	XS_Mantissa+1
.bbc9	05 82		ora $82				ora 	XS_Mantissa+2
.bbcb	05 83		ora $83				ora 	XS_Mantissa+3
.bbcd	d0 08		bne $bbd7			bne 	_CUTExit 					; if not, just exit
.bbcf	20 7d ae	jsr $ae7d			jsr 	StackRestorePosition 		; otherwise loop round again.
.bbd2	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.bbd4	20 19 ae	jsr $ae19			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.bbd7					_CUTExit:
.bbd7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.bbd8					EVESyntax:
.bbd8	4c b1 ae	jmp $aeb1			jmp 	SyntaxError
.bbdb					EvaluateExpression:
.bbdb	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.bbdd					EvaluateExpressionX:
.bbdd	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.bbdf					EvaluateExpressionXA:
.bbdf	48		pha				pha 								; save precedence on stack.
.bbe0	ea		nop				nop
.bbe1	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbe3	f0 f3		beq $bbd8			beq 	EVESyntax 					; end of line, syntax error.
.bbe5	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.bbe7	b0 03		bcs $bbec			bcs 	_EVNotVariable
.bbe9	4c b8 bc	jmp $bcb8			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.bbec					_EVNotVariable:
.bbec	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.bbee	90 e8		bcc $bbd8			bcc 	EVESyntax
.bbf0	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.bbf2	b0 59		bcs $bc4d			bcs 	_EVNotInteger
.bbf4	20 e6 bc	jsr $bce6			jsr 	EvaluateGetInteger
.bbf7					_EVCheckDecimal:
.bbf7	ea		nop				nop
.bbf8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbfa	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.bbfc	d0 05		bne $bc03			bne 	_EVGotAtom 					; no, get atom.
.bbfe					_EVIsDecimal:
.bbfe	20 0e bd	jsr $bd0e			jsr 	EVGetDecimal 				; extend to the decimal part.
.bc01	80 00		bra $bc03			bra 	_EVGotAtom 					; and continue to got atom.
.bc03					_EVGotAtom:
.bc03	ea		nop				nop
.bc04	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc06	10 43		bpl $bc4b			bpl 	_EVExitDrop 				; must be a token.
.bc08	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.bc0a	b0 3f		bcs $bc4b			bcs 	_EVExitDrop
.bc0c	68		pla				pla 								; get current precedence
.bc0d	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.bc0f	da		phx				phx 								; save X
.bc10	ea		nop				nop
.bc11	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc13	aa		tax				tax 								; put in X
.bc14	bd 98 af	lda $af98,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.bc17	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.bc19	fa		plx				plx 								; restore X
.bc1a	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.bc1c	90 2e		bcc $bc4c			bcc 	_EVExit 					; exit if too low.
.bc1e	f0 2c		beq $bc4c			beq 	_EVExit 					; exit if equals
.bc20	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.bc22	48		pha				pha
.bc23	ea		nop				nop
.bc24	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc26	48		pha				pha
.bc27	1b		inz				inz
.bc28	da		phx				phx 								; save current position
.bc29	e8		inx				inx
.bc2a	e8		inx				inx
.bc2b	e8		inx				inx
.bc2c	e8		inx				inx
.bc2d	e8		inx				inx
.bc2e	e8		inx				inx
.bc2f	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.bc31	20 df bb	jsr $bbdf			jsr 	EvaluateExpressionXA 		; do the RHS.
.bc34	fa		plx				plx 								; restore X
.bc35	68		pla				pla 								; get the binary operator in A.
.bc36					_EVCallA:
.bc36	da		phx				phx 								; save X again
.bc37	0a		asl a				asl 	a 							; double, lose the MSB.
.bc38	aa		tax				tax									; put in X
.bc39	bd 47 af	lda $af47,x			lda 	VectorTable,x 				; copy address into zGenPtr
.bc3c	8d 11 03	sta $0311			sta 	LocalVector+1
.bc3f	bd 48 af	lda $af48,x			lda 	VectorTable+1,x
.bc42	8d 12 03	sta $0312			sta 	LocalVector+2
.bc45	fa		plx				plx 								; restore X
.bc46	20 c1 bc	jsr $bcc1			jsr 	EVCallLocalVector
.bc49	80 b8		bra $bc03			bra 	_EVGotAtom 					; and loop back.
.bc4b					_EVExitDrop:
.bc4b	68		pla				pla
.bc4c					_EVExit:
.bc4c	60		rts				rts
.bc4d					_EVNotInteger:
.bc4d	1b		inz				inz
.bc4e	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.bc50	d0 16		bne $bc68			bne 	_EVNotMinus
.bc52	20 59 bd	jsr $bd59			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.bc55	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bc57	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bc59	f0 05		beq $bc60			beq 	_EVMinusFloat
.bc5b	20 5d cb	jsr $cb5d			jsr 	IntegerNegateAlways 		; negation
.bc5e	80 a3		bra $bc03			bra 	_EVGotAtom 					; and go back.
.bc60					_EVMinusFloat:
.bc60	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.bc62	49 80		eor #$80			eor 	#$80
.bc64	95 85		sta $85,x			sta 	XS_Type,x
.bc66	80 9b		bra $bc03			bra 	_EVGotAtom
.bc68					_EVNotMinus:
.bc68	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.bc6a	d0 18		bne $bc84			bne 	_EVNotParenthesis
.bc6c	20 dd bb	jsr $bbdd			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.bc6f	ea		nop				nop
.bc70	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc72	1b		inz				inz
.bc73	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.bc75	f0 8c		beq $bc03			beq 	_EVGotAtom
.bc77	20 e0 ae	jsr $aee0			jsr ERR_Handler
>bc7a	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>bc82	29 00
.bc84					_EVNotParenthesis:
.bc84	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.bc86	d0 0c		bne $bc94			bne 	_EVNotNot
.bc88	20 59 bd	jsr $bd59			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.bc8b	20 f1 cf	jsr $cff1			jsr 	FPUToInteger 				; make it an integer - if possible.
.bc8e	20 3e bd	jsr $bd3e			jsr 	NotInteger 					; do the not calculation
.bc91	4c 03 bc	jmp $bc03			jmp 	_EVGotAtom
.bc94					_EVNotNot:
.bc94	c9 fe		cmp #$fe			cmp 	#$FE
.bc96	d0 12		bne $bcaa			bne 	_EVNotString
.bc98	20 58 c4	jsr $c458			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.bc9b	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.bc9d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc9f	a5 23		lda $23				lda 	zTempStr+1
.bca1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bca3	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.bca5	95 85		sta $85,x			sta 	XS_Type,x
.bca7	4c 03 bc	jmp $bc03			jmp 	_EVGotAtom
.bcaa					_EVNotString:
.bcaa	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.bcac	90 04		bcc $bcb2			bcc 	_EVBadElement
.bcae	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.bcb0	90 03		bcc $bcb5			bcc 	_EVUnaryFunction
.bcb2					_EVBadElement:
.bcb2	4c b1 ae	jmp $aeb1			jmp 	SyntaxError
.bcb5					_EVUnaryFunction:
.bcb5	4c 36 bc	jmp $bc36			jmp 	_EVCallA
.bcb8					_EVVariableHandler:
.bcb8	20 94 c6	jsr $c694			jsr 	VariableFind 				; locate a variable
.bcbb	20 e0 c9	jsr $c9e0			jsr 	VariableGet 				; copy into memory.
.bcbe	4c 03 bc	jmp $bc03			jmp 	_EVGotAtom 					; and go round.
.bcc1					EVCallLocalVector:
.bcc1	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.bcc4					EVShiftMantissaLeft6:
.bcc4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.bcc6	95 84		sta $84,x			sta 	XS_Exponent,x
.bcc8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bcca	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bccc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bcce	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bcd0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bcd2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bcd4	a9 00		lda #$00			lda 	#0
.bcd6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bcd8	20 db bc	jsr $bcdb			jsr 	_EVSMLShift 					; call it here to do it twice
.bcdb					_EVSMLShift:
.bcdb	56 84		lsr $84,x			lsr 	XS_Exponent,x
.bcdd	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.bcdf	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.bce1	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.bce3	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.bce5	60		rts				rts
.bce6					EvaluateGetInteger:
.bce6	ea		nop				nop
.bce7	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bce9	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.bceb	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.bced	a9 00		lda #$00			lda 	#0
.bcef	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bcf1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bcf3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bcf5	1a		inc a				inc 	a 							; set to type 1 (integer)
.bcf6	95 85		sta $85,x			sta 	XS_Type,x
.bcf8					_EVCheckNextInteger:
.bcf8	1b		inz				inz
.bcf9	ea		nop				nop
.bcfa	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bcfc	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.bcfe	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.bd00	b0 0b		bcs $bd0d			bcs 	_EVEndInteger
.bd02	48		pha				pha 								; save it.
.bd03	20 c4 bc	jsr $bcc4			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.bd06	68		pla				pla
.bd07	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.bd09	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd0b	80 eb		bra $bcf8			bra 	_EVCheckNextInteger
.bd0d					_EVEndInteger:
.bd0d	60		rts				rts
.bd0e					EVGetDecimal:
.bd0e	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.bd10	8d 15 03	sta $0315			sta 	Num_Buffer
.bd13	da		phx				phx
.bd14	1b		inz				inz
.bd15	ea		nop				nop
.bd16	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bd18	1b		inz				inz
.bd19	3a		dec a				dec 	a								; convert to a string length.
.bd1a	3a		dec a				dec 	a
.bd1b	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.bd1d					_EVGDCopy:
.bd1d	48		pha				pha 									; save count
.bd1e	ea		nop				nop
.bd1f	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bd21	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.bd24	e8		inx				inx 									; forward ....
.bd25	1b		inz				inz
.bd26	68		pla				pla 									; get count
.bd27	3a		dec a				dec 	a 								; until zero
.bd28	d0 f3		bne $bd1d			bne 	_EVGDCopy
.bd2a	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.bd2d	fa		plx				plx 									; restore X
.bd2e	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.bd30	85 20		sta $20				sta 	zGenPtr
.bd32	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.bd34	85 21		sta $21				sta 	zGenPtr+1
.bd36	5a		phy				phy 									; save Y
.bd37	a0 00		ldy #$00			ldy 	#0 								; start position
.bd39	20 ab d1	jsr $d1ab			jsr 	FPFromString 					; convert current
.bd3c	7a		ply				ply 									; restore Y
.bd3d	60		rts				rts
.bd3e					NotInteger:
.bd3e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bd40	49 ff		eor #$ff			eor 	#$FF
.bd42	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd44	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd46	49 ff		eor #$ff			eor 	#$FF
.bd48	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd4a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bd4c	49 ff		eor #$ff			eor 	#$FF
.bd4e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd50	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bd52	49 ff		eor #$ff			eor 	#$FF
.bd54	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd56	60		rts				rts
.bd57					EvaluateGetAtom:
.bd57	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.bd59					EvaluateGetAtomX:
.bd59	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.bd5b	20 df bb	jsr $bbdf			jsr 	EvaluateExpressionXA
.bd5e	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.bd60	29 0f		and #$0f			and 	#15
.bd62	c9 02		cmp #$02			cmp 	#2
.bd64	b0 01		bcs $bd67			bcs 	EvaluateType
.bd66	60		rts				rts
.bd67					EvaluateType:
.bd67	4c c1 ae	jmp $aec1			jmp 	TypeError
.bd6a					EvaluateNumber:
.bd6a	a2 00		ldx #$00			ldx 	#0
.bd6c					EvaluateNumberX:
.bd6c	20 dd bb	jsr $bbdd			jsr 	EvaluateExpressionX
.bd6f	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.bd71	29 0f		and #$0f			and 	#15
.bd73	c9 02		cmp #$02			cmp 	#2
.bd75	b0 f0		bcs $bd67			bcs 	EvaluateType
.bd77	60		rts				rts
.bd78					EvaluateInteger:
.bd78	a2 00		ldx #$00			ldx 	#0
.bd7a					EvaluateIntegerX:
.bd7a	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX
.bd7d	20 f1 cf	jsr $cff1			jsr 	FPUToInteger
.bd80	60		rts				rts
.bd81					EvaluateString:
.bd81	a2 00		ldx #$00			ldx 	#0
.bd83					EvaluateStringX:
.bd83	20 dd bb	jsr $bbdd			jsr 	EvaluateExpressionX
.bd86	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.bd88	29 0f		and #$0f			and 	#15
.bd8a	c9 02		cmp #$02			cmp 	#2
.bd8c	d0 d9		bne $bd67			bne 	EvaluateType
.bd8e	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.bd90	85 20		sta $20				sta 	zGenPtr
.bd92	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd94	85 21		sta $21				sta 	zGenPtr+1
.bd96	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.bd97					BinaryOp_And:
.bd97	20 eb bd	jsr $bdeb			jsr 	BinaryMakeBothInteger
.bd9a	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bd9c	35 86		and $86,x			and 	XS2_Mantissa+0,x
.bd9e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bda0	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bda2	35 87		and $87,x			and 	XS2_Mantissa+1,x
.bda4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bda6	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bda8	35 88		and $88,x			and 	XS2_Mantissa+2,x
.bdaa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bdac	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bdae	35 89		and $89,x			and 	XS2_Mantissa+3,x
.bdb0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bdb2	60		rts				rts
.bdb3					BinaryOp_Or:
.bdb3	20 eb bd	jsr $bdeb			jsr 	BinaryMakeBothInteger
.bdb6	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bdb8	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.bdba	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bdbc	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bdbe	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.bdc0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bdc2	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bdc4	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.bdc6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bdc8	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bdca	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.bdcc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bdce	60		rts				rts
.bdcf					BinaryOp_Eor:
.bdcf					BinaryOp_Xor:
.bdcf	20 eb bd	jsr $bdeb			jsr 	BinaryMakeBothInteger
.bdd2	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bdd4	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.bdd6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bdd8	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bdda	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.bddc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bdde	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bde0	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.bde2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bde4	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bde6	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.bde8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bdea	60		rts				rts
.bdeb					BinaryMakeBothInteger:
.bdeb	da		phx				phx 								; save X
.bdec	e8		inx				inx
.bded	e8		inx				inx
.bdee	e8		inx				inx
.bdef	e8		inx				inx
.bdf0	e8		inx				inx
.bdf1	e8		inx				inx
.bdf2	20 f6 bd	jsr $bdf6			jsr 	BinaryMakeInteger 			; convert to integer.
.bdf5	fa		plx				plx 								; restore X and fall through.
.bdf6					BinaryMakeInteger:
.bdf6	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.bdf8	29 0f		and #$0f			and 	#15 						; check type zero
.bdfa	f0 04		beq $be00			beq 	_BMIConvert 				; if float convert to integer.
.bdfc	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.bdfd	90 04		bcc $be03			bcc 	_BMIError
.bdff	60		rts				rts
.be00					_BMIConvert:
.be00	4c f1 cf	jmp $cff1			jmp 	FPUToInteger 				; convert to integer
.be03					_BMIError:
.be03	4c c1 ae	jmp $aec1			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.be06					Binary_Equal:
.be06	20 4f be	jsr $be4f			jsr 	CompareValues 				; compare the values
.be09	09 00		ora #$00			ora 	#0 							; true if 0
.be0b	f0 33		beq $be40			beq 	CCTrue
.be0d	80 2d		bra $be3c			bra 	CCFalse
.be0f					Binary_NotEqual:
.be0f	20 4f be	jsr $be4f			jsr 	CompareValues
.be12	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.be14	f0 26		beq $be3c			beq 	CCFalse
.be16	80 28		bra $be40			bra 	CCTrue
.be18					Binary_Less:
.be18	20 4f be	jsr $be4f			jsr 	CompareValues
.be1b	09 00		ora #$00			ora 	#0 							; true if -1
.be1d	30 21		bmi $be40			bmi 	CCTrue
.be1f	80 1b		bra $be3c			bra 	CCFalse
.be21					Binary_LessEqual:
.be21	20 4f be	jsr $be4f			jsr 	CompareValues
.be24	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.be26	d0 18		bne $be40			bne 	CCTrue
.be28	80 12		bra $be3c			bra 	CCFalse
.be2a					Binary_GreaterEqual:
.be2a	20 4f be	jsr $be4f			jsr 	CompareValues
.be2d	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.be2f	10 0f		bpl $be40			bpl 	CCTrue
.be31	80 09		bra $be3c			bra 	CCFalse
.be33					Binary_Greater:
.be33	20 4f be	jsr $be4f			jsr 	CompareValues 				; true if 1
.be36	c9 01		cmp #$01			cmp 	#1
.be38	f0 06		beq $be40			beq 	CCTrue
.be3a	80 00		bra $be3c			bra 	CCFalse
.be3c	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.be3e	80 02		bra $be42			bra 	CCWrite
.be40	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.be42	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.be44	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.be46	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.be48	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.be4a	a9 01		lda #$01			lda 	#1
.be4c	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.be4e	60		rts				rts
.be4f					CompareValues:
.be4f	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.be51	35 8b		and $8b,x			and 	XS2_Type,x
.be53	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.be55	f0 11		beq $be68			beq 	_CVString					; comparison routine.
.be57	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.be59	35 8b		and $8b,x			and 	XS2_Type,x
.be5b	4a		lsr a				lsr 	a 							; shift bit 0 into C
.be5c	90 03		bcc $be61			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.be5e	4c aa be	jmp $beaa			jmp 	CompareInteger32 							; so execute code at \1
.be61					_BCFloat:
.be61	20 44 bf	jsr $bf44			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.be64	4c ea ce	jmp $ceea			jmp 	FPCompare 							; and execute code at \2
.be67	60		rts				rts
.be68					_CVString:
.be68	da		phx				phx 								; save XY
.be69	5a		phy				phy
.be6a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.be6c	85 1c		sta $1c				sta		zLTemp1+0
.be6e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.be70	85 1d		sta $1d				sta 	zLTemp1+1
.be72	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.be74	85 1e		sta $1e				sta 	zLTemp1+2
.be76	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.be78	85 1f		sta $1f				sta 	zLTemp1+3
.be7a	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.be7c	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.be7e	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.be80	90 02		bcc $be84			bcc 	_CVCommon
.be82	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.be84					_CVCommon:
.be84	aa		tax				tax 								; put shorter string length in zero.
.be85	f0 0c		beq $be93			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.be87					_CVCompare:
.be87	c8		iny				iny 								; next character
.be88	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.be8a	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.be8c	90 13		bcc $bea1			bcc 	_CVReturnLess 				; <
.be8e	d0 15		bne $bea5			bne 	_CVReturnGreater 			; >
.be90	ca		dex				dex 								; until common length matched.
.be91	d0 f4		bne $be87			bne 	_CVCompare
.be93					_CVMatch:
.be93	a0 00		ldy #$00			ldy 	#0
.be95	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.be97	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.be99	90 06		bcc $bea1			bcc 	_CVReturnLess 				; <
.be9b	d0 08		bne $bea5			bne 	_CVReturnGreater 			; >
.be9d	a9 00		lda #$00			lda 	#0
.be9f	80 06		bra $bea7			bra 	_CVExit
.bea1					_CVReturnLess:
.bea1	a9 ff		lda #$ff			lda 	#$FF
.bea3	80 02		bra $bea7			bra 	_CVExit
.bea5					_CVReturnGreater:
.bea5	a9 01		lda #$01			lda 	#$01
.bea7					_CVExit:
.bea7	7a		ply				ply
.bea8	fa		plx				plx
.bea9	60		rts				rts
.beaa					CompareInteger32:
.beaa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.beac	49 80		eor #$80			eor 	#$80
.beae	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.beb0	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.beb2	49 80		eor #$80			eor 	#$80
.beb4	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.beb6	20 2a bf	jsr $bf2a			jsr 	SubInteger32 				; subtraction
.beb9	90 0d		bcc $bec8			bcc 	_CI32Less 					; cc return -1
.bebb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.bebd	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.bebf	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bec1	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bec3	f0 02		beq $bec7			beq 	_CI32Exit
.bec5	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.bec7					_CI32Exit:
.bec7	60		rts				rts
.bec8					_CI32Less:
.bec8	a9 ff		lda #$ff			lda 	#$FF
.beca	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.becb					BinaryOp_Add:
.becb	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.becd	35 8b		and $8b,x			and 	XS2_Type,x
.becf	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.bed1	d0 11		bne $bee4			bne 	_BOAString 					; so go do the string code.
.bed3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bed5	35 8b		and $8b,x			and 	XS2_Type,x
.bed7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bed8	90 03		bcc $bedd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.beda	4c 10 bf	jmp $bf10			jmp 	AddInteger32 							; so execute code at \1
.bedd					_BCFloat:
.bedd	20 44 bf	jsr $bf44			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bee0	4c c5 cc	jmp $ccc5			jmp 	FPAdd 							; and execute code at \2
.bee3	60		rts				rts
.bee4					_BOAString:
.bee4	4c 5e bf	jmp $bf5e			jmp 	ConcatenateString 			; concatenate two strings.
.bee7					BinaryOp_Subtract:
.bee7	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bee9	35 8b		and $8b,x			and 	XS2_Type,x
.beeb	4a		lsr a				lsr 	a 							; shift bit 0 into C
.beec	90 03		bcc $bef1			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.beee	4c 2a bf	jmp $bf2a			jmp 	SubInteger32 							; so execute code at \1
.bef1					_BCFloat:
.bef1	20 44 bf	jsr $bf44			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bef4	4c bd cc	jmp $ccbd			jmp 	FPSubtract 							; and execute code at \2
.bef7	60		rts				rts
.bef8					BinaryOp_Multiply:
.bef8	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.befa	35 8b		and $8b,x			and 	XS2_Type,x
.befc	4a		lsr a				lsr 	a 							; shift bit 0 into C
.befd	90 03		bcc $bf02			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.beff	4c 98 ca	jmp $ca98			jmp 	MulInteger32 							; so execute code at \1
.bf02					_BCFloat:
.bf02	20 44 bf	jsr $bf44			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bf05	4c ec cd	jmp $cdec			jmp 	FPMultiply 							; and execute code at \2
.bf08	60		rts				rts
.bf09					BinaryOp_Divide:
.bf09	20 44 bf	jsr $bf44			jsr 	BinaryMakeBothFloat
.bf0c	20 79 cd	jsr $cd79			jsr 	FPDivide
.bf0f	60		rts				rts
.bf10					AddInteger32:
.bf10	18		clc				clc
.bf11	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bf13	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.bf15	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf17	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf19	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.bf1b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf1d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bf1f	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.bf21	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf23	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf25	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.bf27	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf29	60		rts				rts
.bf2a					SubInteger32:
.bf2a	38		sec				sec
.bf2b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bf2d	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.bf2f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf31	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf33	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.bf35	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf37	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bf39	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.bf3b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf3d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf3f	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.bf41	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf43	60		rts				rts
.bf44					BinaryMakeBothFloat:
.bf44	da		phx				phx 								; save X
.bf45	e8		inx				inx
.bf46	e8		inx				inx
.bf47	e8		inx				inx
.bf48	e8		inx				inx
.bf49	e8		inx				inx
.bf4a	e8		inx				inx
.bf4b	20 4f bf	jsr $bf4f			jsr 	BinaryMakeFloat 			; convert to float.
.bf4e	fa		plx				plx 								; restore X and fall through.
.bf4f					BinaryMakeFloat:
.bf4f	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.bf51	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.bf52	b0 04		bcs $bf58			bcs 	_BMFConvert
.bf54	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.bf55	b0 04		bcs $bf5b			bcs 	_BMFError
.bf57	60		rts				rts
.bf58					_BMFConvert:
.bf58	4c a5 cf	jmp $cfa5			jmp 	FPUToFloat 					; convert to float, only float builds of course
.bf5b					_BMFError:
.bf5b	4c c1 ae	jmp $aec1			jmp 	TypeError
.bf5e					ConcatenateString:
.bf5e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.bf60	85 1c		sta $1c				sta		zLTemp1+0
.bf62	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf64	85 1d		sta $1d				sta 	zLTemp1+1
.bf66	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.bf68	85 1e		sta $1e				sta 	zLTemp1+2
.bf6a	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.bf6c	85 1f		sta $1f				sta 	zLTemp1+3
.bf6e	5a		phy				phy
.bf6f	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.bf71	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.bf73	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.bf75	7a		ply				ply
.bf76	b0 33		bcs $bfab			bcs 	_CSError					; check in range.
.bf78	c9 fe		cmp #$fe			cmp 	#maxString+1
.bf7a	b0 2f		bcs $bfab			bcs 	_CSError
.bf7c	20 1d c4	jsr $c41d			jsr 	AllocateTempString 			; store the result
.bf7f	20 96 bf	jsr $bf96			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.bf82	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.bf84	85 1c		sta $1c				sta 	zLTemp1
.bf86	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.bf88	85 1d		sta $1d				sta 	zLTemp1+1
.bf8a	20 96 bf	jsr $bf96			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.bf8d	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.bf8f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf91	a5 23		lda $23				lda 	zTempStr+1
.bf93	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf95	60		rts				rts
.bf96					_CSCopyString:
.bf96	da		phx				phx
.bf97	5a		phy				phy
.bf98	a0 00		ldy #$00			ldy 	#0 							; get length
.bf9a	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.bf9c	f0 0a		beq $bfa8			beq 	_CSCSExit 					; if zero, exit immediately
.bf9e	aa		tax				tax 								; put in X which is the counter.
.bf9f					_CSCSLoop:
.bf9f	c8		iny				iny 								; get next char
.bfa0	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.bfa2	20 48 c4	jsr $c448			jsr		WriteTempString 			; copy out to new string
.bfa5	ca		dex				dex 								; do whole string
.bfa6	d0 f7		bne $bf9f			bne 	_CSCSLoop
.bfa8					_CSCSExit:
.bfa8	7a		ply				ply
.bfa9	fa		plx				plx
.bfaa	60		rts				rts
.bfab					_CSError:
.bfab	20 e0 ae	jsr $aee0			jsr ERR_Handler
>bfae	53 74 72 69 6e 67 20 74			.text "String too long",0
>bfb6	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.bfbe					Unary_Sgn:
.bfbe	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX 			; get value
.bfc1	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; check right bracket.
.bfc4	20 e2 bf	jsr $bfe2			jsr 	GetSignCurrent 				; get sign.
.bfc7	09 00		ora #$00			ora 	#0
.bfc9	10 08		bpl $bfd3			bpl		UnarySetAInteger			; if 0,1 return that.
.bfcb	80 00		bra $bfcd			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.bfcd					UnarySetAMinus1:
.bfcd	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.bfcf	95 80		sta $80,x			sta 	XS_Mantissa,x
.bfd1	80 04		bra $bfd7			bra 	UnarySetAFill
.bfd3					UnarySetAInteger:
.bfd3	95 80		sta $80,x			sta 	XS_Mantissa,x
.bfd5	a9 00		lda #$00			lda 	#0
.bfd7					UnarySetAFill:
.bfd7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bfd9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bfdb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bfdd	a9 01		lda #$01			lda 	#1 							; set type to integer.
.bfdf	95 85		sta $85,x			sta 	XS_Type,x
.bfe1	60		rts				rts
.bfe2					GetSignCurrent:
.bfe2	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.bfe4	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.bfe5	90 15		bcc $bffc			bcc 	_GSCFloat 					; if clear do the float code.
.bfe7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.bfe9	30 0e		bmi $bff9			bmi 	_GSCMinus1
.bfeb	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.bfed	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.bfef	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bff1	d0 03		bne $bff6			bne 	_GSCPlus1 					; check if zero by oring all together.
.bff3					_GSCZero:
.bff3	a9 00		lda #$00			lda 	#0
.bff5	60		rts				rts
.bff6					_GSCPlus1:
.bff6	a9 01		lda #$01			lda 	#$01
.bff8	60		rts				rts
.bff9					_GSCMinus1:
.bff9	a9 ff		lda #$ff			lda 	#$FF
.bffb	60		rts				rts
.bffc					_GSCFloat:
.bffc	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.bffe	70 f3		bvs $bff3			bvs 	_GSCZero 					; if zero flag set return zero
.c000	30 f7		bmi $bff9			bmi 	_GSCMinus1 					; if sign set return -1
.c002	80 f2		bra $bff6			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.c004					Unary_Abs:
.c004	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX 			; get value
.c007	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; check right bracket.
.c00a	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.c00c	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c00e	f0 07		beq $c017			beq 	_UAMinusFloat
.c010	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.c012	10 09		bpl $c01d			bpl 	_UAExit
.c014	4c 5d cb	jmp $cb5d			jmp 	IntegerNegateAlways 		; if so negate it.
.c017					_UAMinusFloat:
.c017	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.c019	29 7f		and #$7f			and		#$7F
.c01b	95 85		sta $85,x			sta 	XS_Type,x
.c01d					_UAExit:
.c01d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.c01e					Unary_Peek:
.c01e	a9 01		lda #$01			lda 	#1 							; 1 byte
.c020	80 06		bra $c028			bra 	UPMain
.c022					Unary_Deek:
.c022	a9 02		lda #$02			lda 	#2 							; 2 bytes
.c024	80 02		bra $c028			bra 	UPMain
.c026					Unary_Leek:
.c026	a9 04		lda #$04			lda 	#4 							; 4 bytes
.c028					UPMain:
.c028	48		pha				pha 								; save bytes to copy.
.c029	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.c02c	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c02f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.c031	85 1c		sta $1c				sta 	zLTemp1
.c033	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c035	85 1d		sta $1d				sta 	zLTemp1+1
.c037	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c039	85 1e		sta $1e				sta 	zLTemp1+2
.c03b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c03d	85 1f		sta $1f				sta 	zLTemp1+3
.c03f	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.c041	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.c043	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c045	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c047	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c049	68		pla				pla 								; restore bytes to copy
.c04a	da		phx				phx 								; save XY
.c04b	5a		phy				phy
.c04c	20 45 c3	jsr $c345			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.c04f	7a		ply				ply 								; restore and exit
.c050	fa		plx				plx
.c051	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.c052					Unary_Pos:
.c052	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.c055	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; check right bracket.
.c058	20 aa ae	jsr $aeaa			jsr 	VIOCharGetPosition 			; get the position
.c05b	4c d3 bf	jmp $bfd3			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.c05e					Unary_Mod:
.c05e	20 86 c0	jsr $c086			jsr 	_UMParameter 				; first parameter, get |param|
.c061	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma
.c064	da		phx				phx 								; second parameter, get |param|
.c065	e8		inx				inx
.c066	e8		inx				inx
.c067	e8		inx				inx
.c068	e8		inx				inx
.c069	e8		inx				inx
.c06a	e8		inx				inx
.c06b	20 86 c0	jsr $c086			jsr 	_UMParameter
.c06e	fa		plx				plx
.c06f	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen
.c072	20 d6 ca	jsr $cad6			jsr 	DivInteger32 				; divide, which handily leaves ....
.c075	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.c077	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c079	a5 1d		lda $1d				lda 	zLTemp1+1
.c07b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c07d	a5 1e		lda $1e				lda 	zLTemp1+2
.c07f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c081	a5 1f		lda $1f				lda 	zLTemp1+3
.c083	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c085	60		rts				rts
.c086					_UMParameter:
.c086	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX 			; get value
.c089	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.c08b	10 03		bpl $c090			bpl 	_UMNotSigned
.c08d	20 5d cb	jsr $cb5d			jsr 	IntegerNegateAlways
.c090					_UMNotSigned:
.c090	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.c091					Unary_Usr:
.c091	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX 			; numeric parameter
.c094	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c097	da		phx				phx 								; save XY
.c098	5a		phy				phy
.c099	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.c09c	7a		ply				ply 								; restore YX and exit with whatever the
.c09d	fa		plx				plx 								; routine called has chosen to do with it.
.c09e	60		rts				rts
.c09f					USRDefault:
.c09f	20 e0 ae	jsr $aee0			jsr ERR_Handler
>c0a2	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>c0aa	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.c0b1					Unary_Val:
.c0b1	20 83 bd	jsr $bd83			jsr 	EvaluateStringX 			; get string
.c0b4	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; check right bracket.
.c0b7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.c0b9	85 20		sta $20				sta 	zGenPtr
.c0bb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c0bd	85 21		sta $21				sta 	zGenPtr+1
.c0bf	da		phx				phx
.c0c0	5a		phy				phy
.c0c1	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.c0c3	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.c0c5	f0 1b		beq $c0e2			beq 	UVBadNumber
.c0c7	aa		tax				tax
.c0c8					_UVCopy1:
.c0c8	c8		iny				iny
.c0c9	c0 18		cpy #$18			cpy 	#24 						; too long
.c0cb	f0 15		beq $c0e2			beq 	UVBadNumber
.c0cd	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.c0cf	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.c0d2	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.c0d4	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.c0d7	ca		dex				dex
.c0d8	d0 ee		bne $c0c8			bne 	_UVCopy1
.c0da	7a		ply				ply
.c0db	fa		plx				plx
.c0dc	20 f0 c0	jsr $c0f0			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.c0df	b0 01		bcs $c0e2			bcs 	UVBadNumber
.c0e1	60		rts				rts
.c0e2					UVBadNumber:
.c0e2	20 e0 ae	jsr $aee0			jsr ERR_Handler
>c0e5	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>c0ed	65 72 00
.c0f0					ConvertNumBuffer:
.c0f0	5a		phy				phy
.c0f1	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.c0f3	85 20		sta $20				sta 	zGenPtr
.c0f5	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.c0f7	85 21		sta $21				sta 	zGenPtr+1
.c0f9	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.c0fc	c9 2d		cmp #$2d			cmp 	#"-"
.c0fe	d0 02		bne $c102			bne 	_UVNotMinus1
.c100	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.c102					_UVNotMinus1:
.c102	20 2b cc	jsr $cc2b			jsr 	IntFromString 				; get integer
.c105	b0 22		bcs $c129			bcs 	_UVFail
.c107	20 ab d1	jsr $d1ab			jsr 	FPFromString 				; possibly float it.
.c10a	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.c10c	d0 1b		bne $c129			bne 	_UVFail 					; no, exit.
.c10e	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.c111	c9 2d		cmp #$2d			cmp 	#"-"
.c113	d0 11		bne $c126			bne 	_UVNotMinus2
.c115	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.c117	29 0f		and #$0f			and 	#$0F
.c119	f0 05		beq $c120			beq 	_UVNegateFloat
.c11b	20 5d cb	jsr $cb5d			jsr 	IntegerNegateAlways
.c11e	80 06		bra $c126			bra 	_UVNotMinus2
.c120					_UVNegateFloat:
.c120	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.c122	09 80		ora #$80			ora 	#$80
.c124	95 85		sta $85,x			sta 	XS_Type,x
.c126					_UVNotMinus2:
.c126	7a		ply				ply
.c127	18		clc				clc
.c128	60		rts				rts
.c129	7a		ply		_UVFail:ply
.c12a	38		sec				sec
.c12b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.c12c					Unary_Str:
.c12c	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX 			; numeric parameter
.c12f	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c132	a9 00		lda #$00			lda 	#0 							; reset buffer index
.c134	8d 14 03	sta $0314			sta 	NumBufX
.c137	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.c139	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.c13a	b0 05		bcs $c141			bcs 	_USInt 						; if msb set do as integer
.c13c	20 f0 d0	jsr $d0f0			jsr 	FPToString 					; call fp to str otherwise
.c13f	80 03		bra $c144			bra 	_USDuplicate
.c141	20 7a cb	jsr $cb7a	_USInt:	jsr 	IntToString					; call int to str.
.c144					_USDuplicate:
.c144	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.c147	1a		inc a				inc 	a 							; one more for length
.c148	20 1d c4	jsr $c41d			jsr 	AllocateTempString 			; allocate space for it.
.c14b	5a		phy				phy 								; save Y
.c14c	a0 00		ldy #$00			ldy 	#0 							; start copying
.c14e	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.c151	20 48 c4	jsr $c448			jsr 	WriteTempString
.c154	c8		iny				iny
.c155	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.c158	d0 f4		bne $c14e			bne 	_USCopy
.c15a	7a		ply				ply 								; restore Y
.c15b	4c 38 c3	jmp $c338			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c15e					Unary_Asc:
.c15e	20 83 bd	jsr $bd83			jsr 	EvaluateStringX 			; string parameter
.c161	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c164	5a		phy				phy 								; get the string length
.c165	a0 00		ldy #$00			ldy 	#0
.c167	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c169	f0 07		beq $c172			beq 	_UAIllegal 					; must be at least one character, 0 => error
.c16b	c8		iny				iny
.c16c	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.c16e	7a		ply				ply
.c16f	4c d3 bf	jmp $bfd3			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.c172					_UAIllegal:
.c172	4c cf ae	jmp $aecf			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c175					Unary_Len:
.c175	20 83 bd	jsr $bd83			jsr 	EvaluateStringX 			; string parameter
.c178	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c17b	5a		phy				phy 								; get the string length
.c17c	a0 00		ldy #$00			ldy 	#0
.c17e	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c180	7a		ply				ply
.c181	4c d3 bf	jmp $bfd3			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.c184					Unary_Mid:
.c184	20 83 bd	jsr $bd83			jsr 	EvaluateStringX 				; get string.
.c187	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c189	48		pha				pha
.c18a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c18c	48		pha				pha
.c18d	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma 					; skip comma
.c190	20 19 c2	jsr $c219			jsr 	SLIByteParameter 				; get a byte parameter (start)
.c193	48		pha				pha 									; and push it.
.c194	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma 					; skip comma
.c197	20 19 c2	jsr $c219			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.c19a	48		pha				pha 									; and push it.
.c19b	80 41		bra $c1de			bra 	SLIProcess
.c19d					Unary_Left:
.c19d	20 83 bd	jsr $bd83			jsr 	EvaluateStringX 				; get string.
.c1a0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c1a2	48		pha				pha
.c1a3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c1a5	48		pha				pha
.c1a6	a9 01		lda #$01			lda 	#1 								; push start position (1)
.c1a8	48		pha				pha
.c1a9	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma 					; skip comma
.c1ac	20 19 c2	jsr $c219			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.c1af	48		pha				pha 									; and push it.
.c1b0	80 2c		bra $c1de			bra 	SLIProcess
.c1b2					Unary_Right:
.c1b2	20 83 bd	jsr $bd83			jsr 	EvaluateStringX 				; get string.
.c1b5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c1b7	48		pha				pha
.c1b8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c1ba	48		pha				pha
.c1bb	da		phx				phx 									; get the string length and push on stack.
.c1bc	a2 00		ldx #$00			ldx 	#0
.c1be	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.c1c0	fa		plx				plx
.c1c1	48		pha				pha
.c1c2	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma 					; skip comma
.c1c5	20 19 c2	jsr $c219			jsr 	SLIByteParameter 				; get a byte parameter.
.c1c8	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.c1cb	68		pla				pla 									; restore string length.
.c1cc	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.c1cd	38		sec				sec
.c1ce	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.c1d1	f0 02		beq $c1d5			beq 	_URStart 						; if <= 0 start from 1.
.c1d3	10 02		bpl $c1d7			bpl 	_UROkay
.c1d5					_URStart:
.c1d5	a9 01		lda #$01			lda 	#1
.c1d7					_UROkay:
.c1d7	48		pha				pha 									; push start
.c1d8	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.c1db	48		pha				pha
.c1dc	80 00		bra $c1de			bra 	SLIProcess
.c1de					SLIProcess:
.c1de	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 				; closing right bracket.
.c1e1	68		pla				pla
.c1e2	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.c1e5	1a		inc a				inc 	a 								; allocate +1 for it.
.c1e6	20 1d c4	jsr $c41d			jsr 	AllocateTempString
.c1e9	68		pla				pla 									; pop start number off stack.
.c1ea	f0 3b		beq $c227			beq 	SLIError 						; exit if start = 0
.c1ec	8d a1 03	sta $03a1			sta 	SliceStart
.c1ef	68		pla				pla  									; pop string address.
.c1f0	85 21		sta $21				sta 	zGenPtr+1
.c1f2	68		pla				pla
.c1f3	85 20		sta $20				sta 	zGenPtr
.c1f5	da		phx				phx
.c1f6	5a		phy				phy
.c1f7	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.c1f9	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.c1fc					_SLICopy:
.c1fc	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.c1ff	f0 12		beq $c213			beq 	_SLIExit
.c201	ce a2 03	dec $03a2			dec 	SliceCount
.c204	98		tya				tya 									; index of character
.c205	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.c207	f0 02		beq $c20b			beq 	_SLIOk 							; if equal, okay.
.c209	b0 08		bcs $c213			bcs 	_SLIExit 						; if past end, then exit.
.c20b	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.c20d	c8		iny				iny
.c20e	20 48 c4	jsr $c448			jsr 	WriteTempString
.c211	80 e9		bra $c1fc			bra 	_SLICopy 						; go round till copied characters
.c213					_SLIExit:
.c213	7a		ply				ply 									; restore YX
.c214	fa		plx				plx
.c215	4c 38 c3	jmp $c338			jmp 	UnaryReturnTempStr 				; return new temporary string.
.c218	ea		nop				nop
.c219					SLIByteParameter:
.c219	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX 				; get integer
.c21c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.c21e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c220	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c222	d0 03		bne $c227			bne 	SLIError
.c224	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c226	60		rts				rts
.c227					SLIError:
.c227	4c cf ae	jmp $aecf			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.c22a					Unary_Hex:
.c22a	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX 			; numeric parameter
.c22d	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c230	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.c232	20 1d c4	jsr $c41d			jsr 	AllocateTempString			; allocate string space
.c235	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.c237	20 5b c2	jsr $c25b			jsr 	_UHConvert
.c23a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c23c	20 5b c2	jsr $c25b			jsr 	_UHConvert
.c23f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c241	20 5b c2	jsr $c25b			jsr 	_UHConvert
.c244	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c246	20 5b c2	jsr $c25b			jsr 	_UHConvert
.c249	5a		phy				phy 								; get length of new string
.c24a	a0 00		ldy #$00			ldy 	#0
.c24c	b1 22		lda ($22),y			lda 	(zTempStr),y
.c24e	7a		ply				ply
.c24f	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.c251	d0 05		bne $c258			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.c253	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.c255	20 48 c4	jsr $c448			jsr 	WriteTempString
.c258					_UHExit:
.c258	4c 38 c3	jmp $c338			jmp 	UnaryReturnTempStr 			; return new temporary string.
.c25b					_UHConvert:
.c25b	48		pha				pha
.c25c	4a		lsr a				lsr 	a 							; do MSB
.c25d	4a		lsr a				lsr 	a
.c25e	4a		lsr a				lsr 	a
.c25f	4a		lsr a				lsr 	a
.c260	20 64 c2	jsr $c264			jsr 	_UHNibble
.c263	68		pla				pla 								; do LSB
.c264					_UHNibble:
.c264	29 0f		and #$0f			and 	#15 						; get nibble
.c266	d0 0c		bne $c274			bne 	_UHNonZero 					; if not zero, write it out anyway.
.c268	5a		phy				phy									; get the length
.c269	a0 00		ldy #$00			ldy 	#0
.c26b	b1 22		lda ($22),y			lda 	(zTempStr),y
.c26d	7a		ply				ply
.c26e	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.c270	f0 0d		beq $c27f			beq 	_UHExit2
.c272	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.c274					_UHNonZero:
.c274	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c276	90 02		bcc $c27a			bcc 	_UHDigit
.c278	69 06		adc #$06			adc 	#7-1
.c27a					_UHDigit:
.c27a	69 30		adc #$30			adc 	#48
.c27c	20 48 c4	jsr $c448			jsr 	WriteTempString				; output to temp string.
.c27f					_UHExit2:
.c27f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.c280					Unary_Dec:
.c280	20 83 bd	jsr $bd83			jsr 	EvaluateStringX 			; string parameter
.c283	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c286	5a		phy				phy
.c287	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.c289	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c28b	f0 43		beq $c2d0			beq 	_UDFail 					; must fail if zero.
.c28d	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.c290	a9 00		lda #$00			lda 	#0 							; set result to zero
.c292	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c294	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c296	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c298	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c29a	a9 01		lda #$01			lda 	#1 							; set type to integer.
.c29c	95 85		sta $85,x			sta 	XS_Type,x
.c29e					_UDConvertLoop:
.c29e	5a		phy				phy 								; shift mantissa left 4
.c29f	a0 04		ldy #$04			ldy 	#4
.c2a1					_UDShift:
.c2a1	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c2a3	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c2a5	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c2a7	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c2a9	88		dey				dey
.c2aa	d0 f5		bne $c2a1			bne 	_UDShift
.c2ac	7a		ply				ply
.c2ad	c8		iny				iny 								; next character
.c2ae	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.c2b0	20 d3 c2	jsr $c2d3			jsr 	ConvertUpper 				; convert to U/C
.c2b3	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.c2b5	90 19		bcc $c2d0			bcc 	_UDFail
.c2b7	c9 3a		cmp #$3a			cmp 	#"9"+1
.c2b9	90 08		bcc $c2c3			bcc 	_UDOkay
.c2bb	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.c2bd	90 11		bcc $c2d0			bcc 	_UDFail 					; fails if between 9 and @
.c2bf	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.c2c1	b0 0d		bcs $c2d0			bcs 	_UDFail
.c2c3					_UDOkay:
.c2c3	29 0f		and #$0f			and 	#15 						; nibble only
.c2c5	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.c2c7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c2c9	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.c2cc	d0 d0		bne $c29e			bne 	_UDConvertLoop
.c2ce	7a		ply				ply
.c2cf	60		rts				rts
.c2d0					_UDFail:
.c2d0	4c cf ae	jmp $aecf			jmp 	BadParamError
.c2d3					ConvertUpper:
.c2d3	c9 61		cmp #$61			cmp 	#"a"
.c2d5	90 07		bcc $c2de			bcc 	_CUExit
.c2d7	c9 7b		cmp #$7b			cmp 	#"z"+1
.c2d9	b0 03		bcs $c2de			bcs 	_CUExit
.c2db	38		sec				sec
.c2dc	e9 20		sbc #$20			sbc 	#32
.c2de	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.c2df					Unary_Chr:
.c2df	20 7a bd	jsr $bd7a			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.c2e2	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; right bracket.
.c2e5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c2e7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c2e9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c2eb	d0 0d		bne $c2fa			bne 	_UCChar
.c2ed	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.c2ef	20 1d c4	jsr $c41d			jsr 	AllocateTempString			; allocate it.
.c2f2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.c2f4	20 48 c4	jsr $c448			jsr 	WriteTempString
.c2f7	4c 38 c3	jmp $c338			jmp 	UnaryReturnTempStr 			; and return that string.
.c2fa					_UCChar:
.c2fa	4c cf ae	jmp $aecf			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.c2fd					Unary_Spc:
.c2fd	20 19 c2	jsr $c219			jsr 	SLIByteParameter 			; get number of spaces
.c300	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; skip )
.c303	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.c305					UnarySpcCreate:
.c305	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.c307	b0 14		bcs $c31d			bcs 	_USSize
.c309	48		pha				pha 								; save length
.c30a	1a		inc a				inc 	a 							; allocate one more.
.c30b	20 1d c4	jsr $c41d			jsr 	AllocateTempString
.c30e	68		pla				pla 								; get length
.c30f	f0 27		beq $c338			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.c311					_USLoop:
.c311	48		pha				pha
.c312	a9 20		lda #$20			lda 	#" "
.c314	20 48 c4	jsr $c448			jsr 	WriteTempString
.c317	68		pla				pla
.c318	3a		dec a				dec 	a
.c319	d0 f6		bne $c311			bne 	_USLoop
.c31b	80 1b		bra $c338			bra 	UnaryReturnTempStr 			; and return the temporary space.
.c31d					_USSize:
.c31d	4c cf ae	jmp $aecf			jmp 	BadParamError
.c320					Unary_Tab:
.c320	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.c322	20 19 c2	jsr $c219			jsr 	SLIByteParameter
.c325	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen
.c328	20 aa ae	jsr $aeaa			jsr 	VIOCharGetPosition 			; were are we ?
.c32b	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.c32d	38		sec				sec
.c32e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.c330	e5 10		sbc $10				sbc 	zTemp1
.c332	b0 d1		bcs $c305			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.c334	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.c336	80 cd		bra $c305			bra 	UnarySpcCreate
.c338					UnaryReturnTempStr:
.c338	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.c33a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c33c	a5 23		lda $23				lda 	zTempStr+1
.c33e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c340	a9 02		lda #$02			lda 	#2 							; set type to string
.c342	95 85		sta $85,x			sta 	XS_Type,x
.c344	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.c345	db		phz		MemRead:phz
.c346	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c349	a3 00		ldz #$00			ldz 	#0 							; start from here
.c34b	ea		nop		_MLoop1:nop
.c34c	b2 1c		lda ($1c),z			lda 	(zlTemp1),z 				; read the long address
.c34e	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.c350	1b		inz				inz 								; next to copy
.c351	e8		inx				inx
.c352	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c355	d0 f4		bne $c34b			bne 	_MLoop1
.c357	fb		plz				plz
.c358	60		rts				rts
.c359					MemWrite:
.c359	db		phz				phz
.c35a	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c35d	a3 00		ldz #$00			ldz 	#0 							; start from here
.c35f	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.c361	ea		nop				nop
.c362	92 1c		sta ($1c),z			sta 	(zlTemp1),z 				; write it out
.c364	1b		inz				inz 								; next to copy
.c365	e8		inx				inx
.c366	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c369	d0 f4		bne $c35f			bne 	_MLoop1
.c36b	fb		plz				plz
.c36c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.c36d					UpdateProgramEnd:
.c36d	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.c36f	85 18		sta $18				sta 	zCodePtr+0
.c371	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.c373	85 19		sta $19				sta 	zCodePtr+1
.c375	a9 00		lda #$00			lda 	#(BasicProgram) >> 16
.c377	85 1a		sta $1a				sta 	zCodePtr+2
.c379	a9 00		lda #$00			lda 	#0
.c37b	85 1b		sta $1b				sta 	zCodePtr+3
.c37d	a3 03		ldz #$03			ldz 	#3
.c37f					_UPDLoop:
.c37f	a3 00		ldz #$00			ldz 	#0
.c381	ea		nop				nop
.c382	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c384	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.c386	f0 10		beq $c398			beq 	_UPDFoundEnd
.c388	a3 00		ldz #$00			ldz 	#0 							; point to offset
.c38a	ea		nop				nop
.c38b	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.c38d	18		clc				clc
.c38e	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.c390	85 18		sta $18				sta 	zCodePtr
.c392	90 02		bcc $c396			bcc 	_SNLNoCarry
.c394	e6 19		inc $19				inc 	zCodePtr+1
.c396					_SNLNoCarry:
.c396	80 e7		bra $c37f			bra 	_UPDLoop
.c398					_UPDFoundEnd:
.c398	18		clc				clc 								; end of program 2 on.
.c399	a5 18		lda $18				lda 	zCodePtr
.c39b	69 02		adc #$02			adc 	#2
.c39d	8d 04 03	sta $0304			sta 	endOfProgram
.c3a0	a5 19		lda $19				lda 	zCodePtr+1
.c3a2	69 00		adc #$00			adc 	#0
.c3a4	8d 05 03	sta $0305			sta 	endOfProgram+1
.c3a7	a5 1a		lda $1a				lda 	zCodePtr+2
.c3a9	69 00		adc #$00			adc		#0
.c3ab	8d 06 03	sta $0306			sta 	endOfProgram+2
.c3ae	a5 1b		lda $1b				lda 	zCodePtr+3
.c3b0	69 00		adc #$00			adc 	#0
.c3b2	8d 07 03	sta $0307			sta 	endOfProgram+3
.c3b5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.c3b6					CheckNextToken:
.c3b6	ea		nop				nop
.c3b7	d2 18		cmp ($18),z			cmp 	(zCodePtr),z
.c3b9	d0 02		bne $c3bd			bne 	CTFail 						; no, then fail
.c3bb	1b		inz				inz
.c3bc	60		rts				rts
.c3bd					CTFail:
.c3bd	20 e0 ae	jsr $aee0			jsr ERR_Handler
>c3c0	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>c3c8	74 6f 6b 65 6e 00
.c3ce					CheckNextRParen:
.c3ce	ea		nop				nop
.c3cf	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c3d1	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.c3d3	d0 e8		bne $c3bd			bne 	CTFail 						; fail if not
.c3d5	1b		inz				inz
.c3d6	60		rts				rts
.c3d7					CheckNextComma:
.c3d7	ea		nop				nop
.c3d8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c3da	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.c3dc	d0 df		bne $c3bd			bne 	CTFail 						; fail if not
.c3de	1b		inz				inz
.c3df	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.c3e0					StringConcrete:
.c3e0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.c3e2	85 10		sta $10				sta 	zTemp1
.c3e4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c3e6	85 11		sta $11				sta 	zTemp1+1
.c3e8	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.c3ea	b1 10		lda ($10),y			lda 	(zTemp1),y
.c3ec	f0 26		beq $c414			beq		_SCEmpty 					; concreting it wastes memory.
.c3ee	18		clc				clc 								; from the string pointer
.c3ef	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.c3f2	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.c3f4	8d 00 03	sta $0300			sta 	StringPtr
.c3f7	85 12		sta $12				sta 	zTemp2
.c3f9	ad 01 03	lda $0301			lda 	StringPtr+1
.c3fc	e9 00		sbc #$00			sbc 	#0
.c3fe	8d 01 03	sta $0301			sta 	StringPtr+1
.c401	85 13		sta $13				sta 	zTemp2+1
.c403	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.c405	1a		inc a				inc 	a
.c406	aa		tax				tax
.c407	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.c409	91 12		sta ($12),y			sta 	(zTemp2),y
.c40b	c8		iny				iny
.c40c	ca		dex				dex
.c40d	d0 f8		bne $c407			bne 	_SCCopy
.c40f	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.c411	a6 12		ldx $12				ldx 	zTemp2
.c413	60		rts				rts
.c414					_SCEmpty:
.c414	a9 00		lda #$00			lda 	#0
.c416	85 27		sta $27				sta 	zNullString
.c418	a9 00		lda #$00			lda 	#zNullString >> 8
.c41a	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.c41c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c41d					AllocateTempString:
.c41d	48		pha				pha 								; save required count.
.c41e	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.c420	d0 0b		bne $c42d			bne 	_ATSInitialised
.c422	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c425	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.c427	ad 01 03	lda $0301			lda 	StringPtr+1
.c42a	3a		dec a				dec 	a 							; allow the page.
.c42b	85 23		sta $23				sta 	zTempStr+1
.c42d					_ATSInitialised:
.c42d	68		pla				pla 								; get required count back.
.c42e	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.c430	1a		inc a				inc 	a
.c431	18		clc				clc
.c432	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.c434	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.c436	a9 ff		lda #$ff			lda 	#$FF
.c438	65 23		adc $23				adc 	zTempStr+1
.c43a	85 23		sta $23				sta 	zTempStr+1
.c43c	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.c43e	5a		phy				phy
.c43f	a8		tay				tay
.c440	91 22		sta ($22),y			sta 	(zTempStr),y
.c442	7a		ply				ply
.c443	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.c444	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.c447	60		rts				rts
.c448					WriteTempString:
.c448	5a		phy				phy 								; save Y
.c449	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.c44c	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.c44e	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.c451	98		tya				tya 								; unchanged Y is now length
.c452	a0 00		ldy #$00			ldy 	#0
.c454	91 22		sta ($22),y			sta 	(zTempStr),y
.c456	7a		ply				ply 								; restore Y and exit
.c457	60		rts				rts
.c458					CreateTempStringCopy:
.c458	da		phx				phx 								; save X
.c459	ea		nop				nop
.c45a	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c45c	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c45d	20 1d c4	jsr $c41d			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c460	ea		nop				nop
.c461	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c463	1b		inz				inz
.c464	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.c465	3a		dec a				dec 	a 							; for the marker and the length.
.c466	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c468	81 22		sta ($22,x)			sta 	(zTempStr,x)
.c46a	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.c46c	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c46e	f0 0f		beq $c47f			beq 	_CTSCExit
.c470					_CTSCLoop:
.c470	ea		nop				nop
.c471	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c473	1b		inz				inz
.c474	5a		phy				phy 								; save Y
.c475	e8		inx				inx 								; bump index
.c476	da		phx				phx 								; save that
.c477	7a		ply				ply 								; index into Y
.c478	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.c47a	7a		ply				ply 								; restore Y
.c47b	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.c47d	d0 f1		bne $c470			bne 	_CTSCLoop
.c47f					_CTSCExit:
.c47f	fa		plx				plx 								; restore X
.c480	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.c481					TokeniseKeyword:
.c481	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.c482	18		clc				clc
.c483	65 20		adc $20				adc 	zGenPtr
.c485	85 20		sta $20				sta 	zGenPtr
.c487	90 02		bcc $c48b			bcc 	_TKWNoBump
.c489	e6 21		inc $21				inc 	zGenPtr+1
.c48b					_TKWNoBump:
.c48b	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.c48d	da		phx				phx
.c48e	a9 27		lda #$27			lda 	#KeyWordText & $FF 			; scan this table.
.c490	a2 b0		ldx #$b0			ldx 	#(KeyWordText >> 8) & $FF
.c492	20 9d c4	jsr $c49d			jsr 	TKWScanTokenTable
.c495	fa		plx				plx
.c496	90 04		bcc $c49c			bcc 	_TKWNoWrite
.c498	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.c49b	e8		inx				inx
.c49c					_TKWNoWrite:
.c49c	60		rts				rts
.c49d					TKWScanTokenTable:
.c49d	86 1d		stx $1d				stx 	zLTemp1+1
.c49f	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.c4a1	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.c4a3	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.c4a5	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c4a7	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise 					; save this in zTemp3
.c4aa	85 14		sta $14				sta 	zTemp3
.c4ac	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.c4ae	85 15		sta $15				sta 	zTemp3+1
.c4b0					_TKWScanLoop:
.c4b0	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c4b2	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.c4b4	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.c4b6	d0 26		bne $c4de			bne		_TKWNext 						; if it doesn't match, go to next.
.c4b8	20 fd c4	jsr $c4fd			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.c4bb	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.c4bd					_TKWCompareFull:
.c4bd	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c4bf	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.c4c1	85 16		sta $16				sta 	zTemp4
.c4c3	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.c4c5	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise 					; make it U/C
.c4c8	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.c4ca	d0 12		bne $c4de			bne 	_TKWNext 						; failed, go to next slot.
.c4cc	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c4ce	c8		iny				iny 									; bump pointer
.c4cf	0a		asl a				asl 	a 								; shift bit 7 into C
.c4d0	90 eb		bcc $c4bd			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.c4d2	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.c4d4	90 08		bcc $c4de			bcc 	_TKWNext 						; if shorter, the original was better
.c4d6	84 12		sty $12				sty 	zTemp2							; update longest match.
.c4d8	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.c4da	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.c4dc	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.c4de					_TKWNext:
.c4de	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c4e0	c8		iny				iny 									; next one.
.c4e1	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.c4e2	90 fa		bcc $c4de			bcc 	_TKWNext
.c4e4	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.c4e6	98		tya				tya 									; has Y gone negative.
.c4e7	10 03		bpl $c4ec			bpl 	_TKWNoYZero
.c4e9	20 fd c4	jsr $c4fd			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.c4ec					_TKWNoYZero:
.c4ec	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c4ee	d0 c0		bne $c4b0			bne 	_TKWScanLoop 					; if not, try the next one.
.c4f0	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.c4f2	f0 05		beq $c4f9			beq 	_TKWFail 						; if zero, none found.
.c4f4	a8		tay				tay 									; return the token in zTemp2, length => y
.c4f5	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.c4f7	38		sec				sec
.c4f8	60		rts				rts
.c4f9					_TKWFail:
.c4f9	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.c4fb	18		clc				clc
.c4fc	60		rts				rts
.c4fd					_TKWClearY:
.c4fd	98		tya				tya
.c4fe	18		clc				clc
.c4ff	65 1c		adc $1c				adc 	zLTemp1
.c501	85 1c		sta $1c				sta 	zLTemp1
.c503	90 02		bcc $c507			bcc 	_TKWCNoBump
.c505	e6 1d		inc $1d				inc 	zLTemp1+1
.c507					_TKWCNoBump:
.c507	a0 00		ldy #$00			ldy 	#0
.c509	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.c50a					TokeniseString:
.c50a	85 20		sta $20				sta 	zGenPtr 					; save source
.c50c	86 21		stx $21				stx 	zGenPtr+1
.c50e	a0 00		ldy #$00			ldy 	#0 							; source
.c510	a2 03		ldx #$03			ldx 	#3 							; target
.c512	8c 00 04	sty $0400			sty 	TokeniseBuffer+0 			; write three NULLs. So it looks like
.c515	8c 01 04	sty $0401			sty 	TokeniseBuffer+1 			; there's a line number zero.
.c518	8c 02 04	sty $0402			sty 	TokeniseBuffer+2
.c51b					_TSMainLoop:
.c51b					_TSSkipSpaces:
.c51b	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.c51d	c8		iny				iny
.c51e	c9 20		cmp #$20			cmp 	#" "
.c520	f0 f9		beq $c51b			beq 	_TSSkipSpaces
.c522	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.c524	90 0a		bcc $c530			bcc 	_TSNotConstant
.c526	c9 3a		cmp #$3a			cmp 	#"9"+1
.c528	b0 06		bcs $c530			bcs 	_TSNotConstant
.c52a	88		dey				dey 								; point back to start
.c52b	20 4f c6	jsr $c64f			jsr 	TokeniseConstant 			; tokenise a constant
.c52e	80 eb		bra $c51b			bra 	_TSMainLoop			 		; and loop back.
.c530					_TSNotConstant:
.c530	c9 20		cmp #$20			cmp 	#32 						; end of line.
.c532	90 52		bcc $c586			bcc 	_TSExit
.c534	c9 22		cmp #$22			cmp		#'"'						; quoted string
.c536	f0 55		beq $c58d			beq 	_TSQuotedString
.c538	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.c53a	f0 56		beq $c592			beq 	_TSDecimal
.c53c	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise 				; make U/C
.c53f	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.c541	d0 05		bne $c548			bne 	_TSNoRemCheck
.c543	20 97 c5	jsr $c597			jsr 	TOKCheckREM
.c546	b0 d3		bcs $c51b			bcs 	_TSMainLoop 				; and if REM okay, go back.
.c548					_TSNoRemCheck:
.c548	88		dey				dey 								; point to character
.c549	20 81 c4	jsr $c481			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.c54c	b0 cd		bcs $c51b			bcs 	_TSMainLoop					; true if tokenised okay.
.c54e	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.c550	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise
.c553	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.c555	90 04		bcc $c55b			bcc 	_TSSingle
.c557	c9 5b		cmp #$5b			cmp 	#"Z"+1
.c559	90 0d		bcc $c568			bcc 	_TSAlphaNumeric
.c55b					_TSSingle:
.c55b	c8		iny				iny 								; skip over output
.c55c	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.c55e	09 80		ora #$80			ora 	#128
.c560	f0 b9		beq $c51b			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.c562	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c565	e8		inx				inx
.c566	80 b3		bra $c51b			bra 	_TSMainLoop
.c568					_TSAlphaNumeric:
.c568	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.c56a	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise
.c56d	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.c56f	90 aa		bcc $c51b			bcc 	_TSMainLoop
.c571	c9 3a		cmp #$3a			cmp 	#"9"+1
.c573	90 0a		bcc $c57f			bcc 	_TSANOkay
.c575	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.c577	90 a2		bcc $c51b			bcc 	_TSMainLoop
.c579	c9 5b		cmp #$5b			cmp 	#"Z"+1
.c57b	b0 9e		bcs $c51b			bcs 	_TSMainLoop
.c57d	29 3f		and #$3f			and 	#63 						; write it out
.c57f					_TSANOkay:
.c57f	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c582	e8		inx				inx
.c583	c8		iny				iny
.c584	80 e2		bra $c568			bra 	_TSAlphaNumeric
.c586	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.c588	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c58b	8a		txa				txa 								; return length of tokenised line in bytes.
.c58c	60		rts				rts
.c58d					_TSQuotedString:
.c58d	20 ed c5	jsr $c5ed			jsr 	TokeniseQuotedString
.c590	80 89		bra $c51b			bra 	_TSMainLoop
.c592					_TSDecimal:
.c592	20 13 c6	jsr $c613			jsr 	TokeniseDecimalString
.c595	80 84		bra $c51b			bra 	_TSMainLoop
.c597					TOKCheckREM:
.c597	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.c599	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise
.c59c	c9 45		cmp #$45			cmp 	#"E"
.c59e	d0 12		bne $c5b2			bne 	_TCRFail
.c5a0	c8		iny				iny
.c5a1	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.c5a3	88		dey				dey
.c5a4	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise
.c5a7	c9 4d		cmp #$4d			cmp 	#"M"
.c5a9	d0 07		bne $c5b2			bne 	_TCRFail
.c5ab	c8		iny				iny									; point to first character
.c5ac	c8		iny				iny
.c5ad	20 bf c5	jsr $c5bf			jsr 	TokeniseREMString 			; tokenise REM
.c5b0	38		sec				sec
.c5b1	60		rts				rts
.c5b2					_TCRFail:
.c5b2	18		clc				clc
.c5b3	60		rts				rts
.c5b4					TOKCapitalise:
.c5b4	c9 61		cmp #$61			cmp 	#"a"
.c5b6	90 06		bcc $c5be			bcc 	_TOKCExit
.c5b8	c9 7b		cmp #$7b			cmp 	#"z"+1
.c5ba	b0 02		bcs $c5be			bcs 	_TOKCExit
.c5bc	49 20		eor #$20			eor 	#$20
.c5be					_TOKCExit:
.c5be	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.c5bf					TokeniseREMString:
.c5bf	86 10		stx $10				stx 	zTemp1 						; save position
.c5c1	a9 ff		lda #$ff			lda 	#$FF 						; write marker
.c5c3	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c5c6	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.c5c9	e8		inx				inx 								; bump, and one space for the count.
.c5ca	e8		inx				inx
.c5cb					_TSRSkip:
.c5cb	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c5cd	c8		iny				iny
.c5ce	c9 20		cmp #$20			cmp 	#" "
.c5d0	f0 f9		beq $c5cb			beq 	_TSRSkip
.c5d2	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.c5d4	f0 31		beq $c607			beq 	SequenceExit 				; ... that's it.
.c5d6					_TSRCopy:
.c5d6	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.c5d9	e8		inx				inx
.c5da	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.c5dc	f0 05		beq $c5e3			beq 	_TSRExit 					; zero is exit
.c5de	c8		iny				iny 								; bump pointer
.c5df	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.c5e1	d0 f3		bne $c5d6			bne 	_TSRCopy
.c5e3					_TSRExit:
.c5e3	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.c5e6	c9 20		cmp #$20			cmp 	#" "
.c5e8	d0 1d		bne $c607			bne 	SequenceExit
.c5ea	ca		dex				dex 								; go back - will bump into $FF eventually.
.c5eb	80 f6		bra $c5e3			bra 	_TSRExit
.c5ed					TokeniseQuotedString:
.c5ed	86 10		stx $10				stx 	zTemp1 						; save position
.c5ef	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.c5f1	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c5f4	e8		inx				inx 								; bump, and one space for the count.
.c5f5	e8		inx				inx
.c5f6					_TSQCopy:
.c5f6	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c5f8	c9 20		cmp #$20			cmp 	#" "
.c5fa	90 0b		bcc $c607			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.c5fc	c8		iny				iny
.c5fd	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.c5ff	f0 06		beq $c607			beq 	SequenceExit
.c601	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.c604	e8		inx				inx
.c605	80 ef		bra $c5f6			bra 	_TSQCopy
.c607					SequenceExit:
.c607	8a		txa				txa 								; current position
.c608	38		sec				sec 								; subtract start.
.c609	e5 10		sbc $10				sbc 	zTemp1
.c60b	da		phx				phx 								; copy that in
.c60c	a6 10		ldx $10				ldx 	zTemp1
.c60e	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.c611	fa		plx				plx
.c612	60		rts				rts
.c613					TokeniseDecimalString:
.c613	86 10		stx $10				stx 	zTemp1 						; save position
.c615	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.c617	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c61a	e8		inx				inx 								; bump, and one space for the count.
.c61b	e8		inx				inx
.c61c	20 3d c6	jsr $c63d			jsr 	_TDSCopyNumber 				; copy a number.
.c61f	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.c621	20 b4 c5	jsr $c5b4			jsr 	TOKCapitalise
.c624	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.c626	d0 df		bne $c607			bne 	SequenceExit 				; exit now.
.c628	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.c62b	e8		inx				inx
.c62c	c8		iny				iny
.c62d	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.c62f	c9 2d		cmp #$2d			cmp 	#"-"
.c631	d0 05		bne $c638			bne 	_TDSNoMinusExponent
.c633	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.c636	e8		inx				inx
.c637	c8		iny				iny
.c638					_TDSNoMinusExponent:
.c638	20 3d c6	jsr $c63d			jsr 	_TDSCopyNumber 				; do the exponent
.c63b	80 ca		bra $c607			bra 	SequenceExit
.c63d					_TDSCopyNumber:
.c63d	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c63f	c9 30		cmp #$30			cmp 	#"0"
.c641	90 0b		bcc $c64e			bcc 	_TDSCNExit
.c643	c9 3a		cmp #$3a			cmp 	#"9"+1
.c645	b0 07		bcs $c64e			bcs 	_TDSCNExit
.c647	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c64a	e8		inx				inx
.c64b	c8		iny				iny
.c64c	80 ef		bra $c63d			bra 	_TDSCopyNumber
.c64e					_TDSCNExit:
.c64e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.c64f					TokeniseConstant:
.c64f	da		phx				phx 								; save X
.c650	a2 00		ldx #$00			ldx 	#0
.c652	20 2d cc	jsr $cc2d			jsr 	IntFromStringY 				; get the integer out.
.c655	b0 37		bcs $c68e			bcs 	_TCQ 						; should not happen.
.c657	fa		plx				plx 								; restore X.
.c658	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.c65a	85 10		sta $10				sta 	zTemp1
.c65c					_TCRotate:
.c65c	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.c65e	29 c0		and #$c0			and 	#$C0
.c660	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.c662	05 82		ora $82				ora 	XS_Mantissa+2
.c664	05 83		ora $83				ora 	XS_Mantissa+3
.c666	f0 16		beq $c67e			beq 	_TCDone						; if so, at the bottom.
.c668	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.c66a	29 3f		and #$3f			and 	#$3F
.c66c	48		pha				pha
.c66d	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.c66f	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.c671					_TCShiftRight:
.c671	46 83		lsr $83				lsr 	XS_Mantissa+3
.c673	66 82		ror $82				ror 	XS_Mantissa+2
.c675	66 81		ror $81				ror 	XS_Mantissa+1
.c677	66 80		ror $80				ror 	XS_Mantissa+0
.c679	3a		dec a				dec 	a
.c67a	d0 f5		bne $c671			bne 	_TCShiftRight
.c67c	80 de		bra $c65c			bra 	_TCRotate 					; and go round again.
.c67e	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.c680					_TCWrite:
.c680	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.c682	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c685	e8		inx				inx
.c686	c6 10		dec $10				dec 	zTemp1 						; done all of them
.c688	30 03		bmi $c68d			bmi 	_TCExit 					; no , more to pop
.c68a	68		pla				pla
.c68b	80 f3		bra $c680			bra 	_TCWrite 					; until everything's off.
.c68d					_TCExit:
.c68d	60		rts				rts
.c68e					_TCQ:
.c68e	20 e0 ae	jsr $aee0			jsr ERR_Handler
>c691	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.c694					VariableFind:
.c694	20 01 c7	jsr $c701			jsr 	VariableExtract 		; find out all about it ....
.c697	20 9c c9	jsr $c99c			jsr 	VariableLocate 			; does it already exist ?
.c69a	b0 03		bcs $c69f			bcs 	_VFExists 				; if so, use that.
.c69c	20 8f c7	jsr $c78f			jsr 	VariableCreate 			; otherwise create it.
.c69f					_VFExists:
.c69f	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.c6a1	29 01		and #$01			and 	#1
.c6a3	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c6a5	d0 28		bne $c6cf			bne 	_VFSingleElement
.c6a7					_VFNextIndex:
.c6a7	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.c6a9	48		pha				pha
.c6aa	a5 25		lda $25				lda 	zVarDataPtr+1
.c6ac	48		pha				pha
.c6ad	a5 26		lda $26				lda 	zVarType
.c6af	48		pha				pha
.c6b0	20 78 bd	jsr $bd78			jsr 	EvaluateInteger 		; calculate the index.
.c6b3	68		pla				pla 							; restore and index.
.c6b4	85 26		sta $26				sta 	zVarType
.c6b6	68		pla				pla
.c6b7	85 25		sta $25				sta 	zVarDataPtr+1
.c6b9	68		pla				pla
.c6ba	85 24		sta $24				sta 	zVarDataPtr
.c6bc	20 1a c8	jsr $c81a			jsr 	ArrayIndexFollow 		; do the index.
.c6bf	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.c6c1	29 01		and #$01			and 	#1
.c6c3	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c6c5	d0 05		bne $c6cc			bne 	_VFArrayDone 			; if so then exit.
.c6c7	20 d7 c3	jsr $c3d7			jsr 	CheckNextComma 			; comma should follow
.c6ca	80 db		bra $c6a7			bra 	_VFNextIndex
.c6cc					_VFArrayDone:
.c6cc	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 		; check closing right bracket.
.c6cf					_VFSingleElement:
.c6cf	60		rts				rts
.c6d0					VariableClear:
.c6d0	48		pha				pha 							; save registers
.c6d1	da		phx				phx
.c6d2	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.c6d4	8a		txa				txa
.c6d5	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.c6d8	e8		inx				inx
.c6d9	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.c6db	d0 f8		bne $c6d5			bne 	_VCLoop
.c6dd	ad 04 03	lda $0304			lda 	endOfProgram
.c6e0	8d 02 03	sta $0302			sta 	VarMemPtr
.c6e3	ad 05 03	lda $0305			lda 	endOfProgram+1
.c6e6	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c6e9	fa		plx				plx 							; restore registers
.c6ea	68		pla				pla
.c6eb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.c6ec					VariableNameError:
.c6ec	20 e0 ae	jsr $aee0			jsr ERR_Handler
>c6ef	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>c6f7	61 62 6c 65 20 4e 61 6d 65 00
.c701					VariableExtract:
.c701	da		phx				phx 							; save X.
.c702	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.c704	8d 95 03	sta $0395			sta 	Var_Type
.c707	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.c70a	ea		nop				nop
.c70b	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c70d	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.c70f	f0 db		beq $c6ec			beq 	VariableNameError
.c711	c9 1b		cmp #$1b			cmp 	#26+1
.c713	b0 d7		bcs $c6ec			bcs 	VariableNameError
.c715	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.c717					_VECopyBuffer:
.c717	e8		inx				inx
.c718	e0 1f		cpx #$1f			cpx 	#31 					; too long
.c71a	f0 d0		beq $c6ec			beq 	VariableNameError
.c71c	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.c71f	18		clc				clc  							; update the hash value for it.
.c720	6d 96 03	adc $0396			adc 	Var_Hash
.c723	8d 96 03	sta $0396			sta 	Var_Hash
.c726	1b		inz				inz
.c727	ea		nop				nop
.c728	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c72a	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.c72c	f0 0e		beq $c73c			beq 	_VECopyEnd
.c72e	30 0c		bmi $c73c			bmi 	_VECopyEnd
.c730	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.c732	90 e3		bcc $c717			bcc 	_VECopyBuffer
.c734	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.c736	90 04		bcc $c73c			bcc 	_VECopyEnd
.c738	c9 3a		cmp #$3a			cmp 	#"9"+1
.c73a	90 db		bcc $c717			bcc 	_VECopyBuffer
.c73c					_VECopyEnd:
.c73c	1b		inz				inz
.c73d	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.c73f	90 04		bcc $c745			bcc 	_VEDefaultRequired
.c741	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.c743	90 0b		bcc $c750			bcc 	_VEHaveType
.c745					_VEDefaultRequired:
.c745	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.c747	f0 04		beq $c74d			beq 	_VESetType 				; default set above.
.c749	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.c74c	3b		dez				dez
.c74d					_VESetType:
.c74d	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.c750					_VEHaveType:
.c750	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.c753	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.c756	09 80		ora #$80			ora 	#$80
.c758	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.c75b	e8		inx				inx 							; offset 3 => length 4.
.c75c	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.c75f	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.c762	38		sec				sec
.c763	e9 b7		sbc #$b7			sbc 	#token_Dollar
.c765	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.c766	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.c767	0a		asl a				asl 	a
.c768	0a		asl a				asl 	a
.c769	8d 98 03	sta $0398			sta 	Var_HashAddress
.c76c	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.c76f	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.c771	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.c772	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.c775	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.c777	8d 98 03	sta $0398			sta 	Var_HashAddress
.c77a	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.c77c	ad 95 03	lda $0395			lda 	Var_Type
.c77f	c9 b9		cmp #$b9			cmp 	#token_Hash
.c781	f0 07		beq $c78a			beq 	_VEHaveSize
.c783	ca		dex				dex
.c784	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.c786	f0 02		beq $c78a			beq 	_VEHaveSize
.c788	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.c78a					_VEHaveSize:
.c78a	8e 99 03	stx $0399			stx 	Var_DataSize
.c78d	fa		plx				plx
.c78e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.c78f					VariableCreate:
.c78f	da		phx				phx
.c790	5a		phy				phy
.c791	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.c794	85 10		sta $10				sta 	zTemp1
.c796	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c799	85 11		sta $11				sta 	zTemp1+1
.c79b	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.c79e	18		clc				clc
.c79f	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.c7a2	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.c7a4	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.c7a7	8d 02 03	sta $0302			sta 	VarMemPtr
.c7aa	90 03		bcc $c7af			bcc 	_VCNoCarry
.c7ac	ee 03 03	inc $0303			inc 	VarMemPtr+1
.c7af					_VCNoCarry:
.c7af	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c7b2	85 12		sta $12				sta 	zTemp2
.c7b4	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c7b6	85 13		sta $13				sta 	zTemp2+1
.c7b8	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.c7ba	b1 12		lda ($12),y			lda 	(zTemp2),y
.c7bc	91 10		sta ($10),y			sta 	(zTemp1),y
.c7be	c8		iny				iny
.c7bf	b1 12		lda ($12),y			lda 	(zTemp2),y
.c7c1	91 10		sta ($10),y			sta 	(zTemp1),y
.c7c3	c8		iny				iny
.c7c4	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.c7c7	91 10		sta ($10),y			sta 	(zTemp1),y
.c7c9	c8		iny				iny
.c7ca	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.c7cc					_VCCopyName:
.c7cc	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.c7cf	91 10		sta ($10),y			sta 	(zTemp1),y
.c7d1	e8		inx				inx
.c7d2	c8		iny				iny
.c7d3	ec 97 03	cpx $0397			cpx 	Var_Length
.c7d6	d0 f4		bne $c7cc			bne 	_VCCopyName
.c7d8	5a		phy				phy 								; save the data offset.
.c7d9	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.c7dc	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.c7de					_VCClearData:
.c7de	91 10		sta ($10),y			sta 	(zTemp1),y
.c7e0	c8		iny				iny
.c7e1	ca		dex				dex
.c7e2	d0 fa		bne $c7de			bne 	_VCClearData
.c7e4	68		pla				pla 								; offset to the data
.c7e5	18		clc				clc
.c7e6	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.c7e8	85 24		sta $24				sta 	zVarDataPtr
.c7ea	a5 11		lda $11				lda 	zTemp1+1
.c7ec	69 00		adc #$00			adc 	#0
.c7ee	85 25		sta $25				sta 	zVarDataPtr+1
.c7f0	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c7f3	85 26		sta $26				sta 	zVarType
.c7f5	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.c7f7	a0 00		ldy #$00			ldy 	#0
.c7f9	91 12		sta ($12),y			sta 	(zTemp2),y
.c7fb	c8		iny				iny
.c7fc	a5 11		lda $11				lda 	zTemp1+1
.c7fe	91 12		sta ($12),y			sta 	(zTemp2),y
.c800	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.c803	29 01		and #$01			and 	#1
.c805	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.c807	d0 0e		bne $c817			bne 	_VCNotArray
.c809	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.c80b	20 b1 c8	jsr $c8b1			jsr 	ArrayCreate
.c80e	5a		phy				phy 								; save YA at zVarDataPtr
.c80f	a0 00		ldy #$00			ldy 	#0
.c811	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c813	c8		iny				iny
.c814	68		pla				pla
.c815	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c817					_VCNotArray:
.c817	7a		ply				ply
.c818	fa		plx				plx
.c819	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.c81a					ArrayIndexFollow:
.c81a	5a		phy				phy
.c81b	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.c81d	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.c81f	48		pha				pha
.c820	c8		iny				iny
.c821	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c823	85 25		sta $25				sta 	zVarDataPtr+1
.c825	68		pla				pla
.c826	85 24		sta $24				sta 	zVarDataPtr
.c828	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.c82a	29 80		and #$80			and 	#$80 						; must be zero.
.c82c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c82e	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c830	d0 59		bne $c88b			bne 	_AIFError
.c832	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.c834	18		clc				clc
.c835	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c837	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c839	c8		iny				iny
.c83a	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c83c	08		php				php 								; clear bit 7 retaining borrow.
.c83d	29 7f		and #$7f			and 	#$7F
.c83f	28		plp				plp
.c840	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c842	90 47		bcc $c88b			bcc 	_AIFError 					; eror if size-current < 0
.c844	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.c846	0a		asl a				asl 	a 							; (e.g. index * 2)
.c847	85 10		sta $10				sta 	zTemp1
.c849	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c84b	2a		rol a				rol 	a
.c84c	85 11		sta $11				sta 	zTemp1+1
.c84e	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.c850	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.c852	30 1d		bmi $c871			bmi 	_AIFCalculate
.c854	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.c856	a5 26		lda $26				lda 	zVarType 					; check that type
.c858	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.c85a	f0 15		beq $c871			beq 	_AIFCalculate
.c85c	06 10		asl $10				asl 	zTemp1			 			; double the index
.c85e	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.c860	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.c862	f0 0d		beq $c871			beq 	_AIFCalculate
.c864	18		clc				clc 								; add the original mantissa in again
.c865	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.c867	65 10		adc $10				adc 	zTemp1
.c869	85 10		sta $10				sta 	zTemp1
.c86b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c86d	65 11		adc $11				adc 	zTemp1+1
.c86f	85 11		sta $11				sta 	zTemp1+1
.c871					_AIFCalculate:
.c871	18		clc				clc 								; add index x 2,4 or 5 to base
.c872	a5 24		lda $24				lda 	zVarDataPtr
.c874	65 10		adc $10				adc 	zTemp1
.c876	85 24		sta $24				sta 	zVarDataPtr
.c878	a5 25		lda $25				lda 	zVarDataPtr+1
.c87a	65 11		adc $11				adc 	zTemp1+1
.c87c	85 25		sta $25				sta 	zVarDataPtr+1
.c87e	18		clc				clc 								; add 2 more for the length prefix.
.c87f	a5 24		lda $24				lda 	zVarDataPtr
.c881	69 02		adc #$02			adc 	#2
.c883	85 24		sta $24				sta 	zVarDataPtr
.c885	90 02		bcc $c889			bcc 	_AIFNoBump
.c887	e6 25		inc $25				inc 	zVarDataPtr+1
.c889					_AIFNoBump:
.c889	7a		ply				ply
.c88a	60		rts				rts
.c88b					_AIFError:
.c88b	20 e0 ae	jsr $aee0			jsr ERR_Handler
>c88e	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c896	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.c89e					ArrayResetDefault:
.c89e	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.c8a0	8d a9 03	sta $03a9			sta 	ArrayDef+0
.c8a3	a9 00		lda #$00			lda 	#0
.c8a5	8d aa 03	sta $03aa			sta 	ArrayDef+1
.c8a8	a9 ff		lda #$ff			lda 	#$FF
.c8aa	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.c8ad	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.c8b0	60		rts				rts
.c8b1					ArrayCreate:
.c8b1	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.c8b4	0a		asl a				asl 	a
.c8b5	85 10		sta $10				sta 	zTemp1
.c8b7	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c8ba	2a		rol a				rol 	a
.c8bb	85 11		sta $11				sta 	zTemp1+1
.c8bd	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.c8c0	10 22		bpl $c8e4			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.c8c2	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.c8c5	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.c8c7	f0 1b		beq $c8e4			beq 	_ACSized
.c8c9	06 10		asl $10				asl 	zTemp1 						; double again
.c8cb	26 11		rol $11				rol 	zTemp1+1
.c8cd	b0 6f		bcs $c93e			bcs 	ArrayIndexError 			; too large.
.c8cf	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.c8d1	f0 11		beq $c8e4			beq 	_ACSized
.c8d3	18		clc				clc 								; add original value x 5 for reals.
.c8d4	a5 10		lda $10				lda 	zTemp1
.c8d6	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.c8d9	85 10		sta $10				sta 	zTemp1
.c8db	a5 11		lda $11				lda 	zTemp1+1
.c8dd	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.c8e0	85 11		sta $11				sta 	zTemp1+1
.c8e2	b0 5a		bcs $c93e			bcs 	ArrayIndexError
.c8e4					_ACSized:
.c8e4	18		clc				clc
.c8e5	a5 10		lda $10				lda 	zTemp1
.c8e7	69 02		adc #$02			adc 	#2
.c8e9	85 10		sta $10				sta 	zTemp1
.c8eb	90 04		bcc $c8f1			bcc 	_ACNoBump
.c8ed	e6 10		inc $10				inc 	zTemp1
.c8ef	f0 4d		beq $c93e			beq 	ArrayIndexError
.c8f1					_ACNoBump:
.c8f1	18		clc				clc
.c8f2	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.c8f5	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.c8f7	85 14		sta $14				sta 	zTemp3
.c8f9	65 10		adc $10				adc 	zTemp1
.c8fb	8d 02 03	sta $0302			sta 	VarMemPtr
.c8fe	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c901	85 13		sta $13				sta 	zTemp2+1
.c903	85 15		sta $15				sta 	zTemp3+1
.c905	65 11		adc $11				adc 	zTemp1+1
.c907	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c90a	85 11		sta $11				sta 	zTemp1+1
.c90c	b0 30		bcs $c93e			bcs 	ArrayIndexError
.c90e	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.c910					_ACClear:
.c910	98		tya				tya
.c911	91 12		sta ($12),y			sta 	(zTemp2),y
.c913	e6 12		inc $12				inc 	zTemp2
.c915	d0 02		bne $c919			bne 	_ACCBump
.c917	e6 13		inc $13				inc 	zTemp2+1
.c919					_ACCBump:
.c919	a5 12		lda $12				lda 	zTemp2
.c91b	cd 02 03	cmp $0302			cmp 	VarMemPtr
.c91e	d0 f0		bne $c910			bne 	_ACClear
.c920	a5 13		lda $13				lda 	zTemp2+1
.c922	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.c925	d0 e9		bne $c910			bne 	_ACClear
.c927	a0 00		ldy #$00			ldy 	#0
.c929	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.c92c	91 14		sta ($14),y			sta 	(zTemp3),y
.c92e	c8		iny				iny
.c92f	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c932	91 14		sta ($14),y			sta 	(zTemp3),y
.c934	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.c937	10 18		bpl $c951			bpl 	ACCFillRecursive
.c939	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.c93b	a5 14		lda $14				lda 	zTemp3
.c93d	60		rts				rts
.c93e					ArrayIndexError:
.c93e	20 e0 ae	jsr $aee0			jsr ERR_Handler
>c941	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c949	79 20 69 6e 64 65 78 00
.c951					ACCFillRecursive:
.c951	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.c953	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.c955	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.c957	c8		iny				iny
.c958	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.c95a	09 80		ora #$80			ora 	#$80 						; an array of pointers
.c95c	91 14		sta ($14),y			sta 	(zTemp3),y
.c95e	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.c960	48		pha				pha
.c961	a5 15		lda $15				lda 	zTemp3+1
.c963	48		pha				pha
.c964					_ACCFillLoop:
.c964	18		clc				clc
.c965	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.c967	69 02		adc #$02			adc 	#2
.c969	85 14		sta $14				sta 	zTemp3
.c96b	90 02		bcc $c96f			bcc 	_ACCSkip2
.c96d	e6 15		inc $15				inc 	zTemp3+1
.c96f					_ACCSkip2:
.c96f	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.c971	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.c973	c8		iny				iny
.c974	11 14		ora ($14),y			ora 	(zTemp3),y
.c976	d0 21		bne $c999			bne 	_ACCExit
.c978	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.c97a	48		pha				pha
.c97b	a5 15		lda $15				lda 	zTemp3+1
.c97d	48		pha				pha
.c97e	e8		inx				inx
.c97f	e8		inx				inx
.c980	20 b1 c8	jsr $c8b1			jsr 	ArrayCreate 				; create array recursively.
.c983	ca		dex				dex
.c984	ca		dex				dex
.c985	85 12		sta $12				sta 	zTemp2 						; save A
.c987	68		pla				pla
.c988	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.c98a	68		pla				pla
.c98b	85 14		sta $14				sta 	zTemp3
.c98d	98		tya				tya 								; write high bye from Y
.c98e	a0 01		ldy #$01			ldy 	#1
.c990	91 14		sta ($14),y			sta 	(zTemp3),y
.c992	88		dey				dey 								; write low byte out.
.c993	a5 12		lda $12				lda 	zTemp2
.c995	91 14		sta ($14),y			sta 	(zTemp3),y
.c997	80 cb		bra $c964			bra 	_ACCFillLoop 				; and try again.
.c999					_ACCExit:
.c999	7a		ply				ply 								; restore the original address
.c99a	68		pla				pla
.c99b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.c99c					VariableLocate:
.c99c	da		phx				phx
.c99d	5a		phy				phy
.c99e	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c9a1	85 12		sta $12				sta 	zTemp2 						; points to first address.
.c9a3	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c9a5	85 13		sta $13				sta 	zTemp2+1
.c9a7	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.c9a9	b1 12		lda ($12),y			lda 	(zTemp2),y
.c9ab	aa		tax				tax
.c9ac	c8		iny				iny
.c9ad	b1 12		lda ($12),y			lda 	(zTemp2),y
.c9af	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c9b1	86 12		stx $12				stx 	zTemp2
.c9b3	05 12		ora $12				ora 	zTemp2 						; got zero
.c9b5	18		clc				clc
.c9b6	f0 25		beq $c9dd			beq 	_VLExit 					; if so, then fail as end of chain.
.c9b8	c8		iny				iny 								; point to hash (offset + 2)
.c9b9	b1 12		lda ($12),y			lda 	(zTemp2),y
.c9bb	cd 96 03	cmp $0396			cmp 	Var_Hash
.c9be	d0 e7		bne $c9a7			bne 	_VLNext 					; try next if different.
.c9c0					_VLCompare:
.c9c0	c8		iny				iny 								; next character
.c9c1	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c9c3	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c9c6	d0 df		bne $c9a7			bne 	_VLNext 					; fail if different, try next.
.c9c8	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c9c9	90 f5		bcc $c9c0			bcc 	_VLCompare
.c9cb	98		tya				tya
.c9cc	38		sec				sec 								; add 1 as Y points to last character
.c9cd	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c9cf	85 24		sta $24				sta 	zVarDataPtr
.c9d1	a5 13		lda $13				lda 	zTemp2+1
.c9d3	69 00		adc #$00			adc 	#0
.c9d5	85 25		sta $25				sta 	zVarDataPtr+1
.c9d7	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c9da	85 26		sta $26				sta 	zVarType
.c9dc	38		sec				sec 								; return CS
.c9dd	7a		ply		_VLExit:ply
.c9de	fa		plx				plx
.c9df	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c9e0					VariableGet:
.c9e0	5a		phy				phy
.c9e1	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c9e3	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c9e5	95 80		sta $80,x			sta 	XS_Mantissa,x
.c9e7	c8		iny				iny
.c9e8	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c9ea	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c9ec	c8		iny				iny
.c9ed	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.c9ef	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c9f1	f0 2c		beq $ca1f			beq 	_VGString
.c9f3	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c9f5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c9f7	c8		iny				iny
.c9f8	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c9fa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c9fc	c8		iny				iny
.c9fd	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c9ff	95 85		sta $85,x			sta 	XS_Type,x
.ca01	a5 26		lda $26				lda 	zVarType
.ca03	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.ca05	f0 28		beq $ca2f			beq 	_VGExit
.ca07	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.ca09	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.ca0b	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.ca0d	95 84		sta $84,x			sta 	XS_Exponent,x
.ca0f	f0 1e		beq $ca2f			beq 	_VGExit 					; if exponent is zero ... it's zero.
.ca11	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.ca13	48		pha				pha
.ca14	29 80		and #$80			and 	#$80
.ca16	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.ca18	68		pla				pla
.ca19	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.ca1b	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.ca1d	80 10		bra $ca2f			bra 	_VGExit
.ca1f					_VGString:
.ca1f	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.ca21	95 85		sta $85,x			sta 	XS_Type,x
.ca23	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.ca25	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.ca27	d0 06		bne $ca2f			bne 	_VGExit 					; if not, exit.
.ca29	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.ca2b	a9 27		lda #$27			lda 	#zNullString
.ca2d	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.ca2f					_VGExit:
.ca2f	7a		ply				ply
.ca30	60		rts				rts
.ca31					VariableSet:
.ca31	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.ca33	29 02		and #$02			and 	#2 							; if so, it has to be
.ca35	d0 4b		bne $ca82			bne 	_VSString
.ca37	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.ca39	c9 b7		cmp #$b7			cmp 	#token_Dollar
.ca3b	f0 42		beq $ca7f			beq 	_VSBadType
.ca3d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.ca3f	f0 05		beq $ca46			beq 	_VSMakeInt
.ca41	20 a5 cf	jsr $cfa5			jsr 	FPUToFloat
.ca44	80 03		bra $ca49			bra 	_VSCopy
.ca46					_VSMakeInt:
.ca46	20 f1 cf	jsr $cff1			jsr 	FPUToInteger
.ca49					_VSCopy:
.ca49	5a		phy				phy
.ca4a	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.ca4c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ca4e	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca50	c8		iny				iny
.ca51	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ca53	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca55	c8		iny				iny
.ca56	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ca58	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca5a	c8		iny				iny
.ca5b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ca5d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca5f	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.ca61	c9 bb		cmp #$bb			cmp 	#token_Percent
.ca63	f0 18		beq $ca7d			beq 	_VSExit
.ca65	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.ca67	0a		asl a				asl 	a
.ca68	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.ca6a	08		php				php
.ca6b	0a		asl a				asl 	a
.ca6c	28		plp				plp
.ca6d	6a		ror a				ror 	a
.ca6e	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca70	c8		iny				iny
.ca71	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.ca73	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca75	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.ca77	50 04		bvc $ca7d			bvc 	_VSExit
.ca79	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.ca7b	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca7d					_VSExit:
.ca7d	7a		ply				ply
.ca7e	60		rts				rts
.ca7f					_VSBadType:
.ca7f	4c c1 ae	jmp $aec1			jmp 	TypeError
.ca82					_VSString:
.ca82	a5 26		lda $26				lda 	zVarType 					; type must be $
.ca84	c9 b7		cmp #$b7			cmp 	#token_Dollar
.ca86	d0 f7		bne $ca7f			bne 	_VSBadType
.ca88	da		phx				phx
.ca89	5a		phy				phy
.ca8a	20 e0 c3	jsr $c3e0			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.ca8d	a0 01		ldy #$01			ldy 	#1 							; save high byte
.ca8f	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca91	88		dey				dey 								; save low byte
.ca92	8a		txa				txa
.ca93	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca95	7a		ply				ply 								; and exit.
.ca96	fa		plx				plx
.ca97	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.ca98					MulInteger32:
.ca98	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.ca9a	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.ca9c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ca9e	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.caa0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.caa2	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.caa4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.caa6	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.caa8	a9 00		lda #$00			lda 	#0
.caaa	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.caac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.caae	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cab0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cab2					_BFMMultiply:
.cab2	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.cab4	29 01		and #$01			and 	#1
.cab6	f0 03		beq $cabb			beq 	_BFMNoAdd
.cab8	20 10 bf	jsr $bf10			jsr 	AddInteger32 					; co-opt this code
.cabb					_BFMNoAdd:
.cabb	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.cabd	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.cabf	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.cac1	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.cac3	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.cac5	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.cac7	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.cac9	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.cacb	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.cacd	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.cacf	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.cad1	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.cad3	d0 dd		bne $cab2			bne 	_BFMMultiply
.cad5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.cad6					DivInteger32:
.cad6	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.cad8	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.cada	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.cadc	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.cade	d0 14		bne $caf4			bne 	_BFDOkay
.cae0	20 e0 ae	jsr $aee0			jsr ERR_Handler
>cae3	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>caeb	20 62 79 20 5a 65 72 6f 00
.caf4					_BFDOkay:
.caf4	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.caf6	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.caf8	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.cafa	85 1e		sta $1e				sta 	zLTemp1+2
.cafc	85 1f		sta $1f				sta 	zLTemp1+3
.cafe	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.cb01	20 58 cb	jsr $cb58			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.cb04	da		phx				phx
.cb05	e8		inx				inx
.cb06	e8		inx				inx
.cb07	e8		inx				inx
.cb08	e8		inx				inx
.cb09	e8		inx				inx
.cb0a	e8		inx				inx
.cb0b	20 58 cb	jsr $cb58			jsr 	CheckIntegerNegate
.cb0e	fa		plx				plx
.cb0f	5a		phy				phy 								; Y is the counter
.cb10	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.cb12					_BFDLoop:
.cb12	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.cb14	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.cb16	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.cb18	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.cb1a	26 1c		rol $1c				rol 	zLTemp1
.cb1c	26 1d		rol $1d				rol 	zLTemp1+1
.cb1e	26 1e		rol $1e				rol 	zLTemp1+2
.cb20	26 1f		rol $1f				rol 	zLTemp1+3
.cb22	38		sec				sec
.cb23	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.cb25	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.cb27	48		pha				pha
.cb28	a5 1d		lda $1d				lda 	zLTemp1+1
.cb2a	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cb2c	48		pha				pha
.cb2d	a5 1e		lda $1e				lda 	zLTemp1+2
.cb2f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.cb31	48		pha				pha
.cb32	a5 1f		lda $1f				lda 	zLTemp1+3
.cb34	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.cb36	90 13		bcc $cb4b			bcc 	_BFDNoAdd
.cb38	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.cb3a	68		pla				pla
.cb3b	85 1e		sta $1e				sta 	zLTemp1+2
.cb3d	68		pla				pla
.cb3e	85 1d		sta $1d				sta 	zLTemp1+1
.cb40	68		pla				pla
.cb41	85 1c		sta $1c				sta 	zLTemp1+0
.cb43	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.cb45	09 01		ora #$01			ora 	#1
.cb47	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cb49	80 03		bra $cb4e			bra 	_BFDNext
.cb4b					_BFDNoAdd:
.cb4b	68		pla				pla 								; Throw away the intermediate calculations
.cb4c	68		pla				pla
.cb4d	68		pla				pla
.cb4e					_BFDNext:
.cb4e	88		dey				dey
.cb4f	d0 c1		bne $cb12			bne 	_BFDLoop
.cb51	7a		ply				ply 								; restore Y
.cb52	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.cb55	b0 06		bcs $cb5d			bcs		IntegerNegateAlways 		; negate the result
.cb57	60		rts				rts
.cb58					CheckIntegerNegate:
.cb58	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.cb5a	30 01		bmi $cb5d			bmi 	IntegerNegateAlways 		; if so negate it
.cb5c	60		rts				rts
.cb5d					IntegerNegateAlways:
.cb5d	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.cb60	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.cb61	a9 00		lda #$00			lda 	#0
.cb63	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.cb65	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cb67	a9 00		lda #$00			lda 	#0
.cb69	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.cb6b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cb6d	a9 00		lda #$00			lda 	#0
.cb6f	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.cb71	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cb73	a9 00		lda #$00			lda 	#0
.cb75	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.cb77	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cb79	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cb7a					INTToString:
.cb7a	48		pha				pha
.cb7b	5a		phy				phy
.cb7c	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.cb7e	10 08		bpl $cb88			bpl 		_ITSNotMinus
.cb80	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cb82	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter 		; .... if it is minus.
.cb85	20 5d cb	jsr $cb5d			jsr 		IntegerNegateAlways 	; negate the number.
.cb88					_ITSNotMinus:
.cb88	a9 00		lda #$00			lda 		#0
.cb8a	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.cb8d	8a		txa				txa 								; use Y for the mantissa index.
.cb8e	a8		tay				tay
.cb8f	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.cb91					_ITSNextSubtractor:
.cb91	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cb93	8d 9b 03	sta $039b			sta 		NumConvCount
.cb96					_ITSSubtract:
.cb96	38		sec				sec
.cb97	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.cb9a	fd f4 cb	sbc $cbf4,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.cb9d	48		pha				pha
.cb9e	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.cba1	fd f5 cb	sbc $cbf5,x			sbc 		_ITSSubtractors+1,x
.cba4	48		pha				pha
.cba5	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.cba8	fd f6 cb	sbc $cbf6,x			sbc 		_ITSSubtractors+2,x
.cbab	48		pha				pha
.cbac	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.cbaf	fd f7 cb	sbc $cbf7,x			sbc 		_ITSSubtractors+3,x
.cbb2	90 14		bcc $cbc8			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.cbb4	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack as it's okay
.cbb7	68		pla				pla
.cbb8	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.cbbb	68		pla				pla
.cbbc	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.cbbf	68		pla				pla
.cbc0	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.cbc3	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.cbc6	80 ce		bra $cb96			bra 		_ITSSubtract 			; go round again.
.cbc8					_ITSCantSubtract:
.cbc8	68		pla				pla 								; throw away interim answers
.cbc9	68		pla				pla 								; (the subtraction that failed)
.cbca	68		pla				pla
.cbcb	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.cbce	c9 30		cmp #$30			cmp 		#"0"
.cbd0	d0 05		bne $cbd7			bne 		_ITSOutputDigit
.cbd2	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cbd5	10 09		bpl $cbe0			bpl	 		_ITSGoNextSubtractor
.cbd7					_ITSOutputDigit:
.cbd7	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.cbda	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.cbdd	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter 		; output it.
.cbe0					_ITSGoNextSubtractor:
.cbe0	e8		inx				inx 								; next dword in subtractor table.
.cbe1	e8		inx				inx
.cbe2	e8		inx				inx
.cbe3	e8		inx				inx
.cbe4	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.cbe6	d0 a9		bne $cb91			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cbe8	98		tya				tya 								; X is back as the mantissa index
.cbe9	aa		tax				tax
.cbea	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cbec	09 30		ora #$30			ora 		#"0"
.cbee	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter
.cbf1	7a		ply				ply 								; and exit
.cbf2	68		pla				pla
.cbf3	60		rts				rts
.cbf4					_ITSSubtractors:
>cbf4	00 ca 9a 3b					.dword 		1000000000
>cbf8	00 e1 f5 05					.dword 		100000000
>cbfc	80 96 98 00					.dword 		10000000
>cc00	40 42 0f 00					.dword 		1000000
>cc04	a0 86 01 00					.dword 		100000
>cc08	10 27 00 00					.dword 		10000
>cc0c	e8 03 00 00					.dword 		1000
>cc10	64 00 00 00					.dword 		100
>cc14	0a 00 00 00					.dword 		10
.cc18					_ITSSubtractorsEnd:
.cc18					ITSOutputCharacter:
.cc18	48		pha				pha
.cc19	da		phx				phx
.cc1a	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.cc1d	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.cc20	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cc22	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.cc25	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.cc28	fa		plx				plx
.cc29	68		pla				pla
.cc2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cc2b					IntFromString:
.cc2b	a0 00		ldy #$00			ldy 	#0 							; from (zGenPtr)
.cc2d					IntFromStringY:
.cc2d	a9 00		lda #$00			lda 	#0
.cc2f	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.cc32	48		pha				pha
.cc33	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.cc35	95 80		sta $80,x			sta 	XS_Mantissa,x 				; (the number converted goes here)
.cc37	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cc39	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cc3b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cc3d	a9 01		lda #$01			lda 	#1 							; sete type to integer
.cc3f	95 85		sta $85,x			sta 	XS_Type,x
.cc41					_IFSLoop:
.cc41	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.cc43	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.cc45	90 4e		bcc $cc95			bcc 	_IFSExit
.cc47	c9 3a		cmp #$3a			cmp 	#"9"+1
.cc49	b0 4a		bcs $cc95			bcs 	_IFSExit
.cc4b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cc4d	c9 0c		cmp #$0c			cmp 	#12 						; (approximately)
.cc4f	b0 4e		bcs $cc9f			bcs 	_IFSOverflow
.cc51	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cc53	48		pha				pha
.cc54	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cc56	48		pha				pha
.cc57	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cc59	48		pha				pha
.cc5a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.cc5c	48		pha				pha
.cc5d	20 b4 cc	jsr $ccb4			jsr 	IFSX1ShiftLeft 				; double
.cc60	20 b4 cc	jsr $ccb4			jsr 	IFSX1ShiftLeft 				; x 4
.cc63	18		clc				clc 								; add saved value x 5
.cc64	68		pla				pla
.cc65	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.cc67	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cc69	68		pla				pla
.cc6a	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.cc6c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cc6e	68		pla				pla
.cc6f	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.cc71	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cc73	68		pla				pla
.cc74	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.cc76	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cc78	20 b4 cc	jsr $ccb4			jsr 	IFSX1ShiftLeft 				; x 10
.cc7b	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.cc7e	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.cc80	29 0f		and #$0f			and 	#15
.cc82	c8		iny				iny
.cc83	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.cc85	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cc87	90 b8		bcc $cc41			bcc 	_IFSLoop
.cc89	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cc8b	d0 b4		bne $cc41			bne 	_IFSLoop
.cc8d	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.cc8f	d0 b0		bne $cc41			bne 	_IFSLoop
.cc91	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.cc93	80 ac		bra $cc41			bra 	_IFSLoop
.cc95					_IFSExit:
.cc95	98		tya				tya 								; get offset
.cc96					_IFSOkay:
.cc96	38		sec				sec
.cc97	ad 9c 03	lda $039c			lda 	ExpTemp 					; if no digits processed, no integer here.
.cc9a	f0 01		beq $cc9d			beq 	_IFSSkipFail
.cc9c	18		clc				clc
.cc9d					_IFSSkipFail:
.cc9d	68		pla				pla 								; and exit.
.cc9e	60		rts				rts
.cc9f					_IFSOverflow:
.cc9f	20 e0 ae	jsr $aee0			jsr 	ERR_Handler
>cca2	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>ccaa	20 6f 76 65 72 66 6c 6f 77 00
.ccb4					IFSX1ShiftLeft:
.ccb4	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.ccb6	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.ccb8	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.ccba	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.ccbc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.ccbd					FPSubtract:
.ccbd	48		pha				pha
.ccbe	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.ccc0	49 80		eor #$80			eor 	#$80
.ccc2	95 8b		sta $8b,x			sta 	XS2_Type,x
.ccc4	68		pla				pla 								; --- and fall through ---
.ccc5					FPAdd:
.ccc5	48		pha				pha
.ccc6	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.ccc8	d0 05		bne $cccf			bne 	_FPA_NegativeLHS
.ccca	20 e6 cc	jsr $cce6			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cccd	68		pla				pla
.ccce	60		rts				rts
.cccf					_FPA_NegativeLHS:
.cccf	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.ccd1	49 80		eor #$80			eor 	#$80
.ccd3	95 85		sta $85,x			sta 	XS_Type,x
.ccd5	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.ccd7	49 80		eor #$80			eor 	#$80
.ccd9	95 8b		sta $8b,x			sta 	XS2_Type,x
.ccdb	20 e6 cc	jsr $cce6			jsr 	FPAdd_Worker 				; do the add calculation.
.ccde	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.cce0	49 80		eor #$80			eor 	#$80
.cce2	95 85		sta $85,x			sta 	XS_Type,x
.cce4	68		pla				pla
.cce5	60		rts				rts
.cce6					FPAdd_Worker:
.cce6	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cce8	70 07		bvs $ccf1			bvs 	_FPAWExit 					; no change.
.ccea	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.ccec	50 07		bvc $ccf5			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.ccee	20 63 cf	jsr $cf63			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.ccf1					_FPAWExit:
.ccf1	20 d2 cf	jsr $cfd2			jsr 	FPUNormalise 				; normalise the result.
.ccf4	60		rts				rts
.ccf5					_FPAWMakeSame:
.ccf5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.ccf7	38		sec				sec
.ccf8	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.ccfa	f0 16		beq $cd12			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.ccfc	da		phx				phx 								; save X
.ccfd	90 06		bcc $cd05			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.ccff	e8		inx				inx
.cd00	e8		inx				inx
.cd01	e8		inx				inx
.cd02	e8		inx				inx
.cd03	e8		inx				inx
.cd04	e8		inx				inx
.cd05					_FPAWShiftA:
.cd05	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cd07	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.cd09	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cd0b	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cd0d	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cd0f	fa		plx				plx 								; restore original X
.cd10	80 e3		bra $ccf5			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cd12					_FPAW_DoArithmetic:
.cd12	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cd14	30 28		bmi $cd3e			bmi 	_FPAW_BNegative
.cd16	18		clc				clc
.cd17	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.cd19	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.cd1b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cd1d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cd1f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.cd21	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cd23	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cd25	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.cd27	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cd29	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cd2b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.cd2d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cd2f	90 c0		bcc $ccf1			bcc 	_FPAWExit 					; no carry.
.cd31	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cd33	38		sec				sec
.cd34	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.cd36	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cd38	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cd3a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cd3c	80 b3		bra $ccf1			bra 	_FPAWExit
.cd3e					_FPAW_BNegative:
.cd3e	38		sec				sec
.cd3f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.cd41	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.cd43	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cd45	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cd47	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cd49	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cd4b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cd4d	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.cd4f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cd51	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cd53	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.cd55	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cd57	b0 09		bcs $cd62			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.cd59	20 89 cf	jsr $cf89			jsr 	FPUNegateInteger			; negate the mantissa
.cd5c	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.cd5e	49 80		eor #$80			eor 	#$80
.cd60	95 85		sta $85,x			sta 	XS_Type,x
.cd62					_FPAWGoExit:
.cd62	4c f1 cc	jmp $ccf1			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cd65					FPD_IsDivZero:
.cd65	20 e0 ae	jsr $aee0			jsr ERR_Handler
>cd68	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>cd70	20 62 79 20 7a 65 72 6f 00
.cd79					FPDivide:
.cd79	48		pha				pha
.cd7a	5a		phy				phy
.cd7b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.cd7d	70 e6		bvs $cd65			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cd7f	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cd81	f0 03		beq $cd86			beq 	_FPDCalculateExp
.cd83					_FPD_Exit:
.cd83	7a		ply				ply
.cd84	68		pla				pla
.cd85	60		rts				rts
.cd86					_FPDCalculateExp:
.cd86	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cd88	49 ff		eor #$ff			eor 	#$FF
.cd8a	1a		inc a				inc 	a
.cd8b	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.cd8d	20 5d ce	jsr $ce5d			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cd90	18		clc				clc 	 							; add 1 to the resulting exponent
.cd91	69 01		adc #$01			adc 	#1
.cd93	b0 54		bcs $cde9			bcs 	_FPD_Overflow 				; which can overflow.
.cd95	95 84		sta $84,x			sta 	XS_Exponent,x
.cd97	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cd99	85 1c		sta $1c				sta 	zLTemp1+0
.cd9b	85 1d		sta $1d				sta 	zLTemp1+1
.cd9d	85 1e		sta $1e				sta 	zLTemp1+2
.cd9f	85 1f		sta $1f				sta 	zLTemp1+3
.cda1	a0 20		ldy #$20			ldy 	#32 						; times round.
.cda3					_FPD_Loop:
.cda3	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cda4	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.cda6	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.cda8	48		pha				pha
.cda9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cdab	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cdad	48		pha				pha
.cdae	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cdb0	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.cdb2	48		pha				pha
.cdb3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cdb5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.cdb7	90 13		bcc $cdcc			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cdb9	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cdbb	68		pla				pla
.cdbc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cdbe	68		pla				pla
.cdbf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cdc1	68		pla				pla
.cdc2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cdc4	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.cdc6	09 80		ora #$80			ora 	#$80
.cdc8	85 1f		sta $1f				sta 	zLTemp1+3
.cdca	80 03		bra $cdcf			bra 	_FPD_Rotates
.cdcc					_FPD_NoSubtract:
.cdcc	68		pla				pla 								; throw away unwanted results
.cdcd	68		pla				pla
.cdce	68		pla				pla
.cdcf					_FPD_Rotates:
.cdcf	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.cdd1	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.cdd3	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.cdd5	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.cdd7	06 1c		asl $1c				asl 	0+zLTemp1
.cdd9	26 1d		rol $1d				rol 	1+zLTemp1
.cddb	26 1e		rol $1e				rol 	2+zLTemp1
.cddd	26 1f		rol $1f				rol 	3+zLTemp1
.cddf	90 02		bcc $cde3			bcc 	_FPD_NoCarry
.cde1	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.cde3					_FPD_NoCarry:
.cde3	88		dey				dey 								; do 32 times
.cde4	d0 bd		bne $cda3			bne 	_FPD_Loop
.cde6	4c 41 ce	jmp $ce41			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cde9					_FPD_Overflow:
.cde9	4c 2f d0	jmp $d02f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cdec					FPMultiply:
.cdec	48		pha				pha
.cded	5a		phy				phy
.cdee	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cdf0	70 07		bvs $cdf9			bvs 	_FPM_Exit
.cdf2	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cdf4	50 06		bvc $cdfc			bvc 	_FPM_CalcExponent
.cdf6	20 63 cf	jsr $cf63			jsr 	FPUCopyX2ToX1
.cdf9					_FPM_Exit:
.cdf9	7a		ply				ply
.cdfa	68		pla				pla
.cdfb	60		rts				rts
.cdfc					_FPM_CalcExponent:
.cdfc	18		clc				clc
.cdfd	20 5d ce	jsr $ce5d			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.ce00	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.ce02	a9 00		lda #$00			lda 	#0
.ce04	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.ce06	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.ce08	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.ce0a	85 1f		sta $1f				sta 	zLTemp1+3
.ce0c	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.ce0e					_FPM_Loop:
.ce0e	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.ce10	29 01		and #$01			and 	#1
.ce12	18		clc				clc 								; clear carry for the long rotate.
.ce13	f0 19		beq $ce2e			beq 	_FPM_NoAddition
.ce15	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.ce16	a5 1c		lda $1c				lda 	zLTemp1+0
.ce18	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.ce1a	85 1c		sta $1c				sta 	zLTemp1+0
.ce1c	a5 1d		lda $1d				lda 	zLTemp1+1
.ce1e	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.ce20	85 1d		sta $1d				sta 	zLTemp1+1
.ce22	a5 1e		lda $1e				lda 	zLTemp1+2
.ce24	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.ce26	85 1e		sta $1e				sta 	zLTemp1+2
.ce28	a5 1f		lda $1f				lda 	zLTemp1+3
.ce2a	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.ce2c	85 1f		sta $1f				sta 	zLTemp1+3
.ce2e					_FPM_NoAddition:
.ce2e	66 1f		ror $1f				ror 	3+zLTemp1
.ce30	66 1e		ror $1e				ror 	2+zLTemp1
.ce32	66 1d		ror $1d				ror 	1+zLTemp1
.ce34	66 1c		ror $1c				ror 	0+zLTemp1
.ce36	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.ce38	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.ce3a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.ce3c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.ce3e	88		dey				dey
.ce3f	d0 cd		bne $ce0e			bne 	_FPM_Loop 					; do this 32 times.
.ce41					FPM_CopySignNormalize:
.ce41	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.ce43	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.ce45	a5 1d		lda $1d				lda 	zLTemp1+1
.ce47	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ce49	a5 1e		lda $1e				lda 	zLTemp1+2
.ce4b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ce4d	a5 1f		lda $1f				lda 	zLTemp1+3
.ce4f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ce51	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.ce53	55 8b		eor $8b,x			eor 	XS2_Type,x
.ce55	95 85		sta $85,x			sta 	XS_Type,x
.ce57	20 d2 cf	jsr $cfd2			jsr 	FPUNormalise 				; normalise and exit.
.ce5a	7a		ply				ply
.ce5b	68		pla				pla
.ce5c	60		rts				rts
.ce5d					FPCalculateExponent:
.ce5d	18		clc				clc
.ce5e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.ce60	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.ce62	b0 08		bcs $ce6c			bcs 	_FPCECarry 					; carry out ?
.ce64	10 03		bpl $ce69			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.ce66	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.ce68	60		rts				rts
.ce69					_FPCEExpZero:
.ce69	a9 00		lda #$00			lda 	#0
.ce6b	60		rts				rts
.ce6c					_FPCECarry:
.ce6c	30 03		bmi $ce71			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.ce6e	09 80		ora #$80			ora 	#$80 						; put in right range
.ce70	60		rts				rts
.ce71					_FPCEOverflow:
.ce71	4c 2f d0	jmp $d02f			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.ce74					FPFractionalPart:
.ce74	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.ce76	38		sec				sec 								; this flag tells us to keep the fractional part
.ce77	30 0d		bmi $ce86			bmi 	FPGetPart
.ce79	60		rts				rts
.ce7a					FPIntegerPart:
.ce7a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.ce7c	18		clc				clc 								; this flag says keep the integer part.
.ce7d	30 07		bmi $ce86			bmi 	FPGetPart 					; -ve exponents are 0..127
.ce7f	48		pha				pha
.ce80	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.ce82	95 85		sta $85,x			sta 	XS_Type,x
.ce84	68		pla				pla
.ce85	60		rts				rts
.ce86					FPGetPart:
.ce86	48		pha				pha
.ce87	5a		phy				phy 								; save Y
.ce88	08		php				php 								; save action
.ce89	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.ce8b	70 59		bvs $cee6			bvs 	_FPGP_Exit 					; then do nothing.
.ce8d	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.ce8f	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.ce91	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.ce93	85 1e		sta $1e				sta 	zLTemp1+2
.ce95	85 1f		sta $1f				sta 	zLTemp1+3
.ce97	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.ce99	38		sec				sec
.ce9a	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.ce9c	f0 12		beq $ceb0			beq 	_FPGP_NoShift 				; ... if any
.ce9e	c9 20		cmp #$20			cmp 	#32
.cea0	90 02		bcc $cea4			bcc 	_FPGP_NotMax
.cea2	a9 20		lda #$20			lda 	#32 						; max of 32.
.cea4					_FPGP_NotMax:
.cea4	a8		tay				tay 								; Y is the mask shift count.
.cea5					_FPGP_ShiftMask:
.cea5	46 1f		lsr $1f				lsr 	3+zLTemp1
.cea7	66 1e		ror $1e				ror 	2+zLTemp1
.cea9	66 1d		ror $1d				ror 	1+zLTemp1
.ceab	66 1c		ror $1c				ror 	0+zLTemp1
.cead	88		dey				dey
.ceae	d0 f5		bne $cea5			bne 	_FPGP_ShiftMask
.ceb0					_FPGP_NoShift:
.ceb0	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.ceb2	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.ceb5					_FPGP_MaskLoop:
.ceb5	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.ceb8	28		plp				plp 								; if CC we keep the top part, so we
.ceb9	08		php				php		 							; flip the mask.
.ceba	b0 02		bcs $cebe			bcs		_FPGP_NoFlip
.cebc	49 ff		eor #$ff			eor 	#$FF
.cebe					_FPGP_NoFlip:
.cebe	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.cec0	95 80		sta $80,x			sta 	XS_Mantissa,x
.cec2	e8		inx				inx
.cec3	c8		iny				iny
.cec4	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.cec6	d0 ed		bne $ceb5			bne 	_FPGP_MaskLoop
.cec8	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.cecb	28		plp				plp
.cecc	08		php				php 								; get action flag on the stack
.cecd	90 04		bcc $ced3			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.cecf	a9 00		lda #$00			lda 	#0
.ced1	95 85		sta $85,x			sta 	XS_Type,x
.ced3					_FPGP_NotFractional:
.ced3	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.ced5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.ced7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ced9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.cedb	f0 05		beq $cee2			beq 	_FPGP_Zero 					; if zero, return zero
.cedd	20 d2 cf	jsr $cfd2			jsr 	FPUNormalise
.cee0	80 04		bra $cee6			bra 	_FPGP_Exit 					; and exit
.cee2					_FPGP_Zero:
.cee2	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cee4	95 85		sta $85,x			sta 	XS_Type,x
.cee6					_FPGP_Exit:
.cee6	68		pla				pla 								; throw saved action flag.
.cee7	7a		ply				ply
.cee8	68		pla				pla
.cee9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.ceea					FPCompare:
.ceea	20 2b cf	jsr $cf2b			jsr 	FPFastCompare 				; fast compare try first
.ceed	b0 3b		bcs $cf2a			bcs 	_FPCExit 					; that worked.
.ceef	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.cef1	48		pha				pha
.cef2	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.cef4	48		pha				pha
.cef5	20 bd cc	jsr $ccbd			jsr 	FPSubtract 					; calculate X1-X2
.cef8	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.cefa	70 2a		bvs $cf26			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exponents
.cefc	68		pla				pla
.cefd	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.cf00	68		pla				pla
.cf01	38		sec				sec
.cf02	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.cf05	70 14		bvs $cf1b			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cf07	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cf08	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cf0a	b0 0f		bcs $cf1b			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cf0c	38		sec				sec
.cf0d	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.cf10	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.cf12	b0 02		bcs $cf16			bcs 	_FPCNotRange 				; keep in range.
.cf14	a9 01		lda #$01			lda 	#1
.cf16					_FPCNotRange:
.cf16	38		sec				sec
.cf17	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cf19	b0 0d		bcs $cf28			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cf1b					_FPCNotEqual:
.cf1b	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cf1d	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cf1f	f0 02		beq $cf23			beq 	_FPCNE2
.cf21	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cf23	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cf24	80 04		bra $cf2a			bra 	_FPCExit
.cf26					_FPCPullZero:
.cf26	68		pla				pla 								; throw saved exponents
.cf27	68		pla				pla
.cf28					_FPCZero:
.cf28	a9 00		lda #$00			lda 	#0 							; and return zero
.cf2a					_FPCExit:
.cf2a	60		rts				rts
.cf2b					FPFastCompare:
.cf2b	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.cf2d	70 23		bvs $cf52			bvs 	_FPFLeftZero 				; return invert sign of n2 (0-n2)
.cf2f	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero ?
.cf31	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of n1 (n1-0)
.cf33	70 25		bvs $cf5a			bvs 	_FPFSignBit
.cf35	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.cf37	0a		asl a				asl 	a 							; put in CS if different.
.cf38	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.cf3a	b0 1e		bcs $cf5a			bcs 	_FPFSignBit
.cf3c	38		sec				sec 								; same sign and not-zero. compare exponents
.cf3d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.cf3f	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.cf41	f0 09		beq $cf4c			beq 	_FPNoFastCompare
.cf43	6a		ror a				ror 	a 							; put carry into bit 7.
.cf44	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.cf46	30 02		bmi $cf4a			bmi		_FPFCNotMinus
.cf48	49 80		eor #$80			eor 	#$80
.cf4a					_FPFCNotMinus:
.cf4a	80 0e		bra $cf5a			bra		_FPFSignBit
.cf4c					_FPNoFastCompare:
.cf4c	18		clc				clc
.cf4d	60		rts				rts
.cf4e					_FPFZero:
.cf4e	a9 00		lda #$00			lda 	#0
.cf50					_FPFExitSet:
.cf50	38		sec				sec
.cf51	60		rts				rts
.cf52					_FPFLeftZero:
.cf52	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.cf54	70 f8		bvs $cf4e			bvs 	_FPFZero
.cf56	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.cf58	49 80		eor #$80			eor 	#$80						; return that as a sign.
.cf5a					_FPFSignBit:
.cf5a	0a		asl a				asl 	a
.cf5b	a9 01		lda #$01			lda 	#1
.cf5d	90 f1		bcc $cf50			bcc		_FPFExitSet
.cf5f	a9 ff		lda #$ff			lda 	#$FF
.cf61	38		sec				sec
.cf62	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cf63					FPUCopyX2ToX1:
.cf63	48		pha				pha									; save AXY
.cf64	da		phx				phx
.cf65	5a		phy				phy
.cf66	a0 08		ldy #$08			ldy 	#8 							; copy the whole mantissa
.cf68	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.cf6a	95 80		sta $80,x			sta 	XS_Mantissa,x
.cf6c	e8		inx				inx
.cf6d	88		dey				dey
.cf6e	10 f8		bpl $cf68			bpl 	_FPUC21
.cf70	7a		ply				ply 								; restore and exit
.cf71	fa		plx				plx
.cf72	68		pla				pla
.cf73	60		rts				rts
.cf74					FPUSetInteger:
.cf74	48		pha				pha
.cf75	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cf77	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cf79	10 02		bpl $cf7d			bpl 	_FPUSIExtend 				; so sign extend it into the mantissa
.cf7b	a9 ff		lda #$ff			lda 	#$FF
.cf7d					_FPUSIExtend:
.cf7d	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cf7f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cf81	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cf83	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cf85	95 85		sta $85,x			sta 	XS_Type,x
.cf87	68		pla				pla
.cf88	60		rts				rts
.cf89					FPUNegateInteger:
.cf89	48		pha				pha
.cf8a	38		sec				sec
.cf8b	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cf8d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.cf8f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cf91	a9 00		lda #$00			lda 	#0
.cf93	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.cf95	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cf97	a9 00		lda #$00			lda 	#0
.cf99	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.cf9b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cf9d	a9 00		lda #$00			lda 	#0
.cf9f	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.cfa1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cfa3	68		pla				pla
.cfa4	60		rts				rts
.cfa5					FPUToFloat:
.cfa5	48		pha				pha
.cfa6	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.cfa8	29 0f		and #$0f			and 	#$0F 						; (e.g. type is zero)
.cfaa	f0 24		beq $cfd0			beq 	_FPUFExit
.cfac	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cfae	95 85		sta $85,x			sta 	XS_Type,x
.cfb0	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cfb2	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.cfb4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cfb6	10 07		bpl $cfbf			bpl		_FPUFPositive
.cfb8	20 89 cf	jsr $cf89			jsr 	FPUNegateInteger 			; negate the mantissa
.cfbb	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cfbd	95 85		sta $85,x			sta 	XS_Type,x
.cfbf					_FPUFPositive:
.cfbf	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cfc1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.cfc3	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.cfc5	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.cfc7	d0 04		bne $cfcd			bne 	_FPUFNonZero
.cfc9	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cfcb	95 85		sta $85,x			sta 	XS_Type,x
.cfcd					_FPUFNonZero:
.cfcd	20 d2 cf	jsr $cfd2			jsr 	FPUNormalise 				; normalise the floating point.
.cfd0					_FPUFExit:
.cfd0	68		pla				pla
.cfd1	60		rts				rts
.cfd2					FPUNormalise:
.cfd2	48		pha				pha
.cfd3	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cfd5	70 18		bvs $cfef			bvs 	_FPUNExit
.cfd7	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cfd9	f0 10		beq $cfeb			beq 	_FPUNSetZero 				; (e.g. the float value zero)
.cfdb					_FPUNLoop:
.cfdb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cfdd	30 10		bmi $cfef			bmi 	_FPUNExit 					; if so, we are normalised.
.cfdf	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.cfe1	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.cfe3	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.cfe5	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.cfe7	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.cfe9	d0 f0		bne $cfdb			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cfeb					_FPUNSetZero:
.cfeb	a9 40		lda #$40			lda 	#$40
.cfed	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.cfef					_FPUNExit:
.cfef	68		pla				pla
.cff0	60		rts				rts
.cff1					FPUToInteger:
.cff1	48		pha				pha
.cff2	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.cff4	29 01		and #$01			and 	#1
.cff6	d0 31		bne $d029			bne 	_FPUTOI_Exit
.cff8	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.cffa	70 23		bvs $d01f			bvs 	_FPUTOI_Zero
.cffc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.cffe	10 1f		bpl $d01f			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.d000	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.d002	b0 2b		bcs $d02f			bcs 	FP_Overflow 				; can't cope with that as an integer.
.d004					_FPUToIToInteger:
.d004	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.d006	c9 a0		cmp #$a0			cmp 	#128+32
.d008	f0 0c		beq $d016			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.d00a	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.d00c	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.d00e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.d010	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.d012	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.d014	80 ee		bra $d004			bra 	_FPUToIToInteger 			; keep going.
.d016					_FPUToICheckSign:
.d016	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.d018	10 0f		bpl $d029			bpl 	_FPUToI_Exit 				; exit if unsigned.
.d01a	20 89 cf	jsr $cf89			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.d01d	80 0a		bra $d029			bra 	_FPUTOI_Exit
.d01f					_FPUTOI_Zero:
.d01f	a9 00		lda #$00			lda 	#0 							; return zero integer.
.d021	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.d023	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d025	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d027	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d029					_FPUToI_Exit:
.d029	a9 01		lda #$01			lda 	#1 							; set type to integer
.d02b	95 85		sta $85,x			sta 	XS_Type,x
.d02d	68		pla				pla
.d02e	60		rts				rts
.d02f					FP_Overflow:
.d02f	20 e0 ae	jsr $aee0			jsr ERR_Handler
>d032	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>d03a	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.d04a					FPUTimes10:
.d04a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.d04c	85 1c		sta $1c				sta 	ZLTemp1+0
.d04e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.d050	85 1d		sta $1d				sta 	ZLTemp1+1
.d052	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.d054	85 1e		sta $1e				sta 	ZLTemp1+2
.d056	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.d058	85 1f		sta $1f				sta 	ZLTemp1+3
.d05a	20 8f d0	jsr $d08f			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.d05d	20 8f d0	jsr $d08f			jsr 	_FPUT_LSR_ZLTemp1
.d060	18		clc				clc
.d061	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.d063	65 1c		adc $1c				adc 	ZLTemp1+0
.d065	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.d067	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.d069	65 1d		adc $1d				adc 	ZLTemp1+1
.d06b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d06d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.d06f	65 1e		adc $1e				adc 	ZLTemp1+2
.d071	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d073	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.d075	65 1f		adc $1f				adc 	ZLTemp1+3
.d077	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d079	90 0a		bcc $d085			bcc 	_FPUTimes10
.d07b	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.d07d	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.d07f	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.d081	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.d083	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.d085					_FPUTimes10:
.d085	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.d087	18		clc				clc
.d088	69 03		adc #$03			adc 	#3
.d08a	95 84		sta $84,x			sta 	XS_Exponent,x
.d08c	b0 a1		bcs $d02f			bcs 	FP_Overflow 				; error
.d08e	60		rts				rts
.d08f					_FPUT_LSR_ZLTemp1:
.d08f	46 1f		lsr $1f				lsr 	ZLTemp1+3
.d091	66 1e		ror $1e				ror 	ZLTemp1+2
.d093	66 1d		ror $1d				ror 	ZLTemp1+1
.d095	66 1c		ror $1c				ror 	ZLTemp1+0
.d097	60		rts				rts
.d098					FPUScale10A:
.d098	5a		phy				phy
.d099	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.d09b	f0 37		beq $d0d4			beq 	_FPUScaleExit
.d09d	da		phx				phx 								; save X
.d09e	e8		inx				inx
.d09f	e8		inx				inx
.d0a0	e8		inx				inx
.d0a1	e8		inx				inx
.d0a2	e8		inx				inx
.d0a3	e8		inx				inx
.d0a4	a8		tay				tay 								; save power scalar in Y.
.d0a5	a9 00		lda #$00			lda 	#0
.d0a7	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0 in float.
.d0a9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d0ab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d0ad	95 85		sta $85,x			sta 	XS_Type,x
.d0af	a9 80		lda #$80			lda 	#$80
.d0b1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d0b3	a9 81		lda #$81			lda 	#$81
.d0b5	95 84		sta $84,x			sta 	XS_Exponent,x
.d0b7	5a		phy				phy 								; save 10^n (e.g. the scalar) on stack.
.d0b8	c0 00		cpy #$00			cpy 	#0
.d0ba	10 05		bpl $d0c1			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.d0bc	98		tya				tya
.d0bd	49 ff		eor #$ff			eor 	#$FF
.d0bf	1a		inc a				inc 	a
.d0c0	a8		tay				tay
.d0c1					_FPUSAbs:
.d0c1	20 4a d0	jsr $d04a			jsr 	FPUTimes10
.d0c4	88		dey				dey
.d0c5	d0 fa		bne $d0c1			bne 	_FPUSAbs 					; tos is now 10^|AC|
.d0c7	68		pla				pla 								; restore count in A
.d0c8	fa		plx				plx 								; restore X pointing to number to scale.
.d0c9	0a		asl a				asl 	a
.d0ca	b0 05		bcs $d0d1			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.d0cc	20 ec cd	jsr $cdec			jsr 	FPMultiply 					; if clear multiply.
.d0cf	80 03		bra $d0d4			bra		_FPUScaleExit
.d0d1					_FPUSDivide:
.d0d1	20 79 cd	jsr $cd79			jsr 	FPDivide
.d0d4					_FPUScaleExit:
.d0d4	7a		ply				ply
.d0d5	60		rts				rts
.d0d6					FPUCopyToNext:
.d0d6	a0 06		ldy #$06			ldy 		#6
.d0d8	da		phx				phx
.d0d9					_FPUCopy1:
.d0d9	b5 80		lda $80,x			lda 	XS_Mantissa,x
.d0db	95 86		sta $86,x			sta 	XS2_Mantissa,x
.d0dd	e8		inx				inx
.d0de	88		dey				dey
.d0df	d0 f8		bne $d0d9			bne 	_FPUCopy1
.d0e1	fa		plx				plx
.d0e2	60		rts				rts
.d0e3					FPUCopyFromNext:
.d0e3	a0 06		ldy #$06			ldy 		#6
.d0e5	da		phx				phx
.d0e6					_FPUCopy1:
.d0e6	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.d0e8	95 80		sta $80,x			sta 	XS_Mantissa,x
.d0ea	e8		inx				inx
.d0eb	88		dey				dey
.d0ec	d0 f8		bne $d0e6			bne 	_FPUCopy1
.d0ee	fa		plx				plx
.d0ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.d0f0					FPToString:
.d0f0	48		pha				pha
.d0f1	5a		phy				phy
.d0f2	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.d0f4	50 0a		bvc $d100			bvc 		_FPTSIsFloat 			; if zero,
.d0f6					_FPTSZero:
.d0f6	a9 30		lda #$30			lda 		#"0"
.d0f8	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter
.d0fb					_FPTSExit:
.d0fb	7a		ply				ply
.d0fc	68		pla				pla
.d0fd	60		rts				rts
.d0fe	80 fb		bra $d0fb			bra 		_FPTSExit
.d100					_FPTSIsFloat:
.d100	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.d102	10 09		bpl $d10d			bpl 		_FPTSNotSigned
.d104	a9 00		lda #$00			lda 		#0 						; clear sign flag
.d106	95 85		sta $85,x			sta 		XS_Type,x
.d108	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d10a	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter
.d10d					_FPTSNotSigned:
.d10d	b5 84		lda $84,x			lda 		XS_Exponent,x
.d10f	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.d111	b0 09		bcs $d11c			bcs 		_FPTSExponent
.d113	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.d115	90 05		bcc $d11c			bcc 		_FPTSExponent 			;
.d117					_FPTSStandard:
.d117	20 5b d1	jsr $d15b			jsr 		FPTOutputBody 			; output the body.
.d11a	80 df		bra $d0fb			bra 		_FPTSExit
.d11c					_FPTSExponent:
.d11c	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.d11e	8d 9d 03	sta $039d			sta 		ExpCount
.d121					_FPTSExponentLoop:
.d121	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.d123	10 0e		bpl $d133			bpl 		_FPTSTimes
.d125	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.d127	90 14		bcc $d13d			bcc 		_FPTSScaledToExp
.d129	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.d12b	20 98 d0	jsr $d098			jsr 		FPUScale10A
.d12e	ee 9d 03	inc $039d			inc 		ExpCount
.d131	80 ee		bra $d121			bra 		_FPTSExponentLoop
.d133					_FPTSTimes:
.d133	a9 01		lda #$01			lda 		#1
.d135	20 98 d0	jsr $d098			jsr 		FPUScale10A
.d138	ce 9d 03	dec $039d			dec 		ExpCount
.d13b	80 e4		bra $d121			bra 		_FPTSExponentLoop
.d13d					_FPTSScaledToExp:
.d13d	20 5b d1	jsr $d15b			jsr 		FPTOutputBody 			; output the body.
.d140	a9 65		lda #$65			lda 		#"e"					; output E
.d142	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter
.d145	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.d148	95 80		sta $80,x			sta 		XS_Mantissa,x
.d14a	29 80		and #$80			and 		#$80 					; sign extend it
.d14c	f0 02		beq $d150			beq 		_FPTSSExt
.d14e	a9 ff		lda #$ff			lda 		#$FF
.d150					_FPTSSExt:
.d150	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.d152	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.d154	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.d156	20 7a cb	jsr $cb7a			jsr 		INTToString 			; output the exponent.
.d159	80 a0		bra $d0fb			bra			_FPTSExit 				; and exit.
.d15b					FPTOutputBody:
.d15b	20 d6 d0	jsr $d0d6			jsr 		FPUCopyToNext 			; copy to next slot.
.d15e	20 f1 cf	jsr $cff1			jsr 		FPUToInteger 			; convert to an integer
.d161	20 7a cb	jsr $cb7a			jsr 		INTToString 			; output the main integer part.
.d164	20 e3 d0	jsr $d0e3			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d167	20 74 ce	jsr $ce74			jsr 		FPFractionalPart 		; get the decimal part.
.d16a	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.d16c	70 3c		bvs $d1aa			bvs 		_FPTOExit 				; if not, exit now.
.d16e	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d170	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter
.d173					_FPOutLoop:
.d173	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.d175	70 1d		bvs $d194			bvs 		_FPStripZeros 			; strip trailing zeros
.d177	20 4a d0	jsr $d04a			jsr 		FPUTimes10 				; multiply by 10
.d17a	20 d6 d0	jsr $d0d6			jsr 		FPUCopyToNext			; copy to next slot.
.d17d	20 f1 cf	jsr $cff1			jsr 		FPUToInteger 			; convert to integer
.d180	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.d182	09 30		ora #$30			ora 		#"0"
.d184	20 18 cc	jsr $cc18			jsr 		ITSOutputCharacter
.d187	20 e3 d0	jsr $d0e3			jsr 		FPUCopyFromNext 		; get it back
.d18a	20 74 ce	jsr $ce74			jsr 		FPFractionalPart 		; get fractional part
.d18d	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.d190	c9 0b		cmp #$0b			cmp 	 	#11
.d192	90 df		bcc $d173			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d194					_FPStripZeros:
.d194	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.d197					_FPStripLoop:
.d197	88		dey				dey 								; back one, if at start then no strip
.d198	f0 10		beq $d1aa			beq 		_FPToExit
.d19a	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.d19d	c9 30		cmp #$30			cmp 		#"0"
.d19f	f0 f6		beq $d197			beq 		_FPStripLoop
.d1a1	c8		iny				iny
.d1a2	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d1a4	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.d1a7	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.d1aa					_FPTOExit:
.d1aa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d1ab					FPFromString:
.d1ab	48		pha				pha 								; push A
.d1ac	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d1ae	c9 2e		cmp #$2e			cmp 	#"."
.d1b0	f0 03		beq $d1b5			beq	 	_FPFIsDecimal
.d1b2	4c 11 d2	jmp $d211			jmp 	_FPFNotDecimal
.d1b5					_FPFIsDecimal:
.d1b5	c8		iny				iny 								; consume the decimal.
.d1b6	20 a5 cf	jsr $cfa5			jsr 	FPUToFloat 					; convert the integer to float.
.d1b9	da		phx				phx 								; save X.
.d1ba	5a		phy				phy 								; save decimal start position
.d1bb	e8		inx				inx
.d1bc	e8		inx				inx
.d1bd	e8		inx				inx
.d1be	e8		inx				inx
.d1bf	e8		inx				inx
.d1c0	e8		inx				inx
.d1c1	20 2d cc	jsr $cc2d			jsr 	INTFromStringY 				; get the part after the DP.
.d1c4	20 a5 cf	jsr $cfa5			jsr 	FPUToFloat 					; convert that to a float.
.d1c7	68		pla				pla 								; calculate - chars consumed.
.d1c8	8c 9c 03	sty $039c			sty 	ExpTemp
.d1cb	38		sec				sec
.d1cc	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.d1cf	20 98 d0	jsr $d098			jsr 	FPUScale10A 				; scale it by 10^AC
.d1d2	fa		plx				plx 								; restore original X
.d1d3	20 c5 cc	jsr $ccc5			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d1d6	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.d1d8	c9 45		cmp #$45			cmp 	#"E"
.d1da	f0 04		beq $d1e0			beq 	_FPFExponent
.d1dc	c9 65		cmp #$65			cmp 	#"e"
.d1de	d0 31		bne $d211			bne 	_FPFNotDecimal 				; no, then exit normally.
.d1e0					_FPFExponent:
.d1e0	c8		iny				iny 								; skip over E symbol.
.d1e1	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.d1e3	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d1e5	d0 01		bne $d1e8			bne 	_FPFGotSign
.d1e7	c8		iny				iny 								; if it was - skip over it.
.d1e8					_FPFGotSign:
.d1e8	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d1e9	da		phx				phx
.d1ea	e8		inx				inx
.d1eb	e8		inx				inx
.d1ec	e8		inx				inx
.d1ed	e8		inx				inx
.d1ee	e8		inx				inx
.d1ef	e8		inx				inx
.d1f0	20 2d cc	jsr $cc2d			jsr 	INTFromStringY 				; get the exponent
.d1f3	fa		plx				plx 								; restore X.
.d1f4	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d1f6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.d1f8	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.d1fa	d0 17		bne $d213			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d1fc	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d1fe	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d200	b0 11		bcs $d213			bcs 	_FPFXOverflow
.d202	68		pla				pla 								; get direction
.d203	d0 07		bne $d20c			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d205	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d207	49 ff		eor #$ff			eor 	#$FF
.d209	1a		inc a				inc 	a
.d20a	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.d20c					_FPFXScale:
.d20c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d20e	20 98 d0	jsr $d098			jsr 	FPUScale10A 				; scale by the exponent.
.d211					_FPFNotDecimal:
.d211	68		pla				pla
.d212	60		rts				rts
.d213					_FPFXOverflow:
.d213	20 e0 ae	jsr $aee0			jsr 	ERR_Handler
>d216	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d21e	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.d225					Unary_Rnd:
.d225	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX 			; get value
.d228	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; check right bracket.
.d22b	20 e2 bf	jsr $bfe2			jsr 	GetSignCurrent 				; get sign -1,0,1.
.d22e	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.d230	30 10		bmi $d242			bmi 	_URSetSeed
.d232	f0 28		beq $d25c			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.d234	da		phx				phx
.d235	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.d237	20 93 d2	jsr $d293			jsr 	Random16
.d23a	a2 02		ldx #$02			ldx 	#2
.d23c	20 93 d2	jsr $d293			jsr 	Random16
.d23f	fa		plx				plx
.d240	80 1a		bra $d25c			bra 	_URMakeRandom
.d242					_URSetSeed:
.d242	20 a5 cf	jsr $cfa5			jsr 	FPUToFloat 					; make it a float to twiddle it.
.d245	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.d247	8d a3 03	sta $03a3			sta 	RandomSeed+0
.d24a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.d24c	8d a4 03	sta $03a4			sta 	RandomSeed+1
.d24f	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.d251	8d a5 03	sta $03a5			sta 	RandomSeed+2
.d254	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.d256	0a		asl a				asl 	a 							; resemblance to the seed value.
.d257	49 db		eor #$db			eor 	#$DB
.d259	8d a6 03	sta $03a6			sta 	RandomSeed+3
.d25c					_URMakeRandom:
.d25c	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.d25f	0d a4 03	ora $03a4			ora 	RandomSeed+1
.d262	0d a5 03	ora $03a5			ora 	RandomSeed+2
.d265	0d a6 03	ora $03a6			ora 	RandomSeed+3
.d268	d0 0a		bne $d274			bne 	_URNotZero
.d26a	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.d26c	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.d26f	a9 3d		lda #$3d			lda 	#$3D
.d271	8d a6 03	sta $03a6			sta 	RandomSeed+3
.d274					_URNotZero:
.d274	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.d277	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.d279	ad a4 03	lda $03a4			lda 	RandomSeed+1
.d27c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d27e	ad a5 03	lda $03a5			lda 	RandomSeed+2
.d281	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d283	ad a6 03	lda $03a6			lda 	RandomSeed+3
.d286	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d288	a9 00		lda #$00			lda 	#$00 						; set type to float.
.d28a	95 85		sta $85,x			sta 	XS_Type,x
.d28c	a9 80		lda #$80			lda 	#$80
.d28e	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.d290	4c d2 cf	jmp $cfd2			jmp 	FPUNormalise 				; and normalise.
.d293					Random16:
.d293	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.d296	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.d299	90 08		bcc $d2a3			bcc 	_R16_NoXor
.d29b	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.d29e	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.d2a0	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.d2a3					_R16_NoXor:
.d2a3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.d2a4					Unary_Int:
.d2a4	20 6c bd	jsr $bd6c			jsr 	EvaluateNumberX 			; get value
.d2a7	20 ce c3	jsr $c3ce			jsr 	CheckNextRParen 			; check right bracket.
.d2aa	4c f1 cf	jmp $cff1			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.d2ad	80 fe		bra $d2ad	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM 					; Reset vector
>fffe	ca ac					.word TIM_BreakVector

;******  End of listing
