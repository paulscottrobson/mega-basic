
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Wed Aug 28 19:09:37 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .word ? 						; End of Program Memory.
>0306					UserVector .fill 4 							; USR(x) calls this.
>030a					LocalVector .fill 4 						; Indirect calls call this.
>030e					NumBufX 	.byte 	?						; buffer index position
>030f					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.032f					HashTableBase:
>032f								.fill	HashTableCount * HashTableSize * 2
.038f					HashTableEnd:
=$30f					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>038f					Var_Type    .byte ? 						; type of variable (as a type token)
>0390					Var_Hash 	.byte ? 						; hash of identifier name.
>0391					Var_Length 	.byte ? 						; length of variable name
>0392					Var_HashAddress .byte ?						; low byte of hash table entry.
>0393					Var_DataSize .byte ?						; size of one element.
>0394					NumSuppress	.byte 	?						; leading zero suppression flag
>0395					NumConvCount .byte 	? 						; count for conversions.
>0396					ExpTemp:	.byte ?							; Working temp for exponents.
>0397					ExpCount:	.byte ? 						; Count of decimal exponents.
>0398					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0399					TempStringWriteIndex: .byte ? 				; Write offset.
>039a					ValSign: 	.byte ? 						; sign flag for val()
>039b					SliceStart:	.byte ? 						; string slice parts
>039c					SliceCount:	.byte ?
>039d					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a1					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03a9					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b1					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b2					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03b4					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03b6					Tim_SR:		.byte ? 						; Processor Status
>03b7					Tim_A:		.byte ? 						; Processor Registers
>03b8					Tim_X:		.byte ?
>03b9					Tim_Y:		.byte ?
>03ba					Tim_Z:		.byte ?
>03bb					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	12 02 00 18 bb 84 40 c0			.byte	$12,$02,$00,$18,$bb,$84,$40,$c0
>8008	d6 fe 08 53 74 61 72 74			.byte	$d6,$fe,$08,$53,$74,$61,$72,$74
>8010	2e 00 0a 03 00 91 c0 19			.byte	$2e,$00,$0a,$03,$00,$91,$c0,$19
>8018	bb 84 40 00 1b 04 00 91			.byte	$bb,$84,$40,$00,$1b,$04,$00,$91
>8020	c0 19 bb 84 19 bb 8a 41			.byte	$c0,$19,$bb,$84,$19,$bb,$8a,$41
>8028	c0 d6 18 bb c1 19 bb c1			.byte	$c0,$d6,$18,$bb,$c1,$19,$bb,$c1
>8030	c0 96 19 bb 84 43 00 14			.byte	$c0,$96,$19,$bb,$84,$43,$00,$14
>8038	05 00 d6 c0 18 bb 84 18			.byte	$05,$00,$d6,$c0,$18,$bb,$84,$18
>8040	bb 8a 41 c0 96 18 bb 84			.byte	$bb,$8a,$41,$c0,$96,$18,$bb,$84
>8048	4f 68 00 0b 06 00 d6 fe			.byte	$4f,$68,$00,$0b,$06,$00,$d6,$fe
>8050	06 45 6e 64 2e 00 05 07			.byte	$06,$45,$6e,$64,$2e,$00,$05,$07
>8058	00 c4 00 00				.byte	$00,$c4,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c 5b b0	jmp $b05b		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 05	sta $0500			sta 	IFT_XCursor
.a071	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a074	ad 01 05	lda $0501			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 05	sta $0500			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 05	inc $0500			inc 	IFT_XCursor
.a150	ad 00 05	lda $0500			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 05	dec $0501			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 05	sta $0501			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 05	inc $0501			inc 	IFT_YCursor
.a168	ad 01 05	lda $0501			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 05	lda $0501			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 05	inc $0500			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab15					TIM_Error:
.ab15	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab18	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab1a	80 02		bra $ab1e			bra 	TIM_ShowPrompt
.ab1c					TIM_NewCommand:
.ab1c	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1e					TIM_ShowPrompt:
.ab1e	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab21	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab24	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.ab27	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab29	84 11		sty $11				sty 	zTemp1+1
.ab2b	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2d	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2f	c9 3f		cmp #$3f			cmp 	#"?"
.ab31	f0 04		beq $ab37			beq 	TIM_SkipFirst
.ab33	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab35	d0 01		bne $ab38			bne 	TIM_NotDot
.ab37					TIM_SkipFirst:
.ab37	c8		iny				iny
.ab38					TIM_NotDot:
.ab38	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab3a	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab3c	f0 6e		beq $abac			beq 	TIM_ShowRegisters
.ab3e	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab40	f0 12		beq $ab54			beq 	TIM_ShowMemory
.ab42	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab44	f0 49		beq $ab8f			beq 	TIM_Execute
.ab46	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab48	f0 07		beq $ab51			beq 	TIM_GoLoadMemory
.ab4a	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab4c	d0 c7		bne $ab15			bne 	TIM_Error
.ab4e	4c d1 ac	jmp $acd1			jmp 	TIM_UpdateRegisters
.ab51					TIM_GoLoadMemory:
.ab51	4c fc ac	jmp $acfc			jmp 	TIM_LoadMemory
.ab54					TIM_ShowMemory:
.ab54	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab57	b0 bc		bcs $ab15			bcs 	TIM_Error
.ab59	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab5b	85 12		sta $12				sta 	zTemp2
.ab5d	a5 15		lda $15				lda 	zTemp3+1
.ab5f	85 13		sta $13				sta 	zTemp2+1
.ab61	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab64	90 08		bcc $ab6e			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab66	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab68	85 14		sta $14				sta 	zTemp3
.ab6a	a5 13		lda $13				lda 	zTemp2+1
.ab6c	85 15		sta $15				sta 	zTemp3+1
.ab6e					_TIMSM_Start:
.ab6e	20 22 ac	jsr $ac22			jsr 	TIM_WriteLine 				; write one line of hex out
.ab71	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab73	18		clc				clc
.ab74	69 10		adc #$10			adc 	#16
.ab76	85 12		sta $12				sta 	zTemp2
.ab78	90 02		bcc $ab7c			bcc 	_TIMSM_NoCarry
.ab7a	e6 13		inc $13				inc 	zTemp2+1
.ab7c					_TIMSM_NoCarry:
.ab7c	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.ab7f	d0 0b		bne $ab8c			bne 	_TIMSM_Ends 				; if pressed break out.
.ab81	38		sec				sec 								; check past the end address in zTemp3
.ab82	a5 14		lda $14				lda 	zTemp3
.ab84	e5 12		sbc $12				sbc 	zTemp2
.ab86	a5 15		lda $15				lda 	zTemp3+1
.ab88	e5 13		sbc $13				sbc 	zTemp2+1
.ab8a	10 e2		bpl $ab6e			bpl 	_TIMSM_Start
.ab8c					_TIMSM_Ends:
.ab8c	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.ab8f					TIM_Execute:
.ab8f	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; get the execute address
.ab92	b0 81		bcs $ab15			bcs 	TIM_Error 					; not legitimate
.ab94	ae bb 03	ldx $03bb			ldx 	TIM_SP 						; set up SP
.ab97	9a		txs				txs
.ab98	ad b6 03	lda $03b6			lda 	TIM_SR 						; Status for PLP
.ab9b	48		pha				pha
.ab9c	ad b7 03	lda $03b7			lda 	TIM_A 						; restore AXYZ
.ab9f	ae b8 03	ldx $03b8			ldx 	TIM_X
.aba2	ac b9 03	ldy $03b9			ldy 	TIM_Y
.aba5	ab ba 03	ldz $03ba			ldz 	TIM_Z
.aba8	28		plp				plp 								; and PS Byte.
.aba9	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.abac					TIM_Start:
.abac					TIM_ShowRegisters:
.abac	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abaf	8d b5 03	sta $03b5			sta 	TIM_IRQ+1
.abb2	ad ff ff	lda $ffff			lda 	$FFFF
.abb5	8d b4 03	sta $03b4			sta 	TIM_IRQ
.abb8	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abba					_TIMSR_Text:
.abba	bd e6 ab	lda $abe6,x			lda 	_TIMSR_Label,x
.abbd	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abc0	e8		inx				inx
.abc1	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc3	d0 f5		bne $abba			bne 	_TIMSR_Text
.abc5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc7					_TIMSR_Skip:
.abc7	e8		inx				inx
.abc8					_TIMSR_LoopSpace:
.abc8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abca	b0 04		bcs $abd0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abcc	8a		txa				txa
.abcd	4a		lsr a				lsr 	a
.abce	b0 05		bcs $abd5			bcs 	_TIMSR_NoSpace
.abd0					_TIMSR_Space:
.abd0	a9 20		lda #$20			lda 	#" "
.abd2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd5					_TIMSR_NoSpace:
.abd5	bd b2 03	lda $03b2,x			lda 	TIM_PC,x 					; output hex value.
.abd8	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.abdb	e8		inx				inx
.abdc	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abde	d0 e8		bne $abc8			bne 	_TimSR_LoopSpace
.abe0	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.abe3	4c 1c ab	jmp $ab1c			jmp	 	TIM_NewCommand 				; new command.
.abe6					_TIMSR_Label:
>abe6	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abee	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfe	52
>abff	20 5a 52					.text 	" ZR"
>ac02	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac09					_TIMSR_LabelEnd:
.ac09					TIM_WriteHex:
.ac09	48		pha				pha 								; save A
.ac0a	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac0b	4a		lsr a				lsr 	a
.ac0c	4a		lsr a				lsr 	a
.ac0d	4a		lsr a				lsr 	a
.ac0e	20 12 ac	jsr $ac12			jsr 	_TIMWH_Nibble 				; print MSB
.ac11	68		pla				pla 								; restore and print LSB
.ac12					_TIMWH_Nibble:
.ac12	48		pha				pha
.ac13	29 0f		and #$0f			and 	#15 						; mask out
.ac15	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac17	90 02		bcc $ac1b			bcc 	_TIMWHNoLetter
.ac19	69 06		adc #$06			adc 	#6
.ac1b					_TIMWHNoLetter:
.ac1b	69 30		adc #$30			adc 	#48
.ac1d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac20	68		pla				pla
.ac21	60		rts				rts
.ac22					TIM_WriteLine:
.ac22	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac24	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac27	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac29	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac2c	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2e	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac31	a5 12		lda $12				lda 	zTemp2
.ac33	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac36	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac38					_TIMWL_Loop:
.ac38	a9 20		lda #$20			lda 	#" "
.ac3a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3d	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3f	20 09 ac	jsr $ac09			jsr 	TIM_WriteHex
.ac42	c8		iny				iny
.ac43	c0 10		cpy #$10			cpy 	#16
.ac45	d0 f1		bne $ac38			bne 	_TIMWL_Loop
.ac47	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.ac4a					TIM_GetHex:
.ac4a	c8		iny				iny
.ac4b	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4d	c9 20		cmp #$20			cmp 	#32
.ac4f	f0 f9		beq $ac4a			beq 	TIM_GetHex
.ac51	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac53	f0 f5		beq $ac4a			beq 	TIM_GetHex
.ac55	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac58	b0 23		bcs $ac7d			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac5a	a9 00		lda #$00			lda 	#0 							; zero result
.ac5c	85 14		sta $14				sta 	zTemp3
.ac5e	85 15		sta $15				sta 	zTemp3+1
.ac60					_TIM_GHLoop:
.ac60	20 7e ac	jsr $ac7e			jsr 	TIM_GetHexCharacter 		; get next character
.ac63	b0 17		bcs $ac7c			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac65	c8		iny				iny 								; skip over it.
.ac66	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac68	26 15		rol $15				rol 	zTemp3+1
.ac6a	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac6c	26 15		rol $15				rol 	zTemp3+1
.ac6e	06 14		asl $14				asl 	zTemp3						; now x 4
.ac70	26 15		rol $15				rol 	zTemp3+1
.ac72	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac74	26 15		rol $15				rol 	zTemp3+1
.ac76	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac78	85 14		sta $14				sta 	zTemp3
.ac7a	80 e4		bra $ac60			bra 	_TIM_GHLoop 				; loop round again.
.ac7c					_TIMGH_Okay:
.ac7c	18		clc				clc
.ac7d					_TIMGH_Exit:
.ac7d	60		rts				rts
.ac7e					TIM_GetHexCharacter:
.ac7e	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac80	38		sec				sec
.ac81	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac83	90 0e		bcc $ac93			bcc 	_TIM_GHCFail
.ac85	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac87	90 0b		bcc $ac94			bcc 	_TIM_GHCExit
.ac89	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac8b	90 06		bcc $ac93			bcc		_TIM_GHCFail
.ac8d	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8f	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac91	90 01		bcc $ac94			bcc		_TIM_GHCExit
.ac93					_TIM_GHCFail:
.ac93	38		sec				sec
.ac94					_TIM_GHCExit:
.ac94	60		rts				rts
.ac95					TIM_BreakVector:
.ac95	da		phx				phx									; save X/A on stack
.ac96	48		pha				pha
.ac97	ba		tsx				tsx 								; X points to S
.ac98	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac9b	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9d	d0 03		bne $aca2			bne 	_TIMBreak					; if set, it's BRK
.ac9f	68		pla				pla 								; abandon routine.
.aca0	fa		plx				plx
.aca1	40		rti				rti
.aca2					_TIMBreak:
.aca2	68		pla				pla 								; save A X Y and maybe Z
.aca3	8d b7 03	sta $03b7			sta 	TIM_A
.aca6	fa		plx				plx
.aca7	8e b8 03	stx $03b8			stx 	TIM_X
.acaa	8c b9 03	sty $03b9			sty 	TIM_Y
.acad	9c ba 03	stz $03ba			stz 	TIM_Z
.acb0	68		pla				pla 								; get Status Register
.acb1	8d b6 03	sta $03b6			sta 	TIM_SR
.acb4	68		pla				pla
.acb5	8d b3 03	sta $03b3			sta 	TIM_PC+1 					; save calling address
.acb8	68		pla				pla
.acb9	8d b2 03	sta $03b2			sta 	TIM_PC 						; high byte
.acbc	ad b3 03	lda $03b3			lda 	TIM_PC+1 					; dec PC to point right.
.acbf	d0 03		bne $acc4			bne 	_TIMDecrement 				; brk bumps it.
.acc1	ce b2 03	dec $03b2			dec 	TIM_PC
.acc4					_TIMDecrement:
.acc4	ce b3 03	dec $03b3			dec 	TIM_PC+1
.acc7	ba		tsx				tsx 								; and copy SP
.acc8	8e bb 03	stx $03bb			stx 	TIM_SP
.accb	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.accd	9a		txs				txs
.acce	4c ac ab	jmp $abac			jmp 	TIM_Start 					; and start up TIM monitor.
.acd1					TIM_UpdateRegisters:
.acd1	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; PC
.acd4	b0 23		bcs $acf9			bcs 	_TIMURFail
.acd6	a5 14		lda $14				lda 	zTemp3
.acd8	8d b3 03	sta $03b3			sta 	Tim_PC+1
.acdb	a5 15		lda $15				lda 	zTemp3+1
.acdd	8d b2 03	sta $03b2			sta 	Tim_PC
.ace0	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; ignore IRQ
.ace3	b0 14		bcs $acf9			bcs 	_TIMURFail
.ace5	a2 00		ldx #$00			ldx 	#0
.ace7					_TIM_URLoop:
.ace7	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; registers
.acea	b0 0d		bcs $acf9			bcs 	_TIMURFail
.acec	a5 14		lda $14				lda 	zTemp3
.acee	9d b6 03	sta $03b6,x			sta 	Tim_SR,x
.acf1	e8		inx				inx
.acf2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf4	d0 f1		bne $ace7			bne 	_TIM_URLoop
.acf6	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand
.acf9					_TIMURFail:
.acf9	4c 15 ab	jmp $ab15			jmp 	TIM_Error
.acfc					TIM_LoadMemory:
.acfc	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; target address => zTemp2
.acff	a5 14		lda $14				lda 	zTemp3
.ad01	85 12		sta $12				sta 	zTemp2
.ad03	a5 15		lda $15				lda 	zTemp3+1
.ad05	85 13		sta $13				sta 	zTemp2+1
.ad07					_TIM_LMLoop:
.ad07	20 4a ac	jsr $ac4a			jsr 	TIM_GetHex 					; next byte ?
.ad0a	b0 0e		bcs $ad1a			bcs 	_TIMLMDone 					; no more
.ad0c	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0e	a5 14		lda $14				lda 	zTemp3
.ad10	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad12	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad14	d0 f1		bne $ad07			bne 	_TIM_LMLoop
.ad16	e6 13		inc $13				inc 	zTemp2+1
.ad18	80 ed		bra $ad07			bra 	_TIM_LMLoop
.ad1a					_TIMLMDone:
.ad1a	4c 1c ab	jmp $ab1c			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.ad1d					StackReset:
.ad1d	48		pha				pha
.ad1e	5a		phy				phy
.ad1f	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.ad21	85 26		sta $26				sta 	zBasicSP
.ad23	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.ad25	85 27		sta $27				sta 	zBasicSP+1
.ad27	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.ad29	98		tya				tya 								; be a legal token.
.ad2a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad2c	7a		ply				ply
.ad2d	68		pla				pla
.ad2e	60		rts				rts
.ad2f					StackPushFrame:
.ad2f	48		pha				pha
.ad30	5a		phy				phy
.ad31	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.ad32	48		pha				pha 								; save it.
.ad33	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.ad35	18		clc				clc 								; add to Basic Stack
.ad36	65 26		adc $26				adc 	zBasicSP
.ad38	85 26		sta $26				sta 	zBasicSP
.ad3a	90 02		bcc $ad3e			bcc 	_SPFNoBump
.ad3c	e6 27		inc $27				inc 	zBasicSP+1
.ad3e					_SPFNoBump:
.ad3e	a0 00		ldy #$00			ldy 	#0
.ad40	68		pla				pla
.ad41	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad43	7a		ply				ply
.ad44	68		pla				pla
.ad45	60		rts				rts
.ad46					StackPopFrame:
.ad46	48		pha				pha
.ad47	5a		phy				phy
.ad48	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.ad4a	51 26		eor ($26),y			eor 	(zBasicSP),y
.ad4c	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ad4e	d0 12		bne $ad62			bne 	_SPFError 					; mixed structures
.ad50	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.ad52	29 0f		and #$0f			and 	#$0F
.ad54	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ad56	38		sec				sec
.ad57	65 26		adc $26				adc 	zBasicSP
.ad59	85 26		sta $26				sta 	zBasicSP
.ad5b	b0 02		bcs $ad5f			bcs 	_SPFNoBump
.ad5d	c6 27		dec $27				dec 	zBasicSP+1
.ad5f					_SPFNoBump:
.ad5f	7a		ply				ply
.ad60	68		pla				pla
.ad61	60		rts				rts
.ad62					_SPFError:
.ad62	20 de ad	jsr $adde			jsr ERR_Handler
>ad65	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ad6d	72 75 63 74 75 72 65 73 00
.ad76					StackSavePosition:
.ad76	6b		tza				tza
.ad77	5a		phy				phy
.ad78	a0 05		ldy #$05			ldy 	#5
.ad7a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad7c	a0 01		ldy #$01			ldy 	#1
.ad7e	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ad80	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad82	c8		iny				iny
.ad83	a5 17		lda $17				lda 	zCodePtr+1
.ad85	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad87	c8		iny				iny
.ad88	a5 18		lda $18				lda 	zCodePtr+2
.ad8a	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad8c	c8		iny				iny
.ad8d	a5 19		lda $19				lda 	zCodePtr+3
.ad8f	91 26		sta ($26),y			sta 	(zBasicSP),y
.ad91	7a		ply				ply
.ad92	60		rts				rts
.ad93					StackRestorePosition:
.ad93	5a		phy				phy
.ad94	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ad96	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad98	85 16		sta $16				sta 	zCodePtr+0
.ad9a	c8		iny				iny
.ad9b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ad9d	85 17		sta $17				sta 	zCodePtr+1
.ad9f	c8		iny				iny
.ada0	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada2	85 18		sta $18				sta 	zCodePtr+2
.ada4	c8		iny				iny
.ada5	b1 26		lda ($26),y			lda 	(zBasicSP),y
.ada7	85 19		sta $19				sta 	zCodePtr+3
.ada9	c8		iny				iny
.adaa	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.adac	7a		ply				ply 								; restore Y
.adad	4b		taz				taz
.adae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.adaf					SyntaxError:
.adaf	20 de ad	jsr $adde			jsr 	ERR_Handler
>adb2	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>adba	72 72 6f 72 00
.adbf					TypeError:
.adbf	20 de ad	jsr $adde			jsr 	ERR_Handler
>adc2	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>adca	70 65 00
.adcd					BadParamError:
.adcd	20 de ad	jsr $adde			jsr 	ERR_Handler
>add0	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>add8	6d 65 74 65 72 00
.adde					ERR_Handler:
.adde	a3 00		ldz #$00			ldz 	#0
.ade0	1b		inz				inz
.ade1	ea		nop				nop
.ade2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ade4	85 80		sta $80				sta 	XS_Mantissa
.ade6	1b		inz				inz
.ade7	ea		nop				nop
.ade8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adea	85 81		sta $81				sta 	XS_Mantissa+1
.adec	fa		plx				plx 								; address in XY
.aded	7a		ply				ply
.adee	e8		inx				inx 								; bump, because of RTS/JSR address -1
.adef	d0 01		bne $adf2			bne 	_EHNoSkip
.adf1	c8		iny				iny
.adf2					_EHNoSkip:
.adf2	20 11 ae	jsr $ae11			jsr 	PrintROMMessage 			; print message from ROM.
.adf5	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.adf7	05 81		ora $81				ora 	XS_Mantissa+1
.adf9	f0 0c		beq $ae07			beq 	_EHNoLine
.adfb	a2 0c		ldx #$0c			ldx 	#_EHAt & $FF 				; print " at "
.adfd	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.adff	20 11 ae	jsr $ae11			jsr 	PrintROMMessage
.ae02	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ae04	20 22 ae	jsr $ae22			jsr 	Print16BitInteger
.ae07					_EHNoLine:
.ae07	80 fe		bra $ae07			bra 	_EHNoLine
.ae09	4c 7e b0	jmp $b07e			jmp 	WarmStart
>ae0c	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ae11					PrintROMMessage:
.ae11	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ae13	84 1b		sty $1b				sty 	zLTemp1+1
.ae15	a0 00		ldy #$00			ldy 	#0
.ae17					_PRMLoop:
.ae17	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ae19	f0 06		beq $ae21			beq		_PRMExit
.ae1b	c8		iny				iny
.ae1c	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ae1f	80 f6		bra $ae17			bra 	_PRMLoop
.ae21					_PRMExit:
.ae21	60		rts				rts
.ae22					Print16BitInteger:
.ae22	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ae24	85 82		sta $82				sta 	XS_Mantissa+2
.ae26	85 83		sta $83				sta 	XS_Mantissa+3
.ae28	8d 0e 03	sta $030e			sta 	NumBufX 					; reset the conversion pointer
.ae2b	aa		tax				tax 								; convert bottom level.
.ae2c	20 40 c0	jsr $c040			jsr 	INTToString 				; make string
.ae2f	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ae31	bd 0f 03	lda $030f,x	_P1Loop:lda 	Num_Buffer,x
.ae34	f0 06		beq $ae3c			beq 	_P1Exit
.ae36	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ae39	e8		inx				inx
.ae3a	80 f5		bra $ae31			bra 	_P1Loop
.ae3c	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.ae3d					VectorTable:
>ae3d	c5 b4					.word BinaryOp_And         & $FFFF ; $80 and
>ae3f	e1 b4					.word BinaryOp_Or          & $FFFF ; $81 or
>ae41	fd b4					.word BinaryOp_Xor         & $FFFF ; $82 xor
>ae43	fd b4					.word BinaryOp_Eor         & $FFFF ; $83 eor
>ae45	34 b5					.word Binary_Equal         & $FFFF ; $84 =
>ae47	4e b5					.word Binary_NotEqual      & $FFFF ; $85 <>
>ae49	57 b5					.word Binary_Less          & $FFFF ; $86 <
>ae4b	60 b5					.word Binary_LessEqual     & $FFFF ; $87 <=
>ae4d	72 b5					.word Binary_Greater       & $FFFF ; $88 >
>ae4f	69 b5					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>ae51	f7 b5					.word BinaryOp_Add         & $FFFF ; $8a +
>ae53	13 b6					.word BinaryOp_Subtract    & $FFFF ; $8b -
>ae55	24 b6					.word BinaryOp_Multiply    & $FFFF ; $8c *
>ae57	35 b6					.word BinaryOp_Divide      & $FFFF ; $8d /
>ae59	f9 ae					.word NotImplemented       & $FFFF ; $8e ^
>ae5b	f9 ae					.word NotImplemented       & $FFFF ; $8f if
>ae5d	f9 ae					.word NotImplemented       & $FFFF ; $90 while
>ae5f	b4 b1					.word Command_REPEAT       & $FFFF ; $91 repeat
>ae61	f9 ae					.word NotImplemented       & $FFFF ; $92 for
>ae63	f9 ae					.word NotImplemented       & $FFFF ; $93 then
>ae65	f9 ae					.word NotImplemented       & $FFFF ; $94 endif
>ae67	f9 ae					.word NotImplemented       & $FFFF ; $95 wend
>ae69	bd b1					.word Command_UNTIL        & $FFFF ; $96 until
>ae6b	f9 ae					.word NotImplemented       & $FFFF ; $97 next
>ae6d	f9 ae					.word NotImplemented       & $FFFF ; $98 not
>ae6f	f9 ae					.word NotImplemented       & $FFFF ; $99 fn(
>ae71	3a b7					.word Unary_Abs            & $FFFF ; $9a abs(
>ae73	7a b8					.word Unary_Asc            & $FFFF ; $9b asc(
>ae75	2b c7					.word Unary_Int            & $FFFF ; $9c int(
>ae77	54 b7					.word Unary_Peek           & $FFFF ; $9d peek(
>ae79	ac c6					.word Unary_Rnd            & $FFFF ; $9e rnd(
>ae7b	bb b7					.word Unary_Usr            & $FFFF ; $9f usr(
>ae7d	b9 b8					.word Unary_Left           & $FFFF ; $a0 left$(
>ae7f	ce b8					.word Unary_Right          & $FFFF ; $a1 right$(
>ae81	a0 b8					.word Unary_Mid            & $FFFF ; $a2 mid$(
>ae83	17 ba					.word Unary_Spc            & $FFFF ; $a3 spc(
>ae85	48 b8					.word Unary_Str            & $FFFF ; $a4 str$(
>ae87	dc b7					.word Unary_Val            & $FFFF ; $a5 val(
>ae89	91 b8					.word Unary_Len            & $FFFF ; $a6 len(
>ae8b	46 b9					.word Unary_Hex            & $FFFF ; $a7 hex$(
>ae8d	f9 ae					.word NotImplemented       & $FFFF ; $a8 sin(
>ae8f	f9 ae					.word NotImplemented       & $FFFF ; $a9 cos(
>ae91	f9 ae					.word NotImplemented       & $FFFF ; $aa tan(
>ae93	f9 ae					.word NotImplemented       & $FFFF ; $ab atn(
>ae95	f9 ae					.word NotImplemented       & $FFFF ; $ac exp(
>ae97	f9 ae					.word NotImplemented       & $FFFF ; $ad log(
>ae99	f9 ae					.word NotImplemented       & $FFFF ; $ae sqr(
>ae9b	9c b9					.word Unary_Dec            & $FFFF ; $af dec(
>ae9d	58 b7					.word Unary_Deek           & $FFFF ; $b0 deek(
>ae9f	5c b7					.word Unary_Leek           & $FFFF ; $b1 leek(
>aea1	88 b7					.word Unary_Mod            & $FFFF ; $b2 mod(
>aea3	f4 b6					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>aea5	f9 b9					.word Unary_Chr            & $FFFF ; $b4 chr$(
>aea7	f9 ae					.word NotImplemented       & $FFFF ; $b5 pos(
>aea9	f9 ae					.word NotImplemented       & $FFFF ; $b6 tab(
>aeab	f9 ae					.word NotImplemented       & $FFFF ; $b7 $
>aead	f9 ae					.word NotImplemented       & $FFFF ; $b8 $(
>aeaf	f9 ae					.word NotImplemented       & $FFFF ; $b9 #
>aeb1	f9 ae					.word NotImplemented       & $FFFF ; $ba #(
>aeb3	f9 ae					.word NotImplemented       & $FFFF ; $bb %
>aeb5	f9 ae					.word NotImplemented       & $FFFF ; $bc %(
>aeb7	f9 ae					.word NotImplemented       & $FFFF ; $bd (
>aeb9	f9 ae					.word NotImplemented       & $FFFF ; $be )
>aebb	f9 ae					.word NotImplemented       & $FFFF ; $bf ,
>aebd	8d b1					.word Command_COLON        & $FFFF ; $c0 :
>aebf	f9 ae					.word NotImplemented       & $FFFF ; $c1 ;
>aec1	f9 ae					.word NotImplemented       & $FFFF ; $c2 def
>aec3	f1 b2					.word Command_CLR          & $FFFF ; $c3 clr
>aec5	05 b3					.word Command_STOP         & $FFFF ; $c4 stop
>aec7	f9 ae					.word NotImplemented       & $FFFF ; $c5 data
>aec9	f9 ae					.word NotImplemented       & $FFFF ; $c6 read
>aecb	84 b0					.word Command_DIM          & $FFFF ; $c7 dim
>aecd	f9 ae					.word NotImplemented       & $FFFF ; $c8 to
>aecf	f9 ae					.word NotImplemented       & $FFFF ; $c9 step
>aed1	67 b2					.word Command_GOSUB        & $FFFF ; $ca gosub
>aed3	75 b2					.word Command_RETURN       & $FFFF ; $cb return
>aed5	61 b2					.word Command_GOTO         & $FFFF ; $cc goto
>aed7	af b1					.word Command_END          & $FFFF ; $cd end
>aed9	f9 ae					.word NotImplemented       & $FFFF ; $ce input
>aedb	8e b1					.word Command_LET          & $FFFF ; $cf let
>aedd	f9 ae					.word NotImplemented       & $FFFF ; $d0 list
>aedf	f9 ae					.word NotImplemented       & $FFFF ; $d1 new
>aee1	f9 ae					.word NotImplemented       & $FFFF ; $d2 old
>aee3	f9 ae					.word NotImplemented       & $FFFF ; $d3 on
>aee5	f9 ae					.word NotImplemented       & $FFFF ; $d4 restore
>aee7	f9 ae					.word NotImplemented       & $FFFF ; $d5 poke
>aee9	d8 b1					.word Command_PRINT        & $FFFF ; $d6 print
>aeeb	0e b1					.word Command_RUN          & $FFFF ; $d7 run
>aeed	f9 ae					.word NotImplemented       & $FFFF ; $d8 wait
>aeef	f9 ae					.word NotImplemented       & $FFFF ; $d9 sys
>aef1	f9 ae					.word NotImplemented       & $FFFF ; $da doke
>aef3	f9 ae					.word NotImplemented       & $FFFF ; $db loke
>aef5	49 b2					.word Command_ASSERT       & $FFFF ; $dc assert
>aef7	f9 ae					.word NotImplemented       & $FFFF ; $dd get
.aef9					NotImplemented:
.aef9	20 de ad	jsr $adde			jsr ERR_Handler
>aefc	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>af04	65 6d 65 6e 74 65 64 00
.af0c					BinaryPrecedence:
>af0c	01					.byte 1    ; $80 and
>af0d	01					.byte 1    ; $81 or
>af0e	01					.byte 1    ; $82 xor
>af0f	01					.byte 1    ; $83 eor
>af10	02					.byte 2    ; $84 =
>af11	02					.byte 2    ; $85 <>
>af12	02					.byte 2    ; $86 <
>af13	02					.byte 2    ; $87 <=
>af14	02					.byte 2    ; $88 >
>af15	02					.byte 2    ; $89 >=
>af16	03					.byte 3    ; $8a +
>af17	03					.byte 3    ; $8b -
>af18	04					.byte 4    ; $8c *
>af19	04					.byte 4    ; $8d /
>af1a	05					.byte 5    ; $8e ^
.af1b					KeywordText:
>af1b	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>af1e	4f d2					.byte $4f,$d2                          ; $81 or
>af20	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>af23	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>af26	bd					.byte $bd                              ; $84 =
>af27	3c be					.byte $3c,$be                          ; $85 <>
>af29	bc					.byte $bc                              ; $86 <
>af2a	3c bd					.byte $3c,$bd                          ; $87 <=
>af2c	be					.byte $be                              ; $88 >
>af2d	3e bd					.byte $3e,$bd                          ; $89 >=
>af2f	ab					.byte $ab                              ; $8a +
>af30	ad					.byte $ad                              ; $8b -
>af31	aa					.byte $aa                              ; $8c *
>af32	af					.byte $af                              ; $8d /
>af33	de					.byte $de                              ; $8e ^
>af34	49 c6					.byte $49,$c6                          ; $8f if
>af36	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>af3b	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>af41	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>af44	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>af48	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>af4d	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>af51	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>af56	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>af5a	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>af5d	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>af60	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>af64	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>af68	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>af6c	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>af71	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>af75	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>af79	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>af7f	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>af86	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>af8b	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>af8f	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>af94	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>af98	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>af9c	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>afa1	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>afa5	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>afa9	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>afad	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>afb1	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>afb5	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>afb9	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>afbd	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>afc1	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>afc6	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>afcb	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>afcf	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>afd3	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>afd8	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>afdc	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>afe0	a4					.byte $a4                              ; $b7 $
>afe1	24 a8					.byte $24,$a8                          ; $b8 $(
>afe3	a3					.byte $a3                              ; $b9 #
>afe4	23 a8					.byte $23,$a8                          ; $ba #(
>afe6	a5					.byte $a5                              ; $bb %
>afe7	25 a8					.byte $25,$a8                          ; $bc %(
>afe9	a8					.byte $a8                              ; $bd (
>afea	a9					.byte $a9                              ; $be )
>afeb	ac					.byte $ac                              ; $bf ,
>afec	ba					.byte $ba                              ; $c0 :
>afed	bb					.byte $bb                              ; $c1 ;
>afee	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>aff1	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>aff4	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>aff8	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>affc	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b000	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b003	54 cf					.byte $54,$cf                          ; $c8 to
>b005	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b009	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b00e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b014	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b018	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b01b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b020	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b023	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b027	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b02a	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b02d	4f ce					.byte $4f,$ce                          ; $d3 on
>b02f	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b036	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b03a	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b03f	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b042	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b046	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b049	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b04d	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b051	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b057	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b05a	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd

;******  Return to file: modules/basic/core.asm

.b05b					BASIC_Start:
.b05b	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.b05e	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b061	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b063	8d 0a 03	sta $030a			sta 	LocalVector
.b066	8d 06 03	sta $0306			sta 	UserVector
.b069	a9 ca		lda #$ca			lda 	#USRDefault & $FF 			; reset USR vector
.b06b	8d 07 03	sta $0307			sta 	UserVector+1
.b06e	a9 b7		lda #$b7			lda 	#(USRDefault >> 8) & $FF
.b070	8d 08 03	sta $0308			sta 	UserVector+2
.b073	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b075	8d 09 03	sta $0309			sta 	UserVector+3
.b078	20 63 ba	jsr $ba63			jsr 	UpdateProgramEnd 			; update the program end.
.b07b	20 f1 b2	jsr $b2f1			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b07e					WarmStart:
.b07e	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b080	9a		txs				txs
.b081	4c 0e b1	jmp $b10e			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b084					Command_DIM:
.b084	6b		tza				tza
.b085	48		pha				pha 								; push on stack.
.b086	20 c7 bb	jsr $bbc7			jsr 	VariableExtract 			; get the identifier
.b089	ad 8f 03	lda $038f			lda 	Var_Type 					; check it is an array
.b08c	29 01		and #$01			and 	#1
.b08e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b090	d0 6e		bne $b100			bne 	_CDIError
.b092	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b094	8d b1 03	sta $03b1			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b097					_CDIGetDimension:
.b097	ad b1 03	lda $03b1			lda 	UsrArrayIdx 				; done too many ?
.b09a	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b09c	f0 62		beq $b100			beq 	_CDIError
.b09e	20 a6 b4	jsr $b4a6			jsr 	EvaluateInteger 			; evaluate an index size
.b0a1	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b0a3	29 80		and #$80			and 	#$80
.b0a5	05 82		ora $82				ora 	XS_Mantissa+2
.b0a7	05 83		ora $83				ora 	XS_Mantissa+3
.b0a9	d0 55		bne $b100			bne 	_CDIError
.b0ab	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy into the array table.
.b0ae	18		clc				clc 								; add 1 - max index => size.
.b0af	a5 80		lda $80				lda 	XS_Mantissa+0
.b0b1	69 01		adc #$01			adc 	#1
.b0b3	9d a9 03	sta $03a9,x			sta 	UsrArrayDef+0,x
.b0b6	a5 81		lda $81				lda 	XS_Mantissa+1
.b0b8	69 00		adc #$00			adc 	#0
.b0ba	9d aa 03	sta $03aa,x			sta 	UsrArrayDef+1,x
.b0bd	30 41		bmi $b100			bmi 	_CDIError 					; could be dim a(32767)
.b0bf	e8		inx				inx 								; bump index.
.b0c0	e8		inx				inx
.b0c1	8e b1 03	stx $03b1			stx 	UsrArrayIdx
.b0c4	ea		nop				nop
.b0c5	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0c7	1b		inz				inz
.b0c8	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b0ca	f0 cb		beq $b097			beq 	_CDIGetDimension
.b0cc	3b		dez				dez
.b0cd	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; closing ) present ?
.b0d0	ae b1 03	ldx $03b1			ldx 	UsrArrayIdx 				; copy USR array to default
.b0d3	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b0d5	9d a2 03	sta $03a2,x			sta 	ArrayDef+1,x
.b0d8					_CDICopy:
.b0d8	bd a9 03	lda $03a9,x			lda 	UsrArrayDef,x
.b0db	9d a1 03	sta $03a1,x			sta 	ArrayDef,x
.b0de	ca		dex				dex
.b0df	10 f7		bpl $b0d8			bpl 	_CDICopy
.b0e1	68		pla				pla									; position of array identifier
.b0e2	85 10		sta $10				sta 	zTemp1
.b0e4	6b		tza				tza
.b0e5	48		pha				pha
.b0e6	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b0e8	4b		taz				taz
.b0e9	20 c7 bb	jsr $bbc7			jsr 	VariableExtract 			; get the identifier
.b0ec	20 62 be	jsr $be62			jsr 	VariableLocate 				; check if it exists already.
.b0ef	b0 0f		bcs $b100			bcs 	_CDIError
.b0f1	20 55 bc	jsr $bc55			jsr 	VariableCreate 				; create it using the current ArrayDef
.b0f4	68		pla				pla 								; restore code position
.b0f5	4b		taz				taz
.b0f6	ea		nop				nop
.b0f7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b0f9	1b		inz				inz
.b0fa	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b0fc	f0 86		beq $b084			beq 	Command_DIM
.b0fe	3b		dez				dez
.b0ff	60		rts				rts
.b100					_CDIError:
.b100	20 de ad	jsr $adde			jsr ERR_Handler
>b103	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b10b					_CDISyntax:
.b10b	4c af ad	jmp $adaf			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b10e					Command_RUN:
.b10e	20 f1 b2	jsr $b2f1			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b111	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b113	85 16		sta $16				sta 	zCodePtr+0
.b115	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b117	85 17		sta $17				sta 	zCodePtr+1
.b119	a9 02		lda #$02			lda 	#2
.b11b	85 18		sta $18				sta 	zCodePtr+2
.b11d	a9 00		lda #$00			lda 	#0
.b11f	85 19		sta $19				sta 	zCodePtr+3
.b121	a3 03		ldz #$03			ldz 	#3
.b123					RUN_NewLine:
.b123	a3 00		ldz #$00			ldz 	#0
.b125	ea		nop				nop
.b126	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b128	1b		inz				inz
.b129	1b		inz				inz
.b12a	1b		inz				inz
.b12b	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b12d	d0 18		bne $b147			bne 	RUN_NextCommand
.b12f	4c 05 b3	jmp $b305			jmp 	Command_STOP 				; go do the command code.
.b132					RUN_Skip:
.b132	ea		nop				nop
.b133	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.b135	1b		inz				inz 								; skip
.b136	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b138	90 0d		bcc $b147			bcc 	_SEDone 					; so just skip over it.
.b13a	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b13c	90 08		bcc $b146			bcc 	_SEDouble
.b13e	6b		tza				tza 								; this is Y + 1
.b13f	18		clc				clc
.b140	ea		nop				nop
.b141	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.b143	4b		taz				taz 								; back in Y.
.b144	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b145	3b		dez				dez
.b146					_SEDouble:
.b146	1b		inz				inz
.b147					_SEDone:
.b147					RUN_NextCommand:
.b147	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b149	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.b14b	ea		nop				nop
.b14c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b14e	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b150	f0 e0		beq $b132			beq 	RUN_Skip
.b152	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b154	d0 10		bne $b166			bne 	RUN_Execute
.b156					RUN_NextLine:
.b156	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b158	ea		nop				nop
.b159	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b15b	18		clc				clc
.b15c	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b15e	85 16		sta $16				sta 	zCodePtr
.b160	90 02		bcc $b164			bcc 	_SNLNoCarry
.b162	e6 17		inc $17				inc 	zCodePtr+1
.b164					_SNLNoCarry:
.b164	80 bd		bra $b123			bra 	RUN_NewLine 				; go do the new line code
.b166					RUN_Execute:
.b166	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b168	b0 1c		bcs $b186			bcs 	RUN_Extension
.b16a	1b		inz				inz
.b16b	0a		asl a				asl 	a 							; double the character read.
.b16c	90 12		bcc $b180			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b16e	aa		tax				tax 								; ready to look up.
.b16f	bd 3d ae	lda $ae3d,x			lda 	VectorTable,x 				; copy address into LocalVector
.b172	8d 0b 03	sta $030b			sta 	LocalVector+1
.b175	bd 3e ae	lda $ae3e,x			lda 	VectorTable+1,x
.b178	8d 0c 03	sta $030c			sta 	LocalVector+2
.b17b	20 17 b4	jsr $b417			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b17e	80 c7		bra $b147			bra 	RUN_NextCommand 			; do the next command.
.b180					RUN_Default:
.b180	3b		dez				dez
.b181	20 8e b1	jsr $b18e			jsr 	Command_LET 				; and try LET.
.b184	80 c1		bra $b147			bra 	RUN_NextCommand
.b186					RUN_Extension:
.b186	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b188	f0 a8		beq $b132			beq 	RUN_Skip 					; skip over it.
.b18a	4c af ad	jmp $adaf			jmp 	SyntaxError
.b18d					Command_COLON:
.b18d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b18e					Command_LET:
.b18e	20 5c bb	jsr $bb5c			jsr 	VariableFind 				; get reference to one variable.
.b191	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b193	20 9e ba	jsr $ba9e			jsr 	CheckNextToken
.b196	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.b198	48		pha				pha
.b199	a5 23		lda $23				lda 	zVarDataPtr+1
.b19b	48		pha				pha
.b19c	a5 24		lda $24				lda 	zVarType
.b19e	48		pha				pha
.b19f	20 10 b3	jsr $b310			jsr 	EvaluateExpression 			; evaluate the RHS.
.b1a2	68		pla				pla 								; restore target variable information.
.b1a3	85 24		sta $24				sta 	zVarType
.b1a5	68		pla				pla
.b1a6	85 23		sta $23				sta 	zVarDataPtr+1
.b1a8	68		pla				pla
.b1a9	85 22		sta $22				sta 	zVarDataPtr
.b1ab	20 f7 be	jsr $bef7			jsr 	VariableSet 				; set the value out.
.b1ae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b1af					Command_END:
.b1af	80 fe		bra $b1af	_halt:	bra 		_halt
.b1b1	4c 7e b0	jmp $b07e			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/repeat.asm

.b1b4					Command_REPEAT:
.b1b4	20 76 ad	jsr $ad76			jsr 	StackSavePosition			; save position into stack
.b1b7	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b1b9	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; push on stack
.b1bc	60		rts				rts
.b1bd					Command_UNTIL:
.b1bd	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.b1bf	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b1c2	20 a6 b4	jsr $b4a6			jsr 	EvaluateInteger				; work out UNTIL
.b1c5	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.b1c7	05 81		ora $81				ora 	XS_Mantissa+1
.b1c9	05 82		ora $82				ora 	XS_Mantissa+2
.b1cb	05 83		ora $83				ora 	XS_Mantissa+3
.b1cd	d0 08		bne $b1d7			bne 	_CUTExit 					; if not, just exit
.b1cf	20 93 ad	jsr $ad93			jsr 	StackRestorePosition 		; otherwise loop round again.
.b1d2	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.b1d4	20 2f ad	jsr $ad2f			jsr 	StackPushFrame 				; fix the stack back.
.b1d7					_CUTExit:
.b1d7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b1d8					Command_PRINT:
.b1d8	ea		nop				nop
.b1d9	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b1db	c9 00		cmp #$00			cmp 	#0 							; end
.b1dd	f0 66		beq $b245			beq 	_CPR_NewLine
.b1df	c9 c0		cmp #$c0			cmp 	#token_Colon
.b1e1	f0 62		beq $b245			beq 	_CPR_NewLine
.b1e3	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b1e5	f0 50		beq $b237			beq 	_CPR_Skip
.b1e7	c9 bf		cmp #$bf			cmp 	#token_Comma
.b1e9	f0 49		beq $b234			beq 	_CPR_Tab
.b1eb	20 10 b3	jsr $b310			jsr 	EvaluateExpression 			; get expression.
.b1ee	a5 85		lda $85				lda 	XS_Type 					; get type.
.b1f0	29 02		and #$02			and 	#2
.b1f2	d0 24		bne $b218			bne 	_CPR_String 				; if type = 2 output as string.
.b1f4					_CPR_Number:
.b1f4	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b1f6	8d 0e 03	sta $030e			sta 	NumBufX
.b1f9	a5 85		lda $85				lda 	XS_Type 					; get type
.b1fb	4a		lsr a				lsr 	a
.b1fc	b0 05		bcs $b203			bcs 	_CPRInt 					; if msb set do as integer
.b1fe	20 77 c5	jsr $c577			jsr 	FPToString 					; call fp to str otherwise
.b201	80 03		bra $b206			bra 	_CPRNPrint
.b203	20 40 c0	jsr $c040	_CPRInt:jsr 	IntToString
.b206					_CPRNPrint:
.b206	ad 0f 03	lda $030f			lda 	Num_Buffer 					; is first character -
.b209	c9 2d		cmp #$2d			cmp 	#"-"
.b20b	f0 05		beq $b212			beq 	_CPRNoSpace
.b20d	a9 20		lda #$20			lda 	#" "						; print the leading space
.b20f	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.b212					_CPRNoSpace:
.b212	a2 0e		ldx #$0e			ldx 	#(Num_Buffer-1) & $FF
.b214	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b216	80 04		bra $b21c			bra 	_CPRPrint
.b218					_CPR_String:
.b218	a6 80		ldx $80				ldx 	XS_Mantissa
.b21a	a5 81		lda $81				lda 	XS_Mantissa+1
.b21c					_CPRPrint:
.b21c	86 1e		stx $1e				stx 	zGenPtr
.b21e	85 1f		sta $1f				sta 	zGenPtr+1
.b220	5a		phy				phy
.b221	a0 00		ldy #$00			ldy 	#0							; get length into X
.b223	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b225	aa		tax				tax
.b226	f0 09		beq $b231			beq 	_CPREndPrint 				; nothing to print
.b228					_CPRLoop:
.b228	c8		iny				iny
.b229	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b22b	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.b22e	ca		dex				dex
.b22f	d0 f7		bne $b228			bne 	_CPRLoop
.b231					_CPREndPrint:
.b231	7a		ply				ply
.b232	80 a4		bra $b1d8			bra 	Command_Print
.b234					_CPR_Tab:
.b234	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.b237					_CPR_Skip:
.b237	1b		inz				inz
.b238	ea		nop				nop
.b239	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b23b	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b23d	f0 09		beq $b248			beq 	_CPR_Exit
.b23f	c9 00		cmp #$00			cmp 	#0
.b241	d0 95		bne $b1d8			bne 	Command_PRINT 				; if not go round again.
.b243	80 03		bra $b248			bra 	_CPR_Exit
.b245					_CPR_NewLine:
.b245	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.b248					_CPR_Exit:
.b248	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b249					Command_ASSERT:
.b249	20 a6 b4	jsr $b4a6			jsr 	EvaluateInteger 			; calculate thing being asserted
.b24c	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b24e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b250	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b252	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b254	f0 01		beq $b257			beq 	_ASFail
.b256	60		rts				rts
.b257					_ASFail:
.b257	20 de ad	jsr $adde			jsr ERR_Handler
>b25a	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.b261					Command_GOTO:
.b261	20 7e b2	jsr $b27e			jsr 	GotoGetLineNumber
.b264	4c 9b b2	jmp $b29b			jmp 	GotoChangeToLineNumber
.b267					Command_GOSUB:
.b267	20 7e b2	jsr $b27e			jsr 	GotoGetLineNumber
.b26a	20 76 ad	jsr $ad76			jsr 	StackSavePosition
.b26d	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.b26f	20 2f ad	jsr $ad2f			jsr 	StackPushFrame
.b272	4c 9b b2	jmp $b29b			jmp 	GotoChangeToLineNumber
.b275					Command_RETURN:
.b275	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.b277	20 46 ad	jsr $ad46			jsr 	StackPopFrame
.b27a	20 93 ad	jsr $ad93			jsr 	StackRestorePosition
.b27d	60		rts				rts
.b27e					GotoGetLineNumber:
.b27e	20 a6 b4	jsr $b4a6			jsr 	EvaluateInteger
.b281	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.b283	05 83		ora $83				ora 	XS_Mantissa+3
.b285	d0 01		bne $b288			bne 	_GLINError
.b287	60		rts				rts
.b288					_GLINError:
.b288	20 de ad	jsr $adde			jsr ERR_Handler
>b28b	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b293	20 4e 75 6d 62 65 72 00
.b29b					GotoChangeToLineNumber:
.b29b	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.b29d	05 81		ora $81				ora 	XS_Mantissa+1
.b29f	f0 3d		beq $b2de			beq 	_GCTLFail
.b2a1	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b2a3	85 16		sta $16				sta 	zCodePtr+0
.b2a5	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b2a7	85 17		sta $17				sta 	zCodePtr+1
.b2a9	a9 02		lda #$02			lda 	#2
.b2ab	85 18		sta $18				sta 	zCodePtr+2
.b2ad	a9 00		lda #$00			lda 	#0
.b2af	85 19		sta $19				sta 	zCodePtr+3
.b2b1	a3 03		ldz #$03			ldz 	#3
.b2b3					_GCTLLoop:
.b2b3	a3 00		ldz #$00			ldz 	#0
.b2b5	ea		nop				nop
.b2b6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2b8	c9 00		cmp #$00			cmp 	#0
.b2ba	f0 22		beq $b2de			beq 	_GCTLFail
.b2bc	1b		inz				inz
.b2bd	ea		nop				nop
.b2be	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2c0	c5 80		cmp $80				cmp 	XS_Mantissa+0
.b2c2	d0 08		bne $b2cc			bne 	_GCTLNext
.b2c4	1b		inz				inz
.b2c5	ea		nop				nop
.b2c6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b2c8	c5 81		cmp $81				cmp 	XS_Mantissa+1
.b2ca	f0 10		beq $b2dc			beq 	_GCTLExit
.b2cc					_GCTLNext:
.b2cc	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b2ce	ea		nop				nop
.b2cf	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.b2d1	18		clc				clc
.b2d2	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.b2d4	85 16		sta $16				sta 	zCodePtr
.b2d6	90 02		bcc $b2da			bcc 	_SNLNoCarry
.b2d8	e6 17		inc $17				inc 	zCodePtr+1
.b2da					_SNLNoCarry:
.b2da	80 d7		bra $b2b3			bra 	_GCTLLoop 					; try next line.
.b2dc					_GCTLExit:
.b2dc	1b		inz				inz
.b2dd	60		rts				rts
.b2de					_GCTLFail:
.b2de	20 de ad	jsr $adde			jsr ERR_Handler
>b2e1	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>b2e9	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.b2f1					Command_CLR:
.b2f1					ResetRunStatus:
.b2f1	20 98 bb	jsr $bb98			jsr 	VariableClear
.b2f4	20 1d ad	jsr $ad1d			jsr 	StackReset
.b2f7	a9 00		lda #$00			lda 	#HighMemory & $FF
.b2f9	8d 00 03	sta $0300			sta 	StringPtr
.b2fc	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.b2fe	8d 01 03	sta $0301			sta 	StringPtr+1
.b301	20 64 bd	jsr $bd64			jsr 	ArrayResetDefault
.b304	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.b305					Command_STOP:
.b305	20 de ad	jsr $adde			jsr ERR_Handler
>b308	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.b30d					EVESyntax:
.b30d	4c af ad	jmp $adaf			jmp 	SyntaxError
.b310					EvaluateExpression:
.b310	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.b312					EvaluateExpressionX:
.b312	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.b314					EvaluateExpressionXA:
.b314	48		pha				pha 								; save precedence on stack.
.b315	ea		nop				nop
.b316	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b318	f0 f3		beq $b30d			beq 	EVESyntax 					; end of line, syntax error.
.b31a	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.b31c	b0 03		bcs $b321			bcs 	_EVNotVariable
.b31e	4c 0e b4	jmp $b40e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.b321					_EVNotVariable:
.b321	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.b323	90 e8		bcc $b30d			bcc 	EVESyntax
.b325	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.b327	b0 7a		bcs $b3a3			bcs 	_EVNotInteger
.b329	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.b32b	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.b32d	a9 00		lda #$00			lda 	#0
.b32f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b331	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b333	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b335	1a		inc a				inc 	a 							; set to type 1 (integer)
.b336	95 85		sta $85,x			sta 	XS_Type,x
.b338					_EVCheckNextInteger:
.b338	1b		inz				inz
.b339	ea		nop				nop
.b33a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b33c	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.b33e	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.b340	b0 0b		bcs $b34d			bcs 	_EVCheckDecimal
.b342	48		pha				pha 								; save it.
.b343	20 1a b4	jsr $b41a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.b346	68		pla				pla
.b347	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.b349	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b34b	80 eb		bra $b338			bra 	_EVCheckNextInteger
.b34d					_EVCheckDecimal:
.b34d	ea		nop				nop
.b34e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b350	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.b352	d0 05		bne $b359			bne 	_EVGotAtom 					; no, get atom.
.b354					_EVIsDecimal:
.b354	20 3c b4	jsr $b43c			jsr 	EVGetDecimal 				; extend to the decimal part.
.b357	80 00		bra $b359			bra 	_EVGotAtom 					; and continue to got atom.
.b359					_EVGotAtom:
.b359	ea		nop				nop
.b35a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b35c	10 43		bpl $b3a1			bpl 	_EVExitDrop 				; must be a token.
.b35e	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.b360	b0 3f		bcs $b3a1			bcs 	_EVExitDrop
.b362	68		pla				pla 								; get current precedence
.b363	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.b365	da		phx				phx 								; save X
.b366	ea		nop				nop
.b367	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b369	aa		tax				tax 								; put in X
.b36a	bd 8c ae	lda $ae8c,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.b36d	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.b36f	fa		plx				plx 								; restore X
.b370	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.b372	90 2e		bcc $b3a2			bcc 	_EVExit 					; exit if too low.
.b374	f0 2c		beq $b3a2			beq 	_EVExit 					; exit if equals
.b376	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.b378	48		pha				pha
.b379	ea		nop				nop
.b37a	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b37c	48		pha				pha
.b37d	1b		inz				inz
.b37e	da		phx				phx 								; save current position
.b37f	e8		inx				inx
.b380	e8		inx				inx
.b381	e8		inx				inx
.b382	e8		inx				inx
.b383	e8		inx				inx
.b384	e8		inx				inx
.b385	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.b387	20 14 b3	jsr $b314			jsr 	EvaluateExpressionXA 		; do the RHS.
.b38a	fa		plx				plx 								; restore X
.b38b	68		pla				pla 								; get the binary operator in A.
.b38c					_EVCallA:
.b38c	da		phx				phx 								; save X again
.b38d	0a		asl a				asl 	a 							; double, lose the MSB.
.b38e	aa		tax				tax									; put in X
.b38f	bd 3d ae	lda $ae3d,x			lda 	VectorTable,x 				; copy address into zGenPtr
.b392	8d 0b 03	sta $030b			sta 	LocalVector+1
.b395	bd 3e ae	lda $ae3e,x			lda 	VectorTable+1,x
.b398	8d 0c 03	sta $030c			sta 	LocalVector+2
.b39b	fa		plx				plx 								; restore X
.b39c	20 17 b4	jsr $b417			jsr 	EVCallLocalVector
.b39f	80 b8		bra $b359			bra 	_EVGotAtom 					; and loop back.
.b3a1					_EVExitDrop:
.b3a1	68		pla				pla
.b3a2					_EVExit:
.b3a2	60		rts				rts
.b3a3					_EVNotInteger:
.b3a3	1b		inz				inz
.b3a4	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.b3a6	d0 16		bne $b3be			bne 	_EVNotMinus
.b3a8	20 87 b4	jsr $b487			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.b3ab	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b3ad	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b3af	f0 05		beq $b3b6			beq 	_EVMinusFloat
.b3b1	20 23 c0	jsr $c023			jsr 	IntegerNegateAlways 		; negation
.b3b4	80 a3		bra $b359			bra 	_EVGotAtom 					; and go back.
.b3b6					_EVMinusFloat:
.b3b6	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.b3b8	49 80		eor #$80			eor 	#$80
.b3ba	95 85		sta $85,x			sta 	XS_Type,x
.b3bc	80 9b		bra $b359			bra 	_EVGotAtom
.b3be					_EVNotMinus:
.b3be	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.b3c0	d0 18		bne $b3da			bne 	_EVNotParenthesis
.b3c2	20 12 b3	jsr $b312			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.b3c5	ea		nop				nop
.b3c6	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b3c8	1b		inz				inz
.b3c9	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.b3cb	f0 8c		beq $b359			beq 	_EVGotAtom
.b3cd	20 de ad	jsr $adde			jsr ERR_Handler
>b3d0	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>b3d8	29 00
.b3da					_EVNotParenthesis:
.b3da	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.b3dc	d0 0c		bne $b3ea			bne 	_EVNotNot
.b3de	20 87 b4	jsr $b487			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b3e1	20 78 c4	jsr $c478			jsr 	FPUToInteger 				; make it an integer - if possible.
.b3e4	20 6c b4	jsr $b46c			jsr 	NotInteger 					; do the not calculation
.b3e7	4c 59 b3	jmp $b359			jmp 	_EVGotAtom
.b3ea					_EVNotNot:
.b3ea	c9 fe		cmp #$fe			cmp 	#$FE
.b3ec	d0 12		bne $b400			bne 	_EVNotString
.b3ee	20 33 bb	jsr $bb33			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b3f1	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b3f3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b3f5	a5 21		lda $21				lda 	zTempStr+1
.b3f7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b3f9	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b3fb	95 85		sta $85,x			sta 	XS_Type,x
.b3fd	4c 59 b3	jmp $b359			jmp 	_EVGotAtom
.b400					_EVNotString:
.b400	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b402	90 04		bcc $b408			bcc 	_EVBadElement
.b404	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.b406	90 03		bcc $b40b			bcc 	_EVUnaryFunction
.b408					_EVBadElement:
.b408	4c af ad	jmp $adaf			jmp 	SyntaxError
.b40b					_EVUnaryFunction:
.b40b	4c 8c b3	jmp $b38c			jmp 	_EVCallA
.b40e					_EVVariableHandler:
.b40e	20 5c bb	jsr $bb5c			jsr 	VariableFind 				; locate a variable
.b411	20 a6 be	jsr $bea6			jsr 	VariableGet 				; copy into memory.
.b414	4c 59 b3	jmp $b359			jmp 	_EVGotAtom 					; and go round.
.b417					EVCallLocalVector:
.b417	6c 0b 03	jmp ($030b)			jmp 	(LocalVector+1)
.b41a					EVShiftMantissaLeft6:
.b41a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b41c	95 84		sta $84,x			sta 	XS_Exponent,x
.b41e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b420	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b422	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b424	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b426	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b428	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b42a	a9 00		lda #$00			lda 	#0
.b42c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b42e	20 31 b4	jsr $b431			jsr 	_EVSMLShift 					; call it here to do it twice
.b431					_EVSMLShift:
.b431	56 84		lsr $84,x			lsr 	XS_Exponent,x
.b433	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.b435	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.b437	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.b439	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.b43b	60		rts				rts
.b43c					EVGetDecimal:
.b43c	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b43e	8d 0f 03	sta $030f			sta 	Num_Buffer
.b441	da		phx				phx
.b442	1b		inz				inz
.b443	ea		nop				nop
.b444	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b446	1b		inz				inz
.b447	3a		dec a				dec 	a								; convert to a string length.
.b448	3a		dec a				dec 	a
.b449	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b44b					_EVGDCopy:
.b44b	48		pha				pha 									; save count
.b44c	ea		nop				nop
.b44d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b44f	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.b452	e8		inx				inx 									; forward ....
.b453	1b		inz				inz
.b454	68		pla				pla 									; get count
.b455	3a		dec a				dec 	a 								; until zero
.b456	d0 f3		bne $b44b			bne 	_EVGDCopy
.b458	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b45b	fa		plx				plx 									; restore X
.b45c	a9 0f		lda #$0f			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b45e	85 1e		sta $1e				sta 	zGenPtr
.b460	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.b462	85 1f		sta $1f				sta 	zGenPtr+1
.b464	5a		phy				phy 									; save Y
.b465	a0 00		ldy #$00			ldy 	#0 								; start position
.b467	20 32 c6	jsr $c632			jsr 	FPFromString 					; convert current
.b46a	7a		ply				ply 									; restore Y
.b46b	60		rts				rts
.b46c					NotInteger:
.b46c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b46e	49 ff		eor #$ff			eor 	#$FF
.b470	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b472	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b474	49 ff		eor #$ff			eor 	#$FF
.b476	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b478	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b47a	49 ff		eor #$ff			eor 	#$FF
.b47c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b47e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b480	49 ff		eor #$ff			eor 	#$FF
.b482	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b484	60		rts				rts
.b485					EvaluateGetAtom:
.b485	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b487					EvaluateGetAtomX:
.b487	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b489	20 14 b3	jsr $b314			jsr 	EvaluateExpressionXA
.b48c	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b48e	29 0f		and #$0f			and 	#15
.b490	c9 02		cmp #$02			cmp 	#2
.b492	b0 01		bcs $b495			bcs 	EvaluateType
.b494	60		rts				rts
.b495					EvaluateType:
.b495	4c bf ad	jmp $adbf			jmp 	TypeError
.b498					EvaluateNumber:
.b498	a2 00		ldx #$00			ldx 	#0
.b49a					EvaluateNumberX:
.b49a	20 12 b3	jsr $b312			jsr 	EvaluateExpressionX
.b49d	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.b49f	29 0f		and #$0f			and 	#15
.b4a1	c9 02		cmp #$02			cmp 	#2
.b4a3	b0 f0		bcs $b495			bcs 	EvaluateType
.b4a5	60		rts				rts
.b4a6					EvaluateInteger:
.b4a6	a2 00		ldx #$00			ldx 	#0
.b4a8					EvaluateIntegerX:
.b4a8	20 9a b4	jsr $b49a			jsr 	EvaluateNumberX
.b4ab	20 78 c4	jsr $c478			jsr 	FPUToInteger
.b4ae	60		rts				rts
.b4af					EvaluateString:
.b4af	a2 00		ldx #$00			ldx 	#0
.b4b1					EvaluateStringX:
.b4b1	20 12 b3	jsr $b312			jsr 	EvaluateExpressionX
.b4b4	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.b4b6	29 0f		and #$0f			and 	#15
.b4b8	c9 02		cmp #$02			cmp 	#2
.b4ba	d0 d9		bne $b495			bne 	EvaluateType
.b4bc	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b4be	85 1e		sta $1e				sta 	zGenPtr
.b4c0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b4c2	85 1f		sta $1f				sta 	zGenPtr+1
.b4c4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b4c5					BinaryOp_And:
.b4c5	20 19 b5	jsr $b519			jsr 	BinaryMakeBothInteger
.b4c8	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b4ca	35 86		and $86,x			and 	XS2_Mantissa+0,x
.b4cc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b4ce	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b4d0	35 87		and $87,x			and 	XS2_Mantissa+1,x
.b4d2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b4d4	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b4d6	35 88		and $88,x			and 	XS2_Mantissa+2,x
.b4d8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b4da	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b4dc	35 89		and $89,x			and 	XS2_Mantissa+3,x
.b4de	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b4e0	60		rts				rts
.b4e1					BinaryOp_Or:
.b4e1	20 19 b5	jsr $b519			jsr 	BinaryMakeBothInteger
.b4e4	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b4e6	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.b4e8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b4ea	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b4ec	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.b4ee	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b4f0	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b4f2	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.b4f4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b4f6	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b4f8	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.b4fa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b4fc	60		rts				rts
.b4fd					BinaryOp_Eor:
.b4fd					BinaryOp_Xor:
.b4fd	20 19 b5	jsr $b519			jsr 	BinaryMakeBothInteger
.b500	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.b502	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.b504	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b506	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.b508	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.b50a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b50c	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.b50e	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.b510	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b512	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.b514	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.b516	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b518	60		rts				rts
.b519					BinaryMakeBothInteger:
.b519	da		phx				phx 								; save X
.b51a	e8		inx				inx
.b51b	e8		inx				inx
.b51c	e8		inx				inx
.b51d	e8		inx				inx
.b51e	e8		inx				inx
.b51f	e8		inx				inx
.b520	20 24 b5	jsr $b524			jsr 	BinaryMakeInteger 			; convert to integer.
.b523	fa		plx				plx 								; restore X and fall through.
.b524					BinaryMakeInteger:
.b524	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b526	29 0f		and #$0f			and 	#15 						; check type zero
.b528	f0 04		beq $b52e			beq 	_BMIConvert 				; if float convert to integer.
.b52a	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b52b	90 04		bcc $b531			bcc 	_BMIError
.b52d	60		rts				rts
.b52e					_BMIConvert:
.b52e	4c 78 c4	jmp $c478			jmp 	FPUToInteger 				; convert to integer
.b531					_BMIError:
.b531	4c bf ad	jmp $adbf			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b534					Binary_Equal:
.b534	20 7b b5	jsr $b57b			jsr 	CompareValues
.b537	09 00		ora #$00			ora 	#0
.b539	f0 04		beq $b53f			beq 	CCTrue
.b53b	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b53d	80 02		bra $b541			bra 	CCWrite
.b53f	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b541	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b543	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b545	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b547	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b549	a9 01		lda #$01			lda 	#1
.b54b	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.b54d	60		rts				rts
.b54e					Binary_NotEqual:
.b54e	20 7b b5	jsr $b57b			jsr 	CompareValues
.b551	09 00		ora #$00			ora 	#0
.b553	f0 e6		beq $b53b			beq 	CCFalse
.b555	80 e8		bra $b53f			bra 	CCTrue
.b557					Binary_Less:
.b557	20 7b b5	jsr $b57b			jsr 	CompareValues
.b55a	09 00		ora #$00			ora 	#0
.b55c	30 e1		bmi $b53f			bmi 	CCTrue
.b55e	80 db		bra $b53b			bra 	CCFalse
.b560					Binary_LessEqual:
.b560	20 7b b5	jsr $b57b			jsr 	CompareValues
.b563	c9 01		cmp #$01			cmp 	#1
.b565	d0 d8		bne $b53f			bne 	CCTrue
.b567	80 d2		bra $b53b			bra 	CCFalse
.b569					Binary_GreaterEqual:
.b569	20 7b b5	jsr $b57b			jsr 	CompareValues
.b56c	09 00		ora #$00			ora 	#0
.b56e	10 cf		bpl $b53f			bpl 	CCTrue
.b570	80 c9		bra $b53b			bra 	CCFalse
.b572					Binary_Greater:
.b572	20 7b b5	jsr $b57b			jsr 	CompareValues
.b575	c9 01		cmp #$01			cmp 	#1
.b577	f0 c6		beq $b53f			beq 	CCTrue
.b579	80 c0		bra $b53b			bra 	CCFalse
.b57b					CompareValues:
.b57b	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.b57d	35 8b		and $8b,x			and 	XS2_Type,x
.b57f	c9 02		cmp #$02			cmp 	#2
.b581	f0 11		beq $b594			beq 	_CVString
.b583	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b585	35 8b		and $8b,x			and 	XS2_Type,x
.b587	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b588	90 03		bcc $b58d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b58a	4c d6 b5	jmp $b5d6			jmp 	CompareInteger32 							; so execute code at \1
.b58d					_BCFloat:
.b58d	20 7a b6	jsr $b67a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b590	4c ae c3	jmp $c3ae			jmp 	FPCompare 							; and execute code at \2
.b593	60		rts				rts
.b594					_CVString:
.b594	da		phx				phx 								; save XY
.b595	5a		phy				phy
.b596	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b598	85 1a		sta $1a				sta		zLTemp1+0
.b59a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b59c	85 1b		sta $1b				sta 	zLTemp1+1
.b59e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b5a0	85 1c		sta $1c				sta 	zLTemp1+2
.b5a2	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b5a4	85 1d		sta $1d				sta 	zLTemp1+3
.b5a6	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b5a8	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b5aa	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b5ac	90 02		bcc $b5b0			bcc 	_CVCommon
.b5ae	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b5b0					_CVCommon:
.b5b0	aa		tax				tax 								; put shorter string length in zero.
.b5b1	f0 0c		beq $b5bf			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b5b3					_CVCompare:
.b5b3	c8		iny				iny 								; next character
.b5b4	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b5b6	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b5b8	90 13		bcc $b5cd			bcc 	_CVReturnLess 				; <
.b5ba	d0 15		bne $b5d1			bne 	_CVReturnGreater 			; >
.b5bc	ca		dex				dex 								; until common length matched.
.b5bd	d0 f4		bne $b5b3			bne 	_CVCompare
.b5bf					_CVMatch:
.b5bf	a0 00		ldy #$00			ldy 	#0
.b5c1	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b5c3	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b5c5	90 06		bcc $b5cd			bcc 	_CVReturnLess 				; <
.b5c7	d0 08		bne $b5d1			bne 	_CVReturnGreater 			; >
.b5c9	a9 00		lda #$00			lda 	#0
.b5cb	80 06		bra $b5d3			bra 	_CVExit 					; same common, same length, same string
.b5cd					_CVReturnLess:
.b5cd	a9 ff		lda #$ff			lda 	#$FF
.b5cf	80 02		bra $b5d3			bra 	_CVExit
.b5d1					_CVReturnGreater:
.b5d1	a9 01		lda #$01			lda 	#$01
.b5d3					_CVExit:
.b5d3	7a		ply				ply
.b5d4	fa		plx				plx
.b5d5	60		rts				rts
.b5d6					CompareInteger32:
.b5d6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b5d8	49 80		eor #$80			eor 	#$80
.b5da	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b5dc	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.b5de	49 80		eor #$80			eor 	#$80
.b5e0	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.b5e2	20 60 b6	jsr $b660			jsr 	SubInteger32 				; subtraction
.b5e5	90 0d		bcc $b5f4			bcc 	_CI32Less 					; cc return -1
.b5e7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.b5e9	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b5eb	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b5ed	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b5ef	f0 02		beq $b5f3			beq 	_CI32Exit
.b5f1	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b5f3					_CI32Exit:
.b5f3	60		rts				rts
.b5f4					_CI32Less:
.b5f4	a9 ff		lda #$ff			lda 	#$FF
.b5f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b5f7					BinaryOp_Add:
.b5f7	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.b5f9	35 8b		and $8b,x			and 	XS2_Type,x
.b5fb	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b5fd	d0 11		bne $b610			bne 	_BOAString
.b5ff	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b601	35 8b		and $8b,x			and 	XS2_Type,x
.b603	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b604	90 03		bcc $b609			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b606	4c 46 b6	jmp $b646			jmp 	AddInteger32 							; so execute code at \1
.b609					_BCFloat:
.b609	20 7a b6	jsr $b67a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b60c	4c 89 c1	jmp $c189			jmp 	FPAdd 							; and execute code at \2
.b60f	60		rts				rts
.b610					_BOAString:
.b610	4c 94 b6	jmp $b694			jmp 	ConcatenateString 			; concatenate two strings.
.b613					BinaryOp_Subtract:
.b613	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b615	35 8b		and $8b,x			and 	XS2_Type,x
.b617	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b618	90 03		bcc $b61d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b61a	4c 60 b6	jmp $b660			jmp 	SubInteger32 							; so execute code at \1
.b61d					_BCFloat:
.b61d	20 7a b6	jsr $b67a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b620	4c 81 c1	jmp $c181			jmp 	FPSubtract 							; and execute code at \2
.b623	60		rts				rts
.b624					BinaryOp_Multiply:
.b624	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b626	35 8b		and $8b,x			and 	XS2_Type,x
.b628	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b629	90 03		bcc $b62e			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b62b	4c 5e bf	jmp $bf5e			jmp 	MulInteger32 							; so execute code at \1
.b62e					_BCFloat:
.b62e	20 7a b6	jsr $b67a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b631	4c b0 c2	jmp $c2b0			jmp 	FPMultiply 							; and execute code at \2
.b634	60		rts				rts
.b635					BinaryOp_Divide:
.b635	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b637	35 8b		and $8b,x			and 	XS2_Type,x
.b639	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b63a	90 03		bcc $b63f			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b63c	4c 9c bf	jmp $bf9c			jmp 	DivInteger32 							; so execute code at \1
.b63f					_BCFloat:
.b63f	20 7a b6	jsr $b67a			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b642	4c 3d c2	jmp $c23d			jmp 	FPDivide 							; and execute code at \2
.b645	60		rts				rts
.b646					AddInteger32:
.b646	18		clc				clc
.b647	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b649	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.b64b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b64d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b64f	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.b651	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b653	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b655	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.b657	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b659	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b65b	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.b65d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b65f	60		rts				rts
.b660					SubInteger32:
.b660	38		sec				sec
.b661	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b663	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.b665	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b667	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b669	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.b66b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b66d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b66f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.b671	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b673	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b675	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.b677	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b679	60		rts				rts
.b67a					BinaryMakeBothFloat:
.b67a	da		phx				phx 								; save X
.b67b	e8		inx				inx
.b67c	e8		inx				inx
.b67d	e8		inx				inx
.b67e	e8		inx				inx
.b67f	e8		inx				inx
.b680	e8		inx				inx
.b681	20 85 b6	jsr $b685			jsr 	BinaryMakeFloat 			; convert to float.
.b684	fa		plx				plx 								; restore X and fall through.
.b685					BinaryMakeFloat:
.b685	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.b687	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b688	b0 04		bcs $b68e			bcs 	_BMFConvert
.b68a	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b68b	b0 04		bcs $b691			bcs 	_BMFError
.b68d	60		rts				rts
.b68e					_BMFConvert:
.b68e	4c 2c c4	jmp $c42c			jmp 	FPUToFloat 					; convert to float
.b691					_BMFError:
.b691	4c bf ad	jmp $adbf			jmp 	TypeError
.b694					ConcatenateString:
.b694	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b696	85 1a		sta $1a				sta		zLTemp1+0
.b698	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b69a	85 1b		sta $1b				sta 	zLTemp1+1
.b69c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.b69e	85 1c		sta $1c				sta 	zLTemp1+2
.b6a0	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b6a2	85 1d		sta $1d				sta 	zLTemp1+3
.b6a4	5a		phy				phy
.b6a5	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b6a7	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b6a9	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b6ab	7a		ply				ply
.b6ac	b0 33		bcs $b6e1			bcs 	_CSError					; check in range.
.b6ae	c9 fe		cmp #$fe			cmp 	#maxString+1
.b6b0	b0 2f		bcs $b6e1			bcs 	_CSError
.b6b2	20 f8 ba	jsr $baf8			jsr 	AllocateTempString 			; store the result
.b6b5	20 cc b6	jsr $b6cc			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b6b8	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b6ba	85 1a		sta $1a				sta 	zLTemp1
.b6bc	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.b6be	85 1b		sta $1b				sta 	zLTemp1+1
.b6c0	20 cc b6	jsr $b6cc			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b6c3	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b6c5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b6c7	a5 21		lda $21				lda 	zTempStr+1
.b6c9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b6cb	60		rts				rts
.b6cc					_CSCopyString:
.b6cc	da		phx				phx
.b6cd	5a		phy				phy
.b6ce	a0 00		ldy #$00			ldy 	#0 							; get length
.b6d0	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b6d2	f0 0a		beq $b6de			beq 	_CSCSExit 					; if zero, exit
.b6d4	aa		tax				tax 								; put in X
.b6d5					_CSCSLoop:
.b6d5	c8		iny				iny 								; get next char
.b6d6	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b6d8	20 23 bb	jsr $bb23			jsr		WriteTempString 			; copy out
.b6db	ca		dex				dex 								; do whole string
.b6dc	d0 f7		bne $b6d5			bne 	_CSCSLoop
.b6de					_CSCSExit:
.b6de	7a		ply				ply
.b6df	fa		plx				plx
.b6e0	60		rts				rts
.b6e1					_CSError:
.b6e1	20 de ad	jsr $adde			jsr ERR_Handler
>b6e4	53 74 72 69 6e 67 20 74			.text "String too long",0
>b6ec	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b6f4					Unary_Sgn:
.b6f4	20 9a b4	jsr $b49a			jsr 	EvaluateNumberX 			; get value
.b6f7	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; check right bracket.
.b6fa	20 18 b7	jsr $b718			jsr 	GetSignCurrent 				; get sign.
.b6fd	09 00		ora #$00			ora 	#0
.b6ff	10 08		bpl $b709			bpl		UnarySetAInteger			; if 0,1 return that.
.b701	80 00		bra $b703			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b703					UnarySetAMinus1:
.b703	a9 ff		lda #$ff			lda 	#$FF
.b705	95 80		sta $80,x			sta 	XS_Mantissa,x
.b707	80 04		bra $b70d			bra 	UnarySetAFill
.b709					UnarySetAInteger:
.b709	95 80		sta $80,x			sta 	XS_Mantissa,x
.b70b	a9 00		lda #$00			lda 	#0
.b70d					UnarySetAFill:
.b70d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b70f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b711	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b713	a9 01		lda #$01			lda 	#1
.b715	95 85		sta $85,x			sta 	XS_Type,x
.b717	60		rts				rts
.b718					GetSignCurrent:
.b718	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.b71a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b71b	90 15		bcc $b732			bcc 	_GSCFloat
.b71d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b71f	30 0e		bmi $b72f			bmi 	_GSCMinus1
.b721	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.b723	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b725	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b727	d0 03		bne $b72c			bne 	_GSCPlus1
.b729					_GSCZero:
.b729	a9 00		lda #$00			lda 	#0
.b72b	60		rts				rts
.b72c					_GSCPlus1:
.b72c	a9 01		lda #$01			lda 	#$01
.b72e	60		rts				rts
.b72f					_GSCMinus1:
.b72f	a9 ff		lda #$ff			lda 	#$FF
.b731	60		rts				rts
.b732					_GSCFloat:
.b732	34 85		bit $85,x			bit 	XS_Type,x
.b734	70 f3		bvs $b729			bvs 	_GSCZero
.b736	30 f7		bmi $b72f			bmi 	_GSCMinus1
.b738	80 f2		bra $b72c			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b73a					Unary_Abs:
.b73a	20 9a b4	jsr $b49a			jsr 	EvaluateNumberX 			; get value
.b73d	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; check right bracket.
.b740	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b742	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b744	f0 07		beq $b74d			beq 	_UAMinusFloat
.b746	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.b748	10 09		bpl $b753			bpl 	_UAExit
.b74a	4c 23 c0	jmp $c023			jmp 	IntegerNegateAlways 		; negation
.b74d					_UAMinusFloat:
.b74d	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.b74f	29 7f		and #$7f			and		#$7F
.b751	95 85		sta $85,x			sta 	XS_Type,x
.b753					_UAExit:
.b753	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b754					Unary_Peek:
.b754	a9 01		lda #$01			lda 	#1
.b756	80 06		bra $b75e			bra 	UPMain
.b758					Unary_Deek:
.b758	a9 02		lda #$02			lda 	#2
.b75a	80 02		bra $b75e			bra 	UPMain
.b75c					Unary_Leek:
.b75c	a9 04		lda #$04			lda 	#4
.b75e					UPMain:
.b75e	48		pha				pha 								; set bytes to copy.
.b75f	20 a8 b4	jsr $b4a8			jsr 	EvaluateIntegerX 			; numeric parameter
.b762	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b765	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b767	85 1a		sta $1a				sta 	zLTemp1
.b769	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b76b	85 1b		sta $1b				sta 	zLTemp1+1
.b76d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b76f	85 1c		sta $1c				sta 	zLTemp1+2
.b771	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.b773	85 1d		sta $1d				sta 	zLTemp1+3
.b775	a9 00		lda #$00			lda 	#0 							; clear target area
.b777	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b779	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b77b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b77d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b77f	68		pla				pla 								; restore bytes to copy
.b780	da		phx				phx 								; save XY
.b781	5a		phy				phy
.b782	20 4f ba	jsr $ba4f			jsr 	MemRead 					; read the bytes in
.b785	7a		ply				ply 								; restore and exit
.b786	fa		plx				plx
.b787	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b788					Unary_Mod:
.b788	20 b0 b7	jsr $b7b0			jsr 	_UMParameter 				; first parameter
.b78b	20 bf ba	jsr $babf			jsr 	CheckNextComma
.b78e	da		phx				phx 								; second parameter
.b78f	e8		inx				inx
.b790	e8		inx				inx
.b791	e8		inx				inx
.b792	e8		inx				inx
.b793	e8		inx				inx
.b794	e8		inx				inx
.b795	20 b0 b7	jsr $b7b0			jsr 	_UMParameter
.b798	fa		plx				plx
.b799	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen
.b79c	20 9c bf	jsr $bf9c			jsr 	DivInteger32 				; divide
.b79f	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b7a1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b7a3	a5 1b		lda $1b				lda 	zLTemp1+1
.b7a5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b7a7	a5 1c		lda $1c				lda 	zLTemp1+2
.b7a9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b7ab	a5 1d		lda $1d				lda 	zLTemp1+3
.b7ad	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b7af	60		rts				rts
.b7b0					_UMParameter:
.b7b0	20 a8 b4	jsr $b4a8			jsr 	EvaluateIntegerX 			; get value
.b7b3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.b7b5	10 03		bpl $b7ba			bpl 	_UMNotSigned
.b7b7	20 23 c0	jsr $c023			jsr 	IntegerNegateAlways
.b7ba					_UMNotSigned:
.b7ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b7bb					Unary_Usr:
.b7bb	20 9a b4	jsr $b49a			jsr 	EvaluateNumberX 			; numeric parameter
.b7be	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b7c1	da		phx				phx 								; save XY
.b7c2	5a		phy				phy
.b7c3	ea		nop				nop
.b7c4	20 06 03	jsr $0306			jsr 	UserVector 					; call the USR function.
.b7c7	7a		ply				ply 								; and exit
.b7c8	fa		plx				plx
.b7c9	60		rts				rts
.b7ca					USRDefault:
.b7ca	20 de ad	jsr $adde			jsr ERR_Handler
>b7cd	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b7d5	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b7dc					Unary_Val:
.b7dc	20 b1 b4	jsr $b4b1			jsr 	EvaluateStringX 			; get string
.b7df	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; check right bracket.
.b7e2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b7e4	85 1e		sta $1e				sta 	zGenPtr
.b7e6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b7e8	85 1f		sta $1f				sta 	zGenPtr+1
.b7ea	5a		phy				phy
.b7eb	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b7ed	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b7ef	f0 54		beq $b845			beq 	_UVBadNumber
.b7f1	48		pha				pha 								; save length.
.b7f2	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b7f3	1a		inc a				inc 	a
.b7f4	20 f8 ba	jsr $baf8			jsr 	AllocateTempString
.b7f7	c8		iny				iny 								; move to the next.
.b7f8	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b7fa	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b7fc	8d 9a 03	sta $039a			sta 	ValSign
.b7ff	d0 04		bne $b805			bne 	_UVNotMinus
.b801	c8		iny				iny 								; skip over it.
.b802	68		pla				pla 								; decrement character count.
.b803	3a		dec a				dec 	a
.b804	48		pha				pha
.b805					_UVNotMinus:
.b805	68		pla				pla 								; this is the count.
.b806	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b807	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b809	c8		iny				iny
.b80a	20 23 bb	jsr $bb23			jsr 	WriteTempString
.b80d	68		pla				pla
.b80e	3a		dec a				dec 	a
.b80f	d0 f5		bne $b806			bne 	_UVCopy
.b811	20 23 bb	jsr $bb23			jsr 	WriteTempString 			; make it ASCIIZ
.b814	18		clc				clc
.b815	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b817	69 01		adc #$01			adc 	#1
.b819	85 1e		sta $1e				sta 	zGenPtr
.b81b	a5 21		lda $21				lda 	zTempStr+1
.b81d	69 00		adc #$00			adc 	#0
.b81f	85 1f		sta $1f				sta 	zGenPtr+1
.b821	18		clc				clc
.b822	20 f1 c0	jsr $c0f1			jsr 	IntFromString 				; first bit.
.b825	b0 1e		bcs $b845			bcs 	_UVBadNumber
.b827	20 32 c6	jsr $c632			jsr 	FPFromString				; try for a float part.
.b82a	ad 9a 03	lda $039a			lda 	ValSign 					; was it negative
.b82d	d0 10		bne $b83f			bne 	_UVNotNegative
.b82f	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.b831	4a		lsr a				lsr 	a
.b832	b0 08		bcs $b83c			bcs 	_UVInteger
.b834	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.b836	09 80		ora #$80			ora 	#$80
.b838	95 85		sta $85,x			sta 	XS_Type,x
.b83a	80 03		bra $b83f			bra 	_UVNotNegative
.b83c					_UVInteger:
.b83c	20 23 c0	jsr $c023			jsr 	IntegerNegateAlways 		; sign it.
.b83f					_UVNotNegative:
.b83f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b841	d0 02		bne $b845			bne 	_UVBadNumber
.b843	7a		ply				ply
.b844	60		rts				rts
.b845					_UVBadNumber:
.b845	4c cd ad	jmp $adcd			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b848					Unary_Str:
.b848	20 9a b4	jsr $b49a			jsr 	EvaluateNumberX 			; numeric parameter
.b84b	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b84e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b850	8d 0e 03	sta $030e			sta 	NumBufX
.b853	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.b855	4a		lsr a				lsr 	a
.b856	b0 05		bcs $b85d			bcs 	_USInt 						; if msb set do as integer
.b858	20 77 c5	jsr $c577			jsr 	FPToString 					; call fp to str otherwise
.b85b	80 03		bra $b860			bra 	_USDuplicate
.b85d	20 40 c0	jsr $c040	_USInt:	jsr 	IntToString
.b860					_USDuplicate:
.b860	ad 0e 03	lda $030e			lda 	NumBufX 					; chars in buffer
.b863	1a		inc a				inc 	a 							; one more for length
.b864	20 f8 ba	jsr $baf8			jsr 	AllocateTempString 			; allocate space for it.
.b867	5a		phy				phy 								; save Y
.b868	a0 00		ldy #$00			ldy 	#0 							; start copying
.b86a	b9 0f 03	lda $030f,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b86d	20 23 bb	jsr $bb23			jsr 	WriteTempString
.b870	c8		iny				iny
.b871	cc 0e 03	cpy $030e			cpy 	NumBufX 					; done the lot
.b874	d0 f4		bne $b86a			bne 	_USCopy
.b876	7a		ply				ply 								; restore Y
.b877	4c 42 ba	jmp $ba42			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b87a					Unary_Asc:
.b87a	20 b1 b4	jsr $b4b1			jsr 	EvaluateStringX 			; string parameter
.b87d	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b880	5a		phy				phy 								; get the string length
.b881	a0 00		ldy #$00			ldy 	#0
.b883	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b885	f0 07		beq $b88e			beq 	_UAIllegal 					; must be at least one character
.b887	c8		iny				iny
.b888	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b88a	7a		ply				ply
.b88b	4c 09 b7	jmp $b709			jmp 	UnarySetAInteger
.b88e					_UAIllegal:
.b88e	4c cd ad	jmp $adcd			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b891					Unary_Len:
.b891	20 b1 b4	jsr $b4b1			jsr 	EvaluateStringX 			; string parameter
.b894	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b897	5a		phy				phy 								; get the string length
.b898	a0 00		ldy #$00			ldy 	#0
.b89a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b89c	7a		ply				ply
.b89d	4c 09 b7	jmp $b709			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b8a0					Unary_Mid:
.b8a0	20 b1 b4	jsr $b4b1			jsr 	EvaluateStringX 				; get string.
.b8a3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b8a5	48		pha				pha
.b8a6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b8a8	48		pha				pha
.b8a9	20 bf ba	jsr $babf			jsr 	CheckNextComma 					; skip comma
.b8ac	20 35 b9	jsr $b935			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b8af	48		pha				pha 									; and push it.
.b8b0	20 bf ba	jsr $babf			jsr 	CheckNextComma 					; skip comma
.b8b3	20 35 b9	jsr $b935			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b8b6	48		pha				pha 									; and push it.
.b8b7	80 41		bra $b8fa			bra 	SLIProcess
.b8b9					Unary_Left:
.b8b9	20 b1 b4	jsr $b4b1			jsr 	EvaluateStringX 				; get string.
.b8bc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b8be	48		pha				pha
.b8bf	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b8c1	48		pha				pha
.b8c2	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b8c4	48		pha				pha
.b8c5	20 bf ba	jsr $babf			jsr 	CheckNextComma 					; skip comma
.b8c8	20 35 b9	jsr $b935			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b8cb	48		pha				pha 									; and push it.
.b8cc	80 2c		bra $b8fa			bra 	SLIProcess
.b8ce					Unary_Right:
.b8ce	20 b1 b4	jsr $b4b1			jsr 	EvaluateStringX 				; get string.
.b8d1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b8d3	48		pha				pha
.b8d4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b8d6	48		pha				pha
.b8d7	da		phx				phx 									; get the string length and push on stack.
.b8d8	a2 00		ldx #$00			ldx 	#0
.b8da	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b8dc	fa		plx				plx
.b8dd	48		pha				pha
.b8de	20 bf ba	jsr $babf			jsr 	CheckNextComma 					; skip comma
.b8e1	20 35 b9	jsr $b935			jsr 	SLIByteParameter 				; get a byte parameter.
.b8e4	8d 98 03	sta $0398			sta 	SignCount 						; save in temporary.
.b8e7	68		pla				pla 									; restore string length.
.b8e8	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b8e9	38		sec				sec
.b8ea	ed 98 03	sbc $0398			sbc 	SignCount 						; subtract characters needed, gives start position.
.b8ed	f0 02		beq $b8f1			beq 	_URStart 						; if <= 0 start from 1.
.b8ef	10 02		bpl $b8f3			bpl 	_UROkay
.b8f1					_URStart:
.b8f1	a9 01		lda #$01			lda 	#1
.b8f3					_UROkay:
.b8f3	48		pha				pha 									; push start
.b8f4	ad 98 03	lda $0398			lda 	SignCount 						; push count of characters
.b8f7	48		pha				pha
.b8f8	80 00		bra $b8fa			bra 	SLIProcess
.b8fa					SLIProcess:
.b8fa	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 				; closing right bracket.
.b8fd	68		pla				pla
.b8fe	8d 9c 03	sta $039c			sta 	SliceCount 						; count in signcount
.b901	1a		inc a				inc 	a 								; allocate +1 for it.
.b902	20 f8 ba	jsr $baf8			jsr 	AllocateTempString
.b905	68		pla				pla 									; pop start number off stack.
.b906	f0 3b		beq $b943			beq 	SLIError 						; exit if start = 0
.b908	8d 9b 03	sta $039b			sta 	SliceStart
.b90b	68		pla				pla  									; pop string address.
.b90c	85 1f		sta $1f				sta 	zGenPtr+1
.b90e	68		pla				pla
.b90f	85 1e		sta $1e				sta 	zGenPtr
.b911	da		phx				phx
.b912	5a		phy				phy
.b913	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b915	ac 9b 03	ldy $039b			ldy 	SliceStart 						; start of the string (+1 for count)
.b918					_SLICopy:
.b918	ad 9c 03	lda $039c			lda 	SliceCount 						; done count characters
.b91b	f0 12		beq $b92f			beq 	_SLIExit
.b91d	ce 9c 03	dec $039c			dec 	SliceCount
.b920	98		tya				tya 									; index of character
.b921	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b923	f0 02		beq $b927			beq 	_SLIOk 							; if equal, okay.
.b925	b0 08		bcs $b92f			bcs 	_SLIExit 						; if past end, then exit.
.b927	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b929	c8		iny				iny
.b92a	20 23 bb	jsr $bb23			jsr 	WriteTempString
.b92d	80 e9		bra $b918			bra 	_SLICopy 						; go round till copied characters
.b92f					_SLIExit:
.b92f	7a		ply				ply 									; restore YX
.b930	fa		plx				plx
.b931	4c 42 ba	jmp $ba42			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b934	ea		nop				nop
.b935					SLIByteParameter:
.b935	20 a8 b4	jsr $b4a8			jsr 	EvaluateIntegerX 				; get integer
.b938	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b93a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b93c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b93e	d0 03		bne $b943			bne 	SLIError
.b940	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b942	60		rts				rts
.b943					SLIError:
.b943	4c cd ad	jmp $adcd			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b946					Unary_Hex:
.b946	20 a8 b4	jsr $b4a8			jsr 	EvaluateIntegerX 			; numeric parameter
.b949	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b94c	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b94e	20 f8 ba	jsr $baf8			jsr 	AllocateTempString			; allocate string space
.b951	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b953	20 77 b9	jsr $b977			jsr 	_UHConvert
.b956	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.b958	20 77 b9	jsr $b977			jsr 	_UHConvert
.b95b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.b95d	20 77 b9	jsr $b977			jsr 	_UHConvert
.b960	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.b962	20 77 b9	jsr $b977			jsr 	_UHConvert
.b965	5a		phy				phy 								; get length of new string
.b966	a0 00		ldy #$00			ldy 	#0
.b968	b1 20		lda ($20),y			lda 	(zTempStr),y
.b96a	7a		ply				ply
.b96b	c9 00		cmp #$00			cmp 	#0
.b96d	d0 05		bne $b974			bne 	_UHExit 					; if it was non zero okay
.b96f	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b971	20 23 bb	jsr $bb23			jsr 	WriteTempString
.b974					_UHExit:
.b974	4c 42 ba	jmp $ba42			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b977					_UHConvert:
.b977	48		pha				pha
.b978	4a		lsr a				lsr 	a 							; do MSB
.b979	4a		lsr a				lsr 	a
.b97a	4a		lsr a				lsr 	a
.b97b	4a		lsr a				lsr 	a
.b97c	20 80 b9	jsr $b980			jsr 	_UHNibble
.b97f	68		pla				pla 								; do LSB
.b980					_UHNibble:
.b980	29 0f		and #$0f			and 	#15 						; get nibble
.b982	d0 0c		bne $b990			bne 	_UHNonZero
.b984	5a		phy				phy									; get the length
.b985	a0 00		ldy #$00			ldy 	#0
.b987	b1 20		lda ($20),y			lda 	(zTempStr),y
.b989	7a		ply				ply
.b98a	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b98c	f0 0d		beq $b99b			beq 	_UHExit2
.b98e	a9 00		lda #$00			lda 	#0
.b990					_UHNonZero:
.b990	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b992	90 02		bcc $b996			bcc 	_UHDigit
.b994	69 06		adc #$06			adc 	#7-1
.b996					_UHDigit:
.b996	69 30		adc #$30			adc 	#48
.b998	20 23 bb	jsr $bb23			jsr 	WriteTempString				; output.
.b99b					_UHExit2:
.b99b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b99c					Unary_Dec:
.b99c	20 b1 b4	jsr $b4b1			jsr 	EvaluateStringX 			; string parameter
.b99f	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b9a2	5a		phy				phy
.b9a3	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b9a5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b9a7	f0 41		beq $b9ea			beq 	_UDFail 					; must fail if zero.
.b9a9	8d 98 03	sta $0398			sta 	SignCount 					; use SignCount as a counter
.b9ac	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b9ae	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b9b0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b9b2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b9b4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b9b6	a9 01		lda #$01			lda 	#1
.b9b8	95 85		sta $85,x			sta 	XS_Type,x
.b9ba					_UDConvertLoop:
.b9ba	5a		phy				phy 								; shift mantissa left 4
.b9bb	a0 04		ldy #$04			ldy 	#4
.b9bd					_UDShift:
.b9bd	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.b9bf	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.b9c1	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.b9c3	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.b9c5	88		dey				dey
.b9c6	d0 f5		bne $b9bd			bne 	_UDShift
.b9c8	7a		ply				ply
.b9c9	c8		iny				iny 								; next character
.b9ca	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b9cc	20 ed b9	jsr $b9ed			jsr 	ConvertUpper 				; convert to U/C
.b9cf	c9 30		cmp #$30			cmp 	#"0"
.b9d1	90 17		bcc $b9ea			bcc 	_UDFail
.b9d3	c9 3a		cmp #$3a			cmp 	#"9"+1
.b9d5	90 06		bcc $b9dd			bcc 	_UDOkay
.b9d7	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b9d9	c9 10		cmp #$10			cmp 	#16
.b9db	b0 0d		bcs $b9ea			bcs 	_UDFail
.b9dd					_UDOkay:
.b9dd	29 0f		and #$0f			and 	#15 						; nibble only
.b9df	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.b9e1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b9e3	ce 98 03	dec $0398			dec 	SignCount 					; do it for each character
.b9e6	d0 d2		bne $b9ba			bne 	_UDConvertLoop
.b9e8	7a		ply				ply
.b9e9	60		rts				rts
.b9ea					_UDFail:
.b9ea	4c cd ad	jmp $adcd			jmp 	BadParamError
.b9ed					ConvertUpper:
.b9ed	c9 61		cmp #$61			cmp 	#"a"
.b9ef	90 07		bcc $b9f8			bcc 	_CUExit
.b9f1	c9 7b		cmp #$7b			cmp 	#"z"+1
.b9f3	b0 03		bcs $b9f8			bcs 	_CUExit
.b9f5	38		sec				sec
.b9f6	e9 20		sbc #$20			sbc 	#32
.b9f8	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b9f9					Unary_Chr:
.b9f9	20 a8 b4	jsr $b4a8			jsr 	EvaluateIntegerX			; numeric parameter
.b9fc	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.b9ff	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.ba01	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ba03	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.ba05	d0 0d		bne $ba14			bne 	_UCChar
.ba07	a9 01		lda #$01			lda 	#1 							; one character string
.ba09	20 f8 ba	jsr $baf8			jsr 	AllocateTempString
.ba0c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.ba0e	20 23 bb	jsr $bb23			jsr 	WriteTempString
.ba11	4c 42 ba	jmp $ba42			jmp 	UnaryReturnTempStr
.ba14					_UCChar:
.ba14	4c cd ad	jmp $adcd			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.ba17					Unary_Spc:
.ba17	20 a8 b4	jsr $b4a8			jsr 	EvaluateIntegerX 			; numeric parameter
.ba1a	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; right bracket.
.ba1d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.ba1f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ba21	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.ba23	d0 1a		bne $ba3f			bne 	_USSize
.ba25	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ba27	c9 fe		cmp #$fe			cmp 	#maxString+1
.ba29	b0 14		bcs $ba3f			bcs 	_USSize
.ba2b	48		pha				pha 								; save length
.ba2c	1a		inc a				inc 	a 							; allocate one more.
.ba2d	20 f8 ba	jsr $baf8			jsr 	AllocateTempString
.ba30	68		pla				pla 								; get length
.ba31	f0 0f		beq $ba42			beq 	UnaryReturnTempStr 			; return the current temp string
.ba33					_USLoop:
.ba33	48		pha				pha
.ba34	a9 20		lda #$20			lda 	#" "
.ba36	20 23 bb	jsr $bb23			jsr 	WriteTempString
.ba39	68		pla				pla
.ba3a	3a		dec a				dec 	a
.ba3b	d0 f6		bne $ba33			bne 	_USLoop
.ba3d	80 03		bra $ba42			bra 	UnaryReturnTempStr
.ba3f					_USSize:
.ba3f	4c cd ad	jmp $adcd			jmp 	BadParamError
.ba42					UnaryReturnTempStr:
.ba42	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.ba44	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ba46	a5 21		lda $21				lda 	zTempStr+1
.ba48	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ba4a	a9 02		lda #$02			lda 	#2 							; set type to string
.ba4c	95 85		sta $85,x			sta 	XS_Type,x
.ba4e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.ba4f	db		phz		MemRead:phz
.ba50	8d 98 03	sta $0398			sta 	SignCount 					; save count
.ba53	a3 00		ldz #$00			ldz 	#0 							; start from here
.ba55	ea		nop		_MLoop1:nop
.ba56	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.ba58	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.ba5a	1b		inz				inz 								; next to copy
.ba5b	e8		inx				inx
.ba5c	dc 98 03	cpz $0398			cpz 	SignCount 					; do required # of bytes.
.ba5f	d0 f4		bne $ba55			bne 	_MLoop1
.ba61	fb		plz				plz
.ba62	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.ba63					UpdateProgramEnd:
.ba63	a9 00		lda #$00			lda 	#BasicProgram & $FF
.ba65	85 16		sta $16				sta 	zCodePtr+0
.ba67	a9 80		lda #$80			lda 	#BasicProgram >> 8
.ba69	85 17		sta $17				sta 	zCodePtr+1
.ba6b	a9 02		lda #$02			lda 	#2
.ba6d	85 18		sta $18				sta 	zCodePtr+2
.ba6f	a9 00		lda #$00			lda 	#0
.ba71	85 19		sta $19				sta 	zCodePtr+3
.ba73	a3 03		ldz #$03			ldz 	#3
.ba75					_UPDLoop:
.ba75	a3 00		ldz #$00			ldz 	#0
.ba77	ea		nop				nop
.ba78	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ba7a	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.ba7c	f0 10		beq $ba8e			beq 	_UPDFoundEnd
.ba7e	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ba80	ea		nop				nop
.ba81	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ba83	18		clc				clc
.ba84	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ba86	85 16		sta $16				sta 	zCodePtr
.ba88	90 02		bcc $ba8c			bcc 	_SNLNoCarry
.ba8a	e6 17		inc $17				inc 	zCodePtr+1
.ba8c					_SNLNoCarry:
.ba8c	80 e7		bra $ba75			bra 	_UPDLoop
.ba8e					_UPDFoundEnd:
.ba8e	18		clc				clc 								; end of program 2 on.
.ba8f	a5 16		lda $16				lda 	zCodePtr
.ba91	69 02		adc #$02			adc 	#2
.ba93	8d 04 03	sta $0304			sta 	endOfProgram
.ba96	a5 17		lda $17				lda 	zCodePtr+1
.ba98	69 00		adc #$00			adc 	#0
.ba9a	8d 05 03	sta $0305			sta 	endOfProgram+1
.ba9d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.ba9e					CheckNextToken:
.ba9e	ea		nop				nop
.ba9f	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.baa1	d0 02		bne $baa5			bne 	CTFail 						; no, then fail
.baa3	1b		inz				inz
.baa4	60		rts				rts
.baa5					CTFail:
.baa5	20 de ad	jsr $adde			jsr ERR_Handler
>baa8	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>bab0	74 6f 6b 65 6e 00
.bab6					CheckNextRParen:
.bab6	ea		nop				nop
.bab7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bab9	c9 be		cmp #$be			cmp 	#token_rparen
.babb	d0 e8		bne $baa5			bne 	CTFail
.babd	1b		inz				inz
.babe	60		rts				rts
.babf					CheckNextComma:
.babf	ea		nop				nop
.bac0	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bac2	c9 bf		cmp #$bf			cmp 	#token_comma
.bac4	d0 df		bne $baa5			bne 	CTFail
.bac6	1b		inz				inz
.bac7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.bac8					StringConcrete:
.bac8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.baca	85 10		sta $10				sta 	zTemp1
.bacc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bace	85 11		sta $11				sta 	zTemp1+1
.bad0	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.bad2	18		clc				clc 								; from the string pointer
.bad3	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.bad6	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.bad8	8d 00 03	sta $0300			sta 	StringPtr
.badb	85 12		sta $12				sta 	zTemp2
.badd	ad 01 03	lda $0301			lda 	StringPtr+1
.bae0	e9 00		sbc #$00			sbc 	#0
.bae2	8d 01 03	sta $0301			sta 	StringPtr+1
.bae5	85 13		sta $13				sta 	zTemp2+1
.bae7	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.bae9	1a		inc a				inc 	a
.baea	aa		tax				tax
.baeb	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.baed	91 12		sta ($12),y			sta 	(zTemp2),y
.baef	c8		iny				iny
.baf0	ca		dex				dex
.baf1	d0 f8		bne $baeb			bne 	_SCCopy
.baf3	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.baf5	a6 12		ldx $12				ldx 	zTemp2
.baf7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.baf8					AllocateTempString:
.baf8	48		pha				pha 								; save required count.
.baf9	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.bafb	d0 0b		bne $bb08			bne 	_ATSInitialised
.bafd	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.bb00	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.bb02	ad 01 03	lda $0301			lda 	StringPtr+1
.bb05	3a		dec a				dec 	a
.bb06	85 21		sta $21				sta 	zTempStr+1
.bb08					_ATSInitialised:
.bb08	68		pla				pla 								; get required count back.
.bb09	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.bb0b	1a		inc a				inc 	a
.bb0c	18		clc				clc
.bb0d	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.bb0f	85 20		sta $20				sta 	zTempStr
.bb11	a9 ff		lda #$ff			lda 	#$FF
.bb13	65 21		adc $21				adc 	zTempStr+1
.bb15	85 21		sta $21				sta 	zTempStr+1
.bb17	a9 00		lda #$00			lda 	#0 							; clear temp string.
.bb19	5a		phy				phy
.bb1a	a8		tay				tay
.bb1b	91 20		sta ($20),y			sta 	(zTempStr),y
.bb1d	7a		ply				ply
.bb1e	1a		inc a				inc 	a 							; reset the write index.
.bb1f	8d 99 03	sta $0399			sta 	TempStringWriteIndex
.bb22	60		rts				rts
.bb23					WriteTempString:
.bb23	5a		phy				phy 								; save Y
.bb24	ac 99 03	ldy $0399			ldy 	TempStringWriteIndex	 	; write position.
.bb27	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.bb29	ee 99 03	inc $0399			inc 	TempStringWriteIndex 		; increment the write position.
.bb2c	98		tya				tya 								; unchanged Y is now length
.bb2d	a0 00		ldy #$00			ldy 	#0
.bb2f	91 20		sta ($20),y			sta 	(zTempStr),y
.bb31	7a		ply				ply 								; restore Y and exit
.bb32	60		rts				rts
.bb33					CreateTempStringCopy:
.bb33	da		phx				phx 								; save X
.bb34	ea		nop				nop
.bb35	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb37	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.bb38	20 f8 ba	jsr $baf8			jsr 	AllocateTempString 			; allocate memory for temporary string.
.bb3b	ea		nop				nop
.bb3c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb3e	1b		inz				inz
.bb3f	3a		dec a				dec 	a 							; make the actual length in charactes
.bb40	3a		dec a				dec 	a
.bb41	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.bb43	81 20		sta ($20,x)			sta 	(zTempStr,x)
.bb45	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.bb47	09 00		ora #$00			ora 	#0 							; if zero already, exit
.bb49	f0 0f		beq $bb5a			beq 	_CTSCExit
.bb4b					_CTSCLoop:
.bb4b	ea		nop				nop
.bb4c	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bb4e	1b		inz				inz
.bb4f	5a		phy				phy 								; save in Y
.bb50	e8		inx				inx 								; bump index
.bb51	da		phx				phx 								; index into Y
.bb52	7a		ply				ply
.bb53	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.bb55	7a		ply				ply 								; restore Y
.bb56	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.bb58	d0 f1		bne $bb4b			bne 	_CTSCLoop
.bb5a					_CTSCExit:
.bb5a	fa		plx				plx 								; restore X
.bb5b	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.bb5c					VariableFind:
.bb5c	20 c7 bb	jsr $bbc7			jsr 	VariableExtract 		; find out all about it ....
.bb5f	20 62 be	jsr $be62			jsr 	VariableLocate 			; does it already exist ?
.bb62	b0 03		bcs $bb67			bcs 	_VFExists 				; if so, use that.
.bb64	20 55 bc	jsr $bc55			jsr 	VariableCreate 			; otherwise create it.
.bb67					_VFExists:
.bb67	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.bb69	29 01		and #$01			and 	#1
.bb6b	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bb6d	d0 28		bne $bb97			bne 	_VFSingleElement
.bb6f					_VFNextIndex:
.bb6f	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.bb71	48		pha				pha
.bb72	a5 23		lda $23				lda 	zVarDataPtr+1
.bb74	48		pha				pha
.bb75	a5 24		lda $24				lda 	zVarType
.bb77	48		pha				pha
.bb78	20 a8 b4	jsr $b4a8			jsr 	EvaluateIntegerX 		; calculate the index.
.bb7b	68		pla				pla 							; restore and index.
.bb7c	85 24		sta $24				sta 	zVarType
.bb7e	68		pla				pla
.bb7f	85 23		sta $23				sta 	zVarDataPtr+1
.bb81	68		pla				pla
.bb82	85 22		sta $22				sta 	zVarDataPtr
.bb84	20 e0 bc	jsr $bce0			jsr 	ArrayIndexFollow 		; do the index.
.bb87	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.bb89	29 01		and #$01			and 	#1
.bb8b	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.bb8d	d0 05		bne $bb94			bne 	_VFArrayDone 			; if so then exit.
.bb8f	20 bf ba	jsr $babf			jsr 	CheckNextComma 			; comma should follow
.bb92	80 db		bra $bb6f			bra 	_VFNextIndex
.bb94					_VFArrayDone:
.bb94	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 		; check closing right bracket.
.bb97					_VFSingleElement:
.bb97	60		rts				rts
.bb98					VariableClear:
.bb98	48		pha				pha 							; save registers
.bb99	da		phx				phx
.bb9a	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.bb9c	8a		txa				txa
.bb9d	9d 2f 03	sta $032f,x	_VCLoop:sta 	HashTableBase,x
.bba0	e8		inx				inx
.bba1	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.bba3	d0 f8		bne $bb9d			bne 	_VCLoop
.bba5	a9 00		lda #$00			lda 	#VariableMemory & $FF
.bba7	8d 02 03	sta $0302			sta 	VarMemPtr
.bbaa	a9 20		lda #$20			lda 	#VariableMemory >> 8
.bbac	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bbaf	fa		plx				plx 							; restore registers
.bbb0	68		pla				pla
.bbb1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.bbb2					VariableNameError:
.bbb2	20 de ad	jsr $adde			jsr ERR_Handler
>bbb5	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>bbbd	61 62 6c 65 20 4e 61 6d 65 00
.bbc7					VariableExtract:
.bbc7	da		phx				phx 							; save X.
.bbc8	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.bbca	8d 8f 03	sta $038f			sta 	Var_Type
.bbcd	8d 90 03	sta $0390			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.bbd0	ea		nop				nop
.bbd1	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbd3	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.bbd5	f0 db		beq $bbb2			beq 	VariableNameError
.bbd7	c9 1b		cmp #$1b			cmp 	#26+1
.bbd9	b0 d7		bcs $bbb2			bcs 	VariableNameError
.bbdb	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.bbdd					_VECopyBuffer:
.bbdd	e8		inx				inx
.bbde	e0 1f		cpx #$1f			cpx 	#31 					; too long
.bbe0	f0 d0		beq $bbb2			beq 	VariableNameError
.bbe2	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x 			; save character
.bbe5	18		clc				clc  							; update the hash value for it.
.bbe6	6d 90 03	adc $0390			adc 	Var_Hash
.bbe9	8d 90 03	sta $0390			sta 	Var_Hash
.bbec	1b		inz				inz
.bbed	ea		nop				nop
.bbee	b2 16		lda ($16),z			lda 	(zCodePtr),z
.bbf0	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.bbf2	f0 0e		beq $bc02			beq 	_VECopyEnd
.bbf4	30 0c		bmi $bc02			bmi 	_VECopyEnd
.bbf6	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.bbf8	90 e3		bcc $bbdd			bcc 	_VECopyBuffer
.bbfa	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.bbfc	90 04		bcc $bc02			bcc 	_VECopyEnd
.bbfe	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc00	90 db		bcc $bbdd			bcc 	_VECopyBuffer
.bc02					_VECopyEnd:
.bc02	1b		inz				inz
.bc03	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.bc05	90 04		bcc $bc0b			bcc 	_VEDefaultRequired
.bc07	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.bc09	90 0b		bcc $bc16			bcc 	_VEHaveType
.bc0b					_VEDefaultRequired:
.bc0b	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.bc0d	f0 04		beq $bc13			beq 	_VESetType 				; default set above.
.bc0f	ce 8f 03	dec $038f			dec 	Var_Type 				; this changes that default to the variable default
.bc12	3b		dez				dez
.bc13					_VESetType:
.bc13	ad 8f 03	lda $038f			lda 	Var_Type 				; get type ....
.bc16					_VEHaveType:
.bc16	8d 8f 03	sta $038f			sta 	Var_Type 				; save as type.
.bc19	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.bc1c	09 80		ora #$80			ora 	#$80
.bc1e	9d 0f 03	sta $030f,x			sta 	Var_Buffer,x
.bc21	e8		inx				inx 							; offset 3 => length 4.
.bc22	8e 91 03	stx $0391			stx 	Var_Length 				; save length of variable name.
.bc25	ad 8f 03	lda $038f			lda 	Var_Type 				; get offset of var type from first type token
.bc28	38		sec				sec
.bc29	e9 b7		sbc #$b7			sbc 	#token_Dollar
.bc2b	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.bc2c	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.bc2d	0a		asl a				asl 	a
.bc2e	0a		asl a				asl 	a
.bc2f	8d 92 03	sta $0392			sta 	Var_HashAddress
.bc32	ad 90 03	lda $0390			lda 	Var_Hash 				; get the hash
.bc35	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.bc37	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.bc38	6d 92 03	adc $0392			adc 	Var_HashAddress 		; add table offset.
.bc3b	69 2f		adc #$2f			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.bc3d	8d 92 03	sta $0392			sta 	Var_HashAddress
.bc40	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.bc42	ad 8f 03	lda $038f			lda 	Var_Type
.bc45	c9 b9		cmp #$b9			cmp 	#token_Hash
.bc47	f0 07		beq $bc50			beq 	_VEHaveSize
.bc49	ca		dex				dex
.bc4a	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.bc4c	f0 02		beq $bc50			beq 	_VEHaveSize
.bc4e	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.bc50					_VEHaveSize:
.bc50	8e 93 03	stx $0393			stx 	Var_DataSize
.bc53	fa		plx				plx
.bc54	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.bc55					VariableCreate:
.bc55	da		phx				phx
.bc56	5a		phy				phy
.bc57	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.bc5a	85 10		sta $10				sta 	zTemp1
.bc5c	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bc5f	85 11		sta $11				sta 	zTemp1+1
.bc61	ad 93 03	lda $0393			lda 	Var_DataSize 				; bytes for the data bit
.bc64	18		clc				clc
.bc65	6d 91 03	adc $0391			adc 	Var_Length 					; add the length of the name
.bc68	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.bc6a	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.bc6d	8d 02 03	sta $0302			sta 	VarMemPtr
.bc70	90 03		bcc $bc75			bcc 	_VCNoCarry
.bc72	ee 03 03	inc $0303			inc 	VarMemPtr+1
.bc75					_VCNoCarry:
.bc75	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.bc78	85 12		sta $12				sta 	zTemp2
.bc7a	a9 03		lda #$03			lda 	#HashTableBase >> 8
.bc7c	85 13		sta $13				sta 	zTemp2+1
.bc7e	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.bc80	b1 12		lda ($12),y			lda 	(zTemp2),y
.bc82	91 10		sta ($10),y			sta 	(zTemp1),y
.bc84	c8		iny				iny
.bc85	b1 12		lda ($12),y			lda 	(zTemp2),y
.bc87	91 10		sta ($10),y			sta 	(zTemp1),y
.bc89	c8		iny				iny
.bc8a	ad 90 03	lda $0390			lda 	Var_Hash 					; write the hash out.
.bc8d	91 10		sta ($10),y			sta 	(zTemp1),y
.bc8f	c8		iny				iny
.bc90	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.bc92					_VCCopyName:
.bc92	bd 0f 03	lda $030f,x			lda 	Var_Buffer,x
.bc95	91 10		sta ($10),y			sta 	(zTemp1),y
.bc97	e8		inx				inx
.bc98	c8		iny				iny
.bc99	ec 91 03	cpx $0391			cpx 	Var_Length
.bc9c	d0 f4		bne $bc92			bne 	_VCCopyName
.bc9e	5a		phy				phy 								; save the data offset.
.bc9f	ae 93 03	ldx $0393			ldx 	Var_DataSize 				; and write the data out.
.bca2	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.bca4					_VCClearData:
.bca4	91 10		sta ($10),y			sta 	(zTemp1),y
.bca6	c8		iny				iny
.bca7	ca		dex				dex
.bca8	d0 fa		bne $bca4			bne 	_VCClearData
.bcaa	68		pla				pla 								; offset to the data
.bcab	18		clc				clc
.bcac	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.bcae	85 22		sta $22				sta 	zVarDataPtr
.bcb0	a5 11		lda $11				lda 	zTemp1+1
.bcb2	69 00		adc #$00			adc 	#0
.bcb4	85 23		sta $23				sta 	zVarDataPtr+1
.bcb6	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.bcb9	85 24		sta $24				sta 	zVarType
.bcbb	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.bcbd	a0 00		ldy #$00			ldy 	#0
.bcbf	91 12		sta ($12),y			sta 	(zTemp2),y
.bcc1	c8		iny				iny
.bcc2	a5 11		lda $11				lda 	zTemp1+1
.bcc4	91 12		sta ($12),y			sta 	(zTemp2),y
.bcc6	ad 8f 03	lda $038f			lda 	Var_Type 					; array ? if so create the empty one.
.bcc9	29 01		and #$01			and 	#1
.bccb	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.bccd	d0 0e		bne $bcdd			bne 	_VCNotArray
.bccf	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.bcd1	20 77 bd	jsr $bd77			jsr 	ArrayCreate
.bcd4	5a		phy				phy 								; save YA at zVarDataPtr
.bcd5	a0 00		ldy #$00			ldy 	#0
.bcd7	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bcd9	c8		iny				iny
.bcda	68		pla				pla
.bcdb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bcdd					_VCNotArray:
.bcdd	7a		ply				ply
.bcde	fa		plx				plx
.bcdf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.bce0					ArrayIndexFollow:
.bce0	5a		phy				phy
.bce1	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.bce3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.bce5	48		pha				pha
.bce6	c8		iny				iny
.bce7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bce9	85 23		sta $23				sta 	zVarDataPtr+1
.bceb	68		pla				pla
.bcec	85 22		sta $22				sta 	zVarDataPtr
.bcee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.bcf0	29 80		and #$80			and 	#$80 						; must be zero.
.bcf2	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bcf4	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.bcf6	d0 59		bne $bd51			bne 	_AIFError
.bcf8	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.bcfa	18		clc				clc
.bcfb	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bcfd	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.bcff	c8		iny				iny
.bd00	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bd02	08		php				php 								; clear bit 7 retaining borrow.
.bd03	29 7f		and #$7f			and 	#$7F
.bd05	28		plp				plp
.bd06	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.bd08	90 47		bcc $bd51			bcc 	_AIFError 					; eror if size-current < 0
.bd0a	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.bd0c	0a		asl a				asl 	a 							; (e.g. index * 2)
.bd0d	85 10		sta $10				sta 	zTemp1
.bd0f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd11	2a		rol a				rol 	a
.bd12	85 11		sta $11				sta 	zTemp1+1
.bd14	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.bd16	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.bd18	30 1d		bmi $bd37			bmi 	_AIFCalculate
.bd1a	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.bd1c	a5 24		lda $24				lda 	zVarType 					; check that type
.bd1e	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.bd20	f0 15		beq $bd37			beq 	_AIFCalculate
.bd22	06 10		asl $10				asl 	zTemp1			 			; double the index
.bd24	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.bd26	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.bd28	f0 0d		beq $bd37			beq 	_AIFCalculate
.bd2a	18		clc				clc 								; add the original mantissa in again
.bd2b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.bd2d	65 10		adc $10				adc 	zTemp1
.bd2f	85 10		sta $10				sta 	zTemp1
.bd31	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd33	65 11		adc $11				adc 	zTemp1+1
.bd35	85 11		sta $11				sta 	zTemp1+1
.bd37					_AIFCalculate:
.bd37	18		clc				clc 								; add index x 2,4 or 5 to base
.bd38	a5 22		lda $22				lda 	zVarDataPtr
.bd3a	65 10		adc $10				adc 	zTemp1
.bd3c	85 22		sta $22				sta 	zVarDataPtr
.bd3e	a5 23		lda $23				lda 	zVarDataPtr+1
.bd40	65 11		adc $11				adc 	zTemp1+1
.bd42	85 23		sta $23				sta 	zVarDataPtr+1
.bd44	18		clc				clc 								; add 2 more for the length prefix.
.bd45	a5 22		lda $22				lda 	zVarDataPtr
.bd47	69 02		adc #$02			adc 	#2
.bd49	85 22		sta $22				sta 	zVarDataPtr
.bd4b	90 02		bcc $bd4f			bcc 	_AIFNoBump
.bd4d	e6 23		inc $23				inc 	zVarDataPtr+1
.bd4f					_AIFNoBump:
.bd4f	7a		ply				ply
.bd50	60		rts				rts
.bd51					_AIFError:
.bd51	20 de ad	jsr $adde			jsr ERR_Handler
>bd54	42 61 64 20 61 72 72 61			.text "Bad array index",0
>bd5c	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.bd64					ArrayResetDefault:
.bd64	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.bd66	8d a1 03	sta $03a1			sta 	ArrayDef+0
.bd69	a9 00		lda #$00			lda 	#0
.bd6b	8d a2 03	sta $03a2			sta 	ArrayDef+1
.bd6e	a9 ff		lda #$ff			lda 	#$FF
.bd70	8d a3 03	sta $03a3			sta 	ArrayDef+2 					; $FFFF implies no second element.
.bd73	8d a4 03	sta $03a4			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.bd76	60		rts				rts
.bd77					ArrayCreate:
.bd77	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.bd7a	0a		asl a				asl 	a
.bd7b	85 10		sta $10				sta 	zTemp1
.bd7d	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.bd80	2a		rol a				rol 	a
.bd81	85 11		sta $11				sta 	zTemp1+1
.bd83	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.bd86	10 22		bpl $bdaa			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.bd88	ad 8f 03	lda $038f			lda 	Var_Type 					; check the type
.bd8b	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.bd8d	f0 1b		beq $bdaa			beq 	_ACSized
.bd8f	06 10		asl $10				asl 	zTemp1 						; double again
.bd91	26 11		rol $11				rol 	zTemp1+1
.bd93	b0 6f		bcs $be04			bcs 	ArrayIndexError 			; too large.
.bd95	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.bd97	f0 11		beq $bdaa			beq 	_ACSized
.bd99	18		clc				clc 								; add original value x 5 for reals.
.bd9a	a5 10		lda $10				lda 	zTemp1
.bd9c	7d a1 03	adc $03a1,x			adc 	ArrayDef+0,x
.bd9f	85 10		sta $10				sta 	zTemp1
.bda1	a5 11		lda $11				lda 	zTemp1+1
.bda3	7d a2 03	adc $03a2,x			adc 	ArrayDef+1,x
.bda6	85 11		sta $11				sta 	zTemp1+1
.bda8	b0 5a		bcs $be04			bcs 	ArrayIndexError
.bdaa					_ACSized:
.bdaa	18		clc				clc
.bdab	a5 10		lda $10				lda 	zTemp1
.bdad	69 02		adc #$02			adc 	#2
.bdaf	85 10		sta $10				sta 	zTemp1
.bdb1	90 04		bcc $bdb7			bcc 	_ACNoBump
.bdb3	e6 10		inc $10				inc 	zTemp1
.bdb5	f0 4d		beq $be04			beq 	ArrayIndexError
.bdb7					_ACNoBump:
.bdb7	18		clc				clc
.bdb8	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.bdbb	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.bdbd	85 14		sta $14				sta 	zTemp3
.bdbf	65 10		adc $10				adc 	zTemp1
.bdc1	8d 02 03	sta $0302			sta 	VarMemPtr
.bdc4	ad 03 03	lda $0303			lda 	VarMemPtr+1
.bdc7	85 13		sta $13				sta 	zTemp2+1
.bdc9	85 15		sta $15				sta 	zTemp3+1
.bdcb	65 11		adc $11				adc 	zTemp1+1
.bdcd	8d 03 03	sta $0303			sta 	VarMemPtr+1
.bdd0	85 11		sta $11				sta 	zTemp1+1
.bdd2	b0 30		bcs $be04			bcs 	ArrayIndexError
.bdd4	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.bdd6					_ACClear:
.bdd6	98		tya				tya
.bdd7	91 12		sta ($12),y			sta 	(zTemp2),y
.bdd9	e6 12		inc $12				inc 	zTemp2
.bddb	d0 02		bne $bddf			bne 	_ACCBump
.bddd	e6 13		inc $13				inc 	zTemp2+1
.bddf					_ACCBump:
.bddf	a5 12		lda $12				lda 	zTemp2
.bde1	cd 02 03	cmp $0302			cmp 	VarMemPtr
.bde4	d0 f0		bne $bdd6			bne 	_ACClear
.bde6	a5 13		lda $13				lda 	zTemp2+1
.bde8	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.bdeb	d0 e9		bne $bdd6			bne 	_ACClear
.bded	a0 00		ldy #$00			ldy 	#0
.bdef	bd a1 03	lda $03a1,x			lda 	ArrayDef+0,x 				; copy the size into the start
.bdf2	91 14		sta ($14),y			sta 	(zTemp3),y
.bdf4	c8		iny				iny
.bdf5	bd a2 03	lda $03a2,x			lda 	ArrayDef+1,x
.bdf8	91 14		sta ($14),y			sta 	(zTemp3),y
.bdfa	bd a4 03	lda $03a4,x			lda 	ArrayDef+3,x 				; have we reached the end
.bdfd	10 18		bpl $be17			bpl 	ACCFillRecursive
.bdff	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.be01	a5 14		lda $14				lda 	zTemp3
.be03	60		rts				rts
.be04					ArrayIndexError:
.be04	20 de ad	jsr $adde			jsr ERR_Handler
>be07	42 61 64 20 61 72 72 61			.text "Bad array index",0
>be0f	79 20 69 6e 64 65 78 00
.be17					ACCFillRecursive:
.be17	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.be19	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.be1b	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.be1d	c8		iny				iny
.be1e	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.be20	09 80		ora #$80			ora 	#$80 						; an array of pointers
.be22	91 14		sta ($14),y			sta 	(zTemp3),y
.be24	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.be26	48		pha				pha
.be27	a5 15		lda $15				lda 	zTemp3+1
.be29	48		pha				pha
.be2a					_ACCFillLoop:
.be2a	18		clc				clc
.be2b	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.be2d	69 02		adc #$02			adc 	#2
.be2f	85 14		sta $14				sta 	zTemp3
.be31	90 02		bcc $be35			bcc 	_ACCSkip2
.be33	e6 15		inc $15				inc 	zTemp3+1
.be35					_ACCSkip2:
.be35	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.be37	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.be39	c8		iny				iny
.be3a	11 14		ora ($14),y			ora 	(zTemp3),y
.be3c	d0 21		bne $be5f			bne 	_ACCExit
.be3e	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.be40	48		pha				pha
.be41	a5 15		lda $15				lda 	zTemp3+1
.be43	48		pha				pha
.be44	e8		inx				inx
.be45	e8		inx				inx
.be46	20 77 bd	jsr $bd77			jsr 	ArrayCreate 				; create array recursively.
.be49	ca		dex				dex
.be4a	ca		dex				dex
.be4b	85 12		sta $12				sta 	zTemp2 						; save A
.be4d	68		pla				pla
.be4e	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.be50	68		pla				pla
.be51	85 14		sta $14				sta 	zTemp3
.be53	98		tya				tya 								; write high bye from Y
.be54	a0 01		ldy #$01			ldy 	#1
.be56	91 14		sta ($14),y			sta 	(zTemp3),y
.be58	88		dey				dey 								; write low byte out.
.be59	a5 12		lda $12				lda 	zTemp2
.be5b	91 14		sta ($14),y			sta 	(zTemp3),y
.be5d	80 cb		bra $be2a			bra 	_ACCFillLoop 				; and try again.
.be5f					_ACCExit:
.be5f	7a		ply				ply 								; restore the original address
.be60	68		pla				pla
.be61	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.be62					VariableLocate:
.be62	da		phx				phx
.be63	5a		phy				phy
.be64	ad 92 03	lda $0392			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.be67	85 12		sta $12				sta 	zTemp2 						; points to first address.
.be69	a9 03		lda #$03			lda 	#HashTableBase >> 8
.be6b	85 13		sta $13				sta 	zTemp2+1
.be6d	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.be6f	b1 12		lda ($12),y			lda 	(zTemp2),y
.be71	aa		tax				tax
.be72	c8		iny				iny
.be73	b1 12		lda ($12),y			lda 	(zTemp2),y
.be75	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.be77	86 12		stx $12				stx 	zTemp2
.be79	05 12		ora $12				ora 	zTemp2 						; got zero
.be7b	18		clc				clc
.be7c	f0 25		beq $bea3			beq 	_VLExit 					; if so, then fail as end of chain.
.be7e	c8		iny				iny 								; point to hash (offset + 2)
.be7f	b1 12		lda ($12),y			lda 	(zTemp2),y
.be81	cd 90 03	cmp $0390			cmp 	Var_Hash
.be84	d0 e7		bne $be6d			bne 	_VLNext 					; try next if different.
.be86					_VLCompare:
.be86	c8		iny				iny 								; next character
.be87	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.be89	d9 0c 03	cmp $030c,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.be8c	d0 df		bne $be6d			bne 	_VLNext 					; fail if different, try next.
.be8e	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.be8f	90 f5		bcc $be86			bcc 	_VLCompare
.be91	98		tya				tya
.be92	38		sec				sec 								; add 1 as Y points to last character
.be93	65 12		adc $12				adc 	zTemp2 						; add to the current address
.be95	85 22		sta $22				sta 	zVarDataPtr
.be97	a5 13		lda $13				lda 	zTemp2+1
.be99	69 00		adc #$00			adc 	#0
.be9b	85 23		sta $23				sta 	zVarDataPtr+1
.be9d	ad 8f 03	lda $038f			lda 	Var_Type 					; and set the type.
.bea0	85 24		sta $24				sta 	zVarType
.bea2	38		sec				sec 								; return CS
.bea3	7a		ply		_VLExit:ply
.bea4	fa		plx				plx
.bea5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.bea6					VariableGet:
.bea6	5a		phy				phy
.bea7	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.bea9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.beab	95 80		sta $80,x			sta 	XS_Mantissa,x
.bead	c8		iny				iny
.beae	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.beb0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.beb2	c8		iny				iny
.beb3	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.beb5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.beb7	f0 2c		beq $bee5			beq 	_VGString
.beb9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.bebb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bebd	c8		iny				iny
.bebe	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.bec0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bec2	c8		iny				iny
.bec3	a9 01		lda #$01			lda 	#1 							; set type to 1.
.bec5	95 85		sta $85,x			sta 	XS_Type,x
.bec7	a5 24		lda $24				lda 	zVarType
.bec9	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.becb	f0 28		beq $bef5			beq 	_VGExit
.becd	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.becf	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.bed1	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.bed3	95 84		sta $84,x			sta 	XS_Exponent,x
.bed5	f0 1e		beq $bef5			beq 	_VGExit 					; if exponent is zero ... it's zero.
.bed7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.bed9	48		pha				pha
.beda	29 80		and #$80			and 	#$80
.bedc	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.bede	68		pla				pla
.bedf	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.bee1	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.bee3	80 10		bra $bef5			bra 	_VGExit
.bee5					_VGString:
.bee5	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.bee7	95 85		sta $85,x			sta 	XS_Type,x
.bee9	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.beeb	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.beed	d0 06		bne $bef5			bne 	_VGExit 					; if not, exit.
.beef	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.bef1	a9 25		lda #$25			lda 	#zNullString
.bef3	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.bef5					_VGExit:
.bef5	7a		ply				ply
.bef6	60		rts				rts
.bef7					VariableSet:
.bef7	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.bef9	29 02		and #$02			and 	#2 							; if so, it has to be
.befb	d0 4b		bne $bf48			bne 	_VSString
.befd	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.beff	c9 b7		cmp #$b7			cmp 	#token_Dollar
.bf01	f0 42		beq $bf45			beq 	_VSBadType
.bf03	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.bf05	f0 05		beq $bf0c			beq 	_VSMakeInt
.bf07	20 2c c4	jsr $c42c			jsr 	FPUToFloat
.bf0a	80 03		bra $bf0f			bra 	_VSCopy
.bf0c					_VSMakeInt:
.bf0c	20 78 c4	jsr $c478			jsr 	FPUToInteger
.bf0f					_VSCopy:
.bf0f	5a		phy				phy
.bf10	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.bf12	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bf14	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf16	c8		iny				iny
.bf17	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf19	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf1b	c8		iny				iny
.bf1c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bf1e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf20	c8		iny				iny
.bf21	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf23	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf25	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.bf27	c9 bb		cmp #$bb			cmp 	#token_Percent
.bf29	f0 18		beq $bf43			beq 	_VSExit
.bf2b	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.bf2d	0a		asl a				asl 	a
.bf2e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.bf30	08		php				php
.bf31	0a		asl a				asl 	a
.bf32	28		plp				plp
.bf33	6a		ror a				ror 	a
.bf34	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf36	c8		iny				iny
.bf37	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.bf39	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf3b	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.bf3d	50 04		bvc $bf43			bvc 	_VSExit
.bf3f	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.bf41	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf43					_VSExit:
.bf43	7a		ply				ply
.bf44	60		rts				rts
.bf45					_VSBadType:
.bf45	4c bf ad	jmp $adbf			jmp 	TypeError
.bf48					_VSString:
.bf48	a5 24		lda $24				lda 	zVarType 					; type must be $
.bf4a	c9 b7		cmp #$b7			cmp 	#token_Dollar
.bf4c	d0 f7		bne $bf45			bne 	_VSBadType
.bf4e	da		phx				phx
.bf4f	5a		phy				phy
.bf50	20 c8 ba	jsr $bac8			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.bf53	a0 01		ldy #$01			ldy 	#1 							; save high byte
.bf55	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf57	88		dey				dey 								; save low byte
.bf58	8a		txa				txa
.bf59	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.bf5b	7a		ply				ply 								; and exit.
.bf5c	fa		plx				plx
.bf5d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.bf5e					MulInteger32:
.bf5e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.bf60	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.bf62	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bf64	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.bf66	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bf68	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.bf6a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bf6c	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.bf6e	a9 00		lda #$00			lda 	#0
.bf70	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.bf72	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf74	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf76	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf78					_BFMMultiply:
.bf78	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.bf7a	29 01		and #$01			and 	#1
.bf7c	f0 03		beq $bf81			beq 	_BFMNoAdd
.bf7e	20 46 b6	jsr $b646			jsr 	AddInteger32
.bf81					_BFMNoAdd:
.bf81	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.bf83	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.bf85	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.bf87	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.bf89	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.bf8b	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.bf8d	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.bf8f	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.bf91	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.bf93	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.bf95	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.bf97	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.bf99	d0 dd		bne $bf78			bne 	_BFMMultiply
.bf9b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.bf9c					DivInteger32:
.bf9c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.bf9e	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.bfa0	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.bfa2	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.bfa4	d0 14		bne $bfba			bne 	_BFDOkay
.bfa6	20 de ad	jsr $adde			jsr ERR_Handler
>bfa9	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>bfb1	20 62 79 20 5a 65 72 6f 00
.bfba					_BFDOkay:
.bfba	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.bfbc	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.bfbe	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.bfc0	85 1c		sta $1c				sta 	zLTemp1+2
.bfc2	85 1d		sta $1d				sta 	zLTemp1+3
.bfc4	8d 98 03	sta $0398			sta 	SignCount 					; Count of signs.
.bfc7	20 1e c0	jsr $c01e			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.bfca	da		phx				phx
.bfcb	e8		inx				inx
.bfcc	e8		inx				inx
.bfcd	e8		inx				inx
.bfce	e8		inx				inx
.bfcf	e8		inx				inx
.bfd0	e8		inx				inx
.bfd1	20 1e c0	jsr $c01e			jsr 	CheckIntegerNegate
.bfd4	fa		plx				plx
.bfd5	5a		phy				phy 								; Y is the counter
.bfd6	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.bfd8					_BFDLoop:
.bfd8	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.bfda	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.bfdc	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.bfde	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.bfe0	26 1a		rol $1a				rol 	zLTemp1
.bfe2	26 1b		rol $1b				rol 	zLTemp1+1
.bfe4	26 1c		rol $1c				rol 	zLTemp1+2
.bfe6	26 1d		rol $1d				rol 	zLTemp1+3
.bfe8	38		sec				sec
.bfe9	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.bfeb	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.bfed	48		pha				pha
.bfee	a5 1b		lda $1b				lda 	zLTemp1+1
.bff0	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.bff2	48		pha				pha
.bff3	a5 1c		lda $1c				lda 	zLTemp1+2
.bff5	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.bff7	48		pha				pha
.bff8	a5 1d		lda $1d				lda 	zLTemp1+3
.bffa	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.bffc	90 13		bcc $c011			bcc 	_BFDNoAdd
.bffe	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c000	68		pla				pla
.c001	85 1c		sta $1c				sta 	zLTemp1+2
.c003	68		pla				pla
.c004	85 1b		sta $1b				sta 	zLTemp1+1
.c006	68		pla				pla
.c007	85 1a		sta $1a				sta 	zLTemp1+0
.c009	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c00b	09 01		ora #$01			ora 	#1
.c00d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c00f	80 03		bra $c014			bra 	_BFDNext
.c011					_BFDNoAdd:
.c011	68		pla				pla 								; Throw away the intermediate calculations
.c012	68		pla				pla
.c013	68		pla				pla
.c014					_BFDNext:
.c014	88		dey				dey
.c015	d0 c1		bne $bfd8			bne 	_BFDLoop
.c017	7a		ply				ply 								; restore Y and exit
.c018	4e 98 03	lsr $0398			lsr 	SignCount 					; if sign count odd,
.c01b	b0 06		bcs $c023			bcs		IntegerNegateAlways 			; negate the result
.c01d	60		rts				rts
.c01e					CheckIntegerNegate:
.c01e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c020	30 01		bmi $c023			bmi 	IntegerNegateAlways
.c022	60		rts				rts
.c023					IntegerNegateAlways:
.c023	ee 98 03	inc $0398			inc 	SignCount
.c026	38		sec				sec
.c027	a9 00		lda #$00			lda 	#0
.c029	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c02b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c02d	a9 00		lda #$00			lda 	#0
.c02f	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c031	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c033	a9 00		lda #$00			lda 	#0
.c035	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c037	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c039	a9 00		lda #$00			lda 	#0
.c03b	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c03d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c03f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c040					INTToString:
.c040	48		pha				pha
.c041	5a		phy				phy
.c042	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.c044	10 08		bpl $c04e			bpl 		_ITSNotMinus
.c046	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c048	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter
.c04b	20 23 c0	jsr $c023			jsr 		IntegerNegateAlways 	; negate the number.
.c04e					_ITSNotMinus:
.c04e	a9 00		lda #$00			lda 		#0
.c050	8d 94 03	sta $0394			sta 		NumSuppress 			; clear the suppression flag.
.c053	8a		txa				txa 								; use Y for the mantissa index.
.c054	a8		tay				tay
.c055	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.c057					_ITSNextSubtractor:
.c057	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c059	8d 95 03	sta $0395			sta 		NumConvCount
.c05c					_ITSSubtract:
.c05c	38		sec				sec
.c05d	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.c060	fd ba c0	sbc $c0ba,x			sbc 		_ITSSubtractors+0,x
.c063	48		pha				pha
.c064	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.c067	fd bb c0	sbc $c0bb,x			sbc 		_ITSSubtractors+1,x
.c06a	48		pha				pha
.c06b	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.c06e	fd bc c0	sbc $c0bc,x			sbc 		_ITSSubtractors+2,x
.c071	48		pha				pha
.c072	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.c075	fd bd c0	sbc $c0bd,x			sbc 		_ITSSubtractors+3,x
.c078	90 14		bcc $c08e			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c07a	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.c07d	68		pla				pla
.c07e	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.c081	68		pla				pla
.c082	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.c085	68		pla				pla
.c086	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.c089	ee 95 03	inc $0395			inc 		NumConvCount 			; bump count.
.c08c	80 ce		bra $c05c			bra 		_ITSSubtract 			; go round again.
.c08e					_ITSCantSubtract:
.c08e	68		pla				pla 								; throw away interim answers
.c08f	68		pla				pla
.c090	68		pla				pla
.c091	ad 95 03	lda $0395			lda 		NumConvCount 			; if not zero then no suppression check
.c094	c9 30		cmp #$30			cmp 		#"0"
.c096	d0 05		bne $c09d			bne 		_ITSOutputDigit
.c098	ad 94 03	lda $0394			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.c09b	10 09		bpl $c0a6			bpl	 		_ITSGoNextSubtractor
.c09d					_ITSOutputDigit:
.c09d	ce 94 03	dec $0394			dec 		NumSuppress 			; suppression check will be non-zero.
.c0a0	ad 95 03	lda $0395			lda 		NumConvCount 			; count of subtractions
.c0a3	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter 		; output it.
.c0a6					_ITSGoNextSubtractor:
.c0a6	e8		inx				inx 								; next dword
.c0a7	e8		inx				inx
.c0a8	e8		inx				inx
.c0a9	e8		inx				inx
.c0aa	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.c0ac	d0 a9		bne $c057			bne 		_ITSNextSubtractor 		; do all the subtractors.
.c0ae	98		tya				tya 								; X is back as the mantissa index
.c0af	aa		tax				tax
.c0b0	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.c0b2	09 30		ora #$30			ora 		#"0"
.c0b4	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter
.c0b7	7a		ply				ply 								; and exit
.c0b8	68		pla				pla
.c0b9	60		rts				rts
.c0ba					_ITSSubtractors:
>c0ba	00 ca 9a 3b					.dword 		1000000000
>c0be	00 e1 f5 05					.dword 		100000000
>c0c2	80 96 98 00					.dword 		10000000
>c0c6	40 42 0f 00					.dword 		1000000
>c0ca	a0 86 01 00					.dword 		100000
>c0ce	10 27 00 00					.dword 		10000
>c0d2	e8 03 00 00					.dword 		1000
>c0d6	64 00 00 00					.dword 		100
>c0da	0a 00 00 00					.dword 		10
.c0de					_ITSSubtractorsEnd:
.c0de					ITSOutputCharacter:
.c0de	48		pha				pha
.c0df	da		phx				phx
.c0e0	ae 0e 03	ldx $030e			ldx 	NumBufX 					; save digit
.c0e3	9d 0f 03	sta $030f,x			sta 	Num_Buffer,x
.c0e6	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.c0e8	9d 10 03	sta $0310,x			sta 	Num_Buffer+1,x
.c0eb	ee 0e 03	inc $030e			inc 	NumBufX						; bump pointer.
.c0ee	fa		plx				plx
.c0ef	68		pla				pla
.c0f0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.c0f1					IntFromString:
.c0f1	a0 00		ldy #$00			ldy 	#0
.c0f3	8c 96 03	sty $0396			sty 	ExpTemp 					; this is the converted digit count.
.c0f6					IntFromStringY:
.c0f6	48		pha				pha
.c0f7	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.c0f9	95 80		sta $80,x			sta 	XS_Mantissa,x
.c0fb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c0fd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c0ff	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c101	a9 01		lda #$01			lda 	#1
.c103	95 85		sta $85,x			sta 	XS_Type,x
.c105					_IFSLoop:
.c105	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.c107	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.c109	90 4e		bcc $c159			bcc 	_IFSExit
.c10b	c9 3a		cmp #$3a			cmp 	#"9"+1
.c10d	b0 4a		bcs $c159			bcs 	_IFSExit
.c10f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.c111	c9 0c		cmp #$0c			cmp 	#12
.c113	b0 4e		bcs $c163			bcs 	_IFSOverflow
.c115	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.c117	48		pha				pha
.c118	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c11a	48		pha				pha
.c11b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c11d	48		pha				pha
.c11e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c120	48		pha				pha
.c121	20 78 c1	jsr $c178			jsr 	IFSX1ShiftLeft 				; double
.c124	20 78 c1	jsr $c178			jsr 	IFSX1ShiftLeft 				; x 4
.c127	18		clc				clc 								; add saved value x 5
.c128	68		pla				pla
.c129	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c12b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c12d	68		pla				pla
.c12e	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.c130	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c132	68		pla				pla
.c133	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.c135	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c137	68		pla				pla
.c138	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.c13a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c13c	20 78 c1	jsr $c178			jsr 	IFSX1ShiftLeft 				; x 10
.c13f	ee 96 03	inc $0396			inc 	ExpTemp 					; bump count of digits processed.
.c142	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.c144	29 0f		and #$0f			and 	#15
.c146	c8		iny				iny
.c147	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.c149	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c14b	90 b8		bcc $c105			bcc 	_IFSLoop
.c14d	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.c14f	d0 b4		bne $c105			bne 	_IFSLoop
.c151	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.c153	d0 b0		bne $c105			bne 	_IFSLoop
.c155	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.c157	80 ac		bra $c105			bra 	_IFSLoop
.c159					_IFSExit:
.c159	98		tya				tya 								; get offset
.c15a					_IFSOkay:
.c15a	38		sec				sec
.c15b	ad 96 03	lda $0396			lda 	ExpTemp
.c15e	f0 01		beq $c161			beq 	_IFSSkipFail
.c160	18		clc				clc
.c161					_IFSSkipFail:
.c161	68		pla				pla 								; and exit.
.c162	60		rts				rts
.c163					_IFSOverflow:
.c163	20 de ad	jsr $adde			jsr 	ERR_Handler
>c166	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>c16e	20 6f 76 65 72 66 6c 6f 77 00
.c178					IFSX1ShiftLeft:
.c178	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c17a	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c17c	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c17e	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c180	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.c181					FPSubtract:
.c181	48		pha				pha
.c182	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.c184	49 80		eor #$80			eor 	#$80
.c186	95 8b		sta $8b,x			sta 	XS2_Type,x
.c188	68		pla				pla 								; --- and fall through ---
.c189					FPAdd:
.c189	48		pha				pha
.c18a	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.c18c	d0 05		bne $c193			bne 	_FPA_NegativeLHS
.c18e	20 aa c1	jsr $c1aa			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.c191	68		pla				pla
.c192	60		rts				rts
.c193					_FPA_NegativeLHS:
.c193	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.c195	49 80		eor #$80			eor 	#$80
.c197	95 85		sta $85,x			sta 	XS_Type,x
.c199	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.c19b	49 80		eor #$80			eor 	#$80
.c19d	95 8b		sta $8b,x			sta 	XS2_Type,x
.c19f	20 aa c1	jsr $c1aa			jsr 	FPAdd_Worker 				; do the add calculation.
.c1a2	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.c1a4	49 80		eor #$80			eor 	#$80
.c1a6	95 85		sta $85,x			sta 	XS_Type,x
.c1a8	68		pla				pla
.c1a9	60		rts				rts
.c1aa					FPAdd_Worker:
.c1aa	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.c1ac	70 07		bvs $c1b5			bvs 	_FPAWExit 					; no change.
.c1ae	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.c1b0	50 07		bvc $c1b9			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.c1b2	20 ea c3	jsr $c3ea			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.c1b5					_FPAWExit:
.c1b5	20 59 c4	jsr $c459			jsr 	FPUNormalise 				; normalise the result.
.c1b8	60		rts				rts
.c1b9					_FPAWMakeSame:
.c1b9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.c1bb	38		sec				sec
.c1bc	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.c1be	f0 16		beq $c1d6			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.c1c0	da		phx				phx 								; save X
.c1c1	90 06		bcc $c1c9			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.c1c3	e8		inx				inx
.c1c4	e8		inx				inx
.c1c5	e8		inx				inx
.c1c6	e8		inx				inx
.c1c7	e8		inx				inx
.c1c8	e8		inx				inx
.c1c9					_FPAWShiftA:
.c1c9	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c1cb	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c1cd	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c1cf	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c1d1	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c1d3	fa		plx				plx 								; restore original X
.c1d4	80 e3		bra $c1b9			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.c1d6					_FPAW_DoArithmetic:
.c1d6	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.c1d8	30 28		bmi $c202			bmi 	_FPAW_BNegative
.c1da	18		clc				clc
.c1db	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c1dd	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c1df	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c1e1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c1e3	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c1e5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c1e7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c1e9	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c1eb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c1ed	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c1ef	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c1f1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c1f3	90 c0		bcc $c1b5			bcc 	_FPAWExit 					; no carry.
.c1f5	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.c1f7	38		sec				sec
.c1f8	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c1fa	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c1fc	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c1fe	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c200	80 b3		bra $c1b5			bra 	_FPAWExit
.c202					_FPAW_BNegative:
.c202	38		sec				sec
.c203	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c205	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.c207	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c209	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c20b	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c20d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c20f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c211	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c213	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c215	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c217	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c219	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c21b	b0 09		bcs $c226			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.c21d	20 10 c4	jsr $c410			jsr 	FPUNegateInteger			; negate the mantissa
.c220	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.c222	49 80		eor #$80			eor 	#$80
.c224	95 85		sta $85,x			sta 	XS_Type,x
.c226					_FPAWGoExit:
.c226	4c b5 c1	jmp $c1b5			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.c229					FPD_IsDivZero:
.c229	20 de ad	jsr $adde			jsr ERR_Handler
>c22c	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>c234	20 62 79 20 7a 65 72 6f 00
.c23d					FPDivide:
.c23d	48		pha				pha
.c23e	5a		phy				phy
.c23f	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.c241	70 e6		bvs $c229			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.c243	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.c245	f0 03		beq $c24a			beq 	_FPDCalculateExp
.c247					_FPD_Exit:
.c247	7a		ply				ply
.c248	68		pla				pla
.c249	60		rts				rts
.c24a					_FPDCalculateExp:
.c24a	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.c24c	49 ff		eor #$ff			eor 	#$FF
.c24e	1a		inc a				inc 	a
.c24f	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.c251	20 21 c3	jsr $c321			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.c254	18		clc				clc 	 							; add 1 to the resulting exponent
.c255	69 01		adc #$01			adc 	#1
.c257	b0 54		bcs $c2ad			bcs 	_FPD_Overflow 				; which can overflow.
.c259	95 84		sta $84,x			sta 	XS_Exponent,x
.c25b	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.c25d	85 1a		sta $1a				sta 	zLTemp1+0
.c25f	85 1b		sta $1b				sta 	zLTemp1+1
.c261	85 1c		sta $1c				sta 	zLTemp1+2
.c263	85 1d		sta $1d				sta 	zLTemp1+3
.c265	a0 20		ldy #$20			ldy 	#32 						; times round.
.c267					_FPD_Loop:
.c267	38		sec				sec 								; calculate X1-X2 stacking result because we might
.c268	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.c26a	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.c26c	48		pha				pha
.c26d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c26f	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.c271	48		pha				pha
.c272	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c274	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.c276	48		pha				pha
.c277	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c279	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.c27b	90 13		bcc $c290			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.c27d	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.c27f	68		pla				pla
.c280	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c282	68		pla				pla
.c283	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c285	68		pla				pla
.c286	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c288	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.c28a	09 80		ora #$80			ora 	#$80
.c28c	85 1d		sta $1d				sta 	zLTemp1+3
.c28e	80 03		bra $c293			bra 	_FPD_Rotates
.c290					_FPD_NoSubtract:
.c290	68		pla				pla 								; throw away unwanted results
.c291	68		pla				pla
.c292	68		pla				pla
.c293					_FPD_Rotates:
.c293	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.c295	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.c297	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.c299	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.c29b	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.c29d	26 1b		rol $1b				rol 	zLTemp1+1
.c29f	26 1c		rol $1c				rol 	zLTemp1+2
.c2a1	26 1d		rol $1d				rol 	zLTemp1+3
.c2a3	90 02		bcc $c2a7			bcc 	_FPD_NoCarry
.c2a5	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.c2a7					_FPD_NoCarry:
.c2a7	88		dey				dey 								; do 32 times
.c2a8	d0 bd		bne $c267			bne 	_FPD_Loop
.c2aa	4c 05 c3	jmp $c305			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.c2ad					_FPD_Overflow:
.c2ad	4c b6 c4	jmp $c4b6			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.c2b0					FPMultiply:
.c2b0	48		pha				pha
.c2b1	5a		phy				phy
.c2b2	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.c2b4	70 07		bvs $c2bd			bvs 	_FPM_Exit
.c2b6	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.c2b8	50 06		bvc $c2c0			bvc 	_FPM_CalcExponent
.c2ba	20 ea c3	jsr $c3ea			jsr 	FPUCopyX2ToX1
.c2bd					_FPM_Exit:
.c2bd	7a		ply				ply
.c2be	68		pla				pla
.c2bf	60		rts				rts
.c2c0					_FPM_CalcExponent:
.c2c0	18		clc				clc
.c2c1	20 21 c3	jsr $c321			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.c2c4	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.c2c6	a9 00		lda #$00			lda 	#0
.c2c8	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.c2ca	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.c2cc	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.c2ce	85 1d		sta $1d				sta 	zLTemp1+3
.c2d0	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.c2d2					_FPM_Loop:
.c2d2	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.c2d4	29 01		and #$01			and 	#1
.c2d6	18		clc				clc 								; clear carry for the long rotate.
.c2d7	f0 19		beq $c2f2			beq 	_FPM_NoAddition
.c2d9	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.c2da	a5 1a		lda $1a				lda 	zLTemp1+0
.c2dc	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.c2de	85 1a		sta $1a				sta 	zLTemp1+0
.c2e0	a5 1b		lda $1b				lda 	zLTemp1+1
.c2e2	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.c2e4	85 1b		sta $1b				sta 	zLTemp1+1
.c2e6	a5 1c		lda $1c				lda 	zLTemp1+2
.c2e8	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.c2ea	85 1c		sta $1c				sta 	zLTemp1+2
.c2ec	a5 1d		lda $1d				lda 	zLTemp1+3
.c2ee	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.c2f0	85 1d		sta $1d				sta 	zLTemp1+3
.c2f2					_FPM_NoAddition:
.c2f2	66 1d		ror $1d				ror 	3+zLTemp1
.c2f4	66 1c		ror $1c				ror 	2+zLTemp1
.c2f6	66 1b		ror $1b				ror 	1+zLTemp1
.c2f8	66 1a		ror $1a				ror 	0+zLTemp1
.c2fa	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c2fc	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c2fe	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c300	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c302	88		dey				dey
.c303	d0 cd		bne $c2d2			bne 	_FPM_Loop 					; do this 32 times.
.c305					FPM_CopySignNormalize:
.c305	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.c307	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.c309	a5 1b		lda $1b				lda 	zLTemp1+1
.c30b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c30d	a5 1c		lda $1c				lda 	zLTemp1+2
.c30f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c311	a5 1d		lda $1d				lda 	zLTemp1+3
.c313	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c315	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.c317	55 8b		eor $8b,x			eor 	XS2_Type,x
.c319	95 85		sta $85,x			sta 	XS_Type,x
.c31b	20 59 c4	jsr $c459			jsr 	FPUNormalise 				; normalise and exit.
.c31e	7a		ply				ply
.c31f	68		pla				pla
.c320	60		rts				rts
.c321					FPCalculateExponent:
.c321	18		clc				clc
.c322	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.c324	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.c326	b0 08		bcs $c330			bcs 	_FPCECarry 					; carry out ?
.c328	10 03		bpl $c32d			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.c32a	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.c32c	60		rts				rts
.c32d					_FPCEExpZero:
.c32d	a9 00		lda #$00			lda 	#0
.c32f	60		rts				rts
.c330					_FPCECarry:
.c330	30 03		bmi $c335			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.c332	09 80		ora #$80			ora 	#$80 						; put in right range
.c334	60		rts				rts
.c335					_FPCEOverflow:
.c335	4c b6 c4	jmp $c4b6			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.c338					FPFractionalPart:
.c338	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.c33a	38		sec				sec 								; this flag tells us to keep the fractional part
.c33b	30 0d		bmi $c34a			bmi 	FPGetPart
.c33d	60		rts				rts
.c33e					FPIntegerPart:
.c33e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.c340	18		clc				clc 								; this flag says keep the integer part.
.c341	30 07		bmi $c34a			bmi 	FPGetPart 					; -ve exponents are 0..127
.c343	48		pha				pha
.c344	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.c346	95 85		sta $85,x			sta 	XS_Type,x
.c348	68		pla				pla
.c349	60		rts				rts
.c34a					FPGetPart:
.c34a	48		pha				pha
.c34b	5a		phy				phy 								; save Y
.c34c	08		php				php 								; save action
.c34d	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.c34f	70 59		bvs $c3aa			bvs 	_FPGP_Exit 					; then do nothing.
.c351	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.c353	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.c355	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.c357	85 1c		sta $1c				sta 	zLTemp1+2
.c359	85 1d		sta $1d				sta 	zLTemp1+3
.c35b	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.c35d	38		sec				sec
.c35e	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.c360	f0 12		beq $c374			beq 	_FPGP_NoShift 				; ... if any
.c362	c9 20		cmp #$20			cmp 	#32
.c364	90 02		bcc $c368			bcc 	_FPGP_NotMax
.c366	a9 20		lda #$20			lda 	#32 						; max of 32.
.c368					_FPGP_NotMax:
.c368	a8		tay				tay 								; Y is the mask shift count.
.c369					_FPGP_ShiftMask:
.c369	46 1d		lsr $1d				lsr 	3+zLTemp1
.c36b	66 1c		ror $1c				ror 	2+zLTemp1
.c36d	66 1b		ror $1b				ror 	1+zLTemp1
.c36f	66 1a		ror $1a				ror 	0+zLTemp1
.c371	88		dey				dey
.c372	d0 f5		bne $c369			bne 	_FPGP_ShiftMask
.c374					_FPGP_NoShift:
.c374	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.c376	8e 96 03	stx $0396			stx 	ExpTemp						; save X
.c379					_FPGP_MaskLoop:
.c379	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.c37c	28		plp				plp 								; if CC we keep the top part, so we
.c37d	08		php				php		 							; flip the mask.
.c37e	b0 02		bcs $c382			bcs		_FPGP_NoFlip
.c380	49 ff		eor #$ff			eor 	#$FF
.c382					_FPGP_NoFlip:
.c382	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.c384	95 80		sta $80,x			sta 	XS_Mantissa,x
.c386	e8		inx				inx
.c387	c8		iny				iny
.c388	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.c38a	d0 ed		bne $c379			bne 	_FPGP_MaskLoop
.c38c	ae 96 03	ldx $0396			ldx 	ExpTemp						; restore X
.c38f	28		plp				plp
.c390	08		php				php 								; get action flag on the stack
.c391	90 04		bcc $c397			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.c393	a9 00		lda #$00			lda 	#0
.c395	95 85		sta $85,x			sta 	XS_Type,x
.c397					_FPGP_NotFractional:
.c397	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.c399	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c39b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c39d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c39f	f0 05		beq $c3a6			beq 	_FPGP_Zero 					; if zero, return zero
.c3a1	20 59 c4	jsr $c459			jsr 	FPUNormalise
.c3a4	80 04		bra $c3aa			bra 	_FPGP_Exit 					; and exit
.c3a6					_FPGP_Zero:
.c3a6	a9 40		lda #$40			lda 	#$40 						; set zero flag
.c3a8	95 85		sta $85,x			sta 	XS_Type,x
.c3aa					_FPGP_Exit:
.c3aa	68		pla				pla 								; throw saved action flag.
.c3ab	7a		ply				ply
.c3ac	68		pla				pla
.c3ad	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.c3ae					FPCompare:
.c3ae	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.c3b0	48		pha				pha
.c3b1	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.c3b3	48		pha				pha
.c3b4	20 81 c1	jsr $c181			jsr 	FPSubtract 					; calculate X1-X2
.c3b7	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.c3b9	70 2a		bvs $c3e5			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.c3bb	68		pla				pla
.c3bc	8d 96 03	sta $0396			sta 	ExpTemp						; save first exponent in temporary reg.
.c3bf	68		pla				pla
.c3c0	38		sec				sec
.c3c1	ed 96 03	sbc $0396			sbc 	ExpTemp 					; calculate AX-BX
.c3c4	70 14		bvs $c3da			bvs 	_FPCNotEqual				; overflow, can't be equal.
.c3c6	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.c3c7	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.c3c9	b0 0f		bcs $c3da			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.c3cb	38		sec				sec
.c3cc	ad 96 03	lda $0396			lda 	ExpTemp 					; get one of the exponents back.
.c3cf	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.c3d1	b0 02		bcs $c3d5			bcs 	_FPCNotRange 				; keep in range.
.c3d3	a9 01		lda #$01			lda 	#1
.c3d5					_FPCNotRange:
.c3d5	38		sec				sec
.c3d6	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.c3d8	b0 0d		bcs $c3e7			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.c3da					_FPCNotEqual:
.c3da	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.c3dc	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.c3de	f0 02		beq $c3e2			beq 	_FPCNE2
.c3e0	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.c3e2	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.c3e3	80 04		bra $c3e9			bra 	_FPCExit
.c3e5					_FPCPullZero:
.c3e5	68		pla				pla 								; throw saved exponents
.c3e6	68		pla				pla
.c3e7					_FPCZero:
.c3e7	a9 00		lda #$00			lda 	#0 							; and return zero
.c3e9					_FPCExit:
.c3e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.c3ea					FPUCopyX2ToX1:
.c3ea	48		pha				pha
.c3eb	da		phx				phx
.c3ec	5a		phy				phy
.c3ed	a0 08		ldy #$08			ldy 	#8
.c3ef	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.c3f1	95 80		sta $80,x			sta 	XS_Mantissa,x
.c3f3	e8		inx				inx
.c3f4	88		dey				dey
.c3f5	10 f8		bpl $c3ef			bpl 	_FPUC21
.c3f7	7a		ply				ply
.c3f8	fa		plx				plx
.c3f9	68		pla				pla
.c3fa	60		rts				rts
.c3fb					FPUSetInteger:
.c3fb	48		pha				pha
.c3fc	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.c3fe	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.c400	10 02		bpl $c404			bpl 	_FPUSIExtend
.c402	a9 ff		lda #$ff			lda 	#$FF
.c404					_FPUSIExtend:
.c404	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.c406	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c408	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c40a	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.c40c	95 85		sta $85,x			sta 	XS_Type,x
.c40e	68		pla				pla
.c40f	60		rts				rts
.c410					FPUNegateInteger:
.c410	48		pha				pha
.c411	38		sec				sec
.c412	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.c414	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c416	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c418	a9 00		lda #$00			lda 	#0
.c41a	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c41c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c41e	a9 00		lda #$00			lda 	#0
.c420	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.c422	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c424	a9 00		lda #$00			lda 	#0
.c426	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.c428	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c42a	68		pla				pla
.c42b	60		rts				rts
.c42c					FPUToFloat:
.c42c	48		pha				pha
.c42d	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.c42f	29 0f		and #$0f			and 	#$0F
.c431	f0 24		beq $c457			beq 	_FPUFExit
.c433	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.c435	95 85		sta $85,x			sta 	XS_Type,x
.c437	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.c439	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.c43b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.c43d	10 07		bpl $c446			bpl		_FPUFPositive
.c43f	20 10 c4	jsr $c410			jsr 	FPUNegateInteger 			; negate the mantissa
.c442	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.c444	95 85		sta $85,x			sta 	XS_Type,x
.c446					_FPUFPositive:
.c446	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.c448	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c44a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c44c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c44e	d0 04		bne $c454			bne 	_FPUFNonZero
.c450	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.c452	95 85		sta $85,x			sta 	XS_Type,x
.c454					_FPUFNonZero:
.c454	20 59 c4	jsr $c459			jsr 	FPUNormalise 				; normalise the floating point.
.c457					_FPUFExit:
.c457	68		pla				pla
.c458	60		rts				rts
.c459					FPUNormalise:
.c459	48		pha				pha
.c45a	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.c45c	70 18		bvs $c476			bvs 	_FPUNExit
.c45e	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.c460	f0 10		beq $c472			beq 	_FPUNSetZero
.c462					_FPUNLoop:
.c462	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.c464	30 10		bmi $c476			bmi 	_FPUNExit 					; if so, we are normalised.
.c466	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.c468	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.c46a	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.c46c	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.c46e	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.c470	d0 f0		bne $c462			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.c472					_FPUNSetZero:
.c472	a9 40		lda #$40			lda 	#$40
.c474	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.c476					_FPUNExit:
.c476	68		pla				pla
.c477	60		rts				rts
.c478					FPUToInteger:
.c478	48		pha				pha
.c479	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.c47b	29 01		and #$01			and 	#1
.c47d	d0 31		bne $c4b0			bne 	_FPUTOI_Exit
.c47f	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.c481	70 23		bvs $c4a6			bvs 	_FPUTOI_Zero
.c483	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.c485	10 1f		bpl $c4a6			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.c487	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.c489	b0 2b		bcs $c4b6			bcs 	FP_Overflow
.c48b					_FPUToIToInteger:
.c48b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.c48d	c9 a0		cmp #$a0			cmp 	#128+32
.c48f	f0 0c		beq $c49d			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.c491	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.c493	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.c495	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c497	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c499	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c49b	80 ee		bra $c48b			bra 	_FPUToIToInteger 			; keep going.
.c49d					_FPUToICheckSign:
.c49d	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.c49f	10 0f		bpl $c4b0			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c4a1	20 10 c4	jsr $c410			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c4a4	80 0a		bra $c4b0			bra 	_FPUTOI_Exit
.c4a6					_FPUTOI_Zero:
.c4a6	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c4a8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c4aa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c4ac	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c4ae	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c4b0					_FPUToI_Exit:
.c4b0	a9 01		lda #$01			lda 	#1 							; set type to integer
.c4b2	95 85		sta $85,x			sta 	XS_Type,x
.c4b4	68		pla				pla
.c4b5	60		rts				rts
.c4b6					FP_Overflow:
.c4b6	20 de ad	jsr $adde			jsr ERR_Handler
>c4b9	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c4c1	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c4d1					FPUTimes10:
.c4d1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c4d3	85 1a		sta $1a				sta 	ZLTemp1+0
.c4d5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c4d7	85 1b		sta $1b				sta 	ZLTemp1+1
.c4d9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c4db	85 1c		sta $1c				sta 	ZLTemp1+2
.c4dd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c4df	85 1d		sta $1d				sta 	ZLTemp1+3
.c4e1	20 16 c5	jsr $c516			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c4e4	20 16 c5	jsr $c516			jsr 	_FPUT_LSR_ZLTemp1
.c4e7	18		clc				clc
.c4e8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c4ea	65 1a		adc $1a				adc 	ZLTemp1+0
.c4ec	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c4ee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c4f0	65 1b		adc $1b				adc 	ZLTemp1+1
.c4f2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c4f4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c4f6	65 1c		adc $1c				adc 	ZLTemp1+2
.c4f8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c4fa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c4fc	65 1d		adc $1d				adc 	ZLTemp1+3
.c4fe	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c500	90 0a		bcc $c50c			bcc 	_FPUTimes10
.c502	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.c504	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.c506	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.c508	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.c50a	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.c50c					_FPUTimes10:
.c50c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c50e	18		clc				clc
.c50f	69 03		adc #$03			adc 	#3
.c511	95 84		sta $84,x			sta 	XS_Exponent,x
.c513	b0 a1		bcs $c4b6			bcs 	FP_Overflow 				; error
.c515	60		rts				rts
.c516					_FPUT_LSR_ZLTemp1:
.c516	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c518	66 1c		ror $1c				ror 	ZLTemp1+2
.c51a	66 1b		ror $1b				ror 	ZLTemp1+1
.c51c	66 1a		ror $1a				ror 	ZLTemp1+0
.c51e	60		rts				rts
.c51f					FPUScale10A:
.c51f	5a		phy				phy
.c520	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c522	f0 37		beq $c55b			beq 	_FPUScaleExit
.c524	da		phx				phx 								; save X
.c525	e8		inx				inx
.c526	e8		inx				inx
.c527	e8		inx				inx
.c528	e8		inx				inx
.c529	e8		inx				inx
.c52a	e8		inx				inx
.c52b	a8		tay				tay 								; save power scalar in Y.
.c52c	a9 00		lda #$00			lda 	#0
.c52e	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c530	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c532	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c534	95 85		sta $85,x			sta 	XS_Type,x
.c536	a9 80		lda #$80			lda 	#$80
.c538	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c53a	a9 81		lda #$81			lda 	#$81
.c53c	95 84		sta $84,x			sta 	XS_Exponent,x
.c53e	5a		phy				phy 								; save 10^n on stack.
.c53f	c0 00		cpy #$00			cpy 	#0
.c541	10 05		bpl $c548			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c543	98		tya				tya
.c544	49 ff		eor #$ff			eor 	#$FF
.c546	1a		inc a				inc 	a
.c547	a8		tay				tay
.c548					_FPUSAbs:
.c548	20 d1 c4	jsr $c4d1			jsr 	FPUTimes10
.c54b	88		dey				dey
.c54c	d0 fa		bne $c548			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c54e	68		pla				pla 								; restore count in A
.c54f	fa		plx				plx 								; restore X pointing to number to scale.
.c550	0a		asl a				asl 	a
.c551	b0 05		bcs $c558			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c553	20 b0 c2	jsr $c2b0			jsr 	FPMultiply 					; if clear multiply.
.c556	80 03		bra $c55b			bra		_FPUScaleExit
.c558					_FPUSDivide:
.c558	20 3d c2	jsr $c23d			jsr 	FPDivide
.c55b					_FPUScaleExit:
.c55b	7a		ply				ply
.c55c	60		rts				rts
.c55d					FPUCopyToNext:
.c55d	a0 06		ldy #$06			ldy 		#6
.c55f	da		phx				phx
.c560					_FPUCopy1:
.c560	b5 80		lda $80,x			lda 	XS_Mantissa,x
.c562	95 86		sta $86,x			sta 	XS2_Mantissa,x
.c564	e8		inx				inx
.c565	88		dey				dey
.c566	d0 f8		bne $c560			bne 	_FPUCopy1
.c568	fa		plx				plx
.c569	60		rts				rts
.c56a					FPUCopyFromNext:
.c56a	a0 06		ldy #$06			ldy 		#6
.c56c	da		phx				phx
.c56d					_FPUCopy1:
.c56d	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.c56f	95 80		sta $80,x			sta 	XS_Mantissa,x
.c571	e8		inx				inx
.c572	88		dey				dey
.c573	d0 f8		bne $c56d			bne 	_FPUCopy1
.c575	fa		plx				plx
.c576	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c577					FPToString:
.c577	48		pha				pha
.c578	5a		phy				phy
.c579	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.c57b	50 0a		bvc $c587			bvc 		_FPTSIsFloat 			; if zero,
.c57d					_FPTSZero:
.c57d	a9 30		lda #$30			lda 		#"0"
.c57f	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter
.c582					_FPTSExit:
.c582	7a		ply				ply
.c583	68		pla				pla
.c584	60		rts				rts
.c585	80 fb		bra $c582			bra 		_FPTSExit
.c587					_FPTSIsFloat:
.c587	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.c589	10 09		bpl $c594			bpl 		_FPTSNotSigned
.c58b	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c58d	95 85		sta $85,x			sta 		XS_Type,x
.c58f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c591	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter
.c594					_FPTSNotSigned:
.c594	b5 84		lda $84,x			lda 		XS_Exponent,x
.c596	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c598	b0 09		bcs $c5a3			bcs 		_FPTSExponent
.c59a	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c59c	90 05		bcc $c5a3			bcc 		_FPTSExponent 			;
.c59e					_FPTSStandard:
.c59e	20 e2 c5	jsr $c5e2			jsr 		FPTOutputBody 			; output the body.
.c5a1	80 df		bra $c582			bra 		_FPTSExit
.c5a3					_FPTSExponent:
.c5a3	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c5a5	8d 97 03	sta $0397			sta 		ExpCount
.c5a8					_FPTSExponentLoop:
.c5a8	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c5aa	10 0e		bpl $c5ba			bpl 		_FPTSTimes
.c5ac	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c5ae	90 14		bcc $c5c4			bcc 		_FPTSScaledToExp
.c5b0	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c5b2	20 1f c5	jsr $c51f			jsr 		FPUScale10A
.c5b5	ee 97 03	inc $0397			inc 		ExpCount
.c5b8	80 ee		bra $c5a8			bra 		_FPTSExponentLoop
.c5ba					_FPTSTimes:
.c5ba	a9 01		lda #$01			lda 		#1
.c5bc	20 1f c5	jsr $c51f			jsr 		FPUScale10A
.c5bf	ce 97 03	dec $0397			dec 		ExpCount
.c5c2	80 e4		bra $c5a8			bra 		_FPTSExponentLoop
.c5c4					_FPTSScaledToExp:
.c5c4	20 e2 c5	jsr $c5e2			jsr 		FPTOutputBody 			; output the body.
.c5c7	a9 65		lda #$65			lda 		#"e"					; output E
.c5c9	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter
.c5cc	ad 97 03	lda $0397			lda 		ExpCount 				; get the exponent
.c5cf	95 80		sta $80,x			sta 		XS_Mantissa,x
.c5d1	29 80		and #$80			and 		#$80 					; sign extend it
.c5d3	f0 02		beq $c5d7			beq 		_FPTSSExt
.c5d5	a9 ff		lda #$ff			lda 		#$FF
.c5d7					_FPTSSExt:
.c5d7	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.c5d9	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.c5db	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.c5dd	20 40 c0	jsr $c040			jsr 		INTToString 			; output the exponent.
.c5e0	80 a0		bra $c582			bra			_FPTSExit 				; and exit.
.c5e2					FPTOutputBody:
.c5e2	20 5d c5	jsr $c55d			jsr 		FPUCopyToNext 			; copy to next slot.
.c5e5	20 78 c4	jsr $c478			jsr 		FPUToInteger 			; convert to an integer
.c5e8	20 40 c0	jsr $c040			jsr 		INTToString 			; output the main integer part.
.c5eb	20 6a c5	jsr $c56a			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c5ee	20 38 c3	jsr $c338			jsr 		FPFractionalPart 		; get the decimal part.
.c5f1	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.c5f3	70 3c		bvs $c631			bvs 		_FPTOExit 				; if not, exit now.
.c5f5	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c5f7	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter
.c5fa					_FPOutLoop:
.c5fa	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.c5fc	70 1d		bvs $c61b			bvs 		_FPStripZeros 			; strip trailing zeros
.c5fe	20 d1 c4	jsr $c4d1			jsr 		FPUTimes10 				; multiply by 10
.c601	20 5d c5	jsr $c55d			jsr 		FPUCopyToNext			; copy to next slot.
.c604	20 78 c4	jsr $c478			jsr 		FPUToInteger 			; convert to integer
.c607	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.c609	09 30		ora #$30			ora 		#"0"
.c60b	20 de c0	jsr $c0de			jsr 		ITSOutputCharacter
.c60e	20 6a c5	jsr $c56a			jsr 		FPUCopyFromNext 		; get it back
.c611	20 38 c3	jsr $c338			jsr 		FPFractionalPart 		; get fractional part
.c614	ad 0e 03	lda $030e			lda 		NumBufX 				; done 11 characters yet ?
.c617	c9 0b		cmp #$0b			cmp 	 	#11
.c619	90 df		bcc $c5fa			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c61b					_FPStripZeros:
.c61b	ac 0e 03	ldy $030e			ldy 		NumBufX 				; strip trailing zeros.
.c61e					_FPStripLoop:
.c61e	88		dey				dey 								; back one, if at start then no strip
.c61f	f0 10		beq $c631			beq 		_FPToExit
.c621	b9 0f 03	lda $030f,y			lda 		Num_Buffer,y 			; keep going if "0"
.c624	c9 30		cmp #$30			cmp 		#"0"
.c626	f0 f6		beq $c61e			beq 		_FPStripLoop
.c628	c8		iny				iny
.c629	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c62b	99 0f 03	sta $030f,y			sta 		Num_Buffer,y
.c62e	8c 0e 03	sty $030e			sty 		NumBufX 				; update position.
.c631					_FPTOExit:
.c631	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c632					FPFromString:
.c632	48		pha				pha 								; push A
.c633	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c635	c9 2e		cmp #$2e			cmp 	#"."
.c637	f0 03		beq $c63c			beq	 	_FPFIsDecimal
.c639	4c 98 c6	jmp $c698			jmp 	_FPFNotDecimal
.c63c					_FPFIsDecimal:
.c63c	c8		iny				iny 								; consume the decimal.
.c63d	20 2c c4	jsr $c42c			jsr 	FPUToFloat 					; convert the integer to float.
.c640	da		phx				phx 								; save X.
.c641	5a		phy				phy 								; save decimal start position
.c642	e8		inx				inx
.c643	e8		inx				inx
.c644	e8		inx				inx
.c645	e8		inx				inx
.c646	e8		inx				inx
.c647	e8		inx				inx
.c648	20 f6 c0	jsr $c0f6			jsr 	INTFromStringY 				; get the part after the DP.
.c64b	20 2c c4	jsr $c42c			jsr 	FPUToFloat 					; convert that to a float.
.c64e	68		pla				pla 								; calculate - chars consumed.
.c64f	8c 96 03	sty $0396			sty 	ExpTemp
.c652	38		sec				sec
.c653	ed 96 03	sbc $0396			sbc 	ExpTemp 					; this is the shift amount
.c656	20 1f c5	jsr $c51f			jsr 	FPUScale10A 				; scale it by 10^AC
.c659	fa		plx				plx 								; restore original X
.c65a	20 89 c1	jsr $c189			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c65d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c65f	c9 45		cmp #$45			cmp 	#"E"
.c661	f0 04		beq $c667			beq 	_FPFExponent
.c663	c9 65		cmp #$65			cmp 	#"e"
.c665	d0 31		bne $c698			bne 	_FPFNotDecimal 				; no, then exit normally.
.c667					_FPFExponent:
.c667	c8		iny				iny 								; skip over E symbol.
.c668	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c66a	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c66c	d0 01		bne $c66f			bne 	_FPFGotSign
.c66e	c8		iny				iny 								; if it was - skip over it.
.c66f					_FPFGotSign:
.c66f	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c670	da		phx				phx
.c671	e8		inx				inx
.c672	e8		inx				inx
.c673	e8		inx				inx
.c674	e8		inx				inx
.c675	e8		inx				inx
.c676	e8		inx				inx
.c677	20 f6 c0	jsr $c0f6			jsr 	INTFromStringY 				; get the exponent
.c67a	fa		plx				plx 								; restore X.
.c67b	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c67d	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.c67f	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.c681	d0 17		bne $c69a			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c683	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c685	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c687	b0 11		bcs $c69a			bcs 	_FPFXOverflow
.c689	68		pla				pla 								; get direction
.c68a	d0 07		bne $c693			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c68c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c68e	49 ff		eor #$ff			eor 	#$FF
.c690	1a		inc a				inc 	a
.c691	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.c693					_FPFXScale:
.c693	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c695	20 1f c5	jsr $c51f			jsr 	FPUScale10A 				; scale by the exponent.
.c698					_FPFNotDecimal:
.c698	68		pla				pla
.c699	60		rts				rts
.c69a					_FPFXOverflow:
.c69a	20 de ad	jsr $adde			jsr 	ERR_Handler
>c69d	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c6a5	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c6ac					Unary_Rnd:
.c6ac	20 9a b4	jsr $b49a			jsr 	EvaluateNumberX 			; get value
.c6af	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; check right bracket.
.c6b2	20 18 b7	jsr $b718			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c6b5	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c6b7	30 10		bmi $c6c9			bmi 	_URSetSeed
.c6b9	f0 28		beq $c6e3			beq 	_URMakeRandom 				; if zero return same number.
.c6bb	da		phx				phx
.c6bc	a2 00		ldx #$00			ldx 	#0
.c6be	20 1a c7	jsr $c71a			jsr 	Random16
.c6c1	a2 02		ldx #$02			ldx 	#2
.c6c3	20 1a c7	jsr $c71a			jsr 	Random16
.c6c6	fa		plx				plx
.c6c7	80 1a		bra $c6e3			bra 	_URMakeRandom
.c6c9					_URSetSeed:
.c6c9	20 2c c4	jsr $c42c			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c6cc	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c6ce	8d 9d 03	sta $039d			sta 	RandomSeed+0
.c6d1	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.c6d3	8d 9e 03	sta $039e			sta 	RandomSeed+1
.c6d6	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.c6d8	8d 9f 03	sta $039f			sta 	RandomSeed+2
.c6db	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.c6dd	0a		asl a				asl 	a
.c6de	49 db		eor #$db			eor 	#$DB
.c6e0	8d a0 03	sta $03a0			sta 	RandomSeed+3
.c6e3					_URMakeRandom:
.c6e3	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; check if seed is zero.
.c6e6	0d 9e 03	ora $039e			ora 	RandomSeed+1
.c6e9	0d 9f 03	ora $039f			ora 	RandomSeed+2
.c6ec	0d a0 03	ora $03a0			ora 	RandomSeed+3
.c6ef	d0 0a		bne $c6fb			bne 	_URNotZero
.c6f1	a9 47		lda #$47			lda 	#$47
.c6f3	8d 9e 03	sta $039e			sta 	RandomSeed+1				; if it is, make it non zero.
.c6f6	a9 3d		lda #$3d			lda 	#$3D
.c6f8	8d a0 03	sta $03a0			sta 	RandomSeed+3
.c6fb					_URNotZero:
.c6fb	ad 9d 03	lda $039d			lda 	RandomSeed+0 				; copy seed into mantissa.
.c6fe	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c700	ad 9e 03	lda $039e			lda 	RandomSeed+1
.c703	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c705	ad 9f 03	lda $039f			lda 	RandomSeed+2
.c708	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c70a	ad a0 03	lda $03a0			lda 	RandomSeed+3
.c70d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c70f	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c711	95 85		sta $85,x			sta 	XS_Type,x
.c713	a9 80		lda #$80			lda 	#$80
.c715	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c717	4c 59 c4	jmp $c459			jmp 	FPUNormalise
.c71a					Random16:
.c71a	5e 9e 03	lsr $039e,x			lsr 	RandomSeed+1,x				; shift seed right
.c71d	7e 9d 03	ror $039d,x			ror 	RandomSeed,x
.c720	90 08		bcc $c72a			bcc 	_R16_NoXor
.c722	bd 9e 03	lda $039e,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c725	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c727	9d 9e 03	sta $039e,x			sta 	RandomSeed+1,x
.c72a					_R16_NoXor:
.c72a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c72b					Unary_Int:
.c72b	20 9a b4	jsr $b49a			jsr 	EvaluateNumberX 			; get value
.c72e	20 b6 ba	jsr $bab6			jsr 	CheckNextRParen 			; check right bracket.
.c731	4c 78 c4	jmp $c478			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c734	80 fe		bra $c734	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	95 ac					.word TIM_BreakVector

;******  End of listing
