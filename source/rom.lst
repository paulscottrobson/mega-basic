
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Tue Sep  3 12:02:05 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=1					autorun = 1
=3					loadtest = 3
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>8000	0c 0a 00 c7 1a 32 12 04			.byte	$0c,$0a,$00,$c7,$1a,$32,$12,$04
>8008	b8 42 be 00 0f 14 00 c7			.byte	$b8,$42,$be,$00,$0f,$14,$00,$c7
>8010	08 34 16 0b 10 bc 42 bf			.byte	$08,$34,$16,$0b,$10,$bc,$42,$bf
>8018	41 be 00 09 1e 00 c7 15			.byte	$41,$be,$00,$09,$1e,$00,$c7,$15
>8020	b8 41 be 00 0b 28 00 c7			.byte	$b8,$41,$be,$00,$0b,$28,$00,$c7
>8028	05 32 02 bd 42 be 00 0c			.byte	$05,$32,$02,$bd,$42,$be,$00,$0c
>8030	32 00 c7 04 37 13 0b b8			.byte	$32,$00,$c7,$04,$37,$13,$0b,$b8
>8038	41 be 00 0c 3c 00 c7 14			.byte	$41,$be,$00,$0c,$3c,$00,$c7,$14
>8040	35 15 10 b8 42 be 00 0d			.byte	$35,$15,$10,$b8,$42,$be,$00,$0d
>8048	46 00 c7 06 34 08 03 05			.byte	$46,$00,$c7,$06,$34,$08,$03,$05
>8050	bc 42 be 00 0c 50 00 c7			.byte	$bc,$42,$be,$00,$0c,$50,$00,$c7
>8058	05 36 14 13 bc 41 be 00			.byte	$05,$36,$14,$13,$bc,$41,$be,$00
>8060	0b 5a 00 c7 14 32 16 bd			.byte	$0b,$5a,$00,$c7,$14,$32,$16,$bd
>8068	42 be 00 0c 64 00 c7 11			.byte	$42,$be,$00,$0c,$64,$00,$c7,$11
>8070	37 09 06 b8 42 be 00 0b			.byte	$37,$09,$06,$b8,$42,$be,$00,$0b
>8078	6e 00 c7 01 35 0e b8 42			.byte	$6e,$00,$c7,$01,$35,$0e,$b8,$42
>8080	be 00 0b 78 00 c7 13 34			.byte	$be,$00,$0b,$78,$00,$c7,$13,$34
>8088	02 ba 42 be 00 13 82 00			.byte	$02,$ba,$42,$be,$00,$13,$82,$00
>8090	cf 02 39 04 0a 07 b9 84			.byte	$cf,$02,$39,$04,$0a,$07,$b9,$84
>8098	42 67 fd 05 38 37 35 00			.byte	$42,$67,$fd,$05,$38,$37,$35,$00
>80a0	11 8c 00 cf 01 b9 84 8b			.byte	$11,$8c,$00,$cf,$01,$b9,$84,$8b
>80a8	43 6f fd 06 34 33 37 35			.byte	$43,$6f,$fd,$06,$34,$33,$37,$35
>80b0	00 10 96 00 cf 04 37 10			.byte	$00,$10,$96,$00,$cf,$04,$37,$10
>80b8	84 47 5a fd 05 31 32 35			.byte	$84,$47,$5a,$fd,$05,$31,$32,$35
>80c0	00 13 a0 00 cf 05 31 19			.byte	$00,$13,$a0,$00,$cf,$05,$31,$19
>80c8	19 84 8b 44 7c fd 06 33			.byte	$19,$84,$8b,$44,$7c,$fd,$06,$33
>80d0	31 32 35 00 10 aa 00 cf			.byte	$31,$32,$35,$00,$10,$aa,$00,$cf
>80d8	18 b9 84 47 5a fd 06 33			.byte	$18,$b9,$84,$47,$5a,$fd,$06,$33
>80e0	31 32 35 00 0a b4 00 cf			.byte	$31,$32,$35,$00,$0a,$b4,$00,$cf
>80e8	13 bb 84 4b 74 00 10 be			.byte	$13,$bb,$84,$4b,$74,$00,$10,$be
>80f0	00 cf 15 30 01 84 8b 49			.byte	$00,$cf,$15,$30,$01,$84,$8b,$49
>80f8	57 fd 04 32 35 00 14 c8			.byte	$57,$fd,$04,$32,$35,$00,$14,$c8
>8100	00 cf 05 31 11 17 09 b9			.byte	$00,$cf,$05,$31,$11,$17,$09,$b9
>8108	84 8b 47 5d fd 05 36 32			.byte	$84,$8b,$47,$5d,$fd,$05,$36,$32
>8110	35 00 12 d2 00 cf 05 32			.byte	$35,$00,$12,$d2,$00,$cf,$05,$32
>8118	0f 0a 10 b9 84 45 47 fd			.byte	$0f,$0a,$10,$b9,$84,$45,$47,$fd
>8120	04 32 35 00 0f dc 00 cf			.byte	$04,$32,$35,$00,$0f,$dc,$00,$cf
>8128	0e 32 0f b9 84 47 fd 04			.byte	$0e,$32,$0f,$b9,$84,$47,$fd,$04
>8130	37 35 00 0d e6 00 cf 19			.byte	$37,$35,$00,$0d,$e6,$00,$cf,$19
>8138	30 03 14 bb 84 46 6e 00			.byte	$30,$03,$14,$bb,$84,$46,$6e,$00
>8140	14 f0 00 cf 05 32 0f 0a			.byte	$14,$f0,$00,$cf,$05,$32,$0f,$0a
>8148	10 b9 84 42 77 fd 06 38			.byte	$10,$b9,$84,$42,$77,$fd,$06,$38
>8150	31 32 35 00 0e fa 00 cf			.byte	$31,$32,$35,$00,$0e,$fa,$00,$cf
>8158	09 b7 84 fe 06 55 30 45			.byte	$09,$b7,$84,$fe,$06,$55,$30,$45
>8160	47 00 0e 04 01 cf 11 37			.byte	$47,$00,$0e,$04,$01,$cf,$11,$37
>8168	08 07 01 bb 84 41 62 00			.byte	$08,$07,$01,$bb,$84,$41,$62,$00
>8170	0e 0e 01 cf 07 b7 84 fe			.byte	$0e,$0e,$01,$cf,$07,$b7,$84,$fe
>8178	06 59 31 49 49 00 13 18			.byte	$06,$59,$31,$49,$49,$00,$13,$18
>8180	01 cf 03 32 08 07 84 8b			.byte	$01,$cf,$03,$32,$08,$07,$84,$8b
>8188	46 64 fd 06 31 38 37 35			.byte	$46,$64,$fd,$06,$31,$38,$37,$35
>8190	00 0e 22 01 cf 16 35 0a			.byte	$00,$0e,$22,$01,$cf,$16,$35,$0a
>8198	0d 0e bb 84 49 7e 00 11			.byte	$0d,$0e,$bb,$84,$49,$7e,$00,$11
>81a0	2c 01 cf 09 34 13 84 43			.byte	$2c,$01,$cf,$09,$34,$13,$84,$43
>81a8	64 fd 06 36 38 37 35 00			.byte	$64,$fd,$06,$36,$38,$37,$35,$00
>81b0	11 36 01 cf 14 34 11 15			.byte	$11,$36,$01,$cf,$14,$34,$11,$15
>81b8	84 41 40 fd 05 38 37 35			.byte	$84,$41,$40,$fd,$05,$38,$37,$35
>81c0	00 10 40 01 cf 0c 31 0b			.byte	$00,$10,$40,$01,$cf,$0c,$31,$0b
>81c8	18 0b 84 46 59 fd 03 30			.byte	$18,$0b,$84,$46,$59,$fd,$03,$30
>81d0	00 12 4a 01 cf 06 31 05			.byte	$00,$12,$4a,$01,$cf,$06,$31,$05
>81d8	10 01 b9 84 8b 41 61 fd			.byte	$10,$01,$b9,$84,$8b,$41,$61,$fd
>81e0	03 35 00 10 54 01 cf 12			.byte	$03,$35,$00,$10,$54,$01,$cf,$12
>81e8	30 14 84 8b 48 56 fd 04			.byte	$30,$14,$84,$8b,$48,$56,$fd,$04
>81f0	32 35 00 11 5e 01 cf 12			.byte	$32,$35,$00,$11,$5e,$01,$cf,$12
>81f8	30 14 84 42 40 fd 06 35			.byte	$30,$14,$84,$42,$40,$fd,$06,$35
>8200	36 32 35 00 0c 68 01 cf			.byte	$36,$32,$35,$00,$0c,$68,$01,$cf
>8208	14 30 19 bb 84 4a 79 00			.byte	$14,$30,$19,$bb,$84,$4a,$79,$00
>8210	0e 72 01 cf 04 38 10 15			.byte	$0e,$72,$01,$cf,$04,$38,$10,$15
>8218	1a bb 84 41 7f 00 13 7c			.byte	$1a,$bb,$84,$41,$7f,$00,$13,$7c
>8220	01 cf 18 32 06 0e 02 84			.byte	$01,$cf,$18,$32,$06,$0e,$02,$84
>8228	49 67 fd 06 34 33 37 35			.byte	$49,$67,$fd,$06,$34,$33,$37,$35
>8230	00 0e 86 01 cf 13 37 0a			.byte	$00,$0e,$86,$01,$cf,$13,$37,$0a
>8238	08 06 bb 84 45 55 00 10			.byte	$08,$06,$bb,$84,$45,$55,$00,$10
>8240	90 01 cf 15 33 05 b9 84			.byte	$90,$01,$cf,$15,$33,$05,$b9,$84
>8248	5e fd 05 33 37 35 00 12			.byte	$5e,$fd,$05,$33,$37,$35,$00,$12
>8250	9a 01 cf 03 32 08 07 84			.byte	$9a,$01,$cf,$03,$32,$08,$07,$84
>8258	46 79 fd 06 36 38 37 35			.byte	$46,$79,$fd,$06,$36,$38,$37,$35
>8260	00 0a a4 01 cf 03 bb 84			.byte	$00,$0a,$a4,$01,$cf,$03,$bb,$84
>8268	49 7a 00 0a ae 01 cf 0e			.byte	$49,$7a,$00,$0a,$ae,$01,$cf,$0e
>8270	bb 84 43 5b 00 0f b8 01			.byte	$bb,$84,$43,$5b,$00,$0f,$b8,$01
>8278	cf 13 37 0a 08 06 bb 84			.byte	$cf,$13,$37,$0a,$08,$06,$bb,$84
>8280	8b 45 58 00 0d c2 01 cf			.byte	$8b,$45,$58,$00,$0d,$c2,$01,$cf
>8288	0f 31 0f 02 bb 84 4b 6c			.byte	$0f,$31,$0f,$02,$bb,$84,$4b,$6c
>8290	00 12 cc 01 cf 04 36 13			.byte	$00,$12,$cc,$01,$cf,$04,$36,$13
>8298	0d b9 84 8b 43 5a fd 04			.byte	$0d,$b9,$84,$8b,$43,$5a,$fd,$04
>82a0	32 35 00 12 d6 01 cf 14			.byte	$32,$35,$00,$12,$d6,$01,$cf,$14
>82a8	37 10 84 8b 41 68 fd 06			.byte	$37,$10,$84,$8b,$41,$68,$fd,$06
>82b0	31 38 37 35 00 13 e0 01			.byte	$31,$38,$37,$35,$00,$13,$e0,$01
>82b8	cf 06 31 05 10 01 b9 84			.byte	$cf,$06,$31,$05,$10,$01,$b9,$84
>82c0	43 60 fd 05 31 32 35 00			.byte	$43,$60,$fd,$05,$31,$32,$35,$00
>82c8	13 ea 01 cf 03 32 08 07			.byte	$13,$ea,$01,$cf,$03,$32,$08,$07
>82d0	84 8b 44 53 fd 06 35 36			.byte	$84,$8b,$44,$53,$fd,$06,$35,$36
>82d8	32 35 00 12 f4 01 cf 14			.byte	$32,$35,$00,$12,$f4,$01,$cf,$14
>82e0	34 11 15 84 48 4a fd 06			.byte	$34,$11,$15,$84,$48,$4a,$fd,$06
>82e8	38 31 32 35 00 14 fe 01			.byte	$38,$31,$32,$35,$00,$14,$fe,$01
>82f0	cf 13 34 02 ba 41 be 84			.byte	$cf,$13,$34,$02,$ba,$41,$be,$84
>82f8	46 62 fd 06 35 36 32 35			.byte	$46,$62,$fd,$06,$35,$36,$32,$35
>8300	00 0a 08 02 cf 13 bb 84			.byte	$00,$0a,$08,$02,$cf,$13,$bb,$84
>8308	42 52 00 14 12 02 cf 14			.byte	$42,$52,$00,$14,$12,$02,$cf,$14
>8310	35 15 10 b8 41 be 84 fe			.byte	$35,$15,$10,$b8,$41,$be,$84,$fe
>8318	07 56 32 4d 41 4f 00 13			.byte	$07,$56,$32,$4d,$41,$4f,$00,$13
>8320	1c 02 cf 0e 36 0d b9 84			.byte	$1c,$02,$cf,$0e,$36,$0d,$b9,$84
>8328	8b 42 50 fd 06 39 33 37			.byte	$8b,$42,$50,$fd,$06,$39,$33,$37
>8330	35 00 0d 26 02 cf 14 37			.byte	$35,$00,$0d,$26,$02,$cf,$14,$37
>8338	13 07 bb 84 41 48 00 12			.byte	$13,$07,$bb,$84,$41,$48,$00,$12
>8340	30 02 cf 05 37 15 1a b9			.byte	$30,$02,$cf,$05,$37,$15,$1a,$b9
>8348	84 8b 47 7f fd 04 37 35			.byte	$84,$8b,$47,$7f,$fd,$04,$37,$35
>8350	00 10 3a 02 cf 0b 39 16			.byte	$00,$10,$3a,$02,$cf,$0b,$39,$16
>8358	19 b7 84 fe 05 4b 38 4f			.byte	$19,$b7,$84,$fe,$05,$4b,$38,$4f
>8360	00 10 44 02 cf 0c 31 0f			.byte	$00,$10,$44,$02,$cf,$0c,$31,$0f
>8368	05 84 8b 42 53 fd 03 30			.byte	$05,$84,$8b,$42,$53,$fd,$03,$30
>8370	00 0f 4e 02 cf 0a 39 01			.byte	$00,$0f,$4e,$02,$cf,$0a,$39,$01
>8378	18 0d b7 84 fe 03 56 00			.byte	$18,$0d,$b7,$84,$fe,$03,$56,$00
>8380	0c 58 02 cf 0f 31 0f 02			.byte	$0c,$58,$02,$cf,$0f,$31,$0f,$02
>8388	bb 84 6b 00 10 62 02 cf			.byte	$bb,$84,$6b,$00,$10,$62,$02,$cf
>8390	0e 32 0f b9 84 8b 45 65			.byte	$0e,$32,$0f,$b9,$84,$8b,$45,$65
>8398	fd 03 30 00 11 6c 02 cf			.byte	$fd,$03,$30,$00,$11,$6c,$02,$cf
>83a0	06 35 06 0f 18 84 8b 49			.byte	$06,$35,$06,$0f,$18,$84,$8b,$49
>83a8	69 fd 03 30 00 14 76 02			.byte	$69,$fd,$03,$30,$00,$14,$76,$02
>83b0	cf 05 37 15 1a b9 84 8b			.byte	$cf,$05,$37,$15,$1a,$b9,$84,$8b
>83b8	41 46 fd 06 36 38 37 35			.byte	$41,$46,$fd,$06,$36,$38,$37,$35
>83c0	00 10 80 02 cf 15 b8 40			.byte	$00,$10,$80,$02,$cf,$15,$b8,$40
>83c8	be 84 fe 06 56 33 47 4d			.byte	$be,$84,$fe,$06,$56,$33,$47,$4d
>83d0	00 11 8a 02 cf 0a 39 01			.byte	$00,$11,$8a,$02,$cf,$0a,$39,$01
>83d8	18 0d b7 84 fe 05 50 37			.byte	$18,$0d,$b7,$84,$fe,$05,$50,$37
>83e0	51 00 0d 94 02 cf 04 39			.byte	$51,$00,$0d,$94,$02,$cf,$04,$39
>83e8	19 bb 84 8b 46 78 00 10			.byte	$19,$bb,$84,$8b,$46,$78,$00,$10
>83f0	9e 02 cf 04 37 10 84 8b			.byte	$9e,$02,$cf,$04,$37,$10,$84,$8b
>83f8	55 fd 05 31 32 35 00 13			.byte	$55,$fd,$05,$31,$32,$35,$00,$13
>8400	a8 02 cf 07 32 08 04 19			.byte	$a8,$02,$cf,$07,$32,$08,$04,$19
>8408	84 8b 44 79 fd 05 36 32			.byte	$84,$8b,$44,$79,$fd,$05,$36,$32
>8410	35 00 13 b2 02 cf 1a 32			.byte	$35,$00,$13,$b2,$02,$cf,$1a,$32
>8418	12 04 b8 41 be 84 fe 06			.byte	$12,$04,$b8,$41,$be,$84,$fe,$06
>8420	4b 36 47 53 00 0f bc 02			.byte	$4b,$36,$47,$53,$00,$0f,$bc,$02
>8428	cf 0c 36 19 b7 84 fe 05			.byte	$cf,$0c,$36,$19,$b7,$84,$fe,$05
>8430	4d 36 46 00 0a c6 02 cf			.byte	$4d,$36,$46,$00,$0a,$c6,$02,$cf
>8438	03 bb 84 49 46 00 14 d0			.byte	$03,$bb,$84,$49,$46,$00,$14,$d0
>8440	02 cf 19 32 13 05 0b 84			.byte	$02,$cf,$19,$32,$13,$05,$0b,$84
>8448	8b 47 5d fd 06 30 36 32			.byte	$8b,$47,$5d,$fd,$06,$30,$36,$32
>8450	35 00 14 da 02 cf 15 35			.byte	$35,$00,$14,$da,$02,$cf,$15,$35
>8458	14 03 11 84 8b 44 51 fd			.byte	$14,$03,$11,$84,$8b,$44,$51,$fd
>8460	06 31 38 37 35 00 11 e4			.byte	$06,$31,$38,$37,$35,$00,$11,$e4
>8468	02 cf 06 34 08 03 05 bc			.byte	$02,$cf,$06,$34,$08,$03,$05,$bc
>8470	41 be 84 8b 43 51 00 0d			.byte	$41,$be,$84,$8b,$43,$51,$00,$0d
>8478	ee 02 cf 14 30 19 bb 84			.byte	$ee,$02,$cf,$14,$30,$19,$bb,$84
>8480	8b 43 43 00 14 f8 02 cf			.byte	$8b,$43,$43,$00,$14,$f8,$02,$cf
>8488	0e 30 0b 0e 01 84 8b 42			.byte	$0e,$30,$0b,$0e,$01,$84,$8b,$42
>8490	6f fd 06 33 31 32 35 00			.byte	$6f,$fd,$06,$33,$31,$32,$35,$00
>8498	13 02 03 cf 05 38 03 04			.byte	$13,$02,$03,$cf,$05,$38,$03,$04
>84a0	17 b7 84 fe 07 58 33 4d			.byte	$17,$b7,$84,$fe,$07,$58,$33,$4d
>84a8	4c 48 00 0e 0c 03 cf 0d			.byte	$4c,$48,$00,$0e,$0c,$03,$cf,$0d
>84b0	31 14 13 bb 84 8b 49 5e			.byte	$31,$14,$13,$bb,$84,$8b,$49,$5e
>84b8	00 11 16 03 cf 0e 39 09			.byte	$00,$11,$16,$03,$cf,$0e,$39,$09
>84c0	b7 84 fe 07 4d 30 59 53			.byte	$b7,$84,$fe,$07,$4d,$30,$59,$53
>84c8	5a 00 0f 20 03 cf 09 b7			.byte	$5a,$00,$0f,$20,$03,$cf,$09,$b7
>84d0	84 fe 07 51 36 59 58 51			.byte	$84,$fe,$07,$51,$36,$59,$58,$51
>84d8	00 0f 2a 03 cf 13 31 0c			.byte	$00,$0f,$2a,$03,$cf,$13,$31,$0c
>84e0	04 b7 84 fe 04 56 33 00			.byte	$04,$b7,$84,$fe,$04,$56,$33,$00
>84e8	12 34 03 cf 05 38 03 04			.byte	$12,$34,$03,$cf,$05,$38,$03,$04
>84f0	17 b7 84 fe 06 43 34 4a			.byte	$17,$b7,$84,$fe,$06,$43,$34,$4a
>84f8	4f 00 10 3e 03 cf 12 30			.byte	$4f,$00,$10,$3e,$03,$cf,$12,$30
>8500	14 84 8b 48 6a fd 04 32			.byte	$14,$84,$8b,$48,$6a,$fd,$04,$32
>8508	35 00 12 48 03 cf 06 33			.byte	$35,$00,$12,$48,$03,$cf,$06,$33
>8510	01 12 0c b9 84 4d fd 05			.byte	$01,$12,$0c,$b9,$84,$4d,$fd,$05
>8518	33 37 35 00 0b 52 03 cf			.byte	$33,$37,$35,$00,$0b,$52,$03,$cf
>8520	13 bb 84 8b 46 6f 00 0f			.byte	$13,$bb,$84,$8b,$46,$6f,$00,$0f
>8528	5c 03 cf 08 33 08 09 84			.byte	$5c,$03,$cf,$08,$33,$08,$09,$84
>8530	49 6c fd 03 35 00 0f 66			.byte	$49,$6c,$fd,$03,$35,$00,$0f,$66
>8538	03 cf 11 84 48 7f fd 06			.byte	$03,$cf,$11,$84,$48,$7f,$fd,$06
>8540	36 38 37 35 00 11 70 03			.byte	$36,$38,$37,$35,$00,$11,$70,$03
>8548	cf 13 31 0c 04 b7 84 fe			.byte	$cf,$13,$31,$0c,$04,$b7,$84,$fe
>8550	06 4a 39 52 48 00 0e 7a			.byte	$06,$4a,$39,$52,$48,$00,$0e,$7a
>8558	03 cf 01 36 09 06 84 49			.byte	$03,$cf,$01,$36,$09,$06,$84,$49
>8560	fd 03 30 00 0e 84 03 cf			.byte	$fd,$03,$30,$00,$0e,$84,$03,$cf
>8568	03 37 17 19 b7 84 fe 03			.byte	$03,$37,$17,$19,$b7,$84,$fe,$03
>8570	49 00 0e 8e 03 cf 18 b9			.byte	$49,$00,$0e,$8e,$03,$cf,$18,$b9
>8578	84 49 6c fd 04 32 35 00			.byte	$84,$49,$6c,$fd,$04,$32,$35,$00
>8580	0e 98 03 cf 04 38 10 15			.byte	$0e,$98,$03,$cf,$04,$38,$10,$15
>8588	1a bb 84 4e 69 00 10 a2			.byte	$1a,$bb,$84,$4e,$69,$00,$10,$a2
>8590	03 cf 12 84 8b 48 5e fd			.byte	$03,$cf,$12,$84,$8b,$48,$5e,$fd
>8598	06 36 38 37 35 00 0f ac			.byte	$06,$36,$38,$37,$35,$00,$0f,$ac
>85a0	03 cf 05 36 14 13 bc 40			.byte	$03,$cf,$05,$36,$14,$13,$bc,$40
>85a8	be 84 4c 59 00 15 b6 03			.byte	$be,$84,$4c,$59,$00,$15,$b6,$03
>85b0	cf 05 31 11 17 09 b9 84			.byte	$cf,$05,$31,$11,$17,$09,$b9,$84
>85b8	8b 46 40 fd 06 35 36 32			.byte	$8b,$46,$40,$fd,$06,$35,$36,$32
>85c0	35 00 12 c0 03 cf 08 38			.byte	$35,$00,$12,$c0,$03,$cf,$08,$38
>85c8	13 0c b9 84 42 48 fd 05			.byte	$13,$0c,$b9,$84,$42,$48,$fd,$05
>85d0	38 37 35 00 10 ca 03 cf			.byte	$38,$37,$35,$00,$10,$ca,$03,$cf
>85d8	14 b9 84 8b 41 68 fd 05			.byte	$14,$b9,$84,$8b,$41,$68,$fd,$05
>85e0	36 32 35 00 13 d4 03 cf			.byte	$36,$32,$35,$00,$13,$d4,$03,$cf
>85e8	1a 31 18 03 16 b9 84 47			.byte	$1a,$31,$18,$03,$16,$b9,$84,$47
>85f0	63 fd 05 38 37 35 00 0e			.byte	$63,$fd,$05,$38,$37,$35,$00,$0e
>85f8	de 03 cf 19 30 03 14 bb			.byte	$de,$03,$cf,$19,$30,$03,$14,$bb
>8600	84 8b 4c 49 00 11 e8 03			.byte	$84,$8b,$4c,$49,$00,$11,$e8,$03
>8608	cf 15 30 01 84 42 73 fd			.byte	$cf,$15,$30,$01,$84,$42,$73,$fd
>8610	06 39 33 37 35 00 10 f2			.byte	$06,$39,$33,$37,$35,$00,$10,$f2
>8618	03 cf 14 b9 84 8b 43 6c			.byte	$03,$cf,$14,$b9,$84,$8b,$43,$6c
>8620	fd 05 36 32 35 00 11 fc			.byte	$fd,$05,$36,$32,$35,$00,$11,$fc
>8628	03 cf 01 36 09 06 84 44			.byte	$03,$cf,$01,$36,$09,$06,$84,$44
>8630	5b fd 05 31 32 35 00 13			.byte	$5b,$fd,$05,$31,$32,$35,$00,$13
>8638	06 04 cf 05 37 15 1a b9			.byte	$06,$04,$cf,$05,$37,$15,$1a,$b9
>8640	84 8b 44 6c fd 05 38 37			.byte	$84,$8b,$44,$6c,$fd,$05,$38,$37
>8648	35 00 0d 10 04 cf 13 31			.byte	$35,$00,$0d,$10,$04,$cf,$13,$31
>8650	0c 04 b7 84 fe 02 00 10			.byte	$0c,$04,$b7,$84,$fe,$02,$00,$10
>8658	1a 04 cf 0c 31 0f 05 84			.byte	$1a,$04,$cf,$0c,$31,$0f,$05,$84
>8660	8b 46 59 fd 03 35 00 12			.byte	$8b,$46,$59,$fd,$03,$35,$00,$12
>8668	24 04 cf 0c 31 0f 05 84			.byte	$24,$04,$cf,$0c,$31,$0f,$05,$84
>8670	49 64 fd 06 35 36 32 35			.byte	$49,$64,$fd,$06,$35,$36,$32,$35
>8678	00 0f 2e 04 cf 0c 36 19			.byte	$00,$0f,$2e,$04,$cf,$0c,$36,$19
>8680	b7 84 fe 05 56 39 55 00			.byte	$b7,$84,$fe,$05,$56,$39,$55,$00
>8688	11 38 04 cf 05 36 01 06			.byte	$11,$38,$04,$cf,$05,$36,$01,$06
>8690	0b 84 8b 46 7e fd 03 35			.byte	$0b,$84,$8b,$46,$7e,$fd,$03,$35
>8698	00 12 42 04 cf 19 32 13			.byte	$00,$12,$42,$04,$cf,$19,$32,$13
>86a0	05 0b 84 8b 47 5c fd 04			.byte	$05,$0b,$84,$8b,$47,$5c,$fd,$04
>86a8	32 35 00 12 4c 04 cf 08			.byte	$32,$35,$00,$12,$4c,$04,$cf,$08
>86b0	34 16 0b 10 bc 40 bf 40			.byte	$34,$16,$0b,$10,$bc,$40,$bf,$40
>86b8	be 84 49 70 00 12 56 04			.byte	$be,$84,$49,$70,$00,$12,$56,$04
>86c0	cf 0e 32 0f b9 84 49 40			.byte	$cf,$0e,$32,$0f,$b9,$84,$49,$40
>86c8	fd 06 36 38 37 35 00 0b			.byte	$fd,$06,$36,$38,$37,$35,$00,$0b
>86d0	60 04 cf 19 bb 84 8b 48			.byte	$60,$04,$cf,$19,$bb,$84,$8b,$48
>86d8	73 00 0f 6a 04 cf 0b 39			.byte	$73,$00,$0f,$6a,$04,$cf,$0b,$39
>86e0	16 19 b7 84 fe 04 4d 33			.byte	$16,$19,$b7,$84,$fe,$04,$4d,$33
>86e8	00 0f 74 04 cf 10 32 1a			.byte	$00,$0f,$74,$04,$cf,$10,$32,$1a
>86f0	03 b7 84 fe 04 52 34 00			.byte	$03,$b7,$84,$fe,$04,$52,$34,$00
>86f8	0e 7e 04 cf 0c 36 19 b7			.byte	$0e,$7e,$04,$cf,$0c,$36,$19,$b7
>8700	84 fe 04 58 34 00 0e 88			.byte	$84,$fe,$04,$58,$34,$00,$0e,$88
>8708	04 cf 0b 36 08 0e 19 bb			.byte	$04,$cf,$0b,$36,$08,$0e,$19,$bb
>8710	84 4b 45 00 0d 92 04 cf			.byte	$84,$4b,$45,$00,$0d,$92,$04,$cf
>8718	1a 38 03 09 bb 84 41 7d			.byte	$1a,$38,$03,$09,$bb,$84,$41,$7d
>8720	00 12 9c 04 cf 14 35 15			.byte	$00,$12,$9c,$04,$cf,$14,$35,$15
>8728	10 b8 42 be 84 fe 05 44			.byte	$10,$b8,$42,$be,$84,$fe,$05,$44
>8730	37 4f 00 11 a6 04 cf 15			.byte	$37,$4f,$00,$11,$a6,$04,$cf,$15
>8738	33 05 b9 84 8b 5c fd 05			.byte	$33,$05,$b9,$84,$8b,$5c,$fd,$05
>8740	33 37 35 00 12 b0 04 cf			.byte	$33,$37,$35,$00,$12,$b0,$04,$cf
>8748	0c 31 0f 05 84 43 64 fd			.byte	$0c,$31,$0f,$05,$84,$43,$64,$fd
>8750	06 35 36 32 35 00 13 ba			.byte	$06,$35,$36,$32,$35,$00,$13,$ba
>8758	04 cf 15 35 14 03 11 84			.byte	$04,$cf,$15,$35,$14,$03,$11,$84
>8760	47 5b fd 06 33 31 32 35			.byte	$47,$5b,$fd,$06,$33,$31,$32,$35
>8768	00 0e c4 04 cf 13 37 0a			.byte	$00,$0e,$c4,$04,$cf,$13,$37,$0a
>8770	08 06 bb 84 46 40 00 14			.byte	$08,$06,$bb,$84,$46,$40,$00,$14
>8778	ce 04 cf 05 37 15 1a b9			.byte	$ce,$04,$cf,$05,$37,$15,$1a,$b9
>8780	84 8b 41 44 fd 06 35 36			.byte	$84,$8b,$41,$44,$fd,$06,$35,$36
>8788	32 35 00 0a d8 04 cf 0e			.byte	$32,$35,$00,$0a,$d8,$04,$cf,$0e
>8790	bb 84 42 7c 00 11 e2 04			.byte	$bb,$84,$42,$7c,$00,$11,$e2,$04
>8798	cf 15 b8 40 be 84 fe 07			.byte	$cf,$15,$b8,$40,$be,$84,$fe,$07
>87a0	4b 32 54 42 41 00 11 ec			.byte	$4b,$32,$54,$42,$41,$00,$11,$ec
>87a8	04 cf 0c 31 0f 05 84 44			.byte	$04,$cf,$0c,$31,$0f,$05,$84,$44
>87b0	55 fd 05 31 32 35 00 10			.byte	$55,$fd,$05,$31,$32,$35,$00,$10
>87b8	f6 04 cf 12 30 14 84 49			.byte	$f6,$04,$cf,$12,$30,$14,$84,$49
>87c0	58 fd 05 36 32 35 00 11			.byte	$58,$fd,$05,$36,$32,$35,$00,$11
>87c8	00 05 cf 08 33 08 09 84			.byte	$00,$05,$cf,$08,$33,$08,$09,$84
>87d0	8b 43 43 fd 04 37 35 00			.byte	$8b,$43,$43,$fd,$04,$37,$35,$00
>87d8	0e 0a 05 cf 03 34 08 b7			.byte	$0e,$0a,$05,$cf,$03,$34,$08,$b7
>87e0	84 fe 04 51 31 00 12 14			.byte	$84,$fe,$04,$51,$31,$00,$12,$14
>87e8	05 cf 08 33 08 09 84 8b			.byte	$05,$cf,$08,$33,$08,$09,$84,$8b
>87f0	46 4f fd 05 33 37 35 00			.byte	$46,$4f,$fd,$05,$33,$37,$35,$00
>87f8	0d 1e 05 cf 1a 38 03 09			.byte	$0d,$1e,$05,$cf,$1a,$38,$03,$09
>8800	bb 84 4e 6a 00 10 28 05			.byte	$bb,$84,$4e,$6a,$00,$10,$28,$05
>8808	cf 0d 34 11 0d b7 84 fe			.byte	$cf,$0d,$34,$11,$0d,$b7,$84,$fe
>8810	05 42 39 44 00 10 32 05			.byte	$05,$42,$39,$44,$00,$10,$32,$05
>8818	cf 05 36 14 13 bc 40 be			.byte	$cf,$05,$36,$14,$13,$bc,$40,$be
>8820	84 8b 43 79 00 0d 3c 05			.byte	$84,$8b,$43,$79,$00,$0d,$3c,$05
>8828	cf 01 31 05 bb 84 8b 44			.byte	$cf,$01,$31,$05,$bb,$84,$8b,$44
>8830	7d 00 10 46 05 cf 08 38			.byte	$7d,$00,$10,$46,$05,$cf,$08,$38
>8838	13 0c b9 84 42 49 fd 03			.byte	$13,$0c,$b9,$84,$42,$49,$fd,$03
>8840	30 00 0d 50 05 cf 19 30			.byte	$30,$00,$0d,$50,$05,$cf,$19,$30
>8848	03 14 bb 84 43 60 00 0e			.byte	$03,$14,$bb,$84,$43,$60,$00,$0e
>8850	5a 05 cf 0a 35 11 19 b7			.byte	$5a,$05,$cf,$0a,$35,$11,$19,$b7
>8858	84 fe 03 41 00 14 64 05			.byte	$84,$fe,$03,$41,$00,$14,$64,$05
>8860	cf 05 31 11 17 09 b9 84			.byte	$cf,$05,$31,$11,$17,$09,$b9,$84
>8868	8b 43 54 fd 05 33 37 35			.byte	$8b,$43,$54,$fd,$05,$33,$37,$35
>8870	00 0f 6e 05 cf 18 30 01			.byte	$00,$0f,$6e,$05,$cf,$18,$30,$01
>8878	11 0b b7 84 fe 03 56 00			.byte	$11,$0b,$b7,$84,$fe,$03,$56,$00
>8880	0f 78 05 cf 01 35 0e b8			.byte	$0f,$78,$05,$cf,$01,$35,$0e,$b8
>8888	42 be 84 fe 03 47 00 11			.byte	$42,$be,$84,$fe,$03,$47,$00,$11
>8890	82 05 cf 0a 38 07 b7 84			.byte	$82,$05,$cf,$0a,$38,$07,$b7,$84
>8898	fe 07 4e 33 57 5a 45 00			.byte	$fe,$07,$4e,$33,$57,$5a,$45,$00
>88a0	12 8c 05 cf 04 37 13 0b			.byte	$12,$8c,$05,$cf,$04,$37,$13,$0b
>88a8	b8 41 be 84 fe 05 59 32			.byte	$b8,$41,$be,$84,$fe,$05,$59,$32
>88b0	4b 00 13 96 05 cf 07 32			.byte	$4b,$00,$13,$96,$05,$cf,$07,$32
>88b8	08 04 19 84 8b 45 7a fd			.byte	$08,$04,$19,$84,$8b,$45,$7a,$fd
>88c0	05 33 37 35 00 11 a0 05			.byte	$05,$33,$37,$35,$00,$11,$a0,$05
>88c8	cf 02 39 05 18 0d b7 84			.byte	$cf,$02,$39,$05,$18,$0d,$b7,$84
>88d0	fe 05 4c 34 48 00 0f aa			.byte	$fe,$05,$4c,$34,$48,$00,$0f,$aa
>88d8	05 cf 13 35 14 1a 0d bb			.byte	$05,$cf,$13,$35,$14,$1a,$0d,$bb
>88e0	84 8b 4c 6d 00 0d b4 05			.byte	$84,$8b,$4c,$6d,$00,$0d,$b4,$05
>88e8	cf 01 31 05 bb 84 8b 4a			.byte	$cf,$01,$31,$05,$bb,$84,$8b,$4a
>88f0	4c 00 14 be 05 cf 06 35			.byte	$4c,$00,$14,$be,$05,$cf,$06,$35
>88f8	06 0f 18 84 8b 47 55 fd			.byte	$06,$0f,$18,$84,$8b,$47,$55,$fd
>8900	06 31 38 37 35 00 13 c8			.byte	$06,$31,$38,$37,$35,$00,$13,$c8
>8908	05 cf 13 34 02 ba 40 be			.byte	$05,$cf,$13,$34,$02,$ba,$40,$be
>8910	84 48 fd 06 33 31 32 35			.byte	$84,$48,$fd,$06,$33,$31,$32,$35
>8918	00 12 d2 05 cf 09 34 13			.byte	$00,$12,$d2,$05,$cf,$09,$34,$13
>8920	84 8b 42 50 fd 06 39 33			.byte	$84,$8b,$42,$50,$fd,$06,$39,$33
>8928	37 35 00 11 dc 05 cf 0b			.byte	$37,$35,$00,$11,$dc,$05,$cf,$0b
>8930	39 16 19 b7 84 fe 06 4b			.byte	$39,$16,$19,$b7,$84,$fe,$06,$4b
>8938	37 56 46 00 13 e6 05 cf			.byte	$37,$56,$46,$00,$13,$e6,$05,$cf
>8940	15 33 05 b9 84 8b 41 70			.byte	$15,$33,$05,$b9,$84,$8b,$41,$70
>8948	fd 06 35 36 32 35 00 0b			.byte	$fd,$06,$35,$36,$32,$35,$00,$0b
>8950	f0 05 cf 19 bb 84 8b 49			.byte	$f0,$05,$cf,$19,$bb,$84,$8b,$49
>8958	40 00 10 fa 05 cf 13 31			.byte	$40,$00,$10,$fa,$05,$cf,$13,$31
>8960	0c 04 b7 84 fe 05 45 31			.byte	$0c,$04,$b7,$84,$fe,$05,$45,$31
>8968	57 00 0d 04 06 cf 1a b7			.byte	$57,$00,$0d,$04,$06,$cf,$1a,$b7
>8970	84 fe 05 4d 35 52 00 11			.byte	$84,$fe,$05,$4d,$35,$52,$00,$11
>8978	0e 06 cf 18 32 06 0e 02			.byte	$0e,$06,$cf,$18,$32,$06,$0e,$02
>8980	84 8b 46 6c fd 03 30 00			.byte	$84,$8b,$46,$6c,$fd,$03,$30,$00
>8988	0e 18 06 cf 05 33 16 04			.byte	$0e,$18,$06,$cf,$05,$33,$16,$04
>8990	0b bb 84 4a 4a 00 0f 22			.byte	$0b,$bb,$84,$4a,$4a,$00,$0f,$22
>8998	06 cf 18 b9 84 8b 41 69			.byte	$06,$cf,$18,$b9,$84,$8b,$41,$69
>89a0	fd 04 37 35 00 10 2c 06			.byte	$fd,$04,$37,$35,$00,$10,$2c,$06
>89a8	cf 05 36 14 13 bc 41 be			.byte	$cf,$05,$36,$14,$13,$bc,$41,$be
>89b0	84 8b 48 58 00 13 36 06			.byte	$84,$8b,$48,$58,$00,$13,$36,$06
>89b8	cf 11 34 0d 03 b9 84 8b			.byte	$cf,$11,$34,$0d,$03,$b9,$84,$8b
>89c0	43 47 fd 05 33 37 35 00			.byte	$43,$47,$fd,$05,$33,$37,$35,$00
>89c8	14 40 06 cf 04 34 1a 12			.byte	$14,$40,$06,$cf,$04,$34,$1a,$12
>89d0	0a b9 84 43 71 fd 06 38			.byte	$0a,$b9,$84,$43,$71,$fd,$06,$38
>89d8	31 32 35 00 12 4a 06 cf			.byte	$31,$32,$35,$00,$12,$4a,$06,$cf
>89e0	02 39 04 0a 07 b9 84 41			.byte	$02,$39,$04,$0a,$07,$b9,$84,$41
>89e8	7b fd 04 32 35 00 0c 54			.byte	$7b,$fd,$04,$32,$35,$00,$0c,$54
>89f0	06 cf 0a 30 03 bb 84 8b			.byte	$06,$cf,$0a,$30,$03,$bb,$84,$8b
>89f8	5a 00 0f 5e 06 cf 06 39			.byte	$5a,$00,$0f,$5e,$06,$cf,$06,$39
>8a00	13 84 8b 5d fd 04 32 35			.byte	$13,$84,$8b,$5d,$fd,$04,$32,$35
>8a08	00 0d 68 06 cf 14 30 19			.byte	$00,$0d,$68,$06,$cf,$14,$30,$19
>8a10	bb 84 8b 4a 6d 00 0e 72			.byte	$bb,$84,$8b,$4a,$6d,$00,$0e,$72
>8a18	06 cf 16 35 0a 0d 0e bb			.byte	$06,$cf,$16,$35,$0a,$0d,$0e,$bb
>8a20	84 42 44 00 10 7c 06 cf			.byte	$84,$42,$44,$00,$10,$7c,$06,$cf
>8a28	14 b9 84 44 55 fd 06 33			.byte	$14,$b9,$84,$44,$55,$fd,$06,$33
>8a30	31 32 35 00 0e 86 06 cf			.byte	$31,$32,$35,$00,$0e,$86,$06,$cf
>8a38	11 37 08 07 01 bb 84 48			.byte	$11,$37,$08,$07,$01,$bb,$84,$48
>8a40	4f 00 0f 90 06 cf 15 b8			.byte	$4f,$00,$0f,$90,$06,$cf,$15,$b8
>8a48	41 be 84 fe 05 4d 31 4a			.byte	$41,$be,$84,$fe,$05,$4d,$31,$4a
>8a50	00 10 9a 06 cf 0b 39 16			.byte	$00,$10,$9a,$06,$cf,$0b,$39,$16
>8a58	19 b7 84 fe 05 56 36 50			.byte	$19,$b7,$84,$fe,$05,$56,$36,$50
>8a60	00 11 a4 06 cf 15 30 01			.byte	$00,$11,$a4,$06,$cf,$15,$30,$01
>8a68	84 48 78 fd 06 35 36 32			.byte	$84,$48,$78,$fd,$06,$35,$36,$32
>8a70	35 00 13 ae 06 cf 11 34			.byte	$35,$00,$13,$ae,$06,$cf,$11,$34
>8a78	0d 03 b9 84 43 64 fd 06			.byte	$0d,$03,$b9,$84,$43,$64,$fd,$06
>8a80	39 33 37 35 00 0d b8 06			.byte	$39,$33,$37,$35,$00,$0d,$b8,$06
>8a88	cf 17 31 03 bb 84 8b 49			.byte	$cf,$17,$31,$03,$bb,$84,$8b,$49
>8a90	78 00 13 c2 06 cf 08 34			.byte	$78,$00,$13,$c2,$06,$cf,$08,$34
>8a98	16 0b 10 bc 40 bf 41 be			.byte	$16,$0b,$10,$bc,$40,$bf,$41,$be
>8aa0	84 8b 45 67 00 11 cc 06			.byte	$84,$8b,$45,$67,$00,$11,$cc,$06
>8aa8	cf 08 38 13 0c b9 84 8b			.byte	$cf,$08,$38,$13,$0c,$b9,$84,$8b
>8ab0	41 5b fd 03 35 00 0b d6			.byte	$41,$5b,$fd,$03,$35,$00,$0b,$d6
>8ab8	06 cf 17 b7 84 fe 03 41			.byte	$06,$cf,$17,$b7,$84,$fe,$03,$41
>8ac0	00 0f e0 06 cf 08 33 08			.byte	$00,$0f,$e0,$06,$cf,$08,$33,$08
>8ac8	09 84 4d fd 04 37 35 00			.byte	$09,$84,$4d,$fd,$04,$37,$35,$00
>8ad0	12 ea 06 cf 0a 35 11 19			.byte	$12,$ea,$06,$cf,$0a,$35,$11,$19
>8ad8	b7 84 fe 07 42 32 44 4e			.byte	$b7,$84,$fe,$07,$42,$32,$44,$4e
>8ae0	50 00 12 f4 06 cf 15 35			.byte	$50,$00,$12,$f4,$06,$cf,$15,$35
>8ae8	14 03 11 84 41 78 fd 05			.byte	$14,$03,$11,$84,$41,$78,$fd,$05
>8af0	31 32 35 00 11 fe 06 cf			.byte	$31,$32,$35,$00,$11,$fe,$06,$cf
>8af8	06 34 08 03 05 bc 41 be			.byte	$06,$34,$08,$03,$05,$bc,$41,$be
>8b00	84 8b 46 6b 00 13 08 07			.byte	$84,$8b,$46,$6b,$00,$13,$08,$07
>8b08	cf 08 34 16 0b 10 bc 40			.byte	$cf,$08,$34,$16,$0b,$10,$bc,$40
>8b10	bf 40 be 84 8b 45 49 00			.byte	$bf,$40,$be,$84,$8b,$45,$49,$00
>8b18	12 12 07 cf 05 37 15 1a			.byte	$12,$12,$07,$cf,$05,$37,$15,$1a
>8b20	b9 84 77 fd 06 30 36 32			.byte	$b9,$84,$77,$fd,$06,$30,$36,$32
>8b28	35 00 11 1c 07 cf 04 37			.byte	$35,$00,$11,$1c,$07,$cf,$04,$37
>8b30	13 0b b8 40 be 84 fe 04			.byte	$13,$0b,$b8,$40,$be,$84,$fe,$04
>8b38	4a 32 00 12 26 07 cf 07			.byte	$4a,$32,$00,$12,$26,$07,$cf,$07
>8b40	32 08 04 19 84 47 6a fd			.byte	$32,$08,$04,$19,$84,$47,$6a,$fd
>8b48	05 33 37 35 00 0f 30 07			.byte	$05,$33,$37,$35,$00,$0f,$30,$07
>8b50	cf 05 36 14 13 bc 41 be			.byte	$cf,$05,$36,$14,$13,$bc,$41,$be
>8b58	84 4a 7f 00 13 3a 07 cf			.byte	$84,$4a,$7f,$00,$13,$3a,$07,$cf
>8b60	14 35 15 10 b8 42 be 84			.byte	$14,$35,$15,$10,$b8,$42,$be,$84
>8b68	fe 06 44 37 4c 46 00 0a			.byte	$fe,$06,$44,$37,$4c,$46,$00,$0a
>8b70	44 07 cf 09 b7 84 fe 02			.byte	$44,$07,$cf,$09,$b7,$84,$fe,$02
>8b78	00 0b 4e 07 cf 19 bb 84			.byte	$00,$0b,$4e,$07,$cf,$19,$bb,$84
>8b80	8b 4a 48 00 10 58 07 cf			.byte	$8b,$4a,$48,$00,$10,$58,$07,$cf
>8b88	06 34 08 03 05 bc 40 be			.byte	$06,$34,$08,$03,$05,$bc,$40,$be
>8b90	84 4b 74 00 15 62 07 cf			.byte	$84,$4b,$74,$00,$15,$62,$07,$cf
>8b98	05 32 0f 0a 10 b9 84 8b			.byte	$05,$32,$0f,$0a,$10,$b9,$84,$8b
>8ba0	46 61 fd 06 30 36 32 35			.byte	$46,$61,$fd,$06,$30,$36,$32,$35
>8ba8	00 0b 6c 07 cf 0e bb 84			.byte	$00,$0b,$6c,$07,$cf,$0e,$bb,$84
>8bb0	8b 49 40 00 11 76 07 cf			.byte	$8b,$49,$40,$00,$11,$76,$07,$cf
>8bb8	17 39 15 02 11 b7 84 fe			.byte	$17,$39,$15,$02,$11,$b7,$84,$fe
>8bc0	05 4a 30 43 00 10 80 07			.byte	$05,$4a,$30,$43,$00,$10,$80,$07
>8bc8	cf 05 38 10 b9 84 47 77			.byte	$cf,$05,$38,$10,$b9,$84,$47,$77
>8bd0	fd 04 37 35 00 13 8a 07			.byte	$fd,$04,$37,$35,$00,$13,$8a,$07
>8bd8	cf 15 33 05 b9 84 8b 43			.byte	$cf,$15,$33,$05,$b9,$84,$8b,$43
>8be0	44 fd 06 39 33 37 35 00			.byte	$44,$fd,$06,$39,$33,$37,$35,$00
>8be8	0e 94 07 cf 14 37 13 07			.byte	$0e,$94,$07,$cf,$14,$37,$13,$07
>8bf0	bb 84 8b 44 78 00 0d 9e			.byte	$bb,$84,$8b,$44,$78,$00,$0d,$9e
>8bf8	07 cf 04 39 19 bb 84 8b			.byte	$07,$cf,$04,$39,$19,$bb,$84,$8b
>8c00	42 71 00 0e a8 07 cf 0b			.byte	$42,$71,$00,$0e,$a8,$07,$cf,$0b
>8c08	36 08 0e 19 bb 84 42 5e			.byte	$36,$08,$0e,$19,$bb,$84,$42,$5e
>8c10	00 12 b2 07 cf 14 37 10			.byte	$00,$12,$b2,$07,$cf,$14,$37,$10
>8c18	84 8b 42 72 fd 06 38 31			.byte	$84,$8b,$42,$72,$fd,$06,$38,$31
>8c20	32 35 00 12 bc 07 cf 01			.byte	$32,$35,$00,$12,$bc,$07,$cf,$01
>8c28	35 0e b8 42 be 84 fe 06			.byte	$35,$0e,$b8,$42,$be,$84,$fe,$06
>8c30	56 38 4a 54 00 13 c6 07			.byte	$56,$38,$4a,$54,$00,$13,$c6,$07
>8c38	cf 03 32 08 07 84 8b 45			.byte	$cf,$03,$32,$08,$07,$84,$8b,$45
>8c40	41 fd 06 36 38 37 35 00			.byte	$41,$fd,$06,$36,$38,$37,$35,$00
>8c48	10 d0 07 cf 11 84 8b 43			.byte	$10,$d0,$07,$cf,$11,$84,$8b,$43
>8c50	5e fd 06 33 31 32 35 00			.byte	$5e,$fd,$06,$33,$31,$32,$35,$00
>8c58	12 da 07 cf 1a 31 18 03			.byte	$12,$da,$07,$cf,$1a,$31,$18,$03
>8c60	16 b9 84 8b 45 52 fd 03			.byte	$16,$b9,$84,$8b,$45,$52,$fd,$03
>8c68	35 00 0e e4 07 cf 18 b9			.byte	$35,$00,$0e,$e4,$07,$cf,$18,$b9
>8c70	84 8b 48 49 fd 03 30 00			.byte	$84,$8b,$48,$49,$fd,$03,$30,$00
>8c78	10 ee 07 cf 04 37 10 84			.byte	$10,$ee,$07,$cf,$04,$37,$10,$84
>8c80	41 6e fd 05 31 32 35 00			.byte	$41,$6e,$fd,$05,$31,$32,$35,$00
>8c88	13 f8 07 cf 05 31 11 17			.byte	$13,$f8,$07,$cf,$05,$31,$11,$17
>8c90	09 b9 84 41 43 fd 05 31			.byte	$09,$b9,$84,$41,$43,$fd,$05,$31
>8c98	32 35 00 11 02 08 cf 15			.byte	$32,$35,$00,$11,$02,$08,$cf,$15
>8ca0	33 05 b9 84 8b 79 fd 05			.byte	$33,$05,$b9,$84,$8b,$79,$fd,$05
>8ca8	36 32 35 00 0f 0c 08 cf			.byte	$36,$32,$35,$00,$0f,$0c,$08,$cf
>8cb0	02 39 05 18 0d b7 84 fe			.byte	$02,$39,$05,$18,$0d,$b7,$84,$fe
>8cb8	03 57 00 12 16 08 cf 05			.byte	$03,$57,$00,$12,$16,$08,$cf,$05
>8cc0	38 03 04 17 b7 84 fe 06			.byte	$38,$03,$04,$17,$b7,$84,$fe,$06
>8cc8	4a 39 59 58 00 12 20 08			.byte	$4a,$39,$59,$58,$00,$12,$20,$08
>8cd0	cf 18 35 03 01 84 48 51			.byte	$cf,$18,$35,$03,$01,$84,$48,$51
>8cd8	fd 06 31 38 37 35 00 13			.byte	$fd,$06,$31,$38,$37,$35,$00,$13
>8ce0	2a 08 cf 15 35 14 03 11			.byte	$2a,$08,$cf,$15,$35,$14,$03,$11
>8ce8	84 42 64 fd 06 31 38 37			.byte	$84,$42,$64,$fd,$06,$31,$38,$37
>8cf0	35 00 0f 34 08 cf 11 84			.byte	$35,$00,$0f,$34,$08,$cf,$11,$84
>8cf8	48 60 fd 06 31 38 37 35			.byte	$48,$60,$fd,$06,$31,$38,$37,$35
>8d00	00 11 3e 08 cf 12 30 14			.byte	$00,$11,$3e,$08,$cf,$12,$30,$14
>8d08	84 48 51 fd 06 30 36 32			.byte	$84,$48,$51,$fd,$06,$30,$36,$32
>8d10	35 00 10 48 08 cf 03 34			.byte	$35,$00,$10,$48,$08,$cf,$03,$34
>8d18	08 b7 84 fe 06 54 35 59			.byte	$08,$b7,$84,$fe,$06,$54,$35,$59
>8d20	47 00 0c 52 08 dc 0c 35			.byte	$47,$00,$0c,$52,$08,$dc,$0c,$35
>8d28	09 12 b9 84 40 00 13 5c			.byte	$09,$12,$b9,$84,$40,$00,$13,$5c
>8d30	08 dc 03 32 08 07 84 8b			.byte	$08,$dc,$03,$32,$08,$07,$84,$8b
>8d38	45 41 fd 06 36 38 37 35			.byte	$45,$41,$fd,$06,$36,$38,$37,$35
>8d40	00 11 66 08 dc 15 30 01			.byte	$00,$11,$66,$08,$dc,$15,$30,$01
>8d48	84 48 78 fd 06 35 36 32			.byte	$84,$48,$78,$fd,$06,$35,$36,$32
>8d50	35 00 11 70 08 dc 0c 31			.byte	$35,$00,$11,$70,$08,$dc,$0c,$31
>8d58	0f 05 84 44 55 fd 05 31			.byte	$0f,$05,$84,$44,$55,$fd,$05,$31
>8d60	32 35 00 12 7a 08 dc 0e			.byte	$32,$35,$00,$12,$7a,$08,$dc,$0e
>8d68	32 0f b9 84 49 40 fd 06			.byte	$32,$0f,$b9,$84,$49,$40,$fd,$06
>8d70	36 38 37 35 00 0a 84 08			.byte	$36,$38,$37,$35,$00,$0a,$84,$08
>8d78	dc 03 bb 84 49 46 00 09			.byte	$dc,$03,$bb,$84,$49,$46,$00,$09
>8d80	8e 08 dc 02 b9 84 40 00			.byte	$8e,$08,$dc,$02,$b9,$84,$40,$00
>8d88	10 98 08 dc 13 31 0c 04			.byte	$10,$98,$08,$dc,$13,$31,$0c,$04
>8d90	b7 84 fe 05 45 31 57 00			.byte	$b7,$84,$fe,$05,$45,$31,$57,$00
>8d98	0c a2 08 dc 10 36 03 17			.byte	$0c,$a2,$08,$dc,$10,$36,$03,$17
>8da0	bb 84 40 00 12 ac 08 dc			.byte	$bb,$84,$40,$00,$12,$ac,$08,$dc
>8da8	04 36 13 0d b9 84 8b 43			.byte	$04,$36,$13,$0d,$b9,$84,$8b,$43
>8db0	5a fd 04 32 35 00 10 b6			.byte	$5a,$fd,$04,$32,$35,$00,$10,$b6
>8db8	08 dc 12 84 8b 48 5e fd			.byte	$08,$dc,$12,$84,$8b,$48,$5e,$fd
>8dc0	06 36 38 37 35 00 09 c0			.byte	$06,$36,$38,$37,$35,$00,$09,$c0
>8dc8	08 dc 0d bb 84 40 00 0b			.byte	$08,$dc,$0d,$bb,$84,$40,$00,$0b
>8dd0	ca 08 dc 0e bb 84 8b 49			.byte	$ca,$08,$dc,$0e,$bb,$84,$8b,$49
>8dd8	40 00 0f d4 08 dc 18 30			.byte	$40,$00,$0f,$d4,$08,$dc,$18,$30
>8de0	01 11 0b b7 84 fe 03 56			.byte	$01,$11,$0b,$b7,$84,$fe,$03,$56
>8de8	00 0d de 08 dc 01 31 05			.byte	$00,$0d,$de,$08,$dc,$01,$31,$05
>8df0	bb 84 8b 4a 4c 00 10 e8			.byte	$bb,$84,$8b,$4a,$4c,$00,$10,$e8
>8df8	08 dc 14 b9 84 44 55 fd			.byte	$08,$dc,$14,$b9,$84,$44,$55,$fd
>8e00	06 33 31 32 35 00 0c f2			.byte	$06,$33,$31,$32,$35,$00,$0c,$f2
>8e08	08 dc 05 30 0a 0a bb 84			.byte	$08,$dc,$05,$30,$0a,$0a,$bb,$84
>8e10	40 00 11 fc 08 dc 05 36			.byte	$40,$00,$11,$fc,$08,$dc,$05,$36
>8e18	01 06 0b 84 8b 46 7e fd			.byte	$01,$06,$0b,$84,$8b,$46,$7e,$fd
>8e20	03 35 00 12 06 09 dc 05			.byte	$03,$35,$00,$12,$06,$09,$dc,$05
>8e28	37 15 1a b9 84 77 fd 06			.byte	$37,$15,$1a,$b9,$84,$77,$fd,$06
>8e30	30 36 32 35 00 0a 10 09			.byte	$30,$36,$32,$35,$00,$0a,$10,$09
>8e38	dc 0c b7 84 fe 02 00 0e			.byte	$dc,$0c,$b7,$84,$fe,$02,$00,$0e
>8e40	1a 09 dc 14 37 13 07 bb			.byte	$1a,$09,$dc,$14,$37,$13,$07,$bb
>8e48	84 8b 44 78 00 0d 24 09			.byte	$84,$8b,$44,$78,$00,$0d,$24,$09
>8e50	dc 04 39 19 bb 84 8b 42			.byte	$dc,$04,$39,$19,$bb,$84,$8b,$42
>8e58	71 00 0e 2e 09 dc 05 33			.byte	$71,$00,$0e,$2e,$09,$dc,$05,$33
>8e60	16 04 0b bb 84 4a 4a 00			.byte	$16,$04,$0b,$bb,$84,$4a,$4a,$00
>8e68	11 38 09 dc 0e 39 09 b7			.byte	$11,$38,$09,$dc,$0e,$39,$09,$b7
>8e70	84 fe 07 4d 30 59 53 5a			.byte	$84,$fe,$07,$4d,$30,$59,$53,$5a
>8e78	00 11 42 09 dc 0a 38 07			.byte	$00,$11,$42,$09,$dc,$0a,$38,$07
>8e80	b7 84 fe 07 4e 33 57 5a			.byte	$b7,$84,$fe,$07,$4e,$33,$57,$5a
>8e88	45 00 11 4c 09 dc 0a 39			.byte	$45,$00,$11,$4c,$09,$dc,$0a,$39
>8e90	01 18 0d b7 84 fe 05 50			.byte	$01,$18,$0d,$b7,$84,$fe,$05,$50
>8e98	37 51 00 0e 56 09 dc 0c			.byte	$37,$51,$00,$0e,$56,$09,$dc,$0c
>8ea0	36 19 b7 84 fe 04 58 34			.byte	$36,$19,$b7,$84,$fe,$04,$58,$34
>8ea8	00 15 60 09 dc 05 32 0f			.byte	$00,$15,$60,$09,$dc,$05,$32,$0f
>8eb0	0a 10 b9 84 8b 46 61 fd			.byte	$0a,$10,$b9,$84,$8b,$46,$61,$fd
>8eb8	06 30 36 32 35 00 0f 6a			.byte	$06,$30,$36,$32,$35,$00,$0f,$6a
>8ec0	09 dc 02 39 05 18 0d b7			.byte	$09,$dc,$02,$39,$05,$18,$0d,$b7
>8ec8	84 fe 03 57 00 0a 74 09			.byte	$84,$fe,$03,$57,$00,$0a,$74,$09
>8ed0	dc 09 b7 84 fe 02 00 12			.byte	$dc,$09,$b7,$84,$fe,$02,$00,$12
>8ed8	7e 09 dc 09 34 13 84 8b			.byte	$7e,$09,$dc,$09,$34,$13,$84,$8b
>8ee0	42 50 fd 06 39 33 37 35			.byte	$42,$50,$fd,$06,$39,$33,$37,$35
>8ee8	00 0e 88 09 dc 04 38 10			.byte	$00,$0e,$88,$09,$dc,$04,$38,$10
>8ef0	15 1a bb 84 4e 69 00 13			.byte	$15,$1a,$bb,$84,$4e,$69,$00,$13
>8ef8	92 09 dc 05 31 19 19 84			.byte	$92,$09,$dc,$05,$31,$19,$19,$84
>8f00	8b 44 7c fd 06 33 31 32			.byte	$8b,$44,$7c,$fd,$06,$33,$31,$32
>8f08	35 00 0b 9c 09 dc 03 31			.byte	$35,$00,$0b,$9c,$09,$dc,$03,$31
>8f10	0c bb 84 40 00 0e a6 09			.byte	$0c,$bb,$84,$40,$00,$0e,$a6,$09
>8f18	dc 03 37 17 19 b7 84 fe			.byte	$dc,$03,$37,$17,$19,$b7,$84,$fe
>8f20	03 49 00 0c b0 09 dc 0f			.byte	$03,$49,$00,$0c,$b0,$09,$dc,$0f
>8f28	31 0f 02 bb 84 6b 00 08			.byte	$31,$0f,$02,$bb,$84,$6b,$00,$08
>8f30	ba 09 dc 0b 84 40 00 0e			.byte	$ba,$09,$dc,$0b,$84,$40,$00,$0e
>8f38	c4 09 dc 13 37 0a 08 06			.byte	$c4,$09,$dc,$13,$37,$0a,$08,$06
>8f40	bb 84 46 40 00 0e ce 09			.byte	$bb,$84,$46,$40,$00,$0e,$ce,$09
>8f48	dc 18 b9 84 8b 48 49 fd			.byte	$dc,$18,$b9,$84,$8b,$48,$49,$fd
>8f50	03 30 00 14 d8 09 dc 06			.byte	$03,$30,$00,$14,$d8,$09,$dc,$06
>8f58	35 06 0f 18 84 8b 47 55			.byte	$35,$06,$0f,$18,$84,$8b,$47,$55
>8f60	fd 06 31 38 37 35 00 12			.byte	$fd,$06,$31,$38,$37,$35,$00,$12
>8f68	e2 09 dc 14 37 10 84 8b			.byte	$e2,$09,$dc,$14,$37,$10,$84,$8b
>8f70	42 72 fd 06 38 31 32 35			.byte	$42,$72,$fd,$06,$38,$31,$32,$35
>8f78	00 11 ec 09 dc 17 39 15			.byte	$00,$11,$ec,$09,$dc,$17,$39,$15
>8f80	02 11 b7 84 fe 05 4a 30			.byte	$02,$11,$b7,$84,$fe,$05,$4a,$30
>8f88	43 00 0f f6 09 dc 08 33			.byte	$43,$00,$0f,$f6,$09,$dc,$08,$33
>8f90	08 09 84 4d fd 04 37 35			.byte	$08,$09,$84,$4d,$fd,$04,$37,$35
>8f98	00 12 00 0a dc 1a 31 18			.byte	$00,$12,$00,$0a,$dc,$1a,$31,$18
>8fa0	03 16 b9 84 8b 45 52 fd			.byte	$03,$16,$b9,$84,$8b,$45,$52,$fd
>8fa8	03 35 00 11 0a 0a dc 01			.byte	$03,$35,$00,$11,$0a,$0a,$dc,$01
>8fb0	36 09 06 84 44 5b fd 05			.byte	$36,$09,$06,$84,$44,$5b,$fd,$05
>8fb8	31 32 35 00 0d 14 0a dc			.byte	$31,$32,$35,$00,$0d,$14,$0a,$dc
>8fc0	1a b7 84 fe 05 4d 35 52			.byte	$1a,$b7,$84,$fe,$05,$4d,$35,$52
>8fc8	00 12 1e 0a dc 0a 35 11			.byte	$00,$12,$1e,$0a,$dc,$0a,$35,$11
>8fd0	19 b7 84 fe 07 42 32 44			.byte	$19,$b7,$84,$fe,$07,$42,$32,$44
>8fd8	4e 50 00 0f 28 0a dc 13			.byte	$4e,$50,$00,$0f,$28,$0a,$dc,$13
>8fe0	35 14 1a 0d bb 84 8b 4c			.byte	$35,$14,$1a,$0d,$bb,$84,$8b,$4c
>8fe8	6d 00 10 32 0a dc 04 37			.byte	$6d,$00,$10,$32,$0a,$dc,$04,$37
>8ff0	10 84 41 6e fd 05 31 32			.byte	$10,$84,$41,$6e,$fd,$05,$31,$32
>8ff8	35 00 12 3c 0a dc 05 38			.byte	$35,$00,$12,$3c,$0a,$dc,$05,$38
>9000	03 04 17 b7 84 fe 06 4a			.byte	$03,$04,$17,$b7,$84,$fe,$06,$4a
>9008	39 59 58 00 14 46 0a dc			.byte	$39,$59,$58,$00,$14,$46,$0a,$dc
>9010	0e 30 0b 0e 01 84 8b 42			.byte	$0e,$30,$0b,$0e,$01,$84,$8b,$42
>9018	6f fd 06 33 31 32 35 00			.byte	$6f,$fd,$06,$33,$31,$32,$35,$00
>9020	12 50 0a dc 07 32 08 04			.byte	$12,$50,$0a,$dc,$07,$32,$08,$04
>9028	19 84 47 6a fd 05 33 37			.byte	$19,$84,$47,$6a,$fd,$05,$33,$37
>9030	35 00 0b 5a 0a dc 12 32			.byte	$35,$00,$0b,$5a,$0a,$dc,$12,$32
>9038	19 bb 84 40 00 10 64 0a			.byte	$19,$bb,$84,$40,$00,$10,$64,$0a
>9040	dc 03 34 08 b7 84 fe 06			.byte	$dc,$03,$34,$08,$b7,$84,$fe,$06
>9048	54 35 59 47 00 0e 6e 0a			.byte	$54,$35,$59,$47,$00,$0e,$6e,$0a
>9050	dc 07 b7 84 fe 06 59 31			.byte	$dc,$07,$b7,$84,$fe,$06,$59,$31
>9058	49 49 00 0c 78 0a dc 19			.byte	$49,$49,$00,$0c,$78,$0a,$dc,$19
>9060	33 09 b7 84 fe 02 00 11			.byte	$33,$09,$b7,$84,$fe,$02,$00,$11
>9068	82 0a dc 18 32 06 0e 02			.byte	$82,$0a,$dc,$18,$32,$06,$0e,$02
>9070	84 8b 46 6c fd 03 30 00			.byte	$84,$8b,$46,$6c,$fd,$03,$30,$00
>9078	13 8c 0a dc 15 35 14 03			.byte	$13,$8c,$0a,$dc,$15,$35,$14,$03
>9080	11 84 42 64 fd 06 31 38			.byte	$11,$84,$42,$64,$fd,$06,$31,$38
>9088	37 35 00 0f 96 0a dc 11			.byte	$37,$35,$00,$0f,$96,$0a,$dc,$11
>9090	84 48 60 fd 06 31 38 37			.byte	$84,$48,$60,$fd,$06,$31,$38,$37
>9098	35 00 09 a0 0a dc 10 b9			.byte	$35,$00,$09,$a0,$0a,$dc,$10,$b9
>90a0	84 40 00 12 aa 0a dc 06			.byte	$84,$40,$00,$12,$aa,$0a,$dc,$06
>90a8	33 01 12 0c b9 84 4d fd			.byte	$33,$01,$12,$0c,$b9,$84,$4d,$fd
>90b0	05 33 37 35 00 10 b4 0a			.byte	$05,$33,$37,$35,$00,$10,$b4,$0a
>90b8	dc 05 38 10 b9 84 47 77			.byte	$dc,$05,$38,$10,$b9,$84,$47,$77
>90c0	fd 04 37 35 00 0a be 0a			.byte	$fd,$04,$37,$35,$00,$0a,$be,$0a
>90c8	dc 0f b7 84 fe 02 00 0d			.byte	$dc,$0f,$b7,$84,$fe,$02,$00,$0d
>90d0	c8 0a dc 08 34 0c 17 11			.byte	$c8,$0a,$dc,$08,$34,$0c,$17,$11
>90d8	bb 84 40 00 0f d2 0a dc			.byte	$bb,$84,$40,$00,$0f,$d2,$0a,$dc
>90e0	06 39 13 84 8b 5d fd 04			.byte	$06,$39,$13,$84,$8b,$5d,$fd,$04
>90e8	32 35 00 0e dc 0a dc 0d			.byte	$32,$35,$00,$0e,$dc,$0a,$dc,$0d
>90f0	31 14 13 bb 84 8b 49 5e			.byte	$31,$14,$13,$bb,$84,$8b,$49,$5e
>90f8	00 0d e6 0a dc 19 30 03			.byte	$00,$0d,$e6,$0a,$dc,$19,$30,$03
>9100	14 bb 84 43 60 00 12 f0			.byte	$14,$bb,$84,$43,$60,$00,$12,$f0
>9108	0a dc 02 39 04 0a 07 b9			.byte	$0a,$dc,$02,$39,$04,$0a,$07,$b9
>9110	84 41 7b fd 04 32 35 00			.byte	$84,$41,$7b,$fd,$04,$32,$35,$00
>9118	11 fa 0a dc 12 30 14 84			.byte	$11,$fa,$0a,$dc,$12,$30,$14,$84
>9120	48 51 fd 06 30 36 32 35			.byte	$48,$51,$fd,$06,$30,$36,$32,$35
>9128	00 0d 04 0b dc 14 30 19			.byte	$00,$0d,$04,$0b,$dc,$14,$30,$19
>9130	bb 84 8b 4a 6d 00 0e 0e			.byte	$bb,$84,$8b,$4a,$6d,$00,$0e,$0e
>9138	0b dc 16 35 0a 0d 0e bb			.byte	$0b,$dc,$16,$35,$0a,$0d,$0e,$bb
>9140	84 42 44 00 13 18 0b dc			.byte	$84,$42,$44,$00,$13,$18,$0b,$dc
>9148	0e 36 0d b9 84 8b 42 50			.byte	$0e,$36,$0d,$b9,$84,$8b,$42,$50
>9150	fd 06 39 33 37 35 00 09			.byte	$fd,$06,$39,$33,$37,$35,$00,$09
>9158	22 0b dc 06 b9 84 40 00			.byte	$22,$0b,$dc,$06,$b9,$84,$40,$00
>9160	0d 2c 0b dc 08 37 0b 10			.byte	$0d,$2c,$0b,$dc,$08,$37,$0b,$10
>9168	0e bb 84 40 00 13 36 0b			.byte	$0e,$bb,$84,$40,$00,$13,$36,$0b
>9170	dc 05 31 11 17 09 b9 84			.byte	$dc,$05,$31,$11,$17,$09,$b9,$84
>9178	41 43 fd 05 31 32 35 00			.byte	$41,$43,$fd,$05,$31,$32,$35,$00
>9180	0d 40 0b dc 1a 38 03 09			.byte	$0d,$40,$0b,$dc,$1a,$38,$03,$09
>9188	bb 84 4e 6a 00 12 4a 0b			.byte	$bb,$84,$4e,$6a,$00,$12,$4a,$0b
>9190	dc 19 32 13 05 0b 84 8b			.byte	$dc,$19,$32,$13,$05,$0b,$84,$8b
>9198	47 5c fd 04 32 35 00 0d			.byte	$47,$5c,$fd,$04,$32,$35,$00,$0d
>91a0	54 0b dc 11 32 12 0c b7			.byte	$54,$0b,$dc,$11,$32,$12,$0c,$b7
>91a8	84 fe 02 00 0b 5e 0b dc			.byte	$84,$fe,$02,$00,$0b,$5e,$0b,$dc
>91b0	13 bb 84 8b 46 6f 00 13			.byte	$13,$bb,$84,$8b,$46,$6f,$00,$13
>91b8	68 0b dc 11 34 0d 03 b9			.byte	$68,$0b,$dc,$11,$34,$0d,$03,$b9
>91c0	84 43 64 fd 06 39 33 37			.byte	$84,$43,$64,$fd,$06,$39,$33,$37
>91c8	35 00 0d 72 0b dc 17 31			.byte	$35,$00,$0d,$72,$0b,$dc,$17,$31
>91d0	03 bb 84 8b 49 78 00 0d			.byte	$03,$bb,$84,$8b,$49,$78,$00,$0d
>91d8	7c 0b dc 12 33 13 0c 18			.byte	$7c,$0b,$dc,$12,$33,$13,$0c,$18
>91e0	bb 84 40 00 10 86 0b dc			.byte	$bb,$84,$40,$00,$10,$86,$0b,$dc
>91e8	0d 34 11 0d b7 84 fe 05			.byte	$0d,$34,$11,$0d,$b7,$84,$fe,$05
>91f0	42 39 44 00 14 90 0b dc			.byte	$42,$39,$44,$00,$14,$90,$0b,$dc
>91f8	04 34 1a 12 0a b9 84 43			.byte	$04,$34,$1a,$12,$0a,$b9,$84,$43
>9200	71 fd 06 38 31 32 35 00			.byte	$71,$fd,$06,$38,$31,$32,$35,$00
>9208	0a 9a 0b dc 0b 32 08 84			.byte	$0a,$9a,$0b,$dc,$0b,$32,$08,$84
>9210	40 00 0b a4 0b dc 17 b7			.byte	$40,$00,$0b,$a4,$0b,$dc,$17,$b7
>9218	84 fe 03 41 00 11 ae 0b			.byte	$84,$fe,$03,$41,$00,$11,$ae,$0b
>9220	dc 15 33 05 b9 84 8b 79			.byte	$dc,$15,$33,$05,$b9,$84,$8b,$79
>9228	fd 05 36 32 35 00 10 b8			.byte	$fd,$05,$36,$32,$35,$00,$10,$b8
>9230	0b dc 0b 39 16 19 b7 84			.byte	$0b,$dc,$0b,$39,$16,$19,$b7,$84
>9238	fe 05 56 36 50 00 10 c2			.byte	$fe,$05,$56,$36,$50,$00,$10,$c2
>9240	0b dc 0c 31 0b 18 0b 84			.byte	$0b,$dc,$0c,$31,$0b,$18,$0b,$84
>9248	46 59 fd 03 30 00 0b cc			.byte	$46,$59,$fd,$03,$30,$00,$0b,$cc
>9250	0b dc 19 bb 84 8b 4a 48			.byte	$0b,$dc,$19,$bb,$84,$8b,$4a,$48
>9258	00 12 d6 0b dc 18 35 03			.byte	$00,$12,$d6,$0b,$dc,$18,$35,$03
>9260	01 84 48 51 fd 06 31 38			.byte	$01,$84,$48,$51,$fd,$06,$31,$38
>9268	37 35 00 11 e0 0b dc 08			.byte	$37,$35,$00,$11,$e0,$0b,$dc,$08
>9270	38 13 0c b9 84 8b 41 5b			.byte	$38,$13,$0c,$b9,$84,$8b,$41,$5b
>9278	fd 03 35 00 0c ea 0b dc			.byte	$fd,$03,$35,$00,$0c,$ea,$0b,$dc
>9280	12 39 19 18 b9 84 40 00			.byte	$12,$39,$19,$18,$b9,$84,$40,$00
>9288	0f f4 0b dc 10 32 1a 03			.byte	$0f,$f4,$0b,$dc,$10,$32,$1a,$03
>9290	b7 84 fe 04 52 34 00 0e			.byte	$b7,$84,$fe,$04,$52,$34,$00,$0e
>9298	fe 0b dc 0b 36 08 0e 19			.byte	$fe,$0b,$dc,$0b,$36,$08,$0e,$19
>92a0	bb 84 42 5e 00 0c 08 0c			.byte	$bb,$84,$42,$5e,$00,$0c,$08,$0c
>92a8	dc 0a 30 03 bb 84 8b 5a			.byte	$dc,$0a,$30,$03,$bb,$84,$8b,$5a
>92b0	00 0e 12 0c dc 11 37 08			.byte	$00,$0e,$12,$0c,$dc,$11,$37,$08
>92b8	07 01 bb 84 48 4f 00 13			.byte	$07,$01,$bb,$84,$48,$4f,$00,$13
>92c0	1c 0c dc 06 31 05 10 01			.byte	$1c,$0c,$dc,$06,$31,$05,$10,$01
>92c8	b9 84 43 60 fd 05 31 32			.byte	$b9,$84,$43,$60,$fd,$05,$31,$32
>92d0	35 00 11 26 0c dc 01 b9			.byte	$35,$00,$11,$26,$0c,$dc,$01,$b9
>92d8	84 8b 43 6f fd 06 34 33			.byte	$84,$8b,$43,$6f,$fd,$06,$34,$33
>92e0	37 35 00 12 30 0c dc 14			.byte	$37,$35,$00,$12,$30,$0c,$dc,$14
>92e8	34 11 15 84 48 4a fd 06			.byte	$34,$11,$15,$84,$48,$4a,$fd,$06
>92f0	38 31 32 35 00 2b 3a 0c			.byte	$38,$31,$32,$35,$00,$2b,$3a,$0c
>92f8	dc 1a 32 12 04 b8 40 be			.byte	$dc,$1a,$32,$12,$04,$b8,$40,$be
>9300	84 fe 02 c0 dc 1a 32 12			.byte	$84,$fe,$02,$c0,$dc,$1a,$32,$12
>9308	04 b8 41 be 84 fe 06 4b			.byte	$04,$b8,$41,$be,$84,$fe,$06,$4b
>9310	36 47 53 c0 dc 1a 32 12			.byte	$36,$47,$53,$c0,$dc,$1a,$32,$12
>9318	04 b8 42 be 84 fe 02 00			.byte	$04,$b8,$42,$be,$84,$fe,$02,$00
>9320	5b 44 0c dc 08 34 16 0b			.byte	$5b,$44,$0c,$dc,$08,$34,$16,$0b
>9328	10 bc 40 bf 40 be 84 8b			.byte	$10,$bc,$40,$bf,$40,$be,$84,$8b
>9330	45 49 c0 dc 08 34 16 0b			.byte	$45,$49,$c0,$dc,$08,$34,$16,$0b
>9338	10 bc 40 bf 41 be 84 8b			.byte	$10,$bc,$40,$bf,$41,$be,$84,$8b
>9340	45 67 c0 dc 08 34 16 0b			.byte	$45,$67,$c0,$dc,$08,$34,$16,$0b
>9348	10 bc 41 bf 40 be 84 40			.byte	$10,$bc,$41,$bf,$40,$be,$84,$40
>9350	c0 dc 08 34 16 0b 10 bc			.byte	$c0,$dc,$08,$34,$16,$0b,$10,$bc
>9358	41 bf 41 be 84 40 c0 dc			.byte	$41,$bf,$41,$be,$84,$40,$c0,$dc
>9360	08 34 16 0b 10 bc 42 bf			.byte	$08,$34,$16,$0b,$10,$bc,$42,$bf
>9368	40 be 84 40 c0 dc 08 34			.byte	$40,$be,$84,$40,$c0,$dc,$08,$34
>9370	16 0b 10 bc 42 bf 41 be			.byte	$16,$0b,$10,$bc,$42,$bf,$41,$be
>9378	84 40 00 1d 4e 0c dc 15			.byte	$84,$40,$00,$1d,$4e,$0c,$dc,$15
>9380	b8 40 be 84 fe 07 4b 32			.byte	$b8,$40,$be,$84,$fe,$07,$4b,$32
>9388	54 42 41 c0 dc 15 b8 41			.byte	$54,$42,$41,$c0,$dc,$15,$b8,$41
>9390	be 84 fe 05 4d 31 4a 00			.byte	$be,$84,$fe,$05,$4d,$31,$4a,$00
>9398	21 58 0c dc 05 32 02 bd			.byte	$21,$58,$0c,$dc,$05,$32,$02,$bd
>93a0	40 be 84 40 c0 dc 05 32			.byte	$40,$be,$84,$40,$c0,$dc,$05,$32
>93a8	02 bd 41 be 84 40 c0 dc			.byte	$02,$bd,$41,$be,$84,$40,$c0,$dc
>93b0	05 32 02 bd 42 be 84 40			.byte	$05,$32,$02,$bd,$42,$be,$84,$40
>93b8	00 20 62 0c dc 04 37 13			.byte	$00,$20,$62,$0c,$dc,$04,$37,$13
>93c0	0b b8 40 be 84 fe 04 4a			.byte	$0b,$b8,$40,$be,$84,$fe,$04,$4a
>93c8	32 c0 dc 04 37 13 0b b8			.byte	$32,$c0,$dc,$04,$37,$13,$0b,$b8
>93d0	41 be 84 fe 05 59 32 4b			.byte	$41,$be,$84,$fe,$05,$59,$32,$4b
>93d8	00 30 6c 0c dc 14 35 15			.byte	$00,$30,$6c,$0c,$dc,$14,$35,$15
>93e0	10 b8 40 be 84 fe 02 c0			.byte	$10,$b8,$40,$be,$84,$fe,$02,$c0
>93e8	dc 14 35 15 10 b8 41 be			.byte	$dc,$14,$35,$15,$10,$b8,$41,$be
>93f0	84 fe 07 56 32 4d 41 4f			.byte	$84,$fe,$07,$56,$32,$4d,$41,$4f
>93f8	c0 dc 14 35 15 10 b8 42			.byte	$c0,$dc,$14,$35,$15,$10,$b8,$42
>9400	be 84 fe 06 44 37 4c 46			.byte	$be,$84,$fe,$06,$44,$37,$4c,$46
>9408	00 2a 76 0c dc 06 34 08			.byte	$00,$2a,$76,$0c,$dc,$06,$34,$08
>9410	03 05 bc 40 be 84 4b 74			.byte	$03,$05,$bc,$40,$be,$84,$4b,$74
>9418	c0 dc 06 34 08 03 05 bc			.byte	$c0,$dc,$06,$34,$08,$03,$05,$bc
>9420	41 be 84 8b 46 6b c0 dc			.byte	$41,$be,$84,$8b,$46,$6b,$c0,$dc
>9428	06 34 08 03 05 bc 42 be			.byte	$06,$34,$08,$03,$05,$bc,$42,$be
>9430	84 40 00 1c 80 0c dc 05			.byte	$84,$40,$00,$1c,$80,$0c,$dc,$05
>9438	36 14 13 bc 40 be 84 8b			.byte	$36,$14,$13,$bc,$40,$be,$84,$8b
>9440	43 79 c0 dc 05 36 14 13			.byte	$43,$79,$c0,$dc,$05,$36,$14,$13
>9448	bc 41 be 84 4a 7f 00 21			.byte	$bc,$41,$be,$84,$4a,$7f,$00,$21
>9450	8a 0c dc 14 32 16 bd 40			.byte	$8a,$0c,$dc,$14,$32,$16,$bd,$40
>9458	be 84 40 c0 dc 14 32 16			.byte	$be,$84,$40,$c0,$dc,$14,$32,$16
>9460	bd 41 be 84 40 c0 dc 14			.byte	$bd,$41,$be,$84,$40,$c0,$dc,$14
>9468	32 16 bd 42 be 84 40 00			.byte	$32,$16,$bd,$42,$be,$84,$40,$00
>9470	27 94 0c dc 11 37 09 06			.byte	$27,$94,$0c,$dc,$11,$37,$09,$06
>9478	b8 40 be 84 fe 02 c0 dc			.byte	$b8,$40,$be,$84,$fe,$02,$c0,$dc
>9480	11 37 09 06 b8 41 be 84			.byte	$11,$37,$09,$06,$b8,$41,$be,$84
>9488	fe 02 c0 dc 11 37 09 06			.byte	$fe,$02,$c0,$dc,$11,$37,$09,$06
>9490	b8 42 be 84 fe 02 00 28			.byte	$b8,$42,$be,$84,$fe,$02,$00,$28
>9498	9e 0c dc 01 35 0e b8 40			.byte	$9e,$0c,$dc,$01,$35,$0e,$b8,$40
>94a0	be 84 fe 02 c0 dc 01 35			.byte	$be,$84,$fe,$02,$c0,$dc,$01,$35
>94a8	0e b8 41 be 84 fe 02 c0			.byte	$0e,$b8,$41,$be,$84,$fe,$02,$c0
>94b0	dc 01 35 0e b8 42 be 84			.byte	$dc,$01,$35,$0e,$b8,$42,$be,$84
>94b8	fe 06 56 38 4a 54 00 2e			.byte	$fe,$06,$56,$38,$4a,$54,$00,$2e
>94c0	a8 0c dc 13 34 02 ba 40			.byte	$a8,$0c,$dc,$13,$34,$02,$ba,$40
>94c8	be 84 48 fd 06 33 31 32			.byte	$be,$84,$48,$fd,$06,$33,$31,$32
>94d0	35 c0 dc 13 34 02 ba 41			.byte	$35,$c0,$dc,$13,$34,$02,$ba,$41
>94d8	be 84 46 62 fd 06 35 36			.byte	$be,$84,$46,$62,$fd,$06,$35,$36
>94e0	32 35 c0 dc 13 34 02 ba			.byte	$32,$35,$c0,$dc,$13,$34,$02,$ba
>94e8	42 be 84 40 00 1b b2 0c			.byte	$42,$be,$84,$40,$00,$1b,$b2,$0c
>94f0	d6 fe 14 50 61 73 73 65			.byte	$d6,$fe,$14,$50,$61,$73,$73,$65
>94f8	64 20 41 73 73 69 67 6e			.byte	$64,$20,$41,$73,$73,$69,$67,$6e
>9500	6d 65 6e 74 2e c0 c4 00			.byte	$6d,$65,$6e,$74,$2e,$c0,$c4,$00
>9508	00					.byte	$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4a a2	jsr $a24a			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c 2e b1	jmp $b12e		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b1 a1	jsr $a1b1			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c0 a1	jsr $a1c0			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b1 a1	jsr $a1b1			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 05	sta $0500			sta 	IFT_XCursor
.a030	8d 01 05	sta $0501			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 20		beq $a065			beq 	IFT_NewLine
.a045	c9 08		cmp #$08			cmp 	#8
.a047	f0 16		beq $a05f			beq 	_IFT_Left
.a049	48		pha				pha
.a04a	20 7d a0	jsr $a07d			jsr 	IFT_UpperCase 				; make upper case
.a04d	20 e0 a1	jsr $a1e0			jsr 	IF_Write 					; write out.
.a050	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.a053	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.a056	c9 50		cmp #$50			cmp 	#IF_Width
.a058	d0 03		bne $a05d			bne 	_IFT_PCNotEOL
.a05a	20 65 a0	jsr $a065			jsr 	IFT_NewLine 				; if so do new line.
.a05d					_IFT_PCNotEOL:
.a05d	68		pla				pla
.a05e	60		rts				rts
.a05f					_IFT_Left:
.a05f	48		pha				pha
.a060	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a063	68		pla				pla
.a064	60		rts				rts
.a065					IFT_NewLine:
.a065	48		pha				pha
.a066	20 c0 a1	jsr $a1c0			jsr 	IF_NewLine 					; new line on actual screen.
.a069	a9 00		lda #$00			lda 	#0 							; reset x position
.a06b	8d 00 05	sta $0500			sta 	IFT_XCursor
.a06e	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.a071	ad 01 05	lda $0501			lda 	IFT_YCursor
.a074	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a076	d0 03		bne $a07b			bne 	_IFT_NL_NotEOS
.a078	20 88 a0	jsr $a088			jsr 	IFT_Scroll 					; scroll screen up.
.a07b					_IFT_NL_NotEOS:
.a07b	68		pla				pla
.a07c	60		rts				rts
.a07d					IFT_UpperCase:
.a07d	c9 61		cmp #$61			cmp 	#"a"
.a07f	90 06		bcc $a087			bcc 	_IFT_UCExit
.a081	c9 7b		cmp #$7b			cmp 	#"z"+1
.a083	b0 02		bcs $a087			bcs 	_IFT_UCExit
.a085	49 20		eor #$20			eor 	#$20
.a087					_IFT_UCExit:
.a087	60		rts				rts
.a088					IFT_Scroll:
.a088	48		pha				pha 								; save AXY
.a089	da		phx				phx
.a08a	5a		phy				phy
.a08b	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a08d					_IFT_SLoop:
.a08d	20 ad a0	jsr $a0ad			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a090	e8		inx				inx
.a091	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a093	d0 f8		bne $a08d			bne 	_IFT_SLoop
.a095	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a097	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a09a	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09c					_IFT_SBlank:
.a09c	a9 20		lda #$20			lda 	#32
.a09e	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a0a1	ca		dex				dex
.a0a2	d0 f8		bne $a09c			bne 	_IFT_SBlank
.a0a4	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a6	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a0a9	7a		ply				ply
.a0aa	fa		plx				plx
.a0ab	68		pla				pla
.a0ac	60		rts				rts
.a0ad					_IFT_ScrollLine:
.a0ad	da		phx				phx
.a0ae	da		phx				phx
.a0af	8a		txa				txa 								; copy line into buffer.
.a0b0	1a		inc a				inc 	a 							; next line down.
.a0b1	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a0b4	a2 00		ldx #$00			ldx 	#0
.a0b6					_IFTScrollCopy1:
.a0b6	20 d2 a1	jsr $a1d2			jsr 	IF_Read
.a0b9	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.a0bc	e8		inx				inx
.a0bd	e0 50		cpx #$50			cpx 	#IF_Width
.a0bf	d0 f5		bne $a0b6			bne 	_IFTScrollCopy1
.a0c1	68		pla				pla
.a0c2	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a0c5	a2 00		ldx #$00			ldx 	#0
.a0c7					_IFTScrollCopy2:
.a0c7	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.a0ca	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a0cd	e8		inx				inx
.a0ce	e0 50		cpx #$50			cpx 	#IF_Width
.a0d0	d0 f5		bne $a0c7			bne 	_IFTScrollCopy2
.a0d2	fa		plx				plx
.a0d3	60		rts				rts
.a0d4					IFT_SetYPos:
.a0d4	48		pha				pha
.a0d5	da		phx				phx
.a0d6	aa		tax				tax
.a0d7	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0da	e0 00		cpx #$00			cpx 	#0
.a0dc	f0 09		beq $a0e7			beq 	_IFT_MOAExit
.a0de					_IFT_MOALoop:
.a0de	20 c0 a1	jsr $a1c0			jsr 	IF_NewLine
.a0e1	ee 01 05	inc $0501			inc 	IFT_YCursor
.a0e4	ca		dex				dex
.a0e5	d0 f7		bne $a0de			bne		_IFT_MOALoop
.a0e7					_IFT_MOAExit:
.a0e7	fa		plx				plx
.a0e8	68		pla				pla
.a0e9	60		rts				rts
.a0ea					IFT_GetKeyCursor:
.a0ea	20 f2 a0	jsr $a0f2			jsr 	_IFT_FlipCursor 			; reverse current
.a0ed					_IFT_GKCWait:
.a0ed	20 03 a2	jsr $a203			jsr 	IF_GetKey 					; get key
.a0f0	f0 fb		beq $a0ed			beq 	_IFT_GKCWait
.a0f2					_IFT_FlipCursor:
.a0f2	48		pha				pha 								; save
.a0f3	20 d2 a1	jsr $a1d2			jsr 	IF_Read 					; read
.a0f6	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a0f9	49 80		eor #$80			eor 	#$80 						; reverse
.a0fb	20 e0 a1	jsr $a1e0			jsr 	IF_Write 					; write
.a0fe	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a101	68		pla				pla
.a102	60		rts				rts
.a103					IFT_ReadLine:
.a103	48		pha				pha
.a104					_IFT_RLLoop:
.a104	20 ea a0	jsr $a0ea			jsr 	IFT_GetKeyCursor 			; get keystroke
.a107	c9 0d		cmp #$0d			cmp 	#13							; return
.a109	f0 7d		beq $a188			beq 	_IFT_RLExit
.a10b	c9 20		cmp #$20			cmp 	#32 						; control character
.a10d	90 05		bcc $a114			bcc 	_IFT_Control
.a10f	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a112	80 f0		bra $a104			bra 	_IFT_RLLoop
.a114					_IFT_Control:
.a114	c9 01		cmp #$01			cmp 	#"A"-64
.a116	f0 26		beq $a13e			beq 	_IFT_Left
.a118	c9 04		cmp #$04			cmp 	#"D"-64
.a11a	f0 2e		beq $a14a			beq 	_IFT_Right
.a11c	c9 17		cmp #$17			cmp 	#"W"-64
.a11e	f0 36		beq $a156			beq 	_IFT_Up
.a120	c9 13		cmp #$13			cmp 	#"S"-64
.a122	f0 3e		beq $a162			beq 	_IFT_Down
.a124	c9 08		cmp #$08			cmp 	#"H"-64
.a126	f0 09		beq $a131			beq 	_IFT_Backspace
.a128	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12a	d0 d8		bne $a104			bne 	_IFT_RLLoop
.a12c	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a12f	80 d3		bra $a104			bra 	_IFT_RLLoop
.a131					_IFT_Backspace:
.a131	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.a134	f0 ce		beq $a104			beq 	_IFT_RLLoop
.a136	20 eb a1	jsr $a1eb			jsr 	IF_LeftOne
.a139	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13b	20 e0 a1	jsr $a1e0			jsr 	IF_Write
.a13e					_IFT_Left:
.a13e	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.a141	10 29		bpl $a16c			bpl 	_IFT_Reposition
.a143	a9 4f		lda #$4f			lda 	#IF_Width-1
.a145					_IFT_SetX:
.a145	8d 00 05	sta $0500			sta 	IFT_XCursor
.a148	80 22		bra $a16c			bra 	_IFT_Reposition
.a14a					_IFT_Right:
.a14a	ee 00 05	inc $0500			inc 	IFT_XCursor
.a14d	ad 00 05	lda $0500			lda 	IFT_XCursor
.a150	49 50		eor #$50			eor 	#IF_Width
.a152	f0 f1		beq $a145			beq 	_IFT_SetX
.a154	80 16		bra $a16c			bra 	_IFT_Reposition
.a156					_IFT_Up:
.a156	ce 01 05	dec $0501			dec 	IFT_YCursor
.a159	10 11		bpl $a16c			bpl 	_IFT_Reposition
.a15b	a9 18		lda #$18			lda 	#IF_Height-1
.a15d					_IFT_SetY:
.a15d	8d 01 05	sta $0501			sta 	IFT_YCursor
.a160	80 0a		bra $a16c			bra 	_IFT_Reposition
.a162					_IFT_Down:
.a162	ee 01 05	inc $0501			inc 	IFT_YCursor
.a165	ad 01 05	lda $0501			lda 	IFT_YCursor
.a168	49 19		eor #$19			eor 	#IF_Height
.a16a	f0 f1		beq $a15d			beq 	_IFT_SetY
.a16c					_IFT_Reposition:
.a16c	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a16f	48		pha				pha
.a170	ad 01 05	lda $0501			lda 	IFT_YCursor
.a173	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a176	68		pla				pla
.a177	aa		tax				tax
.a178	e0 00		cpx #$00			cpx 	#0
.a17a	f0 88		beq $a104			beq 	_IFT_RLLoop
.a17c					_IFT_MoveRight:
.a17c	20 d2 a1	jsr $a1d2			jsr 	IF_Read
.a17f	ee 00 05	inc $0500			inc 	IFT_XCursor
.a182	ca		dex				dex
.a183	d0 f7		bne $a17c			bne 	_IFT_MoveRight
.a185	4c 04 a1	jmp $a104			jmp 	_IFT_RLLoop
.a188					_IFT_RLExit:
.a188	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.a18b	20 d4 a0	jsr $a0d4			jsr 	IFT_SetYPos
.a18e	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a190					_IFT_RLRead:
.a190	20 d2 a1	jsr $a1d2			jsr 	IF_Read
.a193	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a196	e8		inx				inx
.a197	e0 50		cpx #$50			cpx 	#IF_Width
.a199	d0 f5		bne $a190			bne 	_IFT_RLRead
.a19b					_IFT_RL_Trim:
.a19b	ca		dex				dex 	 							; previous char
.a19c	30 07		bmi $a1a5			bmi 	_IFT_Found 					; gone too far
.a19e	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a1	c9 20		cmp #$20			cmp 	#" "
.a1a3	f0 f6		beq $a19b			beq 	_IFT_RL_Trim
.a1a5					_IFT_Found:
.a1a5	e8		inx				inx 								; forward to non-space
.a1a6	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1a8	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.a1ab	68		pla				pla
.a1ac	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1ae	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.a1b0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b1					IF_Home:
.a1b1	48		pha				pha 								; reset cursor position
.a1b2	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b4	85 04		sta $04				sta 	IF_Pos
.a1b6	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1b8	85 05		sta $05				sta 	IF_Pos+1
.a1ba	a9 00		lda #$00			lda 	#0
.a1bc	85 06		sta $06				sta 	IF_XPos
.a1be	68		pla				pla
.a1bf	60		rts				rts
.a1c0					IF_NewLine:
.a1c0	48		pha				pha
.a1c1	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c3	85 06		sta $06				sta 	IF_XPos
.a1c5	18		clc				clc 								; down one line
.a1c6	a5 04		lda $04				lda 	IF_Pos
.a1c8	69 50		adc #$50			adc 	#80
.a1ca	85 04		sta $04				sta 	IF_Pos
.a1cc	90 02		bcc $a1d0			bcc 	_IF_NoCarry 				; carry through.
.a1ce	e6 05		inc $05				inc 	IF_Pos+1
.a1d0					_IF_NoCarry:
.a1d0	68		pla				pla
.a1d1	60		rts				rts
.a1d2					IF_Read:
.a1d2	5a		phy				phy 								; save current Y
.a1d3	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d5	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1d7	49 20		eor #$20			eor 	#$20
.a1d9	18		clc				clc
.a1da	69 20		adc #$20			adc 	#$20
.a1dc	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1de	7a		ply				ply									; restore Y
.a1df	60		rts				rts
.a1e0					IF_Write:
.a1e0	5a		phy				phy 								; save current Y
.a1e1	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e3	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e5	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1e7	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e9	7a		ply				ply									; restore Y
.a1ea	60		rts				rts
.a1eb					IF_LeftOne:
.a1eb	c6 06		dec $06				dec 	IF_XPos
.a1ed	60		rts				rts
.a1ee					IF_CheckBreak:
.a1ee	db		phz				phz
.a1ef	20 37 a2	jsr $a237			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f2	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f4	ea		nop				nop 								; read modifiers.
.a1f5	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1f7	fb		plz				plz 								; restore Z
.a1f8	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fa	c9 05		cmp #$05			cmp 	#5
.a1fc	f0 02		beq $a200			beq 	_IF_CBExit
.a1fe	a9 00		lda #$00			lda 	#0
.a200					_IF_CBExit:
.a200	c9 00		cmp #$00			cmp 	#0
.a202	60		rts				rts
.a203					IF_GetKey:
.a203	db		phz				phz
.a204	20 37 a2	jsr $a237			jsr 	IF_SetupKeyAddress
.a207	ea		nop				nop 								; read keyboard
.a208	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20a	c9 14		cmp #$14			cmp 	#20
.a20c	d0 02		bne $a210			bne 	_KMNo
.a20e	a9 08		lda #$08			lda 	#"H"-64
.a210					_KMNo:
.a210	c9 91		cmp #$91			cmp 	#145
.a212	d0 02		bne $a216			bne 	_KMNo
.a214	a9 17		lda #$17			lda 	#"W"-64
.a216					_KMNo:
.a216	c9 11		cmp #$11			cmp 	#17
.a218	d0 02		bne $a21c			bne 	_KMNo
.a21a	a9 13		lda #$13			lda 	#"S"-64
.a21c					_KMNo:
.a21c	c9 9d		cmp #$9d			cmp 	#157
.a21e	d0 02		bne $a222			bne 	_KMNo
.a220	a9 01		lda #$01			lda 	#"A"-64
.a222					_KMNo:
.a222	c9 1d		cmp #$1d			cmp 	#29
.a224	d0 02		bne $a228			bne 	_KMNo
.a226	a9 04		lda #$04			lda 	#"D"-64
.a228					_KMNo:
.a228	c9 00		cmp #$00			cmp 	#0
.a22a	f0 07		beq $a233			beq 	_IFGKEmpty
.a22c	48		pha				pha
.a22d	a9 00		lda #$00			lda 	#0
.a22f	ea		nop				nop
.a230	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a232	68		pla				pla
.a233					_IFGKEmpty:
.a233	fb		plz				plz
.a234	c9 00		cmp #$00			cmp 	#0 							; set Z
.a236	60		rts				rts
.a237					IF_SetupKeyAddress:
.a237	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a239	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23b	a9 fd		lda #$fd			lda 	#$FD
.a23d	85 0a		sta $0a				sta 	IF_FarPtr+2
.a23f	a9 36		lda #$36			lda 	#$36
.a241	85 09		sta $09				sta 	IF_FarPtr+1
.a243	a9 10		lda #$10			lda 	#$10
.a245	85 08		sta $08				sta 	IF_FarPtr+0
.a247	a3 00		ldz #$00			ldz 	#0
.a249	60		rts				rts
.a24a					IF_Reset:
.a24a	48		pha				pha 								; save registers
.a24b	da		phx				phx
.a24c	5a		phy				phy
.a24d	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a24f	85 0b		sta $0b				sta 	IF_FarPtr+3
.a251	a9 fd		lda #$fd			lda 	#$FD
.a253	85 0a		sta $0a				sta 	IF_FarPtr+2
.a255	a9 30		lda #$30			lda 	#$30
.a257	85 09		sta $09				sta 	IF_FarPtr+1
.a259	a9 00		lda #$00			lda 	#$00
.a25b	85 08		sta $08				sta 	IF_FarPtr+0
.a25d	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a25f	a9 47		lda #$47			lda 	#$47
.a261	ea		nop				nop
.a262	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a264	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a266	a9 53		lda #$53			lda 	#$53
.a268	ea		nop				nop
.a269	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26b	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a26d	a9 40		lda #$40			lda 	#$40
.a26f	ea		nop				nop
.a270	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a272	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a274	a9 c0		lda #$c0			lda 	#$80+$40
.a276	ea		nop				nop
.a277	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a279	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27b	a9 00		lda #$00			lda 	#0
.a27d	ea		nop				nop
.a27e	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a280	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a282	a9 00		lda #$00			lda 	#0
.a284	ea		nop				nop
.a285	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a287	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a289	a9 40		lda #$40			lda 	#$40
.a28b	ea		nop				nop
.a28c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28e	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a290	a9 ff		lda #$ff			lda 	#$FF
.a292	ea		nop				nop
.a293	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a295	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a297	a9 ff		lda #$ff			lda 	#$FF
.a299	ea		nop				nop
.a29a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29c	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a29e	a9 cc		lda #$cc			lda 	#$CC
.a2a0	ea		nop				nop
.a2a1	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a3	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a5	a9 42		lda #$42			lda 	#$42
.a2a7	ea		nop				nop
.a2a8	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2aa	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2ac	a9 1b		lda #$1b			lda 	#$1B
.a2ae	ea		nop				nop
.a2af	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b1	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b3	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b5	a9 01		lda #$01			lda 	#$01
.a2b7	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2b9	a9 f8		lda #$f8			lda 	#$F8
.a2bb	85 09		sta $09				sta 	IF_FarPtr+1
.a2bd	a9 00		lda #$00			lda 	#$00
.a2bf	85 08		sta $08				sta 	IF_FarPtr+0
.a2c1	a3 00		ldz #$00			ldz 	#0
.a2c3					_EXTClearColorRam:
.a2c3	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c5	ea		nop				nop
.a2c6	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2c8	3b		dez				dez
.a2c9	d0 f8		bne $a2c3			bne 	_EXTClearColorRam
.a2cb	e6 09		inc $09				inc 	IF_FarPtr+1
.a2cd	d0 f4		bne $a2c3			bne 	_EXTClearColorRam
.a2cf	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d1					_EXTCopyCBMFont:
.a2d1	bd 12 a3	lda $a312,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d4	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2d7	49 ff		eor #$ff			eor 	#$FF
.a2d9	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2dc	bd 12 a4	lda $a412,x			lda 	IF_CBMFont+$100,x
.a2df	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e2	49 ff		eor #$ff			eor 	#$FF
.a2e4	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2e7	bd 12 a5	lda $a512,x			lda 	IF_CBMFont+$200,x
.a2ea	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2ed	49 ff		eor #$ff			eor 	#$FF
.a2ef	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f2	bd 12 a6	lda $a612,x			lda 	IF_CBMFont+$300,x
.a2f5	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2f8	49 ff		eor #$ff			eor 	#$FF
.a2fa	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a2fd	ca		dex				dex
.a2fe	d0 d1		bne $a2d1			bne 	_EXTCopyCBMFont
.a300	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a302	85 01		sta $01				sta 	$01
.a304	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a306	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a308	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30a	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30c	5c		map				map
.a30d	ea		nop				eom
.a30e	7a		ply				ply 								; restore and exit.
.a30f	fa		plx				plx
.a310	68		pla				pla
.a311	60		rts				rts
.a312					IF_CBMFont:
>a312	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31a	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32a	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33a	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34a	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35a	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36a	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37a	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38a	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39a	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3aa	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3ba	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3ca	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3da	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ea	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fa	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40a	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41a	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42a	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43a	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44a	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45a	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46a	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47a	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48a	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49a	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4aa	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4ba	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4ca	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4da	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ea	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fa	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50a	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51a	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52a	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53a	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54a	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55a	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56a	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57a	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58a	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59a	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5aa	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5ba	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5ca	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5da	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ea	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fa	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60a	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61a	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62a	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63a	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64a	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65a	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66a	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67a	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68a	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69a	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6aa	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6ba	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6ca	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6da	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ea	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fa	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70a	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71a	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72a	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73a	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74a	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75a	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76a	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77a	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78a	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79a	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7aa	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7ba	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7ca	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7da	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ea	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fa	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80a	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81a	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82a	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83a	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84a	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85a	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86a	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87a	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88a	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89a	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8aa	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8ba	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8ca	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8da	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ea	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fa	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90a	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91a	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92a	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93a	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94a	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95a	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96a	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97a	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98a	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99a	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9aa	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9ba	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9ca	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9da	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ea	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fa	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0a	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1a	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2a	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3a	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4a	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5a	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6a	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7a	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8a	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9a	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaaa	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aaba	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aaca	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aada	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaea	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafa	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0a	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.ab12					TIM_Error:
.ab12	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.ab15	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.ab17	80 02		bra $ab1b			bra 	TIM_ShowPrompt
.ab19					TIM_NewCommand:
.ab19	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.ab1b					TIM_ShowPrompt:
.ab1b	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.ab1e	20 03 a1	jsr $a103			jsr 	IFT_ReadLine	 			; get character, go to next line
.ab21	20 65 a0	jsr $a065			jsr 	IFT_NewLine					; go to next line.
.ab24	86 10		stx $10				stx 	zTemp1 						; save line read address
.ab26	84 11		sty $11				sty 	zTemp1+1
.ab28	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.ab2a	b1 10		lda ($10),y			lda 	(zTemp1),y
.ab2c	c9 3f		cmp #$3f			cmp 	#"?"
.ab2e	f0 04		beq $ab34			beq 	TIM_SkipFirst
.ab30	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.ab32	d0 01		bne $ab35			bne 	TIM_NotDot
.ab34					TIM_SkipFirst:
.ab34	c8		iny				iny
.ab35					TIM_NotDot:
.ab35	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.ab37	c9 52		cmp #$52			cmp 	#"R"						; show registers
.ab39	f0 6e		beq $aba9			beq 	TIM_ShowRegisters
.ab3b	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.ab3d	f0 12		beq $ab51			beq 	TIM_ShowMemory
.ab3f	c9 47		cmp #$47			cmp 	#"G"						; execute
.ab41	f0 49		beq $ab8c			beq 	TIM_Execute
.ab43	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.ab45	f0 07		beq $ab4e			beq 	TIM_GoLoadMemory
.ab47	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.ab49	d0 c7		bne $ab12			bne 	TIM_Error
.ab4b	4c ce ac	jmp $acce			jmp 	TIM_UpdateRegisters
.ab4e					TIM_GoLoadMemory:
.ab4e	4c f9 ac	jmp $acf9			jmp 	TIM_LoadMemory
.ab51					TIM_ShowMemory:
.ab51	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab54	b0 bc		bcs $ab12			bcs 	TIM_Error
.ab56	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.ab58	85 12		sta $12				sta 	zTemp2
.ab5a	a5 15		lda $15				lda 	zTemp3+1
.ab5c	85 13		sta $13				sta 	zTemp2+1
.ab5e	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.ab61	90 08		bcc $ab6b			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.ab63	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.ab65	85 14		sta $14				sta 	zTemp3
.ab67	a5 13		lda $13				lda 	zTemp2+1
.ab69	85 15		sta $15				sta 	zTemp3+1
.ab6b					_TIMSM_Start:
.ab6b	20 1f ac	jsr $ac1f			jsr 	TIM_WriteLine 				; write one line of hex out
.ab6e	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.ab70	18		clc				clc
.ab71	69 10		adc #$10			adc 	#16
.ab73	85 12		sta $12				sta 	zTemp2
.ab75	90 02		bcc $ab79			bcc 	_TIMSM_NoCarry
.ab77	e6 13		inc $13				inc 	zTemp2+1
.ab79					_TIMSM_NoCarry:
.ab79	20 ee a1	jsr $a1ee			jsr 	IF_CheckBreak 				; check CTL+C
.ab7c	d0 0b		bne $ab89			bne 	_TIMSM_Ends 				; if pressed break out.
.ab7e	38		sec				sec 								; check past the end address in zTemp3
.ab7f	a5 14		lda $14				lda 	zTemp3
.ab81	e5 12		sbc $12				sbc 	zTemp2
.ab83	a5 15		lda $15				lda 	zTemp3+1
.ab85	e5 13		sbc $13				sbc 	zTemp2+1
.ab87	10 e2		bpl $ab6b			bpl 	_TIMSM_Start
.ab89					_TIMSM_Ends:
.ab89	4c 19 ab	jmp $ab19			jmp 	TIM_NewCommand
.ab8c					TIM_Execute:
.ab8c	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; get the execute address
.ab8f	b0 81		bcs $ab12			bcs 	TIM_Error 					; not legitimate
.ab91	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.ab94	9a		txs				txs
.ab95	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.ab98	48		pha				pha
.ab99	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.ab9c	ae ca 03	ldx $03ca			ldx 	TIM_X
.ab9f	ac cb 03	ldy $03cb			ldy 	TIM_Y
.aba2	ab cc 03	ldz $03cc			ldz 	TIM_Z
.aba5	28		plp				plp 								; and PS Byte.
.aba6	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.aba9					TIM_Start:
.aba9					TIM_ShowRegisters:
.aba9	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.abac	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.abaf	ad ff ff	lda $ffff			lda 	$FFFF
.abb2	8d c6 03	sta $03c6			sta 	TIM_IRQ
.abb5	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.abb7					_TIMSR_Text:
.abb7	bd e3 ab	lda $abe3,x			lda 	_TIMSR_Label,x
.abba	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abbd	e8		inx				inx
.abbe	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.abc0	d0 f5		bne $abb7			bne 	_TIMSR_Text
.abc2	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.abc4					_TIMSR_Skip:
.abc4	e8		inx				inx
.abc5					_TIMSR_LoopSpace:
.abc5	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.abc7	b0 04		bcs $abcd			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.abc9	8a		txa				txa
.abca	4a		lsr a				lsr 	a
.abcb	b0 05		bcs $abd2			bcs 	_TIMSR_NoSpace
.abcd					_TIMSR_Space:
.abcd	a9 20		lda #$20			lda 	#" "
.abcf	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.abd2					_TIMSR_NoSpace:
.abd2	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.abd5	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.abd8	e8		inx				inx
.abd9	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.abdb	d0 e8		bne $abc5			bne 	_TimSR_LoopSpace
.abdd	20 65 a0	jsr $a065			jsr 	IFT_NewLine 				; new line
.abe0	4c 19 ab	jmp $ab19			jmp	 	TIM_NewCommand 				; new command.
.abe3					_TIMSR_Label:
>abe3	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>abeb	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>abfb	52
>abfc	20 5a 52					.text 	" ZR"
>abff	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.ac06					_TIMSR_LabelEnd:
.ac06					TIM_WriteHex:
.ac06	48		pha				pha 								; save A
.ac07	4a		lsr a				lsr 	a 							; shift MSB->LSB
.ac08	4a		lsr a				lsr 	a
.ac09	4a		lsr a				lsr 	a
.ac0a	4a		lsr a				lsr 	a
.ac0b	20 0f ac	jsr $ac0f			jsr 	_TIMWH_Nibble 				; print MSB
.ac0e	68		pla				pla 								; restore and print LSB
.ac0f					_TIMWH_Nibble:
.ac0f	48		pha				pha
.ac10	29 0f		and #$0f			and 	#15 						; mask out
.ac12	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.ac14	90 02		bcc $ac18			bcc 	_TIMWHNoLetter
.ac16	69 06		adc #$06			adc 	#6
.ac18					_TIMWHNoLetter:
.ac18	69 30		adc #$30			adc 	#48
.ac1a	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.ac1d	68		pla				pla
.ac1e	60		rts				rts
.ac1f					TIM_WriteLine:
.ac1f	a9 2e		lda #$2e			lda 	#"." 						; prompt
.ac21	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac24	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.ac26	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac29	a5 13		lda $13				lda 	zTemp2+1 					; write address
.ac2b	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.ac2e	a5 12		lda $12				lda 	zTemp2
.ac30	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.ac33	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.ac35					_TIMWL_Loop:
.ac35	a9 20		lda #$20			lda 	#" "
.ac37	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ac3a	b1 12		lda ($12),y			lda 	(zTemp2),y
.ac3c	20 06 ac	jsr $ac06			jsr 	TIM_WriteHex
.ac3f	c8		iny				iny
.ac40	c0 10		cpy #$10			cpy 	#16
.ac42	d0 f1		bne $ac35			bne 	_TIMWL_Loop
.ac44	4c 65 a0	jmp $a065			jmp 	IFT_NewLine 				; new line and exit
.ac47					TIM_GetHex:
.ac47	c8		iny				iny
.ac48	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.ac4a	c9 20		cmp #$20			cmp 	#32
.ac4c	f0 f9		beq $ac47			beq 	TIM_GetHex
.ac4e	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.ac50	f0 f5		beq $ac47			beq 	TIM_GetHex
.ac52	20 7b ac	jsr $ac7b			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.ac55	b0 23		bcs $ac7a			bcs 	_TIMGH_Exit					; if first bad then exit now.
.ac57	a9 00		lda #$00			lda 	#0 							; zero result
.ac59	85 14		sta $14				sta 	zTemp3
.ac5b	85 15		sta $15				sta 	zTemp3+1
.ac5d					_TIM_GHLoop:
.ac5d	20 7b ac	jsr $ac7b			jsr 	TIM_GetHexCharacter 		; get next character
.ac60	b0 17		bcs $ac79			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.ac62	c8		iny				iny 								; skip over it.
.ac63	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.ac65	26 15		rol $15				rol 	zTemp3+1
.ac67	06 14		asl $14				asl 	zTemp3 						; now x 2
.ac69	26 15		rol $15				rol 	zTemp3+1
.ac6b	06 14		asl $14				asl 	zTemp3						; now x 4
.ac6d	26 15		rol $15				rol 	zTemp3+1
.ac6f	06 14		asl $14				asl 	zTemp3 						; now x 8
.ac71	26 15		rol $15				rol 	zTemp3+1
.ac73	05 14		ora $14				ora 	zTemp3 						; OR result in
.ac75	85 14		sta $14				sta 	zTemp3
.ac77	80 e4		bra $ac5d			bra 	_TIM_GHLoop 				; loop round again.
.ac79					_TIMGH_Okay:
.ac79	18		clc				clc
.ac7a					_TIMGH_Exit:
.ac7a	60		rts				rts
.ac7b					TIM_GetHexCharacter:
.ac7b	b1 10		lda ($10),y			lda 	(zTemp1),y
.ac7d	38		sec				sec
.ac7e	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.ac80	90 0e		bcc $ac90			bcc 	_TIM_GHCFail
.ac82	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.ac84	90 0b		bcc $ac91			bcc 	_TIM_GHCExit
.ac86	c9 11		cmp #$11			cmp 	#65-48						; < A
.ac88	90 06		bcc $ac90			bcc		_TIM_GHCFail
.ac8a	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.ac8c	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.ac8e	90 01		bcc $ac91			bcc		_TIM_GHCExit
.ac90					_TIM_GHCFail:
.ac90	38		sec				sec
.ac91					_TIM_GHCExit:
.ac91	60		rts				rts
.ac92					TIM_BreakVector:
.ac92	da		phx				phx									; save X/A on stack
.ac93	48		pha				pha
.ac94	ba		tsx				tsx 								; X points to S
.ac95	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.ac98	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.ac9a	d0 03		bne $ac9f			bne 	_TIMBreak					; if set, it's BRK
.ac9c	68		pla				pla 								; abandon routine.
.ac9d	fa		plx				plx
.ac9e	40		rti				rti
.ac9f					_TIMBreak:
.ac9f	68		pla				pla 								; save A X Y and maybe Z
.aca0	8d c9 03	sta $03c9			sta 	TIM_A
.aca3	fa		plx				plx
.aca4	8e ca 03	stx $03ca			stx 	TIM_X
.aca7	8c cb 03	sty $03cb			sty 	TIM_Y
.acaa	9c cc 03	stz $03cc			stz 	TIM_Z
.acad	68		pla				pla 								; get Status Register
.acae	8d c8 03	sta $03c8			sta 	TIM_SR
.acb1	68		pla				pla
.acb2	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.acb5	68		pla				pla
.acb6	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.acb9	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.acbc	d0 03		bne $acc1			bne 	_TIMDecrement 				; brk bumps it.
.acbe	ce c4 03	dec $03c4			dec 	TIM_PC
.acc1					_TIMDecrement:
.acc1	ce c5 03	dec $03c5			dec 	TIM_PC+1
.acc4	ba		tsx				tsx 								; and copy SP
.acc5	8e cd 03	stx $03cd			stx 	TIM_SP
.acc8	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.acca	9a		txs				txs
.accb	4c a9 ab	jmp $aba9			jmp 	TIM_Start 					; and start up TIM monitor.
.acce					TIM_UpdateRegisters:
.acce	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; PC
.acd1	b0 23		bcs $acf6			bcs 	_TIMURFail
.acd3	a5 14		lda $14				lda 	zTemp3
.acd5	8d c5 03	sta $03c5			sta 	Tim_PC+1
.acd8	a5 15		lda $15				lda 	zTemp3+1
.acda	8d c4 03	sta $03c4			sta 	Tim_PC
.acdd	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; ignore IRQ
.ace0	b0 14		bcs $acf6			bcs 	_TIMURFail
.ace2	a2 00		ldx #$00			ldx 	#0
.ace4					_TIM_URLoop:
.ace4	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; registers
.ace7	b0 0d		bcs $acf6			bcs 	_TIMURFail
.ace9	a5 14		lda $14				lda 	zTemp3
.aceb	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.acee	e8		inx				inx
.acef	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.acf1	d0 f1		bne $ace4			bne 	_TIM_URLoop
.acf3	4c 19 ab	jmp $ab19			jmp 	TIM_NewCommand
.acf6					_TIMURFail:
.acf6	4c 12 ab	jmp $ab12			jmp 	TIM_Error
.acf9					TIM_LoadMemory:
.acf9	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; target address => zTemp2
.acfc	a5 14		lda $14				lda 	zTemp3
.acfe	85 12		sta $12				sta 	zTemp2
.ad00	a5 15		lda $15				lda 	zTemp3+1
.ad02	85 13		sta $13				sta 	zTemp2+1
.ad04					_TIM_LMLoop:
.ad04	20 47 ac	jsr $ac47			jsr 	TIM_GetHex 					; next byte ?
.ad07	b0 0e		bcs $ad17			bcs 	_TIMLMDone 					; no more
.ad09	a2 00		ldx #$00			ldx 	#0							; write out.
.ad0b	a5 14		lda $14				lda 	zTemp3
.ad0d	81 12		sta ($12,x)			sta 	(zTemp2,x)
.ad0f	e6 12		inc $12				inc 	zTemp2 						; bump address
.ad11	d0 f1		bne $ad04			bne 	_TIM_LMLoop
.ad13	e6 13		inc $13				inc 	zTemp2+1
.ad15	80 ed		bra $ad04			bra 	_TIM_LMLoop
.ad17					_TIMLMDone:
.ad17	4c 19 ab	jmp $ab19			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.ad1a					StructureSearchSingle:
.ad1a	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.ad1c					StructureSearchDouble:
.ad1c	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.ad1e	86 11		stx $11				stx 	zTemp1+1
.ad20	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.ad22	85 12		sta $12				sta 	zTemp2
.ad24	80 1a		bra $ad40			bra 	_SSWLoop 					; jump in, start scanning from here.
.ad26					_SSWNextLine:
.ad26	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ad28	ea		nop				nop
.ad29	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.ad2b	18		clc				clc
.ad2c	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.ad2e	85 18		sta $18				sta 	zCodePtr
.ad30	90 02		bcc $ad34			bcc 	_SNLNoCarry
.ad32	e6 19		inc $19				inc 	zCodePtr+1
.ad34					_SNLNoCarry:
.ad34	a3 00		ldz #$00			ldz 	#0
.ad36	ea		nop				nop
.ad37	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ad39	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.ad3b	f0 57		beq $ad94			beq 	_SSWFail
.ad3d	1b		inz				inz
.ad3e	1b		inz				inz
.ad3f					_SSWNextSimple:
.ad3f	1b		inz				inz
.ad40					_SSWLoop:
.ad40	ea		nop				nop
.ad41	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ad43	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.ad45	f0 df		beq $ad26			beq 	_SSWNextLine 				; if so, then next line
.ad47	10 f6		bpl $ad3f			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.ad49	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.ad4b	d0 08		bne $ad55			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.ad4d	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.ad4f	f0 2f		beq $ad80			beq 	_SSWFound 					; then exit.
.ad51	c5 11		cmp $11				cmp 	zTemp1+1
.ad53	f0 2b		beq $ad80			beq 	_SSWFound
.ad55					_SSWCheckUpDown:
.ad55	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.ad57	90 10		bcc $ad69			bcc 	_SSWNext
.ad59	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.ad5b	90 08		bcc $ad65			bcc 	_SSWPlus
.ad5d	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.ad5f	b0 08		bcs $ad69			bcs 	_SSWNext
.ad61	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.ad63	c6 12		dec $12				dec 	zTemp2
.ad65					_SSWPlus:
.ad65	e6 12		inc $12				inc 	zTemp2
.ad67	30 18		bmi $ad81			bmi 	_SSWUnder					; error if driven -ve
.ad69					_SSWNext:
.ad69	ea		nop				nop
.ad6a	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.ad6c	1b		inz				inz 								; skip
.ad6d	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ad6f	90 0d		bcc $ad7e			bcc 	_SEDone 					; so just skip over it.
.ad71	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ad73	90 08		bcc $ad7d			bcc 	_SEDouble
.ad75	6b		tza				tza 								; this is Y + 1
.ad76	18		clc				clc
.ad77	ea		nop				nop
.ad78	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.ad7a	4b		taz				taz 								; back in Y.
.ad7b	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ad7c	3b		dez				dez
.ad7d					_SEDouble:
.ad7d	1b		inz				inz
.ad7e					_SEDone:
.ad7e	80 c0		bra $ad40			bra 	_SSWLoop
.ad80					_SSWFound:
.ad80	60		rts				rts
.ad81					_SSWUnder:
.ad81	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ad84	53 74 72 75 63 74 75 72			.text "Structure order",0
>ad8c	65 20 6f 72 64 65 72 00
.ad94					_SSWFail:
.ad94	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ad97	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>ad9f	6e 64 20 73 74 72 75 63 74 75 72 65 00
.adac					SkipEndOfCommand:
.adac	ea		nop				nop
.adad	b2 18		lda ($18),z			lda 	(zCodePtr),z
.adaf	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.adb1	f0 1b		beq $adce			beq 	_SOCExit
.adb3	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.adb5	f0 17		beq $adce			beq 	_SOCExit
.adb7	ea		nop				nop
.adb8	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.adba	1b		inz				inz 								; skip
.adbb	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.adbd	90 0d		bcc $adcc			bcc 	_SEDone 					; so just skip over it.
.adbf	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.adc1	90 08		bcc $adcb			bcc 	_SEDouble
.adc3	6b		tza				tza 								; this is Y + 1
.adc4	18		clc				clc
.adc5	ea		nop				nop
.adc6	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.adc8	4b		taz				taz 								; back in Y.
.adc9	3b		dez				dez 								; fix up, one for the +1, one for the iny
.adca	3b		dez				dez
.adcb					_SEDouble:
.adcb	1b		inz				inz
.adcc					_SEDone:
.adcc	80 de		bra $adac			bra 	SkipEndOfCommand
.adce					_SOCExit:
.adce	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.adcf					StackReset:
.adcf	48		pha				pha
.add0	5a		phy				phy
.add1	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.add3	85 28		sta $28				sta 	zBasicSP
.add5	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.add7	85 29		sta $29				sta 	zBasicSP+1
.add9	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.addb	98		tya				tya 								; be a legal token.
.addc	91 28		sta ($28),y			sta 	(zBasicSP),y
.adde	7a		ply				ply
.addf	68		pla				pla
.ade0	60		rts				rts
.ade1					StackPushFrame:
.ade1	48		pha				pha
.ade2	5a		phy				phy
.ade3	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.ade4	48		pha				pha 								; save it.
.ade5	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.ade7	18		clc				clc 								; add to Basic Stack
.ade8	65 28		adc $28				adc 	zBasicSP
.adea	85 28		sta $28				sta 	zBasicSP
.adec	90 02		bcc $adf0			bcc 	_SPFNoBump
.adee	e6 29		inc $29				inc 	zBasicSP+1
.adf0					_SPFNoBump:
.adf0	a0 00		ldy #$00			ldy 	#0
.adf2	68		pla				pla
.adf3	91 28		sta ($28),y			sta 	(zBasicSP),y
.adf5	7a		ply				ply
.adf6	68		pla				pla
.adf7	60		rts				rts
.adf8					StackPopFrame:
.adf8	48		pha				pha
.adf9	5a		phy				phy
.adfa	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.adfc	51 28		eor ($28),y			eor 	(zBasicSP),y
.adfe	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.ae00	d0 12		bne $ae14			bne 	SPFError 					; mixed structures
.ae02	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.ae04	29 0f		and #$0f			and 	#$0F
.ae06	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.ae08	38		sec				sec
.ae09	65 28		adc $28				adc 	zBasicSP
.ae0b	85 28		sta $28				sta 	zBasicSP
.ae0d	b0 02		bcs $ae11			bcs 	_SPFNoBump
.ae0f	c6 29		dec $29				dec 	zBasicSP+1
.ae11					_SPFNoBump:
.ae11	7a		ply				ply
.ae12	68		pla				pla
.ae13	60		rts				rts
.ae14					SPFError:
.ae14	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ae17	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>ae1f	72 75 63 74 75 72 65 73 00
.ae28					StackSavePosition:
.ae28	6b		tza				tza
.ae29	5a		phy				phy
.ae2a	a0 05		ldy #$05			ldy 	#5
.ae2c	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae2e	a0 01		ldy #$01			ldy 	#1
.ae30	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.ae32	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae34	c8		iny				iny
.ae35	a5 19		lda $19				lda 	zCodePtr+1
.ae37	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae39	c8		iny				iny
.ae3a	a5 1a		lda $1a				lda 	zCodePtr+2
.ae3c	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae3e	c8		iny				iny
.ae3f	a5 1b		lda $1b				lda 	zCodePtr+3
.ae41	91 28		sta ($28),y			sta 	(zBasicSP),y
.ae43	7a		ply				ply
.ae44	60		rts				rts
.ae45					StackRestorePosition:
.ae45	5a		phy				phy
.ae46	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.ae48	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae4a	85 18		sta $18				sta 	zCodePtr+0
.ae4c	c8		iny				iny
.ae4d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae4f	85 19		sta $19				sta 	zCodePtr+1
.ae51	c8		iny				iny
.ae52	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae54	85 1a		sta $1a				sta 	zCodePtr+2
.ae56	c8		iny				iny
.ae57	b1 28		lda ($28),y			lda 	(zBasicSP),y
.ae59	85 1b		sta $1b				sta 	zCodePtr+3
.ae5b	c8		iny				iny
.ae5c	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.ae5e	7a		ply				ply 								; restore Y
.ae5f	4b		taz				taz
.ae60	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.ae61					VIOCharPrint:
.ae61	4c 41 a0	jmp $a041			jmp 	IFT_PrintCharacter
.ae64					VIOCharGet:
.ae64	20 03 a2	jsr $a203			jsr 	IF_GetKey
.ae67	c9 00		cmp #$00			cmp 	#0
.ae69	f0 02		beq $ae6d			beq 	_VCG0
.ae6b	38		sec				sec
.ae6c	60		rts				rts
.ae6d	18		clc		_VCG0:	clc
.ae6e	60		rts				rts
.ae6f					VIOCheckBreak:
.ae6f	4c ee a1	jmp $a1ee			jmp 	IF_CheckBreak
.ae72					VIOCharGetPosition:
.ae72	ad 00 05	lda $0500			lda 	IFT_XCursor
.ae75	60		rts				rts
.ae76					VIOReadLine:
.ae76	4c 03 a1	jmp $a103			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ae79					SyntaxError:
.ae79	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>ae7c	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ae84	72 72 6f 72 00
.ae89					TypeError:
.ae89	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>ae8c	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ae94	70 65 00
.ae97					BadParamError:
.ae97	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>ae9a	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>aea2	6d 65 74 65 72 00
.aea8					ERR_Handler:
.aea8	a3 00		ldz #$00			ldz 	#0
.aeaa	1b		inz				inz
.aeab	ea		nop				nop
.aeac	b2 18		lda ($18),z			lda 	(zCodePtr),z
.aeae	85 80		sta $80				sta 	XS_Mantissa
.aeb0	1b		inz				inz
.aeb1	ea		nop				nop
.aeb2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.aeb4	85 81		sta $81				sta 	XS_Mantissa+1
.aeb6	fa		plx				plx 								; address in XY
.aeb7	7a		ply				ply
.aeb8	e8		inx				inx 								; bump, because of RTS/JSR address -1
.aeb9	d0 01		bne $aebc			bne 	_EHNoSkip
.aebb	c8		iny				iny
.aebc					_EHNoSkip:
.aebc	20 db ae	jsr $aedb			jsr 	PrintROMMessage 			; print message from ROM.
.aebf	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.aec1	05 81		ora $81				ora 	XS_Mantissa+1
.aec3	f0 0c		beq $aed1			beq 	_EHNoLine
.aec5	a2 d6		ldx #$d6			ldx 	#_EHAt & $FF 				; print " at "
.aec7	a0 ae		ldy #$ae			ldy 	#(_EHAt >> 8) & $FF
.aec9	20 db ae	jsr $aedb			jsr 	PrintROMMessage
.aecc	a2 00		ldx #$00			ldx 	#0 							; Print line number
.aece	20 ec ae	jsr $aeec			jsr 	Print16BitInteger
.aed1					_EHNoLine:
.aed1	80 fe		bra $aed1			bra 	_EHNoLine
.aed3	4c 57 b1	jmp $b157			jmp 	WarmStart 					; normally warm start.
>aed6	20 61 74 20 00			_EHAt:	.text 	" at ",0
.aedb					PrintROMMessage:
.aedb	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.aedd	84 1d		sty $1d				sty 	zLTemp1+1
.aedf	a0 00		ldy #$00			ldy 	#0
.aee1					_PRMLoop:
.aee1	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; 6502/4510
.aee3	f0 06		beq $aeeb			beq		_PRMExit 					; character $00 => exit
.aee5	c8		iny				iny  								; bump Y and print it.
.aee6	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.aee9	80 f6		bra $aee1			bra 	_PRMLoop
.aeeb					_PRMExit:
.aeeb	60		rts				rts
.aeec					Print16BitInteger:
.aeec	a9 00		lda #$00			lda 	#0 							; make 32 bit
.aeee	85 82		sta $82				sta 	XS_Mantissa+2
.aef0	85 83		sta $83				sta 	XS_Mantissa+3
.aef2					Print32BitInteger:
.aef2	a9 00		lda #$00			lda 	#0
.aef4	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.aef7	aa		tax				tax 								; convert bottom level.
.aef8	20 fe ca	jsr $cafe			jsr 	INTToString 				; make string from integer in Num_Buffer
.aefb	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.aefd	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.af00	f0 06		beq $af08			beq 	_P1Exit
.af02	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.af05	e8		inx				inx
.af06	80 f5		bra $aefd			bra 	_P1Loop
.af08	8a		txa		_P1Exit:txa 								; return chars printed.
.af09	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.af0a					VectorTable:
>af0a	1c bd					.word BinaryOp_And         & $FFFF ; $80 and
>af0c	38 bd					.word BinaryOp_Or          & $FFFF ; $81 or
>af0e	54 bd					.word BinaryOp_Xor         & $FFFF ; $82 xor
>af10	54 bd					.word BinaryOp_Eor         & $FFFF ; $83 eor
>af12	8b bd					.word Binary_Equal         & $FFFF ; $84 =
>af14	94 bd					.word Binary_NotEqual      & $FFFF ; $85 <>
>af16	9d bd					.word Binary_Less          & $FFFF ; $86 <
>af18	a6 bd					.word Binary_LessEqual     & $FFFF ; $87 <=
>af1a	b8 bd					.word Binary_Greater       & $FFFF ; $88 >
>af1c	af bd					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>af1e	50 be					.word BinaryOp_Add         & $FFFF ; $8a +
>af20	6c be					.word BinaryOp_Subtract    & $FFFF ; $8b -
>af22	7d be					.word BinaryOp_Multiply    & $FFFF ; $8c *
>af24	8e be					.word BinaryOp_Divide      & $FFFF ; $8d /
>af26	c8 af					.word NotImplemented       & $FFFF ; $8e ^
>af28	7d b6					.word Command_IF           & $FFFF ; $8f if
>af2a	11 bb					.word Command_WHILE        & $FFFF ; $90 while
>af2c	39 bb					.word Command_REPEAT       & $FFFF ; $91 repeat
>af2e	be b2					.word Command_FOR          & $FFFF ; $92 for
>af30	c8 af					.word NotImplemented       & $FFFF ; $93 then
>af32	e0 b6					.word Command_ENDIF        & $FFFF ; $94 endif
>af34	2e bb					.word Command_WEND         & $FFFF ; $95 wend
>af36	42 bb					.word Command_UNTIL        & $FFFF ; $96 until
>af38	3c b3					.word Command_NEXT         & $FFFF ; $97 next
>af3a	c8 af					.word NotImplemented       & $FFFF ; $98 not
>af3c	c8 af					.word NotImplemented       & $FFFF ; $99 fn(
>af3e	93 bf					.word Unary_Abs            & $FFFF ; $9a abs(
>af40	ed c0					.word Unary_Asc            & $FFFF ; $9b asc(
>af42	28 d2					.word Unary_Int            & $FFFF ; $9c int(
>af44	ad bf					.word Unary_Peek           & $FFFF ; $9d peek(
>af46	a9 d1					.word Unary_Rnd            & $FFFF ; $9e rnd(
>af48	20 c0					.word Unary_Usr            & $FFFF ; $9f usr(
>af4a	2c c1					.word Unary_Left           & $FFFF ; $a0 left$(
>af4c	41 c1					.word Unary_Right          & $FFFF ; $a1 right$(
>af4e	13 c1					.word Unary_Mid            & $FFFF ; $a2 mid$(
>af50	8c c2					.word Unary_Spc            & $FFFF ; $a3 spc(
>af52	bb c0					.word Unary_Str            & $FFFF ; $a4 str$(
>af54	40 c0					.word Unary_Val            & $FFFF ; $a5 val(
>af56	04 c1					.word Unary_Len            & $FFFF ; $a6 len(
>af58	b9 c1					.word Unary_Hex            & $FFFF ; $a7 hex$(
>af5a	c8 af					.word NotImplemented       & $FFFF ; $a8 sin(
>af5c	c8 af					.word NotImplemented       & $FFFF ; $a9 cos(
>af5e	c8 af					.word NotImplemented       & $FFFF ; $aa tan(
>af60	c8 af					.word NotImplemented       & $FFFF ; $ab atn(
>af62	c8 af					.word NotImplemented       & $FFFF ; $ac exp(
>af64	c8 af					.word NotImplemented       & $FFFF ; $ad log(
>af66	c8 af					.word NotImplemented       & $FFFF ; $ae sqr(
>af68	0f c2					.word Unary_Dec            & $FFFF ; $af dec(
>af6a	b1 bf					.word Unary_Deek           & $FFFF ; $b0 deek(
>af6c	b5 bf					.word Unary_Leek           & $FFFF ; $b1 leek(
>af6e	ed bf					.word Unary_Mod            & $FFFF ; $b2 mod(
>af70	4d bf					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>af72	6e c2					.word Unary_Chr            & $FFFF ; $b4 chr$(
>af74	e1 bf					.word Unary_Pos            & $FFFF ; $b5 pos(
>af76	af c2					.word Unary_Tab            & $FFFF ; $b6 tab(
>af78	c8 af					.word NotImplemented       & $FFFF ; $b7 $
>af7a	c8 af					.word NotImplemented       & $FFFF ; $b8 $(
>af7c	c8 af					.word NotImplemented       & $FFFF ; $b9 #
>af7e	c8 af					.word NotImplemented       & $FFFF ; $ba #(
>af80	c8 af					.word NotImplemented       & $FFFF ; $bb %
>af82	c8 af					.word NotImplemented       & $FFFF ; $bc %(
>af84	c8 af					.word NotImplemented       & $FFFF ; $bd (
>af86	c8 af					.word NotImplemented       & $FFFF ; $be )
>af88	c8 af					.word NotImplemented       & $FFFF ; $bf ,
>af8a	bd b2					.word Command_COLON        & $FFFF ; $c0 :
>af8c	c8 af					.word NotImplemented       & $FFFF ; $c1 ;
>af8e	c8 af					.word NotImplemented       & $FFFF ; $c2 def
>af90	f2 ba					.word Command_CLR          & $FFFF ; $c3 clr
>af92	09 bb					.word Command_STOP         & $FFFF ; $c4 stop
>af94	18 b4					.word Command_DATA         & $FFFF ; $c5 data
>af96	f1 b3					.word Command_READ         & $FFFF ; $c6 read
>af98	5c b1					.word Command_DIM          & $FFFF ; $c7 dim
>af9a	c8 af					.word NotImplemented       & $FFFF ; $c8 to
>af9c	c8 af					.word NotImplemented       & $FFFF ; $c9 step
>af9e	31 ba					.word Command_GOSUB        & $FFFF ; $ca gosub
>afa0	41 ba					.word Command_RETURN       & $FFFF ; $cb return
>afa2	29 ba					.word Command_GOTO         & $FFFF ; $cc goto
>afa4	78 b6					.word Command_END          & $FFFF ; $cd end
>afa6	43 b5					.word Command_INPUT        & $FFFF ; $ce input
>afa8	be b4					.word Command_LET          & $FFFF ; $cf let
>afaa	e6 b6					.word Command_LIST         & $FFFF ; $d0 list
>afac	cc b9					.word Command_NEW          & $FFFF ; $d1 new
>afae	eb b9					.word Command_OLD          & $FFFF ; $d2 old
>afb0	4a ba					.word Command_ON           & $FFFF ; $d3 on
>afb2	1b b4					.word Command_RESTORE      & $FFFF ; $d4 restore
>afb4	9b b9					.word Command_POKE         & $FFFF ; $d5 poke
>afb6	eb b8					.word Command_PRINT        & $FFFF ; $d6 print
>afb8	2a b2					.word Command_RUN          & $FFFF ; $d7 run
>afba	e9 b1					.word Command_WAIT         & $FFFF ; $d8 wait
>afbc	2a b5					.word Command_SYS          & $FFFF ; $d9 sys
>afbe	9f b9					.word Command_DOKE         & $FFFF ; $da doke
>afc0	a3 b9					.word Command_LOKE         & $FFFF ; $db loke
>afc2	83 b9					.word Command_ASSERT       & $FFFF ; $dc assert
>afc4	df b4					.word Command_GET          & $FFFF ; $dd get
>afc6	da b6					.word Command_ELSE         & $FFFF ; $de else
.afc8					NotImplemented:
.afc8	20 a8 ae	jsr $aea8			jsr ERR_Handler
>afcb	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>afd3	65 6d 65 6e 74 65 64 00
.afdb					BinaryPrecedence:
>afdb	01					.byte 1    ; $80 and
>afdc	01					.byte 1    ; $81 or
>afdd	01					.byte 1    ; $82 xor
>afde	01					.byte 1    ; $83 eor
>afdf	02					.byte 2    ; $84 =
>afe0	02					.byte 2    ; $85 <>
>afe1	02					.byte 2    ; $86 <
>afe2	02					.byte 2    ; $87 <=
>afe3	02					.byte 2    ; $88 >
>afe4	02					.byte 2    ; $89 >=
>afe5	03					.byte 3    ; $8a +
>afe6	03					.byte 3    ; $8b -
>afe7	04					.byte 4    ; $8c *
>afe8	04					.byte 4    ; $8d /
>afe9	05					.byte 5    ; $8e ^
.afea					KeywordText:
>afea	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>afed	4f d2					.byte $4f,$d2                          ; $81 or
>afef	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>aff2	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>aff5	bd					.byte $bd                              ; $84 =
>aff6	3c be					.byte $3c,$be                          ; $85 <>
>aff8	bc					.byte $bc                              ; $86 <
>aff9	3c bd					.byte $3c,$bd                          ; $87 <=
>affb	be					.byte $be                              ; $88 >
>affc	3e bd					.byte $3e,$bd                          ; $89 >=
>affe	ab					.byte $ab                              ; $8a +
>afff	ad					.byte $ad                              ; $8b -
>b000	aa					.byte $aa                              ; $8c *
>b001	af					.byte $af                              ; $8d /
>b002	de					.byte $de                              ; $8e ^
>b003	49 c6					.byte $49,$c6                          ; $8f if
>b005	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>b00a	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>b010	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>b013	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>b017	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>b01c	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>b020	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>b025	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>b029	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>b02c	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>b02f	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>b033	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>b037	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>b03b	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>b040	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>b044	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>b048	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>b04e	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>b055	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>b05a	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>b05e	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>b063	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>b067	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>b06b	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>b070	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>b074	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>b078	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>b07c	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>b080	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>b084	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>b088	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>b08c	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>b090	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>b095	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>b09a	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>b09e	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>b0a2	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>b0a7	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>b0ab	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>b0af	a4					.byte $a4                              ; $b7 $
>b0b0	24 a8					.byte $24,$a8                          ; $b8 $(
>b0b2	a3					.byte $a3                              ; $b9 #
>b0b3	23 a8					.byte $23,$a8                          ; $ba #(
>b0b5	a5					.byte $a5                              ; $bb %
>b0b6	25 a8					.byte $25,$a8                          ; $bc %(
>b0b8	a8					.byte $a8                              ; $bd (
>b0b9	a9					.byte $a9                              ; $be )
>b0ba	ac					.byte $ac                              ; $bf ,
>b0bb	ba					.byte $ba                              ; $c0 :
>b0bc	bb					.byte $bb                              ; $c1 ;
>b0bd	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>b0c0	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>b0c3	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>b0c7	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>b0cb	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>b0cf	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>b0d2	54 cf					.byte $54,$cf                          ; $c8 to
>b0d4	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>b0d8	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>b0dd	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>b0e3	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>b0e7	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>b0ea	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>b0ef	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>b0f2	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>b0f6	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>b0f9	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>b0fc	4f ce					.byte $4f,$ce                          ; $d3 on
>b0fe	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>b105	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>b109	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>b10e	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>b111	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>b115	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>b118	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>b11c	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>b120	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>b126	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>b129	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>b12d	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.b12e					BASIC_Start:
.b12e	20 4a a2	jsr $a24a			jsr 	IF_Reset 					; set up and clear screen.
.b131	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.b134	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.b136	8d 10 03	sta $0310			sta 	LocalVector
.b139	8d 0c 03	sta $030c			sta 	UserVector
.b13c	a9 2e		lda #$2e			lda 	#USRDefault & $FF 			; reset USR vector to a default
.b13e	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.b141	a9 c0		lda #$c0			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.b143	8d 0e 03	sta $030e			sta 	UserVector+2
.b146	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.b148	8d 0f 03	sta $030f			sta 	UserVector+3
.b14b	20 fc c2	jsr $c2fc			jsr 	UpdateProgramEnd 			; update the program end.
.b14e	20 f2 ba	jsr $baf2			jsr 	ResetRunStatus 				; clear everything (CLR command)
.b151	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b153	9a		txs				txs
.b154	4c 2a b2	jmp $b22a			jmp 	COMMAND_Run
.b157					WarmStart:
.b157	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.b159	9a		txs				txs
.b15a	80 fb		bra $b157			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.b15c					Command_DIM:
.b15c	6b		tza				tza
.b15d	48		pha				pha 								; push on stack.
.b15e	20 85 c6	jsr $c685			jsr 	VariableExtract 			; get the identifier
.b161	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.b164	29 01		and #$01			and 	#1
.b166	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.b168	d0 71		bne $b1db			bne 	_CDIError
.b16a	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.b16c	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.b16f					_CDIGetDimension:
.b16f	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.b172	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.b174	f0 65		beq $b1db			beq 	_CDIError
.b176	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; evaluate an index size
.b179	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.b17b	29 80		and #$80			and 	#$80
.b17d	05 82		ora $82				ora 	XS_Mantissa+2
.b17f	05 83		ora $83				ora 	XS_Mantissa+3
.b181	d0 58		bne $b1db			bne 	_CDIError
.b183	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.b186	18		clc				clc 								; add 1 - max index => size.
.b187	a5 80		lda $80				lda 	XS_Mantissa+0
.b189	69 01		adc #$01			adc 	#1
.b18b	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.b18e	a5 81		lda $81				lda 	XS_Mantissa+1
.b190	69 00		adc #$00			adc 	#0
.b192	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.b195	30 44		bmi $b1db			bmi 	_CDIError 					; could be dim a(32767)
.b197	e8		inx				inx 								; bump index.
.b198	e8		inx				inx
.b199	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.b19c	ea		nop				nop
.b19d	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b19f	1b		inz				inz
.b1a0	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.b1a2	f0 cb		beq $b16f			beq 	_CDIGetDimension
.b1a4	3b		dez				dez
.b1a5	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; closing ) present ?
.b1a8	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.b1ab	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.b1ad	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.b1b0					_CDICopy:
.b1b0	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.b1b3	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.b1b6	ca		dex				dex
.b1b7	10 f7		bpl $b1b0			bpl 	_CDICopy
.b1b9	68		pla				pla									; position of array identifier
.b1ba	85 10		sta $10				sta 	zTemp1
.b1bc	6b		tza				tza
.b1bd	48		pha				pha
.b1be	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.b1c0	4b		taz				taz
.b1c1	20 85 c6	jsr $c685			jsr 	VariableExtract 			; get the identifier
.b1c4	20 20 c9	jsr $c920			jsr 	VariableLocate 				; check if it exists already.
.b1c7	b0 12		bcs $b1db			bcs 	_CDIError
.b1c9	20 13 c7	jsr $c713			jsr 	VariableCreate 				; create it using the current ArrayDef
.b1cc	68		pla				pla 								; restore code position
.b1cd	4b		taz				taz
.b1ce	ea		nop				nop
.b1cf	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b1d1	1b		inz				inz
.b1d2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.b1d4	f0 86		beq $b15c			beq 	Command_DIM
.b1d6	3b		dez				dez
.b1d7	20 22 c8	jsr $c822			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.b1da	60		rts				rts
.b1db					_CDIError:
.b1db	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b1de	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.b1e6					_CDISyntax:
.b1e6	4c 79 ae	jmp $ae79			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.b1e9					Command_WAIT:
.b1e9	20 fd bc	jsr $bcfd			jsr		EvaluateInteger 			; get address to monitor
.b1ec	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.b1ee	20 66 c3	jsr $c366			jsr 	CheckNextComma
.b1f1	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX
.b1f4	a9 00		lda #$00			lda 	#0							; set default xor value.
.b1f6	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.b1f8	ea		nop				nop
.b1f9	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b1fb	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.b1fd	d0 06		bne $b205			bne 	_CWAXorDefault
.b1ff	1b		inz				inz
.b200	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.b202	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX
.b205					_CWAXorDefault:
.b205	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.b207	85 1c		sta $1c				sta 	zLTemp1
.b209	a5 81		lda $81				lda 	XS_Mantissa+1
.b20b	85 1d		sta $1d				sta 	zLTemp1+1
.b20d	a5 82		lda $82				lda 	XS_Mantissa+2
.b20f	85 1e		sta $1e				sta 	zLTemp1+2
.b211					_CWAWaitLoop:
.b211	20 6f ae	jsr $ae6f			jsr 	VIOCheckBreak 				; exit on break.
.b214	c9 00		cmp #$00			cmp 	#0
.b216	d0 11		bne $b229			bne 	_CWAWaitExit
.b218	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.b21a	a2 00		ldx #$00			ldx 	#0
.b21c	5a		phy				phy 								; this is the same routine as PEEK.
.b21d	20 d4 c2	jsr $c2d4			jsr 	MemRead
.b220	7a		ply				ply
.b221	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.b223	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.b225	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.b227	f0 e8		beq $b211			beq 	_CWAWaitLoop 				; and loop if zero.
.b229					_CWAWaitExit:
.b229	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.b22a					Command_RUN:
.b22a	20 f2 ba	jsr $baf2			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.b22d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b22f	85 18		sta $18				sta 	zCodePtr+0
.b231	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b233	85 19		sta $19				sta 	zCodePtr+1
.b235	a9 02		lda #$02			lda 	#2
.b237	85 1a		sta $1a				sta 	zCodePtr+2
.b239	a9 00		lda #$00			lda 	#0
.b23b	85 1b		sta $1b				sta 	zCodePtr+3
.b23d	a3 03		ldz #$03			ldz 	#3
.b23f					RUN_NewLine:
.b23f	a3 00		ldz #$00			ldz 	#0
.b241	ea		nop				nop
.b242	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b244	1b		inz				inz
.b245	1b		inz				inz
.b246	1b		inz				inz
.b247	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.b249	d0 18		bne $b263			bne 	RUN_NextCommand
.b24b	4c 78 b6	jmp $b678			jmp 	Command_END 				; go do the command code.
.b24e					RUN_Skip:
.b24e	ea		nop				nop
.b24f	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b251	1b		inz				inz 								; skip
.b252	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b254	90 0d		bcc $b263			bcc 	_SEDone 					; so just skip over it.
.b256	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b258	90 08		bcc $b262			bcc 	_SEDouble
.b25a	6b		tza				tza 								; this is Y + 1
.b25b	18		clc				clc
.b25c	ea		nop				nop
.b25d	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b25f	4b		taz				taz 								; back in Y.
.b260	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b261	3b		dez				dez
.b262					_SEDouble:
.b262	1b		inz				inz
.b263					_SEDone:
.b263					RUN_NextCommand:
.b263	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.b266	69 10		adc #$10			adc 	#16 						; one time in 16
.b268	8d a8 03	sta $03a8			sta 	BreakCount
.b26b	90 0a		bcc $b277			bcc 	RUN_NoCheckBreak
.b26d	20 6f ae	jsr $ae6f			jsr 	VIOCheckBreak 				; check for break
.b270	c9 00		cmp #$00			cmp 	#0
.b272	f0 03		beq $b277			beq 	RUN_NoCheckBreak
.b274	4c 09 bb	jmp $bb09			jmp 	Command_STOP 				; stop on BREAK.
.b277					RUN_NoCheckBreak:
.b277	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.b279	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.b27b	ea		nop				nop
.b27c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b27e	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.b280	f0 cc		beq $b24e			beq 	RUN_Skip
.b282	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.b284	d0 10		bne $b296			bne 	RUN_Execute
.b286					RUN_NextLine:
.b286	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b288	ea		nop				nop
.b289	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b28b	18		clc				clc
.b28c	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b28e	85 18		sta $18				sta 	zCodePtr
.b290	90 02		bcc $b294			bcc 	_SNLNoCarry
.b292	e6 19		inc $19				inc 	zCodePtr+1
.b294					_SNLNoCarry:
.b294	80 a9		bra $b23f			bra 	RUN_NewLine 				; go do the new line code
.b296					RUN_Execute:
.b296	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.b298	b0 1c		bcs $b2b6			bcs 	RUN_Extension
.b29a	1b		inz				inz
.b29b	0a		asl a				asl 	a 							; double the character read.
.b29c	90 12		bcc $b2b0			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.b29e	aa		tax				tax 								; ready to look up.
.b29f	bd 0a af	lda $af0a,x			lda 	VectorTable,x 				; copy address into LocalVector
.b2a2	8d 11 03	sta $0311			sta 	LocalVector+1
.b2a5	bd 0b af	lda $af0b,x			lda 	VectorTable+1,x
.b2a8	8d 12 03	sta $0312			sta 	LocalVector+2
.b2ab	20 46 bc	jsr $bc46			jsr 	EVCallLocalVector 			; execute the appropriate code.
.b2ae	80 b3		bra $b263			bra 	RUN_NextCommand 			; do the next command.
.b2b0					RUN_Default:
.b2b0	3b		dez				dez
.b2b1	20 be b4	jsr $b4be			jsr 	Command_LET 				; and try LET.
.b2b4	80 ad		bra $b263			bra 	RUN_NextCommand
.b2b6					RUN_Extension:
.b2b6	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.b2b8	f0 94		beq $b24e			beq 	RUN_Skip 					; skip over it.
.b2ba	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.b2bd					Command_COLON:
.b2bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.b2be					Command_FOR:
.b2be	20 be b4	jsr $b4be			jsr 	Command_LET 				; do the A = 99 bit
.b2c1	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.b2c3	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b2c5	f0 72		beq $b339			beq 	_CFOError
.b2c7	48		pha				pha 								; save the variable type.
.b2c8	5a		phy				phy 								; save type/variable address.
.b2c9	a0 01		ldy #$01			ldy 	#1							; type at + 1
.b2cb	91 28		sta ($28),y			sta 	(zBasicSP),y
.b2cd	c8		iny				iny
.b2ce	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.b2d0	91 28		sta ($28),y			sta 	(zBasicSP),y
.b2d2	c8		iny				iny
.b2d3	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.b2d5	91 28		sta ($28),y			sta 	(zBasicSP),y
.b2d7	7a		ply				ply
.b2d8	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.b2da	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.b2dd	a9 c8		lda #$c8			lda 	#token_TO
.b2df	20 45 c3	jsr $c345			jsr 	CheckNextToken
.b2e2	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.b2e4	20 60 bb	jsr $bb60			jsr 	EvaluateExpression
.b2e7	ea		nop				nop
.b2e8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b2ea	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.b2ec	c9 c9		cmp #$c9			cmp 	#token_STEP
.b2ee	d0 06		bne $b2f6			bne 	_CFOStep1
.b2f0	1b		inz				inz
.b2f1	20 62 bb	jsr $bb62			jsr 	EvaluateExpressionX 		; get STEP value.
.b2f4	80 0e		bra $b304			bra 	_CFOHaveStep
.b2f6					_CFOStep1:
.b2f6	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.b2f8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.b2fa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.b2fc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.b2fe	a9 01		lda #$01			lda 	#1
.b300	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b302	95 85		sta $85,x			sta 	XS_Type,x
.b304					_CFOHaveStep:
.b304	68		pla				pla 								; restore variable type
.b305	a2 00		ldx #$00			ldx 	#0
.b307	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.b309	f0 0a		beq $b315			beq 	_CFOInteger
.b30b	20 29 cf	jsr $cf29			jsr 	FPUToFloat
.b30e	a2 06		ldx #$06			ldx 	#6
.b310	20 29 cf	jsr $cf29			jsr 	FPUToFloat
.b313	80 08		bra $b31d			bra 	_CFOEndConv
.b315					_CFOInteger:
.b315	20 75 cf	jsr $cf75			jsr 	FPUToInteger
.b318	a2 06		ldx #$06			ldx 	#6
.b31a	20 75 cf	jsr $cf75			jsr 	FPUToInteger
.b31d					_CFOEndConv:
.b31d	20 28 ae	jsr $ae28			jsr 	StackSavePosition 			; save the loop position at 1-5
.b320	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.b322	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push the loop address frame.
.b325	5a		phy				phy
.b326	a0 00		ldy #$00			ldy 	#0
.b328					_CFOCopy:
.b328	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.b32b	c8		iny				iny
.b32c	91 28		sta ($28),y			sta 	(zBasicSP),y
.b32e	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.b330	d0 f6		bne $b328			bne 	_CFOCopy
.b332	7a		ply				ply
.b333	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.b335	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.b338	60		rts				rts
.b339					_CFOError:
.b339	4c 89 ae	jmp $ae89			jmp 	TypeError 					; wrong type.
.b33c					Command_NEXT:
.b33c	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.b33e	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.b340	ea		nop				nop
.b341	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b343	c9 00		cmp #$00			cmp 	#0 							; EOL
.b345	f0 07		beq $b34e			beq 	_CNextNoVariable
.b347	c9 40		cmp #$40			cmp 	#$40
.b349	b0 03		bcs $b34e			bcs 	_CNextNoVariable
.b34b	20 1a c6	jsr $c61a			jsr 	VariableFind
.b34e					_CNextNoVariable:
.b34e	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.b350	48		pha				pha
.b351	a5 29		lda $29				lda 	zBasicSP+1
.b353	48		pha				pha
.b354	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.b356	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b359	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.b35b	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b35e	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.b360	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b363	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.b365	f0 11		beq $b378			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.b367	5a		phy				phy 								; check addresses match.
.b368	a0 02		ldy #$02			ldy 	#2
.b36a	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b36c	c5 24		cmp $24				cmp 	zVarDataPtr
.b36e	d0 6a		bne $b3da			bne 	_CNextWrong
.b370	c8		iny				iny
.b371	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b373	c5 25		cmp $25				cmp 	zVarDataPtr+1
.b375	d0 63		bne $b3da			bne 	_CNextWrong
.b377	7a		ply				ply
.b378					_CNextGetTarget:
.b378	5a		phy				phy
.b379	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.b37b	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b37d	85 26		sta $26				sta 	zVarType
.b37f	c8		iny				iny
.b380	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b382	85 24		sta $24				sta 	zVarDataPtr
.b384	c8		iny				iny
.b385	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b387	85 25		sta $25				sta 	zVarDataPtr+1
.b389	a2 0c		ldx #$0c			ldx 	#12
.b38b	20 64 c9	jsr $c964			jsr 	VariableGet 				; get that variable value into expr[2]
.b38e	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.b390	a0 0b		ldy #$0b			ldy 	#11
.b392					_CNXCopy:
.b392	b1 28		lda ($28),y			lda 	(zBasicSP),y
.b394	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.b396	e8		inx				inx
.b397	c8		iny				iny
.b398	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.b39a	d0 f6		bne $b392			bne 	_CNXCopy
.b39c	7a		ply				ply
.b39d	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.b39f	20 71 bf	jsr $bf71			jsr 	GetSignCurrent
.b3a2	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.b3a5	a2 06		ldx #$06			ldx 	#6 							; add them, however
.b3a7	20 50 be	jsr $be50			jsr 	BinaryOp_Add
.b3aa	20 b5 c9	jsr $c9b5			jsr 	VariableSet					; and write variable back.
.b3ad	a2 00		ldx #$00			ldx 	#0
.b3af	20 d4 bd	jsr $bdd4			jsr 	CompareValues
.b3b2	09 00		ora #$00			ora 	#0
.b3b4	f0 05		beq $b3bb			beq 	_CNXAgain 					; if true, then do it again.
.b3b6	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.b3b9	d0 0f		bne $b3ca			bne 	_CNXLoopDone
.b3bb					_CNXAgain:
.b3bb	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.b3bd	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.b3c0	20 45 ae	jsr $ae45			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.b3c3	68		pla				pla
.b3c4	85 29		sta $29				sta 	zBasicSP+1
.b3c6	68		pla				pla
.b3c7	85 28		sta $28				sta 	zBasicSP
.b3c9					_CNXExit:
.b3c9	60		rts				rts
.b3ca					_CNXLoopDone:
.b3ca	68		pla				pla 								; throw away saved to Basic Stack Pointer
.b3cb	68		pla				pla
.b3cc	ea		nop				nop
.b3cd	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b3cf	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.b3d1	d0 f6		bne $b3c9			bne 	_CNXExit
.b3d3	1b		inz				inz
.b3d4	20 1a c6	jsr $c61a			jsr 	VariableFind 				; identify the variable
.b3d7	4c 4e b3	jmp $b34e			jmp 	_CNextNoVariable 			; go back with variable pre-found
.b3da					_CNextWrong:
.b3da	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b3dd	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>b3e5	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.b3f1					Command_READ:
.b3f1	20 1a c6	jsr $c61a			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.b3f4	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.b3f6	48		pha				pha
.b3f7	a5 25		lda $25				lda 	zVarDataPtr+1
.b3f9	48		pha				pha
.b3fa	a5 26		lda $26				lda 	zVarType
.b3fc	48		pha				pha
.b3fd	20 44 b4	jsr $b444			jsr 	READGetDataItem 			; get the next data item
.b400	68		pla				pla 								; restore target variable information.
.b401	85 26		sta $26				sta 	zVarType
.b403	68		pla				pla
.b404	85 25		sta $25				sta 	zVarDataPtr+1
.b406	68		pla				pla
.b407	85 24		sta $24				sta 	zVarDataPtr
.b409	a2 00		ldx #$00			ldx 	#0
.b40b	20 b5 c9	jsr $c9b5			jsr 	VariableSet 				; set the value out.
.b40e	ea		nop				nop
.b40f	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b411	1b		inz				inz
.b412	c9 bf		cmp #$bf			cmp 	#token_Comma
.b414	f0 db		beq $b3f1			beq 	Command_READ 				; found, do another READ
.b416	3b		dez				dez
.b417	60		rts				rts
.b418					Command_DATA:
.b418	4c ac ad	jmp $adac			jmp 	SkipEndOfCommand
.b41b					Command_RESTORE:
.b41b	48		pha				pha
.b41c	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.b41e	8d bd 03	sta $03bd			sta 	DataLPtr+0
.b421	8d be 03	sta $03be			sta 	DataLPtr+1
.b424	68		pla				pla
.b425	60		rts				rts
.b426					READSwapPointers:
.b426	6b		tza				tza
.b427	48		pha				pha 								; save it
.b428	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.b42b	4b		taz				taz
.b42c	68		pla				pla 								; get code offset and save in DataIndex
.b42d	8d c1 03	sta $03c1			sta 	DataIndex
.b430	da		phx				phx
.b431	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.b433					_RSWLoop:
.b433	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.b436	48		pha				pha
.b437	b5 18		lda $18,x			lda 	zCodePtr+0,x
.b439	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.b43c	68		pla				pla
.b43d	95 18		sta $18,x			sta 	zCodePtr+0,x
.b43f	ca		dex				dex
.b440	10 f1		bpl $b433			bpl 	_RSWLoop
.b442	fa		plx				plx
.b443	60		rts				rts
.b444					READGetDataItem:
.b444	20 26 b4	jsr $b426			jsr 	ReadSwapPointers 			; swap code and data pointer.
.b447	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.b449	05 19		ora $19				ora 	zCodePtr+1
.b44b	d0 14		bne $b461			bne 	_RGDIIsInitialised
.b44d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b44f	85 18		sta $18				sta 	zCodePtr+0
.b451	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b453	85 19		sta $19				sta 	zCodePtr+1
.b455	a9 02		lda #$02			lda 	#2
.b457	85 1a		sta $1a				sta 	zCodePtr+2
.b459	a9 00		lda #$00			lda 	#0
.b45b	85 1b		sta $1b				sta 	zCodePtr+3
.b45d	a3 03		ldz #$03			ldz 	#3
.b45f	80 07		bra $b468			bra 	_RGDIFindData 				; locate next data from start and read that.
.b461					_RGDIIsInitialised:
.b461	ea		nop				nop
.b462	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b464	c9 bf		cmp #$bf			cmp 	#token_Comma
.b466	f0 4e		beq $b4b6			beq 	_RGDISkipEvaluateExit
.b468					_RGDIFindData:
.b468	ea		nop				nop
.b469	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b46b	c9 00		cmp #$00			cmp 	#0 							; end of line
.b46d	f0 1b		beq $b48a			beq 	_RGDIFindNextLine
.b46f	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.b471	f0 43		beq $b4b6			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.b473	ea		nop				nop
.b474	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b476	1b		inz				inz 								; skip
.b477	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b479	90 0d		bcc $b488			bcc 	_SEDone 					; so just skip over it.
.b47b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b47d	90 08		bcc $b487			bcc 	_SEDouble
.b47f	6b		tza				tza 								; this is Y + 1
.b480	18		clc				clc
.b481	ea		nop				nop
.b482	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b484	4b		taz				taz 								; back in Y.
.b485	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b486	3b		dez				dez
.b487					_SEDouble:
.b487	1b		inz				inz
.b488					_SEDone:
.b488	80 de		bra $b468			bra 	_RGDIFindData
.b48a					_RGDIFindNextLine:
.b48a	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b48c	ea		nop				nop
.b48d	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b48f	18		clc				clc
.b490	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b492	85 18		sta $18				sta 	zCodePtr
.b494	90 02		bcc $b498			bcc 	_SNLNoCarry
.b496	e6 19		inc $19				inc 	zCodePtr+1
.b498					_SNLNoCarry:
.b498	a3 00		ldz #$00			ldz 	#0
.b49a	ea		nop				nop
.b49b	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b49d	48		pha				pha
.b49e	1b		inz				inz
.b49f	1b		inz				inz
.b4a0	1b		inz				inz
.b4a1	68		pla				pla
.b4a2	d0 c4		bne $b468			bne 	_RGDIFindData 				; back to scanning.
.b4a4	20 26 b4	jsr $b426			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.b4a7	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b4aa	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>b4b2	61 74 61 00
.b4b6					_RGDISkipEvaluateExit:
.b4b6	1b		inz				inz
.b4b7	20 60 bb	jsr $bb60			jsr 	EvaluateExpression 			; evaluate the expression
.b4ba	20 26 b4	jsr $b426			jsr 	ReadSwapPointers 			; swap the pointers around.
.b4bd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.b4be					Command_LET:
.b4be	20 1a c6	jsr $c61a			jsr 	VariableFind 				; get reference to one variable.
.b4c1	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.b4c3	20 45 c3	jsr $c345			jsr 	CheckNextToken
.b4c6	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.b4c8	48		pha				pha
.b4c9	a5 25		lda $25				lda 	zVarDataPtr+1
.b4cb	48		pha				pha
.b4cc	a5 26		lda $26				lda 	zVarType
.b4ce	48		pha				pha
.b4cf	20 60 bb	jsr $bb60			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.b4d2	68		pla				pla 								; restore target variable information.
.b4d3	85 26		sta $26				sta 	zVarType
.b4d5	68		pla				pla
.b4d6	85 25		sta $25				sta 	zVarDataPtr+1
.b4d8	68		pla				pla
.b4d9	85 24		sta $24				sta 	zVarDataPtr
.b4db	20 b5 c9	jsr $c9b5			jsr 	VariableSet 				; set the value out.
.b4de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.b4df					Command_GET:
.b4df					_CGLoop:
.b4df	20 1a c6	jsr $c61a			jsr 	VariableFind 				; get a variable.
.b4e2	20 64 ae	jsr $ae64			jsr 	VIOCharGet 					; get character
.b4e5	b0 02		bcs $b4e9			bcs 	_CGNoKey
.b4e7	a9 00		lda #$00			lda 	#0 							; if no character return zero
.b4e9					_CGNoKey:
.b4e9	48		pha				pha
.b4ea	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.b4ec	c9 b7		cmp #$b7			cmp 	#token_Dollar
.b4ee	f0 1f		beq $b50f			beq 	_CGString
.b4f0	68		pla				pla 								; put character in slot.
.b4f1	85 80		sta $80				sta 	XS_Mantissa
.b4f3	a9 00		lda #$00			lda 	#0
.b4f5	85 81		sta $81				sta 	XS_Mantissa+1
.b4f7	85 82		sta $82				sta 	XS_Mantissa+2
.b4f9	85 83		sta $83				sta 	XS_Mantissa+3
.b4fb	a9 01		lda #$01			lda 	#1 							; type integer
.b4fd	85 85		sta $85				sta 	XS_Type
.b4ff					_CGWriteSetNext:
.b4ff	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.b501	20 b5 c9	jsr $c9b5			jsr 	VariableSet
.b504	ea		nop				nop
.b505	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b507	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.b509	d0 03		bne $b50e			bne 	_CGExit
.b50b	1b		inz				inz
.b50c	80 d1		bra $b4df			bra 	_CGLoop 					; and get another.
.b50e					_CGExit:
.b50e	60		rts				rts
.b50f					_CGString:
.b50f	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.b511	20 ac c3	jsr $c3ac			jsr 	AllocateTempString 			; initially empty.
.b514	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.b516	85 80		sta $80				sta 	XS_Mantissa
.b518	a5 23		lda $23				lda 	zTempStr+1
.b51a	85 81		sta $81				sta 	XS_Mantissa+1
.b51c	a9 02		lda #$02			lda 	#2
.b51e	85 85		sta $85				sta 	XS_Type
.b520	68		pla				pla 								; get A
.b521	c9 00		cmp #$00			cmp 	#0
.b523	f0 da		beq $b4ff			beq 	_CGWriteSetNext
.b525	20 d7 c3	jsr $c3d7			jsr 	WriteTempString 			; write it into string
.b528	80 d5		bra $b4ff			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.b52a					Command_SYS:
.b52a	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; address to call.
.b52d	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.b52f	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.b532	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.b534	8d 11 03	sta $0311			sta 	LocalVector+1
.b537	a5 82		lda $82				lda 	XS_Mantissa+2
.b539	8d 12 03	sta $0312			sta 	LocalVector+2
.b53c	20 40 b5	jsr $b540			jsr 	_CSYLocalCall
.b53f	60		rts				rts
.b540					_CSYLocalCall:
.b540	6c 10 03	jmp ($0310)			jmp 	(LocalVector)

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.b543					Command_INPUT:
.b543	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.b545	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.b548	8d c3 03	sta $03c3		sta 	InputRetry
.b54b					_CILoop:
.b54b	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.b54d	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.b54f	ea		nop				nop
.b550	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b552	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.b554	d0 17		bne $b56d		bne 	_CINoPrompt
.b556	1b		inz				inz
.b557	ea		nop				nop
.b558	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b55a	aa		tax			tax 									; into X
.b55b	1b		inz				inz
.b55c	ca		dex			dex 									; deduct marker/prompt length
.b55d	ca		dex			dex
.b55e	f0 eb		beq $b54b		beq 	_CILoop 						; nothing.
.b560					_CIShowPrompt:
.b560	ea		nop				nop
.b561	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b563	20 61 ae	jsr $ae61		jsr 	VIOCharPrint
.b566	1b		inz				inz
.b567	ca		dex			dex
.b568	d0 f6		bne $b560		bne 	_CIShowPrompt
.b56a	80 df		bra $b54b		bra 	_CILoop
.b56c					_CIAdvance:
.b56c	1b		inz				inz
.b56d					_CINoPrompt:
.b56d	ea		nop				nop
.b56e	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b570	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.b572	f0 f8		beq $b56c		beq 	_CIAdvance
.b574	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.b576	f0 f4		beq $b56c		beq 	_CIAdvance
.b578	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.b57a	f0 04		beq $b580		beq 	_CIExit
.b57c	c9 c0		cmp #$c0		cmp 	#token_Colon
.b57e	d0 01		bne $b581		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.b580					_CIExit:
.b580	60		rts			rts
.b581					_CIIsVariable:
.b581	20 1a c6	jsr $c61a		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.b584	a5 26		lda $26			lda 	zVarType
.b586	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.b588	f0 40		beq $b5ca		beq 	_CIIsString
.b58a					_CINGetText:
.b58a	a9 00		lda #$00		lda 	#0
.b58c	8d 14 03	sta $0314		sta 	NumBufX
.b58f					_CINSkip:
.b58f	20 29 b6	jsr $b629		jsr 	CIGetCharacter 					; get character skip spaces
.b592	c9 20		cmp #$20		cmp 	#" "
.b594	f0 f9		beq $b58f		beq 	_CINSkip
.b596	c9 2c		cmp #$2c		cmp 	#","
.b598	f0 f5		beq $b58f		beq 	_CINSkip
.b59a					_CINLoop:
.b59a	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.b59d	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.b5a0	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.b5a2	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.b5a5	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.b5a8	20 29 b6	jsr $b629		jsr 	CIGetCharacter 					; get next character
.b5ab	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.b5ad	f0 08		beq $b5b7		beq 	_CINCopied
.b5af	c9 2c		cmp #$2c		cmp 	#","
.b5b1	f0 04		beq $b5b7		beq 	_CINCopied
.b5b3	c9 21		cmp #$21		cmp 	#" "+1
.b5b5	b0 e3		bcs $b59a		bcs 	_CINLoop
.b5b7					_CINCopied:
.b5b7	a2 00		ldx #$00		ldx 	#0
.b5b9	20 7f c0	jsr $c07f		jsr 	ConvertNumBuffer 				; convert number
.b5bc	b0 05		bcs $b5c3		bcs 	_CINFailed 						; didn't work.
.b5be	20 b5 c9	jsr $c9b5		jsr 	VariableSet 					; set variable.
.b5c1	80 88		bra $b54b		bra 	_CILoop 						; go round again.
.b5c3					_CINFailed:
.b5c3	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.b5c5	8d c2 03	sta $03c2		sta 	InputAvailable
.b5c8	80 c0		bra $b58a		bra 	_CINGetText 					; and try again
.b5ca					_CIIsString:
.b5ca	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.b5cc	20 ac c3	jsr $c3ac		jsr 	AllocateTempString
.b5cf	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.b5d1	8d 14 03	sta $0314		sta 	NumBufX
.b5d4					_CISSkip:
.b5d4	20 29 b6	jsr $b629		jsr 	CIGetCharacter 					; get character skip spaces
.b5d7	c9 20		cmp #$20		cmp 	#" "
.b5d9	f0 f9		beq $b5d4		beq 	_CISSkip
.b5db	80 03		bra $b5e0		bra 	_CISInputProcess 				; handle that as the first character
.b5dd					_CISInput:
.b5dd	20 29 b6	jsr $b629		jsr 	CIGetCharacter
.b5e0					_CISInputProcess:
.b5e0	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.b5e2	f0 31		beq $b615		beq 	_CISDone
.b5e4	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.b5e6	d0 05		bne $b5ed		bne 	_CISNotColon
.b5e8	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.b5eb	10 28		bpl $b615		bpl 	_CISDone 						; if quote flag zero, done
.b5ed					_CISNotColon:
.b5ed	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.b5ef	f0 1a		beq $b60b		beq 	_CISIsQuote						; if so handle that code.
.b5f1	20 d7 c3	jsr $c3d7		jsr 	WriteTempString 				; write to the temporary string
.b5f4	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.b5f7	10 e4		bpl $b5dd		bpl 	_CISInput
.b5f9	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b5fc	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>b604	6f 20 6c 6f 6e 67 00
.b60b					_CISIsQuote:
.b60b	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.b60e	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.b610	8d 14 03	sta $0314		sta 	NumBufX
.b613	d0 c8		bne $b5dd		bne 	_CISInput 						; if entered quote mode, get next character
.b615					_CISDone:
.b615	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.b617	85 80		sta $80			sta 	XS_Mantissa+0
.b619	a5 23		lda $23			lda 	zTempStr+1
.b61b	85 81		sta $81			sta 	XS_Mantissa+1
.b61d	a9 02		lda #$02		lda 	#2
.b61f	85 85		sta $85			sta 	XS_Type
.b621	a2 00		ldx #$00		ldx 	#0
.b623	20 b5 c9	jsr $c9b5		jsr 	VariableSet 					; set variable.
.b626	4c 4b b5	jmp $b54b		jmp 	_CILoop 						; and try again
.b629					CIGetCharacter:
.b629	5a		phy			phy
.b62a	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.b62d	f0 0c		beq $b63b		beq 	_CIGCNewLine 					; no, needs a new line.
.b62f	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.b632	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.b634	f0 03		beq $b639		beq 	_CIGCNoInc
.b636	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.b639					_CIGCNoInc:
.b639	7a		ply			ply
.b63a	60		rts			rts
.b63b					_CIGCNewLine:
.b63b	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.b63e	a9 3f		lda #$3f		lda 	#"?"
.b640	20 61 ae	jsr $ae61		jsr 	VIOCharPrint
.b643	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.b646	f0 03		beq $b64b		beq 	_CIGCPrompt 					; if so, then print ? again
.b648	20 61 ae	jsr $ae61		jsr 	VIOCharPrint
.b64b					_CIGCPrompt:
.b64b	a0 01		ldy #$01		ldy 	#1
.b64d	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.b650					_CIGCBackOne:
.b650	88		dey			dey
.b651					_CIGCLoop:
.b651	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.b653	f0 fb		beq $b650		beq 	_CIGCBackOne
.b655	20 64 ae	jsr $ae64		jsr 	VIOCharGet 						; get a character
.b658	f0 f7		beq $b651		beq 	_CIGCLoop 						; wait until key pressed
.b65a	c9 08		cmp #$08		cmp 	#8 								; backspace
.b65c	f0 10		beq $b66e		beq 	_CIGCBackSpace
.b65e	20 61 ae	jsr $ae61		jsr 	VIOCharPrint 					; echo character
.b661	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.b664	c8		iny			iny
.b665	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.b667	d0 e8		bne $b651		bne 	_CIGCLoop
.b669	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.b66c	7a		ply			ply 									; restore Y
.b66d	60		rts			rts
.b66e					_CIGCBackSpace:
.b66e	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.b670	f0 df		beq $b651		beq 	_CIGCLoop
.b672	20 61 ae	jsr $ae61		jsr 	VIOCharPrint 					; echo BS
.b675	88		dey			dey 									; go back one.
.b676	80 d9		bra $b651		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.b678					Command_END:
.b678	80 fe		bra $b678	_halt:	bra 		_halt
.b67a	4c 57 b1	jmp $b157			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.b67d					Command_IF:
.b67d	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; check success.
.b680	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.b682	05 81		ora $81				ora 	XS_Mantissa+1
.b684	05 82		ora $82				ora 	XS_Mantissa+2
.b686	05 83		ora $83				ora 	XS_Mantissa+3
.b688	aa		tax				tax 								; put into X.
.b689	ea		nop				nop
.b68a	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b68c	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.b68e	d0 30		bne $b6c0			bne 	_FIFExtended
.b690	1b		inz				inz
.b691	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.b693	f0 0c		beq $b6a1			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.b695	ea		nop				nop
.b696	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b698	29 c0		and #$c0			and 	#$C0 						; is it a number
.b69a	c9 40		cmp #$40			cmp 	#$40
.b69c	d0 21		bne $b6bf			bne 	_FIFContinue 				; if not, do what ever follows.
.b69e	4c 29 ba	jmp $ba29			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.b6a1					_FIFEndOfLine:
.b6a1	ea		nop				nop
.b6a2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b6a4	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.b6a6	f0 17		beq $b6bf			beq 	_FIFContinue
.b6a8	ea		nop				nop
.b6a9	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b6ab	1b		inz				inz 								; skip
.b6ac	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b6ae	90 0d		bcc $b6bd			bcc 	_SEDone 					; so just skip over it.
.b6b0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b6b2	90 08		bcc $b6bc			bcc 	_SEDouble
.b6b4	6b		tza				tza 								; this is Y + 1
.b6b5	18		clc				clc
.b6b6	ea		nop				nop
.b6b7	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b6b9	4b		taz				taz 								; back in Y.
.b6ba	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b6bb	3b		dez				dez
.b6bc					_SEDouble:
.b6bc	1b		inz				inz
.b6bd					_SEDone:
.b6bd	80 e2		bra $b6a1			bra 	_FIFEndOfLine
.b6bf					_FIFContinue:
.b6bf	60		rts				rts
.b6c0					_FIFExtended:
.b6c0	da		phx				phx 								; save result
.b6c1	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.b6c3	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.b6c6	68		pla				pla 								; restore result
.b6c7	f0 01		beq $b6ca			beq 	_FIXSkip 					; if zero then it has failed.
.b6c9	60		rts				rts 								; test passed, so continue executing
.b6ca					_FIXSkip:
.b6ca	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.b6cc	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.b6ce	20 1c ad	jsr $ad1c			jsr 	StructureSearchDouble
.b6d1	ea		nop				nop
.b6d2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b6d4	1b		inz				inz
.b6d5	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.b6d7	f0 07		beq $b6e0			beq 	Command_ENDIF
.b6d9	60		rts				rts
.b6da					Command_ELSE:
.b6da	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.b6dc	20 1a ad	jsr $ad1a			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.b6df	1b		inz				inz
.b6e0					Command_ENDIF:
.b6e0	a9 40		lda #$40			lda 	#(SMark_If << 4)
.b6e2	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.b6e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.b6e6					Command_LIST:
.b6e6	20 7f b8	jsr $b87f			jsr 	ListGetRange				; get any parameters
.b6e9	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b6eb	85 18		sta $18				sta 	zCodePtr+0
.b6ed	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b6ef	85 19		sta $19				sta 	zCodePtr+1
.b6f1	a9 02		lda #$02			lda 	#2
.b6f3	85 1a		sta $1a				sta 	zCodePtr+2
.b6f5	a9 00		lda #$00			lda 	#0
.b6f7	85 1b		sta $1b				sta 	zCodePtr+3
.b6f9	a3 03		ldz #$03			ldz 	#3
.b6fb	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.b6fd	8d bc 03	sta $03bc			sta 	LastListIndent
.b700	8d bb 03	sta $03bb			sta 	ListIndent
.b703					_CILLoop:
.b703	a3 00		ldz #$00			ldz 	#0
.b705	ea		nop				nop
.b706	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b708	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.b70a	f0 24		beq $b730			beq 	_CILExit
.b70c	20 6f ae	jsr $ae6f			jsr 	VIOCheckBreak 				; check break
.b70f	c9 00		cmp #$00			cmp 	#0
.b711	d0 1d		bne $b730			bne 	_CILExit
.b713	20 c9 b8	jsr $b8c9			jsr 	ListCheckRange 				; check current line in range.
.b716	b0 08		bcs $b720			bcs		_CILNext
.b718	a3 00		ldz #$00			ldz 	#0
.b71a	1b		inz				inz
.b71b	1b		inz				inz
.b71c	1b		inz				inz
.b71d	20 33 b7	jsr $b733			jsr 	ListLine 					; list one line.
.b720					_CILNext:
.b720	a3 00		ldz #$00			ldz 	#0 							; point to offset
.b722	ea		nop				nop
.b723	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.b725	18		clc				clc
.b726	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.b728	85 18		sta $18				sta 	zCodePtr
.b72a	90 02		bcc $b72e			bcc 	_SNLNoCarry
.b72c	e6 19		inc $19				inc 	zCodePtr+1
.b72e					_SNLNoCarry:
.b72e	80 d3		bra $b703			bra 	_CILLoop
.b730					_CILExit:
.b730	4c 57 b1	jmp $b157			jmp 	WarmStart
.b733					ListLine:
.b733	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.b736	8d bc 03	sta $03bc			sta 	LastListIndent
.b739					_LICountIndent:
.b739	ea		nop				nop
.b73a	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b73c	c9 00		cmp #$00			cmp 	#0
.b73e	f0 31		beq $b771			beq 	_LIDoneIndent
.b740	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.b742	90 16		bcc $b75a			bcc 	_LICINext
.b744	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b746	b0 12		bcs $b75a			bcs 	_LICINext
.b748	ee bb 03	inc $03bb			inc 	ListIndent
.b74b	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.b74d	90 0b		bcc $b75a			bcc 	_LICINext
.b74f	ce bb 03	dec $03bb			dec 	ListIndent
.b752	ce bb 03	dec $03bb			dec 	ListIndent
.b755	10 03		bpl $b75a			bpl 	_LICINext
.b757	ee bb 03	inc $03bb			inc 	ListIndent
.b75a					_LICINext:
.b75a	ea		nop				nop
.b75b	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read element
.b75d	1b		inz				inz 								; skip
.b75e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.b760	90 0d		bcc $b76f			bcc 	_SEDone 					; so just skip over it.
.b762	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.b764	90 08		bcc $b76e			bcc 	_SEDouble
.b766	6b		tza				tza 								; this is Y + 1
.b767	18		clc				clc
.b768	ea		nop				nop
.b769	72 18		adc ($18),z			adc 	(zCodePtr),z 				; add total length of element
.b76b	4b		taz				taz 								; back in Y.
.b76c	3b		dez				dez 								; fix up, one for the +1, one for the iny
.b76d	3b		dez				dez
.b76e					_SEDouble:
.b76e	1b		inz				inz
.b76f					_SEDone:
.b76f	80 c8		bra $b739			bra 	_LICountIndent
.b771					_LIDoneIndent:
.b771	a3 00		ldz #$00			ldz 	#0
.b773	1b		inz				inz
.b774	ea		nop				nop
.b775	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b777	85 80		sta $80				sta 	XS_Mantissa
.b779	1b		inz				inz
.b77a	ea		nop				nop
.b77b	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b77d	85 81		sta $81				sta 	XS_Mantissa+1
.b77f	20 ec ae	jsr $aeec			jsr 	Print16BitInteger 			; print integer.
.b782	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.b784	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.b787	cd bc 03	cmp $03bc			cmp 	LastListIndent
.b78a	90 03		bcc $b78f			bcc 	_LISmaller
.b78c	ad bc 03	lda $03bc			lda 	LastListIndent
.b78f					_LISmaller:
.b78f	0a		asl a				asl 	a 							; double indent
.b790	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.b792	38		sec				sec
.b793	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.b795	aa		tax				tax 								; print spaces to column 6
.b796					_LISpace:
.b796	a9 20		lda #$20			lda 	#" "
.b798	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b79b	e8		inx				inx
.b79c	e0 06		cpx #$06			cpx 	#6
.b79e	d0 f6		bne $b796			bne 	_LISpace
.b7a0					_LIDecode:
.b7a0	1b		inz				inz
.b7a1	ea		nop				nop
.b7a2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7a4	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.b7a6	f0 0f		beq $b7b7			beq 	_LIExit
.b7a8	30 12		bmi $b7bc			bmi 	_LIToken
.b7aa	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.b7ac	b0 52		bcs $b800			bcs 	_LIInteger
.b7ae	49 20		eor #$20			eor 	#$20 						; make 7 bit
.b7b0	69 20		adc #$20			adc 	#$20
.b7b2	20 6f b8	jsr $b86f			jsr 	ListPrintLC 				; print in LC
.b7b5	80 e9		bra $b7a0			bra 	_LIDecode
.b7b7					_LIExit:
.b7b7	a9 0d		lda #$0d			lda 	#13 						; print new line.
.b7b9	4c 6f b8	jmp $b86f			jmp 	ListPrintLC
.b7bc					_LIToken:
.b7bc	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.b7be	90 4b		bcc $b80b			bcc		_LICommandToken
.b7c0	48		pha				pha 								; save in case end
.b7c1	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.b7c3	c9 fe		cmp #$fe			cmp 	#$FE
.b7c5	f0 17		beq $b7de			beq 	_LIPrint
.b7c7	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.b7c9	c9 fd		cmp #$fd			cmp 	#$FD
.b7cb	f0 11		beq $b7de			beq 	_LIPrint
.b7cd	a9 52		lda #$52			lda 	#'R'						; must be REM
.b7cf	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b7d2	a9 45		lda #$45			lda 	#'E'
.b7d4	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b7d7	a9 4d		lda #$4d			lda 	#'M'
.b7d9	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b7dc	a2 20		ldx #$20			ldx 	#' '
.b7de					_LIPrint:
.b7de	8a		txa				txa
.b7df	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b7e2	1b		inz				inz
.b7e3	ea		nop				nop
.b7e4	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7e6	aa		tax				tax 								; put in X
.b7e7	ca		dex				dex
.b7e8					_LILoop:
.b7e8	ca		dex				dex 								; exit when count reached zero.
.b7e9	f0 09		beq $b7f4			beq 	_LIEnd
.b7eb	1b		inz				inz
.b7ec	ea		nop				nop
.b7ed	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b7ef	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b7f2	80 f4		bra $b7e8			bra 	_LILoop
.b7f4	68		pla		_LIEnd:	pla 								; get A back
.b7f5	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.b7f7	d0 a7		bne $b7a0			bne 	_LIDecode
.b7f9	a9 22		lda #$22			lda 	#'"'
.b7fb	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b7fe	80 a0		bra $b7a0			bra 	_LIDecode
.b800					_LIInteger:
.b800	a2 00		ldx #$00			ldx 	#0
.b802	20 6b bc	jsr $bc6b			jsr 	EvaluateGetInteger 			; get an atom
.b805	3b		dez				dez
.b806	20 f2 ae	jsr $aef2			jsr 	Print32BitInteger 			; print integer.
.b809	80 95		bra $b7a0			bra 	_LIDecode
.b80b					_LICommandToken:
.b80b	5a		phy				phy 								; save Y
.b80c	48		pha				pha 								; save token
.b80d	a2 ea		ldx #$ea			ldx  	#KeywordText & $FF 			; address of keyword text table.
.b80f	a9 af		lda #$af			lda 	(#KeywordText >> 8) & $FF
.b811	86 1c		stx $1c				stx 	zLTemp1
.b813	85 1d		sta $1d				sta 	zLTemp1+1
.b815	a9 00		lda #$00			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.b817	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.b819	68		pla				pla 								; get token
.b81a	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.b81c	f0 16		beq $b834			beq 	_LIFoundToken
.b81e	aa		tax				tax
.b81f					_LITokenLoop:
.b81f	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.b821					_LIFindEnd:
.b821	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.b823	c8		iny				iny
.b824	0a		asl a				asl 	a
.b825	90 fa		bcc $b821			bcc 	_LIFindEnd
.b827	98		tya				tya 								; that is step to the next
.b828	18		clc				clc 								; we don't bother bumping the 3rd byte
.b829	65 1c		adc $1c				adc 	zLTemp1 					; here.
.b82b	85 1c		sta $1c				sta 	zLTemp1
.b82d	90 02		bcc $b831			bcc 	_LINoBump
.b82f	e6 1d		inc $1d				inc 	zLTemp1+1
.b831					_LINoBump:
.b831	ca		dex				dex 								; no go round again.
.b832	d0 eb		bne $b81f			bne 	_LITokenLoop
.b834					_LIFoundToken:
.b834	a0 00		ldy #$00			ldy 	#0
.b836					_LIPrintToken:
.b836	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.b838	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.b83a	d0 16		bne $b852			bne 	_LINoPrefixSpace
.b83c	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.b83e	90 12		bcc $b852			bcc 	_LINoPrefixSpace
.b840	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b842	b0 0e		bcs $b852			bcs 	_LINoPrefixSpace
.b844	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.b847	e0 20		cpx #$20			cpx 	#" "
.b849	f0 07		beq $b852			beq 	_LINoPrefixSpace
.b84b	48		pha				pha
.b84c	a9 20		lda #$20			lda 	#" "
.b84e	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b851	68		pla				pla
.b852					_LINoPrefixSpace:
.b852	c8		iny				iny
.b853	48		pha				pha 								; save it
.b854	29 7f		and #$7f			and 	#$7F
.b856	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b859	68		pla				pla
.b85a	10 da		bpl $b836			bpl 	_LIPrintToken 				; go back if not end
.b85c	7a		ply				ply 								; restore Y
.b85d	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.b85f	c9 41		cmp #$41			cmp 	#"A"
.b861	90 09		bcc $b86c			bcc 	_LINotLetter2
.b863	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b865	b0 05		bcs $b86c			bcs 	_LINotLetter2
.b867	a9 20		lda #$20			lda 	#" " 						; add spacing
.b869	20 6f b8	jsr $b86f			jsr 	ListPrintLC
.b86c					_LINotLetter2:
.b86c	4c a0 b7	jmp $b7a0			jmp 	_LIDecode
.b86f					ListPrintLC:
.b86f	8d ba 03	sta $03ba			sta 	LastPrinted
.b872	c9 41		cmp #$41			cmp 	#"A"
.b874	90 06		bcc $b87c			bcc 	_LPLC0
.b876	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b878	b0 02		bcs $b87c			bcs 	_LPLC0
.b87a	69 20		adc #$20			adc 	#$20
.b87c	4c 61 ae	jmp $ae61	_LPLC0:	jmp 	VIOCharPrint
.b87f					ListGetRange:
.b87f	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.b881					_LGRClear:
.b881	a9 00		lda #$00			lda 	#0
.b883	95 80		sta $80,x			sta 	XS_Mantissa,x
.b885	ca		dex				dex
.b886	10 f9		bpl $b881			bpl 	_LGRClear
.b888	ea		nop				nop
.b889	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b88b	c9 00		cmp #$00			cmp 	#0 							; nothing
.b88d	f0 22		beq $b8b1			beq 	_LGRBlank
.b88f	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.b891	f0 1e		beq $b8b1			beq 	_LGRBlank
.b893	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.b895	f0 19		beq $b8b0			beq 	_LGREnd 					; then it's LIST ,x
.b897	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; get the first number into bottom
.b89a	ea		nop				nop
.b89b	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b89d	c9 bf		cmp #$bf			cmp 	#token_Comma
.b89f	f0 0f		beq $b8b0			beq 	_LGREnd 					; then it is LIST a,b
.b8a1	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.b8a3	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.b8a5	a5 81		lda $81				lda 	XS_Mantissa+1
.b8a7	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b8a9					_LGRBumpExit:
.b8a9	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.b8ab	d0 02		bne $b8af			bne 	_LGRBump2
.b8ad	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.b8af					_LGRBump2:
.b8af	60		rts				rts
.b8b0					_LGREnd:
.b8b0	1b		inz				inz
.b8b1					_LGRBlank:
.b8b1	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.b8b3	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.b8b5	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.b8b7	ea		nop				nop
.b8b8	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b8ba	c9 00		cmp #$00			cmp 	#0
.b8bc	f0 f1		beq $b8af			beq 	_LGRBump2
.b8be	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.b8bf	b0 ee		bcs $b8af			bcs 	_LGRBump2
.b8c1	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.b8c3	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX
.b8c6	80 e1		bra $b8a9			bra 	_LGRBumpExit
.b8c8	60		rts				rts
.b8c9					ListCheckRange:
.b8c9	1b		inz				inz
.b8ca	a2 00		ldx #$00			ldx 	#0 							; test low
.b8cc	20 d9 b8	jsr $b8d9			jsr 	_LCRCompare
.b8cf	90 06		bcc $b8d7			bcc 	_LCRFail
.b8d1	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.b8d3	20 d9 b8	jsr $b8d9			jsr 	_LCRCompare
.b8d6	60		rts				rts
.b8d7					_LCRFail:
.b8d7	38		sec				sec
.b8d8	60		rts				rts
.b8d9					_LCRCompare:
.b8d9	ea		nop				nop
.b8da	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b8dc	38		sec				sec
.b8dd	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.b8df	08		php				php
.b8e0	1b		inz				inz
.b8e1	ea		nop				nop
.b8e2	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b8e4	28		plp				plp
.b8e5	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.b8e7	08		php				php
.b8e8	3b		dez				dez
.b8e9	28		plp				plp
.b8ea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.b8eb					Command_PRINT:
.b8eb					_CPR_Loop:
.b8eb	ea		nop				nop
.b8ec	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b8ee	c9 00		cmp #$00			cmp 	#0 							; end
.b8f0	f0 24		beq $b916			beq 	_CPR_GoNewLine
.b8f2	c9 c0		cmp #$c0			cmp 	#token_Colon
.b8f4	f0 20		beq $b916			beq 	_CPR_GoNewLine
.b8f6	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.b8f8	f0 74		beq $b96e			beq 	_CPR_Skip
.b8fa	c9 bf		cmp #$bf			cmp 	#token_Comma
.b8fc	f0 57		beq $b955			beq 	_CPR_Tab
.b8fe	20 60 bb	jsr $bb60			jsr 	EvaluateExpression 			; get expression.
.b901	a5 85		lda $85				lda 	XS_Type 					; get type.
.b903	29 02		and #$02			and 	#2
.b905	d0 27		bne $b92e			bne 	_CPR_String 				; if type = 2 output as string.
.b907					_CPR_Number:
.b907	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b909	8d 14 03	sta $0314			sta 	NumBufX
.b90c	a5 85		lda $85				lda 	XS_Type 					; get type
.b90e	4a		lsr a				lsr 	a
.b90f	b0 08		bcs $b919			bcs 	_CPRInt 					; if msb set do as integer
.b911	20 74 d0	jsr $d074			jsr 	FPToString 					; call fp to str otherwise
.b914	80 06		bra $b91c			bra 	_CPRNPrint
.b916					_CPR_GoNewLine:
.b916	4c 7d b9	jmp $b97d			jmp 	_CPR_NewLine
.b919	20 fe ca	jsr $cafe	_CPRInt:jsr 	IntToString
.b91c					_CPRNPrint:
.b91c	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.b91f	c9 2d		cmp #$2d			cmp 	#"-"
.b921	f0 05		beq $b928			beq 	_CPRNoSpace
.b923	a9 20		lda #$20			lda 	#" "						; print the leading space
.b925	20 61 ae	jsr $ae61			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.b928					_CPRNoSpace:
.b928	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.b92a	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.b92c	80 04		bra $b932			bra 	_CPRPrint
.b92e					_CPR_String:
.b92e	a6 80		ldx $80				ldx 	XS_Mantissa
.b930	a5 81		lda $81				lda 	XS_Mantissa+1
.b932					_CPRPrint:
.b932	86 20		stx $20				stx 	zGenPtr
.b934	85 21		sta $21				sta 	zGenPtr+1
.b936	5a		phy				phy
.b937	a0 00		ldy #$00			ldy 	#0							; get length into X
.b939	b1 20		lda ($20),y			lda 	(zGenPtr),y
.b93b	aa		tax				tax
.b93c	f0 09		beq $b947			beq 	_CPREndPrint 				; nothing to print
.b93e					_CPRLoop:
.b93e	c8		iny				iny
.b93f	b1 20		lda ($20),y			lda 	(zGenPtr),y
.b941	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b944	ca		dex				dex
.b945	d0 f7		bne $b93e			bne 	_CPRLoop
.b947					_CPREndPrint:
.b947	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.b949	29 02		and #$02			and 	#2
.b94b	d0 05		bne $b952			bne 	_CPRNoTrail
.b94d	a9 20		lda #$20			lda 	#" "
.b94f	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b952					_CPRNoTrail:
.b952	7a		ply				ply
.b953	80 96		bra $b8eb			bra 	_CPR_Loop
.b955					_CPR_Tab:
.b955	20 72 ae	jsr $ae72			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.b958					_CPR_CalcSpaces:
.b958	38		sec				sec 								; calculate position mod 10.
.b959	e9 0a		sbc #$0a			sbc 	#10
.b95b	b0 fb		bcs $b958			bcs 	_CPR_CalcSpaces
.b95d	69 0a		adc #$0a			adc 	#10
.b95f	f0 0d		beq $b96e			beq 	_CPR_Skip 					; nothing to print
.b961	aa		tax				tax 								; print out spaces to mod 10
.b962					_CPRTabSpaces:
.b962	a9 20		lda #$20			lda 	#" "
.b964	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b967	e8		inx				inx
.b968	e0 0a		cpx #$0a			cpx 	#10
.b96a	d0 f6		bne $b962			bne 	_CPRTabSpaces
.b96c	80 e7		bra $b955			bra 	_CPR_Tab
.b96e					_CPR_Skip:
.b96e	1b		inz				inz
.b96f	ea		nop				nop
.b970	b2 18		lda ($18),z			lda 	(zCodePtr),z
.b972	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.b974	f0 0c		beq $b982			beq 	_CPR_Exit
.b976	c9 00		cmp #$00			cmp 	#0
.b978	f0 08		beq $b982			beq 	_CPR_Exit 					; if not go round again.
.b97a	4c eb b8	jmp $b8eb			jmp 	_CPR_Loop
.b97d					_CPR_NewLine:
.b97d	a9 0d		lda #$0d			lda 	#13
.b97f	20 61 ae	jsr $ae61			jsr 	VIOCharPrint
.b982					_CPR_Exit:
.b982	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.b983					Command_ASSERT:
.b983	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.b986	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.b988	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.b98a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.b98c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.b98e	f0 01		beq $b991			beq 	_ASFail
.b990	60		rts				rts
.b991					_ASFail:
.b991	20 a8 ae	jsr $aea8			jsr ERR_Handler
>b994	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.b99b					Command_POKE:
.b99b	a9 01		lda #$01			lda 	#1 							; 1 byte
.b99d	80 06		bra $b9a5			bra 	CmdPoke_Main
.b99f					Command_DOKE:
.b99f	a9 02		lda #$02			lda 	#2 							; 2 bytes
.b9a1	80 02		bra $b9a5			bra 	CmdPoke_Main
.b9a3					Command_LOKE:
.b9a3	a9 04		lda #$04			lda 	#4							; 4 bytes
.b9a5					CmdPoke_Main:
.b9a5	48		pha				pha
.b9a6	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; get two parameters. First is address
.b9a9	e8		inx				inx
.b9aa	e8		inx				inx
.b9ab	e8		inx				inx
.b9ac	e8		inx				inx
.b9ad	e8		inx				inx
.b9ae	e8		inx				inx
.b9af	20 66 c3	jsr $c366			jsr 	CheckNextComma
.b9b2	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX 			; second is the data.
.b9b5	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.b9b7	85 1c		sta $1c				sta 	zLTemp1
.b9b9	a5 81		lda $81				lda 	XS_Mantissa+1
.b9bb	85 1d		sta $1d				sta 	zLTemp1+1
.b9bd	a5 82		lda $82				lda 	XS_Mantissa+2
.b9bf	85 1e		sta $1e				sta 	zLTemp1+2
.b9c1	a5 83		lda $83				lda 	XS_Mantissa+3
.b9c3	85 1f		sta $1f				sta 	zLTemp1+3
.b9c5	68		pla				pla 								; get count
.b9c6	5a		phy				phy 								; save Y
.b9c7	20 e8 c2	jsr $c2e8			jsr 	MemWrite 					; write it out
.b9ca	7a		ply				ply 								; restore Y and done.
.b9cb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.b9cc					Command_NEW:
.b9cc	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b9ce	85 18		sta $18				sta 	zCodePtr+0
.b9d0	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b9d2	85 19		sta $19				sta 	zCodePtr+1
.b9d4	a9 02		lda #$02			lda 	#2
.b9d6	85 1a		sta $1a				sta 	zCodePtr+2
.b9d8	a9 00		lda #$00			lda 	#0
.b9da	85 1b		sta $1b				sta 	zCodePtr+3
.b9dc	a3 03		ldz #$03			ldz 	#3
.b9de	a3 00		ldz #$00			ldz 	#0
.b9e0	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.b9e2	ea		nop				nop
.b9e3	92 18		sta ($18),z			sta 	(zCodePtr),z
.b9e5	20 fc c2	jsr $c2fc			jsr 	UpdateProgramEnd 			; update program end.
.b9e8	4c 57 b1	jmp $b157			jmp 	WarmStart 					; and always warmstart, can't be running program.
.b9eb					Command_OLD:
.b9eb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.b9ed	85 18		sta $18				sta 	zCodePtr+0
.b9ef	a9 80		lda #$80			lda 	#BasicProgram >> 8
.b9f1	85 19		sta $19				sta 	zCodePtr+1
.b9f3	a9 02		lda #$02			lda 	#2
.b9f5	85 1a		sta $1a				sta 	zCodePtr+2
.b9f7	a9 00		lda #$00			lda 	#0
.b9f9	85 1b		sta $1b				sta 	zCodePtr+3
.b9fb	a3 03		ldz #$03			ldz 	#3
.b9fd					_COL_Find:
.b9fd	ea		nop				nop
.b9fe	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ba00	1b		inz				inz
.ba01	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.ba03	f0 18		beq $ba1d			beq 	_COL_Found
.ba05	6b		tza				tza
.ba06	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.ba08	d0 f3		bne $b9fd			bne 	_COL_Find 					; can't find old EOL, give up.
.ba0a	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ba0d	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>ba15	43 6f 72 72 75 70 74 00
.ba1d					_COL_Found:
.ba1d	6b		tza				tza
.ba1e	48		pha				pha
.ba1f	a3 00		ldz #$00			ldz 	#0
.ba21	68		pla				pla
.ba22	ea		nop				nop
.ba23	92 18		sta ($18),z			sta 	(zCodePtr),z
.ba25	20 fc c2	jsr $c2fc			jsr 	UpdateProgramEnd 			; reset variable pointer
.ba28	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.ba29					Command_GOTO:
.ba29	20 7f ba	jsr $ba7f			jsr 	GotoGetLineNumber 			; get line number
.ba2c					CmdGOTO:
.ba2c	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.ba2e	4c 9c ba	jmp $ba9c			jmp 	GotoChangeToLineNumberX
.ba31					Command_GOSUB:
.ba31	20 7f ba	jsr $ba7f			jsr 	GotoGetLineNumber 			; get line number
.ba34					CmdGOSUB:
.ba34	20 28 ae	jsr $ae28			jsr 	StackSavePosition 			; save position on stack and push frame
.ba37	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.ba39	20 e1 ad	jsr $ade1			jsr 	StackPushFrame
.ba3c	a2 00		ldx #$00			ldx		#0 							; go to that line number
.ba3e	4c 9c ba	jmp $ba9c			jmp 	GotoChangeToLineNumberX
.ba41					Command_RETURN:
.ba41	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.ba43	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.ba46	20 45 ae	jsr $ae45			jsr 	StackRestorePosition 		; restore position.
.ba49	60		rts				rts
.ba4a					Command_ON:
.ba4a	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.ba4c	20 a8 c1	jsr $c1a8			jsr 	SLIByteParameter
.ba4f	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.ba51	f0 29		beq $ba7c			beq 	_CONFail 					; can't be zero, error if it is.
.ba53	aa		tax				tax 								; save in X.
.ba54	ea		nop				nop
.ba55	b2 18		lda ($18),z			lda 	(zCodePtr),z
.ba57	1b		inz				inz
.ba58	48		pha				pha 								; so we can check what we're doing later.
.ba59	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.ba5b	f0 07		beq $ba64			beq 	_CONOkayToken
.ba5d	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.ba5f	f0 03		beq $ba64			beq 	_CONOkayToken
.ba61	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.ba64					_CONOkayToken:
.ba64	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.ba65					_CONFindNumber:
.ba65	20 7f ba	jsr $ba7f			jsr 	GotoGetLineNumber 			; get a line number.
.ba68	fa		plx				plx 								; restore count
.ba69	ca		dex				dex  								; decrement, exit if zero.
.ba6a	f0 06		beq $ba72			beq 	_CONFound
.ba6c	da		phx				phx 								; push back
.ba6d	20 66 c3	jsr $c366			jsr 	CheckNextComma				; check for comma
.ba70	80 f3		bra $ba65			bra 	_CONFindNumber 				; go round again.
.ba72					_CONFound:
.ba72	68		pla				pla 								; get token to decide what to do
.ba73	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.ba75	f0 b5		beq $ba2c			beq		CmdGOTO 					; then just branch.
.ba77	20 ac ad	jsr $adac			jsr 	SkipEndOfCommand 			; go to end of command
.ba7a	80 b8		bra $ba34			bra 	CmdGOSUB 					; and do a GOSUB.
.ba7c					_CONFail:
.ba7c	4c 97 ae	jmp $ae97			jmp 	BadParamError
.ba7f					GotoGetLineNumber:
.ba7f	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; get integer into mantissa.0
.ba82	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.ba84	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.ba86	d0 01		bne $ba89			bne 	_GLINError
.ba88	60		rts				rts
.ba89					_GLINError:
.ba89	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ba8c	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>ba94	20 4e 75 6d 62 65 72 00
.ba9c					GotoChangeToLineNumberX:
.ba9c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.ba9e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.baa0	f0 3d		beq $badf			beq 	_GCTLFail 					; if so, no can do.
.baa2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.baa4	85 18		sta $18				sta 	zCodePtr+0
.baa6	a9 80		lda #$80			lda 	#BasicProgram >> 8
.baa8	85 19		sta $19				sta 	zCodePtr+1
.baaa	a9 02		lda #$02			lda 	#2
.baac	85 1a		sta $1a				sta 	zCodePtr+2
.baae	a9 00		lda #$00			lda 	#0
.bab0	85 1b		sta $1b				sta 	zCodePtr+3
.bab2	a3 03		ldz #$03			ldz 	#3
.bab4					_GCTLLoop:
.bab4	a3 00		ldz #$00			ldz 	#0
.bab6	ea		nop				nop
.bab7	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bab9	c9 00		cmp #$00			cmp 	#0
.babb	f0 22		beq $badf			beq 	_GCTLFail
.babd	1b		inz				inz
.babe	ea		nop				nop
.babf	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bac1	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.bac3	d0 08		bne $bacd			bne 	_GCTLNext
.bac5	1b		inz				inz
.bac6	ea		nop				nop
.bac7	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bac9	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.bacb	f0 10		beq $badd			beq 	_GCTLExit
.bacd					_GCTLNext:
.bacd	a3 00		ldz #$00			ldz 	#0 							; point to offset
.bacf	ea		nop				nop
.bad0	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.bad2	18		clc				clc
.bad3	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.bad5	85 18		sta $18				sta 	zCodePtr
.bad7	90 02		bcc $badb			bcc 	_SNLNoCarry
.bad9	e6 19		inc $19				inc 	zCodePtr+1
.badb					_SNLNoCarry:
.badb	80 d7		bra $bab4			bra 	_GCTLLoop 					; try next line.
.badd					_GCTLExit:
.badd	1b		inz				inz
.bade	60		rts				rts
.badf					_GCTLFail:
.badf	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bae2	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>baea	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.baf2					Command_CLR:
.baf2					ResetRunStatus:
.baf2	20 56 c6	jsr $c656			jsr 	VariableClear
.baf5	20 cf ad	jsr $adcf			jsr 	StackReset
.baf8	a9 00		lda #$00			lda 	#HighMemory & $FF
.bafa	8d 00 03	sta $0300			sta 	StringPtr
.bafd	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.baff	8d 01 03	sta $0301			sta 	StringPtr+1
.bb02	20 22 c8	jsr $c822			jsr 	ArrayResetDefault
.bb05	20 1b b4	jsr $b41b			jsr 	Command_RESTORE
.bb08	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.bb09					Command_STOP:
.bb09	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bb0c	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.bb11					Command_WHILE:
.bb11	20 28 ae	jsr $ae28			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.bb14	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger 			; calculate the while loop value.
.bb17	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.bb19	05 81		ora $81				ora 	XS_Mantissa+1
.bb1b	05 82		ora $82				ora 	XS_Mantissa+2
.bb1d	05 83		ora $83				ora 	XS_Mantissa+3
.bb1f	f0 06		beq $bb27			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.bb21	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.bb23	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push on stack
.bb26	60		rts				rts
.bb27					_CWHSkip:
.bb27	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.bb29	20 1a ad	jsr $ad1a			jsr 	StructureSearchSingle
.bb2c	1b		inz				inz
.bb2d	60		rts				rts
.bb2e					Command_WEND:
.bb2e	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.bb30	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.bb33	20 45 ae	jsr $ae45			jsr 	StackRestorePosition
.bb36	80 d9		bra $bb11			bra 	Command_WHILE 				; and do the while again.
.bb38	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.bb39					Command_REPEAT:
.bb39	20 28 ae	jsr $ae28			jsr 	StackSavePosition			; save position into stack
.bb3c	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.bb3e	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; push on stack
.bb41	60		rts				rts
.bb42					Command_UNTIL:
.bb42	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.bb44	20 f8 ad	jsr $adf8			jsr 	StackPopFrame
.bb47	20 fd bc	jsr $bcfd			jsr 	EvaluateInteger				; work out the UNTIL expression.
.bb4a	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.bb4c	05 81		ora $81				ora 	XS_Mantissa+1
.bb4e	05 82		ora $82				ora 	XS_Mantissa+2
.bb50	05 83		ora $83				ora 	XS_Mantissa+3
.bb52	d0 08		bne $bb5c			bne 	_CUTExit 					; if not, just exit
.bb54	20 45 ae	jsr $ae45			jsr 	StackRestorePosition 		; otherwise loop round again.
.bb57	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.bb59	20 e1 ad	jsr $ade1			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.bb5c					_CUTExit:
.bb5c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.bb5d					EVESyntax:
.bb5d	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.bb60					EvaluateExpression:
.bb60	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.bb62					EvaluateExpressionX:
.bb62	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.bb64					EvaluateExpressionXA:
.bb64	48		pha				pha 								; save precedence on stack.
.bb65	ea		nop				nop
.bb66	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb68	f0 f3		beq $bb5d			beq 	EVESyntax 					; end of line, syntax error.
.bb6a	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.bb6c	b0 03		bcs $bb71			bcs 	_EVNotVariable
.bb6e	4c 3d bc	jmp $bc3d			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.bb71					_EVNotVariable:
.bb71	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.bb73	90 e8		bcc $bb5d			bcc 	EVESyntax
.bb75	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.bb77	b0 59		bcs $bbd2			bcs 	_EVNotInteger
.bb79	20 6b bc	jsr $bc6b			jsr 	EvaluateGetInteger
.bb7c					_EVCheckDecimal:
.bb7c	ea		nop				nop
.bb7d	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb7f	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.bb81	d0 05		bne $bb88			bne 	_EVGotAtom 					; no, get atom.
.bb83					_EVIsDecimal:
.bb83	20 93 bc	jsr $bc93			jsr 	EVGetDecimal 				; extend to the decimal part.
.bb86	80 00		bra $bb88			bra 	_EVGotAtom 					; and continue to got atom.
.bb88					_EVGotAtom:
.bb88	ea		nop				nop
.bb89	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb8b	10 43		bpl $bbd0			bpl 	_EVExitDrop 				; must be a token.
.bb8d	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.bb8f	b0 3f		bcs $bbd0			bcs 	_EVExitDrop
.bb91	68		pla				pla 								; get current precedence
.bb92	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.bb94	da		phx				phx 								; save X
.bb95	ea		nop				nop
.bb96	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bb98	aa		tax				tax 								; put in X
.bb99	bd 5b af	lda $af5b,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.bb9c	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.bb9e	fa		plx				plx 								; restore X
.bb9f	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.bba1	90 2e		bcc $bbd1			bcc 	_EVExit 					; exit if too low.
.bba3	f0 2c		beq $bbd1			beq 	_EVExit 					; exit if equals
.bba5	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.bba7	48		pha				pha
.bba8	ea		nop				nop
.bba9	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbab	48		pha				pha
.bbac	1b		inz				inz
.bbad	da		phx				phx 								; save current position
.bbae	e8		inx				inx
.bbaf	e8		inx				inx
.bbb0	e8		inx				inx
.bbb1	e8		inx				inx
.bbb2	e8		inx				inx
.bbb3	e8		inx				inx
.bbb4	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.bbb6	20 64 bb	jsr $bb64			jsr 	EvaluateExpressionXA 		; do the RHS.
.bbb9	fa		plx				plx 								; restore X
.bbba	68		pla				pla 								; get the binary operator in A.
.bbbb					_EVCallA:
.bbbb	da		phx				phx 								; save X again
.bbbc	0a		asl a				asl 	a 							; double, lose the MSB.
.bbbd	aa		tax				tax									; put in X
.bbbe	bd 0a af	lda $af0a,x			lda 	VectorTable,x 				; copy address into zGenPtr
.bbc1	8d 11 03	sta $0311			sta 	LocalVector+1
.bbc4	bd 0b af	lda $af0b,x			lda 	VectorTable+1,x
.bbc7	8d 12 03	sta $0312			sta 	LocalVector+2
.bbca	fa		plx				plx 								; restore X
.bbcb	20 46 bc	jsr $bc46			jsr 	EVCallLocalVector
.bbce	80 b8		bra $bb88			bra 	_EVGotAtom 					; and loop back.
.bbd0					_EVExitDrop:
.bbd0	68		pla				pla
.bbd1					_EVExit:
.bbd1	60		rts				rts
.bbd2					_EVNotInteger:
.bbd2	1b		inz				inz
.bbd3	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.bbd5	d0 16		bne $bbed			bne 	_EVNotMinus
.bbd7	20 de bc	jsr $bcde			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.bbda	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bbdc	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bbde	f0 05		beq $bbe5			beq 	_EVMinusFloat
.bbe0	20 e1 ca	jsr $cae1			jsr 	IntegerNegateAlways 		; negation
.bbe3	80 a3		bra $bb88			bra 	_EVGotAtom 					; and go back.
.bbe5					_EVMinusFloat:
.bbe5	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.bbe7	49 80		eor #$80			eor 	#$80
.bbe9	95 85		sta $85,x			sta 	XS_Type,x
.bbeb	80 9b		bra $bb88			bra 	_EVGotAtom
.bbed					_EVNotMinus:
.bbed	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.bbef	d0 18		bne $bc09			bne 	_EVNotParenthesis
.bbf1	20 62 bb	jsr $bb62			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.bbf4	ea		nop				nop
.bbf5	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bbf7	1b		inz				inz
.bbf8	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.bbfa	f0 8c		beq $bb88			beq 	_EVGotAtom
.bbfc	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bbff	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>bc07	29 00
.bc09					_EVNotParenthesis:
.bc09	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.bc0b	d0 0c		bne $bc19			bne 	_EVNotNot
.bc0d	20 de bc	jsr $bcde			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.bc10	20 75 cf	jsr $cf75			jsr 	FPUToInteger 				; make it an integer - if possible.
.bc13	20 c3 bc	jsr $bcc3			jsr 	NotInteger 					; do the not calculation
.bc16	4c 88 bb	jmp $bb88			jmp 	_EVGotAtom
.bc19					_EVNotNot:
.bc19	c9 fe		cmp #$fe			cmp 	#$FE
.bc1b	d0 12		bne $bc2f			bne 	_EVNotString
.bc1d	20 e7 c3	jsr $c3e7			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.bc20	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.bc22	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc24	a5 23		lda $23				lda 	zTempStr+1
.bc26	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc28	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.bc2a	95 85		sta $85,x			sta 	XS_Type,x
.bc2c	4c 88 bb	jmp $bb88			jmp 	_EVGotAtom
.bc2f					_EVNotString:
.bc2f	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.bc31	90 04		bcc $bc37			bcc 	_EVBadElement
.bc33	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.bc35	90 03		bcc $bc3a			bcc 	_EVUnaryFunction
.bc37					_EVBadElement:
.bc37	4c 79 ae	jmp $ae79			jmp 	SyntaxError
.bc3a					_EVUnaryFunction:
.bc3a	4c bb bb	jmp $bbbb			jmp 	_EVCallA
.bc3d					_EVVariableHandler:
.bc3d	20 1a c6	jsr $c61a			jsr 	VariableFind 				; locate a variable
.bc40	20 64 c9	jsr $c964			jsr 	VariableGet 				; copy into memory.
.bc43	4c 88 bb	jmp $bb88			jmp 	_EVGotAtom 					; and go round.
.bc46					EVCallLocalVector:
.bc46	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.bc49					EVShiftMantissaLeft6:
.bc49	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.bc4b	95 84		sta $84,x			sta 	XS_Exponent,x
.bc4d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bc4f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bc51	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bc53	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bc55	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bc57	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc59	a9 00		lda #$00			lda 	#0
.bc5b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc5d	20 60 bc	jsr $bc60			jsr 	_EVSMLShift 					; call it here to do it twice
.bc60					_EVSMLShift:
.bc60	56 84		lsr $84,x			lsr 	XS_Exponent,x
.bc62	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.bc64	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.bc66	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.bc68	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.bc6a	60		rts				rts
.bc6b					EvaluateGetInteger:
.bc6b	ea		nop				nop
.bc6c	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc6e	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.bc70	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.bc72	a9 00		lda #$00			lda 	#0
.bc74	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bc76	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bc78	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bc7a	1a		inc a				inc 	a 							; set to type 1 (integer)
.bc7b	95 85		sta $85,x			sta 	XS_Type,x
.bc7d					_EVCheckNextInteger:
.bc7d	1b		inz				inz
.bc7e	ea		nop				nop
.bc7f	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc81	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.bc83	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.bc85	b0 0b		bcs $bc92			bcs 	_EVEndInteger
.bc87	48		pha				pha 								; save it.
.bc88	20 49 bc	jsr $bc49			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.bc8b	68		pla				pla
.bc8c	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.bc8e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bc90	80 eb		bra $bc7d			bra 	_EVCheckNextInteger
.bc92					_EVEndInteger:
.bc92	60		rts				rts
.bc93					EVGetDecimal:
.bc93	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.bc95	8d 15 03	sta $0315			sta 	Num_Buffer
.bc98	da		phx				phx
.bc99	1b		inz				inz
.bc9a	ea		nop				nop
.bc9b	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bc9d	1b		inz				inz
.bc9e	3a		dec a				dec 	a								; convert to a string length.
.bc9f	3a		dec a				dec 	a
.bca0	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.bca2					_EVGDCopy:
.bca2	48		pha				pha 									; save count
.bca3	ea		nop				nop
.bca4	b2 18		lda ($18),z			lda 	(zCodePtr),z
.bca6	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.bca9	e8		inx				inx 									; forward ....
.bcaa	1b		inz				inz
.bcab	68		pla				pla 									; get count
.bcac	3a		dec a				dec 	a 								; until zero
.bcad	d0 f3		bne $bca2			bne 	_EVGDCopy
.bcaf	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.bcb2	fa		plx				plx 									; restore X
.bcb3	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.bcb5	85 20		sta $20				sta 	zGenPtr
.bcb7	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.bcb9	85 21		sta $21				sta 	zGenPtr+1
.bcbb	5a		phy				phy 									; save Y
.bcbc	a0 00		ldy #$00			ldy 	#0 								; start position
.bcbe	20 2f d1	jsr $d12f			jsr 	FPFromString 					; convert current
.bcc1	7a		ply				ply 									; restore Y
.bcc2	60		rts				rts
.bcc3					NotInteger:
.bcc3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bcc5	49 ff		eor #$ff			eor 	#$FF
.bcc7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bcc9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bccb	49 ff		eor #$ff			eor 	#$FF
.bccd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bccf	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bcd1	49 ff		eor #$ff			eor 	#$FF
.bcd3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bcd5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bcd7	49 ff		eor #$ff			eor 	#$FF
.bcd9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bcdb	60		rts				rts
.bcdc					EvaluateGetAtom:
.bcdc	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.bcde					EvaluateGetAtomX:
.bcde	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.bce0	20 64 bb	jsr $bb64			jsr 	EvaluateExpressionXA
.bce3	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.bce5	29 0f		and #$0f			and 	#15
.bce7	c9 02		cmp #$02			cmp 	#2
.bce9	b0 01		bcs $bcec			bcs 	EvaluateType
.bceb	60		rts				rts
.bcec					EvaluateType:
.bcec	4c 89 ae	jmp $ae89			jmp 	TypeError
.bcef					EvaluateNumber:
.bcef	a2 00		ldx #$00			ldx 	#0
.bcf1					EvaluateNumberX:
.bcf1	20 62 bb	jsr $bb62			jsr 	EvaluateExpressionX
.bcf4	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.bcf6	29 0f		and #$0f			and 	#15
.bcf8	c9 02		cmp #$02			cmp 	#2
.bcfa	b0 f0		bcs $bcec			bcs 	EvaluateType
.bcfc	60		rts				rts
.bcfd					EvaluateInteger:
.bcfd	a2 00		ldx #$00			ldx 	#0
.bcff					EvaluateIntegerX:
.bcff	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX
.bd02	20 75 cf	jsr $cf75			jsr 	FPUToInteger
.bd05	60		rts				rts
.bd06					EvaluateString:
.bd06	a2 00		ldx #$00			ldx 	#0
.bd08					EvaluateStringX:
.bd08	20 62 bb	jsr $bb62			jsr 	EvaluateExpressionX
.bd0b	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.bd0d	29 0f		and #$0f			and 	#15
.bd0f	c9 02		cmp #$02			cmp 	#2
.bd11	d0 d9		bne $bcec			bne 	EvaluateType
.bd13	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.bd15	85 20		sta $20				sta 	zGenPtr
.bd17	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bd19	85 21		sta $21				sta 	zGenPtr+1
.bd1b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.bd1c					BinaryOp_And:
.bd1c	20 70 bd	jsr $bd70			jsr 	BinaryMakeBothInteger
.bd1f	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bd21	35 86		and $86,x			and 	XS2_Mantissa+0,x
.bd23	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd25	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bd27	35 87		and $87,x			and 	XS2_Mantissa+1,x
.bd29	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd2b	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bd2d	35 88		and $88,x			and 	XS2_Mantissa+2,x
.bd2f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd31	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bd33	35 89		and $89,x			and 	XS2_Mantissa+3,x
.bd35	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd37	60		rts				rts
.bd38					BinaryOp_Or:
.bd38	20 70 bd	jsr $bd70			jsr 	BinaryMakeBothInteger
.bd3b	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bd3d	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.bd3f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd41	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bd43	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.bd45	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd47	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bd49	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.bd4b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd4d	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bd4f	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.bd51	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd53	60		rts				rts
.bd54					BinaryOp_Eor:
.bd54					BinaryOp_Xor:
.bd54	20 70 bd	jsr $bd70			jsr 	BinaryMakeBothInteger
.bd57	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.bd59	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.bd5b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bd5d	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.bd5f	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.bd61	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bd63	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.bd65	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.bd67	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bd69	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.bd6b	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.bd6d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bd6f	60		rts				rts
.bd70					BinaryMakeBothInteger:
.bd70	da		phx				phx 								; save X
.bd71	e8		inx				inx
.bd72	e8		inx				inx
.bd73	e8		inx				inx
.bd74	e8		inx				inx
.bd75	e8		inx				inx
.bd76	e8		inx				inx
.bd77	20 7b bd	jsr $bd7b			jsr 	BinaryMakeInteger 			; convert to integer.
.bd7a	fa		plx				plx 								; restore X and fall through.
.bd7b					BinaryMakeInteger:
.bd7b	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.bd7d	29 0f		and #$0f			and 	#15 						; check type zero
.bd7f	f0 04		beq $bd85			beq 	_BMIConvert 				; if float convert to integer.
.bd81	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.bd82	90 04		bcc $bd88			bcc 	_BMIError
.bd84	60		rts				rts
.bd85					_BMIConvert:
.bd85	4c 75 cf	jmp $cf75			jmp 	FPUToInteger 				; convert to integer
.bd88					_BMIError:
.bd88	4c 89 ae	jmp $ae89			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.bd8b					Binary_Equal:
.bd8b	20 d4 bd	jsr $bdd4			jsr 	CompareValues 				; compare the values
.bd8e	09 00		ora #$00			ora 	#0 							; true if 0
.bd90	f0 33		beq $bdc5			beq 	CCTrue
.bd92	80 2d		bra $bdc1			bra 	CCFalse
.bd94					Binary_NotEqual:
.bd94	20 d4 bd	jsr $bdd4			jsr 	CompareValues
.bd97	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.bd99	f0 26		beq $bdc1			beq 	CCFalse
.bd9b	80 28		bra $bdc5			bra 	CCTrue
.bd9d					Binary_Less:
.bd9d	20 d4 bd	jsr $bdd4			jsr 	CompareValues
.bda0	09 00		ora #$00			ora 	#0 							; true if -1
.bda2	30 21		bmi $bdc5			bmi 	CCTrue
.bda4	80 1b		bra $bdc1			bra 	CCFalse
.bda6					Binary_LessEqual:
.bda6	20 d4 bd	jsr $bdd4			jsr 	CompareValues
.bda9	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.bdab	d0 18		bne $bdc5			bne 	CCTrue
.bdad	80 12		bra $bdc1			bra 	CCFalse
.bdaf					Binary_GreaterEqual:
.bdaf	20 d4 bd	jsr $bdd4			jsr 	CompareValues
.bdb2	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.bdb4	10 0f		bpl $bdc5			bpl 	CCTrue
.bdb6	80 09		bra $bdc1			bra 	CCFalse
.bdb8					Binary_Greater:
.bdb8	20 d4 bd	jsr $bdd4			jsr 	CompareValues 				; true if 1
.bdbb	c9 01		cmp #$01			cmp 	#1
.bdbd	f0 06		beq $bdc5			beq 	CCTrue
.bdbf	80 00		bra $bdc1			bra 	CCFalse
.bdc1	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.bdc3	80 02		bra $bdc7			bra 	CCWrite
.bdc5	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.bdc7	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.bdc9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bdcb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bdcd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bdcf	a9 01		lda #$01			lda 	#1
.bdd1	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.bdd3	60		rts				rts
.bdd4					CompareValues:
.bdd4	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.bdd6	35 8b		and $8b,x			and 	XS2_Type,x
.bdd8	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.bdda	f0 11		beq $bded			beq 	_CVString					; comparison routine.
.bddc	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.bdde	35 8b		and $8b,x			and 	XS2_Type,x
.bde0	4a		lsr a				lsr 	a 							; shift bit 0 into C
.bde1	90 03		bcc $bde6			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.bde3	4c 2f be	jmp $be2f			jmp 	CompareInteger32 							; so execute code at \1
.bde6					_BCFloat:
.bde6	20 d3 be	jsr $bed3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.bde9	4c 6e ce	jmp $ce6e			jmp 	FPCompare 							; and execute code at \2
.bdec	60		rts				rts
.bded					_CVString:
.bded	da		phx				phx 								; save XY
.bdee	5a		phy				phy
.bdef	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.bdf1	85 1c		sta $1c				sta		zLTemp1+0
.bdf3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bdf5	85 1d		sta $1d				sta 	zLTemp1+1
.bdf7	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.bdf9	85 1e		sta $1e				sta 	zLTemp1+2
.bdfb	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.bdfd	85 1f		sta $1f				sta 	zLTemp1+3
.bdff	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.be01	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.be03	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.be05	90 02		bcc $be09			bcc 	_CVCommon
.be07	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.be09					_CVCommon:
.be09	aa		tax				tax 								; put shorter string length in zero.
.be0a	f0 0c		beq $be18			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.be0c					_CVCompare:
.be0c	c8		iny				iny 								; next character
.be0d	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.be0f	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.be11	90 13		bcc $be26			bcc 	_CVReturnLess 				; <
.be13	d0 15		bne $be2a			bne 	_CVReturnGreater 			; >
.be15	ca		dex				dex 								; until common length matched.
.be16	d0 f4		bne $be0c			bne 	_CVCompare
.be18					_CVMatch:
.be18	a0 00		ldy #$00			ldy 	#0
.be1a	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.be1c	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.be1e	90 06		bcc $be26			bcc 	_CVReturnLess 				; <
.be20	d0 08		bne $be2a			bne 	_CVReturnGreater 			; >
.be22	a9 00		lda #$00			lda 	#0
.be24	80 06		bra $be2c			bra 	_CVExit
.be26					_CVReturnLess:
.be26	a9 ff		lda #$ff			lda 	#$FF
.be28	80 02		bra $be2c			bra 	_CVExit
.be2a					_CVReturnGreater:
.be2a	a9 01		lda #$01			lda 	#$01
.be2c					_CVExit:
.be2c	7a		ply				ply
.be2d	fa		plx				plx
.be2e	60		rts				rts
.be2f					CompareInteger32:
.be2f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.be31	49 80		eor #$80			eor 	#$80
.be33	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.be35	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.be37	49 80		eor #$80			eor 	#$80
.be39	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.be3b	20 b9 be	jsr $beb9			jsr 	SubInteger32 				; subtraction
.be3e	90 0d		bcc $be4d			bcc 	_CI32Less 					; cc return -1
.be40	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.be42	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.be44	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.be46	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.be48	f0 02		beq $be4c			beq 	_CI32Exit
.be4a	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.be4c					_CI32Exit:
.be4c	60		rts				rts
.be4d					_CI32Less:
.be4d	a9 ff		lda #$ff			lda 	#$FF
.be4f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.be50					BinaryOp_Add:
.be50	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.be52	35 8b		and $8b,x			and 	XS2_Type,x
.be54	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.be56	d0 11		bne $be69			bne 	_BOAString 					; so go do the string code.
.be58	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.be5a	35 8b		and $8b,x			and 	XS2_Type,x
.be5c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.be5d	90 03		bcc $be62			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.be5f	4c 9f be	jmp $be9f			jmp 	AddInteger32 							; so execute code at \1
.be62					_BCFloat:
.be62	20 d3 be	jsr $bed3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.be65	4c 49 cc	jmp $cc49			jmp 	FPAdd 							; and execute code at \2
.be68	60		rts				rts
.be69					_BOAString:
.be69	4c ed be	jmp $beed			jmp 	ConcatenateString 			; concatenate two strings.
.be6c					BinaryOp_Subtract:
.be6c	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.be6e	35 8b		and $8b,x			and 	XS2_Type,x
.be70	4a		lsr a				lsr 	a 							; shift bit 0 into C
.be71	90 03		bcc $be76			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.be73	4c b9 be	jmp $beb9			jmp 	SubInteger32 							; so execute code at \1
.be76					_BCFloat:
.be76	20 d3 be	jsr $bed3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.be79	4c 41 cc	jmp $cc41			jmp 	FPSubtract 							; and execute code at \2
.be7c	60		rts				rts
.be7d					BinaryOp_Multiply:
.be7d	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.be7f	35 8b		and $8b,x			and 	XS2_Type,x
.be81	4a		lsr a				lsr 	a 							; shift bit 0 into C
.be82	90 03		bcc $be87			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.be84	4c 1c ca	jmp $ca1c			jmp 	MulInteger32 							; so execute code at \1
.be87					_BCFloat:
.be87	20 d3 be	jsr $bed3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.be8a	4c 70 cd	jmp $cd70			jmp 	FPMultiply 							; and execute code at \2
.be8d	60		rts				rts
.be8e					BinaryOp_Divide:
.be8e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.be90	35 8b		and $8b,x			and 	XS2_Type,x
.be92	4a		lsr a				lsr 	a 							; shift bit 0 into C
.be93	90 03		bcc $be98			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.be95	4c 5a ca	jmp $ca5a			jmp 	DivInteger32 							; so execute code at \1
.be98					_BCFloat:
.be98	20 d3 be	jsr $bed3			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.be9b	4c fd cc	jmp $ccfd			jmp 	FPDivide 							; and execute code at \2
.be9e	60		rts				rts
.be9f					AddInteger32:
.be9f	18		clc				clc
.bea0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bea2	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.bea4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bea6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bea8	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.beaa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.beac	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.beae	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.beb0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.beb2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.beb4	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.beb6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.beb8	60		rts				rts
.beb9					SubInteger32:
.beb9	38		sec				sec
.beba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.bebc	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.bebe	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bec0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bec2	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.bec4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bec6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bec8	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.beca	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.becc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bece	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.bed0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bed2	60		rts				rts
.bed3					BinaryMakeBothFloat:
.bed3	da		phx				phx 								; save X
.bed4	e8		inx				inx
.bed5	e8		inx				inx
.bed6	e8		inx				inx
.bed7	e8		inx				inx
.bed8	e8		inx				inx
.bed9	e8		inx				inx
.beda	20 de be	jsr $bede			jsr 	BinaryMakeFloat 			; convert to float.
.bedd	fa		plx				plx 								; restore X and fall through.
.bede					BinaryMakeFloat:
.bede	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.bee0	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.bee1	b0 04		bcs $bee7			bcs 	_BMFConvert
.bee3	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.bee4	b0 04		bcs $beea			bcs 	_BMFError
.bee6	60		rts				rts
.bee7					_BMFConvert:
.bee7	4c 29 cf	jmp $cf29			jmp 	FPUToFloat 					; convert to float, only float builds of course
.beea					_BMFError:
.beea	4c 89 ae	jmp $ae89			jmp 	TypeError
.beed					ConcatenateString:
.beed	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.beef	85 1c		sta $1c				sta		zLTemp1+0
.bef1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bef3	85 1d		sta $1d				sta 	zLTemp1+1
.bef5	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.bef7	85 1e		sta $1e				sta 	zLTemp1+2
.bef9	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.befb	85 1f		sta $1f				sta 	zLTemp1+3
.befd	5a		phy				phy
.befe	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.bf00	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.bf02	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.bf04	7a		ply				ply
.bf05	b0 33		bcs $bf3a			bcs 	_CSError					; check in range.
.bf07	c9 fe		cmp #$fe			cmp 	#maxString+1
.bf09	b0 2f		bcs $bf3a			bcs 	_CSError
.bf0b	20 ac c3	jsr $c3ac			jsr 	AllocateTempString 			; store the result
.bf0e	20 25 bf	jsr $bf25			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.bf11	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.bf13	85 1c		sta $1c				sta 	zLTemp1
.bf15	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.bf17	85 1d		sta $1d				sta 	zLTemp1+1
.bf19	20 25 bf	jsr $bf25			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.bf1c	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.bf1e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.bf20	a5 23		lda $23				lda 	zTempStr+1
.bf22	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf24	60		rts				rts
.bf25					_CSCopyString:
.bf25	da		phx				phx
.bf26	5a		phy				phy
.bf27	a0 00		ldy #$00			ldy 	#0 							; get length
.bf29	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.bf2b	f0 0a		beq $bf37			beq 	_CSCSExit 					; if zero, exit immediately
.bf2d	aa		tax				tax 								; put in X which is the counter.
.bf2e					_CSCSLoop:
.bf2e	c8		iny				iny 								; get next char
.bf2f	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.bf31	20 d7 c3	jsr $c3d7			jsr		WriteTempString 			; copy out to new string
.bf34	ca		dex				dex 								; do whole string
.bf35	d0 f7		bne $bf2e			bne 	_CSCSLoop
.bf37					_CSCSExit:
.bf37	7a		ply				ply
.bf38	fa		plx				plx
.bf39	60		rts				rts
.bf3a					_CSError:
.bf3a	20 a8 ae	jsr $aea8			jsr ERR_Handler
>bf3d	53 74 72 69 6e 67 20 74			.text "String too long",0
>bf45	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.bf4d					Unary_Sgn:
.bf4d	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX 			; get value
.bf50	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; check right bracket.
.bf53	20 71 bf	jsr $bf71			jsr 	GetSignCurrent 				; get sign.
.bf56	09 00		ora #$00			ora 	#0
.bf58	10 08		bpl $bf62			bpl		UnarySetAInteger			; if 0,1 return that.
.bf5a	80 00		bra $bf5c			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.bf5c					UnarySetAMinus1:
.bf5c	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.bf5e	95 80		sta $80,x			sta 	XS_Mantissa,x
.bf60	80 04		bra $bf66			bra 	UnarySetAFill
.bf62					UnarySetAInteger:
.bf62	95 80		sta $80,x			sta 	XS_Mantissa,x
.bf64	a9 00		lda #$00			lda 	#0
.bf66					UnarySetAFill:
.bf66	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bf68	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bf6a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bf6c	a9 01		lda #$01			lda 	#1 							; set type to integer.
.bf6e	95 85		sta $85,x			sta 	XS_Type,x
.bf70	60		rts				rts
.bf71					GetSignCurrent:
.bf71	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.bf73	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.bf74	90 15		bcc $bf8b			bcc 	_GSCFloat 					; if clear do the float code.
.bf76	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.bf78	30 0e		bmi $bf88			bmi 	_GSCMinus1
.bf7a	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.bf7c	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.bf7e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.bf80	d0 03		bne $bf85			bne 	_GSCPlus1 					; check if zero by oring all together.
.bf82					_GSCZero:
.bf82	a9 00		lda #$00			lda 	#0
.bf84	60		rts				rts
.bf85					_GSCPlus1:
.bf85	a9 01		lda #$01			lda 	#$01
.bf87	60		rts				rts
.bf88					_GSCMinus1:
.bf88	a9 ff		lda #$ff			lda 	#$FF
.bf8a	60		rts				rts
.bf8b					_GSCFloat:
.bf8b	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.bf8d	70 f3		bvs $bf82			bvs 	_GSCZero 					; if zero flag set return zero
.bf8f	30 f7		bmi $bf88			bmi 	_GSCMinus1 					; if sign set return -1
.bf91	80 f2		bra $bf85			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.bf93					Unary_Abs:
.bf93	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX 			; get value
.bf96	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; check right bracket.
.bf99	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.bf9b	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.bf9d	f0 07		beq $bfa6			beq 	_UAMinusFloat
.bf9f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.bfa1	10 09		bpl $bfac			bpl 	_UAExit
.bfa3	4c e1 ca	jmp $cae1			jmp 	IntegerNegateAlways 		; if so negate it.
.bfa6					_UAMinusFloat:
.bfa6	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.bfa8	29 7f		and #$7f			and		#$7F
.bfaa	95 85		sta $85,x			sta 	XS_Type,x
.bfac					_UAExit:
.bfac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.bfad					Unary_Peek:
.bfad	a9 01		lda #$01			lda 	#1 							; 1 byte
.bfaf	80 06		bra $bfb7			bra 	UPMain
.bfb1					Unary_Deek:
.bfb1	a9 02		lda #$02			lda 	#2 							; 2 bytes
.bfb3	80 02		bra $bfb7			bra 	UPMain
.bfb5					Unary_Leek:
.bfb5	a9 04		lda #$04			lda 	#4 							; 4 bytes
.bfb7					UPMain:
.bfb7	48		pha				pha 								; save bytes to copy.
.bfb8	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.bfbb	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.bfbe	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.bfc0	85 1c		sta $1c				sta 	zLTemp1
.bfc2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.bfc4	85 1d		sta $1d				sta 	zLTemp1+1
.bfc6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.bfc8	85 1e		sta $1e				sta 	zLTemp1+2
.bfca	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.bfcc	85 1f		sta $1f				sta 	zLTemp1+3
.bfce	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.bfd0	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.bfd2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.bfd4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.bfd6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.bfd8	68		pla				pla 								; restore bytes to copy
.bfd9	da		phx				phx 								; save XY
.bfda	5a		phy				phy
.bfdb	20 d4 c2	jsr $c2d4			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.bfde	7a		ply				ply 								; restore and exit
.bfdf	fa		plx				plx
.bfe0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.bfe1					Unary_Pos:
.bfe1	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.bfe4	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; check right bracket.
.bfe7	20 72 ae	jsr $ae72			jsr 	VIOCharGetPosition 			; get the position
.bfea	4c 62 bf	jmp $bf62			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.bfed					Unary_Mod:
.bfed	20 15 c0	jsr $c015			jsr 	_UMParameter 				; first parameter, get |param|
.bff0	20 66 c3	jsr $c366			jsr 	CheckNextComma
.bff3	da		phx				phx 								; second parameter, get |param|
.bff4	e8		inx				inx
.bff5	e8		inx				inx
.bff6	e8		inx				inx
.bff7	e8		inx				inx
.bff8	e8		inx				inx
.bff9	e8		inx				inx
.bffa	20 15 c0	jsr $c015			jsr 	_UMParameter
.bffd	fa		plx				plx
.bffe	20 5d c3	jsr $c35d			jsr 	CheckNextRParen
.c001	20 5a ca	jsr $ca5a			jsr 	DivInteger32 				; divide, which handily leaves ....
.c004	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.c006	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c008	a5 1d		lda $1d				lda 	zLTemp1+1
.c00a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c00c	a5 1e		lda $1e				lda 	zLTemp1+2
.c00e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c010	a5 1f		lda $1f				lda 	zLTemp1+3
.c012	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c014	60		rts				rts
.c015					_UMParameter:
.c015	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX 			; get value
.c018	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.c01a	10 03		bpl $c01f			bpl 	_UMNotSigned
.c01c	20 e1 ca	jsr $cae1			jsr 	IntegerNegateAlways
.c01f					_UMNotSigned:
.c01f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.c020					Unary_Usr:
.c020	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX 			; numeric parameter
.c023	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.c026	da		phx				phx 								; save XY
.c027	5a		phy				phy
.c028	20 0c 03	jsr $030c			jsr 	UserVector 					; call the USR function.
.c02b	7a		ply				ply 								; restore YX and exit with whatever the
.c02c	fa		plx				plx 								; routine called has chosen to do with it.
.c02d	60		rts				rts
.c02e					USRDefault:
.c02e	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c031	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>c039	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.c040					Unary_Val:
.c040	20 08 bd	jsr $bd08			jsr 	EvaluateStringX 			; get string
.c043	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; check right bracket.
.c046	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.c048	85 20		sta $20				sta 	zGenPtr
.c04a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c04c	85 21		sta $21				sta 	zGenPtr+1
.c04e	da		phx				phx
.c04f	5a		phy				phy
.c050	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.c052	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.c054	f0 1b		beq $c071			beq 	UVBadNumber
.c056	aa		tax				tax
.c057					_UVCopy1:
.c057	c8		iny				iny
.c058	c0 18		cpy #$18			cpy 	#24 						; too long
.c05a	f0 15		beq $c071			beq 	UVBadNumber
.c05c	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.c05e	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.c061	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.c063	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.c066	ca		dex				dex
.c067	d0 ee		bne $c057			bne 	_UVCopy1
.c069	7a		ply				ply
.c06a	fa		plx				plx
.c06b	20 7f c0	jsr $c07f			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.c06e	b0 01		bcs $c071			bcs 	UVBadNumber
.c070	60		rts				rts
.c071					UVBadNumber:
.c071	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c074	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>c07c	65 72 00
.c07f					ConvertNumBuffer:
.c07f	5a		phy				phy
.c080	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.c082	85 20		sta $20				sta 	zGenPtr
.c084	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.c086	85 21		sta $21				sta 	zGenPtr+1
.c088	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.c08b	c9 2d		cmp #$2d			cmp 	#"-"
.c08d	d0 02		bne $c091			bne 	_UVNotMinus1
.c08f	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.c091					_UVNotMinus1:
.c091	20 af cb	jsr $cbaf			jsr 	IntFromString 				; get integer
.c094	b0 22		bcs $c0b8			bcs 	_UVFail
.c096	20 2f d1	jsr $d12f			jsr 	FPFromString 				; possibly float it.
.c099	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.c09b	d0 1b		bne $c0b8			bne 	_UVFail 					; no, exit.
.c09d	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.c0a0	c9 2d		cmp #$2d			cmp 	#"-"
.c0a2	d0 11		bne $c0b5			bne 	_UVNotMinus2
.c0a4	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.c0a6	29 0f		and #$0f			and 	#$0F
.c0a8	f0 05		beq $c0af			beq 	_UVNegateFloat
.c0aa	20 e1 ca	jsr $cae1			jsr 	IntegerNegateAlways
.c0ad	80 06		bra $c0b5			bra 	_UVNotMinus2
.c0af					_UVNegateFloat:
.c0af	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.c0b1	09 80		ora #$80			ora 	#$80
.c0b3	95 85		sta $85,x			sta 	XS_Type,x
.c0b5					_UVNotMinus2:
.c0b5	7a		ply				ply
.c0b6	18		clc				clc
.c0b7	60		rts				rts
.c0b8	7a		ply		_UVFail:ply
.c0b9	38		sec				sec
.c0ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.c0bb					Unary_Str:
.c0bb	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX 			; numeric parameter
.c0be	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.c0c1	a9 00		lda #$00			lda 	#0 							; reset buffer index
.c0c3	8d 14 03	sta $0314			sta 	NumBufX
.c0c6	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.c0c8	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.c0c9	b0 05		bcs $c0d0			bcs 	_USInt 						; if msb set do as integer
.c0cb	20 74 d0	jsr $d074			jsr 	FPToString 					; call fp to str otherwise
.c0ce	80 03		bra $c0d3			bra 	_USDuplicate
.c0d0	20 fe ca	jsr $cafe	_USInt:	jsr 	IntToString					; call int to str.
.c0d3					_USDuplicate:
.c0d3	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.c0d6	1a		inc a				inc 	a 							; one more for length
.c0d7	20 ac c3	jsr $c3ac			jsr 	AllocateTempString 			; allocate space for it.
.c0da	5a		phy				phy 								; save Y
.c0db	a0 00		ldy #$00			ldy 	#0 							; start copying
.c0dd	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.c0e0	20 d7 c3	jsr $c3d7			jsr 	WriteTempString
.c0e3	c8		iny				iny
.c0e4	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.c0e7	d0 f4		bne $c0dd			bne 	_USCopy
.c0e9	7a		ply				ply 								; restore Y
.c0ea	4c c7 c2	jmp $c2c7			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.c0ed					Unary_Asc:
.c0ed	20 08 bd	jsr $bd08			jsr 	EvaluateStringX 			; string parameter
.c0f0	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.c0f3	5a		phy				phy 								; get the string length
.c0f4	a0 00		ldy #$00			ldy 	#0
.c0f6	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c0f8	f0 07		beq $c101			beq 	_UAIllegal 					; must be at least one character, 0 => error
.c0fa	c8		iny				iny
.c0fb	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.c0fd	7a		ply				ply
.c0fe	4c 62 bf	jmp $bf62			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.c101					_UAIllegal:
.c101	4c 97 ae	jmp $ae97			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.c104					Unary_Len:
.c104	20 08 bd	jsr $bd08			jsr 	EvaluateStringX 			; string parameter
.c107	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.c10a	5a		phy				phy 								; get the string length
.c10b	a0 00		ldy #$00			ldy 	#0
.c10d	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c10f	7a		ply				ply
.c110	4c 62 bf	jmp $bf62			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.c113					Unary_Mid:
.c113	20 08 bd	jsr $bd08			jsr 	EvaluateStringX 				; get string.
.c116	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c118	48		pha				pha
.c119	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c11b	48		pha				pha
.c11c	20 66 c3	jsr $c366			jsr 	CheckNextComma 					; skip comma
.c11f	20 a8 c1	jsr $c1a8			jsr 	SLIByteParameter 				; get a byte parameter (start)
.c122	48		pha				pha 									; and push it.
.c123	20 66 c3	jsr $c366			jsr 	CheckNextComma 					; skip comma
.c126	20 a8 c1	jsr $c1a8			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.c129	48		pha				pha 									; and push it.
.c12a	80 41		bra $c16d			bra 	SLIProcess
.c12c					Unary_Left:
.c12c	20 08 bd	jsr $bd08			jsr 	EvaluateStringX 				; get string.
.c12f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c131	48		pha				pha
.c132	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c134	48		pha				pha
.c135	a9 01		lda #$01			lda 	#1 								; push start position (1)
.c137	48		pha				pha
.c138	20 66 c3	jsr $c366			jsr 	CheckNextComma 					; skip comma
.c13b	20 a8 c1	jsr $c1a8			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.c13e	48		pha				pha 									; and push it.
.c13f	80 2c		bra $c16d			bra 	SLIProcess
.c141					Unary_Right:
.c141	20 08 bd	jsr $bd08			jsr 	EvaluateStringX 				; get string.
.c144	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.c146	48		pha				pha
.c147	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c149	48		pha				pha
.c14a	da		phx				phx 									; get the string length and push on stack.
.c14b	a2 00		ldx #$00			ldx 	#0
.c14d	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.c14f	fa		plx				plx
.c150	48		pha				pha
.c151	20 66 c3	jsr $c366			jsr 	CheckNextComma 					; skip comma
.c154	20 a8 c1	jsr $c1a8			jsr 	SLIByteParameter 				; get a byte parameter.
.c157	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.c15a	68		pla				pla 									; restore string length.
.c15b	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.c15c	38		sec				sec
.c15d	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.c160	f0 02		beq $c164			beq 	_URStart 						; if <= 0 start from 1.
.c162	10 02		bpl $c166			bpl 	_UROkay
.c164					_URStart:
.c164	a9 01		lda #$01			lda 	#1
.c166					_UROkay:
.c166	48		pha				pha 									; push start
.c167	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.c16a	48		pha				pha
.c16b	80 00		bra $c16d			bra 	SLIProcess
.c16d					SLIProcess:
.c16d	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 				; closing right bracket.
.c170	68		pla				pla
.c171	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.c174	1a		inc a				inc 	a 								; allocate +1 for it.
.c175	20 ac c3	jsr $c3ac			jsr 	AllocateTempString
.c178	68		pla				pla 									; pop start number off stack.
.c179	f0 3b		beq $c1b6			beq 	SLIError 						; exit if start = 0
.c17b	8d a1 03	sta $03a1			sta 	SliceStart
.c17e	68		pla				pla  									; pop string address.
.c17f	85 21		sta $21				sta 	zGenPtr+1
.c181	68		pla				pla
.c182	85 20		sta $20				sta 	zGenPtr
.c184	da		phx				phx
.c185	5a		phy				phy
.c186	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.c188	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.c18b					_SLICopy:
.c18b	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.c18e	f0 12		beq $c1a2			beq 	_SLIExit
.c190	ce a2 03	dec $03a2			dec 	SliceCount
.c193	98		tya				tya 									; index of character
.c194	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.c196	f0 02		beq $c19a			beq 	_SLIOk 							; if equal, okay.
.c198	b0 08		bcs $c1a2			bcs 	_SLIExit 						; if past end, then exit.
.c19a	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.c19c	c8		iny				iny
.c19d	20 d7 c3	jsr $c3d7			jsr 	WriteTempString
.c1a0	80 e9		bra $c18b			bra 	_SLICopy 						; go round till copied characters
.c1a2					_SLIExit:
.c1a2	7a		ply				ply 									; restore YX
.c1a3	fa		plx				plx
.c1a4	4c c7 c2	jmp $c2c7			jmp 	UnaryReturnTempStr 				; return new temporary string.
.c1a7	ea		nop				nop
.c1a8					SLIByteParameter:
.c1a8	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX 				; get integer
.c1ab	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.c1ad	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c1af	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c1b1	d0 03		bne $c1b6			bne 	SLIError
.c1b3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c1b5	60		rts				rts
.c1b6					SLIError:
.c1b6	4c 97 ae	jmp $ae97			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.c1b9					Unary_Hex:
.c1b9	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX 			; numeric parameter
.c1bc	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.c1bf	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.c1c1	20 ac c3	jsr $c3ac			jsr 	AllocateTempString			; allocate string space
.c1c4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.c1c6	20 ea c1	jsr $c1ea			jsr 	_UHConvert
.c1c9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c1cb	20 ea c1	jsr $c1ea			jsr 	_UHConvert
.c1ce	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c1d0	20 ea c1	jsr $c1ea			jsr 	_UHConvert
.c1d3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c1d5	20 ea c1	jsr $c1ea			jsr 	_UHConvert
.c1d8	5a		phy				phy 								; get length of new string
.c1d9	a0 00		ldy #$00			ldy 	#0
.c1db	b1 22		lda ($22),y			lda 	(zTempStr),y
.c1dd	7a		ply				ply
.c1de	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.c1e0	d0 05		bne $c1e7			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.c1e2	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.c1e4	20 d7 c3	jsr $c3d7			jsr 	WriteTempString
.c1e7					_UHExit:
.c1e7	4c c7 c2	jmp $c2c7			jmp 	UnaryReturnTempStr 			; return new temporary string.
.c1ea					_UHConvert:
.c1ea	48		pha				pha
.c1eb	4a		lsr a				lsr 	a 							; do MSB
.c1ec	4a		lsr a				lsr 	a
.c1ed	4a		lsr a				lsr 	a
.c1ee	4a		lsr a				lsr 	a
.c1ef	20 f3 c1	jsr $c1f3			jsr 	_UHNibble
.c1f2	68		pla				pla 								; do LSB
.c1f3					_UHNibble:
.c1f3	29 0f		and #$0f			and 	#15 						; get nibble
.c1f5	d0 0c		bne $c203			bne 	_UHNonZero 					; if not zero, write it out anyway.
.c1f7	5a		phy				phy									; get the length
.c1f8	a0 00		ldy #$00			ldy 	#0
.c1fa	b1 22		lda ($22),y			lda 	(zTempStr),y
.c1fc	7a		ply				ply
.c1fd	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.c1ff	f0 0d		beq $c20e			beq 	_UHExit2
.c201	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.c203					_UHNonZero:
.c203	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c205	90 02		bcc $c209			bcc 	_UHDigit
.c207	69 06		adc #$06			adc 	#7-1
.c209					_UHDigit:
.c209	69 30		adc #$30			adc 	#48
.c20b	20 d7 c3	jsr $c3d7			jsr 	WriteTempString				; output to temp string.
.c20e					_UHExit2:
.c20e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.c20f					Unary_Dec:
.c20f	20 08 bd	jsr $bd08			jsr 	EvaluateStringX 			; string parameter
.c212	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.c215	5a		phy				phy
.c216	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.c218	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c21a	f0 43		beq $c25f			beq 	_UDFail 					; must fail if zero.
.c21c	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.c21f	a9 00		lda #$00			lda 	#0 							; set result to zero
.c221	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c223	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c225	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c227	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c229	a9 01		lda #$01			lda 	#1 							; set type to integer.
.c22b	95 85		sta $85,x			sta 	XS_Type,x
.c22d					_UDConvertLoop:
.c22d	5a		phy				phy 								; shift mantissa left 4
.c22e	a0 04		ldy #$04			ldy 	#4
.c230					_UDShift:
.c230	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.c232	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.c234	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.c236	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.c238	88		dey				dey
.c239	d0 f5		bne $c230			bne 	_UDShift
.c23b	7a		ply				ply
.c23c	c8		iny				iny 								; next character
.c23d	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.c23f	20 62 c2	jsr $c262			jsr 	ConvertUpper 				; convert to U/C
.c242	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.c244	90 19		bcc $c25f			bcc 	_UDFail
.c246	c9 3a		cmp #$3a			cmp 	#"9"+1
.c248	90 08		bcc $c252			bcc 	_UDOkay
.c24a	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.c24c	90 11		bcc $c25f			bcc 	_UDFail 					; fails if between 9 and @
.c24e	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.c250	b0 0d		bcs $c25f			bcs 	_UDFail
.c252					_UDOkay:
.c252	29 0f		and #$0f			and 	#15 						; nibble only
.c254	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.c256	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c258	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.c25b	d0 d0		bne $c22d			bne 	_UDConvertLoop
.c25d	7a		ply				ply
.c25e	60		rts				rts
.c25f					_UDFail:
.c25f	4c 97 ae	jmp $ae97			jmp 	BadParamError
.c262					ConvertUpper:
.c262	c9 61		cmp #$61			cmp 	#"a"
.c264	90 07		bcc $c26d			bcc 	_CUExit
.c266	c9 7b		cmp #$7b			cmp 	#"z"+1
.c268	b0 03		bcs $c26d			bcs 	_CUExit
.c26a	38		sec				sec
.c26b	e9 20		sbc #$20			sbc 	#32
.c26d	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.c26e					Unary_Chr:
.c26e	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.c271	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; right bracket.
.c274	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.c276	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c278	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c27a	d0 0d		bne $c289			bne 	_UCChar
.c27c	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.c27e	20 ac c3	jsr $c3ac			jsr 	AllocateTempString			; allocate it.
.c281	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.c283	20 d7 c3	jsr $c3d7			jsr 	WriteTempString
.c286	4c c7 c2	jmp $c2c7			jmp 	UnaryReturnTempStr 			; and return that string.
.c289					_UCChar:
.c289	4c 97 ae	jmp $ae97			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.c28c					Unary_Spc:
.c28c	20 a8 c1	jsr $c1a8			jsr 	SLIByteParameter 			; get number of spaces
.c28f	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; skip )
.c292	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.c294					UnarySpcCreate:
.c294	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.c296	b0 14		bcs $c2ac			bcs 	_USSize
.c298	48		pha				pha 								; save length
.c299	1a		inc a				inc 	a 							; allocate one more.
.c29a	20 ac c3	jsr $c3ac			jsr 	AllocateTempString
.c29d	68		pla				pla 								; get length
.c29e	f0 27		beq $c2c7			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.c2a0					_USLoop:
.c2a0	48		pha				pha
.c2a1	a9 20		lda #$20			lda 	#" "
.c2a3	20 d7 c3	jsr $c3d7			jsr 	WriteTempString
.c2a6	68		pla				pla
.c2a7	3a		dec a				dec 	a
.c2a8	d0 f6		bne $c2a0			bne 	_USLoop
.c2aa	80 1b		bra $c2c7			bra 	UnaryReturnTempStr 			; and return the temporary space.
.c2ac					_USSize:
.c2ac	4c 97 ae	jmp $ae97			jmp 	BadParamError
.c2af					Unary_Tab:
.c2af	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.c2b1	20 a8 c1	jsr $c1a8			jsr 	SLIByteParameter
.c2b4	20 5d c3	jsr $c35d			jsr 	CheckNextRParen
.c2b7	20 72 ae	jsr $ae72			jsr 	VIOCharGetPosition 			; were are we ?
.c2ba	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.c2bc	38		sec				sec
.c2bd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.c2bf	e5 10		sbc $10				sbc 	zTemp1
.c2c1	b0 d1		bcs $c294			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.c2c3	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.c2c5	80 cd		bra $c294			bra 	UnarySpcCreate
.c2c7					UnaryReturnTempStr:
.c2c7	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.c2c9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.c2cb	a5 23		lda $23				lda 	zTempStr+1
.c2cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c2cf	a9 02		lda #$02			lda 	#2 							; set type to string
.c2d1	95 85		sta $85,x			sta 	XS_Type,x
.c2d3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.c2d4	db		phz		MemRead:phz
.c2d5	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c2d8	a3 00		ldz #$00			ldz 	#0 							; start from here
.c2da	ea		nop		_MLoop1:nop
.c2db	b2 1c		lda ($1c),z			lda 	(zlTemp1),z 				; read the long address
.c2dd	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.c2df	1b		inz				inz 								; next to copy
.c2e0	e8		inx				inx
.c2e1	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c2e4	d0 f4		bne $c2da			bne 	_MLoop1
.c2e6	fb		plz				plz
.c2e7	60		rts				rts
.c2e8					MemWrite:
.c2e8	db		phz				phz
.c2e9	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.c2ec	a3 00		ldz #$00			ldz 	#0 							; start from here
.c2ee	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.c2f0	ea		nop				nop
.c2f1	92 1c		sta ($1c),z			sta 	(zlTemp1),z 				; write it out
.c2f3	1b		inz				inz 								; next to copy
.c2f4	e8		inx				inx
.c2f5	dc 9e 03	cpz $039e			cpz 	SignCount 					; do required # of bytes.
.c2f8	d0 f4		bne $c2ee			bne 	_MLoop1
.c2fa	fb		plz				plz
.c2fb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.c2fc					UpdateProgramEnd:
.c2fc	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c2fe	85 18		sta $18				sta 	zCodePtr+0
.c300	a9 80		lda #$80			lda 	#BasicProgram >> 8
.c302	85 19		sta $19				sta 	zCodePtr+1
.c304	a9 02		lda #$02			lda 	#2
.c306	85 1a		sta $1a				sta 	zCodePtr+2
.c308	a9 00		lda #$00			lda 	#0
.c30a	85 1b		sta $1b				sta 	zCodePtr+3
.c30c	a3 03		ldz #$03			ldz 	#3
.c30e					_UPDLoop:
.c30e	a3 00		ldz #$00			ldz 	#0
.c310	ea		nop				nop
.c311	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c313	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.c315	f0 10		beq $c327			beq 	_UPDFoundEnd
.c317	a3 00		ldz #$00			ldz 	#0 							; point to offset
.c319	ea		nop				nop
.c31a	b2 18		lda ($18),z			lda 	(zCodePtr),z 				; read it
.c31c	18		clc				clc
.c31d	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.c31f	85 18		sta $18				sta 	zCodePtr
.c321	90 02		bcc $c325			bcc 	_SNLNoCarry
.c323	e6 19		inc $19				inc 	zCodePtr+1
.c325					_SNLNoCarry:
.c325	80 e7		bra $c30e			bra 	_UPDLoop
.c327					_UPDFoundEnd:
.c327	18		clc				clc 								; end of program 2 on.
.c328	a5 18		lda $18				lda 	zCodePtr
.c32a	69 02		adc #$02			adc 	#2
.c32c	8d 04 03	sta $0304			sta 	endOfProgram
.c32f	a5 19		lda $19				lda 	zCodePtr+1
.c331	69 00		adc #$00			adc 	#0
.c333	8d 05 03	sta $0305			sta 	endOfProgram+1
.c336	a5 1a		lda $1a				lda 	zCodePtr+2
.c338	69 00		adc #$00			adc		#0
.c33a	8d 06 03	sta $0306			sta 	endOfProgram+2
.c33d	a5 1b		lda $1b				lda 	zCodePtr+3
.c33f	69 00		adc #$00			adc 	#0
.c341	8d 07 03	sta $0307			sta 	endOfProgram+3
.c344	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.c345					CheckNextToken:
.c345	ea		nop				nop
.c346	d2 18		cmp ($18),z			cmp 	(zCodePtr),z
.c348	d0 02		bne $c34c			bne 	CTFail 						; no, then fail
.c34a	1b		inz				inz
.c34b	60		rts				rts
.c34c					CTFail:
.c34c	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c34f	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>c357	74 6f 6b 65 6e 00
.c35d					CheckNextRParen:
.c35d	ea		nop				nop
.c35e	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c360	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.c362	d0 e8		bne $c34c			bne 	CTFail 						; fail if not
.c364	1b		inz				inz
.c365	60		rts				rts
.c366					CheckNextComma:
.c366	ea		nop				nop
.c367	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c369	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.c36b	d0 df		bne $c34c			bne 	CTFail 						; fail if not
.c36d	1b		inz				inz
.c36e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.c36f					StringConcrete:
.c36f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.c371	85 10		sta $10				sta 	zTemp1
.c373	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c375	85 11		sta $11				sta 	zTemp1+1
.c377	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.c379	b1 10		lda ($10),y			lda 	(zTemp1),y
.c37b	f0 26		beq $c3a3			beq		_SCEmpty 					; concreting it wastes memory.
.c37d	18		clc				clc 								; from the string pointer
.c37e	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.c381	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.c383	8d 00 03	sta $0300			sta 	StringPtr
.c386	85 12		sta $12				sta 	zTemp2
.c388	ad 01 03	lda $0301			lda 	StringPtr+1
.c38b	e9 00		sbc #$00			sbc 	#0
.c38d	8d 01 03	sta $0301			sta 	StringPtr+1
.c390	85 13		sta $13				sta 	zTemp2+1
.c392	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.c394	1a		inc a				inc 	a
.c395	aa		tax				tax
.c396	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.c398	91 12		sta ($12),y			sta 	(zTemp2),y
.c39a	c8		iny				iny
.c39b	ca		dex				dex
.c39c	d0 f8		bne $c396			bne 	_SCCopy
.c39e	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.c3a0	a6 12		ldx $12				ldx 	zTemp2
.c3a2	60		rts				rts
.c3a3					_SCEmpty:
.c3a3	a9 00		lda #$00			lda 	#0
.c3a5	85 27		sta $27				sta 	zNullString
.c3a7	a9 00		lda #$00			lda 	#zNullString >> 8
.c3a9	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.c3ab	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c3ac					AllocateTempString:
.c3ac	48		pha				pha 								; save required count.
.c3ad	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.c3af	d0 0b		bne $c3bc			bne 	_ATSInitialised
.c3b1	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c3b4	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.c3b6	ad 01 03	lda $0301			lda 	StringPtr+1
.c3b9	3a		dec a				dec 	a 							; allow the page.
.c3ba	85 23		sta $23				sta 	zTempStr+1
.c3bc					_ATSInitialised:
.c3bc	68		pla				pla 								; get required count back.
.c3bd	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.c3bf	1a		inc a				inc 	a
.c3c0	18		clc				clc
.c3c1	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.c3c3	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.c3c5	a9 ff		lda #$ff			lda 	#$FF
.c3c7	65 23		adc $23				adc 	zTempStr+1
.c3c9	85 23		sta $23				sta 	zTempStr+1
.c3cb	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.c3cd	5a		phy				phy
.c3ce	a8		tay				tay
.c3cf	91 22		sta ($22),y			sta 	(zTempStr),y
.c3d1	7a		ply				ply
.c3d2	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.c3d3	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.c3d6	60		rts				rts
.c3d7					WriteTempString:
.c3d7	5a		phy				phy 								; save Y
.c3d8	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.c3db	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.c3dd	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.c3e0	98		tya				tya 								; unchanged Y is now length
.c3e1	a0 00		ldy #$00			ldy 	#0
.c3e3	91 22		sta ($22),y			sta 	(zTempStr),y
.c3e5	7a		ply				ply 								; restore Y and exit
.c3e6	60		rts				rts
.c3e7					CreateTempStringCopy:
.c3e7	da		phx				phx 								; save X
.c3e8	ea		nop				nop
.c3e9	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c3eb	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c3ec	20 ac c3	jsr $c3ac			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c3ef	ea		nop				nop
.c3f0	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c3f2	1b		inz				inz
.c3f3	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.c3f4	3a		dec a				dec 	a 							; for the marker and the length.
.c3f5	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c3f7	81 22		sta ($22,x)			sta 	(zTempStr,x)
.c3f9	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.c3fb	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c3fd	f0 0f		beq $c40e			beq 	_CTSCExit
.c3ff					_CTSCLoop:
.c3ff	ea		nop				nop
.c400	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c402	1b		inz				inz
.c403	5a		phy				phy 								; save Y
.c404	e8		inx				inx 								; bump index
.c405	da		phx				phx 								; save that
.c406	7a		ply				ply 								; index into Y
.c407	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.c409	7a		ply				ply 								; restore Y
.c40a	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.c40c	d0 f1		bne $c3ff			bne 	_CTSCLoop
.c40e					_CTSCExit:
.c40e	fa		plx				plx 								; restore X
.c40f	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.c410					TokeniseKeyword:
.c410	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.c411	18		clc				clc
.c412	65 20		adc $20				adc 	zGenPtr
.c414	85 20		sta $20				sta 	zGenPtr
.c416	90 02		bcc $c41a			bcc 	_TKWNoBump
.c418	e6 21		inc $21				inc 	zGenPtr+1
.c41a					_TKWNoBump:
.c41a	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.c41c	da		phx				phx
.c41d	a9 ea		lda #$ea			lda 	#KeyWordText & $FF 			; scan this table.
.c41f	a2 af		ldx #$af			ldx 	#(KeyWordText >> 8) & $FF
.c421	20 2c c4	jsr $c42c			jsr 	TKWScanTokenTable
.c424	fa		plx				plx
.c425	90 04		bcc $c42b			bcc 	_TKWNoWrite
.c427	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.c42a	e8		inx				inx
.c42b					_TKWNoWrite:
.c42b	60		rts				rts
.c42c					TKWScanTokenTable:
.c42c	86 1d		stx $1d				stx 	zLTemp1+1
.c42e	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.c430	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.c432	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.c434	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c436	20 3a c5	jsr $c53a			jsr 	TOKCapitalise 					; save this in zTemp3
.c439	85 14		sta $14				sta 	zTemp3
.c43b	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.c43d	85 15		sta $15				sta 	zTemp3+1
.c43f					_TKWScanLoop:
.c43f	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c441	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.c443	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.c445	d0 26		bne $c46d			bne		_TKWNext 						; if it doesn't match, go to next.
.c447	20 8c c4	jsr $c48c			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.c44a	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.c44c					_TKWCompareFull:
.c44c	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c44e	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.c450	85 16		sta $16				sta 	zTemp4
.c452	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.c454	20 3a c5	jsr $c53a			jsr 	TOKCapitalise 					; make it U/C
.c457	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.c459	d0 12		bne $c46d			bne 	_TKWNext 						; failed, go to next slot.
.c45b	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c45d	c8		iny				iny 									; bump pointer
.c45e	0a		asl a				asl 	a 								; shift bit 7 into C
.c45f	90 eb		bcc $c44c			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.c461	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.c463	90 08		bcc $c46d			bcc 	_TKWNext 						; if shorter, the original was better
.c465	84 12		sty $12				sty 	zTemp2							; update longest match.
.c467	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.c469	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.c46b	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.c46d					_TKWNext:
.c46d	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c46f	c8		iny				iny 									; next one.
.c470	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.c471	90 fa		bcc $c46d			bcc 	_TKWNext
.c473	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.c475	98		tya				tya 									; has Y gone negative.
.c476	10 03		bpl $c47b			bpl 	_TKWNoYZero
.c478	20 8c c4	jsr $c48c			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.c47b					_TKWNoYZero:
.c47b	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.c47d	d0 c0		bne $c43f			bne 	_TKWScanLoop 					; if not, try the next one.
.c47f	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.c481	f0 05		beq $c488			beq 	_TKWFail 						; if zero, none found.
.c483	a8		tay				tay 									; return the token in zTemp2, length => y
.c484	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.c486	38		sec				sec
.c487	60		rts				rts
.c488					_TKWFail:
.c488	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.c48a	18		clc				clc
.c48b	60		rts				rts
.c48c					_TKWClearY:
.c48c	98		tya				tya
.c48d	18		clc				clc
.c48e	65 1c		adc $1c				adc 	zLTemp1
.c490	85 1c		sta $1c				sta 	zLTemp1
.c492	90 02		bcc $c496			bcc 	_TKWCNoBump
.c494	e6 1d		inc $1d				inc 	zLTemp1+1
.c496					_TKWCNoBump:
.c496	a0 00		ldy #$00			ldy 	#0
.c498	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.c499					TokeniseString:
.c499	85 20		sta $20				sta 	zGenPtr 					; save source
.c49b	86 21		stx $21				stx 	zGenPtr+1
.c49d	a0 00		ldy #$00			ldy 	#0 							; source
.c49f	a2 00		ldx #$00			ldx 	#0 							; target
.c4a1					_TSMainLoop:
.c4a1					_TSSkipSpaces:
.c4a1	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.c4a3	c8		iny				iny
.c4a4	c9 20		cmp #$20			cmp 	#" "
.c4a6	f0 f9		beq $c4a1			beq 	_TSSkipSpaces
.c4a8	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.c4aa	90 0a		bcc $c4b6			bcc 	_TSNotConstant
.c4ac	c9 3a		cmp #$3a			cmp 	#"9"+1
.c4ae	b0 06		bcs $c4b6			bcs 	_TSNotConstant
.c4b0	88		dey				dey 								; point back to start
.c4b1	20 d5 c5	jsr $c5d5			jsr 	TokeniseConstant 			; tokenise a constant
.c4b4	80 eb		bra $c4a1			bra 	_TSMainLoop			 		; and loop back.
.c4b6					_TSNotConstant:
.c4b6	c9 20		cmp #$20			cmp 	#32 						; end of line.
.c4b8	90 52		bcc $c50c			bcc 	_TSExit
.c4ba	c9 22		cmp #$22			cmp		#'"'						; quoted string
.c4bc	f0 55		beq $c513			beq 	_TSQuotedString
.c4be	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.c4c0	f0 56		beq $c518			beq 	_TSDecimal
.c4c2	20 3a c5	jsr $c53a			jsr 	TOKCapitalise 				; make U/C
.c4c5	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.c4c7	d0 05		bne $c4ce			bne 	_TSNoRemCheck
.c4c9	20 1d c5	jsr $c51d			jsr 	TOKCheckREM
.c4cc	b0 d3		bcs $c4a1			bcs 	_TSMainLoop 				; and if REM okay, go back.
.c4ce					_TSNoRemCheck:
.c4ce	88		dey				dey 								; point to character
.c4cf	20 10 c4	jsr $c410			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.c4d2	b0 cd		bcs $c4a1			bcs 	_TSMainLoop					; true if tokenised okay.
.c4d4	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.c4d6	20 3a c5	jsr $c53a			jsr 	TOKCapitalise
.c4d9	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.c4db	90 04		bcc $c4e1			bcc 	_TSSingle
.c4dd	c9 5b		cmp #$5b			cmp 	#"Z"+1
.c4df	90 0d		bcc $c4ee			bcc 	_TSAlphaNumeric
.c4e1					_TSSingle:
.c4e1	c8		iny				iny 								; skip over output
.c4e2	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.c4e4	09 80		ora #$80			ora 	#128
.c4e6	f0 b9		beq $c4a1			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.c4e8	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c4eb	e8		inx				inx
.c4ec	80 b3		bra $c4a1			bra 	_TSMainLoop
.c4ee					_TSAlphaNumeric:
.c4ee	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.c4f0	20 3a c5	jsr $c53a			jsr 	TOKCapitalise
.c4f3	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.c4f5	90 aa		bcc $c4a1			bcc 	_TSMainLoop
.c4f7	c9 3a		cmp #$3a			cmp 	#"9"+1
.c4f9	90 0a		bcc $c505			bcc 	_TSANOkay
.c4fb	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.c4fd	90 a2		bcc $c4a1			bcc 	_TSMainLoop
.c4ff	c9 5b		cmp #$5b			cmp 	#"Z"+1
.c501	b0 9e		bcs $c4a1			bcs 	_TSMainLoop
.c503	29 3f		and #$3f			and 	#63 						; write it out
.c505					_TSANOkay:
.c505	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c508	e8		inx				inx
.c509	c8		iny				iny
.c50a	80 e2		bra $c4ee			bra 	_TSAlphaNumeric
.c50c	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.c50e	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c511	8a		txa				txa 								; return length of tokenised line in bytes.
.c512	60		rts				rts
.c513					_TSQuotedString:
.c513	20 73 c5	jsr $c573			jsr 	TokeniseQuotedString
.c516	80 89		bra $c4a1			bra 	_TSMainLoop
.c518					_TSDecimal:
.c518	20 99 c5	jsr $c599			jsr 	TokeniseDecimalString
.c51b	80 84		bra $c4a1			bra 	_TSMainLoop
.c51d					TOKCheckREM:
.c51d	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.c51f	20 3a c5	jsr $c53a			jsr 	TOKCapitalise
.c522	c9 45		cmp #$45			cmp 	#"E"
.c524	d0 12		bne $c538			bne 	_TCRFail
.c526	c8		iny				iny
.c527	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.c529	88		dey				dey
.c52a	20 3a c5	jsr $c53a			jsr 	TOKCapitalise
.c52d	c9 4d		cmp #$4d			cmp 	#"M"
.c52f	d0 07		bne $c538			bne 	_TCRFail
.c531	c8		iny				iny									; point to first character
.c532	c8		iny				iny
.c533	20 45 c5	jsr $c545			jsr 	TokeniseREMString 			; tokenise REM
.c536	38		sec				sec
.c537	60		rts				rts
.c538					_TCRFail:
.c538	18		clc				clc
.c539	60		rts				rts
.c53a					TOKCapitalise:
.c53a	c9 61		cmp #$61			cmp 	#"a"
.c53c	90 06		bcc $c544			bcc 	_TOKCExit
.c53e	c9 7b		cmp #$7b			cmp 	#"z"+1
.c540	b0 02		bcs $c544			bcs 	_TOKCExit
.c542	49 20		eor #$20			eor 	#$20
.c544					_TOKCExit:
.c544	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.c545					TokeniseREMString:
.c545	86 10		stx $10				stx 	zTemp1 						; save position
.c547	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.c549	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c54c	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.c54f	e8		inx				inx 								; bump, and one space for the count.
.c550	e8		inx				inx
.c551					_TSRSkip:
.c551	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c553	c8		iny				iny
.c554	c9 20		cmp #$20			cmp 	#" "
.c556	f0 f9		beq $c551			beq 	_TSRSkip
.c558	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.c55a	f0 31		beq $c58d			beq 	SequenceExit 				; ... that's it.
.c55c					_TSRCopy:
.c55c	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.c55f	e8		inx				inx
.c560	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.c562	f0 05		beq $c569			beq 	_TSRExit 					; zero is exit
.c564	c8		iny				iny 								; bump pointer
.c565	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.c567	d0 f3		bne $c55c			bne 	_TSRCopy
.c569					_TSRExit:
.c569	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.c56c	c9 20		cmp #$20			cmp 	#" "
.c56e	d0 1d		bne $c58d			bne 	SequenceExit
.c570	ca		dex				dex 								; go back - will bump into $FE eventually.
.c571	80 f6		bra $c569			bra 	_TSRExit
.c573					TokeniseQuotedString:
.c573	86 10		stx $10				stx 	zTemp1 						; save position
.c575	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.c577	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c57a	e8		inx				inx 								; bump, and one space for the count.
.c57b	e8		inx				inx
.c57c					_TSQCopy:
.c57c	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c57e	c9 20		cmp #$20			cmp 	#" "
.c580	90 0b		bcc $c58d			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.c582	c8		iny				iny
.c583	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.c585	f0 06		beq $c58d			beq 	SequenceExit
.c587	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.c58a	e8		inx				inx
.c58b	80 ef		bra $c57c			bra 	_TSQCopy
.c58d					SequenceExit:
.c58d	8a		txa				txa 								; current position
.c58e	38		sec				sec 								; subtract start.
.c58f	e5 10		sbc $10				sbc 	zTemp1
.c591	da		phx				phx 								; copy that in
.c592	a6 10		ldx $10				ldx 	zTemp1
.c594	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.c597	fa		plx				plx
.c598	60		rts				rts
.c599					TokeniseDecimalString:
.c599	86 10		stx $10				stx 	zTemp1 						; save position
.c59b	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.c59d	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c5a0	e8		inx				inx 								; bump, and one space for the count.
.c5a1	e8		inx				inx
.c5a2	20 c3 c5	jsr $c5c3			jsr 	_TDSCopyNumber 				; copy a number.
.c5a5	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.c5a7	20 3a c5	jsr $c53a			jsr 	TOKCapitalise
.c5aa	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.c5ac	d0 df		bne $c58d			bne 	SequenceExit 				; exit now.
.c5ae	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.c5b1	e8		inx				inx
.c5b2	c8		iny				iny
.c5b3	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.c5b5	c9 2d		cmp #$2d			cmp 	#"-"
.c5b7	d0 05		bne $c5be			bne 	_TDSNoMinusExponent
.c5b9	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.c5bc	e8		inx				inx
.c5bd	c8		iny				iny
.c5be					_TDSNoMinusExponent:
.c5be	20 c3 c5	jsr $c5c3			jsr 	_TDSCopyNumber 				; do the exponent
.c5c1	80 ca		bra $c58d			bra 	SequenceExit
.c5c3					_TDSCopyNumber:
.c5c3	b1 20		lda ($20),y			lda 	(zGenPtr),y
.c5c5	c9 30		cmp #$30			cmp 	#"0"
.c5c7	90 0b		bcc $c5d4			bcc 	_TDSCNExit
.c5c9	c9 3a		cmp #$3a			cmp 	#"9"+1
.c5cb	b0 07		bcs $c5d4			bcs 	_TDSCNExit
.c5cd	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c5d0	e8		inx				inx
.c5d1	c8		iny				iny
.c5d2	80 ef		bra $c5c3			bra 	_TDSCopyNumber
.c5d4					_TDSCNExit:
.c5d4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.c5d5					TokeniseConstant:
.c5d5	da		phx				phx 								; save X
.c5d6	a2 00		ldx #$00			ldx 	#0
.c5d8	20 b1 cb	jsr $cbb1			jsr 	IntFromStringY 				; get the integer out.
.c5db	b0 37		bcs $c614			bcs 	_TCQ 						; should not happen.
.c5dd	fa		plx				plx 								; restore X.
.c5de	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.c5e0	85 10		sta $10				sta 	zTemp1
.c5e2					_TCRotate:
.c5e2	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.c5e4	29 c0		and #$c0			and 	#$C0
.c5e6	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.c5e8	05 82		ora $82				ora 	XS_Mantissa+2
.c5ea	05 83		ora $83				ora 	XS_Mantissa+3
.c5ec	f0 16		beq $c604			beq 	_TCDone						; if so, at the bottom.
.c5ee	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.c5f0	29 3f		and #$3f			and 	#$3F
.c5f2	48		pha				pha
.c5f3	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.c5f5	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.c5f7					_TCShiftRight:
.c5f7	46 83		lsr $83				lsr 	XS_Mantissa+3
.c5f9	66 82		ror $82				ror 	XS_Mantissa+2
.c5fb	66 81		ror $81				ror 	XS_Mantissa+1
.c5fd	66 80		ror $80				ror 	XS_Mantissa+0
.c5ff	3a		dec a				dec 	a
.c600	d0 f5		bne $c5f7			bne 	_TCShiftRight
.c602	80 de		bra $c5e2			bra 	_TCRotate 					; and go round again.
.c604	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.c606					_TCWrite:
.c606	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.c608	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.c60b	e8		inx				inx
.c60c	c6 10		dec $10				dec 	zTemp1 						; done all of them
.c60e	30 03		bmi $c613			bmi 	_TCExit 					; no , more to pop
.c610	68		pla				pla
.c611	80 f3		bra $c606			bra 	_TCWrite 					; until everything's off.
.c613					_TCExit:
.c613	60		rts				rts
.c614					_TCQ:
.c614	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c617	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.c61a					VariableFind:
.c61a	20 85 c6	jsr $c685			jsr 	VariableExtract 		; find out all about it ....
.c61d	20 20 c9	jsr $c920			jsr 	VariableLocate 			; does it already exist ?
.c620	b0 03		bcs $c625			bcs 	_VFExists 				; if so, use that.
.c622	20 13 c7	jsr $c713			jsr 	VariableCreate 			; otherwise create it.
.c625					_VFExists:
.c625	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.c627	29 01		and #$01			and 	#1
.c629	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c62b	d0 28		bne $c655			bne 	_VFSingleElement
.c62d					_VFNextIndex:
.c62d	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.c62f	48		pha				pha
.c630	a5 25		lda $25				lda 	zVarDataPtr+1
.c632	48		pha				pha
.c633	a5 26		lda $26				lda 	zVarType
.c635	48		pha				pha
.c636	20 ff bc	jsr $bcff			jsr 	EvaluateIntegerX 		; calculate the index.
.c639	68		pla				pla 							; restore and index.
.c63a	85 26		sta $26				sta 	zVarType
.c63c	68		pla				pla
.c63d	85 25		sta $25				sta 	zVarDataPtr+1
.c63f	68		pla				pla
.c640	85 24		sta $24				sta 	zVarDataPtr
.c642	20 9e c7	jsr $c79e			jsr 	ArrayIndexFollow 		; do the index.
.c645	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.c647	29 01		and #$01			and 	#1
.c649	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.c64b	d0 05		bne $c652			bne 	_VFArrayDone 			; if so then exit.
.c64d	20 66 c3	jsr $c366			jsr 	CheckNextComma 			; comma should follow
.c650	80 db		bra $c62d			bra 	_VFNextIndex
.c652					_VFArrayDone:
.c652	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 		; check closing right bracket.
.c655					_VFSingleElement:
.c655	60		rts				rts
.c656					VariableClear:
.c656	48		pha				pha 							; save registers
.c657	da		phx				phx
.c658	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.c65a	8a		txa				txa
.c65b	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.c65e	e8		inx				inx
.c65f	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.c661	d0 f8		bne $c65b			bne 	_VCLoop
.c663	a9 00		lda #$00			lda 	#VariableMemory & $FF
.c665	8d 02 03	sta $0302			sta 	VarMemPtr
.c668	a9 20		lda #$20			lda 	#VariableMemory >> 8
.c66a	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c66d	fa		plx				plx 							; restore registers
.c66e	68		pla				pla
.c66f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.c670					VariableNameError:
.c670	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c673	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>c67b	61 62 6c 65 20 4e 61 6d 65 00
.c685					VariableExtract:
.c685	da		phx				phx 							; save X.
.c686	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.c688	8d 95 03	sta $0395			sta 	Var_Type
.c68b	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.c68e	ea		nop				nop
.c68f	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c691	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.c693	f0 db		beq $c670			beq 	VariableNameError
.c695	c9 1b		cmp #$1b			cmp 	#26+1
.c697	b0 d7		bcs $c670			bcs 	VariableNameError
.c699	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.c69b					_VECopyBuffer:
.c69b	e8		inx				inx
.c69c	e0 1f		cpx #$1f			cpx 	#31 					; too long
.c69e	f0 d0		beq $c670			beq 	VariableNameError
.c6a0	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.c6a3	18		clc				clc  							; update the hash value for it.
.c6a4	6d 96 03	adc $0396			adc 	Var_Hash
.c6a7	8d 96 03	sta $0396			sta 	Var_Hash
.c6aa	1b		inz				inz
.c6ab	ea		nop				nop
.c6ac	b2 18		lda ($18),z			lda 	(zCodePtr),z
.c6ae	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.c6b0	f0 0e		beq $c6c0			beq 	_VECopyEnd
.c6b2	30 0c		bmi $c6c0			bmi 	_VECopyEnd
.c6b4	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.c6b6	90 e3		bcc $c69b			bcc 	_VECopyBuffer
.c6b8	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.c6ba	90 04		bcc $c6c0			bcc 	_VECopyEnd
.c6bc	c9 3a		cmp #$3a			cmp 	#"9"+1
.c6be	90 db		bcc $c69b			bcc 	_VECopyBuffer
.c6c0					_VECopyEnd:
.c6c0	1b		inz				inz
.c6c1	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.c6c3	90 04		bcc $c6c9			bcc 	_VEDefaultRequired
.c6c5	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.c6c7	90 0b		bcc $c6d4			bcc 	_VEHaveType
.c6c9					_VEDefaultRequired:
.c6c9	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.c6cb	f0 04		beq $c6d1			beq 	_VESetType 				; default set above.
.c6cd	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.c6d0	3b		dez				dez
.c6d1					_VESetType:
.c6d1	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.c6d4					_VEHaveType:
.c6d4	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.c6d7	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.c6da	09 80		ora #$80			ora 	#$80
.c6dc	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.c6df	e8		inx				inx 							; offset 3 => length 4.
.c6e0	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.c6e3	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.c6e6	38		sec				sec
.c6e7	e9 b7		sbc #$b7			sbc 	#token_Dollar
.c6e9	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.c6ea	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.c6eb	0a		asl a				asl 	a
.c6ec	0a		asl a				asl 	a
.c6ed	8d 98 03	sta $0398			sta 	Var_HashAddress
.c6f0	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.c6f3	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.c6f5	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.c6f6	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.c6f9	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.c6fb	8d 98 03	sta $0398			sta 	Var_HashAddress
.c6fe	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.c700	ad 95 03	lda $0395			lda 	Var_Type
.c703	c9 b9		cmp #$b9			cmp 	#token_Hash
.c705	f0 07		beq $c70e			beq 	_VEHaveSize
.c707	ca		dex				dex
.c708	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.c70a	f0 02		beq $c70e			beq 	_VEHaveSize
.c70c	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.c70e					_VEHaveSize:
.c70e	8e 99 03	stx $0399			stx 	Var_DataSize
.c711	fa		plx				plx
.c712	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.c713					VariableCreate:
.c713	da		phx				phx
.c714	5a		phy				phy
.c715	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.c718	85 10		sta $10				sta 	zTemp1
.c71a	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c71d	85 11		sta $11				sta 	zTemp1+1
.c71f	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.c722	18		clc				clc
.c723	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.c726	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.c728	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.c72b	8d 02 03	sta $0302			sta 	VarMemPtr
.c72e	90 03		bcc $c733			bcc 	_VCNoCarry
.c730	ee 03 03	inc $0303			inc 	VarMemPtr+1
.c733					_VCNoCarry:
.c733	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c736	85 12		sta $12				sta 	zTemp2
.c738	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c73a	85 13		sta $13				sta 	zTemp2+1
.c73c	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.c73e	b1 12		lda ($12),y			lda 	(zTemp2),y
.c740	91 10		sta ($10),y			sta 	(zTemp1),y
.c742	c8		iny				iny
.c743	b1 12		lda ($12),y			lda 	(zTemp2),y
.c745	91 10		sta ($10),y			sta 	(zTemp1),y
.c747	c8		iny				iny
.c748	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.c74b	91 10		sta ($10),y			sta 	(zTemp1),y
.c74d	c8		iny				iny
.c74e	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.c750					_VCCopyName:
.c750	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.c753	91 10		sta ($10),y			sta 	(zTemp1),y
.c755	e8		inx				inx
.c756	c8		iny				iny
.c757	ec 97 03	cpx $0397			cpx 	Var_Length
.c75a	d0 f4		bne $c750			bne 	_VCCopyName
.c75c	5a		phy				phy 								; save the data offset.
.c75d	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.c760	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.c762					_VCClearData:
.c762	91 10		sta ($10),y			sta 	(zTemp1),y
.c764	c8		iny				iny
.c765	ca		dex				dex
.c766	d0 fa		bne $c762			bne 	_VCClearData
.c768	68		pla				pla 								; offset to the data
.c769	18		clc				clc
.c76a	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.c76c	85 24		sta $24				sta 	zVarDataPtr
.c76e	a5 11		lda $11				lda 	zTemp1+1
.c770	69 00		adc #$00			adc 	#0
.c772	85 25		sta $25				sta 	zVarDataPtr+1
.c774	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c777	85 26		sta $26				sta 	zVarType
.c779	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.c77b	a0 00		ldy #$00			ldy 	#0
.c77d	91 12		sta ($12),y			sta 	(zTemp2),y
.c77f	c8		iny				iny
.c780	a5 11		lda $11				lda 	zTemp1+1
.c782	91 12		sta ($12),y			sta 	(zTemp2),y
.c784	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.c787	29 01		and #$01			and 	#1
.c789	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.c78b	d0 0e		bne $c79b			bne 	_VCNotArray
.c78d	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.c78f	20 35 c8	jsr $c835			jsr 	ArrayCreate
.c792	5a		phy				phy 								; save YA at zVarDataPtr
.c793	a0 00		ldy #$00			ldy 	#0
.c795	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c797	c8		iny				iny
.c798	68		pla				pla
.c799	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c79b					_VCNotArray:
.c79b	7a		ply				ply
.c79c	fa		plx				plx
.c79d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.c79e					ArrayIndexFollow:
.c79e	5a		phy				phy
.c79f	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.c7a1	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.c7a3	48		pha				pha
.c7a4	c8		iny				iny
.c7a5	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c7a7	85 25		sta $25				sta 	zVarDataPtr+1
.c7a9	68		pla				pla
.c7aa	85 24		sta $24				sta 	zVarDataPtr
.c7ac	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.c7ae	29 80		and #$80			and 	#$80 						; must be zero.
.c7b0	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.c7b2	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.c7b4	d0 59		bne $c80f			bne 	_AIFError
.c7b6	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.c7b8	18		clc				clc
.c7b9	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c7bb	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.c7bd	c8		iny				iny
.c7be	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c7c0	08		php				php 								; clear bit 7 retaining borrow.
.c7c1	29 7f		and #$7f			and 	#$7F
.c7c3	28		plp				plp
.c7c4	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.c7c6	90 47		bcc $c80f			bcc 	_AIFError 					; eror if size-current < 0
.c7c8	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.c7ca	0a		asl a				asl 	a 							; (e.g. index * 2)
.c7cb	85 10		sta $10				sta 	zTemp1
.c7cd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c7cf	2a		rol a				rol 	a
.c7d0	85 11		sta $11				sta 	zTemp1+1
.c7d2	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.c7d4	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.c7d6	30 1d		bmi $c7f5			bmi 	_AIFCalculate
.c7d8	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.c7da	a5 26		lda $26				lda 	zVarType 					; check that type
.c7dc	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.c7de	f0 15		beq $c7f5			beq 	_AIFCalculate
.c7e0	06 10		asl $10				asl 	zTemp1			 			; double the index
.c7e2	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.c7e4	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.c7e6	f0 0d		beq $c7f5			beq 	_AIFCalculate
.c7e8	18		clc				clc 								; add the original mantissa in again
.c7e9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.c7eb	65 10		adc $10				adc 	zTemp1
.c7ed	85 10		sta $10				sta 	zTemp1
.c7ef	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c7f1	65 11		adc $11				adc 	zTemp1+1
.c7f3	85 11		sta $11				sta 	zTemp1+1
.c7f5					_AIFCalculate:
.c7f5	18		clc				clc 								; add index x 2,4 or 5 to base
.c7f6	a5 24		lda $24				lda 	zVarDataPtr
.c7f8	65 10		adc $10				adc 	zTemp1
.c7fa	85 24		sta $24				sta 	zVarDataPtr
.c7fc	a5 25		lda $25				lda 	zVarDataPtr+1
.c7fe	65 11		adc $11				adc 	zTemp1+1
.c800	85 25		sta $25				sta 	zVarDataPtr+1
.c802	18		clc				clc 								; add 2 more for the length prefix.
.c803	a5 24		lda $24				lda 	zVarDataPtr
.c805	69 02		adc #$02			adc 	#2
.c807	85 24		sta $24				sta 	zVarDataPtr
.c809	90 02		bcc $c80d			bcc 	_AIFNoBump
.c80b	e6 25		inc $25				inc 	zVarDataPtr+1
.c80d					_AIFNoBump:
.c80d	7a		ply				ply
.c80e	60		rts				rts
.c80f					_AIFError:
.c80f	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c812	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c81a	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.c822					ArrayResetDefault:
.c822	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.c824	8d a9 03	sta $03a9			sta 	ArrayDef+0
.c827	a9 00		lda #$00			lda 	#0
.c829	8d aa 03	sta $03aa			sta 	ArrayDef+1
.c82c	a9 ff		lda #$ff			lda 	#$FF
.c82e	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.c831	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.c834	60		rts				rts
.c835					ArrayCreate:
.c835	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.c838	0a		asl a				asl 	a
.c839	85 10		sta $10				sta 	zTemp1
.c83b	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c83e	2a		rol a				rol 	a
.c83f	85 11		sta $11				sta 	zTemp1+1
.c841	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.c844	10 22		bpl $c868			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.c846	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.c849	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.c84b	f0 1b		beq $c868			beq 	_ACSized
.c84d	06 10		asl $10				asl 	zTemp1 						; double again
.c84f	26 11		rol $11				rol 	zTemp1+1
.c851	b0 6f		bcs $c8c2			bcs 	ArrayIndexError 			; too large.
.c853	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.c855	f0 11		beq $c868			beq 	_ACSized
.c857	18		clc				clc 								; add original value x 5 for reals.
.c858	a5 10		lda $10				lda 	zTemp1
.c85a	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.c85d	85 10		sta $10				sta 	zTemp1
.c85f	a5 11		lda $11				lda 	zTemp1+1
.c861	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.c864	85 11		sta $11				sta 	zTemp1+1
.c866	b0 5a		bcs $c8c2			bcs 	ArrayIndexError
.c868					_ACSized:
.c868	18		clc				clc
.c869	a5 10		lda $10				lda 	zTemp1
.c86b	69 02		adc #$02			adc 	#2
.c86d	85 10		sta $10				sta 	zTemp1
.c86f	90 04		bcc $c875			bcc 	_ACNoBump
.c871	e6 10		inc $10				inc 	zTemp1
.c873	f0 4d		beq $c8c2			beq 	ArrayIndexError
.c875					_ACNoBump:
.c875	18		clc				clc
.c876	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.c879	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.c87b	85 14		sta $14				sta 	zTemp3
.c87d	65 10		adc $10				adc 	zTemp1
.c87f	8d 02 03	sta $0302			sta 	VarMemPtr
.c882	ad 03 03	lda $0303			lda 	VarMemPtr+1
.c885	85 13		sta $13				sta 	zTemp2+1
.c887	85 15		sta $15				sta 	zTemp3+1
.c889	65 11		adc $11				adc 	zTemp1+1
.c88b	8d 03 03	sta $0303			sta 	VarMemPtr+1
.c88e	85 11		sta $11				sta 	zTemp1+1
.c890	b0 30		bcs $c8c2			bcs 	ArrayIndexError
.c892	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.c894					_ACClear:
.c894	98		tya				tya
.c895	91 12		sta ($12),y			sta 	(zTemp2),y
.c897	e6 12		inc $12				inc 	zTemp2
.c899	d0 02		bne $c89d			bne 	_ACCBump
.c89b	e6 13		inc $13				inc 	zTemp2+1
.c89d					_ACCBump:
.c89d	a5 12		lda $12				lda 	zTemp2
.c89f	cd 02 03	cmp $0302			cmp 	VarMemPtr
.c8a2	d0 f0		bne $c894			bne 	_ACClear
.c8a4	a5 13		lda $13				lda 	zTemp2+1
.c8a6	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.c8a9	d0 e9		bne $c894			bne 	_ACClear
.c8ab	a0 00		ldy #$00			ldy 	#0
.c8ad	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.c8b0	91 14		sta ($14),y			sta 	(zTemp3),y
.c8b2	c8		iny				iny
.c8b3	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.c8b6	91 14		sta ($14),y			sta 	(zTemp3),y
.c8b8	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.c8bb	10 18		bpl $c8d5			bpl 	ACCFillRecursive
.c8bd	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.c8bf	a5 14		lda $14				lda 	zTemp3
.c8c1	60		rts				rts
.c8c2					ArrayIndexError:
.c8c2	20 a8 ae	jsr $aea8			jsr ERR_Handler
>c8c5	42 61 64 20 61 72 72 61			.text "Bad array index",0
>c8cd	79 20 69 6e 64 65 78 00
.c8d5					ACCFillRecursive:
.c8d5	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.c8d7	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.c8d9	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.c8db	c8		iny				iny
.c8dc	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.c8de	09 80		ora #$80			ora 	#$80 						; an array of pointers
.c8e0	91 14		sta ($14),y			sta 	(zTemp3),y
.c8e2	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.c8e4	48		pha				pha
.c8e5	a5 15		lda $15				lda 	zTemp3+1
.c8e7	48		pha				pha
.c8e8					_ACCFillLoop:
.c8e8	18		clc				clc
.c8e9	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.c8eb	69 02		adc #$02			adc 	#2
.c8ed	85 14		sta $14				sta 	zTemp3
.c8ef	90 02		bcc $c8f3			bcc 	_ACCSkip2
.c8f1	e6 15		inc $15				inc 	zTemp3+1
.c8f3					_ACCSkip2:
.c8f3	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.c8f5	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.c8f7	c8		iny				iny
.c8f8	11 14		ora ($14),y			ora 	(zTemp3),y
.c8fa	d0 21		bne $c91d			bne 	_ACCExit
.c8fc	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.c8fe	48		pha				pha
.c8ff	a5 15		lda $15				lda 	zTemp3+1
.c901	48		pha				pha
.c902	e8		inx				inx
.c903	e8		inx				inx
.c904	20 35 c8	jsr $c835			jsr 	ArrayCreate 				; create array recursively.
.c907	ca		dex				dex
.c908	ca		dex				dex
.c909	85 12		sta $12				sta 	zTemp2 						; save A
.c90b	68		pla				pla
.c90c	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.c90e	68		pla				pla
.c90f	85 14		sta $14				sta 	zTemp3
.c911	98		tya				tya 								; write high bye from Y
.c912	a0 01		ldy #$01			ldy 	#1
.c914	91 14		sta ($14),y			sta 	(zTemp3),y
.c916	88		dey				dey 								; write low byte out.
.c917	a5 12		lda $12				lda 	zTemp2
.c919	91 14		sta ($14),y			sta 	(zTemp3),y
.c91b	80 cb		bra $c8e8			bra 	_ACCFillLoop 				; and try again.
.c91d					_ACCExit:
.c91d	7a		ply				ply 								; restore the original address
.c91e	68		pla				pla
.c91f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.c920					VariableLocate:
.c920	da		phx				phx
.c921	5a		phy				phy
.c922	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.c925	85 12		sta $12				sta 	zTemp2 						; points to first address.
.c927	a9 03		lda #$03			lda 	#HashTableBase >> 8
.c929	85 13		sta $13				sta 	zTemp2+1
.c92b	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.c92d	b1 12		lda ($12),y			lda 	(zTemp2),y
.c92f	aa		tax				tax
.c930	c8		iny				iny
.c931	b1 12		lda ($12),y			lda 	(zTemp2),y
.c933	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.c935	86 12		stx $12				stx 	zTemp2
.c937	05 12		ora $12				ora 	zTemp2 						; got zero
.c939	18		clc				clc
.c93a	f0 25		beq $c961			beq 	_VLExit 					; if so, then fail as end of chain.
.c93c	c8		iny				iny 								; point to hash (offset + 2)
.c93d	b1 12		lda ($12),y			lda 	(zTemp2),y
.c93f	cd 96 03	cmp $0396			cmp 	Var_Hash
.c942	d0 e7		bne $c92b			bne 	_VLNext 					; try next if different.
.c944					_VLCompare:
.c944	c8		iny				iny 								; next character
.c945	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.c947	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.c94a	d0 df		bne $c92b			bne 	_VLNext 					; fail if different, try next.
.c94c	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.c94d	90 f5		bcc $c944			bcc 	_VLCompare
.c94f	98		tya				tya
.c950	38		sec				sec 								; add 1 as Y points to last character
.c951	65 12		adc $12				adc 	zTemp2 						; add to the current address
.c953	85 24		sta $24				sta 	zVarDataPtr
.c955	a5 13		lda $13				lda 	zTemp2+1
.c957	69 00		adc #$00			adc 	#0
.c959	85 25		sta $25				sta 	zVarDataPtr+1
.c95b	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.c95e	85 26		sta $26				sta 	zVarType
.c960	38		sec				sec 								; return CS
.c961	7a		ply		_VLExit:ply
.c962	fa		plx				plx
.c963	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.c964					VariableGet:
.c964	5a		phy				phy
.c965	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.c967	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c969	95 80		sta $80,x			sta 	XS_Mantissa,x
.c96b	c8		iny				iny
.c96c	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c96e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.c970	c8		iny				iny
.c971	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.c973	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c975	f0 2c		beq $c9a3			beq 	_VGString
.c977	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.c979	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.c97b	c8		iny				iny
.c97c	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.c97e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.c980	c8		iny				iny
.c981	a9 01		lda #$01			lda 	#1 							; set type to 1.
.c983	95 85		sta $85,x			sta 	XS_Type,x
.c985	a5 26		lda $26				lda 	zVarType
.c987	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.c989	f0 28		beq $c9b3			beq 	_VGExit
.c98b	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.c98d	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.c98f	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.c991	95 84		sta $84,x			sta 	XS_Exponent,x
.c993	f0 1e		beq $c9b3			beq 	_VGExit 					; if exponent is zero ... it's zero.
.c995	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.c997	48		pha				pha
.c998	29 80		and #$80			and 	#$80
.c99a	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.c99c	68		pla				pla
.c99d	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.c99f	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.c9a1	80 10		bra $c9b3			bra 	_VGExit
.c9a3					_VGString:
.c9a3	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.c9a5	95 85		sta $85,x			sta 	XS_Type,x
.c9a7	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.c9a9	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.c9ab	d0 06		bne $c9b3			bne 	_VGExit 					; if not, exit.
.c9ad	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.c9af	a9 27		lda #$27			lda 	#zNullString
.c9b1	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.c9b3					_VGExit:
.c9b3	7a		ply				ply
.c9b4	60		rts				rts
.c9b5					VariableSet:
.c9b5	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.c9b7	29 02		and #$02			and 	#2 							; if so, it has to be
.c9b9	d0 4b		bne $ca06			bne 	_VSString
.c9bb	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.c9bd	c9 b7		cmp #$b7			cmp 	#token_Dollar
.c9bf	f0 42		beq $ca03			beq 	_VSBadType
.c9c1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.c9c3	f0 05		beq $c9ca			beq 	_VSMakeInt
.c9c5	20 29 cf	jsr $cf29			jsr 	FPUToFloat
.c9c8	80 03		bra $c9cd			bra 	_VSCopy
.c9ca					_VSMakeInt:
.c9ca	20 75 cf	jsr $cf75			jsr 	FPUToInteger
.c9cd					_VSCopy:
.c9cd	5a		phy				phy
.c9ce	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.c9d0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.c9d2	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c9d4	c8		iny				iny
.c9d5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.c9d7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c9d9	c8		iny				iny
.c9da	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.c9dc	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c9de	c8		iny				iny
.c9df	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.c9e1	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c9e3	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.c9e5	c9 bb		cmp #$bb			cmp 	#token_Percent
.c9e7	f0 18		beq $ca01			beq 	_VSExit
.c9e9	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.c9eb	0a		asl a				asl 	a
.c9ec	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.c9ee	08		php				php
.c9ef	0a		asl a				asl 	a
.c9f0	28		plp				plp
.c9f1	6a		ror a				ror 	a
.c9f2	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c9f4	c8		iny				iny
.c9f5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.c9f7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.c9f9	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.c9fb	50 04		bvc $ca01			bvc 	_VSExit
.c9fd	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.c9ff	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca01					_VSExit:
.ca01	7a		ply				ply
.ca02	60		rts				rts
.ca03					_VSBadType:
.ca03	4c 89 ae	jmp $ae89			jmp 	TypeError
.ca06					_VSString:
.ca06	a5 26		lda $26				lda 	zVarType 					; type must be $
.ca08	c9 b7		cmp #$b7			cmp 	#token_Dollar
.ca0a	d0 f7		bne $ca03			bne 	_VSBadType
.ca0c	da		phx				phx
.ca0d	5a		phy				phy
.ca0e	20 6f c3	jsr $c36f			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.ca11	a0 01		ldy #$01			ldy 	#1 							; save high byte
.ca13	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca15	88		dey				dey 								; save low byte
.ca16	8a		txa				txa
.ca17	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.ca19	7a		ply				ply 								; and exit.
.ca1a	fa		plx				plx
.ca1b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.ca1c					MulInteger32:
.ca1c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.ca1e	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.ca20	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.ca22	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.ca24	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ca26	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.ca28	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ca2a	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.ca2c	a9 00		lda #$00			lda 	#0
.ca2e	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.ca30	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.ca32	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ca34	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ca36					_BFMMultiply:
.ca36	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.ca38	29 01		and #$01			and 	#1
.ca3a	f0 03		beq $ca3f			beq 	_BFMNoAdd
.ca3c	20 9f be	jsr $be9f			jsr 	AddInteger32 					; co-opt this code
.ca3f					_BFMNoAdd:
.ca3f	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.ca41	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.ca43	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.ca45	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.ca47	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.ca49	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.ca4b	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.ca4d	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.ca4f	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.ca51	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.ca53	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.ca55	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.ca57	d0 dd		bne $ca36			bne 	_BFMMultiply
.ca59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.ca5a					DivInteger32:
.ca5a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.ca5c	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.ca5e	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.ca60	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.ca62	d0 14		bne $ca78			bne 	_BFDOkay
.ca64	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ca67	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>ca6f	20 62 79 20 5a 65 72 6f 00
.ca78					_BFDOkay:
.ca78	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.ca7a	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.ca7c	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.ca7e	85 1e		sta $1e				sta 	zLTemp1+2
.ca80	85 1f		sta $1f				sta 	zLTemp1+3
.ca82	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.ca85	20 dc ca	jsr $cadc			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ca88	da		phx				phx
.ca89	e8		inx				inx
.ca8a	e8		inx				inx
.ca8b	e8		inx				inx
.ca8c	e8		inx				inx
.ca8d	e8		inx				inx
.ca8e	e8		inx				inx
.ca8f	20 dc ca	jsr $cadc			jsr 	CheckIntegerNegate
.ca92	fa		plx				plx
.ca93	5a		phy				phy 								; Y is the counter
.ca94	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ca96					_BFDLoop:
.ca96	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.ca98	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.ca9a	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.ca9c	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.ca9e	26 1c		rol $1c				rol 	zLTemp1
.caa0	26 1d		rol $1d				rol 	zLTemp1+1
.caa2	26 1e		rol $1e				rol 	zLTemp1+2
.caa4	26 1f		rol $1f				rol 	zLTemp1+3
.caa6	38		sec				sec
.caa7	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.caa9	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.caab	48		pha				pha
.caac	a5 1d		lda $1d				lda 	zLTemp1+1
.caae	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cab0	48		pha				pha
.cab1	a5 1e		lda $1e				lda 	zLTemp1+2
.cab3	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.cab5	48		pha				pha
.cab6	a5 1f		lda $1f				lda 	zLTemp1+3
.cab8	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.caba	90 13		bcc $cacf			bcc 	_BFDNoAdd
.cabc	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.cabe	68		pla				pla
.cabf	85 1e		sta $1e				sta 	zLTemp1+2
.cac1	68		pla				pla
.cac2	85 1d		sta $1d				sta 	zLTemp1+1
.cac4	68		pla				pla
.cac5	85 1c		sta $1c				sta 	zLTemp1+0
.cac7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.cac9	09 01		ora #$01			ora 	#1
.cacb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cacd	80 03		bra $cad2			bra 	_BFDNext
.cacf					_BFDNoAdd:
.cacf	68		pla				pla 								; Throw away the intermediate calculations
.cad0	68		pla				pla
.cad1	68		pla				pla
.cad2					_BFDNext:
.cad2	88		dey				dey
.cad3	d0 c1		bne $ca96			bne 	_BFDLoop
.cad5	7a		ply				ply 								; restore Y
.cad6	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.cad9	b0 06		bcs $cae1			bcs		IntegerNegateAlways 		; negate the result
.cadb	60		rts				rts
.cadc					CheckIntegerNegate:
.cadc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.cade	30 01		bmi $cae1			bmi 	IntegerNegateAlways 		; if so negate it
.cae0	60		rts				rts
.cae1					IntegerNegateAlways:
.cae1	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.cae4	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.cae5	a9 00		lda #$00			lda 	#0
.cae7	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.cae9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.caeb	a9 00		lda #$00			lda 	#0
.caed	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.caef	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.caf1	a9 00		lda #$00			lda 	#0
.caf3	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.caf5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.caf7	a9 00		lda #$00			lda 	#0
.caf9	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.cafb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cafd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.cafe					INTToString:
.cafe	48		pha				pha
.caff	5a		phy				phy
.cb00	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.cb02	10 08		bpl $cb0c			bpl 		_ITSNotMinus
.cb04	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cb06	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter
.cb09	20 e1 ca	jsr $cae1			jsr 		IntegerNegateAlways 	; negate the number.
.cb0c					_ITSNotMinus:
.cb0c	a9 00		lda #$00			lda 		#0
.cb0e	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.cb11	8a		txa				txa 								; use Y for the mantissa index.
.cb12	a8		tay				tay
.cb13	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.cb15					_ITSNextSubtractor:
.cb15	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.cb17	8d 9b 03	sta $039b			sta 		NumConvCount
.cb1a					_ITSSubtract:
.cb1a	38		sec				sec
.cb1b	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.cb1e	fd 78 cb	sbc $cb78,x			sbc 		_ITSSubtractors+0,x
.cb21	48		pha				pha
.cb22	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.cb25	fd 79 cb	sbc $cb79,x			sbc 		_ITSSubtractors+1,x
.cb28	48		pha				pha
.cb29	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.cb2c	fd 7a cb	sbc $cb7a,x			sbc 		_ITSSubtractors+2,x
.cb2f	48		pha				pha
.cb30	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.cb33	fd 7b cb	sbc $cb7b,x			sbc 		_ITSSubtractors+3,x
.cb36	90 14		bcc $cb4c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.cb38	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.cb3b	68		pla				pla
.cb3c	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.cb3f	68		pla				pla
.cb40	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.cb43	68		pla				pla
.cb44	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.cb47	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.cb4a	80 ce		bra $cb1a			bra 		_ITSSubtract 			; go round again.
.cb4c					_ITSCantSubtract:
.cb4c	68		pla				pla 								; throw away interim answers
.cb4d	68		pla				pla
.cb4e	68		pla				pla
.cb4f	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.cb52	c9 30		cmp #$30			cmp 		#"0"
.cb54	d0 05		bne $cb5b			bne 		_ITSOutputDigit
.cb56	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.cb59	10 09		bpl $cb64			bpl	 		_ITSGoNextSubtractor
.cb5b					_ITSOutputDigit:
.cb5b	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.cb5e	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.cb61	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter 		; output it.
.cb64					_ITSGoNextSubtractor:
.cb64	e8		inx				inx 								; next dword
.cb65	e8		inx				inx
.cb66	e8		inx				inx
.cb67	e8		inx				inx
.cb68	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.cb6a	d0 a9		bne $cb15			bne 		_ITSNextSubtractor 		; do all the subtractors.
.cb6c	98		tya				tya 								; X is back as the mantissa index
.cb6d	aa		tax				tax
.cb6e	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.cb70	09 30		ora #$30			ora 		#"0"
.cb72	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter
.cb75	7a		ply				ply 								; and exit
.cb76	68		pla				pla
.cb77	60		rts				rts
.cb78					_ITSSubtractors:
>cb78	00 ca 9a 3b					.dword 		1000000000
>cb7c	00 e1 f5 05					.dword 		100000000
>cb80	80 96 98 00					.dword 		10000000
>cb84	40 42 0f 00					.dword 		1000000
>cb88	a0 86 01 00					.dword 		100000
>cb8c	10 27 00 00					.dword 		10000
>cb90	e8 03 00 00					.dword 		1000
>cb94	64 00 00 00					.dword 		100
>cb98	0a 00 00 00					.dword 		10
.cb9c					_ITSSubtractorsEnd:
.cb9c					ITSOutputCharacter:
.cb9c	48		pha				pha
.cb9d	da		phx				phx
.cb9e	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.cba1	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.cba4	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.cba6	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.cba9	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.cbac	fa		plx				plx
.cbad	68		pla				pla
.cbae	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.cbaf					IntFromString:
.cbaf	a0 00		ldy #$00			ldy 	#0
.cbb1					IntFromStringY:
.cbb1	a9 00		lda #$00			lda 	#0
.cbb3	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.cbb6	48		pha				pha
.cbb7	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.cbb9	95 80		sta $80,x			sta 	XS_Mantissa,x
.cbbb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cbbd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cbbf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cbc1	a9 01		lda #$01			lda 	#1
.cbc3	95 85		sta $85,x			sta 	XS_Type,x
.cbc5					_IFSLoop:
.cbc5	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.cbc7	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.cbc9	90 4e		bcc $cc19			bcc 	_IFSExit
.cbcb	c9 3a		cmp #$3a			cmp 	#"9"+1
.cbcd	b0 4a		bcs $cc19			bcs 	_IFSExit
.cbcf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.cbd1	c9 0c		cmp #$0c			cmp 	#12
.cbd3	b0 4e		bcs $cc23			bcs 	_IFSOverflow
.cbd5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.cbd7	48		pha				pha
.cbd8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cbda	48		pha				pha
.cbdb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cbdd	48		pha				pha
.cbde	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.cbe0	48		pha				pha
.cbe1	20 38 cc	jsr $cc38			jsr 	IFSX1ShiftLeft 				; double
.cbe4	20 38 cc	jsr $cc38			jsr 	IFSX1ShiftLeft 				; x 4
.cbe7	18		clc				clc 								; add saved value x 5
.cbe8	68		pla				pla
.cbe9	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.cbeb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cbed	68		pla				pla
.cbee	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.cbf0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cbf2	68		pla				pla
.cbf3	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.cbf5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cbf7	68		pla				pla
.cbf8	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.cbfa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cbfc	20 38 cc	jsr $cc38			jsr 	IFSX1ShiftLeft 				; x 10
.cbff	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.cc02	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.cc04	29 0f		and #$0f			and 	#15
.cc06	c8		iny				iny
.cc07	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.cc09	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cc0b	90 b8		bcc $cbc5			bcc 	_IFSLoop
.cc0d	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cc0f	d0 b4		bne $cbc5			bne 	_IFSLoop
.cc11	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.cc13	d0 b0		bne $cbc5			bne 	_IFSLoop
.cc15	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.cc17	80 ac		bra $cbc5			bra 	_IFSLoop
.cc19					_IFSExit:
.cc19	98		tya				tya 								; get offset
.cc1a					_IFSOkay:
.cc1a	38		sec				sec
.cc1b	ad 9c 03	lda $039c			lda 	ExpTemp
.cc1e	f0 01		beq $cc21			beq 	_IFSSkipFail
.cc20	18		clc				clc
.cc21					_IFSSkipFail:
.cc21	68		pla				pla 								; and exit.
.cc22	60		rts				rts
.cc23					_IFSOverflow:
.cc23	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>cc26	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>cc2e	20 6f 76 65 72 66 6c 6f 77 00
.cc38					IFSX1ShiftLeft:
.cc38	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.cc3a	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.cc3c	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.cc3e	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.cc40	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.cc41					FPSubtract:
.cc41	48		pha				pha
.cc42	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.cc44	49 80		eor #$80			eor 	#$80
.cc46	95 8b		sta $8b,x			sta 	XS2_Type,x
.cc48	68		pla				pla 								; --- and fall through ---
.cc49					FPAdd:
.cc49	48		pha				pha
.cc4a	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.cc4c	d0 05		bne $cc53			bne 	_FPA_NegativeLHS
.cc4e	20 6a cc	jsr $cc6a			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cc51	68		pla				pla
.cc52	60		rts				rts
.cc53					_FPA_NegativeLHS:
.cc53	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.cc55	49 80		eor #$80			eor 	#$80
.cc57	95 85		sta $85,x			sta 	XS_Type,x
.cc59	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.cc5b	49 80		eor #$80			eor 	#$80
.cc5d	95 8b		sta $8b,x			sta 	XS2_Type,x
.cc5f	20 6a cc	jsr $cc6a			jsr 	FPAdd_Worker 				; do the add calculation.
.cc62	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.cc64	49 80		eor #$80			eor 	#$80
.cc66	95 85		sta $85,x			sta 	XS_Type,x
.cc68	68		pla				pla
.cc69	60		rts				rts
.cc6a					FPAdd_Worker:
.cc6a	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cc6c	70 07		bvs $cc75			bvs 	_FPAWExit 					; no change.
.cc6e	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.cc70	50 07		bvc $cc79			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.cc72	20 e7 ce	jsr $cee7			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.cc75					_FPAWExit:
.cc75	20 56 cf	jsr $cf56			jsr 	FPUNormalise 				; normalise the result.
.cc78	60		rts				rts
.cc79					_FPAWMakeSame:
.cc79	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.cc7b	38		sec				sec
.cc7c	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cc7e	f0 16		beq $cc96			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cc80	da		phx				phx 								; save X
.cc81	90 06		bcc $cc89			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cc83	e8		inx				inx
.cc84	e8		inx				inx
.cc85	e8		inx				inx
.cc86	e8		inx				inx
.cc87	e8		inx				inx
.cc88	e8		inx				inx
.cc89					_FPAWShiftA:
.cc89	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cc8b	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.cc8d	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cc8f	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cc91	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cc93	fa		plx				plx 								; restore original X
.cc94	80 e3		bra $cc79			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cc96					_FPAW_DoArithmetic:
.cc96	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cc98	30 28		bmi $ccc2			bmi 	_FPAW_BNegative
.cc9a	18		clc				clc
.cc9b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.cc9d	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.cc9f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cca1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cca3	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.cca5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cca7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cca9	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.ccab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ccad	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ccaf	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.ccb1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ccb3	90 c0		bcc $cc75			bcc 	_FPAWExit 					; no carry.
.ccb5	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.ccb7	38		sec				sec
.ccb8	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.ccba	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.ccbc	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.ccbe	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.ccc0	80 b3		bra $cc75			bra 	_FPAWExit
.ccc2					_FPAW_BNegative:
.ccc2	38		sec				sec
.ccc3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.ccc5	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.ccc7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.ccc9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cccb	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cccd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cccf	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.ccd1	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.ccd3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.ccd5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.ccd7	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.ccd9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.ccdb	b0 09		bcs $cce6			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.ccdd	20 0d cf	jsr $cf0d			jsr 	FPUNegateInteger			; negate the mantissa
.cce0	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.cce2	49 80		eor #$80			eor 	#$80
.cce4	95 85		sta $85,x			sta 	XS_Type,x
.cce6					_FPAWGoExit:
.cce6	4c 75 cc	jmp $cc75			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cce9					FPD_IsDivZero:
.cce9	20 a8 ae	jsr $aea8			jsr ERR_Handler
>ccec	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>ccf4	20 62 79 20 7a 65 72 6f 00
.ccfd					FPDivide:
.ccfd	48		pha				pha
.ccfe	5a		phy				phy
.ccff	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.cd01	70 e6		bvs $cce9			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cd03	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cd05	f0 03		beq $cd0a			beq 	_FPDCalculateExp
.cd07					_FPD_Exit:
.cd07	7a		ply				ply
.cd08	68		pla				pla
.cd09	60		rts				rts
.cd0a					_FPDCalculateExp:
.cd0a	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cd0c	49 ff		eor #$ff			eor 	#$FF
.cd0e	1a		inc a				inc 	a
.cd0f	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.cd11	20 e1 cd	jsr $cde1			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cd14	18		clc				clc 	 							; add 1 to the resulting exponent
.cd15	69 01		adc #$01			adc 	#1
.cd17	b0 54		bcs $cd6d			bcs 	_FPD_Overflow 				; which can overflow.
.cd19	95 84		sta $84,x			sta 	XS_Exponent,x
.cd1b	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cd1d	85 1c		sta $1c				sta 	zLTemp1+0
.cd1f	85 1d		sta $1d				sta 	zLTemp1+1
.cd21	85 1e		sta $1e				sta 	zLTemp1+2
.cd23	85 1f		sta $1f				sta 	zLTemp1+3
.cd25	a0 20		ldy #$20			ldy 	#32 						; times round.
.cd27					_FPD_Loop:
.cd27	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cd28	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.cd2a	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.cd2c	48		pha				pha
.cd2d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cd2f	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.cd31	48		pha				pha
.cd32	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cd34	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.cd36	48		pha				pha
.cd37	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cd39	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.cd3b	90 13		bcc $cd50			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cd3d	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cd3f	68		pla				pla
.cd40	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cd42	68		pla				pla
.cd43	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cd45	68		pla				pla
.cd46	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cd48	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.cd4a	09 80		ora #$80			ora 	#$80
.cd4c	85 1f		sta $1f				sta 	zLTemp1+3
.cd4e	80 03		bra $cd53			bra 	_FPD_Rotates
.cd50					_FPD_NoSubtract:
.cd50	68		pla				pla 								; throw away unwanted results
.cd51	68		pla				pla
.cd52	68		pla				pla
.cd53					_FPD_Rotates:
.cd53	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.cd55	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.cd57	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.cd59	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.cd5b	06 1c		asl $1c				asl 	zLTemp1 					; rotate result round left
.cd5d	26 1d		rol $1d				rol 	zLTemp1+1
.cd5f	26 1e		rol $1e				rol 	zLTemp1+2
.cd61	26 1f		rol $1f				rol 	zLTemp1+3
.cd63	90 02		bcc $cd67			bcc 	_FPD_NoCarry
.cd65	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.cd67					_FPD_NoCarry:
.cd67	88		dey				dey 								; do 32 times
.cd68	d0 bd		bne $cd27			bne 	_FPD_Loop
.cd6a	4c c5 cd	jmp $cdc5			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cd6d					_FPD_Overflow:
.cd6d	4c b3 cf	jmp $cfb3			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cd70					FPMultiply:
.cd70	48		pha				pha
.cd71	5a		phy				phy
.cd72	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cd74	70 07		bvs $cd7d			bvs 	_FPM_Exit
.cd76	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cd78	50 06		bvc $cd80			bvc 	_FPM_CalcExponent
.cd7a	20 e7 ce	jsr $cee7			jsr 	FPUCopyX2ToX1
.cd7d					_FPM_Exit:
.cd7d	7a		ply				ply
.cd7e	68		pla				pla
.cd7f	60		rts				rts
.cd80					_FPM_CalcExponent:
.cd80	18		clc				clc
.cd81	20 e1 cd	jsr $cde1			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cd84	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.cd86	a9 00		lda #$00			lda 	#0
.cd88	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cd8a	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cd8c	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cd8e	85 1f		sta $1f				sta 	zLTemp1+3
.cd90	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cd92					_FPM_Loop:
.cd92	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.cd94	29 01		and #$01			and 	#1
.cd96	18		clc				clc 								; clear carry for the long rotate.
.cd97	f0 19		beq $cdb2			beq 	_FPM_NoAddition
.cd99	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cd9a	a5 1c		lda $1c				lda 	zLTemp1+0
.cd9c	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.cd9e	85 1c		sta $1c				sta 	zLTemp1+0
.cda0	a5 1d		lda $1d				lda 	zLTemp1+1
.cda2	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.cda4	85 1d		sta $1d				sta 	zLTemp1+1
.cda6	a5 1e		lda $1e				lda 	zLTemp1+2
.cda8	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.cdaa	85 1e		sta $1e				sta 	zLTemp1+2
.cdac	a5 1f		lda $1f				lda 	zLTemp1+3
.cdae	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.cdb0	85 1f		sta $1f				sta 	zLTemp1+3
.cdb2					_FPM_NoAddition:
.cdb2	66 1f		ror $1f				ror 	3+zLTemp1
.cdb4	66 1e		ror $1e				ror 	2+zLTemp1
.cdb6	66 1d		ror $1d				ror 	1+zLTemp1
.cdb8	66 1c		ror $1c				ror 	0+zLTemp1
.cdba	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.cdbc	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cdbe	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cdc0	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cdc2	88		dey				dey
.cdc3	d0 cd		bne $cd92			bne 	_FPM_Loop 					; do this 32 times.
.cdc5					FPM_CopySignNormalize:
.cdc5	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.cdc7	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.cdc9	a5 1d		lda $1d				lda 	zLTemp1+1
.cdcb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cdcd	a5 1e		lda $1e				lda 	zLTemp1+2
.cdcf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cdd1	a5 1f		lda $1f				lda 	zLTemp1+3
.cdd3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cdd5	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.cdd7	55 8b		eor $8b,x			eor 	XS2_Type,x
.cdd9	95 85		sta $85,x			sta 	XS_Type,x
.cddb	20 56 cf	jsr $cf56			jsr 	FPUNormalise 				; normalise and exit.
.cdde	7a		ply				ply
.cddf	68		pla				pla
.cde0	60		rts				rts
.cde1					FPCalculateExponent:
.cde1	18		clc				clc
.cde2	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.cde4	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.cde6	b0 08		bcs $cdf0			bcs 	_FPCECarry 					; carry out ?
.cde8	10 03		bpl $cded			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.cdea	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.cdec	60		rts				rts
.cded					_FPCEExpZero:
.cded	a9 00		lda #$00			lda 	#0
.cdef	60		rts				rts
.cdf0					_FPCECarry:
.cdf0	30 03		bmi $cdf5			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.cdf2	09 80		ora #$80			ora 	#$80 						; put in right range
.cdf4	60		rts				rts
.cdf5					_FPCEOverflow:
.cdf5	4c b3 cf	jmp $cfb3			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.cdf8					FPFractionalPart:
.cdf8	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.cdfa	38		sec				sec 								; this flag tells us to keep the fractional part
.cdfb	30 0d		bmi $ce0a			bmi 	FPGetPart
.cdfd	60		rts				rts
.cdfe					FPIntegerPart:
.cdfe	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.ce00	18		clc				clc 								; this flag says keep the integer part.
.ce01	30 07		bmi $ce0a			bmi 	FPGetPart 					; -ve exponents are 0..127
.ce03	48		pha				pha
.ce04	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.ce06	95 85		sta $85,x			sta 	XS_Type,x
.ce08	68		pla				pla
.ce09	60		rts				rts
.ce0a					FPGetPart:
.ce0a	48		pha				pha
.ce0b	5a		phy				phy 								; save Y
.ce0c	08		php				php 								; save action
.ce0d	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.ce0f	70 59		bvs $ce6a			bvs 	_FPGP_Exit 					; then do nothing.
.ce11	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.ce13	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.ce15	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.ce17	85 1e		sta $1e				sta 	zLTemp1+2
.ce19	85 1f		sta $1f				sta 	zLTemp1+3
.ce1b	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.ce1d	38		sec				sec
.ce1e	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.ce20	f0 12		beq $ce34			beq 	_FPGP_NoShift 				; ... if any
.ce22	c9 20		cmp #$20			cmp 	#32
.ce24	90 02		bcc $ce28			bcc 	_FPGP_NotMax
.ce26	a9 20		lda #$20			lda 	#32 						; max of 32.
.ce28					_FPGP_NotMax:
.ce28	a8		tay				tay 								; Y is the mask shift count.
.ce29					_FPGP_ShiftMask:
.ce29	46 1f		lsr $1f				lsr 	3+zLTemp1
.ce2b	66 1e		ror $1e				ror 	2+zLTemp1
.ce2d	66 1d		ror $1d				ror 	1+zLTemp1
.ce2f	66 1c		ror $1c				ror 	0+zLTemp1
.ce31	88		dey				dey
.ce32	d0 f5		bne $ce29			bne 	_FPGP_ShiftMask
.ce34					_FPGP_NoShift:
.ce34	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.ce36	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.ce39					_FPGP_MaskLoop:
.ce39	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.ce3c	28		plp				plp 								; if CC we keep the top part, so we
.ce3d	08		php				php		 							; flip the mask.
.ce3e	b0 02		bcs $ce42			bcs		_FPGP_NoFlip
.ce40	49 ff		eor #$ff			eor 	#$FF
.ce42					_FPGP_NoFlip:
.ce42	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.ce44	95 80		sta $80,x			sta 	XS_Mantissa,x
.ce46	e8		inx				inx
.ce47	c8		iny				iny
.ce48	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.ce4a	d0 ed		bne $ce39			bne 	_FPGP_MaskLoop
.ce4c	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.ce4f	28		plp				plp
.ce50	08		php				php 								; get action flag on the stack
.ce51	90 04		bcc $ce57			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.ce53	a9 00		lda #$00			lda 	#0
.ce55	95 85		sta $85,x			sta 	XS_Type,x
.ce57					_FPGP_NotFractional:
.ce57	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.ce59	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.ce5b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.ce5d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.ce5f	f0 05		beq $ce66			beq 	_FPGP_Zero 					; if zero, return zero
.ce61	20 56 cf	jsr $cf56			jsr 	FPUNormalise
.ce64	80 04		bra $ce6a			bra 	_FPGP_Exit 					; and exit
.ce66					_FPGP_Zero:
.ce66	a9 40		lda #$40			lda 	#$40 						; set zero flag
.ce68	95 85		sta $85,x			sta 	XS_Type,x
.ce6a					_FPGP_Exit:
.ce6a	68		pla				pla 								; throw saved action flag.
.ce6b	7a		ply				ply
.ce6c	68		pla				pla
.ce6d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.ce6e					FPCompare:
.ce6e	20 af ce	jsr $ceaf			jsr 	FPFastCompare 				; fast compare try first
.ce71	b0 3b		bcs $ceae			bcs 	_FPCExit 					; that worked.
.ce73	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.ce75	48		pha				pha
.ce76	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.ce78	48		pha				pha
.ce79	20 41 cc	jsr $cc41			jsr 	FPSubtract 					; calculate X1-X2
.ce7c	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.ce7e	70 2a		bvs $ceaa			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.ce80	68		pla				pla
.ce81	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.ce84	68		pla				pla
.ce85	38		sec				sec
.ce86	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.ce89	70 14		bvs $ce9f			bvs 	_FPCNotEqual				; overflow, can't be equal.
.ce8b	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.ce8c	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.ce8e	b0 0f		bcs $ce9f			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.ce90	38		sec				sec
.ce91	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.ce94	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.ce96	b0 02		bcs $ce9a			bcs 	_FPCNotRange 				; keep in range.
.ce98	a9 01		lda #$01			lda 	#1
.ce9a					_FPCNotRange:
.ce9a	38		sec				sec
.ce9b	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.ce9d	b0 0d		bcs $ceac			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.ce9f					_FPCNotEqual:
.ce9f	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cea1	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cea3	f0 02		beq $cea7			beq 	_FPCNE2
.cea5	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cea7	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cea8	80 04		bra $ceae			bra 	_FPCExit
.ceaa					_FPCPullZero:
.ceaa	68		pla				pla 								; throw saved exponents
.ceab	68		pla				pla
.ceac					_FPCZero:
.ceac	a9 00		lda #$00			lda 	#0 							; and return zero
.ceae					_FPCExit:
.ceae	60		rts				rts
.ceaf					FPFastCompare:
.ceaf	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.ceb1	70 23		bvs $ced6			bvs 	_FPFLeftZero
.ceb3	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.ceb5	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.ceb7	70 25		bvs $cede			bvs 	_FPFSignBit
.ceb9	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.cebb	0a		asl a				asl 	a 							; put in CS if different.
.cebc	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.cebe	b0 1e		bcs $cede			bcs 	_FPFSignBit
.cec0	38		sec				sec 								; same sign and not-zero. compare exponents
.cec1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.cec3	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.cec5	f0 09		beq $ced0			beq 	_FPNoFastCompare
.cec7	6a		ror a				ror 	a 							; put carry into bit 7.
.cec8	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.ceca	30 02		bmi $cece			bmi		_FPFCNotMinus
.cecc	49 80		eor #$80			eor 	#$80
.cece					_FPFCNotMinus:
.cece	80 0e		bra $cede			bra		_FPFSignBit
.ced0					_FPNoFastCompare:
.ced0	18		clc				clc
.ced1	60		rts				rts
.ced2					_FPFZero:
.ced2	a9 00		lda #$00			lda 	#0
.ced4					_FPFExitSet:
.ced4	38		sec				sec
.ced5	60		rts				rts
.ced6					_FPFLeftZero:
.ced6	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.ced8	70 f8		bvs $ced2			bvs 	_FPFZero
.ceda	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.cedc	49 80		eor #$80			eor 	#$80						; return that as a sign.
.cede					_FPFSignBit:
.cede	0a		asl a				asl 	a
.cedf	a9 01		lda #$01			lda 	#1
.cee1	90 f1		bcc $ced4			bcc		_FPFExitSet
.cee3	a9 ff		lda #$ff			lda 	#$FF
.cee5	38		sec				sec
.cee6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cee7					FPUCopyX2ToX1:
.cee7	48		pha				pha
.cee8	da		phx				phx
.cee9	5a		phy				phy
.ceea	a0 08		ldy #$08			ldy 	#8
.ceec	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.ceee	95 80		sta $80,x			sta 	XS_Mantissa,x
.cef0	e8		inx				inx
.cef1	88		dey				dey
.cef2	10 f8		bpl $ceec			bpl 	_FPUC21
.cef4	7a		ply				ply
.cef5	fa		plx				plx
.cef6	68		pla				pla
.cef7	60		rts				rts
.cef8					FPUSetInteger:
.cef8	48		pha				pha
.cef9	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cefb	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cefd	10 02		bpl $cf01			bpl 	_FPUSIExtend
.ceff	a9 ff		lda #$ff			lda 	#$FF
.cf01					_FPUSIExtend:
.cf01	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cf03	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cf05	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cf07	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cf09	95 85		sta $85,x			sta 	XS_Type,x
.cf0b	68		pla				pla
.cf0c	60		rts				rts
.cf0d					FPUNegateInteger:
.cf0d	48		pha				pha
.cf0e	38		sec				sec
.cf0f	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cf11	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.cf13	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cf15	a9 00		lda #$00			lda 	#0
.cf17	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.cf19	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cf1b	a9 00		lda #$00			lda 	#0
.cf1d	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.cf1f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cf21	a9 00		lda #$00			lda 	#0
.cf23	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.cf25	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cf27	68		pla				pla
.cf28	60		rts				rts
.cf29					FPUToFloat:
.cf29	48		pha				pha
.cf2a	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.cf2c	29 0f		and #$0f			and 	#$0F
.cf2e	f0 24		beq $cf54			beq 	_FPUFExit
.cf30	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.cf32	95 85		sta $85,x			sta 	XS_Type,x
.cf34	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.cf36	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.cf38	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.cf3a	10 07		bpl $cf43			bpl		_FPUFPositive
.cf3c	20 0d cf	jsr $cf0d			jsr 	FPUNegateInteger 			; negate the mantissa
.cf3f	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.cf41	95 85		sta $85,x			sta 	XS_Type,x
.cf43					_FPUFPositive:
.cf43	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.cf45	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.cf47	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.cf49	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.cf4b	d0 04		bne $cf51			bne 	_FPUFNonZero
.cf4d	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.cf4f	95 85		sta $85,x			sta 	XS_Type,x
.cf51					_FPUFNonZero:
.cf51	20 56 cf	jsr $cf56			jsr 	FPUNormalise 				; normalise the floating point.
.cf54					_FPUFExit:
.cf54	68		pla				pla
.cf55	60		rts				rts
.cf56					FPUNormalise:
.cf56	48		pha				pha
.cf57	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.cf59	70 18		bvs $cf73			bvs 	_FPUNExit
.cf5b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.cf5d	f0 10		beq $cf6f			beq 	_FPUNSetZero
.cf5f					_FPUNLoop:
.cf5f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.cf61	30 10		bmi $cf73			bmi 	_FPUNExit 					; if so, we are normalised.
.cf63	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.cf65	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.cf67	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.cf69	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.cf6b	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.cf6d	d0 f0		bne $cf5f			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.cf6f					_FPUNSetZero:
.cf6f	a9 40		lda #$40			lda 	#$40
.cf71	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.cf73					_FPUNExit:
.cf73	68		pla				pla
.cf74	60		rts				rts
.cf75					FPUToInteger:
.cf75	48		pha				pha
.cf76	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.cf78	29 01		and #$01			and 	#1
.cf7a	d0 31		bne $cfad			bne 	_FPUTOI_Exit
.cf7c	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.cf7e	70 23		bvs $cfa3			bvs 	_FPUTOI_Zero
.cf80	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.cf82	10 1f		bpl $cfa3			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.cf84	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.cf86	b0 2b		bcs $cfb3			bcs 	FP_Overflow
.cf88					_FPUToIToInteger:
.cf88	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.cf8a	c9 a0		cmp #$a0			cmp 	#128+32
.cf8c	f0 0c		beq $cf9a			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.cf8e	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.cf90	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.cf92	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.cf94	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.cf96	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.cf98	80 ee		bra $cf88			bra 	_FPUToIToInteger 			; keep going.
.cf9a					_FPUToICheckSign:
.cf9a	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.cf9c	10 0f		bpl $cfad			bpl 	_FPUToI_Exit 				; exit if unsigned.
.cf9e	20 0d cf	jsr $cf0d			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.cfa1	80 0a		bra $cfad			bra 	_FPUTOI_Exit
.cfa3					_FPUTOI_Zero:
.cfa3	a9 00		lda #$00			lda 	#0 							; return zero integer.
.cfa5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cfa7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cfa9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cfab	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cfad					_FPUToI_Exit:
.cfad	a9 01		lda #$01			lda 	#1 							; set type to integer
.cfaf	95 85		sta $85,x			sta 	XS_Type,x
.cfb1	68		pla				pla
.cfb2	60		rts				rts
.cfb3					FP_Overflow:
.cfb3	20 a8 ae	jsr $aea8			jsr ERR_Handler
>cfb6	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>cfbe	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.cfce					FPUTimes10:
.cfce	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.cfd0	85 1c		sta $1c				sta 	ZLTemp1+0
.cfd2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cfd4	85 1d		sta $1d				sta 	ZLTemp1+1
.cfd6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cfd8	85 1e		sta $1e				sta 	ZLTemp1+2
.cfda	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cfdc	85 1f		sta $1f				sta 	ZLTemp1+3
.cfde	20 13 d0	jsr $d013			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.cfe1	20 13 d0	jsr $d013			jsr 	_FPUT_LSR_ZLTemp1
.cfe4	18		clc				clc
.cfe5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.cfe7	65 1c		adc $1c				adc 	ZLTemp1+0
.cfe9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.cfeb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.cfed	65 1d		adc $1d				adc 	ZLTemp1+1
.cfef	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.cff1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.cff3	65 1e		adc $1e				adc 	ZLTemp1+2
.cff5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.cff7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.cff9	65 1f		adc $1f				adc 	ZLTemp1+3
.cffb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.cffd	90 0a		bcc $d009			bcc 	_FPUTimes10
.cfff	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.d001	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.d003	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.d005	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.d007	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.d009					_FPUTimes10:
.d009	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.d00b	18		clc				clc
.d00c	69 03		adc #$03			adc 	#3
.d00e	95 84		sta $84,x			sta 	XS_Exponent,x
.d010	b0 a1		bcs $cfb3			bcs 	FP_Overflow 				; error
.d012	60		rts				rts
.d013					_FPUT_LSR_ZLTemp1:
.d013	46 1f		lsr $1f				lsr 	ZLTemp1+3
.d015	66 1e		ror $1e				ror 	ZLTemp1+2
.d017	66 1d		ror $1d				ror 	ZLTemp1+1
.d019	66 1c		ror $1c				ror 	ZLTemp1+0
.d01b	60		rts				rts
.d01c					FPUScale10A:
.d01c	5a		phy				phy
.d01d	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.d01f	f0 37		beq $d058			beq 	_FPUScaleExit
.d021	da		phx				phx 								; save X
.d022	e8		inx				inx
.d023	e8		inx				inx
.d024	e8		inx				inx
.d025	e8		inx				inx
.d026	e8		inx				inx
.d027	e8		inx				inx
.d028	a8		tay				tay 								; save power scalar in Y.
.d029	a9 00		lda #$00			lda 	#0
.d02b	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.d02d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d02f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d031	95 85		sta $85,x			sta 	XS_Type,x
.d033	a9 80		lda #$80			lda 	#$80
.d035	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d037	a9 81		lda #$81			lda 	#$81
.d039	95 84		sta $84,x			sta 	XS_Exponent,x
.d03b	5a		phy				phy 								; save 10^n on stack.
.d03c	c0 00		cpy #$00			cpy 	#0
.d03e	10 05		bpl $d045			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.d040	98		tya				tya
.d041	49 ff		eor #$ff			eor 	#$FF
.d043	1a		inc a				inc 	a
.d044	a8		tay				tay
.d045					_FPUSAbs:
.d045	20 ce cf	jsr $cfce			jsr 	FPUTimes10
.d048	88		dey				dey
.d049	d0 fa		bne $d045			bne 	_FPUSAbs 					; tos is now 10^|AC|
.d04b	68		pla				pla 								; restore count in A
.d04c	fa		plx				plx 								; restore X pointing to number to scale.
.d04d	0a		asl a				asl 	a
.d04e	b0 05		bcs $d055			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.d050	20 70 cd	jsr $cd70			jsr 	FPMultiply 					; if clear multiply.
.d053	80 03		bra $d058			bra		_FPUScaleExit
.d055					_FPUSDivide:
.d055	20 fd cc	jsr $ccfd			jsr 	FPDivide
.d058					_FPUScaleExit:
.d058	7a		ply				ply
.d059	60		rts				rts
.d05a					FPUCopyToNext:
.d05a	a0 06		ldy #$06			ldy 		#6
.d05c	da		phx				phx
.d05d					_FPUCopy1:
.d05d	b5 80		lda $80,x			lda 	XS_Mantissa,x
.d05f	95 86		sta $86,x			sta 	XS2_Mantissa,x
.d061	e8		inx				inx
.d062	88		dey				dey
.d063	d0 f8		bne $d05d			bne 	_FPUCopy1
.d065	fa		plx				plx
.d066	60		rts				rts
.d067					FPUCopyFromNext:
.d067	a0 06		ldy #$06			ldy 		#6
.d069	da		phx				phx
.d06a					_FPUCopy1:
.d06a	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.d06c	95 80		sta $80,x			sta 	XS_Mantissa,x
.d06e	e8		inx				inx
.d06f	88		dey				dey
.d070	d0 f8		bne $d06a			bne 	_FPUCopy1
.d072	fa		plx				plx
.d073	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.d074					FPToString:
.d074	48		pha				pha
.d075	5a		phy				phy
.d076	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.d078	50 0a		bvc $d084			bvc 		_FPTSIsFloat 			; if zero,
.d07a					_FPTSZero:
.d07a	a9 30		lda #$30			lda 		#"0"
.d07c	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter
.d07f					_FPTSExit:
.d07f	7a		ply				ply
.d080	68		pla				pla
.d081	60		rts				rts
.d082	80 fb		bra $d07f			bra 		_FPTSExit
.d084					_FPTSIsFloat:
.d084	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.d086	10 09		bpl $d091			bpl 		_FPTSNotSigned
.d088	a9 00		lda #$00			lda 		#0 						; clear sign flag
.d08a	95 85		sta $85,x			sta 		XS_Type,x
.d08c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.d08e	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter
.d091					_FPTSNotSigned:
.d091	b5 84		lda $84,x			lda 		XS_Exponent,x
.d093	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.d095	b0 09		bcs $d0a0			bcs 		_FPTSExponent
.d097	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.d099	90 05		bcc $d0a0			bcc 		_FPTSExponent 			;
.d09b					_FPTSStandard:
.d09b	20 df d0	jsr $d0df			jsr 		FPTOutputBody 			; output the body.
.d09e	80 df		bra $d07f			bra 		_FPTSExit
.d0a0					_FPTSExponent:
.d0a0	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.d0a2	8d 9d 03	sta $039d			sta 		ExpCount
.d0a5					_FPTSExponentLoop:
.d0a5	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.d0a7	10 0e		bpl $d0b7			bpl 		_FPTSTimes
.d0a9	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.d0ab	90 14		bcc $d0c1			bcc 		_FPTSScaledToExp
.d0ad	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.d0af	20 1c d0	jsr $d01c			jsr 		FPUScale10A
.d0b2	ee 9d 03	inc $039d			inc 		ExpCount
.d0b5	80 ee		bra $d0a5			bra 		_FPTSExponentLoop
.d0b7					_FPTSTimes:
.d0b7	a9 01		lda #$01			lda 		#1
.d0b9	20 1c d0	jsr $d01c			jsr 		FPUScale10A
.d0bc	ce 9d 03	dec $039d			dec 		ExpCount
.d0bf	80 e4		bra $d0a5			bra 		_FPTSExponentLoop
.d0c1					_FPTSScaledToExp:
.d0c1	20 df d0	jsr $d0df			jsr 		FPTOutputBody 			; output the body.
.d0c4	a9 65		lda #$65			lda 		#"e"					; output E
.d0c6	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter
.d0c9	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.d0cc	95 80		sta $80,x			sta 		XS_Mantissa,x
.d0ce	29 80		and #$80			and 		#$80 					; sign extend it
.d0d0	f0 02		beq $d0d4			beq 		_FPTSSExt
.d0d2	a9 ff		lda #$ff			lda 		#$FF
.d0d4					_FPTSSExt:
.d0d4	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.d0d6	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.d0d8	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.d0da	20 fe ca	jsr $cafe			jsr 		INTToString 			; output the exponent.
.d0dd	80 a0		bra $d07f			bra			_FPTSExit 				; and exit.
.d0df					FPTOutputBody:
.d0df	20 5a d0	jsr $d05a			jsr 		FPUCopyToNext 			; copy to next slot.
.d0e2	20 75 cf	jsr $cf75			jsr 		FPUToInteger 			; convert to an integer
.d0e5	20 fe ca	jsr $cafe			jsr 		INTToString 			; output the main integer part.
.d0e8	20 67 d0	jsr $d067			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d0eb	20 f8 cd	jsr $cdf8			jsr 		FPFractionalPart 		; get the decimal part.
.d0ee	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.d0f0	70 3c		bvs $d12e			bvs 		_FPTOExit 				; if not, exit now.
.d0f2	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d0f4	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter
.d0f7					_FPOutLoop:
.d0f7	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.d0f9	70 1d		bvs $d118			bvs 		_FPStripZeros 			; strip trailing zeros
.d0fb	20 ce cf	jsr $cfce			jsr 		FPUTimes10 				; multiply by 10
.d0fe	20 5a d0	jsr $d05a			jsr 		FPUCopyToNext			; copy to next slot.
.d101	20 75 cf	jsr $cf75			jsr 		FPUToInteger 			; convert to integer
.d104	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.d106	09 30		ora #$30			ora 		#"0"
.d108	20 9c cb	jsr $cb9c			jsr 		ITSOutputCharacter
.d10b	20 67 d0	jsr $d067			jsr 		FPUCopyFromNext 		; get it back
.d10e	20 f8 cd	jsr $cdf8			jsr 		FPFractionalPart 		; get fractional part
.d111	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.d114	c9 0b		cmp #$0b			cmp 	 	#11
.d116	90 df		bcc $d0f7			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d118					_FPStripZeros:
.d118	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.d11b					_FPStripLoop:
.d11b	88		dey				dey 								; back one, if at start then no strip
.d11c	f0 10		beq $d12e			beq 		_FPToExit
.d11e	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.d121	c9 30		cmp #$30			cmp 		#"0"
.d123	f0 f6		beq $d11b			beq 		_FPStripLoop
.d125	c8		iny				iny
.d126	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d128	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.d12b	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.d12e					_FPTOExit:
.d12e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d12f					FPFromString:
.d12f	48		pha				pha 								; push A
.d130	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d132	c9 2e		cmp #$2e			cmp 	#"."
.d134	f0 03		beq $d139			beq	 	_FPFIsDecimal
.d136	4c 95 d1	jmp $d195			jmp 	_FPFNotDecimal
.d139					_FPFIsDecimal:
.d139	c8		iny				iny 								; consume the decimal.
.d13a	20 29 cf	jsr $cf29			jsr 	FPUToFloat 					; convert the integer to float.
.d13d	da		phx				phx 								; save X.
.d13e	5a		phy				phy 								; save decimal start position
.d13f	e8		inx				inx
.d140	e8		inx				inx
.d141	e8		inx				inx
.d142	e8		inx				inx
.d143	e8		inx				inx
.d144	e8		inx				inx
.d145	20 b1 cb	jsr $cbb1			jsr 	INTFromStringY 				; get the part after the DP.
.d148	20 29 cf	jsr $cf29			jsr 	FPUToFloat 					; convert that to a float.
.d14b	68		pla				pla 								; calculate - chars consumed.
.d14c	8c 9c 03	sty $039c			sty 	ExpTemp
.d14f	38		sec				sec
.d150	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.d153	20 1c d0	jsr $d01c			jsr 	FPUScale10A 				; scale it by 10^AC
.d156	fa		plx				plx 								; restore original X
.d157	20 49 cc	jsr $cc49			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d15a	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.d15c	c9 45		cmp #$45			cmp 	#"E"
.d15e	f0 04		beq $d164			beq 	_FPFExponent
.d160	c9 65		cmp #$65			cmp 	#"e"
.d162	d0 31		bne $d195			bne 	_FPFNotDecimal 				; no, then exit normally.
.d164					_FPFExponent:
.d164	c8		iny				iny 								; skip over E symbol.
.d165	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.d167	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d169	d0 01		bne $d16c			bne 	_FPFGotSign
.d16b	c8		iny				iny 								; if it was - skip over it.
.d16c					_FPFGotSign:
.d16c	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d16d	da		phx				phx
.d16e	e8		inx				inx
.d16f	e8		inx				inx
.d170	e8		inx				inx
.d171	e8		inx				inx
.d172	e8		inx				inx
.d173	e8		inx				inx
.d174	20 b1 cb	jsr $cbb1			jsr 	INTFromStringY 				; get the exponent
.d177	fa		plx				plx 								; restore X.
.d178	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d17a	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.d17c	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.d17e	d0 17		bne $d197			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d180	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d182	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d184	b0 11		bcs $d197			bcs 	_FPFXOverflow
.d186	68		pla				pla 								; get direction
.d187	d0 07		bne $d190			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d189	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d18b	49 ff		eor #$ff			eor 	#$FF
.d18d	1a		inc a				inc 	a
.d18e	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.d190					_FPFXScale:
.d190	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d192	20 1c d0	jsr $d01c			jsr 	FPUScale10A 				; scale by the exponent.
.d195					_FPFNotDecimal:
.d195	68		pla				pla
.d196	60		rts				rts
.d197					_FPFXOverflow:
.d197	20 a8 ae	jsr $aea8			jsr 	ERR_Handler
>d19a	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d1a2	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.d1a9					Unary_Rnd:
.d1a9	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX 			; get value
.d1ac	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; check right bracket.
.d1af	20 71 bf	jsr $bf71			jsr 	GetSignCurrent 				; get sign -1,0,1.
.d1b2	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.d1b4	30 10		bmi $d1c6			bmi 	_URSetSeed
.d1b6	f0 28		beq $d1e0			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.d1b8	da		phx				phx
.d1b9	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.d1bb	20 17 d2	jsr $d217			jsr 	Random16
.d1be	a2 02		ldx #$02			ldx 	#2
.d1c0	20 17 d2	jsr $d217			jsr 	Random16
.d1c3	fa		plx				plx
.d1c4	80 1a		bra $d1e0			bra 	_URMakeRandom
.d1c6					_URSetSeed:
.d1c6	20 29 cf	jsr $cf29			jsr 	FPUToFloat 					; make it a float to twiddle it.
.d1c9	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.d1cb	8d a3 03	sta $03a3			sta 	RandomSeed+0
.d1ce	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.d1d0	8d a4 03	sta $03a4			sta 	RandomSeed+1
.d1d3	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.d1d5	8d a5 03	sta $03a5			sta 	RandomSeed+2
.d1d8	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.d1da	0a		asl a				asl 	a 							; resemblance to the seed value.
.d1db	49 db		eor #$db			eor 	#$DB
.d1dd	8d a6 03	sta $03a6			sta 	RandomSeed+3
.d1e0					_URMakeRandom:
.d1e0	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.d1e3	0d a4 03	ora $03a4			ora 	RandomSeed+1
.d1e6	0d a5 03	ora $03a5			ora 	RandomSeed+2
.d1e9	0d a6 03	ora $03a6			ora 	RandomSeed+3
.d1ec	d0 0a		bne $d1f8			bne 	_URNotZero
.d1ee	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.d1f0	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.d1f3	a9 3d		lda #$3d			lda 	#$3D
.d1f5	8d a6 03	sta $03a6			sta 	RandomSeed+3
.d1f8					_URNotZero:
.d1f8	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.d1fb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.d1fd	ad a4 03	lda $03a4			lda 	RandomSeed+1
.d200	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.d202	ad a5 03	lda $03a5			lda 	RandomSeed+2
.d205	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.d207	ad a6 03	lda $03a6			lda 	RandomSeed+3
.d20a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.d20c	a9 00		lda #$00			lda 	#$00 						; set type to float.
.d20e	95 85		sta $85,x			sta 	XS_Type,x
.d210	a9 80		lda #$80			lda 	#$80
.d212	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.d214	4c 56 cf	jmp $cf56			jmp 	FPUNormalise 				; and normalise.
.d217					Random16:
.d217	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.d21a	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.d21d	90 08		bcc $d227			bcc 	_R16_NoXor
.d21f	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.d222	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.d224	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.d227					_R16_NoXor:
.d227	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.d228					Unary_Int:
.d228	20 f1 bc	jsr $bcf1			jsr 	EvaluateNumberX 			; get value
.d22b	20 5d c3	jsr $c35d			jsr 	CheckNextRParen 			; check right bracket.
.d22e	4c 75 cf	jmp $cf75			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.d231	80 fe		bra $d231	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM 					; Reset vector
>fffe	92 ac					.word TIM_BreakVector

;******  End of listing
