
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Mon Aug 26 17:02:01 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0497					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>049f					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04a1					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04a3					Tim_SR:		.byte ? 						; Processor Status
>04a4					Tim_A:		.byte ? 						; Processor Registers
>04a5					Tim_X:		.byte ?
>04a6					Tim_Y:		.byte ?
>04a7					Tim_Z:		.byte ?
>04a8					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=$4000					VariableMemory = $4000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0b 64 00 cd 14 05 13 14			.byte	$0b,$64,$00,$cd,$14,$05,$13,$14
>1008	84 6a 00 1d 65 00 cd 01			.byte	$84,$6a,$00,$1d,$65,$00,$cd,$01
>1010	84 40 fd 03 30 be cd 14			.byte	$84,$40,$fd,$03,$30,$be,$cd,$14
>1018	05 13 14 31 84 41 fd 06			.byte	$05,$13,$14,$31,$84,$41,$fd,$06
>1020	32 65 32 34 8d 41 64 00			.byte	$32,$65,$32,$34,$8d,$41,$64,$00
>1028	12 66 00 14 05 13 14 84			.byte	$12,$66,$00,$14,$05,$13,$14,$84
>1030	14 05 13 14 8a 41 fd 03			.byte	$14,$05,$13,$14,$8a,$41,$fd,$03
>1038	30 00 2e 67 00 03 84 8b			.byte	$30,$00,$2e,$67,$00,$03,$84,$8b
>1040	14 05 13 14 be 03 84 03			.byte	$14,$05,$13,$14,$be,$03,$84,$03
>1048	8b 4f 68 be cd 0e 01 0d			.byte	$8b,$4f,$68,$be,$cd,$0e,$01,$0d
>1050	05 b5 84 fe 07 48 65 6c			.byte	$05,$b5,$84,$fe,$07,$48,$65,$6c
>1058	6c 6f be 03 b5 84 fe 09			.byte	$6c,$6f,$be,$03,$b5,$84,$fe,$09
>1060	2c 77 6f 72 6c 64 21 00			.byte	$2c,$77,$6f,$72,$6c,$64,$21,$00
>1068	17 68 00 07 12 05 05 14			.byte	$17,$68,$00,$07,$12,$05,$05,$14
>1070	09 0e 07 31 b5 84 0e 01			.byte	$09,$0e,$07,$31,$b5,$84,$0e,$01
>1078	0d 05 b5 8a 03 b5 00 14			.byte	$0d,$05,$b5,$8a,$03,$b5,$00,$14
>1080	69 00 0c 31 b9 84 a6 07			.byte	$69,$00,$0c,$31,$b9,$84,$a6,$07
>1088	12 05 05 14 09 0e 07 31			.byte	$12,$05,$05,$14,$09,$0e,$07,$31
>1090	b5 bc 00 0c 6a 00 01 12			.byte	$b5,$bc,$00,$0c,$6a,$00,$01,$12
>1098	12 bb 43 bc 84 42 00 05			.byte	$12,$bb,$43,$bc,$84,$42,$00,$05
>10a0	6b 00 c2 00 00				.byte	$6b,$00,$c2,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 9e 86 01	jmp $01869e		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae a8 04	ldx $04a8			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad a3 04	lda $04a3			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad a4 04	lda $04a4			lda 	TIM_A 						; restore AXYZ
.018281	ae a5 04	ldx $04a5			ldx 	TIM_X
.018284	ac a6 04	ldy $04a6			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d a2 04	sta $04a2			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d a1 04	sta $04a1			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd 9f 04	lda $049f,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d a4 04	sta $04a4			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e a5 04	stx $04a5			stx 	TIM_X
.01838b	8c a6 04	sty $04a6			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d a3 04	sta $04a3			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d a0 04	sta $04a0			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d 9f 04	sta $049f			sta 	TIM_PC 						; high byte
.01839a	ad a0 04	lda $04a0			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce 9f 04	dec $049f			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce a0 04	dec $04a0			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e a8 04	stx $04a8			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d a0 04	sta $04a0			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d 9f 04	sta $049f			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d a3 04	sta $04a3,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	8d 08 03	sta $0308			sta 	XS_Mantissa
.018437	c8		iny				iny
.018438	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01843a	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01843d	fa		plx				plx 								; address in XY
.01843e	7a		ply				ply
.01843f	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018440	d0 01		bne $018443			bne 	_EHNoSkip
.018442	c8		iny				iny
.018443					_EHNoSkip:
.018443	20 64 84	jsr $018464			jsr 	PrintROMMessage 			; print message from ROM.
.018446	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018449	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01844c	f0 0c		beq $01845a			beq 	_EHNoLine
.01844e	a2 5f		ldx #$5f			ldx 	#_EHAt & $FF 				; print " at "
.018450	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018452	20 64 84	jsr $018464			jsr 	PrintROMMessage
.018455	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018457	20 79 84	jsr $018479			jsr 	Print16BitInteger
.01845a					_EHNoLine:
.01845a	80 fe		bra $01845a			bra 	_EHNoLine
.01845c	4c be 86	jmp $0186be			jmp 	WarmStart
>01845f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018464					PrintROMMessage:
.018464	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018466	84 1b		sty $1b				sty 	zLTemp1+1
.018468	4b		phk				phk
.018469	68		pla				pla
.01846a	85 1c		sta $1c				sta 	ZLTemp1+2
.01846c	a0 00		ldy #$00			ldy 	#0
.01846e					_PRMLoop:
.01846e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018470	f0 06		beq $018478			beq		_PRMExit
.018472	c8		iny				iny
.018473	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018476	80 f6		bra $01846e			bra 	_PRMLoop
.018478					_PRMExit:
.018478	60		rts				rts
.018479					Print16BitInteger:
.018479	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01847b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.01847e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018481	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.018484	aa		tax				tax 								; convert bottom level.
.018485	20 2d 95	jsr $01952d			jsr 	INTToString 				; make string
.018488	a2 00		ldx #$00			ldx 	#0 							; print buffer
.01848a	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.01848d	f0 06		beq $018495			beq 	_P1Exit
.01848f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018492	e8		inx				inx
.018493	80 f5		bra $01848a			bra 	_P1Loop
.018495	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.018496					VectorTable:
>018496	ee 89					.word BinaryOp_And         & $FFFF ; $80 and
>018498	16 8a					.word BinaryOp_Or          & $FFFF ; $81 or
>01849a	3e 8a					.word BinaryOp_Xor         & $FFFF ; $82 xor
>01849c	3e 8a					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01849e	82 8a					.word Binary_Equal         & $FFFF ; $84 =
>0184a0	a1 8a					.word Binary_NotEqual      & $FFFF ; $85 <>
>0184a2	aa 8a					.word Binary_Less          & $FFFF ; $86 <
>0184a4	b3 8a					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a6	c5 8a					.word Binary_Greater       & $FFFF ; $88 >
>0184a8	bc 8a					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184aa	5a 8b					.word BinaryOp_Add         & $FFFF ; $8a +
>0184ac	7a 8b					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184ae	8d 8b					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184b0	a0 8b					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184b2	4a 85					.word NotImplemented       & $FFFF ; $8e ^
>0184b4	4a 85					.word NotImplemented       & $FFFF ; $8f if
>0184b6	4a 85					.word NotImplemented       & $FFFF ; $90 while
>0184b8	4a 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184ba	4a 85					.word NotImplemented       & $FFFF ; $92 for
>0184bc	4a 85					.word NotImplemented       & $FFFF ; $93 then
>0184be	4a 85					.word NotImplemented       & $FFFF ; $94 endif
>0184c0	4a 85					.word NotImplemented       & $FFFF ; $95 wend
>0184c2	4a 85					.word NotImplemented       & $FFFF ; $96 until
>0184c4	4a 85					.word NotImplemented       & $FFFF ; $97 next
>0184c6	4a 85					.word NotImplemented       & $FFFF ; $98 not
>0184c8	4a 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184ca	d4 8c					.word Unary_Abs            & $FFFF ; $9a abs(
>0184cc	2c 8e					.word Unary_Asc            & $FFFF ; $9b asc(
>0184ce	12 9d					.word Unary_Int            & $FFFF ; $9c int(
>0184d0	f2 8c					.word Unary_Peek           & $FFFF ; $9d peek(
>0184d2	89 9c					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184d4	66 8d					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d6	6d 8e					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d8	84 8e					.word Unary_Right          & $FFFF ; $a1 right$(
>0184da	52 8e					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184dc	e6 8f					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184de	f9 8d					.word Unary_Str            & $FFFF ; $a4 str$(
>0184e0	88 8d					.word Unary_Val            & $FFFF ; $a5 val(
>0184e2	43 8e					.word Unary_Len            & $FFFF ; $a6 len(
>0184e4	02 8f					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e6	4a 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e8	4a 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184ea	4a 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184ec	4a 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184ee	4a 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184f0	4a 85					.word NotImplemented       & $FFFF ; $ad log(
>0184f2	4a 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184f4	5c 8f					.word Unary_Dec            & $FFFF ; $af dec(
>0184f6	f6 8c					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f8	fa 8c					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184fa	2e 8d					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184fc	82 8c					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184fe	c4 8f					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018500	4a 85					.word NotImplemented       & $FFFF ; $b5 $
>018502	4a 85					.word NotImplemented       & $FFFF ; $b6 $(
>018504	4a 85					.word NotImplemented       & $FFFF ; $b7 #
>018506	4a 85					.word NotImplemented       & $FFFF ; $b8 #(
>018508	4a 85					.word NotImplemented       & $FFFF ; $b9 %
>01850a	4a 85					.word NotImplemented       & $FFFF ; $ba %(
>01850c	4a 85					.word NotImplemented       & $FFFF ; $bb (
>01850e	4a 85					.word NotImplemented       & $FFFF ; $bc )
>018510	4a 85					.word NotImplemented       & $FFFF ; $bd ,
>018512	46 87					.word Command_COLON        & $FFFF ; $be :
>018514	4a 85					.word NotImplemented       & $FFFF ; $bf ;
>018516	4a 85					.word NotImplemented       & $FFFF ; $c0 def
>018518	fb 87					.word Command_CLR          & $FFFF ; $c1 clr
>01851a	0c 88					.word Command_STOP         & $FFFF ; $c2 stop
>01851c	4a 85					.word NotImplemented       & $FFFF ; $c3 data
>01851e	4a 85					.word NotImplemented       & $FFFF ; $c4 read
>018520	4a 85					.word NotImplemented       & $FFFF ; $c5 dim
>018522	4a 85					.word NotImplemented       & $FFFF ; $c6 to
>018524	4a 85					.word NotImplemented       & $FFFF ; $c7 step
>018526	4a 85					.word NotImplemented       & $FFFF ; $c8 gosub
>018528	4a 85					.word NotImplemented       & $FFFF ; $c9 return
>01852a	4a 85					.word NotImplemented       & $FFFF ; $ca goto
>01852c	68 87					.word Command_END          & $FFFF ; $cb end
>01852e	4a 85					.word NotImplemented       & $FFFF ; $cc input
>018530	47 87					.word Command_LET          & $FFFF ; $cd let
>018532	4a 85					.word NotImplemented       & $FFFF ; $ce list
>018534	4a 85					.word NotImplemented       & $FFFF ; $cf new
>018536	4a 85					.word NotImplemented       & $FFFF ; $d0 old
>018538	4a 85					.word NotImplemented       & $FFFF ; $d1 on
>01853a	4a 85					.word NotImplemented       & $FFFF ; $d2 restore
>01853c	4a 85					.word NotImplemented       & $FFFF ; $d3 poke
>01853e	6c 87					.word Command_PRINT        & $FFFF ; $d4 print
>018540	cc 86					.word Command_RUN          & $FFFF ; $d5 run
>018542	4a 85					.word NotImplemented       & $FFFF ; $d6 wait
>018544	4a 85					.word NotImplemented       & $FFFF ; $d7 doke
>018546	4a 85					.word NotImplemented       & $FFFF ; $d8 loke
>018548	df 87					.word Command_ASSERT       & $FFFF ; $d9 assert
.01854a					NotImplemented:
.01854a	20 2f 84	jsr $01842f			jsr ERR_Handler
>01854d	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>018555	65 6d 65 6e 74 65 64 00
.01855d					BinaryPrecedence:
>01855d	01					.byte 1    ; $80 and
>01855e	01					.byte 1    ; $81 or
>01855f	01					.byte 1    ; $82 xor
>018560	01					.byte 1    ; $83 eor
>018561	02					.byte 2    ; $84 =
>018562	02					.byte 2    ; $85 <>
>018563	02					.byte 2    ; $86 <
>018564	02					.byte 2    ; $87 <=
>018565	02					.byte 2    ; $88 >
>018566	02					.byte 2    ; $89 >=
>018567	03					.byte 3    ; $8a +
>018568	03					.byte 3    ; $8b -
>018569	04					.byte 4    ; $8c *
>01856a	04					.byte 4    ; $8d /
>01856b	05					.byte 5    ; $8e ^
.01856c					KeywordText:
>01856c	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01856f	4f d2					.byte $4f,$d2                          ; $81 or
>018571	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>018574	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>018577	bd					.byte $bd                              ; $84 =
>018578	3c be					.byte $3c,$be                          ; $85 <>
>01857a	bc					.byte $bc                              ; $86 <
>01857b	3c bd					.byte $3c,$bd                          ; $87 <=
>01857d	be					.byte $be                              ; $88 >
>01857e	3e bd					.byte $3e,$bd                          ; $89 >=
>018580	ab					.byte $ab                              ; $8a +
>018581	ad					.byte $ad                              ; $8b -
>018582	aa					.byte $aa                              ; $8c *
>018583	af					.byte $af                              ; $8d /
>018584	de					.byte $de                              ; $8e ^
>018585	49 c6					.byte $49,$c6                          ; $8f if
>018587	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>01858c	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018592	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>018595	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018599	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>01859e	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185a2	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185a7	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185ab	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185ae	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b1	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185b5	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185b9	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185bd	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185c2	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185c6	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185ca	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d0	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185d7	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185dc	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e0	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185e5	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185e9	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185ed	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185f2	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185f6	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0185fa	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>0185fe	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018602	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018606	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01860a	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01860e	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018612	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018617	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01861c	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018620	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018624	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018629	a4					.byte $a4                              ; $b5 $
>01862a	24 a8					.byte $24,$a8                          ; $b6 $(
>01862c	a3					.byte $a3                              ; $b7 #
>01862d	23 a8					.byte $23,$a8                          ; $b8 #(
>01862f	a5					.byte $a5                              ; $b9 %
>018630	25 a8					.byte $25,$a8                          ; $ba %(
>018632	a8					.byte $a8                              ; $bb (
>018633	a9					.byte $a9                              ; $bc )
>018634	ac					.byte $ac                              ; $bd ,
>018635	ba					.byte $ba                              ; $be :
>018636	bb					.byte $bb                              ; $bf ;
>018637	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>01863a	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>01863d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>018641	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>018645	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>018649	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>01864c	54 cf					.byte $54,$cf                          ; $c6 to
>01864e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>018652	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>018657	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>01865d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>018661	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>018664	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>018669	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>01866c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>018670	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>018673	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>018676	4f ce					.byte $4f,$ce                          ; $d1 on
>018678	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>01867f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>018683	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>018688	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>01868b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>01868f	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>018693	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>018697	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>01869d	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.01869e					BASIC_Start:
.01869e	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186a1	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186a4	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186a6	8d 04 03	sta $0304			sta 	LocalVector
.0186a9	8d 00 03	sta $0300			sta 	UserVector
.0186ac	a9 76		lda #$76			lda 	#USRDefault & $FF 			; reset USR vector
.0186ae	8d 01 03	sta $0301			sta 	UserVector+1
.0186b1	a9 8d		lda #$8d			lda 	#(USRDefault >> 8) & $FF
.0186b3	8d 02 03	sta $0302			sta 	UserVector+2
.0186b6	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186b8	8d 03 03	sta $0303			sta 	UserVector+3
.0186bb	20 fb 87	jsr $0187fb			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186be					WarmStart:
.0186be	c2 30		rep #$30			rep 	#$30
.0186c0	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186c3	1b		tcs				tcs
.0186c4	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186c7	e2 30		sep #$30			sep 	#$30
.0186c9	4c cc 86	jmp $0186cc			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0186cc					Command_RUN:
.0186cc	20 fb 87	jsr $0187fb			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0186cf	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0186d1	85 16		sta $16				sta 	zCodePtr+0
.0186d3	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0186d5	85 17		sta $17				sta 	zCodePtr+1
.0186d7	a9 00		lda #$00			lda 	#0
.0186d9	85 18		sta $18				sta 	zCodePtr+2
.0186db	85 19		sta $19				sta 	zCodePtr+3
.0186dd	a0 03		ldy #$03			ldy 	#3
.0186df					RUN_NewLine:
.0186df	a0 00		ldy #$00			ldy 	#0
.0186e1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0186e3	c8		iny				iny
.0186e4	c8		iny				iny
.0186e5	c8		iny				iny
.0186e6	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0186e8	d0 16		bne $018700			bne 	RUN_NextCommand
.0186ea	4c 0c 88	jmp $01880c			jmp 	Command_STOP 				; go do the command code.
.0186ed					RUN_Skip:
.0186ed	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0186ef	c8		iny				iny 								; skip
.0186f0	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0186f2	90 0c		bcc $018700			bcc 	_SEDone 					; so just skip over it.
.0186f4	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0186f6	90 07		bcc $0186ff			bcc 	_SEDouble
.0186f8	98		tya				tya 								; this is Y + 1
.0186f9	18		clc				clc
.0186fa	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0186fc	a8		tay				tay 								; back in Y.
.0186fd	88		dey				dey 								; fix up, one for the +1, one for the iny
.0186fe	88		dey				dey
.0186ff					_SEDouble:
.0186ff	c8		iny				iny
.018700					_SEDone:
.018700					RUN_NextCommand:
.018700	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018702	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018704	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018706	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.018708	f0 e3		beq $0186ed			beq 	RUN_Skip
.01870a	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01870c	d0 0f		bne $01871d			bne 	RUN_Execute
.01870e					RUN_NextLine:
.01870e	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018710	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018712	18		clc				clc
.018713	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018715	85 16		sta $16				sta 	zCodePtr
.018717	90 02		bcc $01871b			bcc 	_SNLNoCarry
.018719	e6 17		inc $17				inc 	zCodePtr+1
.01871b					_SNLNoCarry:
.01871b	80 c2		bra $0186df			bra 	RUN_NewLine 				; go do the new line code
.01871d					RUN_Execute:
.01871d	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01871f	b0 1e		bcs $01873f			bcs 	RUN_Extension
.018721	c8		iny				iny
.018722	0a		asl a				asl 	a 							; double the character read.
.018723	90 14		bcc $018739			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018725	aa		tax				tax 								; ready to look up.
.018726	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into LocalVector
.01872a	8d 05 03	sta $0305			sta 	LocalVector+1
.01872d	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.018731	8d 06 03	sta $0306			sta 	LocalVector+2
.018734	20 27 89	jsr $018927			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018737	80 c7		bra $018700			bra 	RUN_NextCommand 			; do the next command.
.018739					RUN_Default:
.018739	88		dey				dey
.01873a	20 47 87	jsr $018747			jsr 	Command_LET 				; and try LET.
.01873d	80 c1		bra $018700			bra 	RUN_NextCommand
.01873f					RUN_Extension:
.01873f	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018741	f0 aa		beq $0186ed			beq 	RUN_Skip 					; skip over it.
.018743	4c 00 84	jmp $018400			jmp 	SyntaxError
.018746					Command_COLON:
.018746	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018747					Command_LET:
.018747	20 f1 90	jsr $0190f1			jsr 	VariableFind 				; get reference to one variable.
.01874a	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.01874c	20 37 90	jsr $019037			jsr 	CheckNextToken
.01874f	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018751	48		pha				pha
.018752	a5 23		lda $23				lda 	zVarDataPtr+1
.018754	48		pha				pha
.018755	a5 24		lda $24				lda 	zVarType
.018757	48		pha				pha
.018758	20 17 88	jsr $018817			jsr 	EvaluateExpression 			; evaluate the RHS.
.01875b	68		pla				pla 								; restore target variable information.
.01875c	85 24		sta $24				sta 	zVarType
.01875e	68		pla				pla
.01875f	85 23		sta $23				sta 	zVarDataPtr+1
.018761	68		pla				pla
.018762	85 22		sta $22				sta 	zVarDataPtr
.018764	20 ab 93	jsr $0193ab			jsr 	VariableSet 				; set the value out.
.018767	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018768					Command_END:
>018768	02						.byte 	2
.018769	4c be 86	jmp $0186be			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.01876c					Command_PRINT:
.01876c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01876e	c9 00		cmp #$00			cmp 	#0 							; end
.018770	f0 69		beq $0187db			beq 	_CPR_NewLine
.018772	c9 be		cmp #$be			cmp 	#token_Colon
.018774	f0 65		beq $0187db			beq 	_CPR_NewLine
.018776	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.018778	f0 54		beq $0187ce			beq 	_CPR_Skip
.01877a	c9 bd		cmp #$bd			cmp 	#token_Comma
.01877c	f0 4d		beq $0187cb			beq 	_CPR_Tab
.01877e	20 17 88	jsr $018817			jsr 	EvaluateExpression 			; get expression.
.018781	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018784	29 02		and #$02			and 	#2
.018786	d0 25		bne $0187ad			bne 	_CPR_String 				; if type = 2 output as string.
.018788					_CPR_Number:
.018788	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01878a	8d 04 04	sta $0404			sta 	NumBufX
.01878d	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018790	4a		lsr a				lsr 	a
.018791	b0 05		bcs $018798			bcs 	_CPRInt 					; if msb set do as integer
.018793	20 41 9b	jsr $019b41			jsr 	FPToString 					; call fp to str otherwise
.018796	80 03		bra $01879b			bra 	_CPRNPrint
.018798	20 2d 95	jsr $01952d	_CPRInt:jsr 	IntToString
.01879b					_CPRNPrint:
.01879b	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.01879e	c9 2d		cmp #$2d			cmp 	#"-"
.0187a0	f0 05		beq $0187a7			beq 	_CPRNoSpace
.0187a2	a9 20		lda #$20			lda 	#" "						; print the leading space
.0187a4	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.0187a7					_CPRNoSpace:
.0187a7	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.0187a9	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.0187ab	80 06		bra $0187b3			bra 	_CPRPrint
.0187ad					_CPR_String:
.0187ad	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.0187b0	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.0187b3					_CPRPrint:
.0187b3	86 1e		stx $1e				stx 	zGenPtr
.0187b5	85 1f		sta $1f				sta 	zGenPtr+1
.0187b7	5a		phy				phy
.0187b8	a0 00		ldy #$00			ldy 	#0							; get length into X
.0187ba	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0187bc	aa		tax				tax
.0187bd	f0 09		beq $0187c8			beq 	_CPREndPrint 				; nothing to print
.0187bf					_CPRLoop:
.0187bf	c8		iny				iny
.0187c0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0187c2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0187c5	ca		dex				dex
.0187c6	d0 f7		bne $0187bf			bne 	_CPRLoop
.0187c8					_CPREndPrint:
.0187c8	7a		ply				ply
.0187c9	80 a1		bra $01876c			bra 	Command_Print
.0187cb					_CPR_Tab:
.0187cb	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0187ce					_CPR_Skip:
.0187ce	c8		iny				iny
.0187cf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187d1	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.0187d3	f0 09		beq $0187de			beq 	_CPR_Exit
.0187d5	c9 00		cmp #$00			cmp 	#0
.0187d7	d0 93		bne $01876c			bne 	Command_PRINT 				; if not go round again.
.0187d9	80 03		bra $0187de			bra 	_CPR_Exit
.0187db					_CPR_NewLine:
.0187db	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.0187de					_CPR_Exit:
.0187de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0187df					Command_ASSERT:
.0187df	20 bd 89	jsr $0189bd			jsr 	EvaluateNumber 				; calculate thing being asserted
.0187e2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0187e5	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0187e8	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0187eb	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0187ee	f0 01		beq $0187f1			beq 	_ASFail
.0187f0	60		rts				rts
.0187f1					_ASFail:
.0187f1	20 2f 84	jsr $01842f			jsr ERR_Handler
>0187f4	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0187fb					Command_CLR:
.0187fb					ResetRunStatus:
.0187fb	20 fd 90	jsr $0190fd			jsr 	VariableClear
.0187fe	a9 00		lda #$00			lda 	#HighMemory & $FF
.018800	8d 00 04	sta $0400			sta 	StringPtr
.018803	a9 80		lda #$80			lda 	#HighMemory >> 8
.018805	8d 01 04	sta $0401			sta 	StringPtr+1
.018808	20 43 92	jsr $019243			jsr 	ArrayResetDefault
.01880b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.01880c					Command_STOP:
.01880c	20 2f 84	jsr $01842f			jsr ERR_Handler
>01880f	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018814					EVESyntax:
.018814	4c 00 84	jmp $018400			jmp 	SyntaxError
.018817					EvaluateExpression:
.018817	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018819					EvaluateExpressionX:
.018819	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01881b					EvaluateExpressionXA:
.01881b	48		pha				pha 								; save precedence on stack.
.01881c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01881e	f0 f4		beq $018814			beq 	EVESyntax 					; end of line, syntax error.
.018820	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018822	b0 03		bcs $018827			bcs 	_EVNotVariable
.018824	4c 1e 89	jmp $01891e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018827					_EVNotVariable:
.018827	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018829	90 e9		bcc $018814			bcc 	EVESyntax
.01882b	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01882d	b0 7f		bcs $0188ae			bcs 	_EVNotInteger
.01882f	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018831	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018834	a9 00		lda #$00			lda 	#0
.018836	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018839	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01883c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01883f	1a		inc a				inc 	a 							; set to type 1 (integer)
.018840	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018843					_EVCheckNextInteger:
.018843	c8		iny				iny
.018844	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018846	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018848	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01884a	b0 0d		bcs $018859			bcs 	_EVCheckDecimal
.01884c	48		pha				pha 								; save it.
.01884d	20 2a 89	jsr $01892a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018850	68		pla				pla
.018851	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018854	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018857	80 ea		bra $018843			bra 	_EVCheckNextInteger
.018859					_EVCheckDecimal:
.018859	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01885b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01885d	d0 05		bne $018864			bne 	_EVGotAtom 					; no, get atom.
.01885f					_EVIsDecimal:
.01885f	20 5a 89	jsr $01895a			jsr 	EVGetDecimal 				; extend to the decimal part.
.018862	80 00		bra $018864			bra 	_EVGotAtom 					; and continue to got atom.
.018864					_EVGotAtom:
.018864	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018866	10 44		bpl $0188ac			bpl 	_EVExitDrop 				; must be a token.
.018868	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01886a	b0 40		bcs $0188ac			bcs 	_EVExitDrop
.01886c	68		pla				pla 								; get current precedence
.01886d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01886f	da		phx				phx 								; save X
.018870	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018872	aa		tax				tax 								; put in X
.018873	bf dd 84 01	lda $0184dd,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018877	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018879	fa		plx				plx 								; restore X
.01887a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01887c	90 2f		bcc $0188ad			bcc 	_EVExit 					; exit if too low.
.01887e	f0 2d		beq $0188ad			beq 	_EVExit 					; exit if equals
.018880	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018882	48		pha				pha
.018883	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018885	48		pha				pha
.018886	c8		iny				iny
.018887	da		phx				phx 								; save current position
.018888	e8		inx				inx
.018889	e8		inx				inx
.01888a	e8		inx				inx
.01888b	e8		inx				inx
.01888c	e8		inx				inx
.01888d	e8		inx				inx
.01888e	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018890	20 1b 88	jsr $01881b			jsr 	EvaluateExpressionXA 		; do the RHS.
.018893	fa		plx				plx 								; restore X
.018894	68		pla				pla 								; get the binary operator in A.
.018895					_EVCallA:
.018895	da		phx				phx 								; save X again
.018896	0a		asl a				asl 	a 							; double, lose the MSB.
.018897	aa		tax				tax									; put in X
.018898	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01889c	8d 05 03	sta $0305			sta 	LocalVector+1
.01889f	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0188a3	8d 06 03	sta $0306			sta 	LocalVector+2
.0188a6	fa		plx				plx 								; restore X
.0188a7	20 27 89	jsr $018927			jsr 	EVCallLocalVector
.0188aa	80 b8		bra $018864			bra 	_EVGotAtom 					; and loop back.
.0188ac					_EVExitDrop:
.0188ac	68		pla				pla
.0188ad					_EVExit:
.0188ad	60		rts				rts
.0188ae					_EVNotInteger:
.0188ae	c8		iny				iny
.0188af	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0188b1	d0 19		bne $0188cc			bne 	_EVNotMinus
.0188b3	20 ab 89	jsr $0189ab			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0188b6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0188b9	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0188bb	f0 05		beq $0188c2			beq 	_EVMinusFloat
.0188bd	20 08 95	jsr $019508			jsr 	IntegerNegateAlways 		; negation
.0188c0	80 a2		bra $018864			bra 	_EVGotAtom 					; and go back.
.0188c2					_EVMinusFloat:
.0188c2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.0188c5	49 80		eor #$80			eor 	#$80
.0188c7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0188ca	80 98		bra $018864			bra 	_EVGotAtom
.0188cc					_EVNotMinus:
.0188cc	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.0188ce	d0 17		bne $0188e7			bne 	_EVNotParenthesis
.0188d0	20 19 88	jsr $018819			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0188d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d5	c8		iny				iny
.0188d6	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0188d8	f0 8a		beq $018864			beq 	_EVGotAtom
.0188da	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188dd	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0188e5	29 00
.0188e7					_EVNotParenthesis:
.0188e7	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0188e9	d0 0c		bne $0188f7			bne 	_EVNotNot
.0188eb	20 ab 89	jsr $0189ab			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0188ee	20 16 9a	jsr $019a16			jsr 	FPUToInteger 				; make it an integer - if possible.
.0188f1	20 88 89	jsr $018988			jsr 	NotInteger 					; do the not calculation
.0188f4	4c 64 88	jmp $018864			jmp 	_EVGotAtom
.0188f7					_EVNotNot:
.0188f7	c9 fe		cmp #$fe			cmp 	#$FE
.0188f9	d0 15		bne $018910			bne 	_EVNotString
.0188fb	20 cb 90	jsr $0190cb			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0188fe	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018900	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018903	a5 21		lda $21				lda 	zTempStr+1
.018905	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018908	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.01890a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01890d	4c 64 88	jmp $018864			jmp 	_EVGotAtom
.018910					_EVNotString:
.018910	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018912	90 04		bcc $018918			bcc 	_EVBadElement
.018914	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.018916	90 03		bcc $01891b			bcc 	_EVUnaryFunction
.018918					_EVBadElement:
.018918	4c 00 84	jmp $018400			jmp 	SyntaxError
.01891b					_EVUnaryFunction:
.01891b	4c 95 88	jmp $018895			jmp 	_EVCallA
.01891e					_EVVariableHandler:
.01891e	20 f1 90	jsr $0190f1			jsr 	VariableFind 				; locate a variable
.018921	20 4a 93	jsr $01934a			jsr 	VariableGet 				; copy into memory.
.018924	4c 64 88	jmp $018864			jmp 	_EVGotAtom 					; and go round.
.018927					EVCallLocalVector:
.018927	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.01892a					EVShiftMantissaLeft6:
.01892a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.01892d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.018930	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018933	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018936	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018939	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01893c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01893f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018942	a9 00		lda #$00			lda 	#0
.018944	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018947	20 4a 89	jsr $01894a			jsr 	_EVSMLShift 					; call it here to do it twice
.01894a					_EVSMLShift:
.01894a	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.01894d	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.018950	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018953	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018956	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018959	60		rts				rts
.01895a					EVGetDecimal:
.01895a	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01895c	8d 05 04	sta $0405			sta 	Num_Buffer
.01895f	da		phx				phx
.018960	c8		iny				iny
.018961	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018963	c8		iny				iny
.018964	3a		dec a				dec 	a								; convert to a string length.
.018965	3a		dec a				dec 	a
.018966	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018968					_EVGDCopy:
.018968	48		pha				pha 									; save count
.018969	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01896b	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.01896e	e8		inx				inx 									; forward ....
.01896f	c8		iny				iny
.018970	68		pla				pla 									; get count
.018971	3a		dec a				dec 	a 								; until zero
.018972	d0 f4		bne $018968			bne 	_EVGDCopy
.018974	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018977	fa		plx				plx 									; restore X
.018978	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01897a	85 1e		sta $1e				sta 	zGenPtr
.01897c	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.01897e	85 1f		sta $1f				sta 	zGenPtr+1
.018980	5a		phy				phy 									; save Y
.018981	a0 00		ldy #$00			ldy 	#0 								; start position
.018983	20 08 9c	jsr $019c08			jsr 	FPFromString 					; convert current
.018986	7a		ply				ply 									; restore Y
.018987	60		rts				rts
.018988					NotInteger:
.018988	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01898b	49 ff		eor #$ff			eor 	#$FF
.01898d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018990	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018993	49 ff		eor #$ff			eor 	#$FF
.018995	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018998	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01899b	49 ff		eor #$ff			eor 	#$FF
.01899d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189a0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189a3	49 ff		eor #$ff			eor 	#$FF
.0189a5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189a8	60		rts				rts
.0189a9					EvaluateGetAtom:
.0189a9	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0189ab					EvaluateGetAtomX:
.0189ab	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0189ad	20 1b 88	jsr $01881b			jsr 	EvaluateExpressionXA
.0189b0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0189b3	29 0f		and #$0f			and 	#15
.0189b5	c9 02		cmp #$02			cmp 	#2
.0189b7	b0 01		bcs $0189ba			bcs 	EvaluateType
.0189b9	60		rts				rts
.0189ba					EvaluateType:
.0189ba	4c 10 84	jmp $018410			jmp 	TypeError
.0189bd					EvaluateNumber:
.0189bd	a2 00		ldx #$00			ldx 	#0
.0189bf					EvaluateNumberX:
.0189bf	20 19 88	jsr $018819			jsr 	EvaluateExpressionX
.0189c2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.0189c5	29 0f		and #$0f			and 	#15
.0189c7	c9 02		cmp #$02			cmp 	#2
.0189c9	b0 ef		bcs $0189ba			bcs 	EvaluateType
.0189cb	60		rts				rts
.0189cc					EvaluateInteger:
.0189cc	a2 00		ldx #$00			ldx 	#0
.0189ce					EvaluateIntegerX:
.0189ce	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX
.0189d1	20 16 9a	jsr $019a16			jsr 	FPUToInteger
.0189d4	60		rts				rts
.0189d5					EvaluateString:
.0189d5	a2 00		ldx #$00			ldx 	#0
.0189d7					EvaluateStringX:
.0189d7	20 19 88	jsr $018819			jsr 	EvaluateExpressionX
.0189da	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0189dd	29 0f		and #$0f			and 	#15
.0189df	c9 02		cmp #$02			cmp 	#2
.0189e1	d0 d7		bne $0189ba			bne 	EvaluateType
.0189e3	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0189e6	85 1e		sta $1e				sta 	zGenPtr
.0189e8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189eb	85 1f		sta $1f				sta 	zGenPtr+1
.0189ed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0189ee					BinaryOp_And:
.0189ee	20 66 8a	jsr $018a66			jsr 	BinaryMakeBothInteger
.0189f1	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0189f4	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0189f7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189fa	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0189fd	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.018a00	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a03	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a06	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018a09	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a0c	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a0f	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018a12	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a15	60		rts				rts
.018a16					BinaryOp_Or:
.018a16	20 66 8a	jsr $018a66			jsr 	BinaryMakeBothInteger
.018a19	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a1c	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018a1f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a22	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018a25	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018a28	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a2b	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a2e	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018a31	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a34	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a37	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018a3a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a3d	60		rts				rts
.018a3e					BinaryOp_Eor:
.018a3e					BinaryOp_Xor:
.018a3e	20 66 8a	jsr $018a66			jsr 	BinaryMakeBothInteger
.018a41	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a44	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018a47	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a4a	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018a4d	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018a50	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a53	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a56	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018a59	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a5c	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a5f	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018a62	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a65	60		rts				rts
.018a66					BinaryMakeBothInteger:
.018a66	da		phx				phx 								; save X
.018a67	e8		inx				inx
.018a68	e8		inx				inx
.018a69	e8		inx				inx
.018a6a	e8		inx				inx
.018a6b	e8		inx				inx
.018a6c	e8		inx				inx
.018a6d	20 71 8a	jsr $018a71			jsr 	BinaryMakeInteger 			; convert to integer.
.018a70	fa		plx				plx 								; restore X and fall through.
.018a71					BinaryMakeInteger:
.018a71	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018a74	29 0f		and #$0f			and 	#15 						; check type zero
.018a76	f0 04		beq $018a7c			beq 	_BMIConvert 				; if float convert to integer.
.018a78	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018a79	90 04		bcc $018a7f			bcc 	_BMIError
.018a7b	60		rts				rts
.018a7c					_BMIConvert:
.018a7c	4c 16 9a	jmp $019a16			jmp 	FPUToInteger 				; convert to integer
.018a7f					_BMIError:
.018a7f	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018a82					Binary_Equal:
.018a82	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018a85	09 00		ora #$00			ora 	#0
.018a87	f0 04		beq $018a8d			beq 	CCTrue
.018a89	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018a8b	80 02		bra $018a8f			bra 	CCWrite
.018a8d	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018a8f	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018a92	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a95	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a98	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a9b	a9 01		lda #$01			lda 	#1
.018a9d	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018aa0	60		rts				rts
.018aa1					Binary_NotEqual:
.018aa1	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018aa4	09 00		ora #$00			ora 	#0
.018aa6	f0 e1		beq $018a89			beq 	CCFalse
.018aa8	80 e3		bra $018a8d			bra 	CCTrue
.018aaa					Binary_Less:
.018aaa	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018aad	09 00		ora #$00			ora 	#0
.018aaf	30 dc		bmi $018a8d			bmi 	CCTrue
.018ab1	80 d6		bra $018a89			bra 	CCFalse
.018ab3					Binary_LessEqual:
.018ab3	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018ab6	c9 01		cmp #$01			cmp 	#1
.018ab8	d0 d3		bne $018a8d			bne 	CCTrue
.018aba	80 cd		bra $018a89			bra 	CCFalse
.018abc					Binary_GreaterEqual:
.018abc	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018abf	09 00		ora #$00			ora 	#0
.018ac1	10 ca		bpl $018a8d			bpl 	CCTrue
.018ac3	80 c4		bra $018a89			bra 	CCFalse
.018ac5					Binary_Greater:
.018ac5	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018ac8	c9 01		cmp #$01			cmp 	#1
.018aca	f0 c1		beq $018a8d			beq 	CCTrue
.018acc	80 bb		bra $018a89			bra 	CCFalse
.018ace					CompareValues:
.018ace	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018ad1	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ad4	c9 02		cmp #$02			cmp 	#2
.018ad6	f0 13		beq $018aeb			beq 	_CVString
.018ad8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018adb	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ade	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018adf	90 03		bcc $018ae4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ae1	4c 31 8b	jmp $018b31			jmp 	CompareInteger32 							; so execute code at \1
.018ae4					_BCFloat:
.018ae4	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ae7	4c 25 99	jmp $019925			jmp 	FPCompare 							; and execute code at \2
.018aea	60		rts				rts
.018aeb					_CVString:
.018aeb	da		phx				phx 								; save XY
.018aec	5a		phy				phy
.018aed	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018af0	85 1a		sta $1a				sta		zLTemp1+0
.018af2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018af5	85 1b		sta $1b				sta 	zLTemp1+1
.018af7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018afa	85 1c		sta $1c				sta 	zLTemp1+2
.018afc	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018aff	85 1d		sta $1d				sta 	zLTemp1+3
.018b01	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018b03	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018b05	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b07	90 02		bcc $018b0b			bcc 	_CVCommon
.018b09	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018b0b					_CVCommon:
.018b0b	aa		tax				tax 								; put shorter string length in zero.
.018b0c	f0 0c		beq $018b1a			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018b0e					_CVCompare:
.018b0e	c8		iny				iny 								; next character
.018b0f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018b11	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b13	90 13		bcc $018b28			bcc 	_CVReturnLess 				; <
.018b15	d0 15		bne $018b2c			bne 	_CVReturnGreater 			; >
.018b17	ca		dex				dex 								; until common length matched.
.018b18	d0 f4		bne $018b0e			bne 	_CVCompare
.018b1a					_CVMatch:
.018b1a	a0 00		ldy #$00			ldy 	#0
.018b1c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018b1e	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b20	90 06		bcc $018b28			bcc 	_CVReturnLess 				; <
.018b22	d0 08		bne $018b2c			bne 	_CVReturnGreater 			; >
.018b24	a9 00		lda #$00			lda 	#0
.018b26	80 06		bra $018b2e			bra 	_CVExit 					; same common, same length, same string
.018b28					_CVReturnLess:
.018b28	a9 ff		lda #$ff			lda 	#$FF
.018b2a	80 02		bra $018b2e			bra 	_CVExit
.018b2c					_CVReturnGreater:
.018b2c	a9 01		lda #$01			lda 	#$01
.018b2e					_CVExit:
.018b2e	7a		ply				ply
.018b2f	fa		plx				plx
.018b30	60		rts				rts
.018b31					CompareInteger32:
.018b31	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018b34	49 80		eor #$80			eor 	#$80
.018b36	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b39	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018b3c	49 80		eor #$80			eor 	#$80
.018b3e	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018b41	20 d9 8b	jsr $018bd9			jsr 	SubInteger32 				; subtraction
.018b44	90 11		bcc $018b57			bcc 	_CI32Less 					; cc return -1
.018b46	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018b49	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018b4c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018b4f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018b52	f0 02		beq $018b56			beq 	_CI32Exit
.018b54	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018b56					_CI32Exit:
.018b56	60		rts				rts
.018b57					_CI32Less:
.018b57	a9 ff		lda #$ff			lda 	#$FF
.018b59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018b5a					BinaryOp_Add:
.018b5a	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018b5d	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b60	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018b62	d0 13		bne $018b77			bne 	_BOAString
.018b64	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b67	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b6a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b6b	90 03		bcc $018b70			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b6d	4c b3 8b	jmp $018bb3			jmp 	AddInteger32 							; so execute code at \1
.018b70					_BCFloat:
.018b70	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b73	4c 99 96	jmp $019699			jmp 	FPAdd 							; and execute code at \2
.018b76	60		rts				rts
.018b77					_BOAString:
.018b77	4c 1a 8c	jmp $018c1a			jmp 	ConcatenateString 			; concatenate two strings.
.018b7a					BinaryOp_Subtract:
.018b7a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b7d	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b80	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b81	90 03		bcc $018b86			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b83	4c d9 8b	jmp $018bd9			jmp 	SubInteger32 							; so execute code at \1
.018b86					_BCFloat:
.018b86	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b89	4c 8f 96	jmp $01968f			jmp 	FPSubtract 							; and execute code at \2
.018b8c	60		rts				rts
.018b8d					BinaryOp_Multiply:
.018b8d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b90	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b93	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b94	90 03		bcc $018b99			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b96	4c 1b 94	jmp $01941b			jmp 	MulInteger32 							; so execute code at \1
.018b99					_BCFloat:
.018b99	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b9c	4c 05 98	jmp $019805			jmp 	FPMultiply 							; and execute code at \2
.018b9f	60		rts				rts
.018ba0					BinaryOp_Divide:
.018ba0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018ba3	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ba6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018ba7	90 03		bcc $018bac			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ba9	4c 72 94	jmp $019472			jmp 	DivInteger32 							; so execute code at \1
.018bac					_BCFloat:
.018bac	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018baf	4c 7d 97	jmp $01977d			jmp 	FPDivide 							; and execute code at \2
.018bb2	60		rts				rts
.018bb3					AddInteger32:
.018bb3	18		clc				clc
.018bb4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bb7	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018bba	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018bbd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018bc0	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018bc3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018bc6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018bc9	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018bcc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018bcf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018bd2	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018bd5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bd8	60		rts				rts
.018bd9					SubInteger32:
.018bd9	38		sec				sec
.018bda	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bdd	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018be0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018be3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018be6	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018be9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018bec	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018bef	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018bf2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018bf5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018bf8	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018bfb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bfe	60		rts				rts
.018bff					BinaryMakeBothFloat:
.018bff	da		phx				phx 								; save X
.018c00	e8		inx				inx
.018c01	e8		inx				inx
.018c02	e8		inx				inx
.018c03	e8		inx				inx
.018c04	e8		inx				inx
.018c05	e8		inx				inx
.018c06	20 0a 8c	jsr $018c0a			jsr 	BinaryMakeFloat 			; convert to float.
.018c09	fa		plx				plx 								; restore X and fall through.
.018c0a					BinaryMakeFloat:
.018c0a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018c0d	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018c0e	b0 04		bcs $018c14			bcs 	_BMFConvert
.018c10	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018c11	b0 04		bcs $018c17			bcs 	_BMFError
.018c13	60		rts				rts
.018c14					_BMFConvert:
.018c14	4c b7 99	jmp $0199b7			jmp 	FPUToFloat 					; convert to float
.018c17					_BMFError:
.018c17	4c 10 84	jmp $018410			jmp 	TypeError
.018c1a					ConcatenateString:
.018c1a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018c1d	85 1a		sta $1a				sta		zLTemp1+0
.018c1f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c22	85 1b		sta $1b				sta 	zLTemp1+1
.018c24	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018c27	85 1c		sta $1c				sta 	zLTemp1+2
.018c29	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018c2c	85 1d		sta $1d				sta 	zLTemp1+3
.018c2e	5a		phy				phy
.018c2f	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018c31	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018c33	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018c35	7a		ply				ply
.018c36	b0 37		bcs $018c6f			bcs 	_CSError					; check in range.
.018c38	c9 fe		cmp #$fe			cmp 	#maxString+1
.018c3a	b0 33		bcs $018c6f			bcs 	_CSError
.018c3c	20 90 90	jsr $019090			jsr 	AllocateTempString 			; store the result
.018c3f	20 5a 8c	jsr $018c5a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018c42	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018c45	85 1a		sta $1a				sta 	zLTemp1
.018c47	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018c4a	85 1b		sta $1b				sta 	zLTemp1+1
.018c4c	20 5a 8c	jsr $018c5a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018c4f	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018c51	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c54	a5 21		lda $21				lda 	zTempStr+1
.018c56	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c59	60		rts				rts
.018c5a					_CSCopyString:
.018c5a	da		phx				phx
.018c5b	5a		phy				phy
.018c5c	a0 00		ldy #$00			ldy 	#0 							; get length
.018c5e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c60	f0 0a		beq $018c6c			beq 	_CSCSExit 					; if zero, exit
.018c62	aa		tax				tax 								; put in X
.018c63					_CSCSLoop:
.018c63	c8		iny				iny 								; get next char
.018c64	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c66	20 bb 90	jsr $0190bb			jsr		WriteTempString 			; copy out
.018c69	ca		dex				dex 								; do whole string
.018c6a	d0 f7		bne $018c63			bne 	_CSCSLoop
.018c6c					_CSCSExit:
.018c6c	7a		ply				ply
.018c6d	fa		plx				plx
.018c6e	60		rts				rts
.018c6f					_CSError:
.018c6f	20 2f 84	jsr $01842f			jsr ERR_Handler
>018c72	53 74 72 69 6e 67 20 74			.text "String too long",0
>018c7a	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018c82					Unary_Sgn:
.018c82	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.018c85	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.018c88	20 ac 8c	jsr $018cac			jsr 	GetSignCurrent 				; get sign.
.018c8b	09 00		ora #$00			ora 	#0
.018c8d	10 09		bpl $018c98			bpl		UnarySetAInteger			; if 0,1 return that.
.018c8f	80 00		bra $018c91			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018c91					UnarySetAMinus1:
.018c91	a9 ff		lda #$ff			lda 	#$FF
.018c93	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018c96	80 05		bra $018c9d			bra 	UnarySetAFill
.018c98					UnarySetAInteger:
.018c98	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018c9b	a9 00		lda #$00			lda 	#0
.018c9d					UnarySetAFill:
.018c9d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ca0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ca3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ca6	a9 01		lda #$01			lda 	#1
.018ca8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018cab	60		rts				rts
.018cac					GetSignCurrent:
.018cac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018caf	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018cb0	90 19		bcc $018ccb			bcc 	_GSCFloat
.018cb2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018cb5	30 11		bmi $018cc8			bmi 	_GSCMinus1
.018cb7	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018cba	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018cbd	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cc0	d0 03		bne $018cc5			bne 	_GSCPlus1
.018cc2					_GSCZero:
.018cc2	a9 00		lda #$00			lda 	#0
.018cc4	60		rts				rts
.018cc5					_GSCPlus1:
.018cc5	a9 01		lda #$01			lda 	#$01
.018cc7	60		rts				rts
.018cc8					_GSCMinus1:
.018cc8	a9 ff		lda #$ff			lda 	#$FF
.018cca	60		rts				rts
.018ccb					_GSCFloat:
.018ccb	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018cce	70 f2		bvs $018cc2			bvs 	_GSCZero
.018cd0	30 f6		bmi $018cc8			bmi 	_GSCMinus1
.018cd2	80 f1		bra $018cc5			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018cd4					Unary_Abs:
.018cd4	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.018cd7	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.018cda	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018cdd	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018cdf	f0 08		beq $018ce9			beq 	_UAMinusFloat
.018ce1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018ce4	10 0b		bpl $018cf1			bpl 	_UAExit
.018ce6	4c 08 95	jmp $019508			jmp 	IntegerNegateAlways 		; negation
.018ce9					_UAMinusFloat:
.018ce9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018cec	29 7f		and #$7f			and		#$7F
.018cee	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018cf1					_UAExit:
.018cf1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018cf2					Unary_Peek:
.018cf2	a9 01		lda #$01			lda 	#1
.018cf4	80 06		bra $018cfc			bra 	UPMain
.018cf6					Unary_Deek:
.018cf6	a9 02		lda #$02			lda 	#2
.018cf8	80 02		bra $018cfc			bra 	UPMain
.018cfa					Unary_Leek:
.018cfa	a9 04		lda #$04			lda 	#4
.018cfc					UPMain:
.018cfc	48		pha				pha 								; set bytes to copy.
.018cfd	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; numeric parameter
.018d00	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018d03	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018d06	85 1a		sta $1a				sta 	zLTemp1
.018d08	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d0b	85 1b		sta $1b				sta 	zLTemp1+1
.018d0d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018d10	85 1c		sta $1c				sta 	zLTemp1+2
.018d12	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d15	85 1d		sta $1d				sta 	zLTemp1+3
.018d17	a9 00		lda #$00			lda 	#0 							; clear target area
.018d19	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d1c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d1f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d22	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d25	68		pla				pla 								; restore bytes to copy
.018d26	da		phx				phx 								; save XY
.018d27	5a		phy				phy
.018d28	20 25 90	jsr $019025			jsr 	MemRead 					; read the bytes in
.018d2b	7a		ply				ply 								; restore and exit
.018d2c	fa		plx				plx
.018d2d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018d2e					Unary_Mod:
.018d2e	20 5a 8d	jsr $018d5a			jsr 	_UMParameter 				; first parameter
.018d31	20 56 90	jsr $019056			jsr 	CheckNextComma
.018d34	da		phx				phx 								; second parameter
.018d35	e8		inx				inx
.018d36	e8		inx				inx
.018d37	e8		inx				inx
.018d38	e8		inx				inx
.018d39	e8		inx				inx
.018d3a	e8		inx				inx
.018d3b	20 5a 8d	jsr $018d5a			jsr 	_UMParameter
.018d3e	fa		plx				plx
.018d3f	20 4e 90	jsr $01904e			jsr 	CheckNextRParen
.018d42	20 72 94	jsr $019472			jsr 	DivInteger32 				; divide
.018d45	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018d47	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d4a	a5 1b		lda $1b				lda 	zLTemp1+1
.018d4c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d4f	a5 1c		lda $1c				lda 	zLTemp1+2
.018d51	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d54	a5 1d		lda $1d				lda 	zLTemp1+3
.018d56	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d59	60		rts				rts
.018d5a					_UMParameter:
.018d5a	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; get value
.018d5d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018d60	10 03		bpl $018d65			bpl 	_UMNotSigned
.018d62	20 08 95	jsr $019508			jsr 	IntegerNegateAlways
.018d65					_UMNotSigned:
.018d65	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018d66					Unary_Usr:
.018d66	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; numeric parameter
.018d69	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018d6c	da		phx				phx 								; save XY
.018d6d	5a		phy				phy
.018d6e	ea		nop				nop
.018d6f	22 00 03 00	jsl $000300			jsl 	UserVector
.018d73	7a		ply				ply 								; and exit
.018d74	fa		plx				plx
.018d75	60		rts				rts
.018d76					USRDefault:
.018d76	20 2f 84	jsr $01842f			jsr ERR_Handler
>018d79	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018d81	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018d88					Unary_Val:
.018d88	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; get string
.018d8b	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.018d8e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018d91	85 1e		sta $1e				sta 	zGenPtr
.018d93	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d96	85 1f		sta $1f				sta 	zGenPtr+1
.018d98	5a		phy				phy
.018d99	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018d9b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018d9d	f0 57		beq $018df6			beq 	_UVBadNumber
.018d9f	48		pha				pha 								; save length.
.018da0	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018da1	1a		inc a				inc 	a
.018da2	20 90 90	jsr $019090			jsr 	AllocateTempString
.018da5	c8		iny				iny 								; move to the next.
.018da6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018da8	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018daa	8d 90 04	sta $0490			sta 	ValSign
.018dad	d0 04		bne $018db3			bne 	_UVNotMinus
.018daf	c8		iny				iny 								; skip over it.
.018db0	68		pla				pla 								; decrement character count.
.018db1	3a		dec a				dec 	a
.018db2	48		pha				pha
.018db3					_UVNotMinus:
.018db3	68		pla				pla 								; this is the count.
.018db4	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018db5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018db7	c8		iny				iny
.018db8	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018dbb	68		pla				pla
.018dbc	3a		dec a				dec 	a
.018dbd	d0 f5		bne $018db4			bne 	_UVCopy
.018dbf	20 bb 90	jsr $0190bb			jsr 	WriteTempString 			; make it ASCIIZ
.018dc2	18		clc				clc
.018dc3	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018dc5	69 01		adc #$01			adc 	#1
.018dc7	85 1e		sta $1e				sta 	zGenPtr
.018dc9	a5 21		lda $21				lda 	zTempStr+1
.018dcb	69 00		adc #$00			adc 	#0
.018dcd	85 1f		sta $1f				sta 	zGenPtr+1
.018dcf	18		clc				clc
.018dd0	20 e4 95	jsr $0195e4			jsr 	IntFromString 				; first bit.
.018dd3	b0 21		bcs $018df6			bcs 	_UVBadNumber
.018dd5	20 08 9c	jsr $019c08			jsr 	FPFromString				; try for a float part.
.018dd8	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.018ddb	d0 13		bne $018df0			bne 	_UVNotNegative
.018ddd	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018de0	4a		lsr a				lsr 	a
.018de1	b0 0a		bcs $018ded			bcs 	_UVInteger
.018de3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018de6	09 80		ora #$80			ora 	#$80
.018de8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018deb	80 03		bra $018df0			bra 	_UVNotNegative
.018ded					_UVInteger:
.018ded	20 08 95	jsr $019508			jsr 	IntegerNegateAlways 		; sign it.
.018df0					_UVNotNegative:
.018df0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018df2	d0 02		bne $018df6			bne 	_UVBadNumber
.018df4	7a		ply				ply
.018df5	60		rts				rts
.018df6					_UVBadNumber:
.018df6	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018df9					Unary_Str:
.018df9	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; numeric parameter
.018dfc	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018dff	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e01	8d 04 04	sta $0404			sta 	NumBufX
.018e04	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018e07	4a		lsr a				lsr 	a
.018e08	b0 05		bcs $018e0f			bcs 	_USInt 						; if msb set do as integer
.018e0a	20 41 9b	jsr $019b41			jsr 	FPToString 					; call fp to str otherwise
.018e0d	80 03		bra $018e12			bra 	_USDuplicate
.018e0f	20 2d 95	jsr $01952d	_USInt:	jsr 	IntToString
.018e12					_USDuplicate:
.018e12	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.018e15	1a		inc a				inc 	a 							; one more for length
.018e16	20 90 90	jsr $019090			jsr 	AllocateTempString 			; allocate space for it.
.018e19	5a		phy				phy 								; save Y
.018e1a	a0 00		ldy #$00			ldy 	#0 							; start copying
.018e1c	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018e1f	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018e22	c8		iny				iny
.018e23	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.018e26	d0 f4		bne $018e1c			bne 	_USCopy
.018e28	7a		ply				ply 								; restore Y
.018e29	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018e2c					Unary_Asc:
.018e2c	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; string parameter
.018e2f	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018e32	5a		phy				phy 								; get the string length
.018e33	a0 00		ldy #$00			ldy 	#0
.018e35	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e37	f0 07		beq $018e40			beq 	_UAIllegal 					; must be at least one character
.018e39	c8		iny				iny
.018e3a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018e3c	7a		ply				ply
.018e3d	4c 98 8c	jmp $018c98			jmp 	UnarySetAInteger
.018e40					_UAIllegal:
.018e40	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018e43					Unary_Len:
.018e43	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; string parameter
.018e46	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018e49	5a		phy				phy 								; get the string length
.018e4a	a0 00		ldy #$00			ldy 	#0
.018e4c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e4e	7a		ply				ply
.018e4f	4c 98 8c	jmp $018c98			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018e52					Unary_Mid:
.018e52	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 				; get string.
.018e55	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e58	48		pha				pha
.018e59	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e5c	48		pha				pha
.018e5d	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e60	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018e63	48		pha				pha 									; and push it.
.018e64	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e67	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018e6a	48		pha				pha 									; and push it.
.018e6b	80 45		bra $018eb2			bra 	SLIProcess
.018e6d					Unary_Left:
.018e6d	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 				; get string.
.018e70	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e73	48		pha				pha
.018e74	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e77	48		pha				pha
.018e78	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018e7a	48		pha				pha
.018e7b	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e7e	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018e81	48		pha				pha 									; and push it.
.018e82	80 2e		bra $018eb2			bra 	SLIProcess
.018e84					Unary_Right:
.018e84	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 				; get string.
.018e87	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e8a	48		pha				pha
.018e8b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e8e	48		pha				pha
.018e8f	da		phx				phx 									; get the string length and push on stack.
.018e90	a2 00		ldx #$00			ldx 	#0
.018e92	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018e94	fa		plx				plx
.018e95	48		pha				pha
.018e96	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e99	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter.
.018e9c	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.018e9f	68		pla				pla 									; restore string length.
.018ea0	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018ea1	38		sec				sec
.018ea2	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.018ea5	f0 02		beq $018ea9			beq 	_URStart 						; if <= 0 start from 1.
.018ea7	10 02		bpl $018eab			bpl 	_UROkay
.018ea9					_URStart:
.018ea9	a9 01		lda #$01			lda 	#1
.018eab					_UROkay:
.018eab	48		pha				pha 									; push start
.018eac	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.018eaf	48		pha				pha
.018eb0	80 00		bra $018eb2			bra 	SLIProcess
.018eb2					SLIProcess:
.018eb2	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 				; closing right bracket.
.018eb5	68		pla				pla
.018eb6	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.018eb9	1a		inc a				inc 	a 								; allocate +1 for it.
.018eba	20 90 90	jsr $019090			jsr 	AllocateTempString
.018ebd	68		pla				pla 									; pop start number off stack.
.018ebe	f0 3f		beq $018eff			beq 	SLIError 						; exit if start = 0
.018ec0	8d 91 04	sta $0491			sta 	SliceStart
.018ec3	68		pla				pla  									; pop string address.
.018ec4	85 1f		sta $1f				sta 	zGenPtr+1
.018ec6	68		pla				pla
.018ec7	85 1e		sta $1e				sta 	zGenPtr
.018ec9	da		phx				phx
.018eca	5a		phy				phy
.018ecb	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018ecd	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.018ed0					_SLICopy:
.018ed0	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.018ed3	f0 12		beq $018ee7			beq 	_SLIExit
.018ed5	ce 92 04	dec $0492			dec 	SliceCount
.018ed8	98		tya				tya 									; index of character
.018ed9	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018edb	f0 02		beq $018edf			beq 	_SLIOk 							; if equal, okay.
.018edd	b0 08		bcs $018ee7			bcs 	_SLIExit 						; if past end, then exit.
.018edf	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018ee1	c8		iny				iny
.018ee2	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018ee5	80 e9		bra $018ed0			bra 	_SLICopy 						; go round till copied characters
.018ee7					_SLIExit:
.018ee7	7a		ply				ply 									; restore YX
.018ee8	fa		plx				plx
.018ee9	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018eec	ea		nop				nop
.018eed					SLIByteParameter:
.018eed	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 				; get integer
.018ef0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018ef3	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ef6	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ef9	d0 04		bne $018eff			bne 	SLIError
.018efb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018efe	60		rts				rts
.018eff					SLIError:
.018eff	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018f02					Unary_Hex:
.018f02	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; numeric parameter
.018f05	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018f08	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018f0a	20 90 90	jsr $019090			jsr 	AllocateTempString			; allocate string space
.018f0d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018f10	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f13	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f16	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f19	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f1c	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f1f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018f22	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f25	5a		phy				phy 								; get length of new string
.018f26	a0 00		ldy #$00			ldy 	#0
.018f28	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f2a	7a		ply				ply
.018f2b	c9 00		cmp #$00			cmp 	#0
.018f2d	d0 05		bne $018f34			bne 	_UHExit 					; if it was non zero okay
.018f2f	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018f31	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018f34					_UHExit:
.018f34	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018f37					_UHConvert:
.018f37	48		pha				pha
.018f38	4a		lsr a				lsr 	a 							; do MSB
.018f39	4a		lsr a				lsr 	a
.018f3a	4a		lsr a				lsr 	a
.018f3b	4a		lsr a				lsr 	a
.018f3c	20 40 8f	jsr $018f40			jsr 	_UHNibble
.018f3f	68		pla				pla 								; do LSB
.018f40					_UHNibble:
.018f40	29 0f		and #$0f			and 	#15 						; get nibble
.018f42	d0 0c		bne $018f50			bne 	_UHNonZero
.018f44	5a		phy				phy									; get the length
.018f45	a0 00		ldy #$00			ldy 	#0
.018f47	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f49	7a		ply				ply
.018f4a	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018f4c	f0 0d		beq $018f5b			beq 	_UHExit2
.018f4e	a9 00		lda #$00			lda 	#0
.018f50					_UHNonZero:
.018f50	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018f52	90 02		bcc $018f56			bcc 	_UHDigit
.018f54	69 06		adc #$06			adc 	#7-1
.018f56					_UHDigit:
.018f56	69 30		adc #$30			adc 	#48
.018f58	20 bb 90	jsr $0190bb			jsr 	WriteTempString				; output.
.018f5b					_UHExit2:
.018f5b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018f5c					Unary_Dec:
.018f5c	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; string parameter
.018f5f	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018f62	5a		phy				phy
.018f63	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018f65	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f67	f0 4c		beq $018fb5			beq 	_UDFail 					; must fail if zero.
.018f69	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.018f6c	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018f6e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018f71	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f74	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f77	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f7a	a9 01		lda #$01			lda 	#1
.018f7c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018f7f					_UDConvertLoop:
.018f7f	5a		phy				phy 								; shift mantissa left 4
.018f80	a0 04		ldy #$04			ldy 	#4
.018f82					_UDShift:
.018f82	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018f85	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018f88	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018f8b	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018f8e	88		dey				dey
.018f8f	d0 f1		bne $018f82			bne 	_UDShift
.018f91	7a		ply				ply
.018f92	c8		iny				iny 								; next character
.018f93	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018f95	20 b8 8f	jsr $018fb8			jsr 	ConvertUpper 				; convert to U/C
.018f98	c9 30		cmp #$30			cmp 	#"0"
.018f9a	90 19		bcc $018fb5			bcc 	_UDFail
.018f9c	c9 3a		cmp #$3a			cmp 	#"9"+1
.018f9e	90 06		bcc $018fa6			bcc 	_UDOkay
.018fa0	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018fa2	c9 10		cmp #$10			cmp 	#16
.018fa4	b0 0f		bcs $018fb5			bcs 	_UDFail
.018fa6					_UDOkay:
.018fa6	29 0f		and #$0f			and 	#15 						; nibble only
.018fa8	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018fab	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018fae	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.018fb1	d0 cc		bne $018f7f			bne 	_UDConvertLoop
.018fb3	7a		ply				ply
.018fb4	60		rts				rts
.018fb5					_UDFail:
.018fb5	4c 1e 84	jmp $01841e			jmp 	BadParamError
.018fb8					ConvertUpper:
.018fb8	c9 61		cmp #$61			cmp 	#"a"
.018fba	90 07		bcc $018fc3			bcc 	_CUExit
.018fbc	c9 7b		cmp #$7b			cmp 	#"z"+1
.018fbe	b0 03		bcs $018fc3			bcs 	_CUExit
.018fc0	38		sec				sec
.018fc1	e9 20		sbc #$20			sbc 	#32
.018fc3	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018fc4					Unary_Chr:
.018fc4	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX			; numeric parameter
.018fc7	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018fca	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018fcd	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018fd0	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018fd3	d0 0e		bne $018fe3			bne 	_UCChar
.018fd5	a9 01		lda #$01			lda 	#1 							; one character string
.018fd7	20 90 90	jsr $019090			jsr 	AllocateTempString
.018fda	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018fdd	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018fe0	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr
.018fe3					_UCChar:
.018fe3	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018fe6					Unary_Spc:
.018fe6	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; numeric parameter
.018fe9	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018fec	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018fef	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ff2	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ff5	d0 1b		bne $019012			bne 	_USSize
.018ff7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018ffa	c9 fe		cmp #$fe			cmp 	#maxString+1
.018ffc	b0 14		bcs $019012			bcs 	_USSize
.018ffe	48		pha				pha 								; save length
.018fff	1a		inc a				inc 	a 							; allocate one more.
.019000	20 90 90	jsr $019090			jsr 	AllocateTempString
.019003	68		pla				pla 								; get length
.019004	f0 0f		beq $019015			beq 	UnaryReturnTempStr 			; return the current temp string
.019006					_USLoop:
.019006	48		pha				pha
.019007	a9 20		lda #$20			lda 	#" "
.019009	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.01900c	68		pla				pla
.01900d	3a		dec a				dec 	a
.01900e	d0 f6		bne $019006			bne 	_USLoop
.019010	80 03		bra $019015			bra 	UnaryReturnTempStr
.019012					_USSize:
.019012	4c 1e 84	jmp $01841e			jmp 	BadParamError
.019015					UnaryReturnTempStr:
.019015	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019017	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01901a	a5 21		lda $21				lda 	zTempStr+1
.01901c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01901f	a9 02		lda #$02			lda 	#2 							; set type to string
.019021	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019024	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019025					MemRead:
.019025	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.019028	a0 00		ldy #$00			ldy 	#0 							; start from here
.01902a	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01902c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.01902f	c8		iny				iny 								; next to copy
.019030	e8		inx				inx
.019031	cc 8e 04	cpy $048e			cpy 	SignCount 					; do required # of bytes.
.019034	d0 f4		bne $01902a			bne 	_MLoop1
.019036	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019037					CheckNextToken:
.019037	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019039	d0 02		bne $01903d			bne 	CTFail 						; no, then fail
.01903b	c8		iny				iny
.01903c	60		rts				rts
.01903d					CTFail:
.01903d	20 2f 84	jsr $01842f			jsr ERR_Handler
>019040	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019048	74 6f 6b 65 6e 00
.01904e					CheckNextRParen:
.01904e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019050	c9 bc		cmp #$bc			cmp 	#token_rparen
.019052	d0 e9		bne $01903d			bne 	CTFail
.019054	c8		iny				iny
.019055	60		rts				rts
.019056					CheckNextComma:
.019056	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019058	c9 bd		cmp #$bd			cmp 	#token_comma
.01905a	d0 e1		bne $01903d			bne 	CTFail
.01905c	c8		iny				iny
.01905d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01905e					StringConcrete:
.01905e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019061	85 10		sta $10				sta 	zTemp1
.019063	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019066	85 11		sta $11				sta 	zTemp1+1
.019068	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.01906a	18		clc				clc 								; from the string pointer
.01906b	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.01906e	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019070	8d 00 04	sta $0400			sta 	StringPtr
.019073	85 12		sta $12				sta 	zTemp2
.019075	ad 01 04	lda $0401			lda 	StringPtr+1
.019078	e9 00		sbc #$00			sbc 	#0
.01907a	8d 01 04	sta $0401			sta 	StringPtr+1
.01907d	85 13		sta $13				sta 	zTemp2+1
.01907f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019081	1a		inc a				inc 	a
.019082	aa		tax				tax
.019083	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019085	91 12		sta ($12),y			sta 	(zTemp2),y
.019087	c8		iny				iny
.019088	ca		dex				dex
.019089	d0 f8		bne $019083			bne 	_SCCopy
.01908b	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01908d	a6 12		ldx $12				ldx 	zTemp2
.01908f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019090					AllocateTempString:
.019090	48		pha				pha 								; save required count.
.019091	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019093	d0 0b		bne $0190a0			bne 	_ATSInitialised
.019095	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019098	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.01909a	ad 01 04	lda $0401			lda 	StringPtr+1
.01909d	3a		dec a				dec 	a
.01909e	85 21		sta $21				sta 	zTempStr+1
.0190a0					_ATSInitialised:
.0190a0	68		pla				pla 								; get required count back.
.0190a1	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0190a3	1a		inc a				inc 	a
.0190a4	18		clc				clc
.0190a5	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0190a7	85 20		sta $20				sta 	zTempStr
.0190a9	a9 ff		lda #$ff			lda 	#$FF
.0190ab	65 21		adc $21				adc 	zTempStr+1
.0190ad	85 21		sta $21				sta 	zTempStr+1
.0190af	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0190b1	5a		phy				phy
.0190b2	a8		tay				tay
.0190b3	91 20		sta ($20),y			sta 	(zTempStr),y
.0190b5	7a		ply				ply
.0190b6	1a		inc a				inc 	a 							; reset the write index.
.0190b7	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.0190ba	60		rts				rts
.0190bb					WriteTempString:
.0190bb	5a		phy				phy 								; save Y
.0190bc	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.0190bf	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0190c1	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.0190c4	98		tya				tya 								; unchanged Y is now length
.0190c5	a0 00		ldy #$00			ldy 	#0
.0190c7	91 20		sta ($20),y			sta 	(zTempStr),y
.0190c9	7a		ply				ply 								; restore Y and exit
.0190ca	60		rts				rts
.0190cb					CreateTempStringCopy:
.0190cb	da		phx				phx 								; save X
.0190cc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190ce	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0190cf	20 90 90	jsr $019090			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0190d2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190d4	c8		iny				iny
.0190d5	3a		dec a				dec 	a 							; make the actual length in charactes
.0190d6	3a		dec a				dec 	a
.0190d7	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0190d9	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0190db	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0190dd	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0190df	f0 0e		beq $0190ef			beq 	_CTSCExit
.0190e1					_CTSCLoop:
.0190e1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190e3	c8		iny				iny
.0190e4	5a		phy				phy 								; save in Y
.0190e5	e8		inx				inx 								; bump index
.0190e6	da		phx				phx 								; index into Y
.0190e7	7a		ply				ply
.0190e8	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0190ea	7a		ply				ply 								; restore Y
.0190eb	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0190ed	d0 f2		bne $0190e1			bne 	_CTSCLoop
.0190ef					_CTSCExit:
.0190ef	fa		plx				plx 								; restore X
.0190f0	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0190f1					VariableFind:
.0190f1	20 2c 91	jsr $01912c			jsr 	VariableExtract 		; find out all about it ....
.0190f4	20 06 93	jsr $019306			jsr 	VariableLocate 			; does it already exist ?
.0190f7	b0 03		bcs $0190fc			bcs 	_VFExists 				; if so, use that.
.0190f9	20 b8 91	jsr $0191b8			jsr 	VariableCreate 			; otherwise create it.
.0190fc					_VFExists:
.0190fc	60		rts				rts
.0190fd					VariableClear:
.0190fd	48		pha				pha 							; save registers
.0190fe	da		phx				phx
.0190ff	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019101	8a		txa				txa
.019102	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.019105	e8		inx				inx
.019106	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019108	d0 f8		bne $019102			bne 	_VCLoop
.01910a	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.01910c	8d 02 04	sta $0402			sta 	VarMemPtr
.01910f	a9 40		lda #$40			lda 	#VariableMemory >> 8
.019111	8d 03 04	sta $0403			sta 	VarMemPtr+1
.019114	fa		plx				plx 							; restore registers
.019115	68		pla				pla
.019116	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019117					VariableNameError:
.019117	20 2f 84	jsr $01842f			jsr ERR_Handler
>01911a	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019122	61 62 6c 65 20 4e 61 6d 65 00
.01912c					VariableExtract:
.01912c	da		phx				phx 							; save X.
.01912d	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.01912f	8d 85 04	sta $0485			sta 	Var_Type
.019132	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019135	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019137	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019139	f0 dc		beq $019117			beq 	VariableNameError
.01913b	c9 1b		cmp #$1b			cmp 	#26+1
.01913d	b0 d8		bcs $019117			bcs 	VariableNameError
.01913f	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019141					_VECopyBuffer:
.019141	e8		inx				inx
.019142	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019144	f0 d1		beq $019117			beq 	VariableNameError
.019146	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.019149	18		clc				clc  							; update the hash value for it.
.01914a	6d 86 04	adc $0486			adc 	Var_Hash
.01914d	8d 86 04	sta $0486			sta 	Var_Hash
.019150	c8		iny				iny
.019151	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019153	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019155	f0 0e		beq $019165			beq 	_VECopyEnd
.019157	30 0c		bmi $019165			bmi 	_VECopyEnd
.019159	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.01915b	90 e4		bcc $019141			bcc 	_VECopyBuffer
.01915d	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01915f	90 04		bcc $019165			bcc 	_VECopyEnd
.019161	c9 3a		cmp #$3a			cmp 	#"9"+1
.019163	90 dc		bcc $019141			bcc 	_VECopyBuffer
.019165					_VECopyEnd:
.019165	c8		iny				iny
.019166	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.019168	90 04		bcc $01916e			bcc 	_VEDefaultRequired
.01916a	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.01916c	90 0b		bcc $019179			bcc 	_VEHaveType
.01916e					_VEDefaultRequired:
.01916e	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019170	f0 04		beq $019176			beq 	_VESetType 				; default set above.
.019172	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.019175	88		dey				dey
.019176					_VESetType:
.019176	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.019179					_VEHaveType:
.019179	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.01917c	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.01917f	09 80		ora #$80			ora 	#$80
.019181	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.019184	e8		inx				inx 							; offset 3 => length 4.
.019185	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.019188	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.01918b	38		sec				sec
.01918c	e9 b5		sbc #$b5			sbc 	#token_Dollar
.01918e	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.01918f	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019190	0a		asl a				asl 	a
.019191	0a		asl a				asl 	a
.019192	8d 88 04	sta $0488			sta 	Var_HashAddress
.019195	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.019198	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.01919a	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.01919b	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.01919e	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0191a0	8d 88 04	sta $0488			sta 	Var_HashAddress
.0191a3	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0191a5	ad 85 04	lda $0485			lda 	Var_Type
.0191a8	c9 b7		cmp #$b7			cmp 	#token_Hash
.0191aa	f0 07		beq $0191b3			beq 	_VEHaveSize
.0191ac	ca		dex				dex
.0191ad	c9 b9		cmp #$b9			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0191af	f0 02		beq $0191b3			beq 	_VEHaveSize
.0191b1	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0191b3					_VEHaveSize:
.0191b3	8e 89 04	stx $0489			stx 	Var_DataSize
.0191b6	fa		plx				plx
.0191b7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0191b8					VariableCreate:
.0191b8	da		phx				phx
.0191b9	5a		phy				phy
.0191ba	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.0191bd	85 10		sta $10				sta 	zTemp1
.0191bf	ad 03 04	lda $0403			lda 	VarMemPtr+1
.0191c2	85 11		sta $11				sta 	zTemp1+1
.0191c4	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.0191c7	18		clc				clc
.0191c8	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.0191cb	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.0191cd	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.0191d0	8d 02 04	sta $0402			sta 	VarMemPtr
.0191d3	90 03		bcc $0191d8			bcc 	_VCNoCarry
.0191d5	ee 03 04	inc $0403			inc 	VarMemPtr+1
.0191d8					_VCNoCarry:
.0191d8	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.0191db	85 12		sta $12				sta 	zTemp2
.0191dd	a9 04		lda #$04			lda 	#HashTableBase >> 8
.0191df	85 13		sta $13				sta 	zTemp2+1
.0191e1	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.0191e3	b1 12		lda ($12),y			lda 	(zTemp2),y
.0191e5	91 10		sta ($10),y			sta 	(zTemp1),y
.0191e7	c8		iny				iny
.0191e8	b1 12		lda ($12),y			lda 	(zTemp2),y
.0191ea	91 10		sta ($10),y			sta 	(zTemp1),y
.0191ec	c8		iny				iny
.0191ed	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.0191f0	91 10		sta ($10),y			sta 	(zTemp1),y
.0191f2	c8		iny				iny
.0191f3	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.0191f5					_VCCopyName:
.0191f5	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.0191f8	91 10		sta ($10),y			sta 	(zTemp1),y
.0191fa	e8		inx				inx
.0191fb	c8		iny				iny
.0191fc	ec 87 04	cpx $0487			cpx 	Var_Length
.0191ff	d0 f4		bne $0191f5			bne 	_VCCopyName
.019201	5a		phy				phy 								; save the data offset.
.019202	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.019205	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019207					_VCClearData:
.019207	91 10		sta ($10),y			sta 	(zTemp1),y
.019209	c8		iny				iny
.01920a	ca		dex				dex
.01920b	d0 fa		bne $019207			bne 	_VCClearData
.01920d	68		pla				pla 								; offset to the data
.01920e	18		clc				clc
.01920f	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019211	85 22		sta $22				sta 	zVarDataPtr
.019213	a5 11		lda $11				lda 	zTemp1+1
.019215	69 00		adc #$00			adc 	#0
.019217	85 23		sta $23				sta 	zVarDataPtr+1
.019219	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.01921c	85 24		sta $24				sta 	zVarType
.01921e	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019220	a0 00		ldy #$00			ldy 	#0
.019222	91 12		sta ($12),y			sta 	(zTemp2),y
.019224	c8		iny				iny
.019225	a5 11		lda $11				lda 	zTemp1+1
.019227	91 12		sta ($12),y			sta 	(zTemp2),y
.019229	ad 85 04	lda $0485			lda 	Var_Type 					; array ? if so create the empty one.
.01922c	29 01		and #$01			and 	#1
.01922e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019230	d0 0e		bne $019240			bne 	_VCNotArray
.019232	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019234	20 56 92	jsr $019256			jsr 	ArrayCreate
.019237	5a		phy				phy 								; save YA at zVarDataPtr
.019238	a0 00		ldy #$00			ldy 	#0
.01923a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01923c	c8		iny				iny
.01923d	68		pla				pla
.01923e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019240					_VCNotArray:
.019240	7a		ply				ply
.019241	fa		plx				plx
.019242	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019243					ArrayResetDefault:
.019243	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019245	8d 97 04	sta $0497			sta 	ArrayDef+0
.019248	a9 00		lda #$00			lda 	#0
.01924a	8d 98 04	sta $0498			sta 	ArrayDef+1
.01924d	a9 ff		lda #$ff			lda 	#$FF
.01924f	8d 99 04	sta $0499			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019252	8d 9a 04	sta $049a			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019255	60		rts				rts
.019256					ArrayCreate:
.019256	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019259	0a		asl a				asl 	a
.01925a	85 10		sta $10				sta 	zTemp1
.01925c	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.01925f	2a		rol a				rol 	a
.019260	85 11		sta $11				sta 	zTemp1+1
.019262	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019265	10 22		bpl $019289			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019267	ad 85 04	lda $0485			lda 	Var_Type 					; check the type
.01926a	c9 b6		cmp #$b6			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.01926c	f0 1b		beq $019289			beq 	_ACSized
.01926e	06 10		asl $10				asl 	zTemp1 						; double again
.019270	26 11		rol $11				rol 	zTemp1+1
.019272	b0 6f		bcs $0192e3			bcs 	ArrayIndexError 			; too large.
.019274	c9 ba		cmp #$ba			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019276	f0 11		beq $019289			beq 	_ACSized
.019278	18		clc				clc 								; add original value x 5 for reals.
.019279	a5 10		lda $10				lda 	zTemp1
.01927b	7d 97 04	adc $0497,x			adc 	ArrayDef+0,x
.01927e	85 10		sta $10				sta 	zTemp1
.019280	a5 11		lda $11				lda 	zTemp1+1
.019282	7d 98 04	adc $0498,x			adc 	ArrayDef+1,x
.019285	85 11		sta $11				sta 	zTemp1+1
.019287	b0 5a		bcs $0192e3			bcs 	ArrayIndexError
.019289					_ACSized:
.019289	18		clc				clc
.01928a	a5 10		lda $10				lda 	zTemp1
.01928c	69 02		adc #$02			adc 	#2
.01928e	85 10		sta $10				sta 	zTemp1
.019290	90 04		bcc $019296			bcc 	_ACNoBump
.019292	e6 10		inc $10				inc 	zTemp1
.019294	f0 4d		beq $0192e3			beq 	ArrayIndexError
.019296					_ACNoBump:
.019296	18		clc				clc
.019297	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.01929a	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.01929c	85 14		sta $14				sta 	zTemp3
.01929e	65 10		adc $10				adc 	zTemp1
.0192a0	8d 02 04	sta $0402			sta 	VarMemPtr
.0192a3	ad 03 04	lda $0403			lda 	VarMemPtr+1
.0192a6	85 13		sta $13				sta 	zTemp2+1
.0192a8	85 15		sta $15				sta 	zTemp3+1
.0192aa	65 11		adc $11				adc 	zTemp1+1
.0192ac	8d 03 04	sta $0403			sta 	VarMemPtr+1
.0192af	85 11		sta $11				sta 	zTemp1+1
.0192b1	b0 30		bcs $0192e3			bcs 	ArrayIndexError
.0192b3	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.0192b5					_ACClear:
.0192b5	98		tya				tya
.0192b6	91 12		sta ($12),y			sta 	(zTemp2),y
.0192b8	e6 12		inc $12				inc 	zTemp2
.0192ba	d0 02		bne $0192be			bne 	_ACCBump
.0192bc	e6 13		inc $13				inc 	zTemp2+1
.0192be					_ACCBump:
.0192be	a5 12		lda $12				lda 	zTemp2
.0192c0	cd 02 04	cmp $0402			cmp 	VarMemPtr
.0192c3	d0 f0		bne $0192b5			bne 	_ACClear
.0192c5	a5 13		lda $13				lda 	zTemp2+1
.0192c7	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.0192ca	d0 e9		bne $0192b5			bne 	_ACClear
.0192cc	a0 00		ldy #$00			ldy 	#0
.0192ce	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; copy the size into the start
.0192d1	91 14		sta ($14),y			sta 	(zTemp3),y
.0192d3	c8		iny				iny
.0192d4	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.0192d7	91 14		sta ($14),y			sta 	(zTemp3),y
.0192d9	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; have we reached the end
.0192dc	10 18		bpl $0192f6			bpl 	ACCFillRecursive
.0192de	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.0192e0	a5 14		lda $14				lda 	zTemp3
.0192e2	60		rts				rts
.0192e3					ArrayIndexError:
.0192e3	20 2f 84	jsr $01842f			jsr ERR_Handler
>0192e6	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0192ee	79 20 69 6e 64 65 78 00
.0192f6					ACCFillRecursive:
.0192f6	20 2f 84	jsr $01842f			jsr ERR_Handler
>0192f9	31 20 69 6e 64 65 78 20			.text "1 index only",0
>019301	6f 6e 6c 79 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019306					VariableLocate:
.019306	da		phx				phx
.019307	5a		phy				phy
.019308	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01930b	85 12		sta $12				sta 	zTemp2 						; points to first address.
.01930d	a9 04		lda #$04			lda 	#HashTableBase >> 8
.01930f	85 13		sta $13				sta 	zTemp2+1
.019311	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019313	b1 12		lda ($12),y			lda 	(zTemp2),y
.019315	aa		tax				tax
.019316	c8		iny				iny
.019317	b1 12		lda ($12),y			lda 	(zTemp2),y
.019319	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01931b	86 12		stx $12				stx 	zTemp2
.01931d	05 12		ora $12				ora 	zTemp2 						; got zero
.01931f	18		clc				clc
.019320	f0 25		beq $019347			beq 	_VLExit 					; if so, then fail as end of chain.
.019322	c8		iny				iny 								; point to hash (offset + 2)
.019323	b1 12		lda ($12),y			lda 	(zTemp2),y
.019325	cd 86 04	cmp $0486			cmp 	Var_Hash
.019328	d0 e7		bne $019311			bne 	_VLNext 					; try next if different.
.01932a					_VLCompare:
.01932a	c8		iny				iny 								; next character
.01932b	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.01932d	d9 02 04	cmp $0402,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019330	d0 df		bne $019311			bne 	_VLNext 					; fail if different, try next.
.019332	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019333	90 f5		bcc $01932a			bcc 	_VLCompare
.019335	98		tya				tya
.019336	38		sec				sec 								; add 1 as Y points to last character
.019337	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019339	85 22		sta $22				sta 	zVarDataPtr
.01933b	a5 13		lda $13				lda 	zTemp2+1
.01933d	69 00		adc #$00			adc 	#0
.01933f	85 23		sta $23				sta 	zVarDataPtr+1
.019341	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.019344	85 24		sta $24				sta 	zVarType
.019346	38		sec				sec 								; return CS
.019347	7a		ply		_VLExit:ply
.019348	fa		plx				plx
.019349	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01934a					VariableGet:
.01934a	5a		phy				phy
.01934b	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01934d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01934f	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019352	c8		iny				iny
.019353	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019355	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019358	c8		iny				iny
.019359	ad 85 04	lda $0485			lda 	Var_Type 					; if it is a string, set up for that.
.01935c	c9 b5		cmp #$b5			cmp 	#token_Dollar
.01935e	f0 35		beq $019395			beq 	_VGString
.019360	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019362	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019365	c8		iny				iny
.019366	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019368	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01936b	c8		iny				iny
.01936c	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01936e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019371	ad 85 04	lda $0485			lda 	Var_Type
.019374	c9 b9		cmp #$b9			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019376	f0 31		beq $0193a9			beq 	_VGExit
.019378	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01937a	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01937d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01937f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019382	f0 25		beq $0193a9			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019384	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019387	48		pha				pha
.019388	29 80		and #$80			and 	#$80
.01938a	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.01938d	68		pla				pla
.01938e	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019390	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019393	80 14		bra $0193a9			bra 	_VGExit
.019395					_VGString:
.019395	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019397	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01939a	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.01939d	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0193a0	d0 07		bne $0193a9			bne 	_VGExit 					; if not, exit.
.0193a2	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.0193a4	a9 25		lda #$25			lda 	#zNullString
.0193a6	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.0193a9					_VGExit:
.0193a9	7a		ply				ply
.0193aa	60		rts				rts
.0193ab					VariableSet:
.0193ab	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.0193ae	29 02		and #$02			and 	#2 							; if so, it has to be
.0193b0	d0 53		bne $019405			bne 	_VSString
.0193b2	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.0193b4	c9 b5		cmp #$b5			cmp 	#token_Dollar
.0193b6	f0 4a		beq $019402			beq 	_VSBadType
.0193b8	c9 b9		cmp #$b9			cmp 	#token_Percent 				; type convert to float/int
.0193ba	f0 05		beq $0193c1			beq 	_VSMakeInt
.0193bc	20 b7 99	jsr $0199b7			jsr 	FPUToFloat
.0193bf	80 03		bra $0193c4			bra 	_VSCopy
.0193c1					_VSMakeInt:
.0193c1	20 16 9a	jsr $019a16			jsr 	FPUToInteger
.0193c4					_VSCopy:
.0193c4	5a		phy				phy
.0193c5	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.0193c7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0193ca	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193cc	c8		iny				iny
.0193cd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0193d0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193d2	c8		iny				iny
.0193d3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0193d6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193d8	c8		iny				iny
.0193d9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0193dc	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193de	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.0193e0	c9 b9		cmp #$b9			cmp 	#token_Percent
.0193e2	f0 1c		beq $019400			beq 	_VSExit
.0193e4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.0193e7	0a		asl a				asl 	a
.0193e8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.0193eb	08		php				php
.0193ec	0a		asl a				asl 	a
.0193ed	28		plp				plp
.0193ee	6a		ror a				ror 	a
.0193ef	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193f1	c8		iny				iny
.0193f2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.0193f5	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0193f7	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.0193fa	50 04		bvc $019400			bvc 	_VSExit
.0193fc	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.0193fe	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019400					_VSExit:
.019400	7a		ply				ply
.019401	60		rts				rts
.019402					_VSBadType:
.019402	4c 10 84	jmp $018410			jmp 	TypeError
.019405					_VSString:
.019405	a5 24		lda $24				lda 	zVarType 					; type must be $
.019407	c9 b5		cmp #$b5			cmp 	#token_Dollar
.019409	d0 f7		bne $019402			bne 	_VSBadType
.01940b	da		phx				phx
.01940c	5a		phy				phy
.01940d	20 5e 90	jsr $01905e			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019410	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019412	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019414	88		dey				dey 								; save low byte
.019415	8a		txa				txa
.019416	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019418	7a		ply				ply 								; and exit.
.019419	fa		plx				plx
.01941a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01941b					MulInteger32:
.01941b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01941e	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.019421	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019424	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.019427	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01942a	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.01942d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019430	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.019433	a9 00		lda #$00			lda 	#0
.019435	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.019438	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01943b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01943e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019441					_BFMMultiply:
.019441	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019444	29 01		and #$01			and 	#1
.019446	f0 03		beq $01944b			beq 	_BFMNoAdd
.019448	20 b3 8b	jsr $018bb3			jsr 	AddInteger32
.01944b					_BFMNoAdd:
.01944b	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01944e	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.019451	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.019454	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.019457	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01945a	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.01945d	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.019460	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.019463	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019466	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.019469	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.01946c	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.01946f	d0 d0		bne $019441			bne 	_BFMMultiply
.019471	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019472					DivInteger32:
.019472	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019475	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.019478	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.01947b	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.01947e	d0 14		bne $019494			bne 	_BFDOkay
.019480	20 2f 84	jsr $01842f			jsr ERR_Handler
>019483	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01948b	20 62 79 20 5a 65 72 6f 00
.019494					_BFDOkay:
.019494	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019496	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019498	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01949a	85 1c		sta $1c				sta 	zLTemp1+2
.01949c	85 1d		sta $1d				sta 	zLTemp1+3
.01949e	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.0194a1	20 02 95	jsr $019502			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.0194a4	da		phx				phx
.0194a5	e8		inx				inx
.0194a6	e8		inx				inx
.0194a7	e8		inx				inx
.0194a8	e8		inx				inx
.0194a9	e8		inx				inx
.0194aa	e8		inx				inx
.0194ab	20 02 95	jsr $019502			jsr 	CheckIntegerNegate
.0194ae	fa		plx				plx
.0194af	5a		phy				phy 								; Y is the counter
.0194b0	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.0194b2					_BFDLoop:
.0194b2	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.0194b5	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.0194b8	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.0194bb	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0194be	26 1a		rol $1a				rol 	zLTemp1
.0194c0	26 1b		rol $1b				rol 	zLTemp1+1
.0194c2	26 1c		rol $1c				rol 	zLTemp1+2
.0194c4	26 1d		rol $1d				rol 	zLTemp1+3
.0194c6	38		sec				sec
.0194c7	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.0194c9	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0194cc	48		pha				pha
.0194cd	a5 1b		lda $1b				lda 	zLTemp1+1
.0194cf	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0194d2	48		pha				pha
.0194d3	a5 1c		lda $1c				lda 	zLTemp1+2
.0194d5	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0194d8	48		pha				pha
.0194d9	a5 1d		lda $1d				lda 	zLTemp1+3
.0194db	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0194de	90 15		bcc $0194f5			bcc 	_BFDNoAdd
.0194e0	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.0194e2	68		pla				pla
.0194e3	85 1c		sta $1c				sta 	zLTemp1+2
.0194e5	68		pla				pla
.0194e6	85 1b		sta $1b				sta 	zLTemp1+1
.0194e8	68		pla				pla
.0194e9	85 1a		sta $1a				sta 	zLTemp1+0
.0194eb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.0194ee	09 01		ora #$01			ora 	#1
.0194f0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0194f3	80 03		bra $0194f8			bra 	_BFDNext
.0194f5					_BFDNoAdd:
.0194f5	68		pla				pla 								; Throw away the intermediate calculations
.0194f6	68		pla				pla
.0194f7	68		pla				pla
.0194f8					_BFDNext:
.0194f8	88		dey				dey
.0194f9	d0 b7		bne $0194b2			bne 	_BFDLoop
.0194fb	7a		ply				ply 								; restore Y and exit
.0194fc	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.0194ff	b0 07		bcs $019508			bcs		IntegerNegateAlways 			; negate the result
.019501	60		rts				rts
.019502					CheckIntegerNegate:
.019502	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019505	30 01		bmi $019508			bmi 	IntegerNegateAlways
.019507	60		rts				rts
.019508					IntegerNegateAlways:
.019508	ee 8e 04	inc $048e			inc 	SignCount
.01950b	38		sec				sec
.01950c	a9 00		lda #$00			lda 	#0
.01950e	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019511	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019514	a9 00		lda #$00			lda 	#0
.019516	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019519	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01951c	a9 00		lda #$00			lda 	#0
.01951e	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019521	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019524	a9 00		lda #$00			lda 	#0
.019526	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019529	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01952c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01952d					INTToString:
.01952d	48		pha				pha
.01952e	5a		phy				phy
.01952f	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.019532	10 08		bpl $01953c			bpl 		_ITSNotMinus
.019534	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019536	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter
.019539	20 08 95	jsr $019508			jsr 		IntegerNegateAlways 	; negate the number.
.01953c					_ITSNotMinus:
.01953c	a9 00		lda #$00			lda 		#0
.01953e	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.019541	8a		txa				txa 								; use Y for the mantissa index.
.019542	a8		tay				tay
.019543	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019545					_ITSNextSubtractor:
.019545	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019547	8d 8b 04	sta $048b			sta 		NumConvCount
.01954a					_ITSSubtract:
.01954a	38		sec				sec
.01954b	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01954e	ff ad 95 01	sbc $0195ad,x			sbc 		_ITSSubtractors+0,x
.019552	48		pha				pha
.019553	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.019556	ff ae 95 01	sbc $0195ae,x			sbc 		_ITSSubtractors+1,x
.01955a	48		pha				pha
.01955b	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.01955e	ff af 95 01	sbc $0195af,x			sbc 		_ITSSubtractors+2,x
.019562	48		pha				pha
.019563	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.019566	ff b0 95 01	sbc $0195b0,x			sbc 		_ITSSubtractors+3,x
.01956a	90 14		bcc $019580			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01956c	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01956f	68		pla				pla
.019570	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.019573	68		pla				pla
.019574	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.019577	68		pla				pla
.019578	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.01957b	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.01957e	80 ca		bra $01954a			bra 		_ITSSubtract 			; go round again.
.019580					_ITSCantSubtract:
.019580	68		pla				pla 								; throw away interim answers
.019581	68		pla				pla
.019582	68		pla				pla
.019583	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.019586	c9 30		cmp #$30			cmp 		#"0"
.019588	d0 05		bne $01958f			bne 		_ITSOutputDigit
.01958a	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01958d	10 09		bpl $019598			bpl	 		_ITSGoNextSubtractor
.01958f					_ITSOutputDigit:
.01958f	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.019592	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.019595	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter 		; output it.
.019598					_ITSGoNextSubtractor:
.019598	e8		inx				inx 								; next dword
.019599	e8		inx				inx
.01959a	e8		inx				inx
.01959b	e8		inx				inx
.01959c	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01959e	d0 a5		bne $019545			bne 		_ITSNextSubtractor 		; do all the subtractors.
.0195a0	98		tya				tya 								; X is back as the mantissa index
.0195a1	aa		tax				tax
.0195a2	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.0195a5	09 30		ora #$30			ora 		#"0"
.0195a7	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter
.0195aa	7a		ply				ply 								; and exit
.0195ab	68		pla				pla
.0195ac	60		rts				rts
.0195ad					_ITSSubtractors:
>0195ad	00 ca 9a 3b					.dword 		1000000000
>0195b1	00 e1 f5 05					.dword 		100000000
>0195b5	80 96 98 00					.dword 		10000000
>0195b9	40 42 0f 00					.dword 		1000000
>0195bd	a0 86 01 00					.dword 		100000
>0195c1	10 27 00 00					.dword 		10000
>0195c5	e8 03 00 00					.dword 		1000
>0195c9	64 00 00 00					.dword 		100
>0195cd	0a 00 00 00					.dword 		10
.0195d1					_ITSSubtractorsEnd:
.0195d1					ITSOutputCharacter:
.0195d1	48		pha				pha
.0195d2	da		phx				phx
.0195d3	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.0195d6	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.0195d9	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0195db	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.0195de	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.0195e1	fa		plx				plx
.0195e2	68		pla				pla
.0195e3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0195e4					IntFromString:
.0195e4	a0 00		ldy #$00			ldy 	#0
.0195e6	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.0195e9					IntFromStringY:
.0195e9	48		pha				pha
.0195ea	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0195ec	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0195ef	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0195f2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0195f5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0195f8	a9 01		lda #$01			lda 	#1
.0195fa	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0195fd					_IFSLoop:
.0195fd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.0195ff	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019601	90 60		bcc $019663			bcc 	_IFSExit
.019603	c9 3a		cmp #$3a			cmp 	#"9"+1
.019605	b0 5c		bcs $019663			bcs 	_IFSExit
.019607	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01960a	c9 0c		cmp #$0c			cmp 	#12
.01960c	b0 5f		bcs $01966d			bcs 	_IFSOverflow
.01960e	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019611	48		pha				pha
.019612	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019615	48		pha				pha
.019616	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019619	48		pha				pha
.01961a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01961d	48		pha				pha
.01961e	20 82 96	jsr $019682			jsr 	IFSX1ShiftLeft 				; double
.019621	20 82 96	jsr $019682			jsr 	IFSX1ShiftLeft 				; x 4
.019624	18		clc				clc 								; add saved value x 5
.019625	68		pla				pla
.019626	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019629	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01962c	68		pla				pla
.01962d	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019630	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019633	68		pla				pla
.019634	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.019637	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01963a	68		pla				pla
.01963b	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.01963e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019641	20 82 96	jsr $019682			jsr 	IFSX1ShiftLeft 				; x 10
.019644	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.019647	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019649	29 0f		and #$0f			and 	#15
.01964b	c8		iny				iny
.01964c	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.01964f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019652	90 a9		bcc $0195fd			bcc 	_IFSLoop
.019654	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019657	d0 a4		bne $0195fd			bne 	_IFSLoop
.019659	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.01965c	d0 9f		bne $0195fd			bne 	_IFSLoop
.01965e	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.019661	80 9a		bra $0195fd			bra 	_IFSLoop
.019663					_IFSExit:
.019663	98		tya				tya 								; get offset
.019664					_IFSOkay:
.019664	38		sec				sec
.019665	ad 8c 04	lda $048c			lda 	ExpTemp
.019668	f0 01		beq $01966b			beq 	_IFSSkipFail
.01966a	18		clc				clc
.01966b					_IFSSkipFail:
.01966b	68		pla				pla 								; and exit.
.01966c	60		rts				rts
.01966d					_IFSOverflow:
.01966d	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019670	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019678	20 6f 76 65 72 66 6c 6f 77 00
.019682					IFSX1ShiftLeft:
.019682	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.019685	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019688	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.01968b	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.01968e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01968f					FPSubtract:
.01968f	48		pha				pha
.019690	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019693	49 80		eor #$80			eor 	#$80
.019695	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019698	68		pla				pla 								; --- and fall through ---
.019699					FPAdd:
.019699	48		pha				pha
.01969a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01969d	d0 05		bne $0196a4			bne 	_FPA_NegativeLHS
.01969f	20 c1 96	jsr $0196c1			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.0196a2	68		pla				pla
.0196a3	60		rts				rts
.0196a4					_FPA_NegativeLHS:
.0196a4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.0196a7	49 80		eor #$80			eor 	#$80
.0196a9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0196ac	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.0196af	49 80		eor #$80			eor 	#$80
.0196b1	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0196b4	20 c1 96	jsr $0196c1			jsr 	FPAdd_Worker 				; do the add calculation.
.0196b7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.0196ba	49 80		eor #$80			eor 	#$80
.0196bc	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0196bf	68		pla				pla
.0196c0	60		rts				rts
.0196c1					FPAdd_Worker:
.0196c1	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.0196c4	70 08		bvs $0196ce			bvs 	_FPAWExit 					; no change.
.0196c6	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.0196c9	50 07		bvc $0196d2			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0196cb	20 66 99	jsr $019966			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0196ce					_FPAWExit:
.0196ce	20 ee 99	jsr $0199ee			jsr 	FPUNormalise 				; normalise the result.
.0196d1	60		rts				rts
.0196d2					_FPAWMakeSame:
.0196d2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0196d5	38		sec				sec
.0196d6	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0196d9	f0 1b		beq $0196f6			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0196db	da		phx				phx 								; save X
.0196dc	90 06		bcc $0196e4			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.0196de	e8		inx				inx
.0196df	e8		inx				inx
.0196e0	e8		inx				inx
.0196e1	e8		inx				inx
.0196e2	e8		inx				inx
.0196e3	e8		inx				inx
.0196e4					_FPAWShiftA:
.0196e4	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0196e7	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0196ea	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0196ed	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0196f0	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0196f3	fa		plx				plx 								; restore original X
.0196f4	80 dc		bra $0196d2			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.0196f6					_FPAW_DoArithmetic:
.0196f6	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.0196f9	30 39		bmi $019734			bmi 	_FPAW_BNegative
.0196fb	18		clc				clc
.0196fc	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0196ff	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019702	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019705	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019708	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.01970b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01970e	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019711	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019714	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019717	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01971a	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.01971d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019720	90 ac		bcc $0196ce			bcc 	_FPAWExit 					; no carry.
.019722	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019725	38		sec				sec
.019726	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019729	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01972c	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.01972f	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019732	80 9a		bra $0196ce			bra 	_FPAWExit
.019734					_FPAW_BNegative:
.019734	38		sec				sec
.019735	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019738	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.01973b	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01973e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019741	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.019744	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019747	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01974a	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.01974d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019750	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019753	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.019756	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019759	b0 0b		bcs $019766			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01975b	20 93 99	jsr $019993			jsr 	FPUNegateInteger			; negate the mantissa
.01975e	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.019761	49 80		eor #$80			eor 	#$80
.019763	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019766					_FPAWGoExit:
.019766	4c ce 96	jmp $0196ce			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019769					FPD_IsDivZero:
.019769	20 2f 84	jsr $01842f			jsr ERR_Handler
>01976c	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019774	20 62 79 20 7a 65 72 6f 00
.01977d					FPDivide:
.01977d	48		pha				pha
.01977e	5a		phy				phy
.01977f	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.019782	70 e5		bvs $019769			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019784	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019787	f0 03		beq $01978c			beq 	_FPDCalculateExp
.019789					_FPD_Exit:
.019789	7a		ply				ply
.01978a	68		pla				pla
.01978b	60		rts				rts
.01978c					_FPDCalculateExp:
.01978c	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01978f	49 ff		eor #$ff			eor 	#$FF
.019791	1a		inc a				inc 	a
.019792	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.019795	20 89 98	jsr $019889			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019798	18		clc				clc 	 							; add 1 to the resulting exponent
.019799	69 01		adc #$01			adc 	#1
.01979b	b0 65		bcs $019802			bcs 	_FPD_Overflow 				; which can overflow.
.01979d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.0197a0	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.0197a2	85 1a		sta $1a				sta 	zLTemp1+0
.0197a4	85 1b		sta $1b				sta 	zLTemp1+1
.0197a6	85 1c		sta $1c				sta 	zLTemp1+2
.0197a8	85 1d		sta $1d				sta 	zLTemp1+3
.0197aa	a0 20		ldy #$20			ldy 	#32 						; times round.
.0197ac					_FPD_Loop:
.0197ac	38		sec				sec 								; calculate X1-X2 stacking result because we might
.0197ad	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.0197b0	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.0197b3	48		pha				pha
.0197b4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0197b7	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0197ba	48		pha				pha
.0197bb	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0197be	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0197c1	48		pha				pha
.0197c2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0197c5	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0197c8	90 17		bcc $0197e1			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.0197ca	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.0197cd	68		pla				pla
.0197ce	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0197d1	68		pla				pla
.0197d2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0197d5	68		pla				pla
.0197d6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197d9	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.0197db	09 80		ora #$80			ora 	#$80
.0197dd	85 1d		sta $1d				sta 	zLTemp1+3
.0197df	80 03		bra $0197e4			bra 	_FPD_Rotates
.0197e1					_FPD_NoSubtract:
.0197e1	68		pla				pla 								; throw away unwanted results
.0197e2	68		pla				pla
.0197e3	68		pla				pla
.0197e4					_FPD_Rotates:
.0197e4	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.0197e7	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.0197ea	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.0197ed	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.0197f0	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.0197f2	26 1b		rol $1b				rol 	zLTemp1+1
.0197f4	26 1c		rol $1c				rol 	zLTemp1+2
.0197f6	26 1d		rol $1d				rol 	zLTemp1+3
.0197f8	90 02		bcc $0197fc			bcc 	_FPD_NoCarry
.0197fa	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.0197fc					_FPD_NoCarry:
.0197fc	88		dey				dey 								; do 32 times
.0197fd	d0 ad		bne $0197ac			bne 	_FPD_Loop
.0197ff	4c 66 98	jmp $019866			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019802					_FPD_Overflow:
.019802	4c 63 9a	jmp $019a63			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019805					FPMultiply:
.019805	48		pha				pha
.019806	5a		phy				phy
.019807	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01980a	70 08		bvs $019814			bvs 	_FPM_Exit
.01980c	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01980f	50 06		bvc $019817			bvc 	_FPM_CalcExponent
.019811	20 66 99	jsr $019966			jsr 	FPUCopyX2ToX1
.019814					_FPM_Exit:
.019814	7a		ply				ply
.019815	68		pla				pla
.019816	60		rts				rts
.019817					_FPM_CalcExponent:
.019817	18		clc				clc
.019818	20 89 98	jsr $019889			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01981b	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.01981e	a9 00		lda #$00			lda 	#0
.019820	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019822	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019824	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019826	85 1d		sta $1d				sta 	zLTemp1+3
.019828	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01982a					_FPM_Loop:
.01982a	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.01982d	29 01		and #$01			and 	#1
.01982f	18		clc				clc 								; clear carry for the long rotate.
.019830	f0 1d		beq $01984f			beq 	_FPM_NoAddition
.019832	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019833	a5 1a		lda $1a				lda 	zLTemp1+0
.019835	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019838	85 1a		sta $1a				sta 	zLTemp1+0
.01983a	a5 1b		lda $1b				lda 	zLTemp1+1
.01983c	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.01983f	85 1b		sta $1b				sta 	zLTemp1+1
.019841	a5 1c		lda $1c				lda 	zLTemp1+2
.019843	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.019846	85 1c		sta $1c				sta 	zLTemp1+2
.019848	a5 1d		lda $1d				lda 	zLTemp1+3
.01984a	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.01984d	85 1d		sta $1d				sta 	zLTemp1+3
.01984f					_FPM_NoAddition:
.01984f	66 1d		ror $1d				ror 	3+zLTemp1
.019851	66 1c		ror $1c				ror 	2+zLTemp1
.019853	66 1b		ror $1b				ror 	1+zLTemp1
.019855	66 1a		ror $1a				ror 	0+zLTemp1
.019857	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.01985a	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.01985d	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019860	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019863	88		dey				dey
.019864	d0 c4		bne $01982a			bne 	_FPM_Loop 					; do this 32 times.
.019866					FPM_CopySignNormalize:
.019866	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019868	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01986b	a5 1b		lda $1b				lda 	zLTemp1+1
.01986d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019870	a5 1c		lda $1c				lda 	zLTemp1+2
.019872	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019875	a5 1d		lda $1d				lda 	zLTemp1+3
.019877	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01987a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.01987d	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019880	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019883	20 ee 99	jsr $0199ee			jsr 	FPUNormalise 				; normalise and exit.
.019886	7a		ply				ply
.019887	68		pla				pla
.019888	60		rts				rts
.019889					FPCalculateExponent:
.019889	18		clc				clc
.01988a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01988d	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019890	b0 08		bcs $01989a			bcs 	_FPCECarry 					; carry out ?
.019892	10 03		bpl $019897			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019894	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019896	60		rts				rts
.019897					_FPCEExpZero:
.019897	a9 00		lda #$00			lda 	#0
.019899	60		rts				rts
.01989a					_FPCECarry:
.01989a	30 03		bmi $01989f			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01989c	09 80		ora #$80			ora 	#$80 						; put in right range
.01989e	60		rts				rts
.01989f					_FPCEOverflow:
.01989f	4c 63 9a	jmp $019a63			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.0198a2					FPFractionalPart:
.0198a2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.0198a5	38		sec				sec 								; this flag tells us to keep the fractional part
.0198a6	30 0f		bmi $0198b7			bmi 	FPGetPart
.0198a8	60		rts				rts
.0198a9					FPIntegerPart:
.0198a9	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.0198ac	18		clc				clc 								; this flag says keep the integer part.
.0198ad	30 08		bmi $0198b7			bmi 	FPGetPart 					; -ve exponents are 0..127
.0198af	48		pha				pha
.0198b0	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.0198b2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0198b5	68		pla				pla
.0198b6	60		rts				rts
.0198b7					FPGetPart:
.0198b7	48		pha				pha
.0198b8	5a		phy				phy 								; save Y
.0198b9	08		php				php 								; save action
.0198ba	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.0198bd	70 62		bvs $019921			bvs 	_FPGP_Exit 					; then do nothing.
.0198bf	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.0198c1	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.0198c3	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.0198c5	85 1c		sta $1c				sta 	zLTemp1+2
.0198c7	85 1d		sta $1d				sta 	zLTemp1+3
.0198c9	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.0198cc	38		sec				sec
.0198cd	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.0198cf	f0 12		beq $0198e3			beq 	_FPGP_NoShift 				; ... if any
.0198d1	c9 20		cmp #$20			cmp 	#32
.0198d3	90 02		bcc $0198d7			bcc 	_FPGP_NotMax
.0198d5	a9 20		lda #$20			lda 	#32 						; max of 32.
.0198d7					_FPGP_NotMax:
.0198d7	a8		tay				tay 								; Y is the mask shift count.
.0198d8					_FPGP_ShiftMask:
.0198d8	46 1d		lsr $1d				lsr 	3+zLTemp1
.0198da	66 1c		ror $1c				ror 	2+zLTemp1
.0198dc	66 1b		ror $1b				ror 	1+zLTemp1
.0198de	66 1a		ror $1a				ror 	0+zLTemp1
.0198e0	88		dey				dey
.0198e1	d0 f5		bne $0198d8			bne 	_FPGP_ShiftMask
.0198e3					_FPGP_NoShift:
.0198e3	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.0198e5	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.0198e8					_FPGP_MaskLoop:
.0198e8	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.0198eb	28		plp				plp 								; if CC we keep the top part, so we
.0198ec	08		php				php		 							; flip the mask.
.0198ed	b0 02		bcs $0198f1			bcs		_FPGP_NoFlip
.0198ef	49 ff		eor #$ff			eor 	#$FF
.0198f1					_FPGP_NoFlip:
.0198f1	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.0198f4	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0198f7	e8		inx				inx
.0198f8	c8		iny				iny
.0198f9	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.0198fb	d0 eb		bne $0198e8			bne 	_FPGP_MaskLoop
.0198fd	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.019900	28		plp				plp
.019901	08		php				php 								; get action flag on the stack
.019902	90 05		bcc $019909			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019904	a9 00		lda #$00			lda 	#0
.019906	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019909					_FPGP_NotFractional:
.019909	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01990c	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.01990f	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019912	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019915	f0 05		beq $01991c			beq 	_FPGP_Zero 					; if zero, return zero
.019917	20 ee 99	jsr $0199ee			jsr 	FPUNormalise
.01991a	80 05		bra $019921			bra 	_FPGP_Exit 					; and exit
.01991c					_FPGP_Zero:
.01991c	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01991e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019921					_FPGP_Exit:
.019921	68		pla				pla 								; throw saved action flag.
.019922	7a		ply				ply
.019923	68		pla				pla
.019924	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019925					FPCompare:
.019925	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019928	48		pha				pha
.019929	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.01992c	48		pha				pha
.01992d	20 8f 96	jsr $01968f			jsr 	FPSubtract 					; calculate X1-X2
.019930	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019933	70 2c		bvs $019961			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019935	68		pla				pla
.019936	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.019939	68		pla				pla
.01993a	38		sec				sec
.01993b	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.01993e	70 15		bvs $019955			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019940	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019941	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019943	b0 10		bcs $019955			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019945	38		sec				sec
.019946	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.019949	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01994b	b0 02		bcs $01994f			bcs 	_FPCNotRange 				; keep in range.
.01994d	a9 01		lda #$01			lda 	#1
.01994f					_FPCNotRange:
.01994f	38		sec				sec
.019950	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019953	b0 0e		bcs $019963			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019955					_FPCNotEqual:
.019955	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019958	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01995a	f0 02		beq $01995e			beq 	_FPCNE2
.01995c	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01995e	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01995f	80 04		bra $019965			bra 	_FPCExit
.019961					_FPCPullZero:
.019961	68		pla				pla 								; throw saved exponents
.019962	68		pla				pla
.019963					_FPCZero:
.019963	a9 00		lda #$00			lda 	#0 							; and return zero
.019965					_FPCExit:
.019965	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019966					FPUCopyX2ToX1:
.019966	48		pha				pha
.019967	da		phx				phx
.019968	5a		phy				phy
.019969	a0 08		ldy #$08			ldy 	#8
.01996b	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.01996e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019971	e8		inx				inx
.019972	88		dey				dey
.019973	10 f6		bpl $01996b			bpl 	_FPUC21
.019975	7a		ply				ply
.019976	fa		plx				plx
.019977	68		pla				pla
.019978	60		rts				rts
.019979					FPUSetInteger:
.019979	48		pha				pha
.01997a	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01997d	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01997f	10 02		bpl $019983			bpl 	_FPUSIExtend
.019981	a9 ff		lda #$ff			lda 	#$FF
.019983					_FPUSIExtend:
.019983	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019986	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019989	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01998c	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01998e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019991	68		pla				pla
.019992	60		rts				rts
.019993					FPUNegateInteger:
.019993	48		pha				pha
.019994	38		sec				sec
.019995	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019997	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.01999a	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01999d	a9 00		lda #$00			lda 	#0
.01999f	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0199a2	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0199a5	a9 00		lda #$00			lda 	#0
.0199a7	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.0199aa	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0199ad	a9 00		lda #$00			lda 	#0
.0199af	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.0199b2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0199b5	68		pla				pla
.0199b6	60		rts				rts
.0199b7					FPUToFloat:
.0199b7	48		pha				pha
.0199b8	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.0199bb	29 0f		and #$0f			and 	#$0F
.0199bd	f0 2d		beq $0199ec			beq 	_FPUFExit
.0199bf	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.0199c1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0199c4	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.0199c6	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.0199c9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.0199cc	10 08		bpl $0199d6			bpl		_FPUFPositive
.0199ce	20 93 99	jsr $019993			jsr 	FPUNegateInteger 			; negate the mantissa
.0199d1	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.0199d3	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0199d6					_FPUFPositive:
.0199d6	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.0199d9	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0199dc	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0199df	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0199e2	d0 05		bne $0199e9			bne 	_FPUFNonZero
.0199e4	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.0199e6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0199e9					_FPUFNonZero:
.0199e9	20 ee 99	jsr $0199ee			jsr 	FPUNormalise 				; normalise the floating point.
.0199ec					_FPUFExit:
.0199ec	68		pla				pla
.0199ed	60		rts				rts
.0199ee					FPUNormalise:
.0199ee	48		pha				pha
.0199ef	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.0199f2	70 20		bvs $019a14			bvs 	_FPUNExit
.0199f4	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.0199f7	f0 16		beq $019a0f			beq 	_FPUNSetZero
.0199f9					_FPUNLoop:
.0199f9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.0199fc	30 16		bmi $019a14			bmi 	_FPUNExit 					; if so, we are normalised.
.0199fe	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019a01	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019a04	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019a07	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019a0a	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019a0d	d0 ea		bne $0199f9			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019a0f					_FPUNSetZero:
.019a0f	a9 40		lda #$40			lda 	#$40
.019a11	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019a14					_FPUNExit:
.019a14	68		pla				pla
.019a15	60		rts				rts
.019a16					FPUToInteger:
.019a16	48		pha				pha
.019a17	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019a1a	29 01		and #$01			and 	#1
.019a1c	d0 3e		bne $019a5c			bne 	_FPUTOI_Exit
.019a1e	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019a21	70 2b		bvs $019a4e			bvs 	_FPUTOI_Zero
.019a23	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019a26	10 26		bpl $019a4e			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019a28	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019a2a	b0 37		bcs $019a63			bcs 	FP_Overflow
.019a2c					_FPUToIToInteger:
.019a2c	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019a2f	c9 a0		cmp #$a0			cmp 	#128+32
.019a31	f0 11		beq $019a44			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019a33	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019a36	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019a39	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019a3c	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019a3f	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019a42	80 e8		bra $019a2c			bra 	_FPUToIToInteger 			; keep going.
.019a44					_FPUToICheckSign:
.019a44	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019a47	10 13		bpl $019a5c			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019a49	20 93 99	jsr $019993			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019a4c	80 0e		bra $019a5c			bra 	_FPUTOI_Exit
.019a4e					_FPUTOI_Zero:
.019a4e	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019a50	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019a53	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019a56	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019a59	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019a5c					_FPUToI_Exit:
.019a5c	a9 01		lda #$01			lda 	#1 							; set type to integer
.019a5e	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a61	68		pla				pla
.019a62	60		rts				rts
.019a63					FP_Overflow:
.019a63	20 2f 84	jsr $01842f			jsr ERR_Handler
>019a66	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019a6e	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019a7e					FPUTimes10:
.019a7e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019a81	85 1a		sta $1a				sta 	ZLTemp1+0
.019a83	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019a86	85 1b		sta $1b				sta 	ZLTemp1+1
.019a88	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019a8b	85 1c		sta $1c				sta 	ZLTemp1+2
.019a8d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019a90	85 1d		sta $1d				sta 	ZLTemp1+3
.019a92	20 d6 9a	jsr $019ad6			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019a95	20 d6 9a	jsr $019ad6			jsr 	_FPUT_LSR_ZLTemp1
.019a98	18		clc				clc
.019a99	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019a9c	65 1a		adc $1a				adc 	ZLTemp1+0
.019a9e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019aa1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019aa4	65 1b		adc $1b				adc 	ZLTemp1+1
.019aa6	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019aa9	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019aac	65 1c		adc $1c				adc 	ZLTemp1+2
.019aae	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019ab1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019ab4	65 1d		adc $1d				adc 	ZLTemp1+3
.019ab6	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019ab9	90 0f		bcc $019aca			bcc 	_FPUTimes10
.019abb	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019abe	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019ac1	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019ac4	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019ac7	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019aca					_FPUTimes10:
.019aca	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019acd	18		clc				clc
.019ace	69 03		adc #$03			adc 	#3
.019ad0	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019ad3	b0 8e		bcs $019a63			bcs 	FP_Overflow 				; error
.019ad5	60		rts				rts
.019ad6					_FPUT_LSR_ZLTemp1:
.019ad6	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019ad8	66 1c		ror $1c				ror 	ZLTemp1+2
.019ada	66 1b		ror $1b				ror 	ZLTemp1+1
.019adc	66 1a		ror $1a				ror 	ZLTemp1+0
.019ade	60		rts				rts
.019adf					FPUScale10A:
.019adf	5a		phy				phy
.019ae0	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019ae2	f0 3d		beq $019b21			beq 	_FPUScaleExit
.019ae4	da		phx				phx 								; save X
.019ae5	e8		inx				inx
.019ae6	e8		inx				inx
.019ae7	e8		inx				inx
.019ae8	e8		inx				inx
.019ae9	e8		inx				inx
.019aea	e8		inx				inx
.019aeb	a8		tay				tay 								; save power scalar in Y.
.019aec	a9 00		lda #$00			lda 	#0
.019aee	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019af1	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019af4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019af7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019afa	a9 80		lda #$80			lda 	#$80
.019afc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019aff	a9 81		lda #$81			lda 	#$81
.019b01	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019b04	5a		phy				phy 								; save 10^n on stack.
.019b05	c0 00		cpy #$00			cpy 	#0
.019b07	10 05		bpl $019b0e			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019b09	98		tya				tya
.019b0a	49 ff		eor #$ff			eor 	#$FF
.019b0c	1a		inc a				inc 	a
.019b0d	a8		tay				tay
.019b0e					_FPUSAbs:
.019b0e	20 7e 9a	jsr $019a7e			jsr 	FPUTimes10
.019b11	88		dey				dey
.019b12	d0 fa		bne $019b0e			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019b14	68		pla				pla 								; restore count in A
.019b15	fa		plx				plx 								; restore X pointing to number to scale.
.019b16	0a		asl a				asl 	a
.019b17	b0 05		bcs $019b1e			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019b19	20 05 98	jsr $019805			jsr 	FPMultiply 					; if clear multiply.
.019b1c	80 03		bra $019b21			bra		_FPUScaleExit
.019b1e					_FPUSDivide:
.019b1e	20 7d 97	jsr $01977d			jsr 	FPDivide
.019b21					_FPUScaleExit:
.019b21	7a		ply				ply
.019b22	60		rts				rts
.019b23					FPUCopyToNext:
.019b23	a0 06		ldy #$06			ldy 		#6
.019b25	da		phx				phx
.019b26					_FPUCopy1:
.019b26	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019b29	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019b2c	e8		inx				inx
.019b2d	88		dey				dey
.019b2e	d0 f6		bne $019b26			bne 	_FPUCopy1
.019b30	fa		plx				plx
.019b31	60		rts				rts
.019b32					FPUCopyFromNext:
.019b32	a0 06		ldy #$06			ldy 		#6
.019b34	da		phx				phx
.019b35					_FPUCopy1:
.019b35	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019b38	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019b3b	e8		inx				inx
.019b3c	88		dey				dey
.019b3d	d0 f6		bne $019b35			bne 	_FPUCopy1
.019b3f	fa		plx				plx
.019b40	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019b41					FPToString:
.019b41	48		pha				pha
.019b42	5a		phy				phy
.019b43	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019b46	50 0a		bvc $019b52			bvc 		_FPTSIsFloat 			; if zero,
.019b48					_FPTSZero:
.019b48	a9 30		lda #$30			lda 		#"0"
.019b4a	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter
.019b4d					_FPTSExit:
.019b4d	7a		ply				ply
.019b4e	68		pla				pla
.019b4f	60		rts				rts
.019b50	80 fb		bra $019b4d			bra 		_FPTSExit
.019b52					_FPTSIsFloat:
.019b52	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019b55	10 0a		bpl $019b61			bpl 		_FPTSNotSigned
.019b57	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019b59	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019b5c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019b5e	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter
.019b61					_FPTSNotSigned:
.019b61	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019b64	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019b66	b0 09		bcs $019b71			bcs 		_FPTSExponent
.019b68	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019b6a	90 05		bcc $019b71			bcc 		_FPTSExponent 			;
.019b6c					_FPTSStandard:
.019b6c	20 b5 9b	jsr $019bb5			jsr 		FPTOutputBody 			; output the body.
.019b6f	80 dc		bra $019b4d			bra 		_FPTSExit
.019b71					_FPTSExponent:
.019b71	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019b73	8d 8d 04	sta $048d			sta 		ExpCount
.019b76					_FPTSExponentLoop:
.019b76	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019b79	10 0e		bpl $019b89			bpl 		_FPTSTimes
.019b7b	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019b7d	90 14		bcc $019b93			bcc 		_FPTSScaledToExp
.019b7f	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019b81	20 df 9a	jsr $019adf			jsr 		FPUScale10A
.019b84	ee 8d 04	inc $048d			inc 		ExpCount
.019b87	80 ed		bra $019b76			bra 		_FPTSExponentLoop
.019b89					_FPTSTimes:
.019b89	a9 01		lda #$01			lda 		#1
.019b8b	20 df 9a	jsr $019adf			jsr 		FPUScale10A
.019b8e	ce 8d 04	dec $048d			dec 		ExpCount
.019b91	80 e3		bra $019b76			bra 		_FPTSExponentLoop
.019b93					_FPTSScaledToExp:
.019b93	20 b5 9b	jsr $019bb5			jsr 		FPTOutputBody 			; output the body.
.019b96	a9 65		lda #$65			lda 		#"e"					; output E
.019b98	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter
.019b9b	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.019b9e	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019ba1	29 80		and #$80			and 		#$80 					; sign extend it
.019ba3	f0 02		beq $019ba7			beq 		_FPTSSExt
.019ba5	a9 ff		lda #$ff			lda 		#$FF
.019ba7					_FPTSSExt:
.019ba7	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019baa	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019bad	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019bb0	20 2d 95	jsr $01952d			jsr 		INTToString 			; output the exponent.
.019bb3	80 98		bra $019b4d			bra			_FPTSExit 				; and exit.
.019bb5					FPTOutputBody:
.019bb5	20 23 9b	jsr $019b23			jsr 		FPUCopyToNext 			; copy to next slot.
.019bb8	20 16 9a	jsr $019a16			jsr 		FPUToInteger 			; convert to an integer
.019bbb	20 2d 95	jsr $01952d			jsr 		INTToString 			; output the main integer part.
.019bbe	20 32 9b	jsr $019b32			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019bc1	20 a2 98	jsr $0198a2			jsr 		FPFractionalPart 		; get the decimal part.
.019bc4	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019bc7	70 3e		bvs $019c07			bvs 		_FPTOExit 				; if not, exit now.
.019bc9	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019bcb	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter
.019bce					_FPOutLoop:
.019bce	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019bd1	70 1e		bvs $019bf1			bvs 		_FPStripZeros 			; strip trailing zeros
.019bd3	20 7e 9a	jsr $019a7e			jsr 		FPUTimes10 				; multiply by 10
.019bd6	20 23 9b	jsr $019b23			jsr 		FPUCopyToNext			; copy to next slot.
.019bd9	20 16 9a	jsr $019a16			jsr 		FPUToInteger 			; convert to integer
.019bdc	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019bdf	09 30		ora #$30			ora 		#"0"
.019be1	20 d1 95	jsr $0195d1			jsr 		ITSOutputCharacter
.019be4	20 32 9b	jsr $019b32			jsr 		FPUCopyFromNext 		; get it back
.019be7	20 a2 98	jsr $0198a2			jsr 		FPFractionalPart 		; get fractional part
.019bea	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.019bed	c9 0b		cmp #$0b			cmp 	 	#11
.019bef	90 dd		bcc $019bce			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019bf1					_FPStripZeros:
.019bf1	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.019bf4					_FPStripLoop:
.019bf4	88		dey				dey 								; back one, if at start then no strip
.019bf5	f0 10		beq $019c07			beq 		_FPToExit
.019bf7	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.019bfa	c9 30		cmp #$30			cmp 		#"0"
.019bfc	f0 f6		beq $019bf4			beq 		_FPStripLoop
.019bfe	c8		iny				iny
.019bff	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019c01	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.019c04	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.019c07					_FPTOExit:
.019c07	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019c08					FPFromString:
.019c08	48		pha				pha 								; push A
.019c09	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019c0b	c9 2e		cmp #$2e			cmp 	#"."
.019c0d	f0 03		beq $019c12			beq	 	_FPFIsDecimal
.019c0f	4c 75 9c	jmp $019c75			jmp 	_FPFNotDecimal
.019c12					_FPFIsDecimal:
.019c12	c8		iny				iny 								; consume the decimal.
.019c13	20 b7 99	jsr $0199b7			jsr 	FPUToFloat 					; convert the integer to float.
.019c16	da		phx				phx 								; save X.
.019c17	5a		phy				phy 								; save decimal start position
.019c18	e8		inx				inx
.019c19	e8		inx				inx
.019c1a	e8		inx				inx
.019c1b	e8		inx				inx
.019c1c	e8		inx				inx
.019c1d	e8		inx				inx
.019c1e	20 e9 95	jsr $0195e9			jsr 	INTFromStringY 				; get the part after the DP.
.019c21	20 b7 99	jsr $0199b7			jsr 	FPUToFloat 					; convert that to a float.
.019c24	68		pla				pla 								; calculate - chars consumed.
.019c25	8c 8c 04	sty $048c			sty 	ExpTemp
.019c28	38		sec				sec
.019c29	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.019c2c	20 df 9a	jsr $019adf			jsr 	FPUScale10A 				; scale it by 10^AC
.019c2f	fa		plx				plx 								; restore original X
.019c30	20 99 96	jsr $019699			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019c33	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019c35	c9 45		cmp #$45			cmp 	#"E"
.019c37	f0 04		beq $019c3d			beq 	_FPFExponent
.019c39	c9 65		cmp #$65			cmp 	#"e"
.019c3b	d0 38		bne $019c75			bne 	_FPFNotDecimal 				; no, then exit normally.
.019c3d					_FPFExponent:
.019c3d	c8		iny				iny 								; skip over E symbol.
.019c3e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019c40	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019c42	d0 01		bne $019c45			bne 	_FPFGotSign
.019c44	c8		iny				iny 								; if it was - skip over it.
.019c45					_FPFGotSign:
.019c45	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019c46	da		phx				phx
.019c47	e8		inx				inx
.019c48	e8		inx				inx
.019c49	e8		inx				inx
.019c4a	e8		inx				inx
.019c4b	e8		inx				inx
.019c4c	e8		inx				inx
.019c4d	20 e9 95	jsr $0195e9			jsr 	INTFromStringY 				; get the exponent
.019c50	fa		plx				plx 								; restore X.
.019c51	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019c54	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019c57	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019c5a	d0 1b		bne $019c77			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019c5c	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019c5f	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019c61	b0 14		bcs $019c77			bcs 	_FPFXOverflow
.019c63	68		pla				pla 								; get direction
.019c64	d0 09		bne $019c6f			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019c66	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019c69	49 ff		eor #$ff			eor 	#$FF
.019c6b	1a		inc a				inc 	a
.019c6c	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019c6f					_FPFXScale:
.019c6f	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019c72	20 df 9a	jsr $019adf			jsr 	FPUScale10A 				; scale by the exponent.
.019c75					_FPFNotDecimal:
.019c75	68		pla				pla
.019c76	60		rts				rts
.019c77					_FPFXOverflow:
.019c77	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019c7a	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019c82	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019c89					Unary_Rnd:
.019c89	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.019c8c	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.019c8f	20 ac 8c	jsr $018cac			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019c92	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019c94	30 10		bmi $019ca6			bmi 	_URSetSeed
.019c96	f0 2c		beq $019cc4			beq 	_URMakeRandom 				; if zero return same number.
.019c98	da		phx				phx
.019c99	a2 00		ldx #$00			ldx 	#0
.019c9b	20 01 9d	jsr $019d01			jsr 	Random16
.019c9e	a2 02		ldx #$02			ldx 	#2
.019ca0	20 01 9d	jsr $019d01			jsr 	Random16
.019ca3	fa		plx				plx
.019ca4	80 1e		bra $019cc4			bra 	_URMakeRandom
.019ca6					_URSetSeed:
.019ca6	20 b7 99	jsr $0199b7			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019ca9	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019cac	8d 93 04	sta $0493			sta 	RandomSeed+0
.019caf	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019cb2	8d 94 04	sta $0494			sta 	RandomSeed+1
.019cb5	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019cb8	8d 95 04	sta $0495			sta 	RandomSeed+2
.019cbb	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019cbe	0a		asl a				asl 	a
.019cbf	49 db		eor #$db			eor 	#$DB
.019cc1	8d 96 04	sta $0496			sta 	RandomSeed+3
.019cc4					_URMakeRandom:
.019cc4	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.019cc7	0d 94 04	ora $0494			ora 	RandomSeed+1
.019cca	0d 95 04	ora $0495			ora 	RandomSeed+2
.019ccd	0d 96 04	ora $0496			ora 	RandomSeed+3
.019cd0	d0 0a		bne $019cdc			bne 	_URNotZero
.019cd2	a9 47		lda #$47			lda 	#$47
.019cd4	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.019cd7	a9 3d		lda #$3d			lda 	#$3D
.019cd9	8d 96 04	sta $0496			sta 	RandomSeed+3
.019cdc					_URNotZero:
.019cdc	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.019cdf	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019ce2	ad 94 04	lda $0494			lda 	RandomSeed+1
.019ce5	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019ce8	ad 95 04	lda $0495			lda 	RandomSeed+2
.019ceb	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019cee	ad 96 04	lda $0496			lda 	RandomSeed+3
.019cf1	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019cf4	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019cf6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019cf9	a9 80		lda #$80			lda 	#$80
.019cfb	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019cfe	4c ee 99	jmp $0199ee			jmp 	FPUNormalise
.019d01					Random16:
.019d01	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.019d04	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.019d07	90 08		bcc $019d11			bcc 	_R16_NoXor
.019d09	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019d0c	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019d0e	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.019d11					_R16_NoXor:
.019d11	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019d12					Unary_Int:
.019d12	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.019d15	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.019d18	4c 16 9a	jmp $019a16			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019d1b	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
