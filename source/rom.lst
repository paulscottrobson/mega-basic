
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Sep  1 22:21:35 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	14 0a 00 ce fe 07 68 65			.byte	$14,$0a,$00,$ce,$fe,$07,$68,$65
>1008	6c 6c 6f bf 08 05 0c 0c			.byte	$6c,$6c,$6f,$bf,$08,$05,$0c,$0c
>1010	0f bf 02 00 11 14 00 ce			.byte	$0f,$bf,$02,$00,$11,$14,$00,$ce
>1018	fe 09 61 6e 6f 74 68 65			.byte	$fe,$09,$61,$6e,$6f,$74,$68,$65
>1020	72 bf 03 bb 00 0f 1e 00			.byte	$72,$bf,$03,$bb,$00,$0f,$1e,$00
>1028	d6 08 05 0c 0c 0f bf 02			.byte	$d6,$08,$05,$0c,$0c,$0f,$bf,$02
>1030	bf 03 bb 00 05 28 00 c4			.byte	$bf,$03,$bb,$00,$05,$28,$00,$c4
>1038	00 00					.byte	$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 0b 88 01	jmp $01880b		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 73 83 01	jmp $018373			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a6 81	jsr $0181a6			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d2 81	jsr $0181d2			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 b9 81	jsr $0181b9			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a6 81	jsr $0181a6			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d2 81	jsr $0181d2			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 b9 81	jsr $0181b9			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d2 81	jsr $0181d2			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 c9 81	jsr $0181c9			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d2 81	jsr $0181d2			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 b9 81	jsr $0181b9			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e3 81	jsr $0181e3			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 c9 81	jsr $0181c9			jsr 	IF_Read 					; read
.0180ea	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d2 81	jsr $0181d2			jsr 	IF_Write 					; write
.0180f2	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d2 81	jsr $0181d2			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 c9 81	jsr $0181c9			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 c9 81	jsr $0181c9			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	68		pla				pla
.0181a0	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a2	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a5					IF_Reset:
.0181a5	60		rts				rts
.0181a6					IF_Home:
.0181a6	48		pha				pha
.0181a7	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181a9	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ab	85 04		sta $04				sta 	IF_Pos
.0181ad	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181af	85 05		sta $05				sta 	IF_Pos+1
.0181b1	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b3	85 06		sta $06				sta 	IF_Pos+2
.0181b5	64 07		stz $07				stz 	IF_Pos+3
.0181b7	68		pla				pla
.0181b8	60		rts				rts
.0181b9					IF_NewLine:
.0181b9	48		pha				pha
.0181ba	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bc	18		clc				clc 								; down one line
.0181bd	a5 04		lda $04				lda 	IF_Pos
.0181bf	69 40		adc #$40			adc 	#64
.0181c1	85 04		sta $04				sta 	IF_Pos
.0181c3	90 02		bcc $0181c7			bcc 	_IF_NoCarry 				; carry through.
.0181c5	e6 05		inc $05				inc 	IF_Pos+1
.0181c7					_IF_NoCarry:
.0181c7	68		pla				pla
.0181c8	60		rts				rts
.0181c9					IF_Read:
.0181c9	5a		phy				phy 								; save current Y
.0181ca	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cc	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181ce	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d0	7a		ply				ply									; restore Y
.0181d1	60		rts				rts
.0181d2					IF_Write:
.0181d2	5a		phy				phy 								; save current Y
.0181d3	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d5	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181d7	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d9	7a		ply				ply									; restore Y
.0181da	60		rts				rts
.0181db					IF_LeftOne:
.0181db	c6 08		dec $08				dec 	IF_XPos
.0181dd	60		rts				rts
.0181de					IF_CheckBreak:
.0181de	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e2	60		rts				rts
.0181e3					IF_GetKey:
.0181e3	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181e7	f0 08		beq $0181f1			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181e9	48		pha				pha 								; key pressed, clear queue.
.0181ea	a9 00		lda #$00			lda 	#0
.0181ec	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f0	68		pla				pla
.0181f1					_IFGK_NoKey:
.0181f1	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f4					TIM_Error:
.0181f4	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181f7	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181f9	80 02		bra $0181fd			bra 	TIM_ShowPrompt
.0181fb					TIM_NewCommand:
.0181fb	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181fd					TIM_ShowPrompt:
.0181fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018200	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018203	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018206	86 10		stx $10				stx 	zTemp1 						; save line read address
.018208	84 11		sty $11				sty 	zTemp1+1
.01820a	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01820e	c9 3f		cmp #$3f			cmp 	#"?"
.018210	f0 04		beq $018216			beq 	TIM_SkipFirst
.018212	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018214	d0 01		bne $018217			bne 	TIM_NotDot
.018216					TIM_SkipFirst:
.018216	c8		iny				iny
.018217					TIM_NotDot:
.018217	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.018219	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821b	f0 6b		beq $018288			beq 	TIM_ShowRegisters
.01821d	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.01821f	f0 12		beq $018233			beq 	TIM_ShowMemory
.018221	c9 47		cmp #$47			cmp 	#"G"						; execute
.018223	f0 49		beq $01826e			beq 	TIM_Execute
.018225	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.018227	f0 07		beq $018230			beq 	TIM_GoLoadMemory
.018229	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822b	d0 c7		bne $0181f4			bne 	TIM_Error
.01822d	4c ac 83	jmp $0183ac			jmp 	TIM_UpdateRegisters
.018230					TIM_GoLoadMemory:
.018230	4c dc 83	jmp $0183dc			jmp 	TIM_LoadMemory
.018233					TIM_ShowMemory:
.018233	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018236	b0 bc		bcs $0181f4			bcs 	TIM_Error
.018238	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823a	85 12		sta $12				sta 	zTemp2
.01823c	a5 15		lda $15				lda 	zTemp3+1
.01823e	85 13		sta $13				sta 	zTemp2+1
.018240	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018243	90 08		bcc $01824d			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018245	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.018247	85 14		sta $14				sta 	zTemp3
.018249	a5 13		lda $13				lda 	zTemp2+1
.01824b	85 15		sta $15				sta 	zTemp3+1
.01824d					_TIMSM_Start:
.01824d	20 00 83	jsr $018300			jsr 	TIM_WriteLine 				; write one line of hex out
.018250	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018252	18		clc				clc
.018253	69 10		adc #$10			adc 	#16
.018255	85 12		sta $12				sta 	zTemp2
.018257	90 02		bcc $01825b			bcc 	_TIMSM_NoCarry
.018259	e6 13		inc $13				inc 	zTemp2+1
.01825b					_TIMSM_NoCarry:
.01825b	20 de 81	jsr $0181de			jsr 	IF_CheckBreak 				; check CTL+C
.01825e	d0 0b		bne $01826b			bne 	_TIMSM_Ends 				; if pressed break out.
.018260	38		sec				sec 								; check past the end address in zTemp3
.018261	a5 14		lda $14				lda 	zTemp3
.018263	e5 12		sbc $12				sbc 	zTemp2
.018265	a5 15		lda $15				lda 	zTemp3+1
.018267	e5 13		sbc $13				sbc 	zTemp2+1
.018269	10 e2		bpl $01824d			bpl 	_TIMSM_Start
.01826b					_TIMSM_Ends:
.01826b	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand
.01826e					TIM_Execute:
.01826e	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get the execute address
.018271	b0 81		bcs $0181f4			bcs 	TIM_Error 					; not legitimate
.018273	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018276	9a		txs				txs
.018277	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827a	48		pha				pha
.01827b	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.01827e	ae ca 03	ldx $03ca			ldx 	TIM_X
.018281	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018284	28		plp				plp 								; and PS Byte.
.018285	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.018288					TIM_Start:
.018288					TIM_ShowRegisters:
.018288	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828b	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.01828e	ad ff ff	lda $ffff			lda 	$FFFF
.018291	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018294	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018296					_TIMSR_Text:
.018296	bf c7 82 01	lda $0182c7,x			lda 	_TIMSR_Label,x
.01829a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01829d	e8		inx				inx
.01829e	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a0	d0 f4		bne $018296			bne 	_TIMSR_Text
.0182a2	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a4					_TIMSR_Skip:
.0182a4	e8		inx				inx
.0182a5					_TIMSR_LoopSpace:
.0182a5	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182a7	b0 04		bcs $0182ad			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182a9	8a		txa				txa
.0182aa	4a		lsr a				lsr 	a
.0182ab	b0 05		bcs $0182b2			bcs 	_TIMSR_NoSpace
.0182ad					_TIMSR_Space:
.0182ad	a9 20		lda #$20			lda 	#" "
.0182af	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b2					_TIMSR_NoSpace:
.0182b2	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b5	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.0182b8	e8		inx				inx
.0182b9	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182bb	f0 e7		beq $0182a4			beq 	_TIMSR_Skip
.0182bd	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182bf	d0 e4		bne $0182a5			bne 	_TimSR_LoopSpace
.0182c1	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c4	4c fb 81	jmp $0181fb			jmp	 	TIM_NewCommand 				; new command.
.0182c7					_TIMSR_Label:
>0182c7	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182cf	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182df	52
>0182e0	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182e7					_TIMSR_LabelEnd:
.0182e7					TIM_WriteHex:
.0182e7	48		pha				pha 								; save A
.0182e8	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182e9	4a		lsr a				lsr 	a
.0182ea	4a		lsr a				lsr 	a
.0182eb	4a		lsr a				lsr 	a
.0182ec	20 f0 82	jsr $0182f0			jsr 	_TIMWH_Nibble 				; print MSB
.0182ef	68		pla				pla 								; restore and print LSB
.0182f0					_TIMWH_Nibble:
.0182f0	48		pha				pha
.0182f1	29 0f		and #$0f			and 	#15 						; mask out
.0182f3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f5	90 02		bcc $0182f9			bcc 	_TIMWHNoLetter
.0182f7	69 06		adc #$06			adc 	#6
.0182f9					_TIMWHNoLetter:
.0182f9	69 30		adc #$30			adc 	#48
.0182fb	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182fe	68		pla				pla
.0182ff	60		rts				rts
.018300					TIM_WriteLine:
.018300	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018302	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018305	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.018307	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830a	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830c	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.01830f	a5 12		lda $12				lda 	zTemp2
.018311	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.018314	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018316					_TIMWL_Loop:
.018316	a9 20		lda #$20			lda 	#" "
.018318	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01831d	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.018320	c8		iny				iny
.018321	c0 10		cpy #$10			cpy 	#16
.018323	d0 f1		bne $018316			bne 	_TIMWL_Loop
.018325	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.018328					TIM_GetHex:
.018328	c8		iny				iny
.018329	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832b	c9 20		cmp #$20			cmp 	#32
.01832d	f0 f9		beq $018328			beq 	TIM_GetHex
.01832f	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018331	f0 f5		beq $018328			beq 	TIM_GetHex
.018333	20 5c 83	jsr $01835c			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018336	b0 23		bcs $01835b			bcs 	_TIMGH_Exit					; if first bad then exit now.
.018338	a9 00		lda #$00			lda 	#0 							; zero result
.01833a	85 14		sta $14				sta 	zTemp3
.01833c	85 15		sta $15				sta 	zTemp3+1
.01833e					_TIM_GHLoop:
.01833e	20 5c 83	jsr $01835c			jsr 	TIM_GetHexCharacter 		; get next character
.018341	b0 17		bcs $01835a			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018343	c8		iny				iny 								; skip over it.
.018344	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018346	26 15		rol $15				rol 	zTemp3+1
.018348	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834a	26 15		rol $15				rol 	zTemp3+1
.01834c	06 14		asl $14				asl 	zTemp3						; now x 4
.01834e	26 15		rol $15				rol 	zTemp3+1
.018350	06 14		asl $14				asl 	zTemp3 						; now x 8
.018352	26 15		rol $15				rol 	zTemp3+1
.018354	05 14		ora $14				ora 	zTemp3 						; OR result in
.018356	85 14		sta $14				sta 	zTemp3
.018358	80 e4		bra $01833e			bra 	_TIM_GHLoop 				; loop round again.
.01835a					_TIMGH_Okay:
.01835a	18		clc				clc
.01835b					_TIMGH_Exit:
.01835b	60		rts				rts
.01835c					TIM_GetHexCharacter:
.01835c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01835e	38		sec				sec
.01835f	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018361	90 0e		bcc $018371			bcc 	_TIM_GHCFail
.018363	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018365	90 0b		bcc $018372			bcc 	_TIM_GHCExit
.018367	c9 11		cmp #$11			cmp 	#65-48						; < A
.018369	90 06		bcc $018371			bcc		_TIM_GHCFail
.01836b	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.01836d	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.01836f	90 01		bcc $018372			bcc		_TIM_GHCExit
.018371					_TIM_GHCFail:
.018371	38		sec				sec
.018372					_TIM_GHCExit:
.018372	60		rts				rts
.018373					TIM_BreakVector:
.018373	da		phx				phx									; save X/A on stack
.018374	48		pha				pha
.018375	ba		tsx				tsx 								; X points to S
.018376	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.018379	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837b	d0 03		bne $018380			bne 	_TIMBreak					; if set, it's BRK
.01837d	68		pla				pla 								; abandon routine.
.01837e	fa		plx				plx
.01837f	40		rti				rti
.018380					_TIMBreak:
.018380	68		pla				pla 								; save A X Y and maybe Z
.018381	8d c9 03	sta $03c9			sta 	TIM_A
.018384	fa		plx				plx
.018385	8e ca 03	stx $03ca			stx 	TIM_X
.018388	8c cb 03	sty $03cb			sty 	TIM_Y
.01838b	68		pla				pla 								; get Status Register
.01838c	8d c8 03	sta $03c8			sta 	TIM_SR
.01838f	68		pla				pla
.018390	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018393	68		pla				pla
.018394	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.018397	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839a	d0 03		bne $01839f			bne 	_TIMDecrement 				; brk bumps it.
.01839c	ce c4 03	dec $03c4			dec 	TIM_PC
.01839f					_TIMDecrement:
.01839f	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a2	ba		tsx				tsx 								; and copy SP
.0183a3	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a6	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183a8	9a		txs				txs
.0183a9	4c 88 82	jmp $018288			jmp 	TIM_Start 					; and start up TIM monitor.
.0183ac					TIM_UpdateRegisters:
.0183ac	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; PC
.0183af	b0 28		bcs $0183d9			bcs 	_TIMURFail
.0183b1	a5 14		lda $14				lda 	zTemp3
.0183b3	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b6	a5 15		lda $15				lda 	zTemp3+1
.0183b8	8d c4 03	sta $03c4			sta 	Tim_PC
.0183bb	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; ignore IRQ
.0183be	b0 19		bcs $0183d9			bcs 	_TIMURFail
.0183c0	a2 00		ldx #$00			ldx 	#0
.0183c2					_TIM_URLoop:
.0183c2	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c4	d0 01		bne $0183c7			bne 	_TIM_1
.0183c6	e8		inx				inx
.0183c7					_TIM_1:
.0183c7	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; registers
.0183ca	b0 0d		bcs $0183d9			bcs 	_TIMURFail
.0183cc	a5 14		lda $14				lda 	zTemp3
.0183ce	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d1	e8		inx				inx
.0183d2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d4	d0 ec		bne $0183c2			bne 	_TIM_URLoop
.0183d6	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand
.0183d9					_TIMURFail:
.0183d9	4c f4 81	jmp $0181f4			jmp 	TIM_Error
.0183dc					TIM_LoadMemory:
.0183dc	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; target address => zTemp2
.0183df	a5 14		lda $14				lda 	zTemp3
.0183e1	85 12		sta $12				sta 	zTemp2
.0183e3	a5 15		lda $15				lda 	zTemp3+1
.0183e5	85 13		sta $13				sta 	zTemp2+1
.0183e7					_TIM_LMLoop:
.0183e7	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; next byte ?
.0183ea	b0 0e		bcs $0183fa			bcs 	_TIMLMDone 					; no more
.0183ec	a2 00		ldx #$00			ldx 	#0							; write out.
.0183ee	a5 14		lda $14				lda 	zTemp3
.0183f0	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f2	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f4	d0 f1		bne $0183e7			bne 	_TIM_LMLoop
.0183f6	e6 13		inc $13				inc 	zTemp2+1
.0183f8	80 ed		bra $0183e7			bra 	_TIM_LMLoop
.0183fa					_TIMLMDone:
.0183fa	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183fd					StructureSearchSingle:
.0183fd	a2 00		ldx #$00			ldx 	#0
.0183ff					StructureSearchDouble:
.0183ff	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.018401	86 11		stx $11				stx 	zTemp1+1
.018403	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018405	85 12		sta $12				sta 	zTemp2
.018407	80 18		bra $018421			bra 	_SSWLoop 					; jump in, start scanning from here.
.018409					_SSWNextLine:
.018409	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840b	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01840d	18		clc				clc
.01840e	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018410	85 16		sta $16				sta 	zCodePtr
.018412	90 02		bcc $018416			bcc 	_SNLNoCarry
.018414	e6 17		inc $17				inc 	zCodePtr+1
.018416					_SNLNoCarry:
.018416	a0 00		ldy #$00			ldy 	#0
.018418	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01841a	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841c	f0 54		beq $018472			beq 	_SSWFail
.01841e	c8		iny				iny
.01841f	c8		iny				iny
.018420					_SSWNextSimple:
.018420	c8		iny				iny
.018421					_SSWLoop:
.018421	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018423	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018425	f0 e2		beq $018409			beq 	_SSWNextLine 				; if so, then next line
.018427	10 f7		bpl $018420			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.018429	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842b	d0 08		bne $018435			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.01842d	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.01842f	f0 2d		beq $01845e			beq 	_SSWFound 					; so exit.
.018431	c5 11		cmp $11				cmp 	zTemp1+1
.018433	f0 29		beq $01845e			beq 	_SSWFound
.018435					_SSWCheckUpDown:
.018435	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.018437	90 10		bcc $018449			bcc 	_SSWNext
.018439	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843b	90 08		bcc $018445			bcc 	_SSWPlus
.01843d	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.01843f	b0 08		bcs $018449			bcs 	_SSWNext
.018441	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018443	c6 12		dec $12				dec 	zTemp2
.018445					_SSWPlus:
.018445	e6 12		inc $12				inc 	zTemp2
.018447	30 16		bmi $01845f			bmi 	_SSWUnder					; error if driven -ve
.018449					_SSWNext:
.018449	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01844b	c8		iny				iny 								; skip
.01844c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01844e	90 0c		bcc $01845c			bcc 	_SEDone 					; so just skip over it.
.018450	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018452	90 07		bcc $01845b			bcc 	_SEDouble
.018454	98		tya				tya 								; this is Y + 1
.018455	18		clc				clc
.018456	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018458	a8		tay				tay 								; back in Y.
.018459	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845a	88		dey				dey
.01845b					_SEDouble:
.01845b	c8		iny				iny
.01845c					_SEDone:
.01845c	80 c3		bra $018421			bra 	_SSWLoop
.01845e					_SSWFound:
.01845e	60		rts				rts
.01845f					_SSWUnder:
.01845f	20 83 85	jsr $018583			jsr ERR_Handler
>018462	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846a	65 20 6f 72 64 65 72 00
.018472					_SSWFail:
.018472	20 83 85	jsr $018583			jsr ERR_Handler
>018475	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>01847d	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848a					SkipEndOfCommand:
.01848a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01848c	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.01848e	f0 19		beq $0184a9			beq 	_SOCExit
.018490	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018492	f0 15		beq $0184a9			beq 	_SOCExit
.018494	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018496	c8		iny				iny 								; skip
.018497	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018499	90 0c		bcc $0184a7			bcc 	_SEDone 					; so just skip over it.
.01849b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01849d	90 07		bcc $0184a6			bcc 	_SEDouble
.01849f	98		tya				tya 								; this is Y + 1
.0184a0	18		clc				clc
.0184a1	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0184a3	a8		tay				tay 								; back in Y.
.0184a4	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a5	88		dey				dey
.0184a6					_SEDouble:
.0184a6	c8		iny				iny
.0184a7					_SEDone:
.0184a7	80 e1		bra $01848a			bra 	SkipEndOfCommand
.0184a9					_SOCExit:
.0184a9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184aa					StackReset:
.0184aa	48		pha				pha
.0184ab	5a		phy				phy
.0184ac	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.0184ae	85 26		sta $26				sta 	zBasicSP
.0184b0	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.0184b2	85 27		sta $27				sta 	zBasicSP+1
.0184b4	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b6	98		tya				tya 								; be a legal token.
.0184b7	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184b9	7a		ply				ply
.0184ba	68		pla				pla
.0184bb	60		rts				rts
.0184bc					StackPushFrame:
.0184bc	48		pha				pha
.0184bd	5a		phy				phy
.0184be	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184bf	48		pha				pha 								; save it.
.0184c0	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184c2	18		clc				clc 								; add to Basic Stack
.0184c3	65 26		adc $26				adc 	zBasicSP
.0184c5	85 26		sta $26				sta 	zBasicSP
.0184c7	90 02		bcc $0184cb			bcc 	_SPFNoBump
.0184c9	e6 27		inc $27				inc 	zBasicSP+1
.0184cb					_SPFNoBump:
.0184cb	a0 00		ldy #$00			ldy 	#0
.0184cd	68		pla				pla
.0184ce	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184d0	7a		ply				ply
.0184d1	68		pla				pla
.0184d2	60		rts				rts
.0184d3					StackPopFrame:
.0184d3	48		pha				pha
.0184d4	5a		phy				phy
.0184d5	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184d7	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184d9	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184db	d0 12		bne $0184ef			bne 	SPFError 					; mixed structures
.0184dd	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184df	29 0f		and #$0f			and 	#$0F
.0184e1	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e3	38		sec				sec
.0184e4	65 26		adc $26				adc 	zBasicSP
.0184e6	85 26		sta $26				sta 	zBasicSP
.0184e8	b0 02		bcs $0184ec			bcs 	_SPFNoBump
.0184ea	c6 27		dec $27				dec 	zBasicSP+1
.0184ec					_SPFNoBump:
.0184ec	7a		ply				ply
.0184ed	68		pla				pla
.0184ee	60		rts				rts
.0184ef					SPFError:
.0184ef	20 83 85	jsr $018583			jsr ERR_Handler
>0184f2	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fa	72 75 63 74 75 72 65 73 00
.018503					StackSavePosition:
.018503	98		tya				tya
.018504	5a		phy				phy
.018505	a0 05		ldy #$05			ldy 	#5
.018507	91 26		sta ($26),y			sta 	(zBasicSP),y
.018509	a0 01		ldy #$01			ldy 	#1
.01850b	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.01850d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 17		lda $17				lda 	zCodePtr+1
.018512	91 26		sta ($26),y			sta 	(zBasicSP),y
.018514	c8		iny				iny
.018515	a5 18		lda $18				lda 	zCodePtr+2
.018517	91 26		sta ($26),y			sta 	(zBasicSP),y
.018519	c8		iny				iny
.01851a	a5 19		lda $19				lda 	zCodePtr+3
.01851c	91 26		sta ($26),y			sta 	(zBasicSP),y
.01851e	7a		ply				ply
.01851f	60		rts				rts
.018520					StackRestorePosition:
.018520	5a		phy				phy
.018521	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018523	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018525	85 16		sta $16				sta 	zCodePtr+0
.018527	c8		iny				iny
.018528	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852a	85 17		sta $17				sta 	zCodePtr+1
.01852c	c8		iny				iny
.01852d	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01852f	85 18		sta $18				sta 	zCodePtr+2
.018531	c8		iny				iny
.018532	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018534	85 19		sta $19				sta 	zCodePtr+3
.018536	c8		iny				iny
.018537	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.018539	7a		ply				ply 								; restore Y
.01853a	a8		tay				tay
.01853b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853c					VIOCharPrint:
.01853c	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.01853f					VIOCharGet:
.01853f	20 e3 81	jsr $0181e3			jsr 	IF_GetKey
.018542	c9 00		cmp #$00			cmp 	#0
.018544	f0 02		beq $018548			beq 	_VCG0
.018546	38		sec				sec
.018547	60		rts				rts
.018548	18		clc		_VCG0:	clc
.018549	60		rts				rts
.01854a					VIOCheckBreak:
.01854a	4c de 81	jmp $0181de			jmp 	IF_CheckBreak
.01854d					VIOCharGetPosition:
.01854d	ad 00 05	lda $0500			lda 	IFT_XCursor
.018550	60		rts				rts
.018551					VIOReadLine:
.018551	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018554					SyntaxError:
.018554	20 83 85	jsr $018583			jsr 	ERR_Handler
>018557	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01855f	72 72 6f 72 00
.018564					TypeError:
.018564	20 83 85	jsr $018583			jsr 	ERR_Handler
>018567	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01856f	70 65 00
.018572					BadParamError:
.018572	20 83 85	jsr $018583			jsr 	ERR_Handler
>018575	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>01857d	6d 65 74 65 72 00
.018583					ERR_Handler:
.018583	a0 00		ldy #$00			ldy 	#0
.018585	c8		iny				iny
.018586	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018588	85 80		sta $80				sta 	XS_Mantissa
.01858a	c8		iny				iny
.01858b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01858d	85 81		sta $81				sta 	XS_Mantissa+1
.01858f	fa		plx				plx 								; address in XY
.018590	7a		ply				ply
.018591	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018592	d0 01		bne $018595			bne 	_EHNoSkip
.018594	c8		iny				iny
.018595					_EHNoSkip:
.018595	20 b4 85	jsr $0185b4			jsr 	PrintROMMessage 			; print message from ROM.
.018598	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859a	05 81		ora $81				ora 	XS_Mantissa+1
.01859c	f0 0c		beq $0185aa			beq 	_EHNoLine
.01859e	a2 af		ldx #$af			ldx 	#_EHAt & $FF 				; print " at "
.0185a0	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a2	20 b4 85	jsr $0185b4			jsr 	PrintROMMessage
.0185a5	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185a7	20 c9 85	jsr $0185c9			jsr 	Print16BitInteger
.0185aa					_EHNoLine:
.0185aa	80 fe		bra $0185aa			bra 	_EHNoLine
.0185ac	4c 3c 88	jmp $01883c			jmp 	WarmStart 					; normally warm start.
>0185af	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185b4					PrintROMMessage:
.0185b4	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.0185b6	84 1b		sty $1b				sty 	zLTemp1+1
.0185b8	4b		phk				phk 								; get current code page
.0185b9	68		pla				pla
.0185ba	85 1c		sta $1c				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185bc	a0 00		ldy #$00			ldy 	#0
.0185be					_PRMLoop:
.0185be	b7 1a		lda [$1a],y			lda 	[zLTemp1],y 				; 65816
.0185c0	f0 06		beq $0185c8			beq		_PRMExit 					; character $00 => exit
.0185c2	c8		iny				iny  								; bump Y and print it.
.0185c3	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.0185c6	80 f6		bra $0185be			bra 	_PRMLoop
.0185c8					_PRMExit:
.0185c8	60		rts				rts
.0185c9					Print16BitInteger:
.0185c9	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185cb	85 82		sta $82				sta 	XS_Mantissa+2
.0185cd	85 83		sta $83				sta 	XS_Mantissa+3
.0185cf					Print32BitInteger:
.0185cf	a9 00		lda #$00			lda 	#0
.0185d1	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185d4	aa		tax				tax 								; convert bottom level.
.0185d5	20 29 9f	jsr $019f29			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185d8	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185da	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185dd	f0 06		beq $0185e5			beq 	_P1Exit
.0185df	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.0185e2	e8		inx				inx
.0185e3	80 f5		bra $0185da			bra 	_P1Loop
.0185e5	8a		txa		_P1Exit:txa 								; return chars printed.
.0185e6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185e7					VectorTable:
>0185e7	62 93					.word BinaryOp_And         & $FFFF ; $80 and
>0185e9	7e 93					.word BinaryOp_Or          & $FFFF ; $81 or
>0185eb	9a 93					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185ed	9a 93					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185ef	d1 93					.word Binary_Equal         & $FFFF ; $84 =
>0185f1	da 93					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185f3	e3 93					.word Binary_Less          & $FFFF ; $86 <
>0185f5	ec 93					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185f7	fe 93					.word Binary_Greater       & $FFFF ; $88 >
>0185f9	f5 93					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185fb	96 94					.word BinaryOp_Add         & $FFFF ; $8a +
>0185fd	b2 94					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185ff	c3 94					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018601	d4 94					.word BinaryOp_Divide      & $FFFF ; $8d /
>018603	a5 86					.word NotImplemented       & $FFFF ; $8e ^
>018605	f0 8c					.word Command_IF           & $FFFF ; $8f if
>018607	5e 91					.word Command_WHILE        & $FFFF ; $90 while
>018609	86 91					.word Command_REPEAT       & $FFFF ; $91 repeat
>01860b	a0 89					.word Command_FOR          & $FFFF ; $92 for
>01860d	a5 86					.word NotImplemented       & $FFFF ; $93 then
>01860f	4d 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018611	7b 91					.word Command_WEND         & $FFFF ; $95 wend
>018613	8f 91					.word Command_UNTIL        & $FFFF ; $96 until
>018615	1d 8a					.word Command_NEXT         & $FFFF ; $97 next
>018617	a5 86					.word NotImplemented       & $FFFF ; $98 not
>018619	a5 86					.word NotImplemented       & $FFFF ; $99 fn(
>01861b	d9 95					.word Unary_Abs            & $FFFF ; $9a abs(
>01861d	34 97					.word Unary_Asc            & $FFFF ; $9b asc(
>01861f	55 a6					.word Unary_Int            & $FFFF ; $9c int(
>018621	f3 95					.word Unary_Peek           & $FFFF ; $9d peek(
>018623	d6 a5					.word Unary_Rnd            & $FFFF ; $9e rnd(
>018625	66 96					.word Unary_Usr            & $FFFF ; $9f usr(
>018627	73 97					.word Unary_Left           & $FFFF ; $a0 left$(
>018629	88 97					.word Unary_Right          & $FFFF ; $a1 right$(
>01862b	5a 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>01862d	d3 98					.word Unary_Spc            & $FFFF ; $a3 spc(
>01862f	02 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018631	87 96					.word Unary_Val            & $FFFF ; $a5 val(
>018633	4b 97					.word Unary_Len            & $FFFF ; $a6 len(
>018635	00 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018637	a5 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018639	a5 86					.word NotImplemented       & $FFFF ; $a9 cos(
>01863b	a5 86					.word NotImplemented       & $FFFF ; $aa tan(
>01863d	a5 86					.word NotImplemented       & $FFFF ; $ab atn(
>01863f	a5 86					.word NotImplemented       & $FFFF ; $ac exp(
>018641	a5 86					.word NotImplemented       & $FFFF ; $ad log(
>018643	a5 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018645	56 98					.word Unary_Dec            & $FFFF ; $af dec(
>018647	f7 95					.word Unary_Deek           & $FFFF ; $b0 deek(
>018649	fb 95					.word Unary_Leek           & $FFFF ; $b1 leek(
>01864b	33 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>01864d	93 95					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01864f	b5 98					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018651	27 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>018653	f6 98					.word Unary_Tab            & $FFFF ; $b6 tab(
>018655	a5 86					.word NotImplemented       & $FFFF ; $b7 $
>018657	a5 86					.word NotImplemented       & $FFFF ; $b8 $(
>018659	a5 86					.word NotImplemented       & $FFFF ; $b9 #
>01865b	a5 86					.word NotImplemented       & $FFFF ; $ba #(
>01865d	a5 86					.word NotImplemented       & $FFFF ; $bb %
>01865f	a5 86					.word NotImplemented       & $FFFF ; $bc %(
>018661	a5 86					.word NotImplemented       & $FFFF ; $bd (
>018663	a5 86					.word NotImplemented       & $FFFF ; $be )
>018665	a5 86					.word NotImplemented       & $FFFF ; $bf ,
>018667	9f 89					.word Command_COLON        & $FFFF ; $c0 :
>018669	a5 86					.word NotImplemented       & $FFFF ; $c1 ;
>01866b	a5 86					.word NotImplemented       & $FFFF ; $c2 def
>01866d	3f 91					.word Command_CLR          & $FFFF ; $c3 clr
>01866f	56 91					.word Command_STOP         & $FFFF ; $c4 stop
>018671	f6 8a					.word Command_DATA         & $FFFF ; $c5 data
>018673	d0 8a					.word Command_READ         & $FFFF ; $c6 read
>018675	49 88					.word Command_DIM          & $FFFF ; $c7 dim
>018677	a5 86					.word NotImplemented       & $FFFF ; $c8 to
>018679	a5 86					.word NotImplemented       & $FFFF ; $c9 step
>01867b	85 90					.word Command_GOSUB        & $FFFF ; $ca gosub
>01867d	95 90					.word Command_RETURN       & $FFFF ; $cb return
>01867f	7d 90					.word Command_GOTO         & $FFFF ; $cc goto
>018681	ec 8c					.word Command_END          & $FFFF ; $cd end
>018683	19 8c					.word Command_INPUT        & $FFFF ; $ce input
>018685	94 8b					.word Command_LET          & $FFFF ; $cf let
>018687	53 8d					.word Command_LIST         & $FFFF ; $d0 list
>018689	26 90					.word Command_NEW          & $FFFF ; $d1 new
>01868b	42 90					.word Command_OLD          & $FFFF ; $d2 old
>01868d	9e 90					.word Command_ON           & $FFFF ; $d3 on
>01868f	f9 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018691	f5 8f					.word Command_POKE         & $FFFF ; $d5 poke
>018693	47 8f					.word Command_PRINT        & $FFFF ; $d6 print
>018695	11 89					.word Command_RUN          & $FFFF ; $d7 run
>018697	d1 88					.word Command_WAIT         & $FFFF ; $d8 wait
>018699	ff 8b					.word Command_SYS          & $FFFF ; $d9 sys
>01869b	f9 8f					.word Command_DOKE         & $FFFF ; $da doke
>01869d	fd 8f					.word Command_LOKE         & $FFFF ; $db loke
>01869f	dd 8f					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a1	b5 8b					.word Command_GET          & $FFFF ; $dd get
>0186a3	47 8d					.word Command_ELSE         & $FFFF ; $de else
.0186a5					NotImplemented:
.0186a5	20 83 85	jsr $018583			jsr ERR_Handler
>0186a8	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b0	65 6d 65 6e 74 65 64 00
.0186b8					BinaryPrecedence:
>0186b8	01					.byte 1    ; $80 and
>0186b9	01					.byte 1    ; $81 or
>0186ba	01					.byte 1    ; $82 xor
>0186bb	01					.byte 1    ; $83 eor
>0186bc	02					.byte 2    ; $84 =
>0186bd	02					.byte 2    ; $85 <>
>0186be	02					.byte 2    ; $86 <
>0186bf	02					.byte 2    ; $87 <=
>0186c0	02					.byte 2    ; $88 >
>0186c1	02					.byte 2    ; $89 >=
>0186c2	03					.byte 3    ; $8a +
>0186c3	03					.byte 3    ; $8b -
>0186c4	04					.byte 4    ; $8c *
>0186c5	04					.byte 4    ; $8d /
>0186c6	05					.byte 5    ; $8e ^
.0186c7					KeywordText:
>0186c7	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186ca	4f d2					.byte $4f,$d2                          ; $81 or
>0186cc	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186cf	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186d2	bd					.byte $bd                              ; $84 =
>0186d3	3c be					.byte $3c,$be                          ; $85 <>
>0186d5	bc					.byte $bc                              ; $86 <
>0186d6	3c bd					.byte $3c,$bd                          ; $87 <=
>0186d8	be					.byte $be                              ; $88 >
>0186d9	3e bd					.byte $3e,$bd                          ; $89 >=
>0186db	ab					.byte $ab                              ; $8a +
>0186dc	ad					.byte $ad                              ; $8b -
>0186dd	aa					.byte $aa                              ; $8c *
>0186de	af					.byte $af                              ; $8d /
>0186df	de					.byte $de                              ; $8e ^
>0186e0	49 c6					.byte $49,$c6                          ; $8f if
>0186e2	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186e7	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186ed	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f0	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186f4	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186f9	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186fd	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018702	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>018706	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018709	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>01870c	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018710	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>018714	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018718	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>01871d	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018721	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>018725	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>01872b	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018732	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018737	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>01873b	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018740	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018744	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018748	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>01874d	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018751	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018755	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018759	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01875d	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018761	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018765	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018769	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01876d	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018772	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018777	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>01877b	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01877f	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018784	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018788	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>01878c	a4					.byte $a4                              ; $b7 $
>01878d	24 a8					.byte $24,$a8                          ; $b8 $(
>01878f	a3					.byte $a3                              ; $b9 #
>018790	23 a8					.byte $23,$a8                          ; $ba #(
>018792	a5					.byte $a5                              ; $bb %
>018793	25 a8					.byte $25,$a8                          ; $bc %(
>018795	a8					.byte $a8                              ; $bd (
>018796	a9					.byte $a9                              ; $be )
>018797	ac					.byte $ac                              ; $bf ,
>018798	ba					.byte $ba                              ; $c0 :
>018799	bb					.byte $bb                              ; $c1 ;
>01879a	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>01879d	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a0	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187a4	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187a8	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187ac	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187af	54 cf					.byte $54,$cf                          ; $c8 to
>0187b1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187b5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187ba	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187c4	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187c7	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187cc	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187cf	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187d3	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187d6	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187d9	4f ce					.byte $4f,$ce                          ; $d3 on
>0187db	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187e2	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187e6	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187eb	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187ee	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187f2	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187f5	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187f9	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187fd	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>018803	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>018806	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>01880a	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.01880b					BASIC_Start:
.01880b	20 a5 81	jsr $0181a5			jsr 	IF_Reset 					; set up and clear screen.
.01880e	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018811	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018813	8d 10 03	sta $0310			sta 	LocalVector
.018816	8d 0c 03	sta $030c			sta 	UserVector
.018819	a9 75		lda #$75			lda 	#USRDefault & $FF 			; reset USR vector
.01881b	8d 0d 03	sta $030d			sta 	UserVector+1
.01881e	a9 96		lda #$96			lda 	#(USRDefault >> 8) & $FF
.018820	8d 0e 03	sta $030e			sta 	UserVector+2
.018823	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018825	8d 0f 03	sta $030f			sta 	UserVector+3
.018828	20 3d 99	jsr $01993d			jsr 	UpdateProgramEnd 			; update the program end.
.01882b	20 3f 91	jsr $01913f			jsr 	ResetRunStatus 				; clear everything (CLR command)
.01882e	c2 30		rep #$30			rep 	#$30
.018830	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018833	1b		tcs				tcs
.018834	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018837	e2 30		sep #$30			sep 	#$30
.018839	4c 11 89	jmp $018911			jmp 	COMMAND_Run
.01883c					WarmStart:
.01883c	c2 30		rep #$30			rep 	#$30
.01883e	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018841	1b		tcs				tcs
.018842	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018845	e2 30		sep #$30			sep 	#$30
.018847	80 f3		bra $01883c			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018849					Command_DIM:
.018849	98		tya				tya
.01884a	48		pha				pha 								; push on stack.
.01884b	20 b2 9a	jsr $019ab2			jsr 	VariableExtract 			; get the identifier
.01884e	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018851	29 01		and #$01			and 	#1
.018853	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018855	d0 6c		bne $0188c3			bne 	_CDIError
.018857	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018859	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.01885c					_CDIGetDimension:
.01885c	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01885f	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018861	f0 60		beq $0188c3			beq 	_CDIError
.018863	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; evaluate an index size
.018866	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018868	29 80		and #$80			and 	#$80
.01886a	05 82		ora $82				ora 	XS_Mantissa+2
.01886c	05 83		ora $83				ora 	XS_Mantissa+3
.01886e	d0 53		bne $0188c3			bne 	_CDIError
.018870	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018873	18		clc				clc 								; add 1 - max index => size.
.018874	a5 80		lda $80				lda 	XS_Mantissa+0
.018876	69 01		adc #$01			adc 	#1
.018878	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.01887b	a5 81		lda $81				lda 	XS_Mantissa+1
.01887d	69 00		adc #$00			adc 	#0
.01887f	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018882	30 3f		bmi $0188c3			bmi 	_CDIError 					; could be dim a(32767)
.018884	e8		inx				inx 								; bump index.
.018885	e8		inx				inx
.018886	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.018889	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01888b	c8		iny				iny
.01888c	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.01888e	f0 cc		beq $01885c			beq 	_CDIGetDimension
.018890	88		dey				dey
.018891	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; closing ) present ?
.018894	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.018897	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018899	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.01889c					_CDICopy:
.01889c	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.01889f	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188a2	ca		dex				dex
.0188a3	10 f7		bpl $01889c			bpl 	_CDICopy
.0188a5	68		pla				pla									; position of array identifier
.0188a6	85 10		sta $10				sta 	zTemp1
.0188a8	98		tya				tya
.0188a9	48		pha				pha
.0188aa	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188ac	a8		tay				tay
.0188ad	20 b2 9a	jsr $019ab2			jsr 	VariableExtract 			; get the identifier
.0188b0	20 4b 9d	jsr $019d4b			jsr 	VariableLocate 				; check if it exists already.
.0188b3	b0 0e		bcs $0188c3			bcs 	_CDIError
.0188b5	20 3e 9b	jsr $019b3e			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188b8	68		pla				pla 								; restore code position
.0188b9	a8		tay				tay
.0188ba	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188bc	c8		iny				iny
.0188bd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188bf	f0 88		beq $018849			beq 	Command_DIM
.0188c1	88		dey				dey
.0188c2	60		rts				rts
.0188c3					_CDIError:
.0188c3	20 83 85	jsr $018583			jsr ERR_Handler
>0188c6	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188ce					_CDISyntax:
.0188ce	4c 54 85	jmp $018554			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188d1					Command_WAIT:
.0188d1	20 43 93	jsr $019343			jsr		EvaluateInteger 			; get address to monitor
.0188d4	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.0188d6	20 a1 99	jsr $0199a1			jsr 	CheckNextComma
.0188d9	20 45 93	jsr $019345			jsr 	EvaluateIntegerX
.0188dc	a9 00		lda #$00			lda 	#0							; set default xor value.
.0188de	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188e0	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188e2	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188e4	d0 06		bne $0188ec			bne 	_CWAXorDefault
.0188e6	c8		iny				iny
.0188e7	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.0188e9	20 45 93	jsr $019345			jsr 	EvaluateIntegerX
.0188ec					_CWAXorDefault:
.0188ec	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188ee	85 1a		sta $1a				sta 	zLTemp1
.0188f0	a5 81		lda $81				lda 	XS_Mantissa+1
.0188f2	85 1b		sta $1b				sta 	zLTemp1+1
.0188f4	a5 82		lda $82				lda 	XS_Mantissa+2
.0188f6	85 1c		sta $1c				sta 	zLTemp1+2
.0188f8					_CWAWaitLoop:
.0188f8	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; exit on break.
.0188fb	c9 00		cmp #$00			cmp 	#0
.0188fd	d0 11		bne $018910			bne 	_CWAWaitExit
.0188ff	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.018901	a2 00		ldx #$00			ldx 	#0
.018903	5a		phy				phy 								; this is the same routine as PEEK.
.018904	20 1b 99	jsr $01991b			jsr 	MemRead
.018907	7a		ply				ply
.018908	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.01890a	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.01890c	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.01890e	f0 e8		beq $0188f8			beq 	_CWAWaitLoop 				; and loop if zero.
.018910					_CWAWaitExit:
.018910	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018911					Command_RUN:
.018911	20 3f 91	jsr $01913f			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018914	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018916	85 16		sta $16				sta 	zCodePtr+0
.018918	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01891a	85 17		sta $17				sta 	zCodePtr+1
.01891c	a9 00		lda #$00			lda 	#0
.01891e	85 18		sta $18				sta 	zCodePtr+2
.018920	85 19		sta $19				sta 	zCodePtr+3
.018922	a0 03		ldy #$03			ldy 	#3
.018924					RUN_NewLine:
.018924	a0 00		ldy #$00			ldy 	#0
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018928	c8		iny				iny
.018929	c8		iny				iny
.01892a	c8		iny				iny
.01892b	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.01892d	d0 16		bne $018945			bne 	RUN_NextCommand
.01892f	4c ec 8c	jmp $018cec			jmp 	Command_END 				; go do the command code.
.018932					RUN_Skip:
.018932	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018934	c8		iny				iny 								; skip
.018935	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018937	90 0c		bcc $018945			bcc 	_SEDone 					; so just skip over it.
.018939	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01893b	90 07		bcc $018944			bcc 	_SEDouble
.01893d	98		tya				tya 								; this is Y + 1
.01893e	18		clc				clc
.01893f	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018941	a8		tay				tay 								; back in Y.
.018942	88		dey				dey 								; fix up, one for the +1, one for the iny
.018943	88		dey				dey
.018944					_SEDouble:
.018944	c8		iny				iny
.018945					_SEDone:
.018945					RUN_NextCommand:
.018945	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018948	69 10		adc #$10			adc 	#16 						; one time in 16
.01894a	8d a8 03	sta $03a8			sta 	BreakCount
.01894d	90 0a		bcc $018959			bcc 	RUN_NoCheckBreak
.01894f	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; check for break
.018952	c9 00		cmp #$00			cmp 	#0
.018954	f0 03		beq $018959			beq 	RUN_NoCheckBreak
.018956	4c 56 91	jmp $019156			jmp 	Command_STOP 				; stop on BREAK.
.018959					RUN_NoCheckBreak:
.018959	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01895b	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.01895d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01895f	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018961	f0 cf		beq $018932			beq 	RUN_Skip
.018963	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018965	d0 0f		bne $018976			bne 	RUN_Execute
.018967					RUN_NextLine:
.018967	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018969	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01896b	18		clc				clc
.01896c	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01896e	85 16		sta $16				sta 	zCodePtr
.018970	90 02		bcc $018974			bcc 	_SNLNoCarry
.018972	e6 17		inc $17				inc 	zCodePtr+1
.018974					_SNLNoCarry:
.018974	80 ae		bra $018924			bra 	RUN_NewLine 				; go do the new line code
.018976					RUN_Execute:
.018976	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018978	b0 1e		bcs $018998			bcs 	RUN_Extension
.01897a	c8		iny				iny
.01897b	0a		asl a				asl 	a 							; double the character read.
.01897c	90 14		bcc $018992			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.01897e	aa		tax				tax 								; ready to look up.
.01897f	bf e7 85 01	lda $0185e7,x			lda 	VectorTable,x 				; copy address into LocalVector
.018983	8d 11 03	sta $0311			sta 	LocalVector+1
.018986	bf e8 85 01	lda $0185e8,x			lda 	VectorTable+1,x
.01898a	8d 12 03	sta $0312			sta 	LocalVector+2
.01898d	20 90 92	jsr $019290			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018990	80 b3		bra $018945			bra 	RUN_NextCommand 			; do the next command.
.018992					RUN_Default:
.018992	88		dey				dey
.018993	20 94 8b	jsr $018b94			jsr 	Command_LET 				; and try LET.
.018996	80 ad		bra $018945			bra 	RUN_NextCommand
.018998					RUN_Extension:
.018998	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01899a	f0 96		beq $018932			beq 	RUN_Skip 					; skip over it.
.01899c	4c 54 85	jmp $018554			jmp 	SyntaxError
.01899f					Command_COLON:
.01899f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189a0					Command_FOR:
.0189a0	20 94 8b	jsr $018b94			jsr 	Command_LET 				; do the A = 99 bit
.0189a3	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.0189a5	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189a7	f0 71		beq $018a1a			beq 	_CFOError
.0189a9	48		pha				pha 								; save the variable type.
.0189aa	5a		phy				phy 								; save type/variable address.
.0189ab	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189ad	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189af	c8		iny				iny
.0189b0	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.0189b2	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189b4	c8		iny				iny
.0189b5	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.0189b7	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189b9	7a		ply				ply
.0189ba	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189bc	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189bf	a9 c8		lda #$c8			lda 	#token_TO
.0189c1	20 82 99	jsr $019982			jsr 	CheckNextToken
.0189c4	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189c6	20 ad 91	jsr $0191ad			jsr 	EvaluateExpression
.0189c9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189cb	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189cd	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189cf	d0 06		bne $0189d7			bne 	_CFOStep1
.0189d1	c8		iny				iny
.0189d2	20 af 91	jsr $0191af			jsr 	EvaluateExpressionX 		; get STEP value.
.0189d5	80 0e		bra $0189e5			bra 	_CFOHaveStep
.0189d7					_CFOStep1:
.0189d7	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189d9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189db	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189dd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189df	a9 01		lda #$01			lda 	#1
.0189e1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189e3	95 85		sta $85,x			sta 	XS_Type,x
.0189e5					_CFOHaveStep:
.0189e5	68		pla				pla 								; restore variable type
.0189e6	a2 00		ldx #$00			ldx 	#0
.0189e8	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189ea	f0 0a		beq $0189f6			beq 	_CFOInteger
.0189ec	20 56 a3	jsr $01a356			jsr 	FPUToFloat
.0189ef	a2 06		ldx #$06			ldx 	#6
.0189f1	20 56 a3	jsr $01a356			jsr 	FPUToFloat
.0189f4	80 08		bra $0189fe			bra 	_CFOEndConv
.0189f6					_CFOInteger:
.0189f6	20 a2 a3	jsr $01a3a2			jsr 	FPUToInteger
.0189f9	a2 06		ldx #$06			ldx 	#6
.0189fb	20 a2 a3	jsr $01a3a2			jsr 	FPUToInteger
.0189fe					_CFOEndConv:
.0189fe	20 03 85	jsr $018503			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a01	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a03	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push the loop address frame.
.018a06	5a		phy				phy
.018a07	a0 00		ldy #$00			ldy 	#0
.018a09					_CFOCopy:
.018a09	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a0c	c8		iny				iny
.018a0d	91 26		sta ($26),y			sta 	(zBasicSP),y
.018a0f	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a11	d0 f6		bne $018a09			bne 	_CFOCopy
.018a13	7a		ply				ply
.018a14	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a16	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018a19	60		rts				rts
.018a1a					_CFOError:
.018a1a	4c 64 85	jmp $018564			jmp 	TypeError 					; wrong type.
.018a1d					Command_NEXT:
.018a1d	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a1f	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.018a21	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a23	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a25	f0 07		beq $018a2e			beq 	_CNextNoVariable
.018a27	c9 40		cmp #$40			cmp 	#$40
.018a29	b0 03		bcs $018a2e			bcs 	_CNextNoVariable
.018a2b	20 47 9a	jsr $019a47			jsr 	VariableFind
.018a2e					_CNextNoVariable:
.018a2e	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.018a30	48		pha				pha
.018a31	a5 27		lda $27				lda 	zBasicSP+1
.018a33	48		pha				pha
.018a34	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a36	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a39	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a3b	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a3e	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a40	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a43	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a45	f0 11		beq $018a58			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a47	5a		phy				phy 								; check addresses match.
.018a48	a0 02		ldy #$02			ldy 	#2
.018a4a	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a4c	c5 22		cmp $22				cmp 	zVarDataPtr
.018a4e	d0 69		bne $018ab9			bne 	_CNextWrong
.018a50	c8		iny				iny
.018a51	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a53	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a55	d0 62		bne $018ab9			bne 	_CNextWrong
.018a57	7a		ply				ply
.018a58					_CNextGetTarget:
.018a58	5a		phy				phy
.018a59	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a5b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a5d	85 24		sta $24				sta 	zVarType
.018a5f	c8		iny				iny
.018a60	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a62	85 22		sta $22				sta 	zVarDataPtr
.018a64	c8		iny				iny
.018a65	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a67	85 23		sta $23				sta 	zVarDataPtr+1
.018a69	a2 0c		ldx #$0c			ldx 	#12
.018a6b	20 8f 9d	jsr $019d8f			jsr 	VariableGet 				; get that variable value into expr[2]
.018a6e	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a70	a0 0b		ldy #$0b			ldy 	#11
.018a72					_CNXCopy:
.018a72	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a74	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a76	e8		inx				inx
.018a77	c8		iny				iny
.018a78	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a7a	d0 f6		bne $018a72			bne 	_CNXCopy
.018a7c	7a		ply				ply
.018a7d	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a7f	20 b7 95	jsr $0195b7			jsr 	GetSignCurrent
.018a82	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a85	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a87	20 96 94	jsr $019496			jsr 	BinaryOp_Add
.018a8a	20 e0 9d	jsr $019de0			jsr 	VariableSet					; and write variable back.
.018a8d	a2 00		ldx #$00			ldx 	#0
.018a8f	20 1a 94	jsr $01941a			jsr 	CompareValues
.018a92	09 00		ora #$00			ora 	#0
.018a94	f0 05		beq $018a9b			beq 	_CNXAgain 					; if true, then do it again.
.018a96	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a99	d0 0f		bne $018aaa			bne 	_CNXLoopDone
.018a9b					_CNXAgain:
.018a9b	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a9d	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018aa0	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018aa3	68		pla				pla
.018aa4	85 27		sta $27				sta 	zBasicSP+1
.018aa6	68		pla				pla
.018aa7	85 26		sta $26				sta 	zBasicSP
.018aa9					_CNXExit:
.018aa9	60		rts				rts
.018aaa					_CNXLoopDone:
.018aaa	68		pla				pla
.018aab	68		pla				pla
.018aac	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aae	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018ab0	d0 f7		bne $018aa9			bne 	_CNXExit
.018ab2	c8		iny				iny
.018ab3	20 47 9a	jsr $019a47			jsr 	VariableFind 				; identify the variable
.018ab6	4c 2e 8a	jmp $018a2e			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018ab9					_CNextWrong:
.018ab9	20 83 85	jsr $018583			jsr ERR_Handler
>018abc	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ac4	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ad0					Command_READ:
.018ad0	20 47 9a	jsr $019a47			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ad3	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018ad5	48		pha				pha
.018ad6	a5 23		lda $23				lda 	zVarDataPtr+1
.018ad8	48		pha				pha
.018ad9	a5 24		lda $24				lda 	zVarType
.018adb	48		pha				pha
.018adc	20 22 8b	jsr $018b22			jsr 	READGetDataItem 			; get the next data item
.018adf	68		pla				pla 								; restore target variable information.
.018ae0	85 24		sta $24				sta 	zVarType
.018ae2	68		pla				pla
.018ae3	85 23		sta $23				sta 	zVarDataPtr+1
.018ae5	68		pla				pla
.018ae6	85 22		sta $22				sta 	zVarDataPtr
.018ae8	a2 00		ldx #$00			ldx 	#0
.018aea	20 e0 9d	jsr $019de0			jsr 	VariableSet 				; set the value out.
.018aed	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018aef	c8		iny				iny
.018af0	c9 bf		cmp #$bf			cmp 	#token_Comma
.018af2	f0 dc		beq $018ad0			beq 	Command_READ 				; found, do another READ
.018af4	88		dey				dey
.018af5	60		rts				rts
.018af6					Command_DATA:
.018af6	4c 8a 84	jmp $01848a			jmp 	SkipEndOfCommand
.018af9					Command_RESTORE:
.018af9	48		pha				pha
.018afa	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018afc	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018aff	8d be 03	sta $03be			sta 	DataLPtr+1
.018b02	68		pla				pla
.018b03	60		rts				rts
.018b04					READSwapPointers:
.018b04	98		tya				tya
.018b05	48		pha				pha 								; save it
.018b06	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b09	a8		tay				tay
.018b0a	68		pla				pla 								; get code offset and save in DataIndex
.018b0b	8d c1 03	sta $03c1			sta 	DataIndex
.018b0e	da		phx				phx
.018b0f	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b11					_RSWLoop:
.018b11	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b14	48		pha				pha
.018b15	b5 16		lda $16,x			lda 	zCodePtr+0,x
.018b17	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b1a	68		pla				pla
.018b1b	95 16		sta $16,x			sta 	zCodePtr+0,x
.018b1d	ca		dex				dex
.018b1e	10 f1		bpl $018b11			bpl 	_RSWLoop
.018b20	fa		plx				plx
.018b21	60		rts				rts
.018b22					READGetDataItem:
.018b22	20 04 8b	jsr $018b04			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b25	a5 16		lda $16				lda		zCodePtr+0 					; initialise ?
.018b27	05 17		ora $17				ora 	zCodePtr+1
.018b29	d0 12		bne $018b3d			bne 	_RGDIIsInitialised
.018b2b	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b2d	85 16		sta $16				sta 	zCodePtr+0
.018b2f	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b31	85 17		sta $17				sta 	zCodePtr+1
.018b33	a9 00		lda #$00			lda 	#0
.018b35	85 18		sta $18				sta 	zCodePtr+2
.018b37	85 19		sta $19				sta 	zCodePtr+3
.018b39	a0 03		ldy #$03			ldy 	#3
.018b3b	80 06		bra $018b43			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b3d					_RGDIIsInitialised:
.018b3d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b3f	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b41	f0 49		beq $018b8c			beq 	_RGDISkipEvaluateExit
.018b43					_RGDIFindData:
.018b43	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b45	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b47	f0 19		beq $018b62			beq 	_RGDIFindNextLine
.018b49	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b4b	f0 3f		beq $018b8c			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b4d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b4f	c8		iny				iny 								; skip
.018b50	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b52	90 0c		bcc $018b60			bcc 	_SEDone 					; so just skip over it.
.018b54	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b56	90 07		bcc $018b5f			bcc 	_SEDouble
.018b58	98		tya				tya 								; this is Y + 1
.018b59	18		clc				clc
.018b5a	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b5c	a8		tay				tay 								; back in Y.
.018b5d	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b5e	88		dey				dey
.018b5f					_SEDouble:
.018b5f	c8		iny				iny
.018b60					_SEDone:
.018b60	80 e1		bra $018b43			bra 	_RGDIFindData
.018b62					_RGDIFindNextLine:
.018b62	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b64	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b66	18		clc				clc
.018b67	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b69	85 16		sta $16				sta 	zCodePtr
.018b6b	90 02		bcc $018b6f			bcc 	_SNLNoCarry
.018b6d	e6 17		inc $17				inc 	zCodePtr+1
.018b6f					_SNLNoCarry:
.018b6f	a0 00		ldy #$00			ldy 	#0
.018b71	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b73	48		pha				pha
.018b74	c8		iny				iny
.018b75	c8		iny				iny
.018b76	c8		iny				iny
.018b77	68		pla				pla
.018b78	d0 c9		bne $018b43			bne 	_RGDIFindData 				; back to scanning.
.018b7a	20 04 8b	jsr $018b04			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b7d	20 83 85	jsr $018583			jsr ERR_Handler
>018b80	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b88	61 74 61 00
.018b8c					_RGDISkipEvaluateExit:
.018b8c	c8		iny				iny
.018b8d	20 ad 91	jsr $0191ad			jsr 	EvaluateExpression 			; evaluate the expression
.018b90	20 04 8b	jsr $018b04			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b93	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b94					Command_LET:
.018b94	20 47 9a	jsr $019a47			jsr 	VariableFind 				; get reference to one variable.
.018b97	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b99	20 82 99	jsr $019982			jsr 	CheckNextToken
.018b9c	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018b9e	48		pha				pha
.018b9f	a5 23		lda $23				lda 	zVarDataPtr+1
.018ba1	48		pha				pha
.018ba2	a5 24		lda $24				lda 	zVarType
.018ba4	48		pha				pha
.018ba5	20 ad 91	jsr $0191ad			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018ba8	68		pla				pla 								; restore target variable information.
.018ba9	85 24		sta $24				sta 	zVarType
.018bab	68		pla				pla
.018bac	85 23		sta $23				sta 	zVarDataPtr+1
.018bae	68		pla				pla
.018baf	85 22		sta $22				sta 	zVarDataPtr
.018bb1	20 e0 9d	jsr $019de0			jsr 	VariableSet 				; set the value out.
.018bb4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018bb5					Command_GET:
.018bb5					_CGLoop:
.018bb5	20 47 9a	jsr $019a47			jsr 	VariableFind 				; get a variable.
.018bb8	20 3f 85	jsr $01853f			jsr 	VIOCharGet 					; get character
.018bbb	b0 02		bcs $018bbf			bcs 	_CGNoKey
.018bbd	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bbf					_CGNoKey:
.018bbf	48		pha				pha
.018bc0	a5 24		lda $24				lda 	zVarType 					; look at the data type.
.018bc2	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bc4	f0 1e		beq $018be4			beq 	_CGString
.018bc6	68		pla				pla 								; put character in slot.
.018bc7	85 80		sta $80				sta 	XS_Mantissa
.018bc9	a9 00		lda #$00			lda 	#0
.018bcb	85 81		sta $81				sta 	XS_Mantissa+1
.018bcd	85 82		sta $82				sta 	XS_Mantissa+2
.018bcf	85 83		sta $83				sta 	XS_Mantissa+3
.018bd1	a9 01		lda #$01			lda 	#1 							; type integer
.018bd3	85 85		sta $85				sta 	XS_Type
.018bd5					_CGWriteSetNext:
.018bd5	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bd7	20 e0 9d	jsr $019de0			jsr 	VariableSet
.018bda	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bdc	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018bde	d0 03		bne $018be3			bne 	_CGExit
.018be0	c8		iny				iny
.018be1	80 d2		bra $018bb5			bra 	_CGLoop 					; and get another.
.018be3					_CGExit:
.018be3	60		rts				rts
.018be4					_CGString:
.018be4	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018be6	20 e6 99	jsr $0199e6			jsr 	AllocateTempString 			; initially empty.
.018be9	a5 20		lda $20				lda 	zTempStr 					; set up to be returned.
.018beb	85 80		sta $80				sta 	XS_Mantissa
.018bed	a5 21		lda $21				lda 	zTempStr+1
.018bef	85 81		sta $81				sta 	XS_Mantissa+1
.018bf1	a9 02		lda #$02			lda 	#2
.018bf3	85 85		sta $85				sta 	XS_Type
.018bf5	68		pla				pla 								; get A
.018bf6	c9 00		cmp #$00			cmp 	#0
.018bf8	f0 db		beq $018bd5			beq 	_CGWriteSetNext
.018bfa	20 11 9a	jsr $019a11			jsr 	WriteTempString 			; write it into string
.018bfd	80 d6		bra $018bd5			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018bff					Command_SYS:
.018bff	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; address to call.
.018c02	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c04	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c07	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c09	8d 11 03	sta $0311			sta 	LocalVector+1
.018c0c	a5 82		lda $82				lda 	XS_Mantissa+2
.018c0e	8d 12 03	sta $0312			sta 	LocalVector+2
.018c11	22 16 8c 01	jsl $018c16			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c15	60		rts				rts
.018c16					_CSYLocalCall:
.018c16	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c19					Command_INPUT:
.018c19	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c1b	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c1e	8d c3 03	sta $03c3		sta 	InputRetry
.018c21					_CILoop:
.018c21	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c23	85 21		sta $21			sta 	zTempStr+1 						; (could get lots of long strings)
.018c25	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c27	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c29	d0 15		bne $018c40		bne 	_CINoPrompt
.018c2b	c8		iny				iny
.018c2c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c2e	aa		tax			tax 									; into X
.018c2f	c8		iny				iny
.018c30	ca		dex			dex 									; deduct marker/prompt length
.018c31	ca		dex			dex
.018c32	f0 ed		beq $018c21		beq 	_CILoop 						; nothing.
.018c34					_CIShowPrompt:
.018c34	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c36	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018c39	c8		iny				iny
.018c3a	ca		dex			dex
.018c3b	d0 f7		bne $018c34		bne 	_CIShowPrompt
.018c3d	80 e2		bra $018c21		bra 	_CILoop
.018c3f					_CIAdvance:
.018c3f	c8		iny				iny
.018c40					_CINoPrompt:
.018c40	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c42	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c44	f0 f9		beq $018c3f		beq 	_CIAdvance
.018c46	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c48	f0 f5		beq $018c3f		beq 	_CIAdvance
.018c4a	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c4c	f0 04		beq $018c52		beq 	_CIExit
.018c4e	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c50	d0 01		bne $018c53		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c52					_CIExit:
.018c52	60		rts			rts
.018c53					_CIIsVariable:
.018c53	20 47 9a	jsr $019a47		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c56	a5 24		lda $24			lda 	zVarType
.018c58	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018c5a	f0 40		beq $018c9c		beq 	_CIIsString
.018c5c					_CINGetText:
.018c5c	a9 00		lda #$00		lda 	#0
.018c5e	8d 14 03	sta $0314		sta 	NumBufX
.018c61					_CINSkip:
.018c61	20 9d 8c	jsr $018c9d		jsr 	CIGetCharacter 					; get character skip spaces
.018c64	c9 20		cmp #$20		cmp 	#" "
.018c66	f0 f9		beq $018c61		beq 	_CINSkip
.018c68	c9 2c		cmp #$2c		cmp 	#","
.018c6a	f0 f5		beq $018c61		beq 	_CINSkip
.018c6c					_CINLoop:
.018c6c	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018c6f	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018c72	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018c74	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018c77	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018c7a	20 9d 8c	jsr $018c9d		jsr 	CIGetCharacter 					; get next character
.018c7d	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018c7f	f0 08		beq $018c89		beq 	_CINCopied
.018c81	c9 2c		cmp #$2c		cmp 	#","
.018c83	f0 04		beq $018c89		beq 	_CINCopied
.018c85	c9 21		cmp #$21		cmp 	#" "+1
.018c87	b0 e3		bcs $018c6c		bcs 	_CINLoop
.018c89					_CINCopied:
.018c89	a2 00		ldx #$00		ldx 	#0
.018c8b	20 c6 96	jsr $0196c6		jsr 	ConvertNumBuffer 				; convert number
.018c8e	b0 05		bcs $018c95		bcs 	_CINFailed 						; didn't work.
.018c90	20 e0 9d	jsr $019de0		jsr 	VariableSet 					; set variable.
.018c93	80 8c		bra $018c21		bra 	_CILoop 						; go round again.
.018c95					_CINFailed:
.018c95	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018c97	8d c2 03	sta $03c2		sta 	InputAvailable
.018c9a	80 c0		bra $018c5c		bra 	_CINGetText 					; and try again
.018c9c					_CIIsString:
.018c9c	ea		nop			nop
.018c9d					CIGetCharacter:
.018c9d	5a		phy			phy
.018c9e	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018ca1	f0 0c		beq $018caf		beq 	_CIGCNewLine 					; no, needs a new line.
.018ca3	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018ca6	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018ca8	f0 03		beq $018cad		beq 	_CIGCNoInc
.018caa	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018cad					_CIGCNoInc:
.018cad	7a		ply			ply
.018cae	60		rts			rts
.018caf					_CIGCNewLine:
.018caf	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018cb2	a9 3f		lda #$3f		lda 	#"?"
.018cb4	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018cb7	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018cba	f0 03		beq $018cbf		beq 	_CIGCPrompt 					; if so, then print ? again
.018cbc	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018cbf					_CIGCPrompt:
.018cbf	a0 01		ldy #$01		ldy 	#1
.018cc1	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018cc4					_CIGCBackOne:
.018cc4	88		dey			dey
.018cc5					_CIGCLoop:
.018cc5	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018cc7	f0 fb		beq $018cc4		beq 	_CIGCBackOne
.018cc9	20 3f 85	jsr $01853f		jsr 	VIOCharGet 						; get a character
.018ccc	f0 f7		beq $018cc5		beq 	_CIGCLoop 						; wait until key pressed
.018cce	c9 08		cmp #$08		cmp 	#8 								; backspace
.018cd0	f0 10		beq $018ce2		beq 	_CIGCBackSpace
.018cd2	20 3c 85	jsr $01853c		jsr 	VIOCharPrint 					; echo character
.018cd5	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018cd8	c8		iny			iny
.018cd9	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018cdb	d0 e8		bne $018cc5		bne 	_CIGCLoop
.018cdd	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018ce0	7a		ply			ply 									; restore Y
.018ce1	60		rts			rts
.018ce2					_CIGCBackSpace:
.018ce2	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018ce4	f0 df		beq $018cc5		beq 	_CIGCLoop
.018ce6	20 3c 85	jsr $01853c		jsr 	VIOCharPrint 					; echo BS
.018ce9	88		dey			dey 									; go back one.
.018cea	80 d9		bra $018cc5		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018cec					Command_END:
>018cec	02						.byte 	2
.018ced	4c 3c 88	jmp $01883c			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018cf0					Command_IF:
.018cf0	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; check success.
.018cf3	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018cf5	05 81		ora $81				ora 	XS_Mantissa+1
.018cf7	05 82		ora $82				ora 	XS_Mantissa+2
.018cf9	05 83		ora $83				ora 	XS_Mantissa+3
.018cfb	aa		tax				tax 								; put into X.
.018cfc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cfe	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018d00	d0 2c		bne $018d2e			bne 	_FIFExtended
.018d02	c8		iny				iny
.018d03	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018d05	f0 0b		beq $018d12			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018d07	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d09	29 c0		and #$c0			and 	#$C0 						; is it a number
.018d0b	c9 40		cmp #$40			cmp 	#$40
.018d0d	d0 1e		bne $018d2d			bne 	_FIFContinue 				; if not, do what ever follows.
.018d0f	4c 7d 90	jmp $01907d			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018d12					_FIFEndOfLine:
.018d12	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d14	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018d16	f0 15		beq $018d2d			beq 	_FIFContinue
.018d18	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018d1a	c8		iny				iny 								; skip
.018d1b	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018d1d	90 0c		bcc $018d2b			bcc 	_SEDone 					; so just skip over it.
.018d1f	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018d21	90 07		bcc $018d2a			bcc 	_SEDouble
.018d23	98		tya				tya 								; this is Y + 1
.018d24	18		clc				clc
.018d25	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018d27	a8		tay				tay 								; back in Y.
.018d28	88		dey				dey 								; fix up, one for the +1, one for the iny
.018d29	88		dey				dey
.018d2a					_SEDouble:
.018d2a	c8		iny				iny
.018d2b					_SEDone:
.018d2b	80 e5		bra $018d12			bra 	_FIFEndOfLine
.018d2d					_FIFContinue:
.018d2d	60		rts				rts
.018d2e					_FIFExtended:
.018d2e	da		phx				phx 								; save result
.018d2f	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018d31	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018d34	68		pla				pla 								; restore result
.018d35	f0 01		beq $018d38			beq 	_FIXSkip 					; if zero then it has failed.
.018d37	60		rts				rts 								; test passed, so continue executing
.018d38					_FIXSkip:
.018d38	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018d3a	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018d3c	20 ff 83	jsr $0183ff			jsr 	StructureSearchDouble
.018d3f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d41	c8		iny				iny
.018d42	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018d44	f0 07		beq $018d4d			beq 	Command_ENDIF
.018d46	60		rts				rts
.018d47					Command_ELSE:
.018d47	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018d49	20 fd 83	jsr $0183fd			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018d4c	c8		iny				iny
.018d4d					Command_ENDIF:
.018d4d	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018d4f	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018d52	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018d53					Command_LIST:
.018d53	20 e0 8e	jsr $018ee0			jsr 	ListGetRange				; get any parameters
.018d56	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018d58	85 16		sta $16				sta 	zCodePtr+0
.018d5a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018d5c	85 17		sta $17				sta 	zCodePtr+1
.018d5e	a9 00		lda #$00			lda 	#0
.018d60	85 18		sta $18				sta 	zCodePtr+2
.018d62	85 19		sta $19				sta 	zCodePtr+3
.018d64	a0 03		ldy #$03			ldy 	#3
.018d66	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018d68	8d bc 03	sta $03bc			sta 	LastListIndent
.018d6b	8d bb 03	sta $03bb			sta 	ListIndent
.018d6e					_CILLoop:
.018d6e	a0 00		ldy #$00			ldy 	#0
.018d70	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d72	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018d74	f0 23		beq $018d99			beq 	_CILExit
.018d76	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; check break
.018d79	c9 00		cmp #$00			cmp 	#0
.018d7b	d0 1c		bne $018d99			bne 	_CILExit
.018d7d	20 27 8f	jsr $018f27			jsr 	ListCheckRange 				; check current line in range.
.018d80	b0 08		bcs $018d8a			bcs		_CILNext
.018d82	a0 00		ldy #$00			ldy 	#0
.018d84	c8		iny				iny
.018d85	c8		iny				iny
.018d86	c8		iny				iny
.018d87	20 9c 8d	jsr $018d9c			jsr 	ListLine 					; list one line.
.018d8a					_CILNext:
.018d8a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018d8c	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018d8e	18		clc				clc
.018d8f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018d91	85 16		sta $16				sta 	zCodePtr
.018d93	90 02		bcc $018d97			bcc 	_SNLNoCarry
.018d95	e6 17		inc $17				inc 	zCodePtr+1
.018d97					_SNLNoCarry:
.018d97	80 d5		bra $018d6e			bra 	_CILLoop
.018d99					_CILExit:
.018d99	4c 3c 88	jmp $01883c			jmp 	WarmStart
.018d9c					ListLine:
.018d9c	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018d9f	8d bc 03	sta $03bc			sta 	LastListIndent
.018da2					_LICountIndent:
.018da2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018da4	c9 00		cmp #$00			cmp 	#0
.018da6	f0 2f		beq $018dd7			beq 	_LIDoneIndent
.018da8	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018daa	90 16		bcc $018dc2			bcc 	_LICINext
.018dac	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018dae	b0 12		bcs $018dc2			bcs 	_LICINext
.018db0	ee bb 03	inc $03bb			inc 	ListIndent
.018db3	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018db5	90 0b		bcc $018dc2			bcc 	_LICINext
.018db7	ce bb 03	dec $03bb			dec 	ListIndent
.018dba	ce bb 03	dec $03bb			dec 	ListIndent
.018dbd	10 03		bpl $018dc2			bpl 	_LICINext
.018dbf	ee bb 03	inc $03bb			inc 	ListIndent
.018dc2					_LICINext:
.018dc2	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018dc4	c8		iny				iny 								; skip
.018dc5	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018dc7	90 0c		bcc $018dd5			bcc 	_SEDone 					; so just skip over it.
.018dc9	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018dcb	90 07		bcc $018dd4			bcc 	_SEDouble
.018dcd	98		tya				tya 								; this is Y + 1
.018dce	18		clc				clc
.018dcf	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018dd1	a8		tay				tay 								; back in Y.
.018dd2	88		dey				dey 								; fix up, one for the +1, one for the iny
.018dd3	88		dey				dey
.018dd4					_SEDouble:
.018dd4	c8		iny				iny
.018dd5					_SEDone:
.018dd5	80 cb		bra $018da2			bra 	_LICountIndent
.018dd7					_LIDoneIndent:
.018dd7	a0 00		ldy #$00			ldy 	#0
.018dd9	c8		iny				iny
.018dda	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ddc	85 80		sta $80				sta 	XS_Mantissa
.018dde	c8		iny				iny
.018ddf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018de1	85 81		sta $81				sta 	XS_Mantissa+1
.018de3	20 c9 85	jsr $0185c9			jsr 	Print16BitInteger 			; print integer.
.018de6	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018de8	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018deb	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018dee	90 03		bcc $018df3			bcc 	_LISmaller
.018df0	ad bc 03	lda $03bc			lda 	LastListIndent
.018df3					_LISmaller:
.018df3	0a		asl a				asl 	a 							; double indent
.018df4	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018df6	38		sec				sec
.018df7	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018df9	aa		tax				tax 								; print spaces to column 6
.018dfa					_LISpace:
.018dfa	a9 20		lda #$20			lda 	#" "
.018dfc	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018dff	e8		inx				inx
.018e00	e0 06		cpx #$06			cpx 	#6
.018e02	d0 f6		bne $018dfa			bne 	_LISpace
.018e04					_LIDecode:
.018e04	c8		iny				iny
.018e05	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e07	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018e09	f0 0f		beq $018e1a			beq 	_LIExit
.018e0b	30 12		bmi $018e1f			bmi 	_LIToken
.018e0d	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018e0f	b0 50		bcs $018e61			bcs 	_LIInteger
.018e11	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018e13	69 20		adc #$20			adc 	#$20
.018e15	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC 				; print in LC
.018e18	80 ea		bra $018e04			bra 	_LIDecode
.018e1a					_LIExit:
.018e1a	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018e1c	4c d0 8e	jmp $018ed0			jmp 	ListPrintLC
.018e1f					_LIToken:
.018e1f	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018e21	90 49		bcc $018e6c			bcc		_LICommandToken
.018e23	48		pha				pha 								; save in case end
.018e24	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018e26	c9 fe		cmp #$fe			cmp 	#$FE
.018e28	f0 17		beq $018e41			beq 	_LIPrint
.018e2a	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018e2c	c9 fd		cmp #$fd			cmp 	#$FD
.018e2e	f0 11		beq $018e41			beq 	_LIPrint
.018e30	a9 52		lda #$52			lda 	#'R'						; must be REM
.018e32	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018e35	a9 45		lda #$45			lda 	#'E'
.018e37	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018e3a	a9 4d		lda #$4d			lda 	#'M'
.018e3c	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018e3f	a2 20		ldx #$20			ldx 	#' '
.018e41					_LIPrint:
.018e41	8a		txa				txa
.018e42	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018e45	c8		iny				iny
.018e46	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e48	aa		tax				tax 								; put in X
.018e49	ca		dex				dex
.018e4a					_LILoop:
.018e4a	ca		dex				dex 								; exit when count reached zero.
.018e4b	f0 08		beq $018e55			beq 	_LIEnd
.018e4d	c8		iny				iny
.018e4e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e50	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018e53	80 f5		bra $018e4a			bra 	_LILoop
.018e55	68		pla		_LIEnd:	pla 								; get A back
.018e56	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018e58	d0 aa		bne $018e04			bne 	_LIDecode
.018e5a	a9 22		lda #$22			lda 	#'"'
.018e5c	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018e5f	80 a3		bra $018e04			bra 	_LIDecode
.018e61					_LIInteger:
.018e61	a2 00		ldx #$00			ldx 	#0
.018e63	20 b5 92	jsr $0192b5			jsr 	EvaluateGetInteger 			; get an atom
.018e66	88		dey				dey
.018e67	20 cf 85	jsr $0185cf			jsr 	Print32BitInteger 			; print integer.
.018e6a	80 98		bra $018e04			bra 	_LIDecode
.018e6c					_LICommandToken:
.018e6c	5a		phy				phy 								; save Y
.018e6d	48		pha				pha 								; save token
.018e6e	a2 c7		ldx #$c7			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018e70	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018e72	86 1a		stx $1a				stx 	zLTemp1
.018e74	85 1b		sta $1b				sta 	zLTemp1+1
.018e76	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018e78	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018e7a	68		pla				pla 								; get token
.018e7b	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018e7d	f0 16		beq $018e95			beq 	_LIFoundToken
.018e7f	aa		tax				tax
.018e80					_LITokenLoop:
.018e80	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018e82					_LIFindEnd:
.018e82	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018e84	c8		iny				iny
.018e85	0a		asl a				asl 	a
.018e86	90 fa		bcc $018e82			bcc 	_LIFindEnd
.018e88	98		tya				tya 								; that is step to the next
.018e89	18		clc				clc 								; we don't bother bumping the 3rd byte
.018e8a	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018e8c	85 1a		sta $1a				sta 	zLTemp1
.018e8e	90 02		bcc $018e92			bcc 	_LINoBump
.018e90	e6 1b		inc $1b				inc 	zLTemp1+1
.018e92					_LINoBump:
.018e92	ca		dex				dex 								; no go round again.
.018e93	d0 eb		bne $018e80			bne 	_LITokenLoop
.018e95					_LIFoundToken:
.018e95	a0 00		ldy #$00			ldy 	#0
.018e97					_LIPrintToken:
.018e97	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018e99	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018e9b	d0 16		bne $018eb3			bne 	_LINoPrefixSpace
.018e9d	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018e9f	90 12		bcc $018eb3			bcc 	_LINoPrefixSpace
.018ea1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018ea3	b0 0e		bcs $018eb3			bcs 	_LINoPrefixSpace
.018ea5	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018ea8	e0 20		cpx #$20			cpx 	#" "
.018eaa	f0 07		beq $018eb3			beq 	_LINoPrefixSpace
.018eac	48		pha				pha
.018ead	a9 20		lda #$20			lda 	#" "
.018eaf	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018eb2	68		pla				pla
.018eb3					_LINoPrefixSpace:
.018eb3	c8		iny				iny
.018eb4	48		pha				pha 								; save it
.018eb5	29 7f		and #$7f			and 	#$7F
.018eb7	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018eba	68		pla				pla
.018ebb	10 da		bpl $018e97			bpl 	_LIPrintToken 				; go back if not end
.018ebd	7a		ply				ply 								; restore Y
.018ebe	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018ec0	c9 41		cmp #$41			cmp 	#"A"
.018ec2	90 09		bcc $018ecd			bcc 	_LINotLetter2
.018ec4	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018ec6	b0 05		bcs $018ecd			bcs 	_LINotLetter2
.018ec8	a9 20		lda #$20			lda 	#" " 						; add spacing
.018eca	20 d0 8e	jsr $018ed0			jsr 	ListPrintLC
.018ecd					_LINotLetter2:
.018ecd	4c 04 8e	jmp $018e04			jmp 	_LIDecode
.018ed0					ListPrintLC:
.018ed0	8d ba 03	sta $03ba			sta 	LastPrinted
.018ed3	c9 41		cmp #$41			cmp 	#"A"
.018ed5	90 06		bcc $018edd			bcc 	_LPLC0
.018ed7	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018ed9	b0 02		bcs $018edd			bcs 	_LPLC0
.018edb	69 20		adc #$20			adc 	#$20
.018edd	4c 3c 85	jmp $01853c	_LPLC0:	jmp 	VIOCharPrint
.018ee0					ListGetRange:
.018ee0	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018ee2					_LGRClear:
.018ee2	a9 00		lda #$00			lda 	#0
.018ee4	95 80		sta $80,x			sta 	XS_Mantissa,x
.018ee6	ca		dex				dex
.018ee7	10 f9		bpl $018ee2			bpl 	_LGRClear
.018ee9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eeb	c9 00		cmp #$00			cmp 	#0 							; nothing
.018eed	f0 21		beq $018f10			beq 	_LGRBlank
.018eef	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018ef1	f0 1d		beq $018f10			beq 	_LGRBlank
.018ef3	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018ef5	f0 18		beq $018f0f			beq 	_LGREnd 					; then it's LIST ,x
.018ef7	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; get the first number into bottom
.018efa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018efc	c9 bf		cmp #$bf			cmp 	#token_Comma
.018efe	f0 0f		beq $018f0f			beq 	_LGREnd 					; then it is LIST a,b
.018f00	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018f02	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018f04	a5 81		lda $81				lda 	XS_Mantissa+1
.018f06	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018f08					_LGRBumpExit:
.018f08	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018f0a	d0 02		bne $018f0e			bne 	_LGRBump2
.018f0c	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018f0e					_LGRBump2:
.018f0e	60		rts				rts
.018f0f					_LGREnd:
.018f0f	c8		iny				iny
.018f10					_LGRBlank:
.018f10	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018f12	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018f14	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018f16	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f18	c9 00		cmp #$00			cmp 	#0
.018f1a	f0 f2		beq $018f0e			beq 	_LGRBump2
.018f1c	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018f1d	b0 ef		bcs $018f0e			bcs 	_LGRBump2
.018f1f	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018f21	20 45 93	jsr $019345			jsr 	EvaluateIntegerX
.018f24	80 e2		bra $018f08			bra 	_LGRBumpExit
.018f26	60		rts				rts
.018f27					ListCheckRange:
.018f27	c8		iny				iny
.018f28	a2 00		ldx #$00			ldx 	#0 							; test low
.018f2a	20 37 8f	jsr $018f37			jsr 	_LCRCompare
.018f2d	90 06		bcc $018f35			bcc 	_LCRFail
.018f2f	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018f31	20 37 8f	jsr $018f37			jsr 	_LCRCompare
.018f34	60		rts				rts
.018f35					_LCRFail:
.018f35	38		sec				sec
.018f36	60		rts				rts
.018f37					_LCRCompare:
.018f37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f39	38		sec				sec
.018f3a	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018f3c	08		php				php
.018f3d	c8		iny				iny
.018f3e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f40	28		plp				plp
.018f41	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018f43	08		php				php
.018f44	88		dey				dey
.018f45	28		plp				plp
.018f46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018f47					Command_PRINT:
.018f47					_CPR_Loop:
.018f47	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f49	c9 00		cmp #$00			cmp 	#0 							; end
.018f4b	f0 24		beq $018f71			beq 	_CPR_GoNewLine
.018f4d	c9 c0		cmp #$c0			cmp 	#token_Colon
.018f4f	f0 20		beq $018f71			beq 	_CPR_GoNewLine
.018f51	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018f53	f0 74		beq $018fc9			beq 	_CPR_Skip
.018f55	c9 bf		cmp #$bf			cmp 	#token_Comma
.018f57	f0 57		beq $018fb0			beq 	_CPR_Tab
.018f59	20 ad 91	jsr $0191ad			jsr 	EvaluateExpression 			; get expression.
.018f5c	a5 85		lda $85				lda 	XS_Type 					; get type.
.018f5e	29 02		and #$02			and 	#2
.018f60	d0 27		bne $018f89			bne 	_CPR_String 				; if type = 2 output as string.
.018f62					_CPR_Number:
.018f62	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018f64	8d 14 03	sta $0314			sta 	NumBufX
.018f67	a5 85		lda $85				lda 	XS_Type 					; get type
.018f69	4a		lsr a				lsr 	a
.018f6a	b0 08		bcs $018f74			bcs 	_CPRInt 					; if msb set do as integer
.018f6c	20 a1 a4	jsr $01a4a1			jsr 	FPToString 					; call fp to str otherwise
.018f6f	80 06		bra $018f77			bra 	_CPRNPrint
.018f71					_CPR_GoNewLine:
.018f71	4c d7 8f	jmp $018fd7			jmp 	_CPR_NewLine
.018f74	20 29 9f	jsr $019f29	_CPRInt:jsr 	IntToString
.018f77					_CPRNPrint:
.018f77	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018f7a	c9 2d		cmp #$2d			cmp 	#"-"
.018f7c	f0 05		beq $018f83			beq 	_CPRNoSpace
.018f7e	a9 20		lda #$20			lda 	#" "						; print the leading space
.018f80	20 3c 85	jsr $01853c			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018f83					_CPRNoSpace:
.018f83	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018f85	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018f87	80 04		bra $018f8d			bra 	_CPRPrint
.018f89					_CPR_String:
.018f89	a6 80		ldx $80				ldx 	XS_Mantissa
.018f8b	a5 81		lda $81				lda 	XS_Mantissa+1
.018f8d					_CPRPrint:
.018f8d	86 1e		stx $1e				stx 	zGenPtr
.018f8f	85 1f		sta $1f				sta 	zGenPtr+1
.018f91	5a		phy				phy
.018f92	a0 00		ldy #$00			ldy 	#0							; get length into X
.018f94	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f96	aa		tax				tax
.018f97	f0 09		beq $018fa2			beq 	_CPREndPrint 				; nothing to print
.018f99					_CPRLoop:
.018f99	c8		iny				iny
.018f9a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f9c	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.018f9f	ca		dex				dex
.018fa0	d0 f7		bne $018f99			bne 	_CPRLoop
.018fa2					_CPREndPrint:
.018fa2	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.018fa4	29 02		and #$02			and 	#2
.018fa6	d0 05		bne $018fad			bne 	_CPRNoTrail
.018fa8	a9 20		lda #$20			lda 	#" "
.018faa	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.018fad					_CPRNoTrail:
.018fad	7a		ply				ply
.018fae	80 97		bra $018f47			bra 	_CPR_Loop
.018fb0					_CPR_Tab:
.018fb0	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.018fb3					_CPR_CalcSpaces:
.018fb3	38		sec				sec 								; calculate position mod 10.
.018fb4	e9 0a		sbc #$0a			sbc 	#10
.018fb6	b0 fb		bcs $018fb3			bcs 	_CPR_CalcSpaces
.018fb8	69 0a		adc #$0a			adc 	#10
.018fba	f0 0d		beq $018fc9			beq 	_CPR_Skip 					; nothing to print
.018fbc	aa		tax				tax 								; print out spaces to mod 10
.018fbd					_CPRTabSpaces:
.018fbd	a9 20		lda #$20			lda 	#" "
.018fbf	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.018fc2	e8		inx				inx
.018fc3	e0 0a		cpx #$0a			cpx 	#10
.018fc5	d0 f6		bne $018fbd			bne 	_CPRTabSpaces
.018fc7	80 e7		bra $018fb0			bra 	_CPR_Tab
.018fc9					_CPR_Skip:
.018fc9	c8		iny				iny
.018fca	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fcc	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018fce	f0 0c		beq $018fdc			beq 	_CPR_Exit
.018fd0	c9 00		cmp #$00			cmp 	#0
.018fd2	f0 08		beq $018fdc			beq 	_CPR_Exit 					; if not go round again.
.018fd4	4c 47 8f	jmp $018f47			jmp 	_CPR_Loop
.018fd7					_CPR_NewLine:
.018fd7	a9 0d		lda #$0d			lda 	#13
.018fd9	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.018fdc					_CPR_Exit:
.018fdc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018fdd					Command_ASSERT:
.018fdd	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.018fe0	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018fe2	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018fe4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018fe6	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018fe8	f0 01		beq $018feb			beq 	_ASFail
.018fea	60		rts				rts
.018feb					_ASFail:
.018feb	20 83 85	jsr $018583			jsr ERR_Handler
>018fee	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018ff5					Command_POKE:
.018ff5	a9 01		lda #$01			lda 	#1 							; 1 byte
.018ff7	80 06		bra $018fff			bra 	CmdPoke_Main
.018ff9					Command_DOKE:
.018ff9	a9 02		lda #$02			lda 	#2 							; 2 bytes
.018ffb	80 02		bra $018fff			bra 	CmdPoke_Main
.018ffd					Command_LOKE:
.018ffd	a9 04		lda #$04			lda 	#4							; 4 bytes
.018fff					CmdPoke_Main:
.018fff	48		pha				pha
.019000	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; get two parameters. First is address
.019003	e8		inx				inx
.019004	e8		inx				inx
.019005	e8		inx				inx
.019006	e8		inx				inx
.019007	e8		inx				inx
.019008	e8		inx				inx
.019009	20 a1 99	jsr $0199a1			jsr 	CheckNextComma
.01900c	20 45 93	jsr $019345			jsr 	EvaluateIntegerX 			; second is the data.
.01900f	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.019011	85 1a		sta $1a				sta 	zLTemp1
.019013	a5 81		lda $81				lda 	XS_Mantissa+1
.019015	85 1b		sta $1b				sta 	zLTemp1+1
.019017	a5 82		lda $82				lda 	XS_Mantissa+2
.019019	85 1c		sta $1c				sta 	zLTemp1+2
.01901b	a5 83		lda $83				lda 	XS_Mantissa+3
.01901d	85 1d		sta $1d				sta 	zLTemp1+3
.01901f	68		pla				pla 								; get count
.019020	5a		phy				phy 								; save Y
.019021	20 2c 99	jsr $01992c			jsr 	MemWrite 					; write it out
.019024	7a		ply				ply 								; restore Y and done.
.019025	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.019026					Command_NEW:
.019026	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019028	85 16		sta $16				sta 	zCodePtr+0
.01902a	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01902c	85 17		sta $17				sta 	zCodePtr+1
.01902e	a9 00		lda #$00			lda 	#0
.019030	85 18		sta $18				sta 	zCodePtr+2
.019032	85 19		sta $19				sta 	zCodePtr+3
.019034	a0 03		ldy #$03			ldy 	#3
.019036	a0 00		ldy #$00			ldy 	#0
.019038	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.01903a	97 16		sta [$16],y			sta 	[zCodePtr],y
.01903c	20 3d 99	jsr $01993d			jsr 	UpdateProgramEnd 			; update program end.
.01903f	4c 3c 88	jmp $01883c			jmp 	WarmStart
.019042					Command_OLD:
.019042	ea		nop				nop
.019043	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019045	85 16		sta $16				sta 	zCodePtr+0
.019047	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019049	85 17		sta $17				sta 	zCodePtr+1
.01904b	a9 00		lda #$00			lda 	#0
.01904d	85 18		sta $18				sta 	zCodePtr+2
.01904f	85 19		sta $19				sta 	zCodePtr+3
.019051	a0 03		ldy #$03			ldy 	#3
.019053					_COL_Find:
.019053	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019055	c8		iny				iny
.019056	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.019058	f0 18		beq $019072			beq 	_COL_Found
.01905a	98		tya				tya
.01905b	c9 00		cmp #$00			cmp 	#0
.01905d	d0 f4		bne $019053			bne 	_COL_Find 					; can't find old EOL, give up.
.01905f	20 83 85	jsr $018583			jsr ERR_Handler
>019062	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>01906a	43 6f 72 72 75 70 74 00
.019072					_COL_Found:
.019072	98		tya				tya
.019073	48		pha				pha
.019074	a0 00		ldy #$00			ldy 	#0
.019076	68		pla				pla
.019077	97 16		sta [$16],y			sta 	[zCodePtr],y
.019079	20 3d 99	jsr $01993d			jsr 	UpdateProgramEnd 			; reset variable pointer
.01907c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.01907d					Command_GOTO:
.01907d	20 d2 90	jsr $0190d2			jsr 	GotoGetLineNumber 			; get line number
.019080					CmdGOTO:
.019080	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.019082	4c ef 90	jmp $0190ef			jmp 	GotoChangeToLineNumberX
.019085					Command_GOSUB:
.019085	20 d2 90	jsr $0190d2			jsr 	GotoGetLineNumber 			; get line number
.019088					CmdGOSUB:
.019088	20 03 85	jsr $018503			jsr 	StackSavePosition 			; save position on stack and push frame
.01908b	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.01908d	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.019090	a2 00		ldx #$00			ldx		#0 							; go to that line number
.019092	4c ef 90	jmp $0190ef			jmp 	GotoChangeToLineNumberX
.019095					Command_RETURN:
.019095	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.019097	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.01909a	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; restore position.
.01909d	60		rts				rts
.01909e					Command_ON:
.01909e	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.0190a0	20 ef 97	jsr $0197ef			jsr 	SLIByteParameter
.0190a3	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.0190a5	f0 28		beq $0190cf			beq 	_CONFail 					; can't be zero, error if it is.
.0190a7	aa		tax				tax 								; save in X.
.0190a8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190aa	c8		iny				iny
.0190ab	48		pha				pha 								; so we can check what we're doing later.
.0190ac	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.0190ae	f0 07		beq $0190b7			beq 	_CONOkayToken
.0190b0	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.0190b2	f0 03		beq $0190b7			beq 	_CONOkayToken
.0190b4	4c 54 85	jmp $018554			jmp 	SyntaxError
.0190b7					_CONOkayToken:
.0190b7	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.0190b8					_CONFindNumber:
.0190b8	20 d2 90	jsr $0190d2			jsr 	GotoGetLineNumber 			; get a line number.
.0190bb	fa		plx				plx 								; restore count
.0190bc	ca		dex				dex  								; decrement, exit if zero.
.0190bd	f0 06		beq $0190c5			beq 	_CONFound
.0190bf	da		phx				phx 								; push back
.0190c0	20 a1 99	jsr $0199a1			jsr 	CheckNextComma				; check for comma
.0190c3	80 f3		bra $0190b8			bra 	_CONFindNumber 				; go round again.
.0190c5					_CONFound:
.0190c5	68		pla				pla 								; get token to decide what to do
.0190c6	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.0190c8	f0 b6		beq $019080			beq		CmdGOTO 					; then just branch.
.0190ca	20 8a 84	jsr $01848a			jsr 	SkipEndOfCommand 			; go to end of command
.0190cd	80 b9		bra $019088			bra 	CmdGOSUB 					; and do a GOSUB.
.0190cf					_CONFail:
.0190cf	4c 72 85	jmp $018572			jmp 	BadParamError
.0190d2					GotoGetLineNumber:
.0190d2	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; get integer into mantissa.0
.0190d5	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.0190d7	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.0190d9	d0 01		bne $0190dc			bne 	_GLINError
.0190db	60		rts				rts
.0190dc					_GLINError:
.0190dc	20 83 85	jsr $018583			jsr ERR_Handler
>0190df	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0190e7	20 4e 75 6d 62 65 72 00
.0190ef					GotoChangeToLineNumberX:
.0190ef	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.0190f1	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0190f3	f0 37		beq $01912c			beq 	_GCTLFail 					; if so, no can do.
.0190f5	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0190f7	85 16		sta $16				sta 	zCodePtr+0
.0190f9	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0190fb	85 17		sta $17				sta 	zCodePtr+1
.0190fd	a9 00		lda #$00			lda 	#0
.0190ff	85 18		sta $18				sta 	zCodePtr+2
.019101	85 19		sta $19				sta 	zCodePtr+3
.019103	a0 03		ldy #$03			ldy 	#3
.019105					_GCTLLoop:
.019105	a0 00		ldy #$00			ldy 	#0
.019107	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019109	c9 00		cmp #$00			cmp 	#0
.01910b	f0 1f		beq $01912c			beq 	_GCTLFail
.01910d	c8		iny				iny
.01910e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019110	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.019112	d0 07		bne $01911b			bne 	_GCTLNext
.019114	c8		iny				iny
.019115	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019117	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.019119	f0 0f		beq $01912a			beq 	_GCTLExit
.01911b					_GCTLNext:
.01911b	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01911d	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01911f	18		clc				clc
.019120	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.019122	85 16		sta $16				sta 	zCodePtr
.019124	90 02		bcc $019128			bcc 	_SNLNoCarry
.019126	e6 17		inc $17				inc 	zCodePtr+1
.019128					_SNLNoCarry:
.019128	80 db		bra $019105			bra 	_GCTLLoop 					; try next line.
.01912a					_GCTLExit:
.01912a	c8		iny				iny
.01912b	60		rts				rts
.01912c					_GCTLFail:
.01912c	20 83 85	jsr $018583			jsr ERR_Handler
>01912f	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019137	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.01913f					Command_CLR:
.01913f					ResetRunStatus:
.01913f	20 83 9a	jsr $019a83			jsr 	VariableClear
.019142	20 aa 84	jsr $0184aa			jsr 	StackReset
.019145	a9 00		lda #$00			lda 	#HighMemory & $FF
.019147	8d 00 03	sta $0300			sta 	StringPtr
.01914a	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.01914c	8d 01 03	sta $0301			sta 	StringPtr+1
.01914f	20 4d 9c	jsr $019c4d			jsr 	ArrayResetDefault
.019152	20 f9 8a	jsr $018af9			jsr 	Command_RESTORE
.019155	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.019156					Command_STOP:
.019156	20 83 85	jsr $018583			jsr ERR_Handler
>019159	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.01915e					Command_WHILE:
.01915e	20 03 85	jsr $018503			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.019161	20 43 93	jsr $019343			jsr 	EvaluateInteger 			; calculate the while loop value.
.019164	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019166	05 81		ora $81				ora 	XS_Mantissa+1
.019168	05 82		ora $82				ora 	XS_Mantissa+2
.01916a	05 83		ora $83				ora 	XS_Mantissa+3
.01916c	f0 06		beq $019174			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01916e	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.019170	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on stack
.019173	60		rts				rts
.019174					_CWHSkip:
.019174	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019176	20 fd 83	jsr $0183fd			jsr 	StructureSearchSingle
.019179	c8		iny				iny
.01917a	60		rts				rts
.01917b					Command_WEND:
.01917b	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.01917d	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.019180	20 20 85	jsr $018520			jsr 	StackRestorePosition
.019183	80 d9		bra $01915e			bra 	Command_WHILE 				; and do the while again.
.019185	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.019186					Command_REPEAT:
.019186	20 03 85	jsr $018503			jsr 	StackSavePosition			; save position into stack
.019189	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.01918b	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on stack
.01918e	60		rts				rts
.01918f					Command_UNTIL:
.01918f	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.019191	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.019194	20 43 93	jsr $019343			jsr 	EvaluateInteger				; work out UNTIL
.019197	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.019199	05 81		ora $81				ora 	XS_Mantissa+1
.01919b	05 82		ora $82				ora 	XS_Mantissa+2
.01919d	05 83		ora $83				ora 	XS_Mantissa+3
.01919f	d0 08		bne $0191a9			bne 	_CUTExit 					; if not, just exit
.0191a1	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; otherwise loop round again.
.0191a4	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0191a6	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; fix the stack back.
.0191a9					_CUTExit:
.0191a9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.0191aa					EVESyntax:
.0191aa	4c 54 85	jmp $018554			jmp 	SyntaxError
.0191ad					EvaluateExpression:
.0191ad	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.0191af					EvaluateExpressionX:
.0191af	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.0191b1					EvaluateExpressionXA:
.0191b1	48		pha				pha 								; save precedence on stack.
.0191b2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191b4	f0 f4		beq $0191aa			beq 	EVESyntax 					; end of line, syntax error.
.0191b6	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.0191b8	b0 03		bcs $0191bd			bcs 	_EVNotVariable
.0191ba	4c 87 92	jmp $019287			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.0191bd					_EVNotVariable:
.0191bd	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.0191bf	90 e9		bcc $0191aa			bcc 	EVESyntax
.0191c1	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.0191c3	b0 58		bcs $01921d			bcs 	_EVNotInteger
.0191c5	20 b5 92	jsr $0192b5			jsr 	EvaluateGetInteger
.0191c8					_EVCheckDecimal:
.0191c8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191ca	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.0191cc	d0 05		bne $0191d3			bne 	_EVGotAtom 					; no, get atom.
.0191ce					_EVIsDecimal:
.0191ce	20 db 92	jsr $0192db			jsr 	EVGetDecimal 				; extend to the decimal part.
.0191d1	80 00		bra $0191d3			bra 	_EVGotAtom 					; and continue to got atom.
.0191d3					_EVGotAtom:
.0191d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191d5	10 44		bpl $01921b			bpl 	_EVExitDrop 				; must be a token.
.0191d7	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.0191d9	b0 40		bcs $01921b			bcs 	_EVExitDrop
.0191db	68		pla				pla 								; get current precedence
.0191dc	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.0191de	da		phx				phx 								; save X
.0191df	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191e1	aa		tax				tax 								; put in X
.0191e2	bf 38 86 01	lda $018638,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.0191e6	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.0191e8	fa		plx				plx 								; restore X
.0191e9	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.0191eb	90 2f		bcc $01921c			bcc 	_EVExit 					; exit if too low.
.0191ed	f0 2d		beq $01921c			beq 	_EVExit 					; exit if equals
.0191ef	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.0191f1	48		pha				pha
.0191f2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0191f4	48		pha				pha
.0191f5	c8		iny				iny
.0191f6	da		phx				phx 								; save current position
.0191f7	e8		inx				inx
.0191f8	e8		inx				inx
.0191f9	e8		inx				inx
.0191fa	e8		inx				inx
.0191fb	e8		inx				inx
.0191fc	e8		inx				inx
.0191fd	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0191ff	20 b1 91	jsr $0191b1			jsr 	EvaluateExpressionXA 		; do the RHS.
.019202	fa		plx				plx 								; restore X
.019203	68		pla				pla 								; get the binary operator in A.
.019204					_EVCallA:
.019204	da		phx				phx 								; save X again
.019205	0a		asl a				asl 	a 							; double, lose the MSB.
.019206	aa		tax				tax									; put in X
.019207	bf e7 85 01	lda $0185e7,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01920b	8d 11 03	sta $0311			sta 	LocalVector+1
.01920e	bf e8 85 01	lda $0185e8,x			lda 	VectorTable+1,x
.019212	8d 12 03	sta $0312			sta 	LocalVector+2
.019215	fa		plx				plx 								; restore X
.019216	20 90 92	jsr $019290			jsr 	EVCallLocalVector
.019219	80 b8		bra $0191d3			bra 	_EVGotAtom 					; and loop back.
.01921b					_EVExitDrop:
.01921b	68		pla				pla
.01921c					_EVExit:
.01921c	60		rts				rts
.01921d					_EVNotInteger:
.01921d	c8		iny				iny
.01921e	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019220	d0 16		bne $019238			bne 	_EVNotMinus
.019222	20 24 93	jsr $019324			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019225	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019227	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019229	f0 05		beq $019230			beq 	_EVMinusFloat
.01922b	20 0c 9f	jsr $019f0c			jsr 	IntegerNegateAlways 		; negation
.01922e	80 a3		bra $0191d3			bra 	_EVGotAtom 					; and go back.
.019230					_EVMinusFloat:
.019230	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019232	49 80		eor #$80			eor 	#$80
.019234	95 85		sta $85,x			sta 	XS_Type,x
.019236	80 9b		bra $0191d3			bra 	_EVGotAtom
.019238					_EVNotMinus:
.019238	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01923a	d0 17		bne $019253			bne 	_EVNotParenthesis
.01923c	20 af 91	jsr $0191af			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.01923f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019241	c8		iny				iny
.019242	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.019244	f0 8d		beq $0191d3			beq 	_EVGotAtom
.019246	20 83 85	jsr $018583			jsr ERR_Handler
>019249	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019251	29 00
.019253					_EVNotParenthesis:
.019253	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019255	d0 0c		bne $019263			bne 	_EVNotNot
.019257	20 24 93	jsr $019324			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01925a	20 a2 a3	jsr $01a3a2			jsr 	FPUToInteger 				; make it an integer - if possible.
.01925d	20 09 93	jsr $019309			jsr 	NotInteger 					; do the not calculation
.019260	4c d3 91	jmp $0191d3			jmp 	_EVGotAtom
.019263					_EVNotNot:
.019263	c9 fe		cmp #$fe			cmp 	#$FE
.019265	d0 12		bne $019279			bne 	_EVNotString
.019267	20 21 9a	jsr $019a21			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01926a	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01926c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01926e	a5 21		lda $21				lda 	zTempStr+1
.019270	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019272	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019274	95 85		sta $85,x			sta 	XS_Type,x
.019276	4c d3 91	jmp $0191d3			jmp 	_EVGotAtom
.019279					_EVNotString:
.019279	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01927b	90 04		bcc $019281			bcc 	_EVBadElement
.01927d	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.01927f	90 03		bcc $019284			bcc 	_EVUnaryFunction
.019281					_EVBadElement:
.019281	4c 54 85	jmp $018554			jmp 	SyntaxError
.019284					_EVUnaryFunction:
.019284	4c 04 92	jmp $019204			jmp 	_EVCallA
.019287					_EVVariableHandler:
.019287	20 47 9a	jsr $019a47			jsr 	VariableFind 				; locate a variable
.01928a	20 8f 9d	jsr $019d8f			jsr 	VariableGet 				; copy into memory.
.01928d	4c d3 91	jmp $0191d3			jmp 	_EVGotAtom 					; and go round.
.019290					EVCallLocalVector:
.019290	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019293					EVShiftMantissaLeft6:
.019293	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019295	95 84		sta $84,x			sta 	XS_Exponent,x
.019297	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019299	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01929b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01929d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01929f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192a1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192a3	a9 00		lda #$00			lda 	#0
.0192a5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192a7	20 aa 92	jsr $0192aa			jsr 	_EVSMLShift 					; call it here to do it twice
.0192aa					_EVSMLShift:
.0192aa	56 84		lsr $84,x			lsr 	XS_Exponent,x
.0192ac	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.0192ae	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.0192b0	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.0192b2	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.0192b4	60		rts				rts
.0192b5					EvaluateGetInteger:
.0192b5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0192b7	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.0192b9	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.0192bb	a9 00		lda #$00			lda 	#0
.0192bd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192bf	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192c1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192c3	1a		inc a				inc 	a 							; set to type 1 (integer)
.0192c4	95 85		sta $85,x			sta 	XS_Type,x
.0192c6					_EVCheckNextInteger:
.0192c6	c8		iny				iny
.0192c7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0192c9	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0192cb	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0192cd	b0 0b		bcs $0192da			bcs 	_EVEndInteger
.0192cf	48		pha				pha 								; save it.
.0192d0	20 93 92	jsr $019293			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0192d3	68		pla				pla
.0192d4	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0192d6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192d8	80 ec		bra $0192c6			bra 	_EVCheckNextInteger
.0192da					_EVEndInteger:
.0192da	60		rts				rts
.0192db					EVGetDecimal:
.0192db	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0192dd	8d 15 03	sta $0315			sta 	Num_Buffer
.0192e0	da		phx				phx
.0192e1	c8		iny				iny
.0192e2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0192e4	c8		iny				iny
.0192e5	3a		dec a				dec 	a								; convert to a string length.
.0192e6	3a		dec a				dec 	a
.0192e7	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.0192e9					_EVGDCopy:
.0192e9	48		pha				pha 									; save count
.0192ea	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0192ec	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.0192ef	e8		inx				inx 									; forward ....
.0192f0	c8		iny				iny
.0192f1	68		pla				pla 									; get count
.0192f2	3a		dec a				dec 	a 								; until zero
.0192f3	d0 f4		bne $0192e9			bne 	_EVGDCopy
.0192f5	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.0192f8	fa		plx				plx 									; restore X
.0192f9	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0192fb	85 1e		sta $1e				sta 	zGenPtr
.0192fd	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0192ff	85 1f		sta $1f				sta 	zGenPtr+1
.019301	5a		phy				phy 									; save Y
.019302	a0 00		ldy #$00			ldy 	#0 								; start position
.019304	20 5c a5	jsr $01a55c			jsr 	FPFromString 					; convert current
.019307	7a		ply				ply 									; restore Y
.019308	60		rts				rts
.019309					NotInteger:
.019309	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01930b	49 ff		eor #$ff			eor 	#$FF
.01930d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01930f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019311	49 ff		eor #$ff			eor 	#$FF
.019313	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019315	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019317	49 ff		eor #$ff			eor 	#$FF
.019319	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01931b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01931d	49 ff		eor #$ff			eor 	#$FF
.01931f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019321	60		rts				rts
.019322					EvaluateGetAtom:
.019322	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019324					EvaluateGetAtomX:
.019324	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019326	20 b1 91	jsr $0191b1			jsr 	EvaluateExpressionXA
.019329	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01932b	29 0f		and #$0f			and 	#15
.01932d	c9 02		cmp #$02			cmp 	#2
.01932f	b0 01		bcs $019332			bcs 	EvaluateType
.019331	60		rts				rts
.019332					EvaluateType:
.019332	4c 64 85	jmp $018564			jmp 	TypeError
.019335					EvaluateNumber:
.019335	a2 00		ldx #$00			ldx 	#0
.019337					EvaluateNumberX:
.019337	20 af 91	jsr $0191af			jsr 	EvaluateExpressionX
.01933a	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01933c	29 0f		and #$0f			and 	#15
.01933e	c9 02		cmp #$02			cmp 	#2
.019340	b0 f0		bcs $019332			bcs 	EvaluateType
.019342	60		rts				rts
.019343					EvaluateInteger:
.019343	a2 00		ldx #$00			ldx 	#0
.019345					EvaluateIntegerX:
.019345	20 37 93	jsr $019337			jsr 	EvaluateNumberX
.019348	20 a2 a3	jsr $01a3a2			jsr 	FPUToInteger
.01934b	60		rts				rts
.01934c					EvaluateString:
.01934c	a2 00		ldx #$00			ldx 	#0
.01934e					EvaluateStringX:
.01934e	20 af 91	jsr $0191af			jsr 	EvaluateExpressionX
.019351	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019353	29 0f		and #$0f			and 	#15
.019355	c9 02		cmp #$02			cmp 	#2
.019357	d0 d9		bne $019332			bne 	EvaluateType
.019359	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.01935b	85 1e		sta $1e				sta 	zGenPtr
.01935d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01935f	85 1f		sta $1f				sta 	zGenPtr+1
.019361	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019362					BinaryOp_And:
.019362	20 b6 93	jsr $0193b6			jsr 	BinaryMakeBothInteger
.019365	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019367	35 86		and $86,x			and 	XS2_Mantissa+0,x
.019369	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01936b	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01936d	35 87		and $87,x			and 	XS2_Mantissa+1,x
.01936f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019371	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019373	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019375	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019377	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019379	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01937b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01937d	60		rts				rts
.01937e					BinaryOp_Or:
.01937e	20 b6 93	jsr $0193b6			jsr 	BinaryMakeBothInteger
.019381	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019383	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019385	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019387	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019389	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01938b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01938d	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01938f	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019391	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019393	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019395	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019397	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019399	60		rts				rts
.01939a					BinaryOp_Eor:
.01939a					BinaryOp_Xor:
.01939a	20 b6 93	jsr $0193b6			jsr 	BinaryMakeBothInteger
.01939d	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01939f	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0193a1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193a3	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0193a5	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.0193a7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193a9	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0193ab	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.0193ad	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193af	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0193b1	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.0193b3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193b5	60		rts				rts
.0193b6					BinaryMakeBothInteger:
.0193b6	da		phx				phx 								; save X
.0193b7	e8		inx				inx
.0193b8	e8		inx				inx
.0193b9	e8		inx				inx
.0193ba	e8		inx				inx
.0193bb	e8		inx				inx
.0193bc	e8		inx				inx
.0193bd	20 c1 93	jsr $0193c1			jsr 	BinaryMakeInteger 			; convert to integer.
.0193c0	fa		plx				plx 								; restore X and fall through.
.0193c1					BinaryMakeInteger:
.0193c1	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0193c3	29 0f		and #$0f			and 	#15 						; check type zero
.0193c5	f0 04		beq $0193cb			beq 	_BMIConvert 				; if float convert to integer.
.0193c7	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.0193c8	90 04		bcc $0193ce			bcc 	_BMIError
.0193ca	60		rts				rts
.0193cb					_BMIConvert:
.0193cb	4c a2 a3	jmp $01a3a2			jmp 	FPUToInteger 				; convert to integer
.0193ce					_BMIError:
.0193ce	4c 64 85	jmp $018564			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0193d1					Binary_Equal:
.0193d1	20 1a 94	jsr $01941a			jsr 	CompareValues 				; compare the values
.0193d4	09 00		ora #$00			ora 	#0 							; true if 0
.0193d6	f0 33		beq $01940b			beq 	CCTrue
.0193d8	80 2d		bra $019407			bra 	CCFalse
.0193da					Binary_NotEqual:
.0193da	20 1a 94	jsr $01941a			jsr 	CompareValues
.0193dd	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.0193df	f0 26		beq $019407			beq 	CCFalse
.0193e1	80 28		bra $01940b			bra 	CCTrue
.0193e3					Binary_Less:
.0193e3	20 1a 94	jsr $01941a			jsr 	CompareValues
.0193e6	09 00		ora #$00			ora 	#0 							; true if -1
.0193e8	30 21		bmi $01940b			bmi 	CCTrue
.0193ea	80 1b		bra $019407			bra 	CCFalse
.0193ec					Binary_LessEqual:
.0193ec	20 1a 94	jsr $01941a			jsr 	CompareValues
.0193ef	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.0193f1	d0 18		bne $01940b			bne 	CCTrue
.0193f3	80 12		bra $019407			bra 	CCFalse
.0193f5					Binary_GreaterEqual:
.0193f5	20 1a 94	jsr $01941a			jsr 	CompareValues
.0193f8	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.0193fa	10 0f		bpl $01940b			bpl 	CCTrue
.0193fc	80 09		bra $019407			bra 	CCFalse
.0193fe					Binary_Greater:
.0193fe	20 1a 94	jsr $01941a			jsr 	CompareValues 				; true if 1
.019401	c9 01		cmp #$01			cmp 	#1
.019403	f0 06		beq $01940b			beq 	CCTrue
.019405	80 00		bra $019407			bra 	CCFalse
.019407	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.019409	80 02		bra $01940d			bra 	CCWrite
.01940b	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01940d	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.01940f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019411	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019413	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019415	a9 01		lda #$01			lda 	#1
.019417	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019419	60		rts				rts
.01941a					CompareValues:
.01941a	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.01941c	35 8b		and $8b,x			and 	XS2_Type,x
.01941e	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.019420	f0 11		beq $019433			beq 	_CVString					; comparison routine.
.019422	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019424	35 8b		and $8b,x			and 	XS2_Type,x
.019426	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019427	90 03		bcc $01942c			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019429	4c 75 94	jmp $019475			jmp 	CompareInteger32 							; so execute code at \1
.01942c					_BCFloat:
.01942c	20 19 95	jsr $019519			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01942f	4c 9b a2	jmp $01a29b			jmp 	FPCompare 							; and execute code at \2
.019432	60		rts				rts
.019433					_CVString:
.019433	da		phx				phx 								; save XY
.019434	5a		phy				phy
.019435	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019437	85 1a		sta $1a				sta		zLTemp1+0
.019439	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01943b	85 1b		sta $1b				sta 	zLTemp1+1
.01943d	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01943f	85 1c		sta $1c				sta 	zLTemp1+2
.019441	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019443	85 1d		sta $1d				sta 	zLTemp1+3
.019445	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019447	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019449	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01944b	90 02		bcc $01944f			bcc 	_CVCommon
.01944d	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.01944f					_CVCommon:
.01944f	aa		tax				tax 								; put shorter string length in zero.
.019450	f0 0c		beq $01945e			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019452					_CVCompare:
.019452	c8		iny				iny 								; next character
.019453	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019455	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.019457	90 13		bcc $01946c			bcc 	_CVReturnLess 				; <
.019459	d0 15		bne $019470			bne 	_CVReturnGreater 			; >
.01945b	ca		dex				dex 								; until common length matched.
.01945c	d0 f4		bne $019452			bne 	_CVCompare
.01945e					_CVMatch:
.01945e	a0 00		ldy #$00			ldy 	#0
.019460	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019462	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019464	90 06		bcc $01946c			bcc 	_CVReturnLess 				; <
.019466	d0 08		bne $019470			bne 	_CVReturnGreater 			; >
.019468	a9 00		lda #$00			lda 	#0
.01946a	80 06		bra $019472			bra 	_CVExit
.01946c					_CVReturnLess:
.01946c	a9 ff		lda #$ff			lda 	#$FF
.01946e	80 02		bra $019472			bra 	_CVExit
.019470					_CVReturnGreater:
.019470	a9 01		lda #$01			lda 	#$01
.019472					_CVExit:
.019472	7a		ply				ply
.019473	fa		plx				plx
.019474	60		rts				rts
.019475					CompareInteger32:
.019475	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019477	49 80		eor #$80			eor 	#$80
.019479	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01947b	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01947d	49 80		eor #$80			eor 	#$80
.01947f	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019481	20 ff 94	jsr $0194ff			jsr 	SubInteger32 				; subtraction
.019484	90 0d		bcc $019493			bcc 	_CI32Less 					; cc return -1
.019486	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019488	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01948a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01948c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01948e	f0 02		beq $019492			beq 	_CI32Exit
.019490	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019492					_CI32Exit:
.019492	60		rts				rts
.019493					_CI32Less:
.019493	a9 ff		lda #$ff			lda 	#$FF
.019495	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019496					BinaryOp_Add:
.019496	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019498	35 8b		and $8b,x			and 	XS2_Type,x
.01949a	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01949c	d0 11		bne $0194af			bne 	_BOAString 					; so go do the string code.
.01949e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194a0	35 8b		and $8b,x			and 	XS2_Type,x
.0194a2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194a3	90 03		bcc $0194a8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194a5	4c e5 94	jmp $0194e5			jmp 	AddInteger32 							; so execute code at \1
.0194a8					_BCFloat:
.0194a8	20 19 95	jsr $019519			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194ab	4c 76 a0	jmp $01a076			jmp 	FPAdd 							; and execute code at \2
.0194ae	60		rts				rts
.0194af					_BOAString:
.0194af	4c 33 95	jmp $019533			jmp 	ConcatenateString 			; concatenate two strings.
.0194b2					BinaryOp_Subtract:
.0194b2	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194b4	35 8b		and $8b,x			and 	XS2_Type,x
.0194b6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194b7	90 03		bcc $0194bc			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194b9	4c ff 94	jmp $0194ff			jmp 	SubInteger32 							; so execute code at \1
.0194bc					_BCFloat:
.0194bc	20 19 95	jsr $019519			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194bf	4c 6e a0	jmp $01a06e			jmp 	FPSubtract 							; and execute code at \2
.0194c2	60		rts				rts
.0194c3					BinaryOp_Multiply:
.0194c3	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194c5	35 8b		and $8b,x			and 	XS2_Type,x
.0194c7	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194c8	90 03		bcc $0194cd			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194ca	4c 47 9e	jmp $019e47			jmp 	MulInteger32 							; so execute code at \1
.0194cd					_BCFloat:
.0194cd	20 19 95	jsr $019519			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194d0	4c 9d a1	jmp $01a19d			jmp 	FPMultiply 							; and execute code at \2
.0194d3	60		rts				rts
.0194d4					BinaryOp_Divide:
.0194d4	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194d6	35 8b		and $8b,x			and 	XS2_Type,x
.0194d8	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194d9	90 03		bcc $0194de			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194db	4c 85 9e	jmp $019e85			jmp 	DivInteger32 							; so execute code at \1
.0194de					_BCFloat:
.0194de	20 19 95	jsr $019519			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194e1	4c 2a a1	jmp $01a12a			jmp 	FPDivide 							; and execute code at \2
.0194e4	60		rts				rts
.0194e5					AddInteger32:
.0194e5	18		clc				clc
.0194e6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0194e8	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0194ea	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0194ec	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194ee	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0194f0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194f2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0194f4	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0194f6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194f8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0194fa	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0194fc	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194fe	60		rts				rts
.0194ff					SubInteger32:
.0194ff	38		sec				sec
.019500	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019502	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019504	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019506	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019508	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01950a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01950c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01950e	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019510	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019512	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019514	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019516	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019518	60		rts				rts
.019519					BinaryMakeBothFloat:
.019519	da		phx				phx 								; save X
.01951a	e8		inx				inx
.01951b	e8		inx				inx
.01951c	e8		inx				inx
.01951d	e8		inx				inx
.01951e	e8		inx				inx
.01951f	e8		inx				inx
.019520	20 24 95	jsr $019524			jsr 	BinaryMakeFloat 			; convert to float.
.019523	fa		plx				plx 								; restore X and fall through.
.019524					BinaryMakeFloat:
.019524	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019526	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019527	b0 04		bcs $01952d			bcs 	_BMFConvert
.019529	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.01952a	b0 04		bcs $019530			bcs 	_BMFError
.01952c	60		rts				rts
.01952d					_BMFConvert:
.01952d	4c 56 a3	jmp $01a356			jmp 	FPUToFloat 					; convert to float, only float builds of course
.019530					_BMFError:
.019530	4c 64 85	jmp $018564			jmp 	TypeError
.019533					ConcatenateString:
.019533	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019535	85 1a		sta $1a				sta		zLTemp1+0
.019537	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019539	85 1b		sta $1b				sta 	zLTemp1+1
.01953b	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01953d	85 1c		sta $1c				sta 	zLTemp1+2
.01953f	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019541	85 1d		sta $1d				sta 	zLTemp1+3
.019543	5a		phy				phy
.019544	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019546	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019548	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.01954a	7a		ply				ply
.01954b	b0 33		bcs $019580			bcs 	_CSError					; check in range.
.01954d	c9 fe		cmp #$fe			cmp 	#maxString+1
.01954f	b0 2f		bcs $019580			bcs 	_CSError
.019551	20 e6 99	jsr $0199e6			jsr 	AllocateTempString 			; store the result
.019554	20 6b 95	jsr $01956b			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019557	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.019559	85 1a		sta $1a				sta 	zLTemp1
.01955b	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01955d	85 1b		sta $1b				sta 	zLTemp1+1
.01955f	20 6b 95	jsr $01956b			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019562	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019564	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019566	a5 21		lda $21				lda 	zTempStr+1
.019568	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01956a	60		rts				rts
.01956b					_CSCopyString:
.01956b	da		phx				phx
.01956c	5a		phy				phy
.01956d	a0 00		ldy #$00			ldy 	#0 							; get length
.01956f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019571	f0 0a		beq $01957d			beq 	_CSCSExit 					; if zero, exit immediately
.019573	aa		tax				tax 								; put in X which is the counter.
.019574					_CSCSLoop:
.019574	c8		iny				iny 								; get next char
.019575	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019577	20 11 9a	jsr $019a11			jsr		WriteTempString 			; copy out to new string
.01957a	ca		dex				dex 								; do whole string
.01957b	d0 f7		bne $019574			bne 	_CSCSLoop
.01957d					_CSCSExit:
.01957d	7a		ply				ply
.01957e	fa		plx				plx
.01957f	60		rts				rts
.019580					_CSError:
.019580	20 83 85	jsr $018583			jsr ERR_Handler
>019583	53 74 72 69 6e 67 20 74			.text "String too long",0
>01958b	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019593					Unary_Sgn:
.019593	20 37 93	jsr $019337			jsr 	EvaluateNumberX 			; get value
.019596	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; check right bracket.
.019599	20 b7 95	jsr $0195b7			jsr 	GetSignCurrent 				; get sign.
.01959c	09 00		ora #$00			ora 	#0
.01959e	10 08		bpl $0195a8			bpl		UnarySetAInteger			; if 0,1 return that.
.0195a0	80 00		bra $0195a2			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0195a2					UnarySetAMinus1:
.0195a2	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.0195a4	95 80		sta $80,x			sta 	XS_Mantissa,x
.0195a6	80 04		bra $0195ac			bra 	UnarySetAFill
.0195a8					UnarySetAInteger:
.0195a8	95 80		sta $80,x			sta 	XS_Mantissa,x
.0195aa	a9 00		lda #$00			lda 	#0
.0195ac					UnarySetAFill:
.0195ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195ae	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195b0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195b2	a9 01		lda #$01			lda 	#1 							; set type to integer.
.0195b4	95 85		sta $85,x			sta 	XS_Type,x
.0195b6	60		rts				rts
.0195b7					GetSignCurrent:
.0195b7	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0195b9	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0195ba	90 15		bcc $0195d1			bcc 	_GSCFloat 					; if clear do the float code.
.0195bc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.0195be	30 0e		bmi $0195ce			bmi 	_GSCMinus1
.0195c0	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0195c2	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0195c4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0195c6	d0 03		bne $0195cb			bne 	_GSCPlus1 					; check if zero by oring all together.
.0195c8					_GSCZero:
.0195c8	a9 00		lda #$00			lda 	#0
.0195ca	60		rts				rts
.0195cb					_GSCPlus1:
.0195cb	a9 01		lda #$01			lda 	#$01
.0195cd	60		rts				rts
.0195ce					_GSCMinus1:
.0195ce	a9 ff		lda #$ff			lda 	#$FF
.0195d0	60		rts				rts
.0195d1					_GSCFloat:
.0195d1	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.0195d3	70 f3		bvs $0195c8			bvs 	_GSCZero 					; if zero flag set return zero
.0195d5	30 f7		bmi $0195ce			bmi 	_GSCMinus1 					; if sign set return -1
.0195d7	80 f2		bra $0195cb			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0195d9					Unary_Abs:
.0195d9	20 37 93	jsr $019337			jsr 	EvaluateNumberX 			; get value
.0195dc	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; check right bracket.
.0195df	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0195e1	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0195e3	f0 07		beq $0195ec			beq 	_UAMinusFloat
.0195e5	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.0195e7	10 09		bpl $0195f2			bpl 	_UAExit
.0195e9	4c 0c 9f	jmp $019f0c			jmp 	IntegerNegateAlways 		; if so negate it.
.0195ec					_UAMinusFloat:
.0195ec	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.0195ee	29 7f		and #$7f			and		#$7F
.0195f0	95 85		sta $85,x			sta 	XS_Type,x
.0195f2					_UAExit:
.0195f2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0195f3					Unary_Peek:
.0195f3	a9 01		lda #$01			lda 	#1 							; 1 byte
.0195f5	80 06		bra $0195fd			bra 	UPMain
.0195f7					Unary_Deek:
.0195f7	a9 02		lda #$02			lda 	#2 							; 2 bytes
.0195f9	80 02		bra $0195fd			bra 	UPMain
.0195fb					Unary_Leek:
.0195fb	a9 04		lda #$04			lda 	#4 							; 4 bytes
.0195fd					UPMain:
.0195fd	48		pha				pha 								; save bytes to copy.
.0195fe	20 45 93	jsr $019345			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.019601	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.019604	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019606	85 1a		sta $1a				sta 	zLTemp1
.019608	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01960a	85 1b		sta $1b				sta 	zLTemp1+1
.01960c	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01960e	85 1c		sta $1c				sta 	zLTemp1+2
.019610	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019612	85 1d		sta $1d				sta 	zLTemp1+3
.019614	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.019616	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.019618	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01961a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01961c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01961e	68		pla				pla 								; restore bytes to copy
.01961f	da		phx				phx 								; save XY
.019620	5a		phy				phy
.019621	20 1b 99	jsr $01991b			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.019624	7a		ply				ply 								; restore and exit
.019625	fa		plx				plx
.019626	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019627					Unary_Pos:
.019627	20 37 93	jsr $019337			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.01962a	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; check right bracket.
.01962d	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; get the position
.019630	4c a8 95	jmp $0195a8			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019633					Unary_Mod:
.019633	20 5b 96	jsr $01965b			jsr 	_UMParameter 				; first parameter, get |param|
.019636	20 a1 99	jsr $0199a1			jsr 	CheckNextComma
.019639	da		phx				phx 								; second parameter, get |param|
.01963a	e8		inx				inx
.01963b	e8		inx				inx
.01963c	e8		inx				inx
.01963d	e8		inx				inx
.01963e	e8		inx				inx
.01963f	e8		inx				inx
.019640	20 5b 96	jsr $01965b			jsr 	_UMParameter
.019643	fa		plx				plx
.019644	20 99 99	jsr $019999			jsr 	CheckNextRParen
.019647	20 85 9e	jsr $019e85			jsr 	DivInteger32 				; divide, which handily leaves ....
.01964a	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.01964c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01964e	a5 1b		lda $1b				lda 	zLTemp1+1
.019650	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019652	a5 1c		lda $1c				lda 	zLTemp1+2
.019654	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019656	a5 1d		lda $1d				lda 	zLTemp1+3
.019658	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01965a	60		rts				rts
.01965b					_UMParameter:
.01965b	20 45 93	jsr $019345			jsr 	EvaluateIntegerX 			; get value
.01965e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019660	10 03		bpl $019665			bpl 	_UMNotSigned
.019662	20 0c 9f	jsr $019f0c			jsr 	IntegerNegateAlways
.019665					_UMNotSigned:
.019665	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019666					Unary_Usr:
.019666	20 37 93	jsr $019337			jsr 	EvaluateNumberX 			; numeric parameter
.019669	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.01966c	da		phx				phx 								; save XY
.01966d	5a		phy				phy
.01966e	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.019672	7a		ply				ply 								; restore YX and exit with whatever the
.019673	fa		plx				plx 								; routine called has chosen to do with it.
.019674	60		rts				rts
.019675					USRDefault:
.019675	20 83 85	jsr $018583			jsr ERR_Handler
>019678	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019680	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019687					Unary_Val:
.019687	20 4e 93	jsr $01934e			jsr 	EvaluateStringX 			; get string
.01968a	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; check right bracket.
.01968d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.01968f	85 1e		sta $1e				sta 	zGenPtr
.019691	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019693	85 1f		sta $1f				sta 	zGenPtr+1
.019695	da		phx				phx
.019696	5a		phy				phy
.019697	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.019699	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.01969b	f0 1b		beq $0196b8			beq 	UVBadNumber
.01969d	aa		tax				tax
.01969e					_UVCopy1:
.01969e	c8		iny				iny
.01969f	c0 18		cpy #$18			cpy 	#24 						; too long
.0196a1	f0 15		beq $0196b8			beq 	UVBadNumber
.0196a3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y					; copy character
.0196a5	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.0196a8	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.0196aa	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.0196ad	ca		dex				dex
.0196ae	d0 ee		bne $01969e			bne 	_UVCopy1
.0196b0	7a		ply				ply
.0196b1	fa		plx				plx
.0196b2	20 c6 96	jsr $0196c6			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.0196b5	b0 01		bcs $0196b8			bcs 	UVBadNumber
.0196b7	60		rts				rts
.0196b8					UVBadNumber:
.0196b8	20 83 85	jsr $018583			jsr ERR_Handler
>0196bb	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>0196c3	65 72 00
.0196c6					ConvertNumBuffer:
.0196c6	5a		phy				phy
.0196c7	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.0196c9	85 1e		sta $1e				sta 	zGenPtr
.0196cb	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0196cd	85 1f		sta $1f				sta 	zGenPtr+1
.0196cf	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.0196d2	c9 2d		cmp #$2d			cmp 	#"-"
.0196d4	d0 02		bne $0196d8			bne 	_UVNotMinus1
.0196d6	e6 1e		inc $1e				inc 	zGenPtr 					; this time just fix the pointer.
.0196d8					_UVNotMinus1:
.0196d8	20 de 9f	jsr $019fde			jsr 	IntFromString 				; get integer
.0196db	b0 22		bcs $0196ff			bcs 	_UVFail
.0196dd	20 5c a5	jsr $01a55c			jsr 	FPFromString 				; possibly float it.
.0196e0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; done the whole string
.0196e2	d0 1b		bne $0196ff			bne 	_UVFail 					; no, exit.
.0196e4	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.0196e7	c9 2d		cmp #$2d			cmp 	#"-"
.0196e9	d0 11		bne $0196fc			bne 	_UVNotMinus2
.0196eb	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.0196ed	29 0f		and #$0f			and 	#$0F
.0196ef	f0 05		beq $0196f6			beq 	_UVNegateFloat
.0196f1	20 0c 9f	jsr $019f0c			jsr 	IntegerNegateAlways
.0196f4	80 06		bra $0196fc			bra 	_UVNotMinus2
.0196f6					_UVNegateFloat:
.0196f6	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.0196f8	09 80		ora #$80			ora 	#$80
.0196fa	95 85		sta $85,x			sta 	XS_Type,x
.0196fc					_UVNotMinus2:
.0196fc	7a		ply				ply
.0196fd	18		clc				clc
.0196fe	60		rts				rts
.0196ff	7a		ply		_UVFail:ply
.019700	38		sec				sec
.019701	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.019702					Unary_Str:
.019702	20 37 93	jsr $019337			jsr 	EvaluateNumberX 			; numeric parameter
.019705	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.019708	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01970a	8d 14 03	sta $0314			sta 	NumBufX
.01970d	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01970f	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.019710	b0 05		bcs $019717			bcs 	_USInt 						; if msb set do as integer
.019712	20 a1 a4	jsr $01a4a1			jsr 	FPToString 					; call fp to str otherwise
.019715	80 03		bra $01971a			bra 	_USDuplicate
.019717	20 29 9f	jsr $019f29	_USInt:	jsr 	IntToString					; call int to str.
.01971a					_USDuplicate:
.01971a	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01971d	1a		inc a				inc 	a 							; one more for length
.01971e	20 e6 99	jsr $0199e6			jsr 	AllocateTempString 			; allocate space for it.
.019721	5a		phy				phy 								; save Y
.019722	a0 00		ldy #$00			ldy 	#0 							; start copying
.019724	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019727	20 11 9a	jsr $019a11			jsr 	WriteTempString
.01972a	c8		iny				iny
.01972b	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01972e	d0 f4		bne $019724			bne 	_USCopy
.019730	7a		ply				ply 								; restore Y
.019731	4c 0e 99	jmp $01990e			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019734					Unary_Asc:
.019734	20 4e 93	jsr $01934e			jsr 	EvaluateStringX 			; string parameter
.019737	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.01973a	5a		phy				phy 								; get the string length
.01973b	a0 00		ldy #$00			ldy 	#0
.01973d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01973f	f0 07		beq $019748			beq 	_UAIllegal 					; must be at least one character, 0 => error
.019741	c8		iny				iny
.019742	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read the first character
.019744	7a		ply				ply
.019745	4c a8 95	jmp $0195a8			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.019748					_UAIllegal:
.019748	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01974b					Unary_Len:
.01974b	20 4e 93	jsr $01934e			jsr 	EvaluateStringX 			; string parameter
.01974e	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.019751	5a		phy				phy 								; get the string length
.019752	a0 00		ldy #$00			ldy 	#0
.019754	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019756	7a		ply				ply
.019757	4c a8 95	jmp $0195a8			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.01975a					Unary_Mid:
.01975a	20 4e 93	jsr $01934e			jsr 	EvaluateStringX 				; get string.
.01975d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01975f	48		pha				pha
.019760	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019762	48		pha				pha
.019763	20 a1 99	jsr $0199a1			jsr 	CheckNextComma 					; skip comma
.019766	20 ef 97	jsr $0197ef			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019769	48		pha				pha 									; and push it.
.01976a	20 a1 99	jsr $0199a1			jsr 	CheckNextComma 					; skip comma
.01976d	20 ef 97	jsr $0197ef			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019770	48		pha				pha 									; and push it.
.019771	80 41		bra $0197b4			bra 	SLIProcess
.019773					Unary_Left:
.019773	20 4e 93	jsr $01934e			jsr 	EvaluateStringX 				; get string.
.019776	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019778	48		pha				pha
.019779	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01977b	48		pha				pha
.01977c	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01977e	48		pha				pha
.01977f	20 a1 99	jsr $0199a1			jsr 	CheckNextComma 					; skip comma
.019782	20 ef 97	jsr $0197ef			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019785	48		pha				pha 									; and push it.
.019786	80 2c		bra $0197b4			bra 	SLIProcess
.019788					Unary_Right:
.019788	20 4e 93	jsr $01934e			jsr 	EvaluateStringX 				; get string.
.01978b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01978d	48		pha				pha
.01978e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019790	48		pha				pha
.019791	da		phx				phx 									; get the string length and push on stack.
.019792	a2 00		ldx #$00			ldx 	#0
.019794	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.019796	fa		plx				plx
.019797	48		pha				pha
.019798	20 a1 99	jsr $0199a1			jsr 	CheckNextComma 					; skip comma
.01979b	20 ef 97	jsr $0197ef			jsr 	SLIByteParameter 				; get a byte parameter.
.01979e	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0197a1	68		pla				pla 									; restore string length.
.0197a2	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.0197a3	38		sec				sec
.0197a4	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.0197a7	f0 02		beq $0197ab			beq 	_URStart 						; if <= 0 start from 1.
.0197a9	10 02		bpl $0197ad			bpl 	_UROkay
.0197ab					_URStart:
.0197ab	a9 01		lda #$01			lda 	#1
.0197ad					_UROkay:
.0197ad	48		pha				pha 									; push start
.0197ae	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.0197b1	48		pha				pha
.0197b2	80 00		bra $0197b4			bra 	SLIProcess
.0197b4					SLIProcess:
.0197b4	20 99 99	jsr $019999			jsr 	CheckNextRParen 				; closing right bracket.
.0197b7	68		pla				pla
.0197b8	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.0197bb	1a		inc a				inc 	a 								; allocate +1 for it.
.0197bc	20 e6 99	jsr $0199e6			jsr 	AllocateTempString
.0197bf	68		pla				pla 									; pop start number off stack.
.0197c0	f0 3b		beq $0197fd			beq 	SLIError 						; exit if start = 0
.0197c2	8d a1 03	sta $03a1			sta 	SliceStart
.0197c5	68		pla				pla  									; pop string address.
.0197c6	85 1f		sta $1f				sta 	zGenPtr+1
.0197c8	68		pla				pla
.0197c9	85 1e		sta $1e				sta 	zGenPtr
.0197cb	da		phx				phx
.0197cc	5a		phy				phy
.0197cd	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0197cf	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0197d2					_SLICopy:
.0197d2	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0197d5	f0 12		beq $0197e9			beq 	_SLIExit
.0197d7	ce a2 03	dec $03a2			dec 	SliceCount
.0197da	98		tya				tya 									; index of character
.0197db	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0197dd	f0 02		beq $0197e1			beq 	_SLIOk 							; if equal, okay.
.0197df	b0 08		bcs $0197e9			bcs 	_SLIExit 						; if past end, then exit.
.0197e1	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0197e3	c8		iny				iny
.0197e4	20 11 9a	jsr $019a11			jsr 	WriteTempString
.0197e7	80 e9		bra $0197d2			bra 	_SLICopy 						; go round till copied characters
.0197e9					_SLIExit:
.0197e9	7a		ply				ply 									; restore YX
.0197ea	fa		plx				plx
.0197eb	4c 0e 99	jmp $01990e			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0197ee	ea		nop				nop
.0197ef					SLIByteParameter:
.0197ef	20 45 93	jsr $019345			jsr 	EvaluateIntegerX 				; get integer
.0197f2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.0197f4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0197f6	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0197f8	d0 03		bne $0197fd			bne 	SLIError
.0197fa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0197fc	60		rts				rts
.0197fd					SLIError:
.0197fd	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.019800					Unary_Hex:
.019800	20 45 93	jsr $019345			jsr 	EvaluateIntegerX 			; numeric parameter
.019803	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.019806	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019808	20 e6 99	jsr $0199e6			jsr 	AllocateTempString			; allocate string space
.01980b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01980d	20 31 98	jsr $019831			jsr 	_UHConvert
.019810	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019812	20 31 98	jsr $019831			jsr 	_UHConvert
.019815	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019817	20 31 98	jsr $019831			jsr 	_UHConvert
.01981a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01981c	20 31 98	jsr $019831			jsr 	_UHConvert
.01981f	5a		phy				phy 								; get length of new string
.019820	a0 00		ldy #$00			ldy 	#0
.019822	b1 20		lda ($20),y			lda 	(zTempStr),y
.019824	7a		ply				ply
.019825	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.019827	d0 05		bne $01982e			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.019829	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.01982b	20 11 9a	jsr $019a11			jsr 	WriteTempString
.01982e					_UHExit:
.01982e	4c 0e 99	jmp $01990e			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019831					_UHConvert:
.019831	48		pha				pha
.019832	4a		lsr a				lsr 	a 							; do MSB
.019833	4a		lsr a				lsr 	a
.019834	4a		lsr a				lsr 	a
.019835	4a		lsr a				lsr 	a
.019836	20 3a 98	jsr $01983a			jsr 	_UHNibble
.019839	68		pla				pla 								; do LSB
.01983a					_UHNibble:
.01983a	29 0f		and #$0f			and 	#15 						; get nibble
.01983c	d0 0c		bne $01984a			bne 	_UHNonZero 					; if not zero, write it out anyway.
.01983e	5a		phy				phy									; get the length
.01983f	a0 00		ldy #$00			ldy 	#0
.019841	b1 20		lda ($20),y			lda 	(zTempStr),y
.019843	7a		ply				ply
.019844	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.019846	f0 0d		beq $019855			beq 	_UHExit2
.019848	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.01984a					_UHNonZero:
.01984a	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01984c	90 02		bcc $019850			bcc 	_UHDigit
.01984e	69 06		adc #$06			adc 	#7-1
.019850					_UHDigit:
.019850	69 30		adc #$30			adc 	#48
.019852	20 11 9a	jsr $019a11			jsr 	WriteTempString				; output to temp string.
.019855					_UHExit2:
.019855	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019856					Unary_Dec:
.019856	20 4e 93	jsr $01934e			jsr 	EvaluateStringX 			; string parameter
.019859	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.01985c	5a		phy				phy
.01985d	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01985f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019861	f0 43		beq $0198a6			beq 	_UDFail 					; must fail if zero.
.019863	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019866	a9 00		lda #$00			lda 	#0 							; set result to zero
.019868	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01986a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01986c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01986e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019870	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019872	95 85		sta $85,x			sta 	XS_Type,x
.019874					_UDConvertLoop:
.019874	5a		phy				phy 								; shift mantissa left 4
.019875	a0 04		ldy #$04			ldy 	#4
.019877					_UDShift:
.019877	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019879	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01987b	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01987d	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01987f	88		dey				dey
.019880	d0 f5		bne $019877			bne 	_UDShift
.019882	7a		ply				ply
.019883	c8		iny				iny 								; next character
.019884	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019886	20 a9 98	jsr $0198a9			jsr 	ConvertUpper 				; convert to U/C
.019889	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.01988b	90 19		bcc $0198a6			bcc 	_UDFail
.01988d	c9 3a		cmp #$3a			cmp 	#"9"+1
.01988f	90 08		bcc $019899			bcc 	_UDOkay
.019891	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.019893	90 11		bcc $0198a6			bcc 	_UDFail 					; fails if between 9 and @
.019895	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.019897	b0 0d		bcs $0198a6			bcs 	_UDFail
.019899					_UDOkay:
.019899	29 0f		and #$0f			and 	#15 						; nibble only
.01989b	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.01989d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01989f	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.0198a2	d0 d0		bne $019874			bne 	_UDConvertLoop
.0198a4	7a		ply				ply
.0198a5	60		rts				rts
.0198a6					_UDFail:
.0198a6	4c 72 85	jmp $018572			jmp 	BadParamError
.0198a9					ConvertUpper:
.0198a9	c9 61		cmp #$61			cmp 	#"a"
.0198ab	90 07		bcc $0198b4			bcc 	_CUExit
.0198ad	c9 7b		cmp #$7b			cmp 	#"z"+1
.0198af	b0 03		bcs $0198b4			bcs 	_CUExit
.0198b1	38		sec				sec
.0198b2	e9 20		sbc #$20			sbc 	#32
.0198b4	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.0198b5					Unary_Chr:
.0198b5	20 45 93	jsr $019345			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.0198b8	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; right bracket.
.0198bb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0198bd	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0198bf	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0198c1	d0 0d		bne $0198d0			bne 	_UCChar
.0198c3	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.0198c5	20 e6 99	jsr $0199e6			jsr 	AllocateTempString			; allocate it.
.0198c8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.0198ca	20 11 9a	jsr $019a11			jsr 	WriteTempString
.0198cd	4c 0e 99	jmp $01990e			jmp 	UnaryReturnTempStr 			; and return that string.
.0198d0					_UCChar:
.0198d0	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0198d3					Unary_Spc:
.0198d3	20 ef 97	jsr $0197ef			jsr 	SLIByteParameter 			; check space.
.0198d6	20 99 99	jsr $019999			jsr 	CheckNextRParen
.0198d9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0198db					UnarySpcCreate:
.0198db	c9 fe		cmp #$fe			cmp 	#maxString+1
.0198dd	b0 14		bcs $0198f3			bcs 	_USSize
.0198df	48		pha				pha 								; save length
.0198e0	1a		inc a				inc 	a 							; allocate one more.
.0198e1	20 e6 99	jsr $0199e6			jsr 	AllocateTempString
.0198e4	68		pla				pla 								; get length
.0198e5	f0 27		beq $01990e			beq 	UnaryReturnTempStr 			; return the current temp string
.0198e7					_USLoop:
.0198e7	48		pha				pha
.0198e8	a9 20		lda #$20			lda 	#" "
.0198ea	20 11 9a	jsr $019a11			jsr 	WriteTempString
.0198ed	68		pla				pla
.0198ee	3a		dec a				dec 	a
.0198ef	d0 f6		bne $0198e7			bne 	_USLoop
.0198f1	80 1b		bra $01990e			bra 	UnaryReturnTempStr
.0198f3					_USSize:
.0198f3	4c 72 85	jmp $018572			jmp 	BadParamError
.0198f6					Unary_Tab:
.0198f6	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.0198f8	20 ef 97	jsr $0197ef			jsr 	SLIByteParameter
.0198fb	20 99 99	jsr $019999			jsr 	CheckNextRParen
.0198fe	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; were are we ?
.019901	85 10		sta $10				sta 	zTemp1
.019903	38		sec				sec
.019904	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.019906	e5 10		sbc $10				sbc 	zTemp1
.019908	b0 d1		bcs $0198db			bcs 	UnarySpcCreate
.01990a	a9 00		lda #$00			lda 	#0
.01990c	80 cd		bra $0198db			bra 	UnarySpcCreate
.01990e					UnaryReturnTempStr:
.01990e	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019910	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019912	a5 21		lda $21				lda 	zTempStr+1
.019914	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019916	a9 02		lda #$02			lda 	#2 							; set type to string
.019918	95 85		sta $85,x			sta 	XS_Type,x
.01991a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.01991b					MemRead:
.01991b	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01991e	a0 00		ldy #$00			ldy 	#0 							; start from here
.019920	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.019922	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019924	c8		iny				iny 								; next to copy
.019925	e8		inx				inx
.019926	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019929	d0 f5		bne $019920			bne 	_MLoop1
.01992b	60		rts				rts
.01992c					MemWrite:
.01992c	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01992f	a0 00		ldy #$00			ldy 	#0 							; start from here
.019931	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019933	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019935	c8		iny				iny 								; next to copy
.019936	e8		inx				inx
.019937	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01993a	d0 f5		bne $019931			bne 	_MLoop1
.01993c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01993d					UpdateProgramEnd:
.01993d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01993f	85 16		sta $16				sta 	zCodePtr+0
.019941	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019943	85 17		sta $17				sta 	zCodePtr+1
.019945	a9 00		lda #$00			lda 	#0
.019947	85 18		sta $18				sta 	zCodePtr+2
.019949	85 19		sta $19				sta 	zCodePtr+3
.01994b	a0 03		ldy #$03			ldy 	#3
.01994d					_UPDLoop:
.01994d	a0 00		ldy #$00			ldy 	#0
.01994f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019951	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019953	f0 0f		beq $019964			beq 	_UPDFoundEnd
.019955	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019957	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019959	18		clc				clc
.01995a	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01995c	85 16		sta $16				sta 	zCodePtr
.01995e	90 02		bcc $019962			bcc 	_SNLNoCarry
.019960	e6 17		inc $17				inc 	zCodePtr+1
.019962					_SNLNoCarry:
.019962	80 e9		bra $01994d			bra 	_UPDLoop
.019964					_UPDFoundEnd:
.019964	18		clc				clc 								; end of program 2 on.
.019965	a5 16		lda $16				lda 	zCodePtr
.019967	69 02		adc #$02			adc 	#2
.019969	8d 04 03	sta $0304			sta 	endOfProgram
.01996c	a5 17		lda $17				lda 	zCodePtr+1
.01996e	69 00		adc #$00			adc 	#0
.019970	8d 05 03	sta $0305			sta 	endOfProgram+1
.019973	a5 18		lda $18				lda 	zCodePtr+2
.019975	69 00		adc #$00			adc		#0
.019977	8d 06 03	sta $0306			sta 	endOfProgram+2
.01997a	a5 19		lda $19				lda 	zCodePtr+3
.01997c	69 00		adc #$00			adc 	#0
.01997e	8d 07 03	sta $0307			sta 	endOfProgram+3
.019981	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019982					CheckNextToken:
.019982	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019984	d0 02		bne $019988			bne 	CTFail 						; no, then fail
.019986	c8		iny				iny
.019987	60		rts				rts
.019988					CTFail:
.019988	20 83 85	jsr $018583			jsr ERR_Handler
>01998b	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019993	74 6f 6b 65 6e 00
.019999					CheckNextRParen:
.019999	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01999b	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.01999d	d0 e9		bne $019988			bne 	CTFail 						; fail if not
.01999f	c8		iny				iny
.0199a0	60		rts				rts
.0199a1					CheckNextComma:
.0199a1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0199a3	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.0199a5	d0 e1		bne $019988			bne 	CTFail 						; fail if not
.0199a7	c8		iny				iny
.0199a8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.0199a9					StringConcrete:
.0199a9	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.0199ab	85 10		sta $10				sta 	zTemp1
.0199ad	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199af	85 11		sta $11				sta 	zTemp1+1
.0199b1	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.0199b3	b1 10		lda ($10),y			lda 	(zTemp1),y
.0199b5	f0 26		beq $0199dd			beq		_SCEmpty 					; concreting it wastes memory.
.0199b7	18		clc				clc 								; from the string pointer
.0199b8	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.0199bb	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.0199bd	8d 00 03	sta $0300			sta 	StringPtr
.0199c0	85 12		sta $12				sta 	zTemp2
.0199c2	ad 01 03	lda $0301			lda 	StringPtr+1
.0199c5	e9 00		sbc #$00			sbc 	#0
.0199c7	8d 01 03	sta $0301			sta 	StringPtr+1
.0199ca	85 13		sta $13				sta 	zTemp2+1
.0199cc	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.0199ce	1a		inc a				inc 	a
.0199cf	aa		tax				tax
.0199d0	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.0199d2	91 12		sta ($12),y			sta 	(zTemp2),y
.0199d4	c8		iny				iny
.0199d5	ca		dex				dex
.0199d6	d0 f8		bne $0199d0			bne 	_SCCopy
.0199d8	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0199da	a6 12		ldx $12				ldx 	zTemp2
.0199dc	60		rts				rts
.0199dd					_SCEmpty:
.0199dd	a9 00		lda #$00			lda 	#0
.0199df	85 25		sta $25				sta 	zNullString
.0199e1	a9 00		lda #$00			lda 	#zNullString >> 8
.0199e3	a2 25		ldx #$25			ldx 	#zNulLString & $FF
.0199e5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0199e6					AllocateTempString:
.0199e6	48		pha				pha 								; save required count.
.0199e7	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0199e9	d0 0b		bne $0199f6			bne 	_ATSInitialised
.0199eb	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0199ee	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0199f0	ad 01 03	lda $0301			lda 	StringPtr+1
.0199f3	3a		dec a				dec 	a 							; allow the page.
.0199f4	85 21		sta $21				sta 	zTempStr+1
.0199f6					_ATSInitialised:
.0199f6	68		pla				pla 								; get required count back.
.0199f7	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.0199f9	1a		inc a				inc 	a
.0199fa	18		clc				clc
.0199fb	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0199fd	85 20		sta $20				sta 	zTempStr					; which means the tsp is also the current.
.0199ff	a9 ff		lda #$ff			lda 	#$FF
.019a01	65 21		adc $21				adc 	zTempStr+1
.019a03	85 21		sta $21				sta 	zTempStr+1
.019a05	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019a07	5a		phy				phy
.019a08	a8		tay				tay
.019a09	91 20		sta ($20),y			sta 	(zTempStr),y
.019a0b	7a		ply				ply
.019a0c	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019a0d	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019a10	60		rts				rts
.019a11					WriteTempString:
.019a11	5a		phy				phy 								; save Y
.019a12	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019a15	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.019a17	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019a1a	98		tya				tya 								; unchanged Y is now length
.019a1b	a0 00		ldy #$00			ldy 	#0
.019a1d	91 20		sta ($20),y			sta 	(zTempStr),y
.019a1f	7a		ply				ply 								; restore Y and exit
.019a20	60		rts				rts
.019a21					CreateTempStringCopy:
.019a21	da		phx				phx 								; save X
.019a22	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019a24	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019a25	20 e6 99	jsr $0199e6			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019a28	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019a2a	c8		iny				iny
.019a2b	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019a2c	3a		dec a				dec 	a 							; for the marker and the length.
.019a2d	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019a2f	81 20		sta ($20,x)			sta 	(zTempStr,x)
.019a31	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.019a33	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019a35	f0 0e		beq $019a45			beq 	_CTSCExit
.019a37					_CTSCLoop:
.019a37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019a39	c8		iny				iny
.019a3a	5a		phy				phy 								; save Y
.019a3b	e8		inx				inx 								; bump index
.019a3c	da		phx				phx 								; save that
.019a3d	7a		ply				ply 								; index into Y
.019a3e	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index position
.019a40	7a		ply				ply 								; restore Y
.019a41	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character, this is the counter.
.019a43	d0 f2		bne $019a37			bne 	_CTSCLoop
.019a45					_CTSCExit:
.019a45	fa		plx				plx 								; restore X
.019a46	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019a47					VariableFind:
.019a47	20 b2 9a	jsr $019ab2			jsr 	VariableExtract 		; find out all about it ....
.019a4a	20 4b 9d	jsr $019d4b			jsr 	VariableLocate 			; does it already exist ?
.019a4d	b0 03		bcs $019a52			bcs 	_VFExists 				; if so, use that.
.019a4f	20 3e 9b	jsr $019b3e			jsr 	VariableCreate 			; otherwise create it.
.019a52					_VFExists:
.019a52	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019a54	29 01		and #$01			and 	#1
.019a56	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019a58	d0 28		bne $019a82			bne 	_VFSingleElement
.019a5a					_VFNextIndex:
.019a5a	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019a5c	48		pha				pha
.019a5d	a5 23		lda $23				lda 	zVarDataPtr+1
.019a5f	48		pha				pha
.019a60	a5 24		lda $24				lda 	zVarType
.019a62	48		pha				pha
.019a63	20 45 93	jsr $019345			jsr 	EvaluateIntegerX 		; calculate the index.
.019a66	68		pla				pla 							; restore and index.
.019a67	85 24		sta $24				sta 	zVarType
.019a69	68		pla				pla
.019a6a	85 23		sta $23				sta 	zVarDataPtr+1
.019a6c	68		pla				pla
.019a6d	85 22		sta $22				sta 	zVarDataPtr
.019a6f	20 c9 9b	jsr $019bc9			jsr 	ArrayIndexFollow 		; do the index.
.019a72	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019a74	29 01		and #$01			and 	#1
.019a76	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019a78	d0 05		bne $019a7f			bne 	_VFArrayDone 			; if so then exit.
.019a7a	20 a1 99	jsr $0199a1			jsr 	CheckNextComma 			; comma should follow
.019a7d	80 db		bra $019a5a			bra 	_VFNextIndex
.019a7f					_VFArrayDone:
.019a7f	20 99 99	jsr $019999			jsr 	CheckNextRParen 		; check closing right bracket.
.019a82					_VFSingleElement:
.019a82	60		rts				rts
.019a83					VariableClear:
.019a83	48		pha				pha 							; save registers
.019a84	da		phx				phx
.019a85	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019a87	8a		txa				txa
.019a88	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019a8b	e8		inx				inx
.019a8c	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019a8e	d0 f8		bne $019a88			bne 	_VCLoop
.019a90	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019a92	8d 02 03	sta $0302			sta 	VarMemPtr
.019a95	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019a97	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019a9a	fa		plx				plx 							; restore registers
.019a9b	68		pla				pla
.019a9c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019a9d					VariableNameError:
.019a9d	20 83 85	jsr $018583			jsr ERR_Handler
>019aa0	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019aa8	61 62 6c 65 20 4e 61 6d 65 00
.019ab2					VariableExtract:
.019ab2	da		phx				phx 							; save X.
.019ab3	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019ab5	8d 95 03	sta $0395			sta 	Var_Type
.019ab8	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019abb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019abd	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019abf	f0 dc		beq $019a9d			beq 	VariableNameError
.019ac1	c9 1b		cmp #$1b			cmp 	#26+1
.019ac3	b0 d8		bcs $019a9d			bcs 	VariableNameError
.019ac5	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019ac7					_VECopyBuffer:
.019ac7	e8		inx				inx
.019ac8	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019aca	f0 d1		beq $019a9d			beq 	VariableNameError
.019acc	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019acf	18		clc				clc  							; update the hash value for it.
.019ad0	6d 96 03	adc $0396			adc 	Var_Hash
.019ad3	8d 96 03	sta $0396			sta 	Var_Hash
.019ad6	c8		iny				iny
.019ad7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019ad9	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019adb	f0 0e		beq $019aeb			beq 	_VECopyEnd
.019add	30 0c		bmi $019aeb			bmi 	_VECopyEnd
.019adf	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019ae1	90 e4		bcc $019ac7			bcc 	_VECopyBuffer
.019ae3	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019ae5	90 04		bcc $019aeb			bcc 	_VECopyEnd
.019ae7	c9 3a		cmp #$3a			cmp 	#"9"+1
.019ae9	90 dc		bcc $019ac7			bcc 	_VECopyBuffer
.019aeb					_VECopyEnd:
.019aeb	c8		iny				iny
.019aec	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019aee	90 04		bcc $019af4			bcc 	_VEDefaultRequired
.019af0	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019af2	90 0b		bcc $019aff			bcc 	_VEHaveType
.019af4					_VEDefaultRequired:
.019af4	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019af6	f0 04		beq $019afc			beq 	_VESetType 				; default set above.
.019af8	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019afb	88		dey				dey
.019afc					_VESetType:
.019afc	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019aff					_VEHaveType:
.019aff	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019b02	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019b05	09 80		ora #$80			ora 	#$80
.019b07	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019b0a	e8		inx				inx 							; offset 3 => length 4.
.019b0b	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019b0e	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019b11	38		sec				sec
.019b12	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019b14	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019b15	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019b16	0a		asl a				asl 	a
.019b17	0a		asl a				asl 	a
.019b18	8d 98 03	sta $0398			sta 	Var_HashAddress
.019b1b	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019b1e	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019b20	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019b21	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019b24	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019b26	8d 98 03	sta $0398			sta 	Var_HashAddress
.019b29	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019b2b	ad 95 03	lda $0395			lda 	Var_Type
.019b2e	c9 b9		cmp #$b9			cmp 	#token_Hash
.019b30	f0 07		beq $019b39			beq 	_VEHaveSize
.019b32	ca		dex				dex
.019b33	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019b35	f0 02		beq $019b39			beq 	_VEHaveSize
.019b37	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019b39					_VEHaveSize:
.019b39	8e 99 03	stx $0399			stx 	Var_DataSize
.019b3c	fa		plx				plx
.019b3d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019b3e					VariableCreate:
.019b3e	da		phx				phx
.019b3f	5a		phy				phy
.019b40	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019b43	85 10		sta $10				sta 	zTemp1
.019b45	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019b48	85 11		sta $11				sta 	zTemp1+1
.019b4a	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019b4d	18		clc				clc
.019b4e	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019b51	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019b53	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019b56	8d 02 03	sta $0302			sta 	VarMemPtr
.019b59	90 03		bcc $019b5e			bcc 	_VCNoCarry
.019b5b	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019b5e					_VCNoCarry:
.019b5e	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019b61	85 12		sta $12				sta 	zTemp2
.019b63	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019b65	85 13		sta $13				sta 	zTemp2+1
.019b67	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019b69	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b6b	91 10		sta ($10),y			sta 	(zTemp1),y
.019b6d	c8		iny				iny
.019b6e	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b70	91 10		sta ($10),y			sta 	(zTemp1),y
.019b72	c8		iny				iny
.019b73	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019b76	91 10		sta ($10),y			sta 	(zTemp1),y
.019b78	c8		iny				iny
.019b79	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019b7b					_VCCopyName:
.019b7b	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019b7e	91 10		sta ($10),y			sta 	(zTemp1),y
.019b80	e8		inx				inx
.019b81	c8		iny				iny
.019b82	ec 97 03	cpx $0397			cpx 	Var_Length
.019b85	d0 f4		bne $019b7b			bne 	_VCCopyName
.019b87	5a		phy				phy 								; save the data offset.
.019b88	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019b8b	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019b8d					_VCClearData:
.019b8d	91 10		sta ($10),y			sta 	(zTemp1),y
.019b8f	c8		iny				iny
.019b90	ca		dex				dex
.019b91	d0 fa		bne $019b8d			bne 	_VCClearData
.019b93	68		pla				pla 								; offset to the data
.019b94	18		clc				clc
.019b95	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019b97	85 22		sta $22				sta 	zVarDataPtr
.019b99	a5 11		lda $11				lda 	zTemp1+1
.019b9b	69 00		adc #$00			adc 	#0
.019b9d	85 23		sta $23				sta 	zVarDataPtr+1
.019b9f	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019ba2	85 24		sta $24				sta 	zVarType
.019ba4	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019ba6	a0 00		ldy #$00			ldy 	#0
.019ba8	91 12		sta ($12),y			sta 	(zTemp2),y
.019baa	c8		iny				iny
.019bab	a5 11		lda $11				lda 	zTemp1+1
.019bad	91 12		sta ($12),y			sta 	(zTemp2),y
.019baf	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019bb2	29 01		and #$01			and 	#1
.019bb4	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019bb6	d0 0e		bne $019bc6			bne 	_VCNotArray
.019bb8	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019bba	20 60 9c	jsr $019c60			jsr 	ArrayCreate
.019bbd	5a		phy				phy 								; save YA at zVarDataPtr
.019bbe	a0 00		ldy #$00			ldy 	#0
.019bc0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bc2	c8		iny				iny
.019bc3	68		pla				pla
.019bc4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bc6					_VCNotArray:
.019bc6	7a		ply				ply
.019bc7	fa		plx				plx
.019bc8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019bc9					ArrayIndexFollow:
.019bc9	5a		phy				phy
.019bca	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019bcc	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019bce	48		pha				pha
.019bcf	c8		iny				iny
.019bd0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019bd2	85 23		sta $23				sta 	zVarDataPtr+1
.019bd4	68		pla				pla
.019bd5	85 22		sta $22				sta 	zVarDataPtr
.019bd7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019bd9	29 80		and #$80			and 	#$80 						; must be zero.
.019bdb	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019bdd	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019bdf	d0 59		bne $019c3a			bne 	_AIFError
.019be1	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019be3	18		clc				clc
.019be4	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019be6	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019be8	c8		iny				iny
.019be9	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019beb	08		php				php 								; clear bit 7 retaining borrow.
.019bec	29 7f		and #$7f			and 	#$7F
.019bee	28		plp				plp
.019bef	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019bf1	90 47		bcc $019c3a			bcc 	_AIFError 					; eror if size-current < 0
.019bf3	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019bf5	0a		asl a				asl 	a 							; (e.g. index * 2)
.019bf6	85 10		sta $10				sta 	zTemp1
.019bf8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019bfa	2a		rol a				rol 	a
.019bfb	85 11		sta $11				sta 	zTemp1+1
.019bfd	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019bff	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019c01	30 1d		bmi $019c20			bmi 	_AIFCalculate
.019c03	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.019c05	a5 24		lda $24				lda 	zVarType 					; check that type
.019c07	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019c09	f0 15		beq $019c20			beq 	_AIFCalculate
.019c0b	06 10		asl $10				asl 	zTemp1			 			; double the index
.019c0d	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019c0f	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019c11	f0 0d		beq $019c20			beq 	_AIFCalculate
.019c13	18		clc				clc 								; add the original mantissa in again
.019c14	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019c16	65 10		adc $10				adc 	zTemp1
.019c18	85 10		sta $10				sta 	zTemp1
.019c1a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c1c	65 11		adc $11				adc 	zTemp1+1
.019c1e	85 11		sta $11				sta 	zTemp1+1
.019c20					_AIFCalculate:
.019c20	18		clc				clc 								; add index x 2,4 or 5 to base
.019c21	a5 22		lda $22				lda 	zVarDataPtr
.019c23	65 10		adc $10				adc 	zTemp1
.019c25	85 22		sta $22				sta 	zVarDataPtr
.019c27	a5 23		lda $23				lda 	zVarDataPtr+1
.019c29	65 11		adc $11				adc 	zTemp1+1
.019c2b	85 23		sta $23				sta 	zVarDataPtr+1
.019c2d	18		clc				clc 								; add 2 more for the length prefix.
.019c2e	a5 22		lda $22				lda 	zVarDataPtr
.019c30	69 02		adc #$02			adc 	#2
.019c32	85 22		sta $22				sta 	zVarDataPtr
.019c34	90 02		bcc $019c38			bcc 	_AIFNoBump
.019c36	e6 23		inc $23				inc 	zVarDataPtr+1
.019c38					_AIFNoBump:
.019c38	7a		ply				ply
.019c39	60		rts				rts
.019c3a					_AIFError:
.019c3a	20 83 85	jsr $018583			jsr ERR_Handler
>019c3d	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019c45	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019c4d					ArrayResetDefault:
.019c4d	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019c4f	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019c52	a9 00		lda #$00			lda 	#0
.019c54	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019c57	a9 ff		lda #$ff			lda 	#$FF
.019c59	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019c5c	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019c5f	60		rts				rts
.019c60					ArrayCreate:
.019c60	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019c63	0a		asl a				asl 	a
.019c64	85 10		sta $10				sta 	zTemp1
.019c66	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019c69	2a		rol a				rol 	a
.019c6a	85 11		sta $11				sta 	zTemp1+1
.019c6c	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019c6f	10 22		bpl $019c93			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019c71	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019c74	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019c76	f0 1b		beq $019c93			beq 	_ACSized
.019c78	06 10		asl $10				asl 	zTemp1 						; double again
.019c7a	26 11		rol $11				rol 	zTemp1+1
.019c7c	b0 6f		bcs $019ced			bcs 	ArrayIndexError 			; too large.
.019c7e	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019c80	f0 11		beq $019c93			beq 	_ACSized
.019c82	18		clc				clc 								; add original value x 5 for reals.
.019c83	a5 10		lda $10				lda 	zTemp1
.019c85	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019c88	85 10		sta $10				sta 	zTemp1
.019c8a	a5 11		lda $11				lda 	zTemp1+1
.019c8c	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019c8f	85 11		sta $11				sta 	zTemp1+1
.019c91	b0 5a		bcs $019ced			bcs 	ArrayIndexError
.019c93					_ACSized:
.019c93	18		clc				clc
.019c94	a5 10		lda $10				lda 	zTemp1
.019c96	69 02		adc #$02			adc 	#2
.019c98	85 10		sta $10				sta 	zTemp1
.019c9a	90 04		bcc $019ca0			bcc 	_ACNoBump
.019c9c	e6 10		inc $10				inc 	zTemp1
.019c9e	f0 4d		beq $019ced			beq 	ArrayIndexError
.019ca0					_ACNoBump:
.019ca0	18		clc				clc
.019ca1	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019ca4	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019ca6	85 14		sta $14				sta 	zTemp3
.019ca8	65 10		adc $10				adc 	zTemp1
.019caa	8d 02 03	sta $0302			sta 	VarMemPtr
.019cad	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019cb0	85 13		sta $13				sta 	zTemp2+1
.019cb2	85 15		sta $15				sta 	zTemp3+1
.019cb4	65 11		adc $11				adc 	zTemp1+1
.019cb6	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019cb9	85 11		sta $11				sta 	zTemp1+1
.019cbb	b0 30		bcs $019ced			bcs 	ArrayIndexError
.019cbd	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019cbf					_ACClear:
.019cbf	98		tya				tya
.019cc0	91 12		sta ($12),y			sta 	(zTemp2),y
.019cc2	e6 12		inc $12				inc 	zTemp2
.019cc4	d0 02		bne $019cc8			bne 	_ACCBump
.019cc6	e6 13		inc $13				inc 	zTemp2+1
.019cc8					_ACCBump:
.019cc8	a5 12		lda $12				lda 	zTemp2
.019cca	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019ccd	d0 f0		bne $019cbf			bne 	_ACClear
.019ccf	a5 13		lda $13				lda 	zTemp2+1
.019cd1	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019cd4	d0 e9		bne $019cbf			bne 	_ACClear
.019cd6	a0 00		ldy #$00			ldy 	#0
.019cd8	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019cdb	91 14		sta ($14),y			sta 	(zTemp3),y
.019cdd	c8		iny				iny
.019cde	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019ce1	91 14		sta ($14),y			sta 	(zTemp3),y
.019ce3	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019ce6	10 18		bpl $019d00			bpl 	ACCFillRecursive
.019ce8	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019cea	a5 14		lda $14				lda 	zTemp3
.019cec	60		rts				rts
.019ced					ArrayIndexError:
.019ced	20 83 85	jsr $018583			jsr ERR_Handler
>019cf0	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019cf8	79 20 69 6e 64 65 78 00
.019d00					ACCFillRecursive:
.019d00	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019d02	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019d04	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019d06	c8		iny				iny
.019d07	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019d09	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019d0b	91 14		sta ($14),y			sta 	(zTemp3),y
.019d0d	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019d0f	48		pha				pha
.019d10	a5 15		lda $15				lda 	zTemp3+1
.019d12	48		pha				pha
.019d13					_ACCFillLoop:
.019d13	18		clc				clc
.019d14	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019d16	69 02		adc #$02			adc 	#2
.019d18	85 14		sta $14				sta 	zTemp3
.019d1a	90 02		bcc $019d1e			bcc 	_ACCSkip2
.019d1c	e6 15		inc $15				inc 	zTemp3+1
.019d1e					_ACCSkip2:
.019d1e	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019d20	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019d22	c8		iny				iny
.019d23	11 14		ora ($14),y			ora 	(zTemp3),y
.019d25	d0 21		bne $019d48			bne 	_ACCExit
.019d27	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019d29	48		pha				pha
.019d2a	a5 15		lda $15				lda 	zTemp3+1
.019d2c	48		pha				pha
.019d2d	e8		inx				inx
.019d2e	e8		inx				inx
.019d2f	20 60 9c	jsr $019c60			jsr 	ArrayCreate 				; create array recursively.
.019d32	ca		dex				dex
.019d33	ca		dex				dex
.019d34	85 12		sta $12				sta 	zTemp2 						; save A
.019d36	68		pla				pla
.019d37	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019d39	68		pla				pla
.019d3a	85 14		sta $14				sta 	zTemp3
.019d3c	98		tya				tya 								; write high bye from Y
.019d3d	a0 01		ldy #$01			ldy 	#1
.019d3f	91 14		sta ($14),y			sta 	(zTemp3),y
.019d41	88		dey				dey 								; write low byte out.
.019d42	a5 12		lda $12				lda 	zTemp2
.019d44	91 14		sta ($14),y			sta 	(zTemp3),y
.019d46	80 cb		bra $019d13			bra 	_ACCFillLoop 				; and try again.
.019d48					_ACCExit:
.019d48	7a		ply				ply 								; restore the original address
.019d49	68		pla				pla
.019d4a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019d4b					VariableLocate:
.019d4b	da		phx				phx
.019d4c	5a		phy				phy
.019d4d	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019d50	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019d52	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019d54	85 13		sta $13				sta 	zTemp2+1
.019d56	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019d58	b1 12		lda ($12),y			lda 	(zTemp2),y
.019d5a	aa		tax				tax
.019d5b	c8		iny				iny
.019d5c	b1 12		lda ($12),y			lda 	(zTemp2),y
.019d5e	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019d60	86 12		stx $12				stx 	zTemp2
.019d62	05 12		ora $12				ora 	zTemp2 						; got zero
.019d64	18		clc				clc
.019d65	f0 25		beq $019d8c			beq 	_VLExit 					; if so, then fail as end of chain.
.019d67	c8		iny				iny 								; point to hash (offset + 2)
.019d68	b1 12		lda ($12),y			lda 	(zTemp2),y
.019d6a	cd 96 03	cmp $0396			cmp 	Var_Hash
.019d6d	d0 e7		bne $019d56			bne 	_VLNext 					; try next if different.
.019d6f					_VLCompare:
.019d6f	c8		iny				iny 								; next character
.019d70	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019d72	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019d75	d0 df		bne $019d56			bne 	_VLNext 					; fail if different, try next.
.019d77	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019d78	90 f5		bcc $019d6f			bcc 	_VLCompare
.019d7a	98		tya				tya
.019d7b	38		sec				sec 								; add 1 as Y points to last character
.019d7c	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019d7e	85 22		sta $22				sta 	zVarDataPtr
.019d80	a5 13		lda $13				lda 	zTemp2+1
.019d82	69 00		adc #$00			adc 	#0
.019d84	85 23		sta $23				sta 	zVarDataPtr+1
.019d86	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019d89	85 24		sta $24				sta 	zVarType
.019d8b	38		sec				sec 								; return CS
.019d8c	7a		ply		_VLExit:ply
.019d8d	fa		plx				plx
.019d8e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019d8f					VariableGet:
.019d8f	5a		phy				phy
.019d90	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019d92	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019d94	95 80		sta $80,x			sta 	XS_Mantissa,x
.019d96	c8		iny				iny
.019d97	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019d99	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d9b	c8		iny				iny
.019d9c	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019d9e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019da0	f0 2c		beq $019dce			beq 	_VGString
.019da2	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019da4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019da6	c8		iny				iny
.019da7	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019da9	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019dab	c8		iny				iny
.019dac	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019dae	95 85		sta $85,x			sta 	XS_Type,x
.019db0	a5 24		lda $24				lda 	zVarType
.019db2	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019db4	f0 28		beq $019dde			beq 	_VGExit
.019db6	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019db8	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019dba	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019dbc	95 84		sta $84,x			sta 	XS_Exponent,x
.019dbe	f0 1e		beq $019dde			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019dc0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019dc2	48		pha				pha
.019dc3	29 80		and #$80			and 	#$80
.019dc5	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019dc7	68		pla				pla
.019dc8	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019dca	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019dcc	80 10		bra $019dde			bra 	_VGExit
.019dce					_VGString:
.019dce	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019dd0	95 85		sta $85,x			sta 	XS_Type,x
.019dd2	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019dd4	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019dd6	d0 06		bne $019dde			bne 	_VGExit 					; if not, exit.
.019dd8	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019dda	a9 25		lda #$25			lda 	#zNullString
.019ddc	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019dde					_VGExit:
.019dde	7a		ply				ply
.019ddf	60		rts				rts
.019de0					VariableSet:
.019de0	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019de2	29 02		and #$02			and 	#2 							; if so, it has to be
.019de4	d0 4b		bne $019e31			bne 	_VSString
.019de6	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019de8	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019dea	f0 42		beq $019e2e			beq 	_VSBadType
.019dec	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019dee	f0 05		beq $019df5			beq 	_VSMakeInt
.019df0	20 56 a3	jsr $01a356			jsr 	FPUToFloat
.019df3	80 03		bra $019df8			bra 	_VSCopy
.019df5					_VSMakeInt:
.019df5	20 a2 a3	jsr $01a3a2			jsr 	FPUToInteger
.019df8					_VSCopy:
.019df8	5a		phy				phy
.019df9	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019dfb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019dfd	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019dff	c8		iny				iny
.019e00	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e02	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e04	c8		iny				iny
.019e05	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e07	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e09	c8		iny				iny
.019e0a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019e0c	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e0e	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019e10	c9 bb		cmp #$bb			cmp 	#token_Percent
.019e12	f0 18		beq $019e2c			beq 	_VSExit
.019e14	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019e16	0a		asl a				asl 	a
.019e17	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019e19	08		php				php
.019e1a	0a		asl a				asl 	a
.019e1b	28		plp				plp
.019e1c	6a		ror a				ror 	a
.019e1d	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e1f	c8		iny				iny
.019e20	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019e22	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e24	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019e26	50 04		bvc $019e2c			bvc 	_VSExit
.019e28	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019e2a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e2c					_VSExit:
.019e2c	7a		ply				ply
.019e2d	60		rts				rts
.019e2e					_VSBadType:
.019e2e	4c 64 85	jmp $018564			jmp 	TypeError
.019e31					_VSString:
.019e31	a5 24		lda $24				lda 	zVarType 					; type must be $
.019e33	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019e35	d0 f7		bne $019e2e			bne 	_VSBadType
.019e37	da		phx				phx
.019e38	5a		phy				phy
.019e39	20 a9 99	jsr $0199a9			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019e3c	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019e3e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e40	88		dey				dey 								; save low byte
.019e41	8a		txa				txa
.019e42	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019e44	7a		ply				ply 								; and exit.
.019e45	fa		plx				plx
.019e46	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019e47					MulInteger32:
.019e47	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019e49	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019e4b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e4d	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019e4f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e51	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019e53	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019e55	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019e57	a9 00		lda #$00			lda 	#0
.019e59	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.019e5b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e5d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e5f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019e61					_BFMMultiply:
.019e61	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019e63	29 01		and #$01			and 	#1
.019e65	f0 03		beq $019e6a			beq 	_BFMNoAdd
.019e67	20 e5 94	jsr $0194e5			jsr 	AddInteger32 					; co-opt this code
.019e6a					_BFMNoAdd:
.019e6a	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019e6c	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019e6e	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019e70	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019e72	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019e74	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019e76	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019e78	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019e7a	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019e7c	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019e7e	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019e80	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019e82	d0 dd		bne $019e61			bne 	_BFMMultiply
.019e84	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019e85					DivInteger32:
.019e85	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.019e87	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019e89	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019e8b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019e8d	d0 14		bne $019ea3			bne 	_BFDOkay
.019e8f	20 83 85	jsr $018583			jsr ERR_Handler
>019e92	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019e9a	20 62 79 20 5a 65 72 6f 00
.019ea3					_BFDOkay:
.019ea3	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019ea5	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019ea7	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019ea9	85 1c		sta $1c				sta 	zLTemp1+2
.019eab	85 1d		sta $1d				sta 	zLTemp1+3
.019ead	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019eb0	20 07 9f	jsr $019f07			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019eb3	da		phx				phx
.019eb4	e8		inx				inx
.019eb5	e8		inx				inx
.019eb6	e8		inx				inx
.019eb7	e8		inx				inx
.019eb8	e8		inx				inx
.019eb9	e8		inx				inx
.019eba	20 07 9f	jsr $019f07			jsr 	CheckIntegerNegate
.019ebd	fa		plx				plx
.019ebe	5a		phy				phy 								; Y is the counter
.019ebf	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019ec1					_BFDLoop:
.019ec1	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019ec3	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019ec5	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019ec7	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019ec9	26 1a		rol $1a				rol 	zLTemp1
.019ecb	26 1b		rol $1b				rol 	zLTemp1+1
.019ecd	26 1c		rol $1c				rol 	zLTemp1+2
.019ecf	26 1d		rol $1d				rol 	zLTemp1+3
.019ed1	38		sec				sec
.019ed2	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019ed4	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019ed6	48		pha				pha
.019ed7	a5 1b		lda $1b				lda 	zLTemp1+1
.019ed9	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019edb	48		pha				pha
.019edc	a5 1c		lda $1c				lda 	zLTemp1+2
.019ede	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019ee0	48		pha				pha
.019ee1	a5 1d		lda $1d				lda 	zLTemp1+3
.019ee3	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019ee5	90 13		bcc $019efa			bcc 	_BFDNoAdd
.019ee7	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019ee9	68		pla				pla
.019eea	85 1c		sta $1c				sta 	zLTemp1+2
.019eec	68		pla				pla
.019eed	85 1b		sta $1b				sta 	zLTemp1+1
.019eef	68		pla				pla
.019ef0	85 1a		sta $1a				sta 	zLTemp1+0
.019ef2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019ef4	09 01		ora #$01			ora 	#1
.019ef6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ef8	80 03		bra $019efd			bra 	_BFDNext
.019efa					_BFDNoAdd:
.019efa	68		pla				pla 								; Throw away the intermediate calculations
.019efb	68		pla				pla
.019efc	68		pla				pla
.019efd					_BFDNext:
.019efd	88		dey				dey
.019efe	d0 c1		bne $019ec1			bne 	_BFDLoop
.019f00	7a		ply				ply 								; restore Y
.019f01	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019f04	b0 06		bcs $019f0c			bcs		IntegerNegateAlways 		; negate the result
.019f06	60		rts				rts
.019f07					CheckIntegerNegate:
.019f07	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.019f09	30 01		bmi $019f0c			bmi 	IntegerNegateAlways 		; if so negate it
.019f0b	60		rts				rts
.019f0c					IntegerNegateAlways:
.019f0c	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.019f0f	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.019f10	a9 00		lda #$00			lda 	#0
.019f12	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019f14	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f16	a9 00		lda #$00			lda 	#0
.019f18	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019f1a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f1c	a9 00		lda #$00			lda 	#0
.019f1e	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019f20	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f22	a9 00		lda #$00			lda 	#0
.019f24	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019f26	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f28	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019f29					INTToString:
.019f29	48		pha				pha
.019f2a	5a		phy				phy
.019f2b	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019f2d	10 08		bpl $019f37			bpl 		_ITSNotMinus
.019f2f	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019f31	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter
.019f34	20 0c 9f	jsr $019f0c			jsr 		IntegerNegateAlways 	; negate the number.
.019f37					_ITSNotMinus:
.019f37	a9 00		lda #$00			lda 		#0
.019f39	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019f3c	8a		txa				txa 								; use Y for the mantissa index.
.019f3d	a8		tay				tay
.019f3e	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019f40					_ITSNextSubtractor:
.019f40	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019f42	8d 9b 03	sta $039b			sta 		NumConvCount
.019f45					_ITSSubtract:
.019f45	38		sec				sec
.019f46	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019f49	ff a7 9f 01	sbc $019fa7,x			sbc 		_ITSSubtractors+0,x
.019f4d	48		pha				pha
.019f4e	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019f51	ff a8 9f 01	sbc $019fa8,x			sbc 		_ITSSubtractors+1,x
.019f55	48		pha				pha
.019f56	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019f59	ff a9 9f 01	sbc $019fa9,x			sbc 		_ITSSubtractors+2,x
.019f5d	48		pha				pha
.019f5e	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019f61	ff aa 9f 01	sbc $019faa,x			sbc 		_ITSSubtractors+3,x
.019f65	90 14		bcc $019f7b			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019f67	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019f6a	68		pla				pla
.019f6b	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019f6e	68		pla				pla
.019f6f	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019f72	68		pla				pla
.019f73	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019f76	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019f79	80 ca		bra $019f45			bra 		_ITSSubtract 			; go round again.
.019f7b					_ITSCantSubtract:
.019f7b	68		pla				pla 								; throw away interim answers
.019f7c	68		pla				pla
.019f7d	68		pla				pla
.019f7e	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019f81	c9 30		cmp #$30			cmp 		#"0"
.019f83	d0 05		bne $019f8a			bne 		_ITSOutputDigit
.019f85	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019f88	10 09		bpl $019f93			bpl	 		_ITSGoNextSubtractor
.019f8a					_ITSOutputDigit:
.019f8a	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019f8d	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019f90	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter 		; output it.
.019f93					_ITSGoNextSubtractor:
.019f93	e8		inx				inx 								; next dword
.019f94	e8		inx				inx
.019f95	e8		inx				inx
.019f96	e8		inx				inx
.019f97	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019f99	d0 a5		bne $019f40			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019f9b	98		tya				tya 								; X is back as the mantissa index
.019f9c	aa		tax				tax
.019f9d	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019f9f	09 30		ora #$30			ora 		#"0"
.019fa1	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter
.019fa4	7a		ply				ply 								; and exit
.019fa5	68		pla				pla
.019fa6	60		rts				rts
.019fa7					_ITSSubtractors:
>019fa7	00 ca 9a 3b					.dword 		1000000000
>019fab	00 e1 f5 05					.dword 		100000000
>019faf	80 96 98 00					.dword 		10000000
>019fb3	40 42 0f 00					.dword 		1000000
>019fb7	a0 86 01 00					.dword 		100000
>019fbb	10 27 00 00					.dword 		10000
>019fbf	e8 03 00 00					.dword 		1000
>019fc3	64 00 00 00					.dword 		100
>019fc7	0a 00 00 00					.dword 		10
.019fcb					_ITSSubtractorsEnd:
.019fcb					ITSOutputCharacter:
.019fcb	48		pha				pha
.019fcc	da		phx				phx
.019fcd	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019fd0	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019fd3	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019fd5	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019fd8	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019fdb	fa		plx				plx
.019fdc	68		pla				pla
.019fdd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019fde					IntFromString:
.019fde	a0 00		ldy #$00			ldy 	#0
.019fe0	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019fe3					IntFromStringY:
.019fe3	48		pha				pha
.019fe4	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019fe6	95 80		sta $80,x			sta 	XS_Mantissa,x
.019fe8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fea	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fec	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fee	a9 01		lda #$01			lda 	#1
.019ff0	95 85		sta $85,x			sta 	XS_Type,x
.019ff2					_IFSLoop:
.019ff2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019ff4	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019ff6	90 4e		bcc $01a046			bcc 	_IFSExit
.019ff8	c9 3a		cmp #$3a			cmp 	#"9"+1
.019ffa	b0 4a		bcs $01a046			bcs 	_IFSExit
.019ffc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019ffe	c9 0c		cmp #$0c			cmp 	#12
.01a000	b0 4e		bcs $01a050			bcs 	_IFSOverflow
.01a002	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a004	48		pha				pha
.01a005	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a007	48		pha				pha
.01a008	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a00a	48		pha				pha
.01a00b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a00d	48		pha				pha
.01a00e	20 65 a0	jsr $01a065			jsr 	IFSX1ShiftLeft 				; double
.01a011	20 65 a0	jsr $01a065			jsr 	IFSX1ShiftLeft 				; x 4
.01a014	18		clc				clc 								; add saved value x 5
.01a015	68		pla				pla
.01a016	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a018	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a01a	68		pla				pla
.01a01b	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a01d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a01f	68		pla				pla
.01a020	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a022	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a024	68		pla				pla
.01a025	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a027	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a029	20 65 a0	jsr $01a065			jsr 	IFSX1ShiftLeft 				; x 10
.01a02c	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a02f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.01a031	29 0f		and #$0f			and 	#15
.01a033	c8		iny				iny
.01a034	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a036	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a038	90 b8		bcc $019ff2			bcc 	_IFSLoop
.01a03a	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a03c	d0 b4		bne $019ff2			bne 	_IFSLoop
.01a03e	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a040	d0 b0		bne $019ff2			bne 	_IFSLoop
.01a042	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a044	80 ac		bra $019ff2			bra 	_IFSLoop
.01a046					_IFSExit:
.01a046	98		tya				tya 								; get offset
.01a047					_IFSOkay:
.01a047	38		sec				sec
.01a048	ad 9c 03	lda $039c			lda 	ExpTemp
.01a04b	f0 01		beq $01a04e			beq 	_IFSSkipFail
.01a04d	18		clc				clc
.01a04e					_IFSSkipFail:
.01a04e	68		pla				pla 								; and exit.
.01a04f	60		rts				rts
.01a050					_IFSOverflow:
.01a050	20 83 85	jsr $018583			jsr 	ERR_Handler
>01a053	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a05b	20 6f 76 65 72 66 6c 6f 77 00
.01a065					IFSX1ShiftLeft:
.01a065	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a067	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a069	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a06b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a06d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a06e					FPSubtract:
.01a06e	48		pha				pha
.01a06f	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a071	49 80		eor #$80			eor 	#$80
.01a073	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a075	68		pla				pla 								; --- and fall through ---
.01a076					FPAdd:
.01a076	48		pha				pha
.01a077	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a079	d0 05		bne $01a080			bne 	_FPA_NegativeLHS
.01a07b	20 97 a0	jsr $01a097			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a07e	68		pla				pla
.01a07f	60		rts				rts
.01a080					_FPA_NegativeLHS:
.01a080	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a082	49 80		eor #$80			eor 	#$80
.01a084	95 85		sta $85,x			sta 	XS_Type,x
.01a086	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a088	49 80		eor #$80			eor 	#$80
.01a08a	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a08c	20 97 a0	jsr $01a097			jsr 	FPAdd_Worker 				; do the add calculation.
.01a08f	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a091	49 80		eor #$80			eor 	#$80
.01a093	95 85		sta $85,x			sta 	XS_Type,x
.01a095	68		pla				pla
.01a096	60		rts				rts
.01a097					FPAdd_Worker:
.01a097	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a099	70 07		bvs $01a0a2			bvs 	_FPAWExit 					; no change.
.01a09b	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a09d	50 07		bvc $01a0a6			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a09f	20 14 a3	jsr $01a314			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a0a2					_FPAWExit:
.01a0a2	20 83 a3	jsr $01a383			jsr 	FPUNormalise 				; normalise the result.
.01a0a5	60		rts				rts
.01a0a6					_FPAWMakeSame:
.01a0a6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a0a8	38		sec				sec
.01a0a9	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a0ab	f0 16		beq $01a0c3			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a0ad	da		phx				phx 								; save X
.01a0ae	90 06		bcc $01a0b6			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a0b0	e8		inx				inx
.01a0b1	e8		inx				inx
.01a0b2	e8		inx				inx
.01a0b3	e8		inx				inx
.01a0b4	e8		inx				inx
.01a0b5	e8		inx				inx
.01a0b6					_FPAWShiftA:
.01a0b6	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a0b8	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a0ba	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a0bc	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a0be	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a0c0	fa		plx				plx 								; restore original X
.01a0c1	80 e3		bra $01a0a6			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a0c3					_FPAW_DoArithmetic:
.01a0c3	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a0c5	30 28		bmi $01a0ef			bmi 	_FPAW_BNegative
.01a0c7	18		clc				clc
.01a0c8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a0ca	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a0cc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a0ce	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0d0	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a0d2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0d4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0d6	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a0d8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0da	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0dc	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a0de	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0e0	90 c0		bcc $01a0a2			bcc 	_FPAWExit 					; no carry.
.01a0e2	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a0e4	38		sec				sec
.01a0e5	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a0e7	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a0e9	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a0eb	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a0ed	80 b3		bra $01a0a2			bra 	_FPAWExit
.01a0ef					_FPAW_BNegative:
.01a0ef	38		sec				sec
.01a0f0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a0f2	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a0f4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a0f6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0f8	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a0fa	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0fc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0fe	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a100	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a102	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a104	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a106	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a108	b0 09		bcs $01a113			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a10a	20 3a a3	jsr $01a33a			jsr 	FPUNegateInteger			; negate the mantissa
.01a10d	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a10f	49 80		eor #$80			eor 	#$80
.01a111	95 85		sta $85,x			sta 	XS_Type,x
.01a113					_FPAWGoExit:
.01a113	4c a2 a0	jmp $01a0a2			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a116					FPD_IsDivZero:
.01a116	20 83 85	jsr $018583			jsr ERR_Handler
>01a119	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a121	20 62 79 20 7a 65 72 6f 00
.01a12a					FPDivide:
.01a12a	48		pha				pha
.01a12b	5a		phy				phy
.01a12c	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a12e	70 e6		bvs $01a116			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a130	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a132	f0 03		beq $01a137			beq 	_FPDCalculateExp
.01a134					_FPD_Exit:
.01a134	7a		ply				ply
.01a135	68		pla				pla
.01a136	60		rts				rts
.01a137					_FPDCalculateExp:
.01a137	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a139	49 ff		eor #$ff			eor 	#$FF
.01a13b	1a		inc a				inc 	a
.01a13c	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a13e	20 0e a2	jsr $01a20e			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a141	18		clc				clc 	 							; add 1 to the resulting exponent
.01a142	69 01		adc #$01			adc 	#1
.01a144	b0 54		bcs $01a19a			bcs 	_FPD_Overflow 				; which can overflow.
.01a146	95 84		sta $84,x			sta 	XS_Exponent,x
.01a148	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a14a	85 1a		sta $1a				sta 	zLTemp1+0
.01a14c	85 1b		sta $1b				sta 	zLTemp1+1
.01a14e	85 1c		sta $1c				sta 	zLTemp1+2
.01a150	85 1d		sta $1d				sta 	zLTemp1+3
.01a152	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a154					_FPD_Loop:
.01a154	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a155	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a157	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a159	48		pha				pha
.01a15a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a15c	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a15e	48		pha				pha
.01a15f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a161	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a163	48		pha				pha
.01a164	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a166	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a168	90 13		bcc $01a17d			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a16a	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a16c	68		pla				pla
.01a16d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a16f	68		pla				pla
.01a170	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a172	68		pla				pla
.01a173	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a175	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.01a177	09 80		ora #$80			ora 	#$80
.01a179	85 1d		sta $1d				sta 	zLTemp1+3
.01a17b	80 03		bra $01a180			bra 	_FPD_Rotates
.01a17d					_FPD_NoSubtract:
.01a17d	68		pla				pla 								; throw away unwanted results
.01a17e	68		pla				pla
.01a17f	68		pla				pla
.01a180					_FPD_Rotates:
.01a180	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a182	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a184	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a186	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a188	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.01a18a	26 1b		rol $1b				rol 	zLTemp1+1
.01a18c	26 1c		rol $1c				rol 	zLTemp1+2
.01a18e	26 1d		rol $1d				rol 	zLTemp1+3
.01a190	90 02		bcc $01a194			bcc 	_FPD_NoCarry
.01a192	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.01a194					_FPD_NoCarry:
.01a194	88		dey				dey 								; do 32 times
.01a195	d0 bd		bne $01a154			bne 	_FPD_Loop
.01a197	4c f2 a1	jmp $01a1f2			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a19a					_FPD_Overflow:
.01a19a	4c e0 a3	jmp $01a3e0			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a19d					FPMultiply:
.01a19d	48		pha				pha
.01a19e	5a		phy				phy
.01a19f	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a1a1	70 07		bvs $01a1aa			bvs 	_FPM_Exit
.01a1a3	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a1a5	50 06		bvc $01a1ad			bvc 	_FPM_CalcExponent
.01a1a7	20 14 a3	jsr $01a314			jsr 	FPUCopyX2ToX1
.01a1aa					_FPM_Exit:
.01a1aa	7a		ply				ply
.01a1ab	68		pla				pla
.01a1ac	60		rts				rts
.01a1ad					_FPM_CalcExponent:
.01a1ad	18		clc				clc
.01a1ae	20 0e a2	jsr $01a20e			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a1b1	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a1b3	a9 00		lda #$00			lda 	#0
.01a1b5	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a1b7	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a1b9	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a1bb	85 1d		sta $1d				sta 	zLTemp1+3
.01a1bd	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a1bf					_FPM_Loop:
.01a1bf	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a1c1	29 01		and #$01			and 	#1
.01a1c3	18		clc				clc 								; clear carry for the long rotate.
.01a1c4	f0 19		beq $01a1df			beq 	_FPM_NoAddition
.01a1c6	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a1c7	a5 1a		lda $1a				lda 	zLTemp1+0
.01a1c9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a1cb	85 1a		sta $1a				sta 	zLTemp1+0
.01a1cd	a5 1b		lda $1b				lda 	zLTemp1+1
.01a1cf	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a1d1	85 1b		sta $1b				sta 	zLTemp1+1
.01a1d3	a5 1c		lda $1c				lda 	zLTemp1+2
.01a1d5	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a1d7	85 1c		sta $1c				sta 	zLTemp1+2
.01a1d9	a5 1d		lda $1d				lda 	zLTemp1+3
.01a1db	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a1dd	85 1d		sta $1d				sta 	zLTemp1+3
.01a1df					_FPM_NoAddition:
.01a1df	66 1d		ror $1d				ror 	3+zLTemp1
.01a1e1	66 1c		ror $1c				ror 	2+zLTemp1
.01a1e3	66 1b		ror $1b				ror 	1+zLTemp1
.01a1e5	66 1a		ror $1a				ror 	0+zLTemp1
.01a1e7	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a1e9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a1eb	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a1ed	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a1ef	88		dey				dey
.01a1f0	d0 cd		bne $01a1bf			bne 	_FPM_Loop 					; do this 32 times.
.01a1f2					FPM_CopySignNormalize:
.01a1f2	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a1f4	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a1f6	a5 1b		lda $1b				lda 	zLTemp1+1
.01a1f8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1fa	a5 1c		lda $1c				lda 	zLTemp1+2
.01a1fc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1fe	a5 1d		lda $1d				lda 	zLTemp1+3
.01a200	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a202	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a204	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a206	95 85		sta $85,x			sta 	XS_Type,x
.01a208	20 83 a3	jsr $01a383			jsr 	FPUNormalise 				; normalise and exit.
.01a20b	7a		ply				ply
.01a20c	68		pla				pla
.01a20d	60		rts				rts
.01a20e					FPCalculateExponent:
.01a20e	18		clc				clc
.01a20f	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a211	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a213	b0 08		bcs $01a21d			bcs 	_FPCECarry 					; carry out ?
.01a215	10 03		bpl $01a21a			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a217	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a219	60		rts				rts
.01a21a					_FPCEExpZero:
.01a21a	a9 00		lda #$00			lda 	#0
.01a21c	60		rts				rts
.01a21d					_FPCECarry:
.01a21d	30 03		bmi $01a222			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a21f	09 80		ora #$80			ora 	#$80 						; put in right range
.01a221	60		rts				rts
.01a222					_FPCEOverflow:
.01a222	4c e0 a3	jmp $01a3e0			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a225					FPFractionalPart:
.01a225	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a227	38		sec				sec 								; this flag tells us to keep the fractional part
.01a228	30 0d		bmi $01a237			bmi 	FPGetPart
.01a22a	60		rts				rts
.01a22b					FPIntegerPart:
.01a22b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a22d	18		clc				clc 								; this flag says keep the integer part.
.01a22e	30 07		bmi $01a237			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a230	48		pha				pha
.01a231	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a233	95 85		sta $85,x			sta 	XS_Type,x
.01a235	68		pla				pla
.01a236	60		rts				rts
.01a237					FPGetPart:
.01a237	48		pha				pha
.01a238	5a		phy				phy 								; save Y
.01a239	08		php				php 								; save action
.01a23a	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a23c	70 59		bvs $01a297			bvs 	_FPGP_Exit 					; then do nothing.
.01a23e	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a240	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a242	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a244	85 1c		sta $1c				sta 	zLTemp1+2
.01a246	85 1d		sta $1d				sta 	zLTemp1+3
.01a248	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a24a	38		sec				sec
.01a24b	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a24d	f0 12		beq $01a261			beq 	_FPGP_NoShift 				; ... if any
.01a24f	c9 20		cmp #$20			cmp 	#32
.01a251	90 02		bcc $01a255			bcc 	_FPGP_NotMax
.01a253	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a255					_FPGP_NotMax:
.01a255	a8		tay				tay 								; Y is the mask shift count.
.01a256					_FPGP_ShiftMask:
.01a256	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a258	66 1c		ror $1c				ror 	2+zLTemp1
.01a25a	66 1b		ror $1b				ror 	1+zLTemp1
.01a25c	66 1a		ror $1a				ror 	0+zLTemp1
.01a25e	88		dey				dey
.01a25f	d0 f5		bne $01a256			bne 	_FPGP_ShiftMask
.01a261					_FPGP_NoShift:
.01a261	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a263	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a266					_FPGP_MaskLoop:
.01a266	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a269	28		plp				plp 								; if CC we keep the top part, so we
.01a26a	08		php				php		 							; flip the mask.
.01a26b	b0 02		bcs $01a26f			bcs		_FPGP_NoFlip
.01a26d	49 ff		eor #$ff			eor 	#$FF
.01a26f					_FPGP_NoFlip:
.01a26f	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a271	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a273	e8		inx				inx
.01a274	c8		iny				iny
.01a275	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a277	d0 ed		bne $01a266			bne 	_FPGP_MaskLoop
.01a279	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a27c	28		plp				plp
.01a27d	08		php				php 								; get action flag on the stack
.01a27e	90 04		bcc $01a284			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a280	a9 00		lda #$00			lda 	#0
.01a282	95 85		sta $85,x			sta 	XS_Type,x
.01a284					_FPGP_NotFractional:
.01a284	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a286	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a288	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a28a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a28c	f0 05		beq $01a293			beq 	_FPGP_Zero 					; if zero, return zero
.01a28e	20 83 a3	jsr $01a383			jsr 	FPUNormalise
.01a291	80 04		bra $01a297			bra 	_FPGP_Exit 					; and exit
.01a293					_FPGP_Zero:
.01a293	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a295	95 85		sta $85,x			sta 	XS_Type,x
.01a297					_FPGP_Exit:
.01a297	68		pla				pla 								; throw saved action flag.
.01a298	7a		ply				ply
.01a299	68		pla				pla
.01a29a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a29b					FPCompare:
.01a29b	20 dc a2	jsr $01a2dc			jsr 	FPFastCompare 				; fast compare try first
.01a29e	b0 3b		bcs $01a2db			bcs 	_FPCExit 					; that worked.
.01a2a0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a2a2	48		pha				pha
.01a2a3	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a2a5	48		pha				pha
.01a2a6	20 6e a0	jsr $01a06e			jsr 	FPSubtract 					; calculate X1-X2
.01a2a9	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a2ab	70 2a		bvs $01a2d7			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a2ad	68		pla				pla
.01a2ae	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a2b1	68		pla				pla
.01a2b2	38		sec				sec
.01a2b3	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a2b6	70 14		bvs $01a2cc			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a2b8	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a2b9	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a2bb	b0 0f		bcs $01a2cc			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a2bd	38		sec				sec
.01a2be	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a2c1	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a2c3	b0 02		bcs $01a2c7			bcs 	_FPCNotRange 				; keep in range.
.01a2c5	a9 01		lda #$01			lda 	#1
.01a2c7					_FPCNotRange:
.01a2c7	38		sec				sec
.01a2c8	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a2ca	b0 0d		bcs $01a2d9			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a2cc					_FPCNotEqual:
.01a2cc	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a2ce	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a2d0	f0 02		beq $01a2d4			beq 	_FPCNE2
.01a2d2	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a2d4	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a2d5	80 04		bra $01a2db			bra 	_FPCExit
.01a2d7					_FPCPullZero:
.01a2d7	68		pla				pla 								; throw saved exponents
.01a2d8	68		pla				pla
.01a2d9					_FPCZero:
.01a2d9	a9 00		lda #$00			lda 	#0 							; and return zero
.01a2db					_FPCExit:
.01a2db	60		rts				rts
.01a2dc					FPFastCompare:
.01a2dc	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a2de	70 23		bvs $01a303			bvs 	_FPFLeftZero
.01a2e0	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a2e2	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a2e4	70 25		bvs $01a30b			bvs 	_FPFSignBit
.01a2e6	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a2e8	0a		asl a				asl 	a 							; put in CS if different.
.01a2e9	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a2eb	b0 1e		bcs $01a30b			bcs 	_FPFSignBit
.01a2ed	38		sec				sec 								; same sign and not-zero. compare exponents
.01a2ee	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a2f0	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a2f2	f0 09		beq $01a2fd			beq 	_FPNoFastCompare
.01a2f4	6a		ror a				ror 	a 							; put carry into bit 7.
.01a2f5	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a2f7	30 02		bmi $01a2fb			bmi		_FPFCNotMinus
.01a2f9	49 80		eor #$80			eor 	#$80
.01a2fb					_FPFCNotMinus:
.01a2fb	80 0e		bra $01a30b			bra		_FPFSignBit
.01a2fd					_FPNoFastCompare:
.01a2fd	18		clc				clc
.01a2fe	60		rts				rts
.01a2ff					_FPFZero:
.01a2ff	a9 00		lda #$00			lda 	#0
.01a301					_FPFExitSet:
.01a301	38		sec				sec
.01a302	60		rts				rts
.01a303					_FPFLeftZero:
.01a303	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a305	70 f8		bvs $01a2ff			bvs 	_FPFZero
.01a307	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a309	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a30b					_FPFSignBit:
.01a30b	0a		asl a				asl 	a
.01a30c	a9 01		lda #$01			lda 	#1
.01a30e	90 f1		bcc $01a301			bcc		_FPFExitSet
.01a310	a9 ff		lda #$ff			lda 	#$FF
.01a312	38		sec				sec
.01a313	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a314					FPUCopyX2ToX1:
.01a314	48		pha				pha
.01a315	da		phx				phx
.01a316	5a		phy				phy
.01a317	a0 08		ldy #$08			ldy 	#8
.01a319	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a31b	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a31d	e8		inx				inx
.01a31e	88		dey				dey
.01a31f	10 f8		bpl $01a319			bpl 	_FPUC21
.01a321	7a		ply				ply
.01a322	fa		plx				plx
.01a323	68		pla				pla
.01a324	60		rts				rts
.01a325					FPUSetInteger:
.01a325	48		pha				pha
.01a326	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a328	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a32a	10 02		bpl $01a32e			bpl 	_FPUSIExtend
.01a32c	a9 ff		lda #$ff			lda 	#$FF
.01a32e					_FPUSIExtend:
.01a32e	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a330	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a332	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a334	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a336	95 85		sta $85,x			sta 	XS_Type,x
.01a338	68		pla				pla
.01a339	60		rts				rts
.01a33a					FPUNegateInteger:
.01a33a	48		pha				pha
.01a33b	38		sec				sec
.01a33c	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a33e	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a340	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a342	a9 00		lda #$00			lda 	#0
.01a344	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a346	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a348	a9 00		lda #$00			lda 	#0
.01a34a	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a34c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a34e	a9 00		lda #$00			lda 	#0
.01a350	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a352	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a354	68		pla				pla
.01a355	60		rts				rts
.01a356					FPUToFloat:
.01a356	48		pha				pha
.01a357	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a359	29 0f		and #$0f			and 	#$0F
.01a35b	f0 24		beq $01a381			beq 	_FPUFExit
.01a35d	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a35f	95 85		sta $85,x			sta 	XS_Type,x
.01a361	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a363	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a365	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a367	10 07		bpl $01a370			bpl		_FPUFPositive
.01a369	20 3a a3	jsr $01a33a			jsr 	FPUNegateInteger 			; negate the mantissa
.01a36c	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a36e	95 85		sta $85,x			sta 	XS_Type,x
.01a370					_FPUFPositive:
.01a370	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a372	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a374	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a376	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a378	d0 04		bne $01a37e			bne 	_FPUFNonZero
.01a37a	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a37c	95 85		sta $85,x			sta 	XS_Type,x
.01a37e					_FPUFNonZero:
.01a37e	20 83 a3	jsr $01a383			jsr 	FPUNormalise 				; normalise the floating point.
.01a381					_FPUFExit:
.01a381	68		pla				pla
.01a382	60		rts				rts
.01a383					FPUNormalise:
.01a383	48		pha				pha
.01a384	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a386	70 18		bvs $01a3a0			bvs 	_FPUNExit
.01a388	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a38a	f0 10		beq $01a39c			beq 	_FPUNSetZero
.01a38c					_FPUNLoop:
.01a38c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a38e	30 10		bmi $01a3a0			bmi 	_FPUNExit 					; if so, we are normalised.
.01a390	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a392	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a394	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a396	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a398	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a39a	d0 f0		bne $01a38c			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a39c					_FPUNSetZero:
.01a39c	a9 40		lda #$40			lda 	#$40
.01a39e	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a3a0					_FPUNExit:
.01a3a0	68		pla				pla
.01a3a1	60		rts				rts
.01a3a2					FPUToInteger:
.01a3a2	48		pha				pha
.01a3a3	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a3a5	29 01		and #$01			and 	#1
.01a3a7	d0 31		bne $01a3da			bne 	_FPUTOI_Exit
.01a3a9	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a3ab	70 23		bvs $01a3d0			bvs 	_FPUTOI_Zero
.01a3ad	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a3af	10 1f		bpl $01a3d0			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a3b1	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a3b3	b0 2b		bcs $01a3e0			bcs 	FP_Overflow
.01a3b5					_FPUToIToInteger:
.01a3b5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a3b7	c9 a0		cmp #$a0			cmp 	#128+32
.01a3b9	f0 0c		beq $01a3c7			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a3bb	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a3bd	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a3bf	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a3c1	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a3c3	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a3c5	80 ee		bra $01a3b5			bra 	_FPUToIToInteger 			; keep going.
.01a3c7					_FPUToICheckSign:
.01a3c7	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a3c9	10 0f		bpl $01a3da			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a3cb	20 3a a3	jsr $01a33a			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a3ce	80 0a		bra $01a3da			bra 	_FPUTOI_Exit
.01a3d0					_FPUTOI_Zero:
.01a3d0	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a3d2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3d4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3d6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3d8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a3da					_FPUToI_Exit:
.01a3da	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a3dc	95 85		sta $85,x			sta 	XS_Type,x
.01a3de	68		pla				pla
.01a3df	60		rts				rts
.01a3e0					FP_Overflow:
.01a3e0	20 83 85	jsr $018583			jsr ERR_Handler
>01a3e3	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a3eb	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a3fb					FPUTimes10:
.01a3fb	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a3fd	85 1a		sta $1a				sta 	ZLTemp1+0
.01a3ff	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a401	85 1b		sta $1b				sta 	ZLTemp1+1
.01a403	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a405	85 1c		sta $1c				sta 	ZLTemp1+2
.01a407	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a409	85 1d		sta $1d				sta 	ZLTemp1+3
.01a40b	20 40 a4	jsr $01a440			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a40e	20 40 a4	jsr $01a440			jsr 	_FPUT_LSR_ZLTemp1
.01a411	18		clc				clc
.01a412	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a414	65 1a		adc $1a				adc 	ZLTemp1+0
.01a416	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a418	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a41a	65 1b		adc $1b				adc 	ZLTemp1+1
.01a41c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a41e	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a420	65 1c		adc $1c				adc 	ZLTemp1+2
.01a422	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a424	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a426	65 1d		adc $1d				adc 	ZLTemp1+3
.01a428	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a42a	90 0a		bcc $01a436			bcc 	_FPUTimes10
.01a42c	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a42e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a430	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a432	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a434	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a436					_FPUTimes10:
.01a436	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a438	18		clc				clc
.01a439	69 03		adc #$03			adc 	#3
.01a43b	95 84		sta $84,x			sta 	XS_Exponent,x
.01a43d	b0 a1		bcs $01a3e0			bcs 	FP_Overflow 				; error
.01a43f	60		rts				rts
.01a440					_FPUT_LSR_ZLTemp1:
.01a440	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a442	66 1c		ror $1c				ror 	ZLTemp1+2
.01a444	66 1b		ror $1b				ror 	ZLTemp1+1
.01a446	66 1a		ror $1a				ror 	ZLTemp1+0
.01a448	60		rts				rts
.01a449					FPUScale10A:
.01a449	5a		phy				phy
.01a44a	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a44c	f0 37		beq $01a485			beq 	_FPUScaleExit
.01a44e	da		phx				phx 								; save X
.01a44f	e8		inx				inx
.01a450	e8		inx				inx
.01a451	e8		inx				inx
.01a452	e8		inx				inx
.01a453	e8		inx				inx
.01a454	e8		inx				inx
.01a455	a8		tay				tay 								; save power scalar in Y.
.01a456	a9 00		lda #$00			lda 	#0
.01a458	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a45a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a45c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a45e	95 85		sta $85,x			sta 	XS_Type,x
.01a460	a9 80		lda #$80			lda 	#$80
.01a462	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a464	a9 81		lda #$81			lda 	#$81
.01a466	95 84		sta $84,x			sta 	XS_Exponent,x
.01a468	5a		phy				phy 								; save 10^n on stack.
.01a469	c0 00		cpy #$00			cpy 	#0
.01a46b	10 05		bpl $01a472			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a46d	98		tya				tya
.01a46e	49 ff		eor #$ff			eor 	#$FF
.01a470	1a		inc a				inc 	a
.01a471	a8		tay				tay
.01a472					_FPUSAbs:
.01a472	20 fb a3	jsr $01a3fb			jsr 	FPUTimes10
.01a475	88		dey				dey
.01a476	d0 fa		bne $01a472			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a478	68		pla				pla 								; restore count in A
.01a479	fa		plx				plx 								; restore X pointing to number to scale.
.01a47a	0a		asl a				asl 	a
.01a47b	b0 05		bcs $01a482			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a47d	20 9d a1	jsr $01a19d			jsr 	FPMultiply 					; if clear multiply.
.01a480	80 03		bra $01a485			bra		_FPUScaleExit
.01a482					_FPUSDivide:
.01a482	20 2a a1	jsr $01a12a			jsr 	FPDivide
.01a485					_FPUScaleExit:
.01a485	7a		ply				ply
.01a486	60		rts				rts
.01a487					FPUCopyToNext:
.01a487	a0 06		ldy #$06			ldy 		#6
.01a489	da		phx				phx
.01a48a					_FPUCopy1:
.01a48a	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a48c	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a48e	e8		inx				inx
.01a48f	88		dey				dey
.01a490	d0 f8		bne $01a48a			bne 	_FPUCopy1
.01a492	fa		plx				plx
.01a493	60		rts				rts
.01a494					FPUCopyFromNext:
.01a494	a0 06		ldy #$06			ldy 		#6
.01a496	da		phx				phx
.01a497					_FPUCopy1:
.01a497	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a499	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a49b	e8		inx				inx
.01a49c	88		dey				dey
.01a49d	d0 f8		bne $01a497			bne 	_FPUCopy1
.01a49f	fa		plx				plx
.01a4a0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a4a1					FPToString:
.01a4a1	48		pha				pha
.01a4a2	5a		phy				phy
.01a4a3	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a4a5	50 0a		bvc $01a4b1			bvc 		_FPTSIsFloat 			; if zero,
.01a4a7					_FPTSZero:
.01a4a7	a9 30		lda #$30			lda 		#"0"
.01a4a9	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter
.01a4ac					_FPTSExit:
.01a4ac	7a		ply				ply
.01a4ad	68		pla				pla
.01a4ae	60		rts				rts
.01a4af	80 fb		bra $01a4ac			bra 		_FPTSExit
.01a4b1					_FPTSIsFloat:
.01a4b1	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a4b3	10 09		bpl $01a4be			bpl 		_FPTSNotSigned
.01a4b5	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a4b7	95 85		sta $85,x			sta 		XS_Type,x
.01a4b9	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a4bb	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter
.01a4be					_FPTSNotSigned:
.01a4be	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a4c0	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a4c2	b0 09		bcs $01a4cd			bcs 		_FPTSExponent
.01a4c4	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a4c6	90 05		bcc $01a4cd			bcc 		_FPTSExponent 			;
.01a4c8					_FPTSStandard:
.01a4c8	20 0c a5	jsr $01a50c			jsr 		FPTOutputBody 			; output the body.
.01a4cb	80 df		bra $01a4ac			bra 		_FPTSExit
.01a4cd					_FPTSExponent:
.01a4cd	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a4cf	8d 9d 03	sta $039d			sta 		ExpCount
.01a4d2					_FPTSExponentLoop:
.01a4d2	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a4d4	10 0e		bpl $01a4e4			bpl 		_FPTSTimes
.01a4d6	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a4d8	90 14		bcc $01a4ee			bcc 		_FPTSScaledToExp
.01a4da	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a4dc	20 49 a4	jsr $01a449			jsr 		FPUScale10A
.01a4df	ee 9d 03	inc $039d			inc 		ExpCount
.01a4e2	80 ee		bra $01a4d2			bra 		_FPTSExponentLoop
.01a4e4					_FPTSTimes:
.01a4e4	a9 01		lda #$01			lda 		#1
.01a4e6	20 49 a4	jsr $01a449			jsr 		FPUScale10A
.01a4e9	ce 9d 03	dec $039d			dec 		ExpCount
.01a4ec	80 e4		bra $01a4d2			bra 		_FPTSExponentLoop
.01a4ee					_FPTSScaledToExp:
.01a4ee	20 0c a5	jsr $01a50c			jsr 		FPTOutputBody 			; output the body.
.01a4f1	a9 65		lda #$65			lda 		#"e"					; output E
.01a4f3	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter
.01a4f6	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a4f9	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a4fb	29 80		and #$80			and 		#$80 					; sign extend it
.01a4fd	f0 02		beq $01a501			beq 		_FPTSSExt
.01a4ff	a9 ff		lda #$ff			lda 		#$FF
.01a501					_FPTSSExt:
.01a501	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a503	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a505	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a507	20 29 9f	jsr $019f29			jsr 		INTToString 			; output the exponent.
.01a50a	80 a0		bra $01a4ac			bra			_FPTSExit 				; and exit.
.01a50c					FPTOutputBody:
.01a50c	20 87 a4	jsr $01a487			jsr 		FPUCopyToNext 			; copy to next slot.
.01a50f	20 a2 a3	jsr $01a3a2			jsr 		FPUToInteger 			; convert to an integer
.01a512	20 29 9f	jsr $019f29			jsr 		INTToString 			; output the main integer part.
.01a515	20 94 a4	jsr $01a494			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a518	20 25 a2	jsr $01a225			jsr 		FPFractionalPart 		; get the decimal part.
.01a51b	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a51d	70 3c		bvs $01a55b			bvs 		_FPTOExit 				; if not, exit now.
.01a51f	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a521	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter
.01a524					_FPOutLoop:
.01a524	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a526	70 1d		bvs $01a545			bvs 		_FPStripZeros 			; strip trailing zeros
.01a528	20 fb a3	jsr $01a3fb			jsr 		FPUTimes10 				; multiply by 10
.01a52b	20 87 a4	jsr $01a487			jsr 		FPUCopyToNext			; copy to next slot.
.01a52e	20 a2 a3	jsr $01a3a2			jsr 		FPUToInteger 			; convert to integer
.01a531	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a533	09 30		ora #$30			ora 		#"0"
.01a535	20 cb 9f	jsr $019fcb			jsr 		ITSOutputCharacter
.01a538	20 94 a4	jsr $01a494			jsr 		FPUCopyFromNext 		; get it back
.01a53b	20 25 a2	jsr $01a225			jsr 		FPFractionalPart 		; get fractional part
.01a53e	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a541	c9 0b		cmp #$0b			cmp 	 	#11
.01a543	90 df		bcc $01a524			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a545					_FPStripZeros:
.01a545	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a548					_FPStripLoop:
.01a548	88		dey				dey 								; back one, if at start then no strip
.01a549	f0 10		beq $01a55b			beq 		_FPToExit
.01a54b	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a54e	c9 30		cmp #$30			cmp 		#"0"
.01a550	f0 f6		beq $01a548			beq 		_FPStripLoop
.01a552	c8		iny				iny
.01a553	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a555	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a558	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a55b					_FPTOExit:
.01a55b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a55c					FPFromString:
.01a55c	48		pha				pha 								; push A
.01a55d	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a55f	c9 2e		cmp #$2e			cmp 	#"."
.01a561	f0 03		beq $01a566			beq	 	_FPFIsDecimal
.01a563	4c c2 a5	jmp $01a5c2			jmp 	_FPFNotDecimal
.01a566					_FPFIsDecimal:
.01a566	c8		iny				iny 								; consume the decimal.
.01a567	20 56 a3	jsr $01a356			jsr 	FPUToFloat 					; convert the integer to float.
.01a56a	da		phx				phx 								; save X.
.01a56b	5a		phy				phy 								; save decimal start position
.01a56c	e8		inx				inx
.01a56d	e8		inx				inx
.01a56e	e8		inx				inx
.01a56f	e8		inx				inx
.01a570	e8		inx				inx
.01a571	e8		inx				inx
.01a572	20 e3 9f	jsr $019fe3			jsr 	INTFromStringY 				; get the part after the DP.
.01a575	20 56 a3	jsr $01a356			jsr 	FPUToFloat 					; convert that to a float.
.01a578	68		pla				pla 								; calculate - chars consumed.
.01a579	8c 9c 03	sty $039c			sty 	ExpTemp
.01a57c	38		sec				sec
.01a57d	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a580	20 49 a4	jsr $01a449			jsr 	FPUScale10A 				; scale it by 10^AC
.01a583	fa		plx				plx 								; restore original X
.01a584	20 76 a0	jsr $01a076			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a587	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a589	c9 45		cmp #$45			cmp 	#"E"
.01a58b	f0 04		beq $01a591			beq 	_FPFExponent
.01a58d	c9 65		cmp #$65			cmp 	#"e"
.01a58f	d0 31		bne $01a5c2			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a591					_FPFExponent:
.01a591	c8		iny				iny 								; skip over E symbol.
.01a592	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a594	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a596	d0 01		bne $01a599			bne 	_FPFGotSign
.01a598	c8		iny				iny 								; if it was - skip over it.
.01a599					_FPFGotSign:
.01a599	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a59a	da		phx				phx
.01a59b	e8		inx				inx
.01a59c	e8		inx				inx
.01a59d	e8		inx				inx
.01a59e	e8		inx				inx
.01a59f	e8		inx				inx
.01a5a0	e8		inx				inx
.01a5a1	20 e3 9f	jsr $019fe3			jsr 	INTFromStringY 				; get the exponent
.01a5a4	fa		plx				plx 								; restore X.
.01a5a5	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a5a7	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a5a9	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a5ab	d0 17		bne $01a5c4			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a5ad	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a5af	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a5b1	b0 11		bcs $01a5c4			bcs 	_FPFXOverflow
.01a5b3	68		pla				pla 								; get direction
.01a5b4	d0 07		bne $01a5bd			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a5b6	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a5b8	49 ff		eor #$ff			eor 	#$FF
.01a5ba	1a		inc a				inc 	a
.01a5bb	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a5bd					_FPFXScale:
.01a5bd	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a5bf	20 49 a4	jsr $01a449			jsr 	FPUScale10A 				; scale by the exponent.
.01a5c2					_FPFNotDecimal:
.01a5c2	68		pla				pla
.01a5c3	60		rts				rts
.01a5c4					_FPFXOverflow:
.01a5c4	20 83 85	jsr $018583			jsr 	ERR_Handler
>01a5c7	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a5cf	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a5d6					Unary_Rnd:
.01a5d6	20 37 93	jsr $019337			jsr 	EvaluateNumberX 			; get value
.01a5d9	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; check right bracket.
.01a5dc	20 b7 95	jsr $0195b7			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a5df	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a5e1	30 10		bmi $01a5f3			bmi 	_URSetSeed
.01a5e3	f0 28		beq $01a60d			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a5e5	da		phx				phx
.01a5e6	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a5e8	20 44 a6	jsr $01a644			jsr 	Random16
.01a5eb	a2 02		ldx #$02			ldx 	#2
.01a5ed	20 44 a6	jsr $01a644			jsr 	Random16
.01a5f0	fa		plx				plx
.01a5f1	80 1a		bra $01a60d			bra 	_URMakeRandom
.01a5f3					_URSetSeed:
.01a5f3	20 56 a3	jsr $01a356			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a5f6	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a5f8	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a5fb	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a5fd	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a600	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a602	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a605	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a607	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a608	49 db		eor #$db			eor 	#$DB
.01a60a	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a60d					_URMakeRandom:
.01a60d	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a610	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a613	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a616	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a619	d0 0a		bne $01a625			bne 	_URNotZero
.01a61b	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a61d	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a620	a9 3d		lda #$3d			lda 	#$3D
.01a622	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a625					_URNotZero:
.01a625	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a628	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a62a	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a62d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a62f	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a632	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a634	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a637	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a639	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a63b	95 85		sta $85,x			sta 	XS_Type,x
.01a63d	a9 80		lda #$80			lda 	#$80
.01a63f	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a641	4c 83 a3	jmp $01a383			jmp 	FPUNormalise 				; and normalise.
.01a644					Random16:
.01a644	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a647	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a64a	90 08		bcc $01a654			bcc 	_R16_NoXor
.01a64c	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a64f	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a651	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a654					_R16_NoXor:
.01a654	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a655					Unary_Int:
.01a655	20 37 93	jsr $019337			jsr 	EvaluateNumberX 			; get value
.01a658	20 99 99	jsr $019999			jsr 	CheckNextRParen 			; check right bracket.
.01a65b	4c a2 a3	jmp $01a3a2			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a65e	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
