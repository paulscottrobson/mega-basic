
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Thu Aug 22 13:39:00 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					hasFloat = 1
=1					hasInteger = 1
=253					maxString = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0304					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0305					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=774					XS2_Mantissa = XS_Mantissa+XS_Size
=778					XS2_Exponent = XS_Exponent+XS_Size
=779					XS2_Type = XS_Type+XS_Size
=780					XS3_Mantissa = XS_Mantissa+XS_Size*2
=784					XS3_Exponent = XS_Exponent+XS_Size*2
=785					XS3_Type = XS_Type+XS_Size*2
>0400					Num_Buffer	.fill 	32 						; buffer for numeric conversions
>0420					NumBufX 	.byte 	?						; buffer index position
>0421					NumSuppress	.byte 	?						; leading zero suppression flag
>0422					NumConvCount .byte 	? 						; count for conversions.
>0423					ExpTemp:	.byte ?							; Working temp for exponents.
>0424					ExpCount:	.byte ? 						; Count of decimal exponents.
>0425					SignCount:	.byte ?							; Integer Divide Sign Counts.
>0426					StringPtr:	.byte ? 						; Top of free memory (for string allocation)
>0427					TempStringWriteIndex: .byte ? 				; Write offset.
>0428					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>042a					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>042c					Tim_SR:		.byte ? 						; Processor Status
>042d					Tim_A:		.byte ? 						; Processor Registers
>042e					Tim_X:		.byte ?
>042f					Tim_Y:		.byte ?
>0430					Tim_Z:		.byte ?
>0431					Tim_SP:		.byte ?							; Stack Pointer

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0f 0a 00 d7 9a 6a ba bc			.byte	$0f,$0a,$00,$d7,$9a,$6a,$ba,$bc
>1008	ff 06 68 69 20 21 00 00			.byte	$ff,$06,$68,$69,$20,$21,$00,$00

;******  Return to file: modules/hardware/em65816.asm


;******  Processing file: modules/hardware/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b2					lastUnaryFunction = $b2
.c000					VectorTable:
>c000	c6 c5					.word BinaryOp_And         ; $80 and
>c002	ee c5					.word BinaryOp_Or          ; $81 or
>c004	16 c6					.word BinaryOp_Xor         ; $82 xor
>c006	16 c6					.word BinaryOp_Eor         ; $83 eor
>c008	59 c6					.word Binary_Equal         ; $84 =
>c00a	78 c6					.word Binary_NotEqual      ; $85 <>
>c00c	81 c6					.word Binary_Less          ; $86 <
>c00e	8a c6					.word Binary_LessEqual     ; $87 <=
>c010	9c c6					.word Binary_Greater       ; $88 >
>c012	93 c6					.word Binary_GreaterEqual  ; $89 >=
>c014	31 c7					.word BinaryOp_Add         ; $8a +
>c016	51 c7					.word BinaryOp_Subtract    ; $8b -
>c018	64 c7					.word BinaryOp_Multiply    ; $8c *
>c01a	77 c7					.word BinaryOp_Divide      ; $8d /
>c01c	ae c0					.word NotImplemented       ; $8e ^
>c01e	ae c0					.word NotImplemented       ; $8f if
>c020	ae c0					.word NotImplemented       ; $90 while
>c022	ae c0					.word NotImplemented       ; $91 repeat
>c024	ae c0					.word NotImplemented       ; $92 for
>c026	ae c0					.word NotImplemented       ; $93 then
>c028	ae c0					.word NotImplemented       ; $94 endif
>c02a	ae c0					.word NotImplemented       ; $95 wend
>c02c	ae c0					.word NotImplemented       ; $96 until
>c02e	ae c0					.word NotImplemented       ; $97 next
>c030	ae c0					.word NotImplemented       ; $98 not
>c032	ae c0					.word NotImplemented       ; $99 fn(
>c034	47 c8					.word Unary_Abs            ; $9a abs(
>c036	ae c0					.word NotImplemented       ; $9b asc(
>c038	ae c0					.word NotImplemented       ; $9c int(
>c03a	ae c0					.word NotImplemented       ; $9d peek(
>c03c	ae c0					.word NotImplemented       ; $9e rnd(
>c03e	ae c0					.word NotImplemented       ; $9f usr(
>c040	ae c0					.word NotImplemented       ; $a0 left$(
>c042	ae c0					.word NotImplemented       ; $a1 right$(
>c044	ae c0					.word NotImplemented       ; $a2 mid$(
>c046	ae c0					.word NotImplemented       ; $a3 spc(
>c048	ae c0					.word NotImplemented       ; $a4 str$(
>c04a	ae c0					.word NotImplemented       ; $a5 val(
>c04c	ae c0					.word NotImplemented       ; $a6 len(
>c04e	ae c0					.word NotImplemented       ; $a7 hex$(
>c050	ae c0					.word NotImplemented       ; $a8 sin(
>c052	ae c0					.word NotImplemented       ; $a9 cos(
>c054	ae c0					.word NotImplemented       ; $aa tan(
>c056	ae c0					.word NotImplemented       ; $ab atn(
>c058	ae c0					.word NotImplemented       ; $ac exp(
>c05a	ae c0					.word NotImplemented       ; $ad log(
>c05c	ae c0					.word NotImplemented       ; $ae sqr(
>c05e	ae c0					.word NotImplemented       ; $af dec(
>c060	ae c0					.word NotImplemented       ; $b0 deek(
>c062	ae c0					.word NotImplemented       ; $b1 leek(
>c064	ae c0					.word NotImplemented       ; $b2 mod(
>c066	ae c0					.word NotImplemented       ; $b3 $(
>c068	ae c0					.word NotImplemented       ; $b4 $
>c06a	ae c0					.word NotImplemented       ; $b5 #(
>c06c	ae c0					.word NotImplemented       ; $b6 #
>c06e	ae c0					.word NotImplemented       ; $b7 %(
>c070	ae c0					.word NotImplemented       ; $b8 %
>c072	ae c0					.word NotImplemented       ; $b9 (
>c074	ae c0					.word NotImplemented       ; $ba )
>c076	ae c0					.word NotImplemented       ; $bb ,
>c078	ae c0					.word NotImplemented       ; $bc :
>c07a	ae c0					.word NotImplemented       ; $bd ;
>c07c	ae c0					.word NotImplemented       ; $be def
>c07e	0b c4					.word CLR_Command          ; $bf clr
>c080	ae c0					.word NotImplemented       ; $c1 data
>c082	ae c0					.word NotImplemented       ; $c2 read
>c084	ae c0					.word NotImplemented       ; $c3 dim
>c086	ae c0					.word NotImplemented       ; $c4 to
>c088	ae c0					.word NotImplemented       ; $c5 step
>c08a	ae c0					.word NotImplemented       ; $c6 gosub
>c08c	ae c0					.word NotImplemented       ; $c7 return
>c08e	ae c0					.word NotImplemented       ; $c8 goto
>c090	ae c0					.word NotImplemented       ; $c9 input
>c092	ae c0					.word NotImplemented       ; $ca let
>c094	ae c0					.word NotImplemented       ; $cb list
>c096	ae c0					.word NotImplemented       ; $cc new
>c098	ae c0					.word NotImplemented       ; $cd old
>c09a	ae c0					.word NotImplemented       ; $ce on
>c09c	ae c0					.word NotImplemented       ; $cf restore
>c09e	ae c0					.word NotImplemented       ; $d0 poke
>c0a0	ae c0					.word NotImplemented       ; $d1 print
>c0a2	ae c0					.word NotImplemented       ; $d2 run
>c0a4	ae c0					.word NotImplemented       ; $d3 stop
>c0a6	ae c0					.word NotImplemented       ; $d4 wait
>c0a8	ae c0					.word NotImplemented       ; $d5 doke
>c0aa	ae c0					.word NotImplemented       ; $d6 loke
>c0ac	ae c0					.word NotImplemented       ; $d7 assert
.c0ae					NotImplemented:
.c0ae	80 fe		bra $c0ae		_error: bra _error
.c0b0					BinaryPrecedence:
>c0b0	01					.byte 1    ; $80 and
>c0b1	01					.byte 1    ; $81 or
>c0b2	01					.byte 1    ; $82 xor
>c0b3	01					.byte 1    ; $83 eor
>c0b4	02					.byte 2    ; $84 =
>c0b5	02					.byte 2    ; $85 <>
>c0b6	02					.byte 2    ; $86 <
>c0b7	02					.byte 2    ; $87 <=
>c0b8	02					.byte 2    ; $88 >
>c0b9	02					.byte 2    ; $89 >=
>c0ba	03					.byte 3    ; $8a +
>c0bb	03					.byte 3    ; $8b -
>c0bc	04					.byte 4    ; $8c *
>c0bd	04					.byte 4    ; $8d /
>c0be	05					.byte 5    ; $8e ^
.c0bf					KeywordText:
>c0bf	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>c0c2	4f d2					.byte $4f,$d2                          ; $81 or
>c0c4	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>c0c7	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>c0ca	bd					.byte $bd                              ; $84 =
>c0cb	3c be					.byte $3c,$be                          ; $85 <>
>c0cd	bc					.byte $bc                              ; $86 <
>c0ce	3c bd					.byte $3c,$bd                          ; $87 <=
>c0d0	be					.byte $be                              ; $88 >
>c0d1	3e bd					.byte $3e,$bd                          ; $89 >=
>c0d3	ab					.byte $ab                              ; $8a +
>c0d4	ad					.byte $ad                              ; $8b -
>c0d5	aa					.byte $aa                              ; $8c *
>c0d6	af					.byte $af                              ; $8d /
>c0d7	de					.byte $de                              ; $8e ^
>c0d8	49 c6					.byte $49,$c6                          ; $8f if
>c0da	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>c0df	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>c0e5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>c0e8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>c0ec	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>c0f1	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>c0f5	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>c0fa	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>c0fe	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>c101	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>c104	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>c108	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>c10c	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>c110	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>c115	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>c119	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>c11d	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>c123	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>c12a	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>c12f	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>c133	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>c138	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>c13c	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>c140	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>c145	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>c149	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>c14d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>c151	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>c155	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>c159	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>c15d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>c161	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>c165	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>c16a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>c16f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>c173	24 a8					.byte $24,$a8                          ; $b3 $(
>c175	a4					.byte $a4                              ; $b4 $
>c176	23 a8					.byte $23,$a8                          ; $b5 #(
>c178	a3					.byte $a3                              ; $b6 #
>c179	25 a8					.byte $25,$a8                          ; $b7 %(
>c17b	a5					.byte $a5                              ; $b8 %
>c17c	a8					.byte $a8                              ; $b9 (
>c17d	a9					.byte $a9                              ; $ba )
>c17e	ac					.byte $ac                              ; $bb ,
>c17f	ba					.byte $ba                              ; $bc :
>c180	bb					.byte $bb                              ; $bd ;
>c181	44 45 c6				.byte $44,$45,$c6                      ; $be def
>c184	43 4c d2				.byte $43,$4c,$d2                      ; $bf clr
>c187	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c1 data
>c18b	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c2 read
>c18f	44 49 cd				.byte $44,$49,$cd                      ; $c3 dim
>c192	54 cf					.byte $54,$cf                          ; $c4 to
>c194	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c5 step
>c198	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c6 gosub
>c19d	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c7 return
>c1a3	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $c8 goto
>c1a7	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $c9 input
>c1ac	4c 45 d4				.byte $4c,$45,$d4                      ; $ca let
>c1af	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $cb list
>c1b3	4e 45 d7				.byte $4e,$45,$d7                      ; $cc new
>c1b6	4f 4c c4				.byte $4f,$4c,$c4                      ; $cd old
>c1b9	4f ce					.byte $4f,$ce                          ; $ce on
>c1bb	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $cf restore
>c1c2	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d0 poke
>c1c6	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d1 print
>c1cb	52 55 ce				.byte $52,$55,$ce                      ; $d2 run
>c1ce	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $d3 stop
>c1d2	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d4 wait
>c1d6	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d5 doke
>c1da	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d6 loke
>c1de	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d7 assert
>c1e4	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_dollarlparen = $b3
=$b4					token_dollar = $b4
=$b5					token_hashlparen = $b5
=$b6					token_hash = $b6
=$b7					token_percentlparen = $b7
=$b8					token_percent = $b8
=$b9					token_lparen = $b9
=$ba					token_rparen = $ba
=$bb					token_comma = $bb
=$bc					token_colon = $bc
=$bd					token_semicolon = $bd
=$be					token_def = $be
=$bf					token_clr = $bf
=$c1					token_data = $c1
=$c2					token_read = $c2
=$c3					token_dim = $c3
=$c4					token_to = $c4
=$c5					token_step = $c5
=$c6					token_gosub = $c6
=$c7					token_return = $c7
=$c8					token_goto = $c8
=$c9					token_input = $c9
=$ca					token_let = $ca
=$cb					token_list = $cb
=$cc					token_new = $cc
=$cd					token_old = $cd
=$ce					token_on = $ce
=$cf					token_restore = $cf
=$d0					token_poke = $d0
=$d1					token_print = $d1
=$d2					token_run = $d2
=$d3					token_stop = $d3
=$d4					token_wait = $d4
=$d5					token_doke = $d5
=$d6					token_loke = $d6
=$d7					token_assert = $d7

;******  Return to file: modules/hardware/em65816.asm

.c1e5					StartROM:
.c1e5	18		clc				clc
.c1e6	fb		xce				xce
.c1e7	c2 30		rep #$30			rep 	#$30
.c1e9	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c1ec	1b		tcs				tcs
.c1ed	e2 30		sep #$30			sep 	#$30 						; clear AXY in 16 bit.
.c1ef	c2 30		rep #$30			rep 	#$30
.c1f1	a9 00 00	lda #$0000			lda 	#$0000
.c1f4	aa		tax				tax
.c1f5	a8		tay				tay
.c1f6	e2 30		sep #$30			sep 	#$30
.c1f8	20 9c c3	jsr $c39c			jsr 	IF_Reset 					; reset external interface
.c1fb	20 01 c2	jsr $c201			jsr 	IFT_ClearScreen
.c1fe	4c eb c3	jmp $c3eb		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.c201					IFT_ClearScreen:
.c201	48		pha				pha
.c202	da		phx				phx
.c203	5a		phy				phy
.c204	20 9d c3	jsr $c39d			jsr 	IF_Home 					; home cursor
.c207	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.c209					_IFT_CS0:
.c209	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.c20b					_IFT_CS1:
.c20b	a9 20		lda #$20			lda 	#' '						; clear line.
.c20d	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c210	88		dey				dey
.c211	d0 f8		bne $c20b			bne 	_IFT_CS1
.c213	20 b0 c3	jsr $c3b0			jsr 	IF_NewLine 					; next line down
.c216	ca		dex				dex
.c217	d0 f0		bne $c209			bne 	_IFT_CS0
.c219	7a		ply				ply
.c21a	fa		plx				plx
.c21b	68		pla				pla
.c21c					IFT_HomeCursor:
.c21c	48		pha				pha
.c21d	20 9d c3	jsr $c39d			jsr 	IF_Home
.c220	a9 00		lda #$00			lda 	#0
.c222	8d 00 02	sta $0200			sta 	IFT_XCursor
.c225	8d 01 02	sta $0201			sta 	IFT_YCursor
.c228	68		pla				pla
.c229	60		rts				rts
.c22a					IFT_UpLine:
.c22a	48		pha				pha
.c22b	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.c22e	3a		dec a				dec 	a 							; line above
.c22f	30 03		bmi $c234			bmi 	_IFTULExit 					; too far, abort
.c231	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos					; set to that line.
.c234					_IFTULExit:
.c234	68		pla				pla
.c235	60		rts				rts
.c236					IFT_PrintCharacter:
.c236	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.c238	f0 16		beq $c250			beq 	IFT_NewLine
.c23a	48		pha				pha
.c23b	20 68 c2	jsr $c268			jsr 	IFT_UpperCase 				; make upper case
.c23e	20 c9 c3	jsr $c3c9			jsr 	IF_Write 					; write out.
.c241	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.c244	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.c247	c9 40		cmp #$40			cmp 	#IF_Width
.c249	d0 03		bne $c24e			bne 	_IFT_PCNotEOL
.c24b	20 50 c2	jsr $c250			jsr 	IFT_NewLine 				; if so do new line.
.c24e					_IFT_PCNotEOL:
.c24e	68		pla				pla
.c24f	60		rts				rts
.c250					IFT_NewLine:
.c250	48		pha				pha
.c251	20 b0 c3	jsr $c3b0			jsr 	IF_NewLine 					; new line on actual screen.
.c254	a9 00		lda #$00			lda 	#0 							; reset x position
.c256	8d 00 02	sta $0200			sta 	IFT_XCursor
.c259	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.c25c	ad 01 02	lda $0201			lda 	IFT_YCursor
.c25f	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.c261	d0 03		bne $c266			bne 	_IFT_NL_NotEOS
.c263	20 73 c2	jsr $c273			jsr 	IFT_Scroll 					; scroll screen up.
.c266					_IFT_NL_NotEOS:
.c266	68		pla				pla
.c267	60		rts				rts
.c268					IFT_UpperCase:
.c268	c9 61		cmp #$61			cmp 	#"a"
.c26a	90 06		bcc $c272			bcc 	_IFT_UCExit
.c26c	c9 7b		cmp #$7b			cmp 	#"z"+1
.c26e	b0 02		bcs $c272			bcs 	_IFT_UCExit
.c270	49 20		eor #$20			eor 	#$20
.c272					_IFT_UCExit:
.c272	60		rts				rts
.c273					IFT_Scroll:
.c273	48		pha				pha 								; save AXY
.c274	da		phx				phx
.c275	5a		phy				phy
.c276	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.c278					_IFT_SLoop:
.c278	20 98 c2	jsr $c298			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.c27b	e8		inx				inx
.c27c	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.c27e	d0 f8		bne $c278			bne 	_IFT_SLoop
.c280	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c282	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c285	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.c287					_IFT_SBlank:
.c287	a9 20		lda #$20			lda 	#32
.c289	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c28c	ca		dex				dex
.c28d	d0 f8		bne $c287			bne 	_IFT_SBlank
.c28f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.c291	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c294	7a		ply				ply
.c295	fa		plx				plx
.c296	68		pla				pla
.c297	60		rts				rts
.c298					_IFT_ScrollLine:
.c298	da		phx				phx
.c299	da		phx				phx
.c29a	8a		txa				txa 								; copy line into buffer.
.c29b	1a		inc a				inc 	a 							; next line down.
.c29c	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c29f	a2 00		ldx #$00			ldx 	#0
.c2a1					_IFTScrollCopy1:
.c2a1	20 c0 c3	jsr $c3c0			jsr 	IF_Read
.c2a4	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.c2a7	e8		inx				inx
.c2a8	e0 40		cpx #$40			cpx 	#IF_Width
.c2aa	d0 f5		bne $c2a1			bne 	_IFTScrollCopy1
.c2ac	68		pla				pla
.c2ad	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c2b0	a2 00		ldx #$00			ldx 	#0
.c2b2					_IFTScrollCopy2:
.c2b2	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.c2b5	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c2b8	e8		inx				inx
.c2b9	e0 40		cpx #$40			cpx 	#IF_Width
.c2bb	d0 f5		bne $c2b2			bne 	_IFTScrollCopy2
.c2bd	fa		plx				plx
.c2be	60		rts				rts
.c2bf					IFT_SetYPos:
.c2bf	48		pha				pha
.c2c0	da		phx				phx
.c2c1	aa		tax				tax
.c2c2	20 1c c2	jsr $c21c			jsr 	IFT_HomeCursor
.c2c5	e0 00		cpx #$00			cpx 	#0
.c2c7	f0 09		beq $c2d2			beq 	_IFT_MOAExit
.c2c9					_IFT_MOALoop:
.c2c9	20 b0 c3	jsr $c3b0			jsr 	IF_NewLine
.c2cc	ee 01 02	inc $0201			inc 	IFT_YCursor
.c2cf	ca		dex				dex
.c2d0	d0 f7		bne $c2c9			bne		_IFT_MOALoop
.c2d2					_IFT_MOAExit:
.c2d2	fa		plx				plx
.c2d3	68		pla				pla
.c2d4	60		rts				rts
.c2d5					IFT_GetKeyCursor:
.c2d5	20 dd c2	jsr $c2dd			jsr 	_IFT_FlipCursor 			; reverse current
.c2d8					_IFT_GKCWait:
.c2d8	20 da c3	jsr $c3da			jsr 	IF_GetKey 					; get key
.c2db	f0 fb		beq $c2d8			beq 	_IFT_GKCWait
.c2dd					_IFT_FlipCursor:
.c2dd	48		pha				pha 								; save
.c2de	20 c0 c3	jsr $c3c0			jsr 	IF_Read 					; read
.c2e1	20 d2 c3	jsr $c3d2			jsr 	IF_LeftOne
.c2e4	49 80		eor #$80			eor 	#$80 						; reverse
.c2e6	20 c9 c3	jsr $c3c9			jsr 	IF_Write 					; write
.c2e9	20 d2 c3	jsr $c3d2			jsr 	IF_LeftOne
.c2ec	68		pla				pla
.c2ed	60		rts				rts
.c2ee					IFT_ReadLine:
.c2ee	48		pha				pha
.c2ef					_IFT_RLLoop:
.c2ef	20 d5 c2	jsr $c2d5			jsr 	IFT_GetKeyCursor 			; get keystroke
.c2f2	c9 0d		cmp #$0d			cmp 	#13							; return
.c2f4	f0 7d		beq $c373			beq 	_IFT_RLExit
.c2f6	c9 20		cmp #$20			cmp 	#32 						; control character
.c2f8	90 05		bcc $c2ff			bcc 	_IFT_Control
.c2fa	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.c2fd	80 f0		bra $c2ef			bra 	_IFT_RLLoop
.c2ff					_IFT_Control:
.c2ff	c9 01		cmp #$01			cmp 	#"A"-64
.c301	f0 26		beq $c329			beq 	_IFT_Left
.c303	c9 04		cmp #$04			cmp 	#"D"-64
.c305	f0 2e		beq $c335			beq 	_IFT_Right
.c307	c9 17		cmp #$17			cmp 	#"W"-64
.c309	f0 36		beq $c341			beq 	_IFT_Up
.c30b	c9 13		cmp #$13			cmp 	#"S"-64
.c30d	f0 3e		beq $c34d			beq 	_IFT_Down
.c30f	c9 08		cmp #$08			cmp 	#"H"-64
.c311	f0 09		beq $c31c			beq 	_IFT_Backspace
.c313	c9 1a		cmp #$1a			cmp 	#"Z"-64
.c315	d0 d8		bne $c2ef			bne 	_IFT_RLLoop
.c317	20 01 c2	jsr $c201			jsr 	IFT_ClearScreen				; clear CTL-Z
.c31a	80 d3		bra $c2ef			bra 	_IFT_RLLoop
.c31c					_IFT_Backspace:
.c31c	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.c31f	f0 ce		beq $c2ef			beq 	_IFT_RLLoop
.c321	20 d2 c3	jsr $c3d2			jsr 	IF_LeftOne
.c324	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.c326	20 c9 c3	jsr $c3c9			jsr 	IF_Write
.c329					_IFT_Left:
.c329	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.c32c	10 29		bpl $c357			bpl 	_IFT_Reposition
.c32e	a9 3f		lda #$3f			lda 	#IF_Width-1
.c330					_IFT_SetX:
.c330	8d 00 02	sta $0200			sta 	IFT_XCursor
.c333	80 22		bra $c357			bra 	_IFT_Reposition
.c335					_IFT_Right:
.c335	ee 00 02	inc $0200			inc 	IFT_XCursor
.c338	ad 00 02	lda $0200			lda 	IFT_XCursor
.c33b	49 40		eor #$40			eor 	#IF_Width
.c33d	f0 f1		beq $c330			beq 	_IFT_SetX
.c33f	80 16		bra $c357			bra 	_IFT_Reposition
.c341					_IFT_Up:
.c341	ce 01 02	dec $0201			dec 	IFT_YCursor
.c344	10 11		bpl $c357			bpl 	_IFT_Reposition
.c346	a9 1f		lda #$1f			lda 	#IF_Height-1
.c348					_IFT_SetY:
.c348	8d 01 02	sta $0201			sta 	IFT_YCursor
.c34b	80 0a		bra $c357			bra 	_IFT_Reposition
.c34d					_IFT_Down:
.c34d	ee 01 02	inc $0201			inc 	IFT_YCursor
.c350	ad 01 02	lda $0201			lda 	IFT_YCursor
.c353	49 20		eor #$20			eor 	#IF_Height
.c355	f0 f1		beq $c348			beq 	_IFT_SetY
.c357					_IFT_Reposition:
.c357	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.c35a	48		pha				pha
.c35b	ad 01 02	lda $0201			lda 	IFT_YCursor
.c35e	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c361	68		pla				pla
.c362	aa		tax				tax
.c363	e0 00		cpx #$00			cpx 	#0
.c365	f0 88		beq $c2ef			beq 	_IFT_RLLoop
.c367					_IFT_MoveRight:
.c367	20 c0 c3	jsr $c3c0			jsr 	IF_Read
.c36a	ee 00 02	inc $0200			inc 	IFT_XCursor
.c36d	ca		dex				dex
.c36e	d0 f7		bne $c367			bne 	_IFT_MoveRight
.c370	4c ef c2	jmp $c2ef			jmp 	_IFT_RLLoop
.c373					_IFT_RLExit:
.c373	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.c376	20 bf c2	jsr $c2bf			jsr 	IFT_SetYPos
.c379	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.c37b					_IFT_RLRead:
.c37b	20 c0 c3	jsr $c3c0			jsr 	IF_Read
.c37e	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c381	e8		inx				inx
.c382	e0 40		cpx #$40			cpx 	#IF_Width
.c384	d0 f5		bne $c37b			bne 	_IFT_RLRead
.c386					_IFT_RL_Trim:
.c386	ca		dex				dex 	 							; previous char
.c387	30 07		bmi $c390			bmi 	_IFT_Found 					; gone too far
.c389	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.c38c	c9 20		cmp #$20			cmp 	#" "
.c38e	f0 f6		beq $c386			beq 	_IFT_RL_Trim
.c390					_IFT_Found:
.c390	e8		inx				inx 								; forward to non-space
.c391	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.c393	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.c396	68		pla				pla
.c397	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.c399	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.c39b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.c39c					IF_Reset:
.c39c	60		rts				rts
.c39d					IF_Home:
.c39d	48		pha				pha
.c39e	64 08		stz $08				stz 	IF_XPos 					; zero X position
.c3a0	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.c3a2	85 04		sta $04				sta 	IF_Pos
.c3a4	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.c3a6	85 05		sta $05				sta 	IF_Pos+1
.c3a8	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.c3aa	85 06		sta $06				sta 	IF_Pos+2
.c3ac	64 07		stz $07				stz 	IF_Pos+3
.c3ae	68		pla				pla
.c3af	60		rts				rts
.c3b0					IF_NewLine:
.c3b0	48		pha				pha
.c3b1	64 08		stz $08				stz 	IF_XPos						; back to start of line
.c3b3	18		clc				clc 								; down one line
.c3b4	a5 04		lda $04				lda 	IF_Pos
.c3b6	69 40		adc #$40			adc 	#64
.c3b8	85 04		sta $04				sta 	IF_Pos
.c3ba	90 02		bcc $c3be			bcc 	_IF_NoCarry 				; carry through.
.c3bc	e6 05		inc $05				inc 	IF_Pos+1
.c3be					_IF_NoCarry:
.c3be	68		pla				pla
.c3bf	60		rts				rts
.c3c0					IF_Read:
.c3c0	5a		phy				phy 								; save current Y
.c3c1	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.c3c3	b7 04		lda [$04],y			lda 	[IF_Pos],y
.c3c5	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3c7	7a		ply				ply									; restore Y
.c3c8	60		rts				rts
.c3c9					IF_Write:
.c3c9	5a		phy				phy 								; save current Y
.c3ca	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.c3cc	97 04		sta [$04],y			sta 	[IF_Pos],y
.c3ce	e6 08		inc $08				inc 	IF_XPos 					; step right.
.c3d0	7a		ply				ply									; restore Y
.c3d1	60		rts				rts
.c3d2					IF_LeftOne:
.c3d2	c6 08		dec $08				dec 	IF_XPos
.c3d4	60		rts				rts
.c3d5					IF_CheckBreak:
.c3d5	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.c3d9	60		rts				rts
.c3da					IF_GetKey:
.c3da	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.c3de	f0 08		beq $c3e8			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.c3e0	48		pha				pha 								; key pressed, clear queue.
.c3e1	a9 00		lda #$00			lda 	#0
.c3e3	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.c3e7	68		pla				pla
.c3e8					_IFGK_NoKey:
.c3e8	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.c3ea	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm

.c3eb					BASIC_Start:
.c3eb	20 0b c4	jsr $c40b			jsr 	ResetRunStatus 				; clear everything (CLR command)
.c3ee	a9 00		lda #$00			lda 	#0 							; mark temp string pointer uninitialised.
.c3f0	85 21		sta $21				sta 	zTempStr+1 					; (done before every base level evaluation/or command)
.c3f2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.c3f4	85 16		sta $16				sta 	zCodePtr+0
.c3f6	a9 10		lda #$10			lda 	#BasicProgram >> 8
.c3f8	85 17		sta $17				sta 	zCodePtr+1
.c3fa	a9 00		lda #$00			lda 	#0
.c3fc	85 18		sta $18				sta 	zCodePtr+2
.c3fe	85 19		sta $19				sta 	zCodePtr+3
.c400	a0 03		ldy #$03			ldy 	#3
.c402	c8		iny				iny
.c403	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c405	20 19 c4	jsr $c419			jsr 	EvaluateExpression
>c408	02						.byte 	2
.c409					SyntaxError:
.c409					ERR_Handler:
.c409	80 fe		bra $c409			bra 	ERR_Handler

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.c40b					CLR_Command:
.c40b					ResetRunStatus:
.c40b	a9 00		lda #$00			lda 	#HighMemory & $FF
.c40d	8d 26 04	sta $0426			sta 	StringPtr
.c410	a9 80		lda #$80			lda 	#HighMemory >> 8
.c412	8d 27 04	sta $0427			sta 	StringPtr+1
.c415	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.c416					EVESyntax:
.c416	4c 09 c4	jmp $c409			jmp 	SyntaxError
.c419					EvaluateExpression:
.c419	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.c41b					EvaluateExpressionX:
.c41b	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.c41d					EvaluateExpressionXA:
.c41d	48		pha				pha 								; save precedence on stack.
.c41e	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c420	f0 f4		beq $c416			beq 	EVESyntax 					; end of line, syntax error.
.c422	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.c424	b0 03		bcs $c429			bcs 	_EVNotVariable
.c426	4c 12 c5	jmp $c512			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.c429					_EVNotVariable:
.c429	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.c42b	90 e9		bcc $c416			bcc 	EVESyntax
.c42d	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.c42f	b0 7b		bcs $c4ac			bcs 	_EVNotInteger
.c431	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.c433	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.c436	a9 00		lda #$00			lda 	#0
.c438	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c43b	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c43e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c441	a9 01		lda #$01			lda 	#1 							; set to type 1 (integer)
.c443	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c446					_EVCheckNextInteger:
.c446	c8		iny				iny
.c447	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c449	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.c44b	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.c44d	b0 0d		bcs $c45c			bcs 	_EVCheckDecimal
.c44f	48		pha				pha 								; save it.
.c450	20 16 c5	jsr $c516			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.c453	68		pla				pla
.c454	1d 00 03	ora $0300,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.c457	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c45a	80 ea		bra $c446			bra 	_EVCheckNextInteger
.c45c					_EVCheckDecimal:
.c45c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c45e	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.c460	d0 05		bne $c467			bne 	_EVGotAtom 					; no, get atom.
.c462					_EVIsDecimal:
.c462	20 46 c5	jsr $c546			jsr 	EVGetDecimal 				; extend to the decimal part.
.c465	80 00		bra $c467			bra 	_EVGotAtom 					; and continue to got atom.
.c467					_EVGotAtom:
.c467	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c469	10 3f		bpl $c4aa			bpl 	_EVExitDrop 				; must be a token.
.c46b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.c46d	b0 3b		bcs $c4aa			bcs 	_EVExitDrop
.c46f	68		pla				pla 								; get current precedence
.c470	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.c472	da		phx				phx 								; save X
.c473	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c475	aa		tax				tax 								; put in X
.c476	bd 30 c0	lda $c030,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.c479	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.c47b	fa		plx				plx 								; restore X
.c47c	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.c47e	90 2b		bcc $c4ab			bcc 	_EVExit 					; exit if too low.
.c480	f0 29		beq $c4ab			beq 	_EVExit 					; exit if equals
.c482	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.c484	48		pha				pha
.c485	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c487	48		pha				pha
.c488	c8		iny				iny
.c489	da		phx				phx 								; save current position
.c48a	e8		inx				inx
.c48b	e8		inx				inx
.c48c	e8		inx				inx
.c48d	e8		inx				inx
.c48e	e8		inx				inx
.c48f	e8		inx				inx
.c490	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.c492	20 1d c4	jsr $c41d			jsr 	EvaluateExpressionXA 		; do the RHS.
.c495	fa		plx				plx 								; restore X
.c496	68		pla				pla 								; get the binary operator in A.
.c497					_EVCallA:
.c497	da		phx				phx 								; save X again
.c498	0a		asl a				asl 	a 							; double, lose the MSB.
.c499	aa		tax				tax									; put in X
.c49a	bd 00 c0	lda $c000,x			lda 	VectorTable,x 				; copy address into zGenPtr
.c49d	85 1e		sta $1e				sta 	zGenPtr
.c49f	bd 01 c0	lda $c001,x			lda 	VectorTable+1,x
.c4a2	85 1f		sta $1f				sta 	zGenPtr+1
.c4a4	fa		plx				plx 								; restore X
.c4a5	20 13 c5	jsr $c513			jsr 	EVGoZGenPtr 				; execute that function/operator
.c4a8	80 bd		bra $c467			bra 	_EVGotAtom 					; and loop back.
.c4aa					_EVExitDrop:
.c4aa	68		pla				pla
.c4ab					_EVExit:
.c4ab	60		rts				rts
.c4ac					_EVNotInteger:
.c4ac	c8		iny				iny
.c4ad	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.c4af	d0 19		bne $c4ca			bne 	_EVNotMinus
.c4b1	20 97 c5	jsr $c597			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.c4b4	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type
.c4b7	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.c4b9	f0 05		beq $c4c0			beq 	_EVMinusFloat
.c4bb	20 86 c9	jsr $c986			jsr 	IntegerNegateAlways 		; negation
.c4be	80 a7		bra $c467			bra 	_EVGotAtom 					; and go back.
.c4c0					_EVMinusFloat:
.c4c0	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; invert the sign bit.
.c4c3	49 80		eor #$80			eor 	#$80
.c4c5	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c4c8	80 9d		bra $c467			bra 	_EVGotAtom
.c4ca					_EVNotMinus:
.c4ca	c9 b9		cmp #$b9			cmp 	#token_lparen 				; is it left parenthesis
.c4cc	d0 0c		bne $c4da			bne 	_EVNotParenthesis
.c4ce	20 1b c4	jsr $c41b			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.c4d1	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c4d3	c8		iny				iny
.c4d4	c9 ba		cmp #$ba			cmp 	#token_rparen 				; okay if right bracket.
.c4d6	f0 8f		beq $c467			beq 	_EVGotAtom
.c4d8	80 fe		bra $c4d8		_error: bra _error
.c4da					_EVNotParenthesis:
.c4da	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.c4dc	d0 0c		bne $c4ea			bne 	_EVNotNot
.c4de	20 97 c5	jsr $c597			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.c4e1	20 7a ce	jsr $ce7a			jsr 	FPUToInteger 				; make it an integer - if possible.
.c4e4	20 74 c5	jsr $c574			jsr 	NotInteger 					; do the not calculation
.c4e7	4c 67 c4	jmp $c467			jmp 	_EVGotAtom
.c4ea					_EVNotNot:
.c4ea	c9 fe		cmp #$fe			cmp 	#$FE
.c4ec	d0 15		bne $c503			bne 	_EVNotString
.c4ee	20 86 c8	jsr $c886			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.c4f1	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.c4f3	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c4f6	a5 21		lda $21				lda 	zTempStr+1
.c4f8	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c4fb	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.c4fd	9d 05 03	sta $0305,x			sta 	XS_Type,x
.c500	4c 67 c4	jmp $c467			jmp 	_EVGotAtom
.c503					_EVNotString:
.c503	ea		nop				nop
.c504	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.c506	90 04		bcc $c50c			bcc 	_EVBadElement
.c508	c9 b3		cmp #$b3			cmp 	#lastUnaryFunction+1
.c50a	90 03		bcc $c50f			bcc 	_EVUnaryFunction
.c50c					_EVBadElement:
.c50c	4c 09 c4	jmp $c409			jmp 	SyntaxError
.c50f					_EVUnaryFunction:
.c50f	4c 97 c4	jmp $c497			jmp 	_EVCallA
.c512					_EVVariableHandler:
.c512	ea		nop				nop
.c513					EVGoZGenPtr:
.c513	6c 1e 00	jmp ($001e)			jmp 	 (zGenPtr)
.c516					EVShiftMantissaLeft6:
.c516	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.c519	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.c51c	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c51f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c522	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c525	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c528	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c52b	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c52e	a9 00		lda #$00			lda 	#0
.c530	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c533	20 36 c5	jsr $c536			jsr 	_EVSMLShift 					; call it here to do it twice
.c536					_EVSMLShift:
.c536	5e 04 03	lsr $0304,x			lsr 	XS_Exponent,x
.c539	7e 03 03	ror $0303,x			ror 	XS_Mantissa+3,x
.c53c	7e 02 03	ror $0302,x			ror 	XS_Mantissa+2,x
.c53f	7e 01 03	ror $0301,x			ror 	XS_Mantissa+1,x
.c542	7e 00 03	ror $0300,x			ror 	XS_Mantissa+0,x
.c545	60		rts				rts
.c546					EVGetDecimal:
.c546	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.c548	8d 00 04	sta $0400			sta 	Num_Buffer
.c54b	da		phx				phx
.c54c	c8		iny				iny
.c54d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c54f	c8		iny				iny
.c550	3a		dec a				dec 	a								; convert to a string length.
.c551	3a		dec a				dec 	a
.c552	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.c554					_EVGDCopy:
.c554	48		pha				pha 									; save count
.c555	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c557	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.c55a	e8		inx				inx 									; forward ....
.c55b	c8		iny				iny
.c55c	68		pla				pla 									; get count
.c55d	3a		dec a				dec 	a 								; until zero
.c55e	d0 f4		bne $c554			bne 	_EVGDCopy
.c560	9d 00 04	sta $0400,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.c563	fa		plx				plx 									; restore X
.c564	a9 00		lda #$00			lda 	#Num_Buffer & $FF 				; set zGenPtr
.c566	85 1e		sta $1e				sta 	zGenPtr
.c568	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.c56a	85 1f		sta $1f				sta 	zGenPtr+1
.c56c	5a		phy				phy 									; save Y
.c56d	a0 00		ldy #$00			ldy 	#0 								; start position
.c56f	20 53 d0	jsr $d053			jsr 	FPFromString 					; convert current
.c572	7a		ply				ply 									; restore Y
.c573	60		rts				rts
.c574					NotInteger:
.c574	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c577	49 ff		eor #$ff			eor 	#$FF
.c579	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c57c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c57f	49 ff		eor #$ff			eor 	#$FF
.c581	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c584	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c587	49 ff		eor #$ff			eor 	#$FF
.c589	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c58c	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c58f	49 ff		eor #$ff			eor 	#$FF
.c591	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c594	60		rts				rts
.c595					EvaluateGetAtom:
.c595	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.c597					EvaluateGetAtomX:
.c597	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.c599	20 1d c4	jsr $c41d			jsr 	EvaluateExpressionXA
.c59c	bd 05 03	lda $0305,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.c59f	29 0f		and #$0f			and 	#15
.c5a1	c9 02		cmp #$02			cmp 	#2
.c5a3	b0 01		bcs $c5a6			bcs 	EvaluateType
.c5a5	60		rts				rts
.c5a6					EvaluateType:
.c5a6	80 fe		bra $c5a6		_error: bra _error
.c5a8					EvaluateNumber:
.c5a8	a2 00		ldx #$00			ldx 	#0
.c5aa					EvaluateNumberX:
.c5aa	20 1b c4	jsr $c41b			jsr 	EvaluateExpressionX
.c5ad	ad 05 03	lda $0305			lda 	XS_Type 						; check type is 0/1
.c5b0	29 0f		and #$0f			and 	#15
.c5b2	c9 02		cmp #$02			cmp 	#2
.c5b4	b0 f0		bcs $c5a6			bcs 	EvaluateType
.c5b6	60		rts				rts
.c5b7					EvaluateString:
.c5b7	a2 00		ldx #$00			ldx 	#0
.c5b9					EvaluateStringX:
.c5b9	20 1b c4	jsr $c41b			jsr 	EvaluateExpressionX
.c5bc	ad 05 03	lda $0305			lda 	XS_Type 						; check type is 2
.c5bf	29 0f		and #$0f			and 	#15
.c5c1	c9 02		cmp #$02			cmp 	#2
.c5c3	d0 e1		bne $c5a6			bne 	EvaluateType
.c5c5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.c5c6					BinaryOp_And:
.c5c6	20 3e c6	jsr $c63e			jsr 	BinaryMakeBothInteger
.c5c9	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5cc	3d 06 03	and $0306,x			and 	XS2_Mantissa+0,x
.c5cf	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5d2	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5d5	3d 07 03	and $0307,x			and 	XS2_Mantissa+1,x
.c5d8	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c5db	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c5de	3d 08 03	and $0308,x			and 	XS2_Mantissa+2,x
.c5e1	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c5e4	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c5e7	3d 09 03	and $0309,x			and 	XS2_Mantissa+3,x
.c5ea	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c5ed	60		rts				rts
.c5ee					BinaryOp_Or:
.c5ee	20 3e c6	jsr $c63e			jsr 	BinaryMakeBothInteger
.c5f1	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c5f4	1d 06 03	ora $0306,x			ora 	XS2_Mantissa+0,x
.c5f7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c5fa	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c5fd	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c600	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c603	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c606	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c609	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c60c	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c60f	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c612	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c615	60		rts				rts
.c616					BinaryOp_Eor:
.c616					BinaryOp_Xor:
.c616	20 3e c6	jsr $c63e			jsr 	BinaryMakeBothInteger
.c619	bd 00 03	lda $0300,x			lda		XS_Mantissa+0,x
.c61c	5d 06 03	eor $0306,x			eor 	XS2_Mantissa+0,x
.c61f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c622	bd 01 03	lda $0301,x			lda		XS_Mantissa+1,x
.c625	5d 07 03	eor $0307,x			eor 	XS2_Mantissa+1,x
.c628	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c62b	bd 02 03	lda $0302,x			lda		XS_Mantissa+2,x
.c62e	5d 08 03	eor $0308,x			eor 	XS2_Mantissa+2,x
.c631	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c634	bd 03 03	lda $0303,x			lda		XS_Mantissa+3,x
.c637	5d 09 03	eor $0309,x			eor 	XS2_Mantissa+3,x
.c63a	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c63d	60		rts				rts
.c63e					BinaryMakeBothInteger:
.c63e	da		phx				phx 								; save X
.c63f	e8		inx				inx
.c640	e8		inx				inx
.c641	e8		inx				inx
.c642	e8		inx				inx
.c643	e8		inx				inx
.c644	e8		inx				inx
.c645	20 49 c6	jsr $c649			jsr 	BinaryMakeInteger 			; convert to integer.
.c648	fa		plx				plx 								; restore X and fall through.
.c649					BinaryMakeInteger:
.c649	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c64c	29 0f		and #$0f			and 	#15 						; check type zero
.c64e	f0 04		beq $c654			beq 	_BMIConvert 				; if float convert to integer.
.c650	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.c651	90 04		bcc $c657			bcc 	_BMIError
.c653	60		rts				rts
.c654					_BMIConvert:
.c654	4c 7a ce	jmp $ce7a			jmp 	FPUToInteger 				; convert to integer
.c657					_BMIError:
.c657	80 fe		bra $c657		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.c659					Binary_Equal:
.c659	20 a5 c6	jsr $c6a5			jsr 	CompareValues
.c65c	09 00		ora #$00			ora 	#0
.c65e	f0 04		beq $c664			beq 	CCTrue
.c660	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.c662	80 02		bra $c666			bra 	CCWrite
.c664	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.c666	9d 00 03	sta $0300,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.c669	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c66c	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c66f	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c672	a9 01		lda #$01			lda 	#1
.c674	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; set type to integer whatever.
.c677	60		rts				rts
.c678					Binary_NotEqual:
.c678	20 a5 c6	jsr $c6a5			jsr 	CompareValues
.c67b	09 00		ora #$00			ora 	#0
.c67d	d0 e1		bne $c660			bne 	CCFalse
.c67f	80 e3		bra $c664			bra 	CCTrue
.c681					Binary_Less:
.c681	20 a5 c6	jsr $c6a5			jsr 	CompareValues
.c684	09 00		ora #$00			ora 	#0
.c686	30 dc		bmi $c664			bmi 	CCTrue
.c688	80 d6		bra $c660			bra 	CCFalse
.c68a					Binary_LessEqual:
.c68a	20 a5 c6	jsr $c6a5			jsr 	CompareValues
.c68d	c9 01		cmp #$01			cmp 	#1
.c68f	d0 d3		bne $c664			bne 	CCTrue
.c691	80 cd		bra $c660			bra 	CCFalse
.c693					Binary_GreaterEqual:
.c693	20 a5 c6	jsr $c6a5			jsr 	CompareValues
.c696	09 00		ora #$00			ora 	#0
.c698	10 ca		bpl $c664			bpl 	CCTrue
.c69a	80 c4		bra $c660			bra 	CCFalse
.c69c					Binary_Greater:
.c69c	20 a5 c6	jsr $c6a5			jsr 	CompareValues
.c69f	c9 01		cmp #$01			cmp 	#1
.c6a1	d0 c1		bne $c664			bne 	CCTrue
.c6a3	80 bb		bra $c660			bra 	CCFalse
.c6a5					CompareValues:
.c6a5	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and the types together
.c6a8	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6ab	c9 02		cmp #$02			cmp 	#2
.c6ad	f0 13		beq $c6c2			beq 	_CVString
.c6af	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c6b2	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c6b5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c6b6	90 03		bcc $c6bb			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c6b8	4c 08 c7	jmp $c708			jmp 	CompareInteger32 							; so execute code at \1
.c6bb					_BCFloat:
.c6bb	20 d6 c7	jsr $c7d6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c6be	4c 89 cd	jmp $cd89			jmp 	FPCompare 							; and execute code at \2
.c6c1	60		rts				rts
.c6c2					_CVString:
.c6c2	da		phx				phx 								; save XY
.c6c3	5a		phy				phy
.c6c4	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c6c7	85 1a		sta $1a				sta		zLTemp1+0
.c6c9	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c6cc	85 1b		sta $1b				sta 	zLTemp1+1
.c6ce	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c6d1	85 1c		sta $1c				sta 	zLTemp1+2
.c6d3	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c6d6	85 1d		sta $1d				sta 	zLTemp1+3
.c6d8	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.c6da	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c6dc	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6de	90 02		bcc $c6e2			bcc 	_CVCommon
.c6e0	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.c6e2					_CVCommon:
.c6e2	aa		tax				tax 								; put shorter string length in zero.
.c6e3	f0 0c		beq $c6f1			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.c6e5					_CVCompare:
.c6e5	c8		iny				iny 								; next character
.c6e6	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.c6e8	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6ea	90 13		bcc $c6ff			bcc 	_CVReturnLess 				; <
.c6ec	d0 15		bne $c703			bne 	_CVReturnGreater 			; >
.c6ee	ca		dex				dex 								; until common length matched.
.c6ef	d0 f4		bne $c6e5			bne 	_CVCompare
.c6f1					_CVMatch:
.c6f1	a0 00		ldy #$00			ldy 	#0
.c6f3	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c6f5	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.c6f7	90 06		bcc $c6ff			bcc 	_CVReturnLess 				; <
.c6f9	d0 08		bne $c703			bne 	_CVReturnGreater 			; >
.c6fb	a9 00		lda #$00			lda 	#0
.c6fd	80 06		bra $c705			bra 	_CVExit 					; same common, same length, same string
.c6ff					_CVReturnLess:
.c6ff	a9 ff		lda #$ff			lda 	#$FF
.c701	80 02		bra $c705			bra 	_CVExit
.c703					_CVReturnGreater:
.c703	a9 01		lda #$01			lda 	#$01
.c705					_CVExit:
.c705	7a		ply				ply
.c706	fa		plx				plx
.c707	60		rts				rts
.c708					CompareInteger32:
.c708	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.c70b	49 80		eor #$80			eor 	#$80
.c70d	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c710	bd 09 03	lda $0309,x			lda 	XS2_Mantissa+3,x
.c713	49 80		eor #$80			eor 	#$80
.c715	9d 09 03	sta $0309,x			sta 	XS2_Mantissa+3,x
.c718	20 b0 c7	jsr $c7b0			jsr 	SubInteger32 				; subtraction
.c71b	90 11		bcc $c72e			bcc 	_CI32Less 					; cc return -1
.c71d	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; check if zero
.c720	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.c723	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.c726	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.c729	f0 02		beq $c72d			beq 	_CI32Exit
.c72b	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.c72d					_CI32Exit:
.c72d	60		rts				rts
.c72e					_CI32Less:
.c72e	a9 ff		lda #$ff			lda 	#$FF
.c730	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.c731					BinaryOp_Add:
.c731	bd 05 03	lda $0305,x			lda 	XS_Type,x  					; and types together
.c734	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c737	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.c739	d0 13		bne $c74e			bne 	_BOAString
.c73b	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c73e	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c741	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c742	90 03		bcc $c747			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c744	4c 8a c7	jmp $c78a			jmp 	AddInteger32 							; so execute code at \1
.c747					_BCFloat:
.c747	20 d6 c7	jsr $c7d6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c74a	4c 0f cb	jmp $cb0f			jmp 	FPAdd 							; and execute code at \2
.c74d	60		rts				rts
.c74e					_BOAString:
.c74e	4c f0 c7	jmp $c7f0			jmp 	ConcatenateString 			; concatenate two strings.
.c751					BinaryOp_Subtract:
.c751	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c754	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c757	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c758	90 03		bcc $c75d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c75a	4c b0 c7	jmp $c7b0			jmp 	SubInteger32 							; so execute code at \1
.c75d					_BCFloat:
.c75d	20 d6 c7	jsr $c7d6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c760	4c 05 cb	jmp $cb05			jmp 	FPSubtract 							; and execute code at \2
.c763	60		rts				rts
.c764					BinaryOp_Multiply:
.c764	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c767	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c76a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c76b	90 03		bcc $c770			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c76d	4c ab c8	jmp $c8ab			jmp 	MulInteger32 							; so execute code at \1
.c770					_BCFloat:
.c770	20 d6 c7	jsr $c7d6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c773	4c 69 cc	jmp $cc69			jmp 	FPMultiply 							; and execute code at \2
.c776	60		rts				rts
.c777					BinaryOp_Divide:
.c777	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; and 2 type bytes together.
.c77a	3d 0b 03	and $030b,x			and 	XS2_Type,x
.c77d	4a		lsr a				lsr 	a 							; shift bit 0 into C
.c77e	90 03		bcc $c783			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.c780	4c 02 c9	jmp $c902			jmp 	DivInteger32 							; so execute code at \1
.c783					_BCFloat:
.c783	20 d6 c7	jsr $c7d6			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.c786	4c e1 cb	jmp $cbe1			jmp 	FPDivide 							; and execute code at \2
.c789	60		rts				rts
.c78a					AddInteger32:
.c78a	18		clc				clc
.c78b	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c78e	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.c791	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c794	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c797	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.c79a	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c79d	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7a0	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.c7a3	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7a6	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7a9	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.c7ac	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7af	60		rts				rts
.c7b0					SubInteger32:
.c7b0	38		sec				sec
.c7b1	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.c7b4	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c7b7	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c7ba	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7bd	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c7c0	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c7c3	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c7c6	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c7c9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c7cc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c7cf	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c7d2	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c7d5	60		rts				rts
.c7d6					BinaryMakeBothFloat:
.c7d6	da		phx				phx 								; save X
.c7d7	e8		inx				inx
.c7d8	e8		inx				inx
.c7d9	e8		inx				inx
.c7da	e8		inx				inx
.c7db	e8		inx				inx
.c7dc	e8		inx				inx
.c7dd	20 e1 c7	jsr $c7e1			jsr 	BinaryMakeFloat 			; convert to float.
.c7e0	fa		plx				plx 								; restore X and fall through.
.c7e1					BinaryMakeFloat:
.c7e1	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; get type byte.
.c7e4	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.c7e5	b0 04		bcs $c7eb			bcs 	_BMFConvert
.c7e7	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.c7e8	b0 04		bcs $c7ee			bcs 	_BMFError
.c7ea	60		rts				rts
.c7eb					_BMFConvert:
.c7eb	4c 1b ce	jmp $ce1b			jmp 	FPUToFloat 					; convert to float
.c7ee					_BMFError:
.c7ee	80 fe		bra $c7ee		_error: bra _error
.c7f0					ConcatenateString:
.c7f0	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.c7f3	85 1a		sta $1a				sta		zLTemp1+0
.c7f5	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c7f8	85 1b		sta $1b				sta 	zLTemp1+1
.c7fa	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x
.c7fd	85 1c		sta $1c				sta 	zLTemp1+2
.c7ff	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c802	85 1d		sta $1d				sta 	zLTemp1+3
.c804	5a		phy				phy
.c805	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.c807	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.c809	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.c80b	7a		ply				ply
.c80c	b0 37		bcs $c845			bcs 	_CSError					; check in range.
.c80e	c9 fe		cmp #$fe			cmp 	#maxString+1
.c810	b0 33		bcs $c845			bcs 	_CSError
.c812	20 4b c8	jsr $c84b			jsr 	AllocateTempString 			; store the result
.c815	20 30 c8	jsr $c830			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c818	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.c81b	85 1a		sta $1a				sta 	zLTemp1
.c81d	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x
.c820	85 1b		sta $1b				sta 	zLTemp1+1
.c822	20 30 c8	jsr $c830			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.c825	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.c827	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c82a	a5 21		lda $21				lda 	zTempStr+1
.c82c	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c82f	60		rts				rts
.c830					_CSCopyString:
.c830	da		phx				phx
.c831	5a		phy				phy
.c832	a0 00		ldy #$00			ldy 	#0 							; get length
.c834	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c836	f0 0a		beq $c842			beq 	_CSCSExit 					; if zero, exit
.c838	aa		tax				tax 								; put in X
.c839					_CSCSLoop:
.c839	c8		iny				iny 								; get next char
.c83a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.c83c	20 76 c8	jsr $c876			jsr		WriteTempString 			; copy out
.c83f	ca		dex				dex 								; do whole string
.c840	d0 f7		bne $c839			bne 	_CSCSLoop
.c842					_CSCSExit:
.c842	7a		ply				ply
.c843	fa		plx				plx
.c844	60		rts				rts
.c845					_CSError:
.c845	80 fe		bra $c845		_error: bra _error

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.c847					Unary_Abs:
.c847	ea		nop				nop
.c848	20 aa c5	jsr $c5aa			jsr 	EvaluateNumberX

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.c84b					AllocateTempString:
.c84b	48		pha				pha 								; save required count.
.c84c	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.c84e	d0 0b		bne $c85b			bne 	_ATSInitialised
.c850	ad 26 04	lda $0426			lda 	StringPtr 					; set temporary string ptr 1 page below available
.c853	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.c855	ad 27 04	lda $0427			lda 	StringPtr+1
.c858	3a		dec a				dec 	a
.c859	85 21		sta $21				sta 	zTempStr+1
.c85b					_ATSInitialised:
.c85b	68		pla				pla 								; get required count back.
.c85c	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.c85e	1a		inc a				inc 	a
.c85f	18		clc				clc
.c860	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.c862	85 20		sta $20				sta 	zTempStr
.c864	a9 ff		lda #$ff			lda 	#$FF
.c866	65 21		adc $21				adc 	zTempStr+1
.c868	85 21		sta $21				sta 	zTempStr+1
.c86a	a9 00		lda #$00			lda 	#0 							; clear temp string.
.c86c	5a		phy				phy
.c86d	a8		tay				tay
.c86e	91 20		sta ($20),y			sta 	(zTempStr),y
.c870	7a		ply				ply
.c871	1a		inc a				inc 	a 							; reset the write index.
.c872	8d 27 04	sta $0427			sta 	TempStringWriteIndex
.c875	60		rts				rts
.c876					WriteTempString:
.c876	5a		phy				phy 								; save Y
.c877	ac 27 04	ldy $0427			ldy 	TempStringWriteIndex	 	; write position.
.c87a	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.c87c	ee 27 04	inc $0427			inc 	TempStringWriteIndex 		; increment the write position.
.c87f	98		tya				tya 								; unchanged Y is now length
.c880	a0 00		ldy #$00			ldy 	#0
.c882	91 20		sta ($20),y			sta 	(zTempStr),y
.c884	7a		ply				ply 								; restore Y and exit
.c885	60		rts				rts
.c886					CreateTempStringCopy:
.c886	da		phx				phx 								; save X
.c887	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c889	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.c88a	20 4b c8	jsr $c84b			jsr 	AllocateTempString 			; allocate memory for temporary string.
.c88d	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c88f	c8		iny				iny
.c890	3a		dec a				dec 	a 							; make the actual length in charactes
.c891	3a		dec a				dec 	a
.c892	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.c894	81 20		sta ($20,x)			sta 	(zTempStr,x)
.c896	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.c898	09 00		ora #$00			ora 	#0 							; if zero already, exit
.c89a	f0 0d		beq $c8a9			beq 	_CTSCExit
.c89c					_CTSCLoop:
.c89c	b1 16		lda ($16),y			lda 	(zCodePtr),y
.c89e	c8		iny				iny
.c89f	5a		phy				phy 								; save in Y
.c8a0	e8		inx				inx 								; bump index
.c8a1	9b		txy				txy 								; index into Y
.c8a2	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.c8a4	7a		ply				ply 								; restore Y
.c8a5	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.c8a7	d0 f3		bne $c89c			bne 	_CTSCLoop
.c8a9					_CTSCExit:
.c8a9	fa		plx				plx 								; restore X
.c8aa	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.c8ab					MulInteger32:
.c8ab	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.c8ae	9d 0c 03	sta $030c,x			sta 	XS3_Mantissa,x
.c8b1	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.c8b4	9d 0d 03	sta $030d,x			sta 	XS3_Mantissa+1,x
.c8b7	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.c8ba	9d 0e 03	sta $030e,x			sta 	XS3_Mantissa+2,x
.c8bd	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c8c0	9d 0f 03	sta $030f,x			sta 	XS3_Mantissa+3,x
.c8c3	a9 00		lda #$00			lda 	#0
.c8c5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 				; zero +0
.c8c8	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c8cb	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c8ce	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c8d1					_BFMMultiply:
.c8d1	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.c8d4	29 01		and #$01			and 	#1
.c8d6	f0 03		beq $c8db			beq 	_BFMNoAdd
.c8d8	20 8a c7	jsr $c78a			jsr 	AddInteger32
.c8db					_BFMNoAdd:
.c8db	1e 06 03	asl $0306,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.c8de	3e 07 03	rol $0307,x			rol 	XS2_Mantissa+1,x
.c8e1	3e 08 03	rol $0308,x			rol 	XS2_Mantissa+2,x
.c8e4	3e 09 03	rol $0309,x			rol 	XS2_Mantissa+3,x
.c8e7	5e 0f 03	lsr $030f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.c8ea	7e 0e 03	ror $030e,x			ror 	XS3_Mantissa+2,x
.c8ed	7e 0d 03	ror $030d,x			ror 	XS3_Mantissa+1,x
.c8f0	7e 0c 03	ror $030c,x			ror 	XS3_Mantissa,x
.c8f3	bd 0c 03	lda $030c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.c8f6	1d 0d 03	ora $030d,x			ora 	XS3_Mantissa+1,x
.c8f9	1d 0e 03	ora $030e,x			ora 	XS3_Mantissa+2,x
.c8fc	1d 0f 03	ora $030f,x			ora 	XS3_Mantissa+3,x
.c8ff	d0 d0		bne $c8d1			bne 	_BFMMultiply
.c901	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.c902					DivInteger32:
.c902	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; check for /0
.c905	1d 07 03	ora $0307,x			ora 	XS2_Mantissa+1,x
.c908	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.c90b	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.c90e	d0 02		bne $c912			bne 	_BFDOkay
.c910	80 fe		bra $c910		_error: bra _error
.c912					_BFDOkay:
.c912	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.c914	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.c916	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.c918	85 1c		sta $1c				sta 	zLTemp1+2
.c91a	85 1d		sta $1d				sta 	zLTemp1+3
.c91c	8d 25 04	sta $0425			sta 	SignCount 					; Count of signs.
.c91f	20 80 c9	jsr $c980			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.c922	da		phx				phx
.c923	e8		inx				inx
.c924	e8		inx				inx
.c925	e8		inx				inx
.c926	e8		inx				inx
.c927	e8		inx				inx
.c928	e8		inx				inx
.c929	20 80 c9	jsr $c980			jsr 	CheckIntegerNegate
.c92c	fa		plx				plx
.c92d	5a		phy				phy 								; Y is the counter
.c92e	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.c930					_BFDLoop:
.c930	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.c933	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.c936	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.c939	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.c93c	26 1a		rol $1a				rol 	zLTemp1
.c93e	26 1b		rol $1b				rol 	zLTemp1+1
.c940	26 1c		rol $1c				rol 	zLTemp1+2
.c942	26 1d		rol $1d				rol 	zLTemp1+3
.c944	38		sec				sec
.c945	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.c947	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.c94a	48		pha				pha
.c94b	a5 1b		lda $1b				lda 	zLTemp1+1
.c94d	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.c950	48		pha				pha
.c951	a5 1c		lda $1c				lda 	zLTemp1+2
.c953	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.c956	48		pha				pha
.c957	a5 1d		lda $1d				lda 	zLTemp1+3
.c959	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.c95c	90 15		bcc $c973			bcc 	_BFDNoAdd
.c95e	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.c960	68		pla				pla
.c961	85 1c		sta $1c				sta 	zLTemp1+2
.c963	68		pla				pla
.c964	85 1b		sta $1b				sta 	zLTemp1+1
.c966	68		pla				pla
.c967	85 1a		sta $1a				sta 	zLTemp1+0
.c969	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.c96c	09 01		ora #$01			ora 	#1
.c96e	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c971	80 03		bra $c976			bra 	_BFDNext
.c973					_BFDNoAdd:
.c973	68		pla				pla 								; Throw away the intermediate calculations
.c974	68		pla				pla
.c975	68		pla				pla
.c976					_BFDNext:
.c976	88		dey				dey
.c977	d0 b7		bne $c930			bne 	_BFDLoop
.c979	7a		ply				ply 								; restore Y and exit
.c97a	4e 25 04	lsr $0425			lsr 	SignCount 					; if sign count odd,
.c97d	b0 07		bcs $c986			bcs		IntegerNegateAlways 			; negate the result
.c97f	60		rts				rts
.c980					CheckIntegerNegate:
.c980	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.c983	30 01		bmi $c986			bmi 	IntegerNegateAlways
.c985	60		rts				rts
.c986					IntegerNegateAlways:
.c986	ee 25 04	inc $0425			inc 	SignCount
.c989	38		sec				sec
.c98a	a9 00		lda #$00			lda 	#0
.c98c	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.c98f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.c992	a9 00		lda #$00			lda 	#0
.c994	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.c997	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.c99a	a9 00		lda #$00			lda 	#0
.c99c	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.c99f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.c9a2	a9 00		lda #$00			lda 	#0
.c9a4	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.c9a7	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.c9aa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.c9ab					INTToString:
.c9ab	48		pha				pha
.c9ac	5a		phy				phy
.c9ad	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x 		; check -ve
.c9b0	10 08		bpl $c9ba			bpl 		_ITSNotMinus
.c9b2	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c9b4	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter
.c9b7	20 86 c9	jsr $c986			jsr 		IntegerNegateAlways 	; negate the number.
.c9ba					_ITSNotMinus:
.c9ba	a9 00		lda #$00			lda 		#0 						; X is offset in table.
.c9bc	8d 21 04	sta $0421			sta 		NumSuppress 			; clear the suppression flag.
.c9bf	a0 00		ldy #$00			ldy 		#0 						; Y is index into dword subtraction table.
.c9c1					_ITSNextSubtractor:
.c9c1	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.c9c3	8d 22 04	sta $0422			sta 		NumConvCount
.c9c6					_ITSSubtract:
.c9c6	38		sec				sec
.c9c7	bd 00 03	lda $0300,x			lda 		XS_Mantissa,x 			; subtract number and push on stack
.c9ca	f9 23 ca	sbc $ca23,y			sbc 		_ITSSubtractors+0,y
.c9cd	48		pha				pha
.c9ce	bd 01 03	lda $0301,x			lda 		XS_Mantissa+1,x
.c9d1	f9 24 ca	sbc $ca24,y			sbc 		_ITSSubtractors+1,y
.c9d4	48		pha				pha
.c9d5	bd 02 03	lda $0302,x			lda 		XS_Mantissa+2,x
.c9d8	f9 25 ca	sbc $ca25,y			sbc 		_ITSSubtractors+2,y
.c9db	48		pha				pha
.c9dc	bd 03 03	lda $0303,x			lda 		XS_Mantissa+3,x
.c9df	f9 26 ca	sbc $ca26,y			sbc 		_ITSSubtractors+3,y
.c9e2	90 14		bcc $c9f8			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.c9e4	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x 		; save subtract off stack
.c9e7	68		pla				pla
.c9e8	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.c9eb	68		pla				pla
.c9ec	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.c9ef	68		pla				pla
.c9f0	9d 00 03	sta $0300,x			sta 		XS_Mantissa+0,x
.c9f3	ee 22 04	inc $0422			inc 		NumConvCount 			; bump count.
.c9f6	80 ce		bra $c9c6			bra 		_ITSSubtract 			; go round again.
.c9f8					_ITSCantSubtract:
.c9f8	68		pla				pla 								; throw away interim answers
.c9f9	68		pla				pla
.c9fa	68		pla				pla
.c9fb	ad 22 04	lda $0422			lda 		NumConvCount 			; if not zero then no suppression check
.c9fe	c9 30		cmp #$30			cmp 		#"0"
.ca00	d0 05		bne $ca07			bne 		_ITSOutputDigit
.ca02	ad 21 04	lda $0421			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.ca05	10 09		bpl $ca10			bpl 		_ITSGoNextSubtractor
.ca07					_ITSOutputDigit:
.ca07	ce 21 04	dec $0421			dec 		NumSuppress 			; suppression check will be non-zero.
.ca0a	ad 22 04	lda $0422			lda 		NumConvCount 			; count of subtractions
.ca0d	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter 		; output it.
.ca10					_ITSGoNextSubtractor:
.ca10	c8		iny				iny 								; next dword
.ca11	c8		iny				iny
.ca12	c8		iny				iny
.ca13	c8		iny				iny
.ca14	c0 24		cpy #$24			cpy 		#_ITSSubtractorsEnd-_ITSSubtractors
.ca16	d0 a9		bne $c9c1			bne 		_ITSNextSubtractor 		; do all the subtractors.
.ca18	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.ca1b	09 30		ora #$30			ora 		#"0"
.ca1d	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter
.ca20	7a		ply				ply 								; and exit
.ca21	68		pla				pla
.ca22	60		rts				rts
.ca23					_ITSSubtractors:
>ca23	00 ca 9a 3b					.dword 		1000000000
>ca27	00 e1 f5 05					.dword 		100000000
>ca2b	80 96 98 00					.dword 		10000000
>ca2f	40 42 0f 00					.dword 		1000000
>ca33	a0 86 01 00					.dword 		100000
>ca37	10 27 00 00					.dword 		10000
>ca3b	e8 03 00 00					.dword 		1000
>ca3f	64 00 00 00					.dword 		100
>ca43	0a 00 00 00					.dword 		10
.ca47					_ITSSubtractorsEnd:
.ca47					ITSOutputCharacter:
.ca47	48		pha				pha
.ca48	da		phx				phx
.ca49	ae 20 04	ldx $0420			ldx 	NumBufX 					; save digit
.ca4c	9d 00 04	sta $0400,x			sta 	Num_Buffer,x
.ca4f	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.ca51	9d 01 04	sta $0401,x			sta 	Num_Buffer+1,x
.ca54	ee 20 04	inc $0420			inc 	NumBufX						; bump pointer.
.ca57	fa		plx				plx
.ca58	68		pla				pla
.ca59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.ca5a					IntFromString:
.ca5a	a0 00		ldy #$00			ldy 	#0
.ca5c	8c 23 04	sty $0423			sty 	ExpTemp 					; this is the converted digit count.
.ca5f					IntFromStringY:
.ca5f	48		pha				pha
.ca60	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.ca62	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.ca65	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ca68	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ca6b	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ca6e	a9 01		lda #$01			lda 	#1
.ca70	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ca73					_IFSLoop:
.ca73	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.ca75	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.ca77	90 60		bcc $cad9			bcc 	_IFSExit
.ca79	c9 3a		cmp #$3a			cmp 	#"9"+1
.ca7b	b0 5c		bcs $cad9			bcs 	_IFSExit
.ca7d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.ca80	c9 0c		cmp #$0c			cmp 	#12
.ca82	b0 5f		bcs $cae3			bcs 	_IFSOverflow
.ca84	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.ca87	48		pha				pha
.ca88	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ca8b	48		pha				pha
.ca8c	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ca8f	48		pha				pha
.ca90	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.ca93	48		pha				pha
.ca94	20 f8 ca	jsr $caf8			jsr 	IFSX1ShiftLeft 				; double
.ca97	20 f8 ca	jsr $caf8			jsr 	IFSX1ShiftLeft 				; x 4
.ca9a	18		clc				clc 								; add saved value x 5
.ca9b	68		pla				pla
.ca9c	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.ca9f	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.caa2	68		pla				pla
.caa3	7d 01 03	adc $0301,x			adc 	XS_Mantissa+1,x
.caa6	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.caa9	68		pla				pla
.caaa	7d 02 03	adc $0302,x			adc 	XS_Mantissa+2,x
.caad	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cab0	68		pla				pla
.cab1	7d 03 03	adc $0303,x			adc 	XS_Mantissa+3,x
.cab4	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cab7	20 f8 ca	jsr $caf8			jsr 	IFSX1ShiftLeft 				; x 10
.caba	ee 23 04	inc $0423			inc 	ExpTemp 					; bump count of digits processed.
.cabd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.cabf	29 0f		and #$0f			and 	#15
.cac1	c8		iny				iny
.cac2	7d 00 03	adc $0300,x			adc 	XS_Mantissa+0,x
.cac5	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cac8	90 a9		bcc $ca73			bcc 	_IFSLoop
.caca	fe 01 03	inc $0301,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.cacd	d0 a4		bne $ca73			bne 	_IFSLoop
.cacf	fe 02 03	inc $0302,x			inc 	XS_Mantissa+2,x
.cad2	d0 9f		bne $ca73			bne 	_IFSLoop
.cad4	fe 03 03	inc $0303,x			inc 	XS_Mantissa+3,x
.cad7	80 9a		bra $ca73			bra 	_IFSLoop
.cad9					_IFSExit:
.cad9	98		tya				tya 								; get offset
.cada					_IFSOkay:
.cada	38		sec				sec
.cadb	ad 23 04	lda $0423			lda 	ExpTemp
.cade	f0 01		beq $cae1			beq 	_IFSSkipFail
.cae0	18		clc				clc
.cae1					_IFSSkipFail:
.cae1	68		pla				pla 								; and exit.
.cae2	60		rts				rts
.cae3					_IFSOverflow:
.cae3	20 09 c4	jsr $c409			jsr 	ERR_Handler
>cae6	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>caee	20 6f 76 65 72 66 6c 6f 77 00
.caf8					IFSX1ShiftLeft:
.caf8	1e 00 03	asl $0300,x			asl 	XS_Mantissa+0,x
.cafb	3e 01 03	rol $0301,x			rol 	XS_Mantissa+1,x
.cafe	3e 02 03	rol $0302,x			rol 	XS_Mantissa+2,x
.cb01	3e 03 03	rol $0303,x			rol 	XS_Mantissa+3,x
.cb04	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.cb05					FPSubtract:
.cb05	48		pha				pha
.cb06	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.cb09	49 80		eor #$80			eor 	#$80
.cb0b	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.cb0e	68		pla				pla 								; --- and fall through ---
.cb0f					FPAdd:
.cb0f	48		pha				pha
.cb10	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.cb13	d0 05		bne $cb1a			bne 	_FPA_NegativeLHS
.cb15	20 37 cb	jsr $cb37			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.cb18	68		pla				pla
.cb19	60		rts				rts
.cb1a					_FPA_NegativeLHS:
.cb1a	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.cb1d	49 80		eor #$80			eor 	#$80
.cb1f	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb22	bd 0b 03	lda $030b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.cb25	49 80		eor #$80			eor 	#$80
.cb27	9d 0b 03	sta $030b,x			sta 	XS2_Type,x
.cb2a	20 37 cb	jsr $cb37			jsr 	FPAdd_Worker 				; do the add calculation.
.cb2d	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip sign of X1 back
.cb30	49 80		eor #$80			eor 	#$80
.cb32	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cb35	68		pla				pla
.cb36	60		rts				rts
.cb37					FPAdd_Worker:
.cb37	3c 0b 03	bit $030b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.cb3a	70 08		bvs $cb44			bvs 	_FPAWExit 					; no change.
.cb3c	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.cb3f	50 07		bvc $cb48			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.cb41	20 ca cd	jsr $cdca			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.cb44					_FPAWExit:
.cb44	20 52 ce	jsr $ce52			jsr 	FPUNormalise 				; normalise the result.
.cb47	60		rts				rts
.cb48					_FPAWMakeSame:
.cb48	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.cb4b	38		sec				sec
.cb4c	fd 0a 03	sbc $030a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.cb4f	f0 1b		beq $cb6c			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.cb51	da		phx				phx 								; save X
.cb52	90 06		bcc $cb5a			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.cb54	e8		inx				inx
.cb55	e8		inx				inx
.cb56	e8		inx				inx
.cb57	e8		inx				inx
.cb58	e8		inx				inx
.cb59	e8		inx				inx
.cb5a					_FPAWShiftA:
.cb5a	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cb5d	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.cb60	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cb63	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cb66	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cb69	fa		plx				plx 								; restore original X
.cb6a	80 dc		bra $cb48			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.cb6c					_FPAW_DoArithmetic:
.cb6c	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.cb6f	30 39		bmi $cbaa			bmi 	_FPAW_BNegative
.cb71	18		clc				clc
.cb72	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cb75	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cb78	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cb7b	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cb7e	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cb81	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cb84	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cb87	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.cb8a	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cb8d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cb90	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.cb93	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cb96	90 ac		bcc $cb44			bcc 	_FPAWExit 					; no carry.
.cb98	fe 04 03	inc $0304,x			inc 	XS_Exponent,x 				; so shift exponent up.
.cb9b	38		sec				sec
.cb9c	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cb9f	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cba2	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cba5	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cba8	80 9a		bra $cb44			bra 	_FPAWExit
.cbaa					_FPAW_BNegative:
.cbaa	38		sec				sec
.cbab	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x
.cbae	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa+0,x
.cbb1	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cbb4	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cbb7	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cbba	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cbbd	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cbc0	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cbc3	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cbc6	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cbc9	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cbcc	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cbcf	b0 0b		bcs $cbdc			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.cbd1	20 f7 cd	jsr $cdf7			jsr 	FPUNegateInteger			; negate the mantissa
.cbd4	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; flip result sign
.cbd7	49 80		eor #$80			eor 	#$80
.cbd9	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cbdc					_FPAWGoExit:
.cbdc	4c 44 cb	jmp $cb44			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.cbdf					FPD_IsDivZero:
.cbdf	80 fe		bra $cbdf		_error: bra _error
.cbe1					FPDivide:
.cbe1	48		pha				pha
.cbe2	5a		phy				phy
.cbe3	3c 0b 03	bit $030b,x			bit 	XS2_Type,x 					; check if division by zero
.cbe6	70 f7		bvs $cbdf			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.cbe8	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.cbeb	f0 03		beq $cbf0			beq 	_FPDCalculateExp
.cbed					_FPD_Exit:
.cbed	7a		ply				ply
.cbee	68		pla				pla
.cbef	60		rts				rts
.cbf0					_FPDCalculateExp:
.cbf0	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.cbf3	49 ff		eor #$ff			eor 	#$FF
.cbf5	1a		inc a				inc 	a
.cbf6	9d 0a 03	sta $030a,x			sta 	XS2_Exponent,x
.cbf9	20 ed cc	jsr $cced			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.cbfc	18		clc				clc 	 							; add 1 to the resulting exponent
.cbfd	69 01		adc #$01			adc 	#1
.cbff	b0 65		bcs $cc66			bcs 	_FPD_Overflow 				; which can overflow.
.cc01	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cc04	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.cc06	85 1a		sta $1a				sta 	zLTemp1+0
.cc08	85 1b		sta $1b				sta 	zLTemp1+1
.cc0a	85 1c		sta $1c				sta 	zLTemp1+2
.cc0c	85 1d		sta $1d				sta 	zLTemp1+3
.cc0e	a0 20		ldy #$20			ldy 	#32 						; times round.
.cc10					_FPD_Loop:
.cc10	38		sec				sec 								; calculate X1-X2 stacking result because we might
.cc11	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; not save it.
.cc14	fd 06 03	sbc $0306,x			sbc 	XS2_Mantissa,x
.cc17	48		pha				pha
.cc18	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.cc1b	fd 07 03	sbc $0307,x			sbc 	XS2_Mantissa+1,x
.cc1e	48		pha				pha
.cc1f	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cc22	fd 08 03	sbc $0308,x			sbc 	XS2_Mantissa+2,x
.cc25	48		pha				pha
.cc26	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cc29	fd 09 03	sbc $0309,x			sbc 	XS2_Mantissa+3,x
.cc2c	90 17		bcc $cc45			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.cc2e	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x 			; save results out to A
.cc31	68		pla				pla
.cc32	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cc35	68		pla				pla
.cc36	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cc39	68		pla				pla
.cc3a	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.cc3d	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.cc3f	09 80		ora #$80			ora 	#$80
.cc41	85 1d		sta $1d				sta 	zLTemp1+3
.cc43	80 03		bra $cc48			bra 	_FPD_Rotates
.cc45					_FPD_NoSubtract:
.cc45	68		pla				pla 								; throw away unwanted results
.cc46	68		pla				pla
.cc47	68		pla				pla
.cc48					_FPD_Rotates:
.cc48	5e 09 03	lsr $0309,x			lsr 	3+XS2_Mantissa,x
.cc4b	7e 08 03	ror $0308,x			ror 	2+XS2_Mantissa,x
.cc4e	7e 07 03	ror $0307,x			ror 	1+XS2_Mantissa,x
.cc51	7e 06 03	ror $0306,x			ror 	0+XS2_Mantissa,x
.cc54	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.cc56	26 1b		rol $1b				rol 	zLTemp1+1
.cc58	26 1c		rol $1c				rol 	zLTemp1+2
.cc5a	26 1d		rol $1d				rol 	zLTemp1+3
.cc5c	90 02		bcc $cc60			bcc 	_FPD_NoCarry
.cc5e	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.cc60					_FPD_NoCarry:
.cc60	88		dey				dey 								; do 32 times
.cc61	d0 ad		bne $cc10			bne 	_FPD_Loop
.cc63	4c ca cc	jmp $ccca			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.cc66					_FPD_Overflow:
.cc66	4c c7 ce	jmp $cec7			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.cc69					FPMultiply:
.cc69	48		pha				pha
.cc6a	5a		phy				phy
.cc6b	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.cc6e	70 08		bvs $cc78			bvs 	_FPM_Exit
.cc70	3c 0b 03	bit $030b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.cc73	50 06		bvc $cc7b			bvc 	_FPM_CalcExponent
.cc75	20 ca cd	jsr $cdca			jsr 	FPUCopyX2ToX1
.cc78					_FPM_Exit:
.cc78	7a		ply				ply
.cc79	68		pla				pla
.cc7a	60		rts				rts
.cc7b					_FPM_CalcExponent:
.cc7b	18		clc				clc
.cc7c	20 ed cc	jsr $cced			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.cc7f	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; save the result.
.cc82	a9 00		lda #$00			lda 	#0
.cc84	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.cc86	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.cc88	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.cc8a	85 1d		sta $1d				sta 	zLTemp1+3
.cc8c	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.cc8e					_FPM_Loop:
.cc8e	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x				; check LSB of long product
.cc91	29 01		and #$01			and 	#1
.cc93	18		clc				clc 								; clear carry for the long rotate.
.cc94	f0 1d		beq $ccb3			beq 	_FPM_NoAddition
.cc96	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.cc97	a5 1a		lda $1a				lda 	zLTemp1+0
.cc99	7d 06 03	adc $0306,x			adc 	XS2_Mantissa+0,x
.cc9c	85 1a		sta $1a				sta 	zLTemp1+0
.cc9e	a5 1b		lda $1b				lda 	zLTemp1+1
.cca0	7d 07 03	adc $0307,x			adc 	XS2_Mantissa+1,x
.cca3	85 1b		sta $1b				sta 	zLTemp1+1
.cca5	a5 1c		lda $1c				lda 	zLTemp1+2
.cca7	7d 08 03	adc $0308,x			adc 	XS2_Mantissa+2,x
.ccaa	85 1c		sta $1c				sta 	zLTemp1+2
.ccac	a5 1d		lda $1d				lda 	zLTemp1+3
.ccae	7d 09 03	adc $0309,x			adc 	XS2_Mantissa+3,x
.ccb1	85 1d		sta $1d				sta 	zLTemp1+3
.ccb3					_FPM_NoAddition:
.ccb3	66 1d		ror $1d				ror 	3+zLTemp1
.ccb5	66 1c		ror $1c				ror 	2+zLTemp1
.ccb7	66 1b		ror $1b				ror 	1+zLTemp1
.ccb9	66 1a		ror $1a				ror 	0+zLTemp1
.ccbb	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.ccbe	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.ccc1	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.ccc4	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.ccc7	88		dey				dey
.ccc8	d0 c4		bne $cc8e			bne 	_FPM_Loop 					; do this 32 times.
.ccca					FPM_CopySignNormalize:
.ccca	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.cccc	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.cccf	a5 1b		lda $1b				lda 	zLTemp1+1
.ccd1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ccd4	a5 1c		lda $1c				lda 	zLTemp1+2
.ccd6	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ccd9	a5 1d		lda $1d				lda 	zLTemp1+3
.ccdb	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ccde	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; sign is xor of signs
.cce1	5d 0b 03	eor $030b,x			eor 	XS2_Type,x
.cce4	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cce7	20 52 ce	jsr $ce52			jsr 	FPUNormalise 				; normalise and exit.
.ccea	7a		ply				ply
.cceb	68		pla				pla
.ccec	60		rts				rts
.cced					FPCalculateExponent:
.cced	18		clc				clc
.ccee	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.ccf1	7d 0a 03	adc $030a,x			adc 	XS2_Exponent,x
.ccf4	b0 08		bcs $ccfe			bcs 	_FPCECarry 					; carry out ?
.ccf6	10 03		bpl $ccfb			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.ccf8	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.ccfa	60		rts				rts
.ccfb					_FPCEExpZero:
.ccfb	a9 00		lda #$00			lda 	#0
.ccfd	60		rts				rts
.ccfe					_FPCECarry:
.ccfe	30 03		bmi $cd03			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.cd00	09 80		ora #$80			ora 	#$80 						; put in right range
.cd02	60		rts				rts
.cd03					_FPCEOverflow:
.cd03	4c c7 ce	jmp $cec7			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.cd06					FPFractionalPart:
.cd06	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.cd09	38		sec				sec 								; this flag tells us to keep the fractional part
.cd0a	30 0f		bmi $cd1b			bmi 	FPGetPart
.cd0c	60		rts				rts
.cd0d					FPIntegerPart:
.cd0d	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.cd10	18		clc				clc 								; this flag says keep the integer part.
.cd11	30 08		bmi $cd1b			bmi 	FPGetPart 					; -ve exponents are 0..127
.cd13	48		pha				pha
.cd14	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.cd16	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd19	68		pla				pla
.cd1a	60		rts				rts
.cd1b					FPGetPart:
.cd1b	48		pha				pha
.cd1c	5a		phy				phy 								; save Y
.cd1d	08		php				php 								; save action
.cd1e	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.cd21	70 62		bvs $cd85			bvs 	_FPGP_Exit 					; then do nothing.
.cd23	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.cd25	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.cd27	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.cd29	85 1c		sta $1c				sta 	zLTemp1+2
.cd2b	85 1d		sta $1d				sta 	zLTemp1+3
.cd2d	bd 04 03	lda $0304,x			lda 	XS_Exponent,x				; the number of shifts.
.cd30	38		sec				sec
.cd31	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.cd33	f0 12		beq $cd47			beq 	_FPGP_NoShift 				; ... if any
.cd35	c9 20		cmp #$20			cmp 	#32
.cd37	90 02		bcc $cd3b			bcc 	_FPGP_NotMax
.cd39	a9 20		lda #$20			lda 	#32 						; max of 32.
.cd3b					_FPGP_NotMax:
.cd3b	a8		tay				tay 								; Y is the mask shift count.
.cd3c					_FPGP_ShiftMask:
.cd3c	46 1d		lsr $1d				lsr 	3+zLTemp1
.cd3e	66 1c		ror $1c				ror 	2+zLTemp1
.cd40	66 1b		ror $1b				ror 	1+zLTemp1
.cd42	66 1a		ror $1a				ror 	0+zLTemp1
.cd44	88		dey				dey
.cd45	d0 f5		bne $cd3c			bne 	_FPGP_ShiftMask
.cd47					_FPGP_NoShift:
.cd47	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.cd49	8e 23 04	stx $0423			stx 	ExpTemp						; save X
.cd4c					_FPGP_MaskLoop:
.cd4c	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.cd4f	28		plp				plp 								; if CC we keep the top part, so we
.cd50	08		php				php		 							; flip the mask.
.cd51	b0 02		bcs $cd55			bcs		_FPGP_NoFlip
.cd53	49 ff		eor #$ff			eor 	#$FF
.cd55					_FPGP_NoFlip:
.cd55	3d 00 03	and $0300,x			and 	XS_Mantissa,x 				; and into the mantissa.
.cd58	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cd5b	e8		inx				inx
.cd5c	c8		iny				iny
.cd5d	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.cd5f	d0 eb		bne $cd4c			bne 	_FPGP_MaskLoop
.cd61	ae 23 04	ldx $0423			ldx 	ExpTemp						; restore X
.cd64	28		plp				plp
.cd65	08		php				php 								; get action flag on the stack
.cd66	90 05		bcc $cd6d			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.cd68	a9 00		lda #$00			lda 	#0
.cd6a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd6d					_FPGP_NotFractional:
.cd6d	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 						; check if \1 zero
.cd70	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.cd73	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.cd76	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.cd79	f0 05		beq $cd80			beq 	_FPGP_Zero 					; if zero, return zero
.cd7b	20 52 ce	jsr $ce52			jsr 	FPUNormalise
.cd7e	80 05		bra $cd85			bra 	_FPGP_Exit 					; and exit
.cd80					_FPGP_Zero:
.cd80	a9 40		lda #$40			lda 	#$40 						; set zero flag
.cd82	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cd85					_FPGP_Exit:
.cd85	68		pla				pla 								; throw saved action flag.
.cd86	7a		ply				ply
.cd87	68		pla				pla
.cd88	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.cd89					FPCompare:
.cd89	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.cd8c	48		pha				pha
.cd8d	bd 0a 03	lda $030a,x			lda 	XS2_Exponent,x
.cd90	48		pha				pha
.cd91	20 05 cb	jsr $cb05			jsr 	FPSubtract 					; calculate X1-X2
.cd94	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.cd97	70 2c		bvs $cdc5			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.cd99	68		pla				pla
.cd9a	8d 23 04	sta $0423			sta 	ExpTemp						; save first exponent in temporary reg.
.cd9d	68		pla				pla
.cd9e	38		sec				sec
.cd9f	ed 23 04	sbc $0423			sbc 	ExpTemp 					; calculate AX-BX
.cda2	70 15		bvs $cdb9			bvs 	_FPCNotEqual				; overflow, can't be equal.
.cda4	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.cda5	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.cda7	b0 10		bcs $cdb9			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.cda9	38		sec				sec
.cdaa	ad 23 04	lda $0423			lda 	ExpTemp 					; get one of the exponents back.
.cdad	e9 18		sbc #$18			sbc 	#24 						; allow for 2^24 error, relatively.
.cdaf	b0 02		bcs $cdb3			bcs 	_FPCNotRange 				; keep in range.
.cdb1	a9 01		lda #$01			lda 	#1
.cdb3					_FPCNotRange:
.cdb3	38		sec				sec
.cdb4	fd 04 03	sbc $0304,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.cdb7	b0 0e		bcs $cdc7			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.cdb9					_FPCNotEqual:
.cdb9	bd 05 03	lda $0305,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.cdbc	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.cdbe	f0 02		beq $cdc2			beq 	_FPCNE2
.cdc0	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.cdc2	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.cdc3	80 04		bra $cdc9			bra 	_FPCExit
.cdc5					_FPCPullZero:
.cdc5	68		pla				pla 								; throw saved exponents
.cdc6	68		pla				pla
.cdc7					_FPCZero:
.cdc7	a9 00		lda #$00			lda 	#0 							; and return zero
.cdc9					_FPCExit:
.cdc9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.cdca					FPUCopyX2ToX1:
.cdca	48		pha				pha
.cdcb	da		phx				phx
.cdcc	5a		phy				phy
.cdcd	a0 08		ldy #$08			ldy 	#8
.cdcf	bd 06 03	lda $0306,x	_FPUC21:lda 	XS2_Mantissa,x
.cdd2	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cdd5	e8		inx				inx
.cdd6	88		dey				dey
.cdd7	10 f6		bpl $cdcf			bpl 	_FPUC21
.cdd9	7a		ply				ply
.cdda	fa		plx				plx
.cddb	68		pla				pla
.cddc	60		rts				rts
.cddd					FPUSetInteger:
.cddd	48		pha				pha
.cdde	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.cde1	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.cde3	10 02		bpl $cde7			bpl 	_FPUSIExtend
.cde5	a9 ff		lda #$ff			lda 	#$FF
.cde7					_FPUSIExtend:
.cde7	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.cdea	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cded	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cdf0	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.cdf2	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cdf5	68		pla				pla
.cdf6	60		rts				rts
.cdf7					FPUNegateInteger:
.cdf7	48		pha				pha
.cdf8	38		sec				sec
.cdf9	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.cdfb	fd 00 03	sbc $0300,x			sbc 	XS_Mantissa+0,x
.cdfe	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ce01	a9 00		lda #$00			lda 	#0
.ce03	fd 01 03	sbc $0301,x			sbc 	XS_Mantissa+1,x
.ce06	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ce09	a9 00		lda #$00			lda 	#0
.ce0b	fd 02 03	sbc $0302,x			sbc 	XS_Mantissa+2,x
.ce0e	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.ce11	a9 00		lda #$00			lda 	#0
.ce13	fd 03 03	sbc $0303,x			sbc 	XS_Mantissa+3,x
.ce16	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.ce19	68		pla				pla
.ce1a	60		rts				rts
.ce1b					FPUToFloat:
.ce1b	48		pha				pha
.ce1c	bd 05 03	lda $0305,x			lda 	XS_Type,x					; exit if already float.
.ce1f	29 0f		and #$0f			and 	#$0F
.ce21	f0 2d		beq $ce50			beq 	_FPUFExit
.ce23	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.ce25	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce28	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.ce2a	9d 04 03	sta $0304,x			sta 	XS_Exponent,x 				; x mantissa.
.ce2d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.ce30	10 08		bpl $ce3a			bpl		_FPUFPositive
.ce32	20 f7 cd	jsr $cdf7			jsr 	FPUNegateInteger 			; negate the mantissa
.ce35	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.ce37	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce3a					_FPUFPositive:
.ce3a	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.ce3d	1d 01 03	ora $0301,x			ora 	XS_Mantissa+1,x
.ce40	1d 02 03	ora $0302,x			ora 	XS_Mantissa+2,x
.ce43	1d 03 03	ora $0303,x			ora 	XS_Mantissa+3,x
.ce46	d0 05		bne $ce4d			bne 	_FPUFNonZero
.ce48	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.ce4a	9d 05 03	sta $0305,x			sta 	XS_Type,x
.ce4d					_FPUFNonZero:
.ce4d	20 52 ce	jsr $ce52			jsr 	FPUNormalise 				; normalise the floating point.
.ce50					_FPUFExit:
.ce50	68		pla				pla
.ce51	60		rts				rts
.ce52					FPUNormalise:
.ce52	48		pha				pha
.ce53	3c 05 03	bit $0305,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.ce56	70 20		bvs $ce78			bvs 	_FPUNExit
.ce58	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.ce5b	f0 16		beq $ce73			beq 	_FPUNSetZero
.ce5d					_FPUNLoop:
.ce5d	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.ce60	30 16		bmi $ce78			bmi 	_FPUNExit 					; if so, we are normalised.
.ce62	1e 00 03	asl $0300,x			asl 	0+XS_Mantissa+0,x
.ce65	3e 01 03	rol $0301,x			rol 	1+XS_Mantissa+0,x
.ce68	3e 02 03	rol $0302,x			rol 	2+XS_Mantissa+0,x
.ce6b	3e 03 03	rol $0303,x			rol 	3+XS_Mantissa+0,x
.ce6e	de 04 03	dec $0304,x			dec 	XS_Exponent,x 				; decrement exponent
.ce71	d0 ea		bne $ce5d			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.ce73					_FPUNSetZero:
.ce73	a9 40		lda #$40			lda 	#$40
.ce75	9d 05 03	sta $0305,x			sta 	XS_Type,x 					; the result is now zero.
.ce78					_FPUNExit:
.ce78	68		pla				pla
.ce79	60		rts				rts
.ce7a					FPUToInteger:
.ce7a	48		pha				pha
.ce7b	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; if already integer, exit
.ce7e	29 01		and #$01			and 	#1
.ce80	d0 3e		bne $cec0			bne 	_FPUTOI_Exit
.ce82	3c 05 03	bit $0305,x			bit 	XS_Type,x					; if zero, return zero.
.ce85	70 2b		bvs $ceb2			bvs 	_FPUTOI_Zero
.ce87	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.ce8a	10 26		bpl $ceb2			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.ce8c	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.ce8e	b0 37		bcs $cec7			bcs 	FP_Overflow
.ce90					_FPUToIToInteger:
.ce90	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.ce93	c9 a0		cmp #$a0			cmp 	#128+32
.ce95	f0 11		beq $cea8			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.ce97	fe 04 03	inc $0304,x			inc 	XS_Exponent,X 				; increment Exponent
.ce9a	5e 03 03	lsr $0303,x			lsr 	3+XS_Mantissa,x
.ce9d	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cea0	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cea3	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cea6	80 e8		bra $ce90			bra 	_FPUToIToInteger 			; keep going.
.cea8					_FPUToICheckSign:
.cea8	bd 05 03	lda $0305,x			lda 	XS_Type,x 					; check sign
.ceab	10 13		bpl $cec0			bpl 	_FPUToI_Exit 				; exit if unsigned.
.cead	20 f7 cd	jsr $cdf7			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.ceb0	80 0e		bra $cec0			bra 	_FPUTOI_Exit
.ceb2					_FPUTOI_Zero:
.ceb2	a9 00		lda #$00			lda 	#0 							; return zero integer.
.ceb4	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ceb7	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.ceba	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cebd	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cec0					_FPUToI_Exit:
.cec0	a9 01		lda #$01			lda 	#1 							; set type to integer
.cec2	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cec5	68		pla				pla
.cec6	60		rts				rts
.cec7					FP_Overflow:
.cec7	80 fe		bra $cec7		_error: bra _error
.cec9					FPUTimes10:
.cec9	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.cecc	85 1a		sta $1a				sta 	ZLTemp1+0
.cece	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ced1	85 1b		sta $1b				sta 	ZLTemp1+1
.ced3	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.ced6	85 1c		sta $1c				sta 	ZLTemp1+2
.ced8	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.cedb	85 1d		sta $1d				sta 	ZLTemp1+3
.cedd	20 21 cf	jsr $cf21			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.cee0	20 21 cf	jsr $cf21			jsr 	_FPUT_LSR_ZLTemp1
.cee3	18		clc				clc
.cee4	bd 00 03	lda $0300,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.cee7	65 1a		adc $1a				adc 	ZLTemp1+0
.cee9	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x
.ceec	bd 01 03	lda $0301,x			lda 	XS_Mantissa+1,x
.ceef	65 1b		adc $1b				adc 	ZLTemp1+1
.cef1	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cef4	bd 02 03	lda $0302,x			lda 	XS_Mantissa+2,x
.cef7	65 1c		adc $1c				adc 	ZLTemp1+2
.cef9	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cefc	bd 03 03	lda $0303,x			lda 	XS_Mantissa+3,x
.ceff	65 1d		adc $1d				adc 	ZLTemp1+3
.cf01	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cf04	90 0f		bcc $cf15			bcc 	_FPUTimes10
.cf06	7e 03 03	ror $0303,x			ror 	3+XS_Mantissa,x
.cf09	7e 02 03	ror $0302,x			ror 	2+XS_Mantissa,x
.cf0c	7e 01 03	ror $0301,x			ror 	1+XS_Mantissa,x
.cf0f	7e 00 03	ror $0300,x			ror 	0+XS_Mantissa,x
.cf12	fe 04 03	inc $0304,x			inc 	XS_Exponent,x				; fix exponent
.cf15					_FPUTimes10:
.cf15	bd 04 03	lda $0304,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.cf18	18		clc				clc
.cf19	69 03		adc #$03			adc 	#3
.cf1b	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cf1e	b0 a7		bcs $cec7			bcs 	FP_Overflow 				; error
.cf20	60		rts				rts
.cf21					_FPUT_LSR_ZLTemp1:
.cf21	46 1d		lsr $1d				lsr 	ZLTemp1+3
.cf23	66 1c		ror $1c				ror 	ZLTemp1+2
.cf25	66 1b		ror $1b				ror 	ZLTemp1+1
.cf27	66 1a		ror $1a				ror 	ZLTemp1+0
.cf29	60		rts				rts
.cf2a					FPUScale10A:
.cf2a	5a		phy				phy
.cf2b	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.cf2d	f0 3d		beq $cf6c			beq 	_FPUScaleExit
.cf2f	da		phx				phx 								; save X
.cf30	e8		inx				inx
.cf31	e8		inx				inx
.cf32	e8		inx				inx
.cf33	e8		inx				inx
.cf34	e8		inx				inx
.cf35	e8		inx				inx
.cf36	a8		tay				tay 								; save power scalar in Y.
.cf37	a9 00		lda #$00			lda 	#0
.cf39	9d 00 03	sta $0300,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.cf3c	9d 01 03	sta $0301,x			sta 	XS_Mantissa+1,x
.cf3f	9d 02 03	sta $0302,x			sta 	XS_Mantissa+2,x
.cf42	9d 05 03	sta $0305,x			sta 	XS_Type,x
.cf45	a9 80		lda #$80			lda 	#$80
.cf47	9d 03 03	sta $0303,x			sta 	XS_Mantissa+3,x
.cf4a	a9 81		lda #$81			lda 	#$81
.cf4c	9d 04 03	sta $0304,x			sta 	XS_Exponent,x
.cf4f	5a		phy				phy 								; save 10^n on stack.
.cf50	c0 00		cpy #$00			cpy 	#0
.cf52	10 05		bpl $cf59			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.cf54	98		tya				tya
.cf55	49 ff		eor #$ff			eor 	#$FF
.cf57	1a		inc a				inc 	a
.cf58	a8		tay				tay
.cf59					_FPUSAbs:
.cf59	20 c9 ce	jsr $cec9			jsr 	FPUTimes10
.cf5c	88		dey				dey
.cf5d	d0 fa		bne $cf59			bne 	_FPUSAbs 					; tos is now 10^|AC|
.cf5f	68		pla				pla 								; restore count in A
.cf60	fa		plx				plx 								; restore X pointing to number to scale.
.cf61	0a		asl a				asl 	a
.cf62	b0 05		bcs $cf69			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.cf64	20 69 cc	jsr $cc69			jsr 	FPMultiply 					; if clear multiply.
.cf67	80 03		bra $cf6c			bra		_FPUScaleExit
.cf69					_FPUSDivide:
.cf69	20 e1 cb	jsr $cbe1			jsr 	FPDivide
.cf6c					_FPUScaleExit:
.cf6c	7a		ply				ply
.cf6d	60		rts				rts
.cf6e					FPUCopyToNext:
.cf6e	a0 06		ldy #$06			ldy 		#6
.cf70	da		phx				phx
.cf71					_FPUCopy1:
.cf71	bd 00 03	lda $0300,x			lda 	XS_Mantissa,x
.cf74	9d 06 03	sta $0306,x			sta 	XS2_Mantissa,x
.cf77	e8		inx				inx
.cf78	88		dey				dey
.cf79	d0 f6		bne $cf71			bne 	_FPUCopy1
.cf7b	fa		plx				plx
.cf7c	60		rts				rts
.cf7d					FPUCopyFromNext:
.cf7d	a0 06		ldy #$06			ldy 		#6
.cf7f	da		phx				phx
.cf80					_FPUCopy1:
.cf80	bd 06 03	lda $0306,x			lda 	XS2_Mantissa,x
.cf83	9d 00 03	sta $0300,x			sta 	XS_Mantissa,x
.cf86	e8		inx				inx
.cf87	88		dey				dey
.cf88	d0 f6		bne $cf80			bne 	_FPUCopy1
.cf8a	fa		plx				plx
.cf8b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.cf8c					FPToString:
.cf8c	48		pha				pha
.cf8d	5a		phy				phy
.cf8e	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; check zero flag
.cf91	50 0a		bvc $cf9d			bvc 		_FPTSIsFloat 			; if zero,
.cf93					_FPTSZero:
.cf93	a9 30		lda #$30			lda 		#"0"
.cf95	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter
.cf98					_FPTSExit:
.cf98	7a		ply				ply
.cf99	68		pla				pla
.cf9a	60		rts				rts
.cf9b	80 fb		bra $cf98			bra 		_FPTSExit
.cf9d					_FPTSIsFloat:
.cf9d	bd 05 03	lda $0305,x			lda 		XS_Type,x 				; is it signed ?
.cfa0	10 0a		bpl $cfac			bpl 		_FPTSNotSigned
.cfa2	a9 00		lda #$00			lda 		#0 						; clear sign flag
.cfa4	9d 05 03	sta $0305,x			sta 		XS_Type,x
.cfa7	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.cfa9	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter
.cfac					_FPTSNotSigned:
.cfac	bd 04 03	lda $0304,x			lda 		XS_Exponent,x
.cfaf	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.cfb1	b0 09		bcs $cfbc			bcs 		_FPTSExponent
.cfb3	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.cfb5	90 05		bcc $cfbc			bcc 		_FPTSExponent 			;
.cfb7					_FPTSStandard:
.cfb7	20 00 d0	jsr $d000			jsr 		FPTOutputBody 			; output the body.
.cfba	80 dc		bra $cf98			bra 		_FPTSExit
.cfbc					_FPTSExponent:
.cfbc	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.cfbe	8d 24 04	sta $0424			sta 		ExpCount
.cfc1					_FPTSExponentLoop:
.cfc1	bd 04 03	lda $0304,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.cfc4	10 0e		bpl $cfd4			bpl 		_FPTSTimes
.cfc6	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.cfc8	90 14		bcc $cfde			bcc 		_FPTSScaledToExp
.cfca	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.cfcc	20 2a cf	jsr $cf2a			jsr 		FPUScale10A
.cfcf	ee 24 04	inc $0424			inc 		ExpCount
.cfd2	80 ed		bra $cfc1			bra 		_FPTSExponentLoop
.cfd4					_FPTSTimes:
.cfd4	a9 01		lda #$01			lda 		#1
.cfd6	20 2a cf	jsr $cf2a			jsr 		FPUScale10A
.cfd9	ce 24 04	dec $0424			dec 		ExpCount
.cfdc	80 e3		bra $cfc1			bra 		_FPTSExponentLoop
.cfde					_FPTSScaledToExp:
.cfde	20 00 d0	jsr $d000			jsr 		FPTOutputBody 			; output the body.
.cfe1	a9 65		lda #$65			lda 		#"e"					; output E
.cfe3	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter
.cfe6	ad 24 04	lda $0424			lda 		ExpCount 				; get the exponent
.cfe9	9d 00 03	sta $0300,x			sta 		XS_Mantissa,x
.cfec	29 80		and #$80			and 		#$80 					; sign extend it
.cfee	f0 02		beq $cff2			beq 		_FPTSSExt
.cff0	a9 ff		lda #$ff			lda 		#$FF
.cff2					_FPTSSExt:
.cff2	9d 01 03	sta $0301,x			sta 		XS_Mantissa+1,x
.cff5	9d 02 03	sta $0302,x			sta 		XS_Mantissa+2,x
.cff8	9d 03 03	sta $0303,x			sta 		XS_Mantissa+3,x
.cffb	20 ab c9	jsr $c9ab			jsr 		INTToString 			; output the exponent.
.cffe	80 98		bra $cf98			bra			_FPTSExit 				; and exit.
.d000					FPTOutputBody:
.d000	20 6e cf	jsr $cf6e			jsr 		FPUCopyToNext 			; copy to next slot.
.d003	20 7a ce	jsr $ce7a			jsr 		FPUToInteger 			; convert to an integer
.d006	20 ab c9	jsr $c9ab			jsr 		INTToString 			; output the main integer part.
.d009	20 7d cf	jsr $cf7d			jsr 		FPUCopyFromNext 		; get the fractional part back.
.d00c	20 06 cd	jsr $cd06			jsr 		FPFractionalPart 		; get the decimal part.
.d00f	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; any fractional part.
.d012	70 3e		bvs $d052			bvs 		_FPTOExit 				; if not, exit now.
.d014	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.d016	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter
.d019					_FPOutLoop:
.d019	3c 05 03	bit $0305,x			bit 		XS_Type,x 				; finally reached zero.
.d01c	70 1e		bvs $d03c			bvs 		_FPStripZeros 			; strip trailing zeros
.d01e	20 c9 ce	jsr $cec9			jsr 		FPUTimes10 				; multiply by 10
.d021	20 6e cf	jsr $cf6e			jsr 		FPUCopyToNext			; copy to next slot.
.d024	20 7a ce	jsr $ce7a			jsr 		FPUToInteger 			; convert to integer
.d027	bd 00 03	lda $0300,x			lda 		XS_Mantissa+0,x 		; print digit.
.d02a	09 30		ora #$30			ora 		#"0"
.d02c	20 47 ca	jsr $ca47			jsr 		ITSOutputCharacter
.d02f	20 7d cf	jsr $cf7d			jsr 		FPUCopyFromNext 		; get it back
.d032	20 06 cd	jsr $cd06			jsr 		FPFractionalPart 		; get fractional part
.d035	ad 20 04	lda $0420			lda 		NumBufX 				; done 11 characters yet ?
.d038	c9 0b		cmp #$0b			cmp 	 	#11
.d03a	90 dd		bcc $d019			bcc 		_FPOutLoop 				; if so, keep going till zero.
.d03c					_FPStripZeros:
.d03c	ac 20 04	ldy $0420			ldy 		NumBufX 				; strip trailing zeros.
.d03f					_FPStripLoop:
.d03f	88		dey				dey 								; back one, if at start then no strip
.d040	f0 10		beq $d052			beq 		_FPToExit
.d042	b9 00 04	lda $0400,y			lda 		Num_Buffer,y 			; keep going if "0"
.d045	c9 30		cmp #$30			cmp 		#"0"
.d047	f0 f6		beq $d03f			beq 		_FPStripLoop
.d049	c8		iny				iny
.d04a	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.d04c	99 00 04	sta $0400,y			sta 		Num_Buffer,y
.d04f	8c 20 04	sty $0420			sty 		NumBufX 				; update position.
.d052					_FPTOExit:
.d052	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.d053					FPFromString:
.d053	48		pha				pha 								; push A
.d054	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.d056	c9 2e		cmp #$2e			cmp 	#"."
.d058	f0 03		beq $d05d			beq	 	_FPFIsDecimal
.d05a	4c c0 d0	jmp $d0c0			jmp 	_FPFNotDecimal
.d05d					_FPFIsDecimal:
.d05d	c8		iny				iny 								; consume the decimal.
.d05e	20 1b ce	jsr $ce1b			jsr 	FPUToFloat 					; convert the integer to float.
.d061	da		phx				phx 								; save X.
.d062	5a		phy				phy 								; save decimal start position
.d063	e8		inx				inx
.d064	e8		inx				inx
.d065	e8		inx				inx
.d066	e8		inx				inx
.d067	e8		inx				inx
.d068	e8		inx				inx
.d069	20 5f ca	jsr $ca5f			jsr 	INTFromStringY 				; get the part after the DP.
.d06c	20 1b ce	jsr $ce1b			jsr 	FPUToFloat 					; convert that to a float.
.d06f	68		pla				pla 								; calculate - chars consumed.
.d070	8c 23 04	sty $0423			sty 	ExpTemp
.d073	38		sec				sec
.d074	ed 23 04	sbc $0423			sbc 	ExpTemp 					; this is the shift amount
.d077	20 2a cf	jsr $cf2a			jsr 	FPUScale10A 				; scale it by 10^AC
.d07a	fa		plx				plx 								; restore original X
.d07b	20 0f cb	jsr $cb0f			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.d07e	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.d080	c9 45		cmp #$45			cmp 	#"E"
.d082	f0 04		beq $d088			beq 	_FPFExponent
.d084	c9 65		cmp #$65			cmp 	#"e"
.d086	d0 38		bne $d0c0			bne 	_FPFNotDecimal 				; no, then exit normally.
.d088					_FPFExponent:
.d088	c8		iny				iny 								; skip over E symbol.
.d089	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.d08b	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.d08d	d0 01		bne $d090			bne 	_FPFGotSign
.d08f	c8		iny				iny 								; if it was - skip over it.
.d090					_FPFGotSign:
.d090	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.d091	da		phx				phx
.d092	e8		inx				inx
.d093	e8		inx				inx
.d094	e8		inx				inx
.d095	e8		inx				inx
.d096	e8		inx				inx
.d097	e8		inx				inx
.d098	20 5f ca	jsr $ca5f			jsr 	INTFromStringY 				; get the exponent
.d09b	fa		plx				plx 								; restore X.
.d09c	bd 07 03	lda $0307,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.d09f	1d 09 03	ora $0309,x			ora 	XS2_Mantissa+3,x
.d0a2	1d 08 03	ora $0308,x			ora 	XS2_Mantissa+2,x
.d0a5	d0 1b		bne $d0c2			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.d0a7	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.d0aa	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.d0ac	b0 14		bcs $d0c2			bcs 	_FPFXOverflow
.d0ae	68		pla				pla 								; get direction
.d0af	d0 09		bne $d0ba			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.d0b1	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.d0b4	49 ff		eor #$ff			eor 	#$FF
.d0b6	1a		inc a				inc 	a
.d0b7	9d 06 03	sta $0306,x			sta 	XS2_Mantissa+0,x
.d0ba					_FPFXScale:
.d0ba	bd 06 03	lda $0306,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.d0bd	20 2a cf	jsr $cf2a			jsr 	FPUScale10A 				; scale by the exponent.
.d0c0					_FPFNotDecimal:
.d0c0	68		pla				pla
.d0c1	60		rts				rts
.d0c2					_FPFXOverflow:
.d0c2	20 09 c4	jsr $c409			jsr 	ERR_Handler
>d0c5	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>d0cd	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.d0d4					TIM_Error:
.d0d4	20 2a c2	jsr $c22a			jsr 	IFT_UpLine 					; go up one line.
.d0d7	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.d0d9	80 02		bra $d0dd			bra 	TIM_ShowPrompt
.d0db					TIM_NewCommand:
.d0db	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.d0dd					TIM_ShowPrompt:
.d0dd	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.d0e0	20 ee c2	jsr $c2ee			jsr 	IFT_ReadLine	 			; get character, go to next line
.d0e3	20 50 c2	jsr $c250			jsr 	IFT_NewLine					; go to next line.
.d0e6	86 10		stx $10				stx 	zTemp1 						; save line read address
.d0e8	84 11		sty $11				sty 	zTemp1+1
.d0ea	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.d0ec	b1 10		lda ($10),y			lda 	(zTemp1),y
.d0ee	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.d0f0	d0 01		bne $d0f3			bne 	TIM_NotDot
.d0f2	c8		iny				iny
.d0f3					TIM_NotDot:
.d0f3	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.d0f5	c9 52		cmp #$52			cmp 	#"R"						; show registers
.d0f7	f0 6b		beq $d164			beq 	TIM_ShowRegisters
.d0f9	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.d0fb	f0 12		beq $d10f			beq 	TIM_ShowMemory
.d0fd	c9 47		cmp #$47			cmp 	#"G"						; execute
.d0ff	f0 49		beq $d14a			beq 	TIM_Execute
.d101	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.d103	f0 07		beq $d10c			beq 	TIM_GoLoadMemory
.d105	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.d107	d0 cb		bne $d0d4			bne 	TIM_Error
.d109	4c 87 d2	jmp $d287			jmp 	TIM_UpdateRegisters
.d10c					TIM_GoLoadMemory:
.d10c	4c b7 d2	jmp $d2b7			jmp 	TIM_LoadMemory
.d10f					TIM_ShowMemory:
.d10f	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d112	b0 c0		bcs $d0d4			bcs 	TIM_Error
.d114	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.d116	85 12		sta $12				sta 	zTemp2
.d118	a5 15		lda $15				lda 	zTemp3+1
.d11a	85 13		sta $13				sta 	zTemp2+1
.d11c	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.d11f	90 08		bcc $d129			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.d121	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.d123	85 14		sta $14				sta 	zTemp3
.d125	a5 13		lda $13				lda 	zTemp2+1
.d127	85 15		sta $15				sta 	zTemp3+1
.d129					_TIMSM_Start:
.d129	20 db d1	jsr $d1db			jsr 	TIM_WriteLine 				; write one line of hex out
.d12c	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.d12e	18		clc				clc
.d12f	69 10		adc #$10			adc 	#16
.d131	85 12		sta $12				sta 	zTemp2
.d133	90 02		bcc $d137			bcc 	_TIMSM_NoCarry
.d135	e6 13		inc $13				inc 	zTemp2+1
.d137					_TIMSM_NoCarry:
.d137	20 d5 c3	jsr $c3d5			jsr 	IF_CheckBreak 				; check CTL+C
.d13a	d0 0b		bne $d147			bne 	_TIMSM_Ends 				; if pressed break out.
.d13c	38		sec				sec 								; check past the end address in zTemp3
.d13d	a5 14		lda $14				lda 	zTemp3
.d13f	e5 12		sbc $12				sbc 	zTemp2
.d141	a5 15		lda $15				lda 	zTemp3+1
.d143	e5 13		sbc $13				sbc 	zTemp2+1
.d145	10 e2		bpl $d129			bpl 	_TIMSM_Start
.d147					_TIMSM_Ends:
.d147	4c db d0	jmp $d0db			jmp 	TIM_NewCommand
.d14a					TIM_Execute:
.d14a	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; get the execute address
.d14d	b0 85		bcs $d0d4			bcs 	TIM_Error 					; not legitimate
.d14f	ae 31 04	ldx $0431			ldx 	TIM_SP 						; set up SP
.d152	9a		txs				txs
.d153	ad 2c 04	lda $042c			lda 	TIM_SR 						; Status for PLP
.d156	48		pha				pha
.d157	ad 2d 04	lda $042d			lda 	TIM_A 						; restore AXYZ
.d15a	ae 2e 04	ldx $042e			ldx 	TIM_X
.d15d	ac 2f 04	ldy $042f			ldy 	TIM_Y
.d160	28		plp				plp 								; and PS Byte.
.d161	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.d164					TIM_Start:
.d164					TIM_ShowRegisters:
.d164	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.d167	8d 2b 04	sta $042b			sta 	TIM_IRQ+1
.d16a	ad ff ff	lda $ffff			lda 	$FFFF
.d16d	8d 2a 04	sta $042a			sta 	TIM_IRQ
.d170	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.d172					_TIMSR_Text:
.d172	bd a2 d1	lda $d1a2,x			lda 	_TIMSR_Label,x
.d175	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d178	e8		inx				inx
.d179	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.d17b	d0 f5		bne $d172			bne 	_TIMSR_Text
.d17d	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.d17f					_TIMSR_Skip:
.d17f	e8		inx				inx
.d180					_TIMSR_LoopSpace:
.d180	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.d182	b0 04		bcs $d188			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.d184	8a		txa				txa
.d185	4a		lsr a				lsr 	a
.d186	b0 05		bcs $d18d			bcs 	_TIMSR_NoSpace
.d188					_TIMSR_Space:
.d188	a9 20		lda #$20			lda 	#" "
.d18a	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d18d					_TIMSR_NoSpace:
.d18d	bd 28 04	lda $0428,x			lda 	TIM_PC,x 					; output hex value.
.d190	20 c2 d1	jsr $d1c2			jsr 	TIM_WriteHex
.d193	e8		inx				inx
.d194	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.d196	f0 e7		beq $d17f			beq 	_TIMSR_Skip
.d198	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.d19a	d0 e4		bne $d180			bne 	_TimSR_LoopSpace
.d19c	20 50 c2	jsr $c250			jsr 	IFT_NewLine 				; new line
.d19f	4c db d0	jmp $d0db			jmp	 	TIM_NewCommand 				; new command.
.d1a2					_TIMSR_Label:
>d1a2	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>d1aa	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>d1ba	52
>d1bb	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.d1c2					_TIMSR_LabelEnd:
.d1c2					TIM_WriteHex:
.d1c2	48		pha				pha 								; save A
.d1c3	4a		lsr a				lsr 	a 							; shift MSB->LSB
.d1c4	4a		lsr a				lsr 	a
.d1c5	4a		lsr a				lsr 	a
.d1c6	4a		lsr a				lsr 	a
.d1c7	20 cb d1	jsr $d1cb			jsr 	_TIMWH_Nibble 				; print MSB
.d1ca	68		pla				pla 								; restore and print LSB
.d1cb					_TIMWH_Nibble:
.d1cb	48		pha				pha
.d1cc	29 0f		and #$0f			and 	#15 						; mask out
.d1ce	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.d1d0	90 02		bcc $d1d4			bcc 	_TIMWHNoLetter
.d1d2	69 06		adc #$06			adc 	#6
.d1d4					_TIMWHNoLetter:
.d1d4	69 30		adc #$30			adc 	#48
.d1d6	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter 			; print it out.
.d1d9	68		pla				pla
.d1da	60		rts				rts
.d1db					TIM_WriteLine:
.d1db	a9 2e		lda #$2e			lda 	#"." 						; prompt
.d1dd	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d1e0	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.d1e2	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d1e5	a5 13		lda $13				lda 	zTemp2+1 					; write address
.d1e7	20 c2 d1	jsr $d1c2			jsr 	TIM_WriteHex
.d1ea	a5 12		lda $12				lda 	zTemp2
.d1ec	20 c2 d1	jsr $d1c2			jsr 	TIM_WriteHex
.d1ef	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.d1f1					_TIMWL_Loop:
.d1f1	a9 20		lda #$20			lda 	#" "
.d1f3	20 36 c2	jsr $c236			jsr 	IFT_PrintCharacter
.d1f6	b1 12		lda ($12),y			lda 	(zTemp2),y
.d1f8	20 c2 d1	jsr $d1c2			jsr 	TIM_WriteHex
.d1fb	c8		iny				iny
.d1fc	c0 10		cpy #$10			cpy 	#16
.d1fe	d0 f1		bne $d1f1			bne 	_TIMWL_Loop
.d200	4c 50 c2	jmp $c250			jmp 	IFT_NewLine 				; new line and exit
.d203					TIM_GetHex:
.d203	c8		iny				iny
.d204	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.d206	c9 20		cmp #$20			cmp 	#32
.d208	f0 f9		beq $d203			beq 	TIM_GetHex
.d20a	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.d20c	f0 f5		beq $d203			beq 	TIM_GetHex
.d20e	20 37 d2	jsr $d237			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.d211	b0 23		bcs $d236			bcs 	_TIMGH_Exit					; if first bad then exit now.
.d213	a9 00		lda #$00			lda 	#0 							; zero result
.d215	85 14		sta $14				sta 	zTemp3
.d217	85 15		sta $15				sta 	zTemp3+1
.d219					_TIM_GHLoop:
.d219	20 37 d2	jsr $d237			jsr 	TIM_GetHexCharacter 		; get next character
.d21c	b0 17		bcs $d235			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.d21e	c8		iny				iny 								; skip over it.
.d21f	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.d221	26 15		rol $15				rol 	zTemp3+1
.d223	06 14		asl $14				asl 	zTemp3 						; now x 2
.d225	26 15		rol $15				rol 	zTemp3+1
.d227	06 14		asl $14				asl 	zTemp3						; now x 4
.d229	26 15		rol $15				rol 	zTemp3+1
.d22b	06 14		asl $14				asl 	zTemp3 						; now x 8
.d22d	26 15		rol $15				rol 	zTemp3+1
.d22f	05 14		ora $14				ora 	zTemp3 						; OR result in
.d231	85 14		sta $14				sta 	zTemp3
.d233	80 e4		bra $d219			bra 	_TIM_GHLoop 				; loop round again.
.d235					_TIMGH_Okay:
.d235	18		clc				clc
.d236					_TIMGH_Exit:
.d236	60		rts				rts
.d237					TIM_GetHexCharacter:
.d237	b1 10		lda ($10),y			lda 	(zTemp1),y
.d239	38		sec				sec
.d23a	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.d23c	90 0e		bcc $d24c			bcc 	_TIM_GHCFail
.d23e	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.d240	90 0b		bcc $d24d			bcc 	_TIM_GHCExit
.d242	c9 11		cmp #$11			cmp 	#65-48						; < A
.d244	90 06		bcc $d24c			bcc		_TIM_GHCFail
.d246	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.d248	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.d24a	90 01		bcc $d24d			bcc		_TIM_GHCExit
.d24c					_TIM_GHCFail:
.d24c	38		sec				sec
.d24d					_TIM_GHCExit:
.d24d	60		rts				rts
.d24e					TIM_BreakVector:
.d24e	da		phx				phx									; save X/A on stack
.d24f	48		pha				pha
.d250	ba		tsx				tsx 								; X points to S
.d251	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.d254	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.d256	d0 03		bne $d25b			bne 	_TIMBreak					; if set, it's BRK
.d258	68		pla				pla 								; abandon routine.
.d259	fa		plx				plx
.d25a	40		rti				rti
.d25b					_TIMBreak:
.d25b	68		pla				pla 								; save A X Y and maybe Z
.d25c	8d 2d 04	sta $042d			sta 	TIM_A
.d25f	fa		plx				plx
.d260	8e 2e 04	stx $042e			stx 	TIM_X
.d263	8c 2f 04	sty $042f			sty 	TIM_Y
.d266	68		pla				pla 								; get Status Register
.d267	8d 2c 04	sta $042c			sta 	TIM_SR
.d26a	68		pla				pla
.d26b	8d 29 04	sta $0429			sta 	TIM_PC+1 					; save calling address
.d26e	68		pla				pla
.d26f	8d 28 04	sta $0428			sta 	TIM_PC 						; high byte
.d272	ad 29 04	lda $0429			lda 	TIM_PC+1 					; dec PC to point right.
.d275	d0 03		bne $d27a			bne 	_TIMDecrement 				; brk bumps it.
.d277	ce 28 04	dec $0428			dec 	TIM_PC
.d27a					_TIMDecrement:
.d27a	ce 29 04	dec $0429			dec 	TIM_PC+1
.d27d	ba		tsx				tsx 								; and copy SP
.d27e	8e 31 04	stx $0431			stx 	TIM_SP
.d281	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.d283	9a		txs				txs
.d284	4c 64 d1	jmp $d164			jmp 	TIM_Start 					; and start up TIM monitor.
.d287					TIM_UpdateRegisters:
.d287	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; PC
.d28a	b0 28		bcs $d2b4			bcs 	_TIMURFail
.d28c	a5 14		lda $14				lda 	zTemp3
.d28e	8d 29 04	sta $0429			sta 	Tim_PC+1
.d291	a5 15		lda $15				lda 	zTemp3+1
.d293	8d 28 04	sta $0428			sta 	Tim_PC
.d296	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; ignore IRQ
.d299	b0 19		bcs $d2b4			bcs 	_TIMURFail
.d29b	a2 00		ldx #$00			ldx 	#0
.d29d					_TIM_URLoop:
.d29d	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.d29f	d0 01		bne $d2a2			bne 	_TIM_1
.d2a1	e8		inx				inx
.d2a2					_TIM_1:
.d2a2	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; registers
.d2a5	b0 0d		bcs $d2b4			bcs 	_TIMURFail
.d2a7	a5 14		lda $14				lda 	zTemp3
.d2a9	9d 2c 04	sta $042c,x			sta 	Tim_SR,x
.d2ac	e8		inx				inx
.d2ad	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.d2af	d0 ec		bne $d29d			bne 	_TIM_URLoop
.d2b1	4c db d0	jmp $d0db			jmp 	TIM_NewCommand
.d2b4					_TIMURFail:
.d2b4	4c d4 d0	jmp $d0d4			jmp 	TIM_Error
.d2b7					TIM_LoadMemory:
.d2b7	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; target address => zTemp2
.d2ba	a5 14		lda $14				lda 	zTemp3
.d2bc	85 12		sta $12				sta 	zTemp2
.d2be	a5 15		lda $15				lda 	zTemp3+1
.d2c0	85 13		sta $13				sta 	zTemp2+1
.d2c2					_TIM_LMLoop:
.d2c2	20 03 d2	jsr $d203			jsr 	TIM_GetHex 					; next byte ?
.d2c5	b0 0e		bcs $d2d5			bcs 	_TIMLMDone 					; no more
.d2c7	a2 00		ldx #$00			ldx 	#0							; write out.
.d2c9	a5 14		lda $14				lda 	zTemp3
.d2cb	81 12		sta ($12,x)			sta 	(zTemp2,x)
.d2cd	e6 12		inc $12				inc 	zTemp2 						; bump address
.d2cf	d0 f1		bne $d2c2			bne 	_TIM_LMLoop
.d2d1	e6 13		inc $13				inc 	zTemp2+1
.d2d3	80 ed		bra $d2c2			bra 	_TIM_LMLoop
.d2d5					_TIMLMDone:
.d2d5	4c db d0	jmp $d0db			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>d2d8	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	e5 c1						.word 	StartROM
>fffe	4e d2					.word TIM_BreakVector

;******  End of listing
