
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sat Aug 31 20:29:45 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bf					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c1					Tim_SR:		.byte ? 						; Processor Status
>03c2					Tim_A:		.byte ? 						; Processor Registers
>03c3					Tim_X:		.byte ?
>03c4					Tim_Y:		.byte ?
>03c5					Tim_Z:		.byte ?
>03c6					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0d 0a 00 92 09 84 41 c8			.byte	$0d,$0a,$00,$92,$09,$84,$41,$c8
>1008	42 4c c9 51 00 12 14 00			.byte	$42,$4c,$c9,$51,$00,$12,$14,$00
>1010	d6 09 c1 b5 40 be c1 b6			.byte	$d6,$09,$c1,$b5,$40,$be,$c1,$b6
>1018	68 be c1 fe 03 2a 00 06			.byte	$68,$be,$c1,$fe,$03,$2a,$00,$06
>1020	1e 00 97 09 00 05 28 00			.byte	$1e,$00,$97,$09,$00,$05,$28,$00
>1028	c4 00 00				.byte	$c4,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c d6 87 01	jmp $0187d6		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 69 83 01	jmp $018369			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 9c 81	jsr $01819c			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 9c 81	jsr $01819c			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 be 80	jsr $0180be			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 16		beq $01804f			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 67 80	jsr $018067			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_NewLine:
.01804f	48		pha				pha
.018050	20 af 81	jsr $0181af			jsr 	IF_NewLine 					; new line on actual screen.
.018053	a9 00		lda #$00			lda 	#0 							; reset x position
.018055	8d 00 05	sta $0500			sta 	IFT_XCursor
.018058	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.01805b	ad 01 05	lda $0501			lda 	IFT_YCursor
.01805e	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.018060	d0 03		bne $018065			bne 	_IFT_NL_NotEOS
.018062	20 72 80	jsr $018072			jsr 	IFT_Scroll 					; scroll screen up.
.018065					_IFT_NL_NotEOS:
.018065	68		pla				pla
.018066	60		rts				rts
.018067					IFT_UpperCase:
.018067	c9 61		cmp #$61			cmp 	#"a"
.018069	90 06		bcc $018071			bcc 	_IFT_UCExit
.01806b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01806d	b0 02		bcs $018071			bcs 	_IFT_UCExit
.01806f	49 20		eor #$20			eor 	#$20
.018071					_IFT_UCExit:
.018071	60		rts				rts
.018072					IFT_Scroll:
.018072	48		pha				pha 								; save AXY
.018073	da		phx				phx
.018074	5a		phy				phy
.018075	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018077					_IFT_SLoop:
.018077	20 97 80	jsr $018097			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.01807a	e8		inx				inx
.01807b	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01807d	d0 f8		bne $018077			bne 	_IFT_SLoop
.01807f	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018081	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018084	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018086					_IFT_SBlank:
.018086	a9 20		lda #$20			lda 	#32
.018088	20 c8 81	jsr $0181c8			jsr 	IF_Write
.01808b	ca		dex				dex
.01808c	d0 f8		bne $018086			bne 	_IFT_SBlank
.01808e	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.018090	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018093	7a		ply				ply
.018094	fa		plx				plx
.018095	68		pla				pla
.018096	60		rts				rts
.018097					_IFT_ScrollLine:
.018097	da		phx				phx
.018098	da		phx				phx
.018099	8a		txa				txa 								; copy line into buffer.
.01809a	1a		inc a				inc 	a 							; next line down.
.01809b	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.01809e	a2 00		ldx #$00			ldx 	#0
.0180a0					_IFTScrollCopy1:
.0180a0	20 bf 81	jsr $0181bf			jsr 	IF_Read
.0180a3	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180a6	e8		inx				inx
.0180a7	e0 40		cpx #$40			cpx 	#IF_Width
.0180a9	d0 f5		bne $0180a0			bne 	_IFTScrollCopy1
.0180ab	68		pla				pla
.0180ac	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.0180af	a2 00		ldx #$00			ldx 	#0
.0180b1					_IFTScrollCopy2:
.0180b1	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180b4	20 c8 81	jsr $0181c8			jsr 	IF_Write
.0180b7	e8		inx				inx
.0180b8	e0 40		cpx #$40			cpx 	#IF_Width
.0180ba	d0 f5		bne $0180b1			bne 	_IFTScrollCopy2
.0180bc	fa		plx				plx
.0180bd	60		rts				rts
.0180be					IFT_SetYPos:
.0180be	48		pha				pha
.0180bf	da		phx				phx
.0180c0	aa		tax				tax
.0180c1	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180c4	e0 00		cpx #$00			cpx 	#0
.0180c6	f0 09		beq $0180d1			beq 	_IFT_MOAExit
.0180c8					_IFT_MOALoop:
.0180c8	20 af 81	jsr $0181af			jsr 	IF_NewLine
.0180cb	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180ce	ca		dex				dex
.0180cf	d0 f7		bne $0180c8			bne		_IFT_MOALoop
.0180d1					_IFT_MOAExit:
.0180d1	fa		plx				plx
.0180d2	68		pla				pla
.0180d3	60		rts				rts
.0180d4					IFT_GetKeyCursor:
.0180d4	20 dc 80	jsr $0180dc			jsr 	_IFT_FlipCursor 			; reverse current
.0180d7					_IFT_GKCWait:
.0180d7	20 d9 81	jsr $0181d9			jsr 	IF_GetKey 					; get key
.0180da	f0 fb		beq $0180d7			beq 	_IFT_GKCWait
.0180dc					_IFT_FlipCursor:
.0180dc	48		pha				pha 								; save
.0180dd	20 bf 81	jsr $0181bf			jsr 	IF_Read 					; read
.0180e0	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180e3	49 80		eor #$80			eor 	#$80 						; reverse
.0180e5	20 c8 81	jsr $0181c8			jsr 	IF_Write 					; write
.0180e8	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.0180eb	68		pla				pla
.0180ec	60		rts				rts
.0180ed					IFT_ReadLine:
.0180ed	48		pha				pha
.0180ee					_IFT_RLLoop:
.0180ee	20 d4 80	jsr $0180d4			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180f1	c9 0d		cmp #$0d			cmp 	#13							; return
.0180f3	f0 7d		beq $018172			beq 	_IFT_RLExit
.0180f5	c9 20		cmp #$20			cmp 	#32 						; control character
.0180f7	90 05		bcc $0180fe			bcc 	_IFT_Control
.0180f9	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0180fc	80 f0		bra $0180ee			bra 	_IFT_RLLoop
.0180fe					_IFT_Control:
.0180fe	c9 01		cmp #$01			cmp 	#"A"-64
.018100	f0 26		beq $018128			beq 	_IFT_Left
.018102	c9 04		cmp #$04			cmp 	#"D"-64
.018104	f0 2e		beq $018134			beq 	_IFT_Right
.018106	c9 17		cmp #$17			cmp 	#"W"-64
.018108	f0 36		beq $018140			beq 	_IFT_Up
.01810a	c9 13		cmp #$13			cmp 	#"S"-64
.01810c	f0 3e		beq $01814c			beq 	_IFT_Down
.01810e	c9 08		cmp #$08			cmp 	#"H"-64
.018110	f0 09		beq $01811b			beq 	_IFT_Backspace
.018112	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018114	d0 d8		bne $0180ee			bne 	_IFT_RLLoop
.018116	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018119	80 d3		bra $0180ee			bra 	_IFT_RLLoop
.01811b					_IFT_Backspace:
.01811b	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01811e	f0 ce		beq $0180ee			beq 	_IFT_RLLoop
.018120	20 d1 81	jsr $0181d1			jsr 	IF_LeftOne
.018123	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018125	20 c8 81	jsr $0181c8			jsr 	IF_Write
.018128					_IFT_Left:
.018128	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.01812b	10 29		bpl $018156			bpl 	_IFT_Reposition
.01812d	a9 3f		lda #$3f			lda 	#IF_Width-1
.01812f					_IFT_SetX:
.01812f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018132	80 22		bra $018156			bra 	_IFT_Reposition
.018134					_IFT_Right:
.018134	ee 00 05	inc $0500			inc 	IFT_XCursor
.018137	ad 00 05	lda $0500			lda 	IFT_XCursor
.01813a	49 40		eor #$40			eor 	#IF_Width
.01813c	f0 f1		beq $01812f			beq 	_IFT_SetX
.01813e	80 16		bra $018156			bra 	_IFT_Reposition
.018140					_IFT_Up:
.018140	ce 01 05	dec $0501			dec 	IFT_YCursor
.018143	10 11		bpl $018156			bpl 	_IFT_Reposition
.018145	a9 1f		lda #$1f			lda 	#IF_Height-1
.018147					_IFT_SetY:
.018147	8d 01 05	sta $0501			sta 	IFT_YCursor
.01814a	80 0a		bra $018156			bra 	_IFT_Reposition
.01814c					_IFT_Down:
.01814c	ee 01 05	inc $0501			inc 	IFT_YCursor
.01814f	ad 01 05	lda $0501			lda 	IFT_YCursor
.018152	49 20		eor #$20			eor 	#IF_Height
.018154	f0 f1		beq $018147			beq 	_IFT_SetY
.018156					_IFT_Reposition:
.018156	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018159	48		pha				pha
.01815a	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815d	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018160	68		pla				pla
.018161	aa		tax				tax
.018162	e0 00		cpx #$00			cpx 	#0
.018164	f0 88		beq $0180ee			beq 	_IFT_RLLoop
.018166					_IFT_MoveRight:
.018166	20 bf 81	jsr $0181bf			jsr 	IF_Read
.018169	ee 00 05	inc $0500			inc 	IFT_XCursor
.01816c	ca		dex				dex
.01816d	d0 f7		bne $018166			bne 	_IFT_MoveRight
.01816f	4c ee 80	jmp $0180ee			jmp 	_IFT_RLLoop
.018172					_IFT_RLExit:
.018172	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018175	20 be 80	jsr $0180be			jsr 	IFT_SetYPos
.018178	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.01817a					_IFT_RLRead:
.01817a	20 bf 81	jsr $0181bf			jsr 	IF_Read
.01817d	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018180	e8		inx				inx
.018181	e0 40		cpx #$40			cpx 	#IF_Width
.018183	d0 f5		bne $01817a			bne 	_IFT_RLRead
.018185					_IFT_RL_Trim:
.018185	ca		dex				dex 	 							; previous char
.018186	30 07		bmi $01818f			bmi 	_IFT_Found 					; gone too far
.018188	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.01818b	c9 20		cmp #$20			cmp 	#" "
.01818d	f0 f6		beq $018185			beq 	_IFT_RL_Trim
.01818f					_IFT_Found:
.01818f	e8		inx				inx 								; forward to non-space
.018190	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.018192	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.018195	68		pla				pla
.018196	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.018198	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.01819a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.01819b					IF_Reset:
.01819b	60		rts				rts
.01819c					IF_Home:
.01819c	48		pha				pha
.01819d	64 08		stz $08				stz 	IF_XPos 					; zero X position
.01819f	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181a1	85 04		sta $04				sta 	IF_Pos
.0181a3	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181a5	85 05		sta $05				sta 	IF_Pos+1
.0181a7	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181a9	85 06		sta $06				sta 	IF_Pos+2
.0181ab	64 07		stz $07				stz 	IF_Pos+3
.0181ad	68		pla				pla
.0181ae	60		rts				rts
.0181af					IF_NewLine:
.0181af	48		pha				pha
.0181b0	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181b2	18		clc				clc 								; down one line
.0181b3	a5 04		lda $04				lda 	IF_Pos
.0181b5	69 40		adc #$40			adc 	#64
.0181b7	85 04		sta $04				sta 	IF_Pos
.0181b9	90 02		bcc $0181bd			bcc 	_IF_NoCarry 				; carry through.
.0181bb	e6 05		inc $05				inc 	IF_Pos+1
.0181bd					_IF_NoCarry:
.0181bd	68		pla				pla
.0181be	60		rts				rts
.0181bf					IF_Read:
.0181bf	5a		phy				phy 								; save current Y
.0181c0	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181c2	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181c4	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181c6	7a		ply				ply									; restore Y
.0181c7	60		rts				rts
.0181c8					IF_Write:
.0181c8	5a		phy				phy 								; save current Y
.0181c9	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181cb	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181cd	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181cf	7a		ply				ply									; restore Y
.0181d0	60		rts				rts
.0181d1					IF_LeftOne:
.0181d1	c6 08		dec $08				dec 	IF_XPos
.0181d3	60		rts				rts
.0181d4					IF_CheckBreak:
.0181d4	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181d8	60		rts				rts
.0181d9					IF_GetKey:
.0181d9	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181dd	f0 08		beq $0181e7			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181df	48		pha				pha 								; key pressed, clear queue.
.0181e0	a9 00		lda #$00			lda 	#0
.0181e2	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181e6	68		pla				pla
.0181e7					_IFGK_NoKey:
.0181e7	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181e9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181ea					TIM_Error:
.0181ea	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181ed	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181ef	80 02		bra $0181f3			bra 	TIM_ShowPrompt
.0181f1					TIM_NewCommand:
.0181f1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181f3					TIM_ShowPrompt:
.0181f3	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.0181f6	20 ed 80	jsr $0180ed			jsr 	IFT_ReadLine	 			; get character, go to next line
.0181f9	20 4f 80	jsr $01804f			jsr 	IFT_NewLine					; go to next line.
.0181fc	86 10		stx $10				stx 	zTemp1 						; save line read address
.0181fe	84 11		sty $11				sty 	zTemp1+1
.018200	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.018202	b1 10		lda ($10),y			lda 	(zTemp1),y
.018204	c9 3f		cmp #$3f			cmp 	#"?"
.018206	f0 04		beq $01820c			beq 	TIM_SkipFirst
.018208	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.01820a	d0 01		bne $01820d			bne 	TIM_NotDot
.01820c					TIM_SkipFirst:
.01820c	c8		iny				iny
.01820d					TIM_NotDot:
.01820d	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01820f	c9 52		cmp #$52			cmp 	#"R"						; show registers
.018211	f0 6b		beq $01827e			beq 	TIM_ShowRegisters
.018213	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018215	f0 12		beq $018229			beq 	TIM_ShowMemory
.018217	c9 47		cmp #$47			cmp 	#"G"						; execute
.018219	f0 49		beq $018264			beq 	TIM_Execute
.01821b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01821d	f0 07		beq $018226			beq 	TIM_GoLoadMemory
.01821f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.018221	d0 c7		bne $0181ea			bne 	TIM_Error
.018223	4c a2 83	jmp $0183a2			jmp 	TIM_UpdateRegisters
.018226					TIM_GoLoadMemory:
.018226	4c d2 83	jmp $0183d2			jmp 	TIM_LoadMemory
.018229					TIM_ShowMemory:
.018229	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.01822c	b0 bc		bcs $0181ea			bcs 	TIM_Error
.01822e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.018230	85 12		sta $12				sta 	zTemp2
.018232	a5 15		lda $15				lda 	zTemp3+1
.018234	85 13		sta $13				sta 	zTemp2+1
.018236	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	90 08		bcc $018243			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.01823b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01823d	85 14		sta $14				sta 	zTemp3
.01823f	a5 13		lda $13				lda 	zTemp2+1
.018241	85 15		sta $15				sta 	zTemp3+1
.018243					_TIMSM_Start:
.018243	20 f6 82	jsr $0182f6			jsr 	TIM_WriteLine 				; write one line of hex out
.018246	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018248	18		clc				clc
.018249	69 10		adc #$10			adc 	#16
.01824b	85 12		sta $12				sta 	zTemp2
.01824d	90 02		bcc $018251			bcc 	_TIMSM_NoCarry
.01824f	e6 13		inc $13				inc 	zTemp2+1
.018251					_TIMSM_NoCarry:
.018251	20 d4 81	jsr $0181d4			jsr 	IF_CheckBreak 				; check CTL+C
.018254	d0 0b		bne $018261			bne 	_TIMSM_Ends 				; if pressed break out.
.018256	38		sec				sec 								; check past the end address in zTemp3
.018257	a5 14		lda $14				lda 	zTemp3
.018259	e5 12		sbc $12				sbc 	zTemp2
.01825b	a5 15		lda $15				lda 	zTemp3+1
.01825d	e5 13		sbc $13				sbc 	zTemp2+1
.01825f	10 e2		bpl $018243			bpl 	_TIMSM_Start
.018261					_TIMSM_Ends:
.018261	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.018264					TIM_Execute:
.018264	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; get the execute address
.018267	b0 81		bcs $0181ea			bcs 	TIM_Error 					; not legitimate
.018269	ae c6 03	ldx $03c6			ldx 	TIM_SP 						; set up SP
.01826c	9a		txs				txs
.01826d	ad c1 03	lda $03c1			lda 	TIM_SR 						; Status for PLP
.018270	48		pha				pha
.018271	ad c2 03	lda $03c2			lda 	TIM_A 						; restore AXYZ
.018274	ae c3 03	ldx $03c3			ldx 	TIM_X
.018277	ac c4 03	ldy $03c4			ldy 	TIM_Y
.01827a	28		plp				plp 								; and PS Byte.
.01827b	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01827e					TIM_Start:
.01827e					TIM_ShowRegisters:
.01827e	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.018281	8d c0 03	sta $03c0			sta 	TIM_IRQ+1
.018284	ad ff ff	lda $ffff			lda 	$FFFF
.018287	8d bf 03	sta $03bf			sta 	TIM_IRQ
.01828a	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.01828c					_TIMSR_Text:
.01828c	bf bd 82 01	lda $0182bd,x			lda 	_TIMSR_Label,x
.018290	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018293	e8		inx				inx
.018294	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.018296	d0 f4		bne $01828c			bne 	_TIMSR_Text
.018298	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.01829a					_TIMSR_Skip:
.01829a	e8		inx				inx
.01829b					_TIMSR_LoopSpace:
.01829b	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.01829d	b0 04		bcs $0182a3			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.01829f	8a		txa				txa
.0182a0	4a		lsr a				lsr 	a
.0182a1	b0 05		bcs $0182a8			bcs 	_TIMSR_NoSpace
.0182a3					_TIMSR_Space:
.0182a3	a9 20		lda #$20			lda 	#" "
.0182a5	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a8					_TIMSR_NoSpace:
.0182a8	bd bd 03	lda $03bd,x			lda 	TIM_PC,x 					; output hex value.
.0182ab	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.0182ae	e8		inx				inx
.0182af	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182b1	f0 e7		beq $01829a			beq 	_TIMSR_Skip
.0182b3	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182b5	d0 e4		bne $01829b			bne 	_TimSR_LoopSpace
.0182b7	20 4f 80	jsr $01804f			jsr 	IFT_NewLine 				; new line
.0182ba	4c f1 81	jmp $0181f1			jmp	 	TIM_NewCommand 				; new command.
.0182bd					_TIMSR_Label:
>0182bd	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182c5	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182d5	52
>0182d6	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182dd					_TIMSR_LabelEnd:
.0182dd					TIM_WriteHex:
.0182dd	48		pha				pha 								; save A
.0182de	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182df	4a		lsr a				lsr 	a
.0182e0	4a		lsr a				lsr 	a
.0182e1	4a		lsr a				lsr 	a
.0182e2	20 e6 82	jsr $0182e6			jsr 	_TIMWH_Nibble 				; print MSB
.0182e5	68		pla				pla 								; restore and print LSB
.0182e6					_TIMWH_Nibble:
.0182e6	48		pha				pha
.0182e7	29 0f		and #$0f			and 	#15 						; mask out
.0182e9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182eb	90 02		bcc $0182ef			bcc 	_TIMWHNoLetter
.0182ed	69 06		adc #$06			adc 	#6
.0182ef					_TIMWHNoLetter:
.0182ef	69 30		adc #$30			adc 	#48
.0182f1	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182f4	68		pla				pla
.0182f5	60		rts				rts
.0182f6					TIM_WriteLine:
.0182f6	a9 2e		lda #$2e			lda 	#"." 						; prompt
.0182f8	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182fb	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.0182fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018300	a5 13		lda $13				lda 	zTemp2+1 					; write address
.018302	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018305	a5 12		lda $12				lda 	zTemp2
.018307	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.01830a	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.01830c					_TIMWL_Loop:
.01830c	a9 20		lda #$20			lda 	#" "
.01830e	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018311	b1 12		lda ($12),y			lda 	(zTemp2),y
.018313	20 dd 82	jsr $0182dd			jsr 	TIM_WriteHex
.018316	c8		iny				iny
.018317	c0 10		cpy #$10			cpy 	#16
.018319	d0 f1		bne $01830c			bne 	_TIMWL_Loop
.01831b	4c 4f 80	jmp $01804f			jmp 	IFT_NewLine 				; new line and exit
.01831e					TIM_GetHex:
.01831e	c8		iny				iny
.01831f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.018321	c9 20		cmp #$20			cmp 	#32
.018323	f0 f9		beq $01831e			beq 	TIM_GetHex
.018325	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018327	f0 f5		beq $01831e			beq 	TIM_GetHex
.018329	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.01832c	b0 23		bcs $018351			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01832e	a9 00		lda #$00			lda 	#0 							; zero result
.018330	85 14		sta $14				sta 	zTemp3
.018332	85 15		sta $15				sta 	zTemp3+1
.018334					_TIM_GHLoop:
.018334	20 52 83	jsr $018352			jsr 	TIM_GetHexCharacter 		; get next character
.018337	b0 17		bcs $018350			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018339	c8		iny				iny 								; skip over it.
.01833a	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.01833c	26 15		rol $15				rol 	zTemp3+1
.01833e	06 14		asl $14				asl 	zTemp3 						; now x 2
.018340	26 15		rol $15				rol 	zTemp3+1
.018342	06 14		asl $14				asl 	zTemp3						; now x 4
.018344	26 15		rol $15				rol 	zTemp3+1
.018346	06 14		asl $14				asl 	zTemp3 						; now x 8
.018348	26 15		rol $15				rol 	zTemp3+1
.01834a	05 14		ora $14				ora 	zTemp3 						; OR result in
.01834c	85 14		sta $14				sta 	zTemp3
.01834e	80 e4		bra $018334			bra 	_TIM_GHLoop 				; loop round again.
.018350					_TIMGH_Okay:
.018350	18		clc				clc
.018351					_TIMGH_Exit:
.018351	60		rts				rts
.018352					TIM_GetHexCharacter:
.018352	b1 10		lda ($10),y			lda 	(zTemp1),y
.018354	38		sec				sec
.018355	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018357	90 0e		bcc $018367			bcc 	_TIM_GHCFail
.018359	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.01835b	90 0b		bcc $018368			bcc 	_TIM_GHCExit
.01835d	c9 11		cmp #$11			cmp 	#65-48						; < A
.01835f	90 06		bcc $018367			bcc		_TIM_GHCFail
.018361	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018363	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018365	90 01		bcc $018368			bcc		_TIM_GHCExit
.018367					_TIM_GHCFail:
.018367	38		sec				sec
.018368					_TIM_GHCExit:
.018368	60		rts				rts
.018369					TIM_BreakVector:
.018369	da		phx				phx									; save X/A on stack
.01836a	48		pha				pha
.01836b	ba		tsx				tsx 								; X points to S
.01836c	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01836f	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.018371	d0 03		bne $018376			bne 	_TIMBreak					; if set, it's BRK
.018373	68		pla				pla 								; abandon routine.
.018374	fa		plx				plx
.018375	40		rti				rti
.018376					_TIMBreak:
.018376	68		pla				pla 								; save A X Y and maybe Z
.018377	8d c2 03	sta $03c2			sta 	TIM_A
.01837a	fa		plx				plx
.01837b	8e c3 03	stx $03c3			stx 	TIM_X
.01837e	8c c4 03	sty $03c4			sty 	TIM_Y
.018381	68		pla				pla 								; get Status Register
.018382	8d c1 03	sta $03c1			sta 	TIM_SR
.018385	68		pla				pla
.018386	8d be 03	sta $03be			sta 	TIM_PC+1 					; save calling address
.018389	68		pla				pla
.01838a	8d bd 03	sta $03bd			sta 	TIM_PC 						; high byte
.01838d	ad be 03	lda $03be			lda 	TIM_PC+1 					; dec PC to point right.
.018390	d0 03		bne $018395			bne 	_TIMDecrement 				; brk bumps it.
.018392	ce bd 03	dec $03bd			dec 	TIM_PC
.018395					_TIMDecrement:
.018395	ce be 03	dec $03be			dec 	TIM_PC+1
.018398	ba		tsx				tsx 								; and copy SP
.018399	8e c6 03	stx $03c6			stx 	TIM_SP
.01839c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.01839e	9a		txs				txs
.01839f	4c 7e 82	jmp $01827e			jmp 	TIM_Start 					; and start up TIM monitor.
.0183a2					TIM_UpdateRegisters:
.0183a2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; PC
.0183a5	b0 28		bcs $0183cf			bcs 	_TIMURFail
.0183a7	a5 14		lda $14				lda 	zTemp3
.0183a9	8d be 03	sta $03be			sta 	Tim_PC+1
.0183ac	a5 15		lda $15				lda 	zTemp3+1
.0183ae	8d bd 03	sta $03bd			sta 	Tim_PC
.0183b1	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; ignore IRQ
.0183b4	b0 19		bcs $0183cf			bcs 	_TIMURFail
.0183b6	a2 00		ldx #$00			ldx 	#0
.0183b8					_TIM_URLoop:
.0183b8	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183ba	d0 01		bne $0183bd			bne 	_TIM_1
.0183bc	e8		inx				inx
.0183bd					_TIM_1:
.0183bd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; registers
.0183c0	b0 0d		bcs $0183cf			bcs 	_TIMURFail
.0183c2	a5 14		lda $14				lda 	zTemp3
.0183c4	9d c1 03	sta $03c1,x			sta 	Tim_SR,x
.0183c7	e8		inx				inx
.0183c8	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183ca	d0 ec		bne $0183b8			bne 	_TIM_URLoop
.0183cc	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand
.0183cf					_TIMURFail:
.0183cf	4c ea 81	jmp $0181ea			jmp 	TIM_Error
.0183d2					TIM_LoadMemory:
.0183d2	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; target address => zTemp2
.0183d5	a5 14		lda $14				lda 	zTemp3
.0183d7	85 12		sta $12				sta 	zTemp2
.0183d9	a5 15		lda $15				lda 	zTemp3+1
.0183db	85 13		sta $13				sta 	zTemp2+1
.0183dd					_TIM_LMLoop:
.0183dd	20 1e 83	jsr $01831e			jsr 	TIM_GetHex 					; next byte ?
.0183e0	b0 0e		bcs $0183f0			bcs 	_TIMLMDone 					; no more
.0183e2	a2 00		ldx #$00			ldx 	#0							; write out.
.0183e4	a5 14		lda $14				lda 	zTemp3
.0183e6	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183e8	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183ea	d0 f1		bne $0183dd			bne 	_TIM_LMLoop
.0183ec	e6 13		inc $13				inc 	zTemp2+1
.0183ee	80 ed		bra $0183dd			bra 	_TIM_LMLoop
.0183f0					_TIMLMDone:
.0183f0	4c f1 81	jmp $0181f1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183f3					StructureSearchSingle:
.0183f3	a2 00		ldx #$00			ldx 	#0
.0183f5					StructureSearchDouble:
.0183f5	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.0183f7	86 11		stx $11				stx 	zTemp1+1
.0183f9	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.0183fb	85 12		sta $12				sta 	zTemp2
.0183fd	80 18		bra $018417			bra 	_SSWLoop 					; jump in, start scanning from here.
.0183ff					_SSWNextLine:
.0183ff	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018401	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018403	18		clc				clc
.018404	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018406	85 16		sta $16				sta 	zCodePtr
.018408	90 02		bcc $01840c			bcc 	_SNLNoCarry
.01840a	e6 17		inc $17				inc 	zCodePtr+1
.01840c					_SNLNoCarry:
.01840c	a0 00		ldy #$00			ldy 	#0
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018410	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.018412	f0 54		beq $018468			beq 	_SSWFail
.018414	c8		iny				iny
.018415	c8		iny				iny
.018416					_SSWNextSimple:
.018416	c8		iny				iny
.018417					_SSWLoop:
.018417	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018419	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.01841b	f0 e2		beq $0183ff			beq 	_SSWNextLine 				; if so, then next line
.01841d	10 f7		bpl $018416			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01841f	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.018421	d0 08		bne $01842b			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018423	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018425	f0 2d		beq $018454			beq 	_SSWFound 					; so exit.
.018427	c5 11		cmp $11				cmp 	zTemp1+1
.018429	f0 29		beq $018454			beq 	_SSWFound
.01842b					_SSWCheckUpDown:
.01842b	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01842d	90 10		bcc $01843f			bcc 	_SSWNext
.01842f	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.018431	90 08		bcc $01843b			bcc 	_SSWPlus
.018433	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018435	b0 08		bcs $01843f			bcs 	_SSWNext
.018437	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018439	c6 12		dec $12				dec 	zTemp2
.01843b					_SSWPlus:
.01843b	e6 12		inc $12				inc 	zTemp2
.01843d	30 16		bmi $018455			bmi 	_SSWUnder					; error if driven -ve
.01843f					_SSWNext:
.01843f	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018441	c8		iny				iny 								; skip
.018442	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018444	90 0c		bcc $018452			bcc 	_SEDone 					; so just skip over it.
.018446	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018448	90 07		bcc $018451			bcc 	_SEDouble
.01844a	98		tya				tya 								; this is Y + 1
.01844b	18		clc				clc
.01844c	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01844e	a8		tay				tay 								; back in Y.
.01844f	88		dey				dey 								; fix up, one for the +1, one for the iny
.018450	88		dey				dey
.018451					_SEDouble:
.018451	c8		iny				iny
.018452					_SEDone:
.018452	80 c3		bra $018417			bra 	_SSWLoop
.018454					_SSWFound:
.018454	60		rts				rts
.018455					_SSWUnder:
.018455	20 4e 85	jsr $01854e			jsr ERR_Handler
>018458	53 74 72 75 63 74 75 72			.text "Structure order",0
>018460	65 20 6f 72 64 65 72 00
.018468					_SSWFail:
.018468	20 4e 85	jsr $01854e			jsr ERR_Handler
>01846b	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018473	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.018480					StackReset:
.018480	48		pha				pha
.018481	5a		phy				phy
.018482	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018484	85 26		sta $26				sta 	zBasicSP
.018486	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018488	85 27		sta $27				sta 	zBasicSP+1
.01848a	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.01848c	98		tya				tya 								; be a legal token.
.01848d	91 26		sta ($26),y			sta 	(zBasicSP),y
.01848f	7a		ply				ply
.018490	68		pla				pla
.018491	60		rts				rts
.018492					StackPushFrame:
.018492	48		pha				pha
.018493	5a		phy				phy
.018494	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.018495	48		pha				pha 								; save it.
.018496	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.018498	18		clc				clc 								; add to Basic Stack
.018499	65 26		adc $26				adc 	zBasicSP
.01849b	85 26		sta $26				sta 	zBasicSP
.01849d	90 02		bcc $0184a1			bcc 	_SPFNoBump
.01849f	e6 27		inc $27				inc 	zBasicSP+1
.0184a1					_SPFNoBump:
.0184a1	a0 00		ldy #$00			ldy 	#0
.0184a3	68		pla				pla
.0184a4	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184a6	7a		ply				ply
.0184a7	68		pla				pla
.0184a8	60		rts				rts
.0184a9					StackPopFrame:
.0184a9	48		pha				pha
.0184aa	5a		phy				phy
.0184ab	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184ad	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184af	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184b1	d0 12		bne $0184c5			bne 	SPFError 					; mixed structures
.0184b3	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184b5	29 0f		and #$0f			and 	#$0F
.0184b7	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184b9	38		sec				sec
.0184ba	65 26		adc $26				adc 	zBasicSP
.0184bc	85 26		sta $26				sta 	zBasicSP
.0184be	b0 02		bcs $0184c2			bcs 	_SPFNoBump
.0184c0	c6 27		dec $27				dec 	zBasicSP+1
.0184c2					_SPFNoBump:
.0184c2	7a		ply				ply
.0184c3	68		pla				pla
.0184c4	60		rts				rts
.0184c5					SPFError:
.0184c5	20 4e 85	jsr $01854e			jsr ERR_Handler
>0184c8	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184d0	72 75 63 74 75 72 65 73 00
.0184d9					StackSavePosition:
.0184d9	98		tya				tya
.0184da	5a		phy				phy
.0184db	a0 05		ldy #$05			ldy 	#5
.0184dd	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184df	a0 01		ldy #$01			ldy 	#1
.0184e1	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.0184e3	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184e5	c8		iny				iny
.0184e6	a5 17		lda $17				lda 	zCodePtr+1
.0184e8	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ea	c8		iny				iny
.0184eb	a5 18		lda $18				lda 	zCodePtr+2
.0184ed	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ef	c8		iny				iny
.0184f0	a5 19		lda $19				lda 	zCodePtr+3
.0184f2	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f4	7a		ply				ply
.0184f5	60		rts				rts
.0184f6					StackRestorePosition:
.0184f6	5a		phy				phy
.0184f7	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.0184f9	b1 26		lda ($26),y			lda 	(zBasicSP),y
.0184fb	85 16		sta $16				sta 	zCodePtr+0
.0184fd	c8		iny				iny
.0184fe	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018500	85 17		sta $17				sta 	zCodePtr+1
.018502	c8		iny				iny
.018503	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018505	85 18		sta $18				sta 	zCodePtr+2
.018507	c8		iny				iny
.018508	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01850a	85 19		sta $19				sta 	zCodePtr+3
.01850c	c8		iny				iny
.01850d	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01850f	7a		ply				ply 								; restore Y
.018510	a8		tay				tay
.018511	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.018512					CharPrint:
.018512	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018515					CharGet:
.018515	4c d9 81	jmp $0181d9			jmp 	IF_GetKey
.018518					CheckBreak:
.018518	4c d4 81	jmp $0181d4			jmp 	IF_CheckBreak
.01851b					CharGetPosition:
.01851b	ad 00 05	lda $0500			lda 	IFT_XCursor
.01851e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.01851f					SyntaxError:
.01851f	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>018522	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01852a	72 72 6f 72 00
.01852f					TypeError:
.01852f	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>018532	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01853a	70 65 00
.01853d					BadParamError:
.01853d	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>018540	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018548	6d 65 74 65 72 00
.01854e					ERR_Handler:
.01854e	a0 00		ldy #$00			ldy 	#0
.018550	c8		iny				iny
.018551	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018553	85 80		sta $80				sta 	XS_Mantissa
.018555	c8		iny				iny
.018556	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018558	85 81		sta $81				sta 	XS_Mantissa+1
.01855a	fa		plx				plx 								; address in XY
.01855b	7a		ply				ply
.01855c	e8		inx				inx 								; bump, because of RTS/JSR address -1
.01855d	d0 01		bne $018560			bne 	_EHNoSkip
.01855f	c8		iny				iny
.018560					_EHNoSkip:
.018560	20 7f 85	jsr $01857f			jsr 	PrintROMMessage 			; print message from ROM.
.018563	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.018565	05 81		ora $81				ora 	XS_Mantissa+1
.018567	f0 0c		beq $018575			beq 	_EHNoLine
.018569	a2 7a		ldx #$7a			ldx 	#_EHAt & $FF 				; print " at "
.01856b	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.01856d	20 7f 85	jsr $01857f			jsr 	PrintROMMessage
.018570	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018572	20 94 85	jsr $018594			jsr 	Print16BitInteger
.018575					_EHNoLine:
.018575	80 fe		bra $018575			bra 	_EHNoLine
.018577	4c 07 88	jmp $018807			jmp 	WarmStart
>01857a	20 61 74 20 00			_EHAt:	.text 	" at ",0
.01857f					PrintROMMessage:
.01857f	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018581	84 1b		sty $1b				sty 	zLTemp1+1
.018583	4b		phk				phk
.018584	68		pla				pla
.018585	85 1c		sta $1c				sta 	ZLTemp1+2
.018587	a0 00		ldy #$00			ldy 	#0
.018589					_PRMLoop:
.018589	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.01858b	f0 06		beq $018593			beq		_PRMExit
.01858d	c8		iny				iny
.01858e	20 12 85	jsr $018512			jsr 	CharPrint
.018591	80 f6		bra $018589			bra 	_PRMLoop
.018593					_PRMExit:
.018593	60		rts				rts
.018594					Print16BitInteger:
.018594	a9 00		lda #$00			lda 	#0 							; make 32 bit
.018596	85 82		sta $82				sta 	XS_Mantissa+2
.018598	85 83		sta $83				sta 	XS_Mantissa+3
.01859a					Print32BitInteger:
.01859a	a9 00		lda #$00			lda 	#0
.01859c	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.01859f	aa		tax				tax 								; convert bottom level.
.0185a0	20 ed 9c	jsr $019ced			jsr 	INTToString 				; make string
.0185a3	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185a5	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185a8	f0 06		beq $0185b0			beq 	_P1Exit
.0185aa	20 12 85	jsr $018512			jsr 	CharPrint
.0185ad	e8		inx				inx
.0185ae	80 f5		bra $0185a5			bra 	_P1Loop
.0185b0	8a		txa		_P1Exit:txa 								; return chars printed.
.0185b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185b2					VectorTable:
>0185b2	45 91					.word BinaryOp_And         & $FFFF ; $80 and
>0185b4	61 91					.word BinaryOp_Or          & $FFFF ; $81 or
>0185b6	7d 91					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185b8	7d 91					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185ba	b4 91					.word Binary_Equal         & $FFFF ; $84 =
>0185bc	ce 91					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185be	d7 91					.word Binary_Less          & $FFFF ; $86 <
>0185c0	e0 91					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185c2	f2 91					.word Binary_Greater       & $FFFF ; $88 >
>0185c4	e9 91					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185c6	77 92					.word BinaryOp_Add         & $FFFF ; $8a +
>0185c8	93 92					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185ca	a4 92					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185cc	b5 92					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185ce	70 86					.word NotImplemented       & $FFFF ; $8e ^
>0185d0	d8 8a					.word Command_IF           & $FFFF ; $8f if
>0185d2	41 8f					.word Command_WHILE        & $FFFF ; $90 while
>0185d4	69 8f					.word Command_REPEAT       & $FFFF ; $91 repeat
>0185d6	69 89					.word Command_FOR          & $FFFF ; $92 for
>0185d8	70 86					.word NotImplemented       & $FFFF ; $93 then
>0185da	35 8b					.word Command_ENDIF        & $FFFF ; $94 endif
>0185dc	5e 8f					.word Command_WEND         & $FFFF ; $95 wend
>0185de	72 8f					.word Command_UNTIL        & $FFFF ; $96 until
>0185e0	e6 89					.word Command_NEXT         & $FFFF ; $97 next
>0185e2	70 86					.word NotImplemented       & $FFFF ; $98 not
>0185e4	70 86					.word NotImplemented       & $FFFF ; $99 fn(
>0185e6	ba 93					.word Unary_Abs            & $FFFF ; $9a abs(
>0185e8	07 95					.word Unary_Asc            & $FFFF ; $9b asc(
>0185ea	19 a4					.word Unary_Int            & $FFFF ; $9c int(
>0185ec	d4 93					.word Unary_Peek           & $FFFF ; $9d peek(
>0185ee	9a a3					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0185f0	47 94					.word Unary_Usr            & $FFFF ; $9f usr(
>0185f2	46 95					.word Unary_Left           & $FFFF ; $a0 left$(
>0185f4	5b 95					.word Unary_Right          & $FFFF ; $a1 right$(
>0185f6	2d 95					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0185f8	a4 96					.word Unary_Spc            & $FFFF ; $a3 spc(
>0185fa	d5 94					.word Unary_Str            & $FFFF ; $a4 str$(
>0185fc	69 94					.word Unary_Val            & $FFFF ; $a5 val(
>0185fe	1e 95					.word Unary_Len            & $FFFF ; $a6 len(
>018600	d3 95					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018602	70 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018604	70 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018606	70 86					.word NotImplemented       & $FFFF ; $aa tan(
>018608	70 86					.word NotImplemented       & $FFFF ; $ab atn(
>01860a	70 86					.word NotImplemented       & $FFFF ; $ac exp(
>01860c	70 86					.word NotImplemented       & $FFFF ; $ad log(
>01860e	70 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018610	29 96					.word Unary_Dec            & $FFFF ; $af dec(
>018612	d8 93					.word Unary_Deek           & $FFFF ; $b0 deek(
>018614	dc 93					.word Unary_Leek           & $FFFF ; $b1 leek(
>018616	14 94					.word Unary_Mod            & $FFFF ; $b2 mod(
>018618	74 93					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01861a	86 96					.word Unary_Chr            & $FFFF ; $b4 chr$(
>01861c	08 94					.word Unary_Pos            & $FFFF ; $b5 pos(
>01861e	c7 96					.word Unary_Tab            & $FFFF ; $b6 tab(
>018620	70 86					.word NotImplemented       & $FFFF ; $b7 $
>018622	70 86					.word NotImplemented       & $FFFF ; $b8 $(
>018624	70 86					.word NotImplemented       & $FFFF ; $b9 #
>018626	70 86					.word NotImplemented       & $FFFF ; $ba #(
>018628	70 86					.word NotImplemented       & $FFFF ; $bb %
>01862a	70 86					.word NotImplemented       & $FFFF ; $bc %(
>01862c	70 86					.word NotImplemented       & $FFFF ; $bd (
>01862e	70 86					.word NotImplemented       & $FFFF ; $be )
>018630	70 86					.word NotImplemented       & $FFFF ; $bf ,
>018632	68 89					.word Command_COLON        & $FFFF ; $c0 :
>018634	70 86					.word NotImplemented       & $FFFF ; $c1 ;
>018636	70 86					.word NotImplemented       & $FFFF ; $c2 def
>018638	25 8f					.word Command_CLR          & $FFFF ; $c3 clr
>01863a	39 8f					.word Command_STOP         & $FFFF ; $c4 stop
>01863c	70 86					.word NotImplemented       & $FFFF ; $c5 data
>01863e	70 86					.word NotImplemented       & $FFFF ; $c6 read
>018640	14 88					.word Command_DIM          & $FFFF ; $c7 dim
>018642	70 86					.word NotImplemented       & $FFFF ; $c8 to
>018644	70 86					.word NotImplemented       & $FFFF ; $c9 step
>018646	51 8e					.word Command_GOSUB        & $FFFF ; $ca gosub
>018648	61 8e					.word Command_RETURN       & $FFFF ; $cb return
>01864a	49 8e					.word Command_GOTO         & $FFFF ; $cc goto
>01864c	d4 8a					.word Command_END          & $FFFF ; $cd end
>01864e	70 86					.word NotImplemented       & $FFFF ; $ce input
>018650	99 8a					.word Command_LET          & $FFFF ; $cf let
>018652	3b 8b					.word Command_LIST         & $FFFF ; $d0 list
>018654	f2 8d					.word Command_NEW          & $FFFF ; $d1 new
>018656	0e 8e					.word Command_OLD          & $FFFF ; $d2 old
>018658	6a 8e					.word Command_ON           & $FFFF ; $d3 on
>01865a	70 86					.word NotImplemented       & $FFFF ; $d4 restore
>01865c	c1 8d					.word Command_POKE         & $FFFF ; $d5 poke
>01865e	2f 8d					.word Command_PRINT        & $FFFF ; $d6 print
>018660	da 88					.word Command_RUN          & $FFFF ; $d7 run
>018662	9c 88					.word Command_WAIT         & $FFFF ; $d8 wait
>018664	ba 8a					.word Command_SYS          & $FFFF ; $d9 sys
>018666	c5 8d					.word Command_DOKE         & $FFFF ; $da doke
>018668	c9 8d					.word Command_LOKE         & $FFFF ; $db loke
>01866a	a9 8d					.word Command_ASSERT       & $FFFF ; $dc assert
>01866c	70 86					.word NotImplemented       & $FFFF ; $dd get
>01866e	2f 8b					.word Command_ELSE         & $FFFF ; $de else
.018670					NotImplemented:
.018670	20 4e 85	jsr $01854e			jsr ERR_Handler
>018673	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>01867b	65 6d 65 6e 74 65 64 00
.018683					BinaryPrecedence:
>018683	01					.byte 1    ; $80 and
>018684	01					.byte 1    ; $81 or
>018685	01					.byte 1    ; $82 xor
>018686	01					.byte 1    ; $83 eor
>018687	02					.byte 2    ; $84 =
>018688	02					.byte 2    ; $85 <>
>018689	02					.byte 2    ; $86 <
>01868a	02					.byte 2    ; $87 <=
>01868b	02					.byte 2    ; $88 >
>01868c	02					.byte 2    ; $89 >=
>01868d	03					.byte 3    ; $8a +
>01868e	03					.byte 3    ; $8b -
>01868f	04					.byte 4    ; $8c *
>018690	04					.byte 4    ; $8d /
>018691	05					.byte 5    ; $8e ^
.018692					KeywordText:
>018692	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>018695	4f d2					.byte $4f,$d2                          ; $81 or
>018697	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>01869a	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>01869d	bd					.byte $bd                              ; $84 =
>01869e	3c be					.byte $3c,$be                          ; $85 <>
>0186a0	bc					.byte $bc                              ; $86 <
>0186a1	3c bd					.byte $3c,$bd                          ; $87 <=
>0186a3	be					.byte $be                              ; $88 >
>0186a4	3e bd					.byte $3e,$bd                          ; $89 >=
>0186a6	ab					.byte $ab                              ; $8a +
>0186a7	ad					.byte $ad                              ; $8b -
>0186a8	aa					.byte $aa                              ; $8c *
>0186a9	af					.byte $af                              ; $8d /
>0186aa	de					.byte $de                              ; $8e ^
>0186ab	49 c6					.byte $49,$c6                          ; $8f if
>0186ad	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186b2	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186b8	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186bb	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186bf	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186c4	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186c8	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186cd	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186d1	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186d4	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0186d7	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0186db	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0186df	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0186e3	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0186e8	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0186ec	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0186f0	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0186f6	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0186fd	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018702	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018706	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>01870b	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01870f	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018713	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018718	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>01871c	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018720	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018724	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018728	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>01872c	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018730	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018734	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018738	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01873d	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018742	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018746	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01874a	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01874f	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018753	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018757	a4					.byte $a4                              ; $b7 $
>018758	24 a8					.byte $24,$a8                          ; $b8 $(
>01875a	a3					.byte $a3                              ; $b9 #
>01875b	23 a8					.byte $23,$a8                          ; $ba #(
>01875d	a5					.byte $a5                              ; $bb %
>01875e	25 a8					.byte $25,$a8                          ; $bc %(
>018760	a8					.byte $a8                              ; $bd (
>018761	a9					.byte $a9                              ; $be )
>018762	ac					.byte $ac                              ; $bf ,
>018763	ba					.byte $ba                              ; $c0 :
>018764	bb					.byte $bb                              ; $c1 ;
>018765	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018768	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>01876b	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>01876f	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>018773	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018777	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>01877a	54 cf					.byte $54,$cf                          ; $c8 to
>01877c	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018780	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>018785	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>01878b	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>01878f	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>018792	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>018797	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>01879a	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>01879e	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187a1	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187a4	4f ce					.byte $4f,$ce                          ; $d3 on
>0187a6	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187ad	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187b1	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187b6	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187b9	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187bd	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187c0	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187c4	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187c8	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187ce	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187d1	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>0187d5	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.0187d6					BASIC_Start:
.0187d6	20 9b 81	jsr $01819b			jsr 	IF_Reset 					; set up and clear screen.
.0187d9	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0187dc	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0187de	8d 10 03	sta $0310			sta 	LocalVector
.0187e1	8d 0c 03	sta $030c			sta 	UserVector
.0187e4	a9 57		lda #$57			lda 	#USRDefault & $FF 			; reset USR vector
.0187e6	8d 0d 03	sta $030d			sta 	UserVector+1
.0187e9	a9 94		lda #$94			lda 	#(USRDefault >> 8) & $FF
.0187eb	8d 0e 03	sta $030e			sta 	UserVector+2
.0187ee	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0187f0	8d 0f 03	sta $030f			sta 	UserVector+3
.0187f3	20 0e 97	jsr $01970e			jsr 	UpdateProgramEnd 			; update the program end.
.0187f6	20 25 8f	jsr $018f25			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0187f9	c2 30		rep #$30			rep 	#$30
.0187fb	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0187fe	1b		tcs				tcs
.0187ff	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018802	e2 30		sep #$30			sep 	#$30
.018804	4c da 88	jmp $0188da			jmp 	COMMAND_Run
.018807					WarmStart:
.018807	c2 30		rep #$30			rep 	#$30
.018809	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01880c	1b		tcs				tcs
.01880d	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018810	e2 30		sep #$30			sep 	#$30
.018812	80 f3		bra $018807			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018814					Command_DIM:
.018814	98		tya				tya
.018815	48		pha				pha 								; push on stack.
.018816	20 76 98	jsr $019876			jsr 	VariableExtract 			; get the identifier
.018819	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.01881c	29 01		and #$01			and 	#1
.01881e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018820	d0 6c		bne $01888e			bne 	_CDIError
.018822	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018824	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018827					_CDIGetDimension:
.018827	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01882a	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.01882c	f0 60		beq $01888e			beq 	_CDIError
.01882e	20 26 91	jsr $019126			jsr 	EvaluateInteger 			; evaluate an index size
.018831	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018833	29 80		and #$80			and 	#$80
.018835	05 82		ora $82				ora 	XS_Mantissa+2
.018837	05 83		ora $83				ora 	XS_Mantissa+3
.018839	d0 53		bne $01888e			bne 	_CDIError
.01883b	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.01883e	18		clc				clc 								; add 1 - max index => size.
.01883f	a5 80		lda $80				lda 	XS_Mantissa+0
.018841	69 01		adc #$01			adc 	#1
.018843	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.018846	a5 81		lda $81				lda 	XS_Mantissa+1
.018848	69 00		adc #$00			adc 	#0
.01884a	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.01884d	30 3f		bmi $01888e			bmi 	_CDIError 					; could be dim a(32767)
.01884f	e8		inx				inx 								; bump index.
.018850	e8		inx				inx
.018851	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.018854	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018856	c8		iny				iny
.018857	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018859	f0 cc		beq $018827			beq 	_CDIGetDimension
.01885b	88		dey				dey
.01885c	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; closing ) present ?
.01885f	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.018862	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018864	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.018867					_CDICopy:
.018867	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.01886a	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.01886d	ca		dex				dex
.01886e	10 f7		bpl $018867			bpl 	_CDICopy
.018870	68		pla				pla									; position of array identifier
.018871	85 10		sta $10				sta 	zTemp1
.018873	98		tya				tya
.018874	48		pha				pha
.018875	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018877	a8		tay				tay
.018878	20 76 98	jsr $019876			jsr 	VariableExtract 			; get the identifier
.01887b	20 0f 9b	jsr $019b0f			jsr 	VariableLocate 				; check if it exists already.
.01887e	b0 0e		bcs $01888e			bcs 	_CDIError
.018880	20 02 99	jsr $019902			jsr 	VariableCreate 				; create it using the current ArrayDef
.018883	68		pla				pla 								; restore code position
.018884	a8		tay				tay
.018885	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018887	c8		iny				iny
.018888	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.01888a	f0 88		beq $018814			beq 	Command_DIM
.01888c	88		dey				dey
.01888d	60		rts				rts
.01888e					_CDIError:
.01888e	20 4e 85	jsr $01854e			jsr ERR_Handler
>018891	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.018899					_CDISyntax:
.018899	4c 1f 85	jmp $01851f			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.01889c					Command_WAIT:
.01889c	20 26 91	jsr $019126			jsr		EvaluateInteger 			; address
.01889f	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188a1	20 72 97	jsr $019772			jsr 	CheckNextComma
.0188a4	20 28 91	jsr $019128			jsr 	EvaluateIntegerX
.0188a7	a9 00		lda #$00			lda 	#0							; set default xor.
.0188a9	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188ab	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188ad	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188af	d0 06		bne $0188b7			bne 	_CWAXorDefault
.0188b1	c8		iny				iny
.0188b2	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188b4	20 28 91	jsr $019128			jsr 	EvaluateIntegerX
.0188b7					_CWAXorDefault:
.0188b7	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188b9	85 1a		sta $1a				sta 	zLTemp1
.0188bb	a5 81		lda $81				lda 	XS_Mantissa+1
.0188bd	85 1b		sta $1b				sta 	zLTemp1+1
.0188bf	a5 82		lda $82				lda 	XS_Mantissa+2
.0188c1	85 1c		sta $1c				sta 	zLTemp1+2
.0188c3					_CWAWaitLoop:
.0188c3	20 18 85	jsr $018518			jsr 	CheckBreak 					; exit on break.
.0188c6	c9 00		cmp #$00			cmp 	#0
.0188c8	d0 0f		bne $0188d9			bne 	_CWAWaitExit
.0188ca	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188cc	a2 00		ldx #$00			ldx 	#0
.0188ce	5a		phy				phy 								; this is the same routine as PEEK.
.0188cf	20 ec 96	jsr $0196ec			jsr 	MemRead
.0188d2	7a		ply				ply
.0188d3	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.0188d5	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.0188d7	f0 ea		beq $0188c3			beq 	_CWAWaitLoop
.0188d9					_CWAWaitExit:
.0188d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0188da					Command_RUN:
.0188da	20 25 8f	jsr $018f25			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0188dd	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188df	85 16		sta $16				sta 	zCodePtr+0
.0188e1	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188e3	85 17		sta $17				sta 	zCodePtr+1
.0188e5	a9 00		lda #$00			lda 	#0
.0188e7	85 18		sta $18				sta 	zCodePtr+2
.0188e9	85 19		sta $19				sta 	zCodePtr+3
.0188eb	a0 03		ldy #$03			ldy 	#3
.0188ed					RUN_NewLine:
.0188ed	a0 00		ldy #$00			ldy 	#0
.0188ef	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188f1	c8		iny				iny
.0188f2	c8		iny				iny
.0188f3	c8		iny				iny
.0188f4	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0188f6	d0 16		bne $01890e			bne 	RUN_NextCommand
.0188f8	4c d4 8a	jmp $018ad4			jmp 	Command_END 				; go do the command code.
.0188fb					RUN_Skip:
.0188fb	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0188fd	c8		iny				iny 								; skip
.0188fe	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018900	90 0c		bcc $01890e			bcc 	_SEDone 					; so just skip over it.
.018902	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018904	90 07		bcc $01890d			bcc 	_SEDouble
.018906	98		tya				tya 								; this is Y + 1
.018907	18		clc				clc
.018908	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01890a	a8		tay				tay 								; back in Y.
.01890b	88		dey				dey 								; fix up, one for the +1, one for the iny
.01890c	88		dey				dey
.01890d					_SEDouble:
.01890d	c8		iny				iny
.01890e					_SEDone:
.01890e					RUN_NextCommand:
.01890e	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018911	69 10		adc #$10			adc 	#16 						; one time in 16
.018913	8d a8 03	sta $03a8			sta 	BreakCount
.018916	90 0a		bcc $018922			bcc 	RUN_NoCheckBreak
.018918	20 18 85	jsr $018518			jsr 	CheckBreak 					; check for break
.01891b	c9 00		cmp #$00			cmp 	#0
.01891d	f0 03		beq $018922			beq 	RUN_NoCheckBreak
.01891f	4c 39 8f	jmp $018f39			jmp 	Command_STOP 				; stop on BREAK.
.018922					RUN_NoCheckBreak:
.018922	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018924	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018926	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018928	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.01892a	f0 cf		beq $0188fb			beq 	RUN_Skip
.01892c	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01892e	d0 0f		bne $01893f			bne 	RUN_Execute
.018930					RUN_NextLine:
.018930	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018932	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018934	18		clc				clc
.018935	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018937	85 16		sta $16				sta 	zCodePtr
.018939	90 02		bcc $01893d			bcc 	_SNLNoCarry
.01893b	e6 17		inc $17				inc 	zCodePtr+1
.01893d					_SNLNoCarry:
.01893d	80 ae		bra $0188ed			bra 	RUN_NewLine 				; go do the new line code
.01893f					RUN_Execute:
.01893f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.018941	b0 1e		bcs $018961			bcs 	RUN_Extension
.018943	c8		iny				iny
.018944	0a		asl a				asl 	a 							; double the character read.
.018945	90 14		bcc $01895b			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018947	aa		tax				tax 								; ready to look up.
.018948	bf b2 85 01	lda $0185b2,x			lda 	VectorTable,x 				; copy address into LocalVector
.01894c	8d 11 03	sta $0311			sta 	LocalVector+1
.01894f	bf b3 85 01	lda $0185b3,x			lda 	VectorTable+1,x
.018953	8d 12 03	sta $0312			sta 	LocalVector+2
.018956	20 73 90	jsr $019073			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018959	80 b3		bra $01890e			bra 	RUN_NextCommand 			; do the next command.
.01895b					RUN_Default:
.01895b	88		dey				dey
.01895c	20 99 8a	jsr $018a99			jsr 	Command_LET 				; and try LET.
.01895f	80 ad		bra $01890e			bra 	RUN_NextCommand
.018961					RUN_Extension:
.018961	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018963	f0 96		beq $0188fb			beq 	RUN_Skip 					; skip over it.
.018965	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.018968					Command_COLON:
.018968	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.018969					Command_FOR:
.018969	20 99 8a	jsr $018a99			jsr 	Command_LET 				; do the A = 99 bit
.01896c	a5 24		lda $24				lda 	zVarType 					; obviously has to be integer/real.
.01896e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018970	f0 71		beq $0189e3			beq 	_CFOError
.018972	48		pha				pha 								; save the variable type.
.018973	5a		phy				phy 								; save type/variable address.
.018974	a0 01		ldy #$01			ldy 	#1							; type at + 1
.018976	91 26		sta ($26),y			sta 	(zBasicSP),y
.018978	c8		iny				iny
.018979	a5 22		lda $22				lda 	zVarDataPtr 				; data low at +2
.01897b	91 26		sta ($26),y			sta 	(zBasicSP),y
.01897d	c8		iny				iny
.01897e	a5 23		lda $23				lda 	zVarDataPtr+1 				; data high at +3
.018980	91 26		sta ($26),y			sta 	(zBasicSP),y
.018982	7a		ply				ply
.018983	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.018985	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018988	a9 c8		lda #$c8			lda 	#token_TO
.01898a	20 53 97	jsr $019753			jsr 	CheckNextToken
.01898d	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.01898f	20 90 8f	jsr $018f90			jsr 	EvaluateExpression
.018992	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018994	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.018996	c9 c9		cmp #$c9			cmp 	#token_STEP
.018998	d0 06		bne $0189a0			bne 	_CFOStep1
.01899a	c8		iny				iny
.01899b	20 92 8f	jsr $018f92			jsr 	EvaluateExpressionX 		; get STEP value.
.01899e	80 0e		bra $0189ae			bra 	_CFOHaveStep
.0189a0					_CFOStep1:
.0189a0	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189a2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189a4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189a6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189a8	a9 01		lda #$01			lda 	#1
.0189aa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189ac	95 85		sta $85,x			sta 	XS_Type,x
.0189ae					_CFOHaveStep:
.0189ae	68		pla				pla 								; restore variable type
.0189af	a2 00		ldx #$00			ldx 	#0
.0189b1	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189b3	f0 0a		beq $0189bf			beq 	_CFOInteger
.0189b5	20 1a a1	jsr $01a11a			jsr 	FPUToFloat
.0189b8	a2 06		ldx #$06			ldx 	#6
.0189ba	20 1a a1	jsr $01a11a			jsr 	FPUToFloat
.0189bd	80 08		bra $0189c7			bra 	_CFOEndConv
.0189bf					_CFOInteger:
.0189bf	20 66 a1	jsr $01a166			jsr 	FPUToInteger
.0189c2	a2 06		ldx #$06			ldx 	#6
.0189c4	20 66 a1	jsr $01a166			jsr 	FPUToInteger
.0189c7					_CFOEndConv:
.0189c7	20 d9 84	jsr $0184d9			jsr 	StackSavePosition 			; save the loop position at 1-5
.0189ca	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.0189cc	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push the loop address frame.
.0189cf	5a		phy				phy
.0189d0	a0 00		ldy #$00			ldy 	#0
.0189d2					_CFOCopy:
.0189d2	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.0189d5	c8		iny				iny
.0189d6	91 26		sta ($26),y			sta 	(zBasicSP),y
.0189d8	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.0189da	d0 f6		bne $0189d2			bne 	_CFOCopy
.0189dc	7a		ply				ply
.0189dd	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.0189df	20 92 84	jsr $018492			jsr 	StackPushFrame
.0189e2	60		rts				rts
.0189e3					_CFOError:
.0189e3	4c 2f 85	jmp $01852f			jmp 	TypeError 					; wrong type.
.0189e6					Command_NEXT:
.0189e6	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.0189e8	85 23		sta $23				sta 	zVarDataPtr+1 				; this means we don't check
.0189ea	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189ec	c9 00		cmp #$00			cmp 	#0 							; EOL
.0189ee	f0 07		beq $0189f7			beq 	_CNextNoVariable
.0189f0	c9 40		cmp #$40			cmp 	#$40
.0189f2	b0 03		bcs $0189f7			bcs 	_CNextNoVariable
.0189f4	20 0b 98	jsr $01980b			jsr 	VariableFind
.0189f7					_CNextNoVariable:
.0189f7	a5 26		lda $26				lda 	zBasicSP 					; save on stack
.0189f9	48		pha				pha
.0189fa	a5 27		lda $27				lda 	zBasicSP+1
.0189fc	48		pha				pha
.0189fd	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.0189ff	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018a02	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a04	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018a07	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a09	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018a0c	a5 23		lda $23				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a0e	f0 11		beq $018a21			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a10	5a		phy				phy 								; check addresses match.
.018a11	a0 02		ldy #$02			ldy 	#2
.018a13	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a15	c5 22		cmp $22				cmp 	zVarDataPtr
.018a17	d0 69		bne $018a82			bne 	_CNextWrong
.018a19	c8		iny				iny
.018a1a	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a1c	c5 23		cmp $23				cmp 	zVarDataPtr+1
.018a1e	d0 62		bne $018a82			bne 	_CNextWrong
.018a20	7a		ply				ply
.018a21					_CNextGetTarget:
.018a21	5a		phy				phy
.018a22	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a24	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a26	85 24		sta $24				sta 	zVarType
.018a28	c8		iny				iny
.018a29	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a2b	85 22		sta $22				sta 	zVarDataPtr
.018a2d	c8		iny				iny
.018a2e	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a30	85 23		sta $23				sta 	zVarDataPtr+1
.018a32	a2 0c		ldx #$0c			ldx 	#12
.018a34	20 53 9b	jsr $019b53			jsr 	VariableGet 				; get that variable value into expr[2]
.018a37	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a39	a0 0b		ldy #$0b			ldy 	#11
.018a3b					_CNXCopy:
.018a3b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018a3d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a3f	e8		inx				inx
.018a40	c8		iny				iny
.018a41	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a43	d0 f6		bne $018a3b			bne 	_CNXCopy
.018a45	7a		ply				ply
.018a46	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a48	20 98 93	jsr $019398			jsr 	GetSignCurrent
.018a4b	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a4e	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a50	20 77 92	jsr $019277			jsr 	BinaryOp_Add
.018a53	20 a4 9b	jsr $019ba4			jsr 	VariableSet					; and write variable back.
.018a56	a2 00		ldx #$00			ldx 	#0
.018a58	20 fb 91	jsr $0191fb			jsr 	CompareValues
.018a5b	09 00		ora #$00			ora 	#0
.018a5d	f0 05		beq $018a64			beq 	_CNXAgain 					; if true, then do it again.
.018a5f	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a62	d0 0f		bne $018a73			bne 	_CNXLoopDone
.018a64					_CNXAgain:
.018a64	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018a66	20 92 84	jsr $018492			jsr 	StackPushFrame
.018a69	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018a6c	68		pla				pla
.018a6d	85 27		sta $27				sta 	zBasicSP+1
.018a6f	68		pla				pla
.018a70	85 26		sta $26				sta 	zBasicSP
.018a72					_CNXExit:
.018a72	60		rts				rts
.018a73					_CNXLoopDone:
.018a73	68		pla				pla
.018a74	68		pla				pla
.018a75	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a77	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018a79	d0 f7		bne $018a72			bne 	_CNXExit
.018a7b	c8		iny				iny
.018a7c	20 0b 98	jsr $01980b			jsr 	VariableFind 				; identify the variable
.018a7f	4c f7 89	jmp $0189f7			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018a82					_CNextWrong:
.018a82	20 4e 85	jsr $01854e			jsr ERR_Handler
>018a85	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018a8d	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018a99					Command_LET:
.018a99	20 0b 98	jsr $01980b			jsr 	VariableFind 				; get reference to one variable.
.018a9c	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018a9e	20 53 97	jsr $019753			jsr 	CheckNextToken
.018aa1	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018aa3	48		pha				pha
.018aa4	a5 23		lda $23				lda 	zVarDataPtr+1
.018aa6	48		pha				pha
.018aa7	a5 24		lda $24				lda 	zVarType
.018aa9	48		pha				pha
.018aaa	20 90 8f	jsr $018f90			jsr 	EvaluateExpression 			; evaluate the RHS.
.018aad	68		pla				pla 								; restore target variable information.
.018aae	85 24		sta $24				sta 	zVarType
.018ab0	68		pla				pla
.018ab1	85 23		sta $23				sta 	zVarDataPtr+1
.018ab3	68		pla				pla
.018ab4	85 22		sta $22				sta 	zVarDataPtr
.018ab6	20 a4 9b	jsr $019ba4			jsr 	VariableSet 				; set the value out.
.018ab9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018aba					Command_SYS:
.018aba	20 26 91	jsr $019126			jsr 	EvaluateInteger 			; address
.018abd	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018abf	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018ac2	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018ac4	8d 11 03	sta $0311			sta 	LocalVector+1
.018ac7	a5 82		lda $82				lda 	XS_Mantissa+2
.018ac9	8d 12 03	sta $0312			sta 	LocalVector+2
.018acc	22 d1 8a 01	jsl $018ad1			jsl 	_CSYLocalCall
.018ad0	60		rts				rts
.018ad1					_CSYLocalCall:
.018ad1	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018ad4					Command_END:
>018ad4	02						.byte 	2
.018ad5	4c 07 88	jmp $018807			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018ad8					Command_IF:
.018ad8	20 26 91	jsr $019126			jsr 	EvaluateInteger 			; check success.
.018adb	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018add	05 81		ora $81				ora 	XS_Mantissa+1
.018adf	05 82		ora $82				ora 	XS_Mantissa+2
.018ae1	05 83		ora $83				ora 	XS_Mantissa+3
.018ae3	aa		tax				tax 								; put into X.
.018ae4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ae6	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018ae8	d0 2c		bne $018b16			bne 	_FIFExtended
.018aea	c8		iny				iny
.018aeb	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018aed	f0 0b		beq $018afa			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018aef	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018af1	29 c0		and #$c0			and 	#$C0 						; is it a number
.018af3	c9 40		cmp #$40			cmp 	#$40
.018af5	d0 1e		bne $018b15			bne 	_FIFContinue 				; if not, do what ever follows.
.018af7	4c 49 8e	jmp $018e49			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018afa					_FIFEndOfLine:
.018afa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018afc	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018afe	f0 15		beq $018b15			beq 	_FIFContinue
.018b00	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018b02	c8		iny				iny 								; skip
.018b03	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b05	90 0c		bcc $018b13			bcc 	_SEDone 					; so just skip over it.
.018b07	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b09	90 07		bcc $018b12			bcc 	_SEDouble
.018b0b	98		tya				tya 								; this is Y + 1
.018b0c	18		clc				clc
.018b0d	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018b0f	a8		tay				tay 								; back in Y.
.018b10	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b11	88		dey				dey
.018b12					_SEDouble:
.018b12	c8		iny				iny
.018b13					_SEDone:
.018b13	80 e5		bra $018afa			bra 	_FIFEndOfLine
.018b15					_FIFContinue:
.018b15	60		rts				rts
.018b16					_FIFExtended:
.018b16	da		phx				phx 								; save result
.018b17	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018b19	20 92 84	jsr $018492			jsr 	StackPushFrame
.018b1c	68		pla				pla 								; restore result
.018b1d	f0 01		beq $018b20			beq 	_FIXSkip 					; if zero then it has failed.
.018b1f	60		rts				rts 								; test passed, so continue executing
.018b20					_FIXSkip:
.018b20	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018b22	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018b24	20 f5 83	jsr $0183f5			jsr 	StructureSearchDouble
.018b27	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b29	c8		iny				iny
.018b2a	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018b2c	f0 07		beq $018b35			beq 	Command_ENDIF
.018b2e	60		rts				rts
.018b2f					Command_ELSE:
.018b2f	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018b31	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018b34	c8		iny				iny
.018b35					Command_ENDIF:
.018b35	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018b37	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018b3a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018b3b					Command_LIST:
.018b3b	20 c8 8c	jsr $018cc8			jsr 	ListGetRange				; get any parameters
.018b3e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b40	85 16		sta $16				sta 	zCodePtr+0
.018b42	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b44	85 17		sta $17				sta 	zCodePtr+1
.018b46	a9 00		lda #$00			lda 	#0
.018b48	85 18		sta $18				sta 	zCodePtr+2
.018b4a	85 19		sta $19				sta 	zCodePtr+3
.018b4c	a0 03		ldy #$03			ldy 	#3
.018b4e	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018b50	8d bc 03	sta $03bc			sta 	LastListIndent
.018b53	8d bb 03	sta $03bb			sta 	ListIndent
.018b56					_CILLoop:
.018b56	a0 00		ldy #$00			ldy 	#0
.018b58	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b5a	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018b5c	f0 23		beq $018b81			beq 	_CILExit
.018b5e	20 18 85	jsr $018518			jsr 	CheckBreak 					; check break
.018b61	c9 00		cmp #$00			cmp 	#0
.018b63	d0 1c		bne $018b81			bne 	_CILExit
.018b65	20 0f 8d	jsr $018d0f			jsr 	ListCheckRange 				; check current line in range.
.018b68	b0 08		bcs $018b72			bcs		_CILNext
.018b6a	a0 00		ldy #$00			ldy 	#0
.018b6c	c8		iny				iny
.018b6d	c8		iny				iny
.018b6e	c8		iny				iny
.018b6f	20 84 8b	jsr $018b84			jsr 	ListLine 					; list one line.
.018b72					_CILNext:
.018b72	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b74	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018b76	18		clc				clc
.018b77	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018b79	85 16		sta $16				sta 	zCodePtr
.018b7b	90 02		bcc $018b7f			bcc 	_SNLNoCarry
.018b7d	e6 17		inc $17				inc 	zCodePtr+1
.018b7f					_SNLNoCarry:
.018b7f	80 d5		bra $018b56			bra 	_CILLoop
.018b81					_CILExit:
.018b81	4c 07 88	jmp $018807			jmp 	WarmStart
.018b84					ListLine:
.018b84	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018b87	8d bc 03	sta $03bc			sta 	LastListIndent
.018b8a					_LICountIndent:
.018b8a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b8c	c9 00		cmp #$00			cmp 	#0
.018b8e	f0 2f		beq $018bbf			beq 	_LIDoneIndent
.018b90	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018b92	90 16		bcc $018baa			bcc 	_LICINext
.018b94	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018b96	b0 12		bcs $018baa			bcs 	_LICINext
.018b98	ee bb 03	inc $03bb			inc 	ListIndent
.018b9b	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018b9d	90 0b		bcc $018baa			bcc 	_LICINext
.018b9f	ce bb 03	dec $03bb			dec 	ListIndent
.018ba2	ce bb 03	dec $03bb			dec 	ListIndent
.018ba5	10 03		bpl $018baa			bpl 	_LICINext
.018ba7	ee bb 03	inc $03bb			inc 	ListIndent
.018baa					_LICINext:
.018baa	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018bac	c8		iny				iny 								; skip
.018bad	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018baf	90 0c		bcc $018bbd			bcc 	_SEDone 					; so just skip over it.
.018bb1	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018bb3	90 07		bcc $018bbc			bcc 	_SEDouble
.018bb5	98		tya				tya 								; this is Y + 1
.018bb6	18		clc				clc
.018bb7	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018bb9	a8		tay				tay 								; back in Y.
.018bba	88		dey				dey 								; fix up, one for the +1, one for the iny
.018bbb	88		dey				dey
.018bbc					_SEDouble:
.018bbc	c8		iny				iny
.018bbd					_SEDone:
.018bbd	80 cb		bra $018b8a			bra 	_LICountIndent
.018bbf					_LIDoneIndent:
.018bbf	a0 00		ldy #$00			ldy 	#0
.018bc1	c8		iny				iny
.018bc2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bc4	85 80		sta $80				sta 	XS_Mantissa
.018bc6	c8		iny				iny
.018bc7	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bc9	85 81		sta $81				sta 	XS_Mantissa+1
.018bcb	20 94 85	jsr $018594			jsr 	Print16BitInteger 			; print integer.
.018bce	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018bd0	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018bd3	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018bd6	90 03		bcc $018bdb			bcc 	_LISmaller
.018bd8	ad bc 03	lda $03bc			lda 	LastListIndent
.018bdb					_LISmaller:
.018bdb	0a		asl a				asl 	a 							; double indent
.018bdc	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018bde	38		sec				sec
.018bdf	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018be1	aa		tax				tax 								; print spaces to column 6
.018be2					_LISpace:
.018be2	a9 20		lda #$20			lda 	#" "
.018be4	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018be7	e8		inx				inx
.018be8	e0 06		cpx #$06			cpx 	#6
.018bea	d0 f6		bne $018be2			bne 	_LISpace
.018bec					_LIDecode:
.018bec	c8		iny				iny
.018bed	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bef	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018bf1	f0 0f		beq $018c02			beq 	_LIExit
.018bf3	30 12		bmi $018c07			bmi 	_LIToken
.018bf5	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018bf7	b0 50		bcs $018c49			bcs 	_LIInteger
.018bf9	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018bfb	69 20		adc #$20			adc 	#$20
.018bfd	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC 				; print in LC
.018c00	80 ea		bra $018bec			bra 	_LIDecode
.018c02					_LIExit:
.018c02	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018c04	4c b8 8c	jmp $018cb8			jmp 	ListPrintLC
.018c07					_LIToken:
.018c07	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018c09	90 49		bcc $018c54			bcc		_LICommandToken
.018c0b	48		pha				pha 								; save in case end
.018c0c	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018c0e	c9 fe		cmp #$fe			cmp 	#$FE
.018c10	f0 17		beq $018c29			beq 	_LIPrint
.018c12	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018c14	c9 fd		cmp #$fd			cmp 	#$FD
.018c16	f0 11		beq $018c29			beq 	_LIPrint
.018c18	a9 52		lda #$52			lda 	#'R'						; must be REM
.018c1a	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018c1d	a9 45		lda #$45			lda 	#'E'
.018c1f	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018c22	a9 4d		lda #$4d			lda 	#'M'
.018c24	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018c27	a2 20		ldx #$20			ldx 	#' '
.018c29					_LIPrint:
.018c29	8a		txa				txa
.018c2a	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018c2d	c8		iny				iny
.018c2e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c30	aa		tax				tax 								; put in X
.018c31	ca		dex				dex
.018c32					_LILoop:
.018c32	ca		dex				dex 								; exit when count reached zero.
.018c33	f0 08		beq $018c3d			beq 	_LIEnd
.018c35	c8		iny				iny
.018c36	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c38	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018c3b	80 f5		bra $018c32			bra 	_LILoop
.018c3d	68		pla		_LIEnd:	pla 								; get A back
.018c3e	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018c40	d0 aa		bne $018bec			bne 	_LIDecode
.018c42	a9 22		lda #$22			lda 	#'"'
.018c44	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018c47	80 a3		bra $018bec			bra 	_LIDecode
.018c49					_LIInteger:
.018c49	a2 00		ldx #$00			ldx 	#0
.018c4b	20 98 90	jsr $019098			jsr 	EvaluateGetInteger 			; get an atom
.018c4e	88		dey				dey
.018c4f	20 9a 85	jsr $01859a			jsr 	Print32BitInteger 			; print integer.
.018c52	80 98		bra $018bec			bra 	_LIDecode
.018c54					_LICommandToken:
.018c54	5a		phy				phy 								; save Y
.018c55	48		pha				pha 								; save token
.018c56	a2 92		ldx #$92			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018c58	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018c5a	86 1a		stx $1a				stx 	zLTemp1
.018c5c	85 1b		sta $1b				sta 	zLTemp1+1
.018c5e	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018c60	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018c62	68		pla				pla 								; get token
.018c63	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018c65	f0 16		beq $018c7d			beq 	_LIFoundToken
.018c67	aa		tax				tax
.018c68					_LITokenLoop:
.018c68	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018c6a					_LIFindEnd:
.018c6a	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018c6c	c8		iny				iny
.018c6d	0a		asl a				asl 	a
.018c6e	90 fa		bcc $018c6a			bcc 	_LIFindEnd
.018c70	98		tya				tya 								; that is step to the next
.018c71	18		clc				clc 								; we don't bother bumping the 3rd byte
.018c72	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018c74	85 1a		sta $1a				sta 	zLTemp1
.018c76	90 02		bcc $018c7a			bcc 	_LINoBump
.018c78	e6 1b		inc $1b				inc 	zLTemp1+1
.018c7a					_LINoBump:
.018c7a	ca		dex				dex 								; no go round again.
.018c7b	d0 eb		bne $018c68			bne 	_LITokenLoop
.018c7d					_LIFoundToken:
.018c7d	a0 00		ldy #$00			ldy 	#0
.018c7f					_LIPrintToken:
.018c7f	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018c81	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018c83	d0 16		bne $018c9b			bne 	_LINoPrefixSpace
.018c85	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018c87	90 12		bcc $018c9b			bcc 	_LINoPrefixSpace
.018c89	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018c8b	b0 0e		bcs $018c9b			bcs 	_LINoPrefixSpace
.018c8d	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018c90	e0 20		cpx #$20			cpx 	#" "
.018c92	f0 07		beq $018c9b			beq 	_LINoPrefixSpace
.018c94	48		pha				pha
.018c95	a9 20		lda #$20			lda 	#" "
.018c97	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018c9a	68		pla				pla
.018c9b					_LINoPrefixSpace:
.018c9b	c8		iny				iny
.018c9c	48		pha				pha 								; save it
.018c9d	29 7f		and #$7f			and 	#$7F
.018c9f	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018ca2	68		pla				pla
.018ca3	10 da		bpl $018c7f			bpl 	_LIPrintToken 				; go back if not end
.018ca5	7a		ply				ply 								; restore Y
.018ca6	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018ca8	c9 41		cmp #$41			cmp 	#"A"
.018caa	90 09		bcc $018cb5			bcc 	_LINotLetter2
.018cac	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018cae	b0 05		bcs $018cb5			bcs 	_LINotLetter2
.018cb0	a9 20		lda #$20			lda 	#" " 						; add spacing
.018cb2	20 b8 8c	jsr $018cb8			jsr 	ListPrintLC
.018cb5					_LINotLetter2:
.018cb5	4c ec 8b	jmp $018bec			jmp 	_LIDecode
.018cb8					ListPrintLC:
.018cb8	8d ba 03	sta $03ba			sta 	LastPrinted
.018cbb	c9 41		cmp #$41			cmp 	#"A"
.018cbd	90 06		bcc $018cc5			bcc 	_LPLC0
.018cbf	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018cc1	b0 02		bcs $018cc5			bcs 	_LPLC0
.018cc3	69 20		adc #$20			adc 	#$20
.018cc5	4c 12 85	jmp $018512	_LPLC0:	jmp 	CharPrint
.018cc8					ListGetRange:
.018cc8	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018cca					_LGRClear:
.018cca	a9 00		lda #$00			lda 	#0
.018ccc	95 80		sta $80,x			sta 	XS_Mantissa,x
.018cce	ca		dex				dex
.018ccf	10 f9		bpl $018cca			bpl 	_LGRClear
.018cd1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cd3	c9 00		cmp #$00			cmp 	#0 							; nothing
.018cd5	f0 21		beq $018cf8			beq 	_LGRBlank
.018cd7	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018cd9	f0 1d		beq $018cf8			beq 	_LGRBlank
.018cdb	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018cdd	f0 18		beq $018cf7			beq 	_LGREnd 					; then it's LIST ,x
.018cdf	20 26 91	jsr $019126			jsr 	EvaluateInteger 			; get the first number into bottom
.018ce2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ce4	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ce6	f0 0f		beq $018cf7			beq 	_LGREnd 					; then it is LIST a,b
.018ce8	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018cea	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018cec	a5 81		lda $81				lda 	XS_Mantissa+1
.018cee	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018cf0					_LGRBumpExit:
.018cf0	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018cf2	d0 02		bne $018cf6			bne 	_LGRBump2
.018cf4	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018cf6					_LGRBump2:
.018cf6	60		rts				rts
.018cf7					_LGREnd:
.018cf7	c8		iny				iny
.018cf8					_LGRBlank:
.018cf8	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018cfa	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018cfc	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018cfe	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d00	c9 00		cmp #$00			cmp 	#0
.018d02	f0 f2		beq $018cf6			beq 	_LGRBump2
.018d04	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018d05	b0 ef		bcs $018cf6			bcs 	_LGRBump2
.018d07	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018d09	20 28 91	jsr $019128			jsr 	EvaluateIntegerX
.018d0c	80 e2		bra $018cf0			bra 	_LGRBumpExit
.018d0e	60		rts				rts
.018d0f					ListCheckRange:
.018d0f	c8		iny				iny
.018d10	a2 00		ldx #$00			ldx 	#0 							; test low
.018d12	20 1f 8d	jsr $018d1f			jsr 	_LCRCompare
.018d15	90 06		bcc $018d1d			bcc 	_LCRFail
.018d17	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018d19	20 1f 8d	jsr $018d1f			jsr 	_LCRCompare
.018d1c	60		rts				rts
.018d1d					_LCRFail:
.018d1d	38		sec				sec
.018d1e	60		rts				rts
.018d1f					_LCRCompare:
.018d1f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d21	38		sec				sec
.018d22	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018d24	08		php				php
.018d25	c8		iny				iny
.018d26	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d28	28		plp				plp
.018d29	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018d2b	08		php				php
.018d2c	88		dey				dey
.018d2d	28		plp				plp
.018d2e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018d2f					Command_PRINT:
.018d2f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d31	c9 00		cmp #$00			cmp 	#0 							; end
.018d33	f0 70		beq $018da5			beq 	_CPR_NewLine
.018d35	c9 c0		cmp #$c0			cmp 	#token_Colon
.018d37	f0 6c		beq $018da5			beq 	_CPR_NewLine
.018d39	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018d3b	f0 5b		beq $018d98			beq 	_CPR_Skip
.018d3d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018d3f	f0 49		beq $018d8a			beq 	_CPR_Tab
.018d41	20 90 8f	jsr $018f90			jsr 	EvaluateExpression 			; get expression.
.018d44	a5 85		lda $85				lda 	XS_Type 					; get type.
.018d46	29 02		and #$02			and 	#2
.018d48	d0 24		bne $018d6e			bne 	_CPR_String 				; if type = 2 output as string.
.018d4a					_CPR_Number:
.018d4a	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018d4c	8d 14 03	sta $0314			sta 	NumBufX
.018d4f	a5 85		lda $85				lda 	XS_Type 					; get type
.018d51	4a		lsr a				lsr 	a
.018d52	b0 05		bcs $018d59			bcs 	_CPRInt 					; if msb set do as integer
.018d54	20 65 a2	jsr $01a265			jsr 	FPToString 					; call fp to str otherwise
.018d57	80 03		bra $018d5c			bra 	_CPRNPrint
.018d59	20 ed 9c	jsr $019ced	_CPRInt:jsr 	IntToString
.018d5c					_CPRNPrint:
.018d5c	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018d5f	c9 2d		cmp #$2d			cmp 	#"-"
.018d61	f0 05		beq $018d68			beq 	_CPRNoSpace
.018d63	a9 20		lda #$20			lda 	#" "						; print the leading space
.018d65	20 12 85	jsr $018512			jsr 	CharPrint 					; so beloved of MS Basics.
.018d68					_CPRNoSpace:
.018d68	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018d6a	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018d6c	80 04		bra $018d72			bra 	_CPRPrint
.018d6e					_CPR_String:
.018d6e	a6 80		ldx $80				ldx 	XS_Mantissa
.018d70	a5 81		lda $81				lda 	XS_Mantissa+1
.018d72					_CPRPrint:
.018d72	86 1e		stx $1e				stx 	zGenPtr
.018d74	85 1f		sta $1f				sta 	zGenPtr+1
.018d76	5a		phy				phy
.018d77	a0 00		ldy #$00			ldy 	#0							; get length into X
.018d79	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d7b	aa		tax				tax
.018d7c	f0 09		beq $018d87			beq 	_CPREndPrint 				; nothing to print
.018d7e					_CPRLoop:
.018d7e	c8		iny				iny
.018d7f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018d81	20 12 85	jsr $018512			jsr 	CharPrint
.018d84	ca		dex				dex
.018d85	d0 f7		bne $018d7e			bne 	_CPRLoop
.018d87					_CPREndPrint:
.018d87	7a		ply				ply
.018d88	80 a5		bra $018d2f			bra 	Command_Print
.018d8a					_CPR_Tab:
.018d8a	20 1b 85	jsr $01851b			jsr 	CharGetPosition 			; print until position % 8 = 0
.018d8d	29 07		and #$07			and 	#7
.018d8f	f0 07		beq $018d98			beq 	_CPR_Skip
.018d91	a9 20		lda #$20			lda 	#" "
.018d93	20 12 85	jsr $018512			jsr 	CharPrint
.018d96	80 f2		bra $018d8a			bra 	_CPR_Tab
.018d98					_CPR_Skip:
.018d98	c8		iny				iny
.018d99	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d9b	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018d9d	f0 09		beq $018da8			beq 	_CPR_Exit
.018d9f	c9 00		cmp #$00			cmp 	#0
.018da1	d0 8c		bne $018d2f			bne 	Command_PRINT 				; if not go round again.
.018da3	80 03		bra $018da8			bra 	_CPR_Exit
.018da5					_CPR_NewLine:
.018da5	20 4f 80	jsr $01804f			jsr 	IFT_NewLine
.018da8					_CPR_Exit:
.018da8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018da9					Command_ASSERT:
.018da9	20 26 91	jsr $019126			jsr 	EvaluateInteger 			; calculate thing being asserted
.018dac	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018dae	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018db0	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018db2	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018db4	f0 01		beq $018db7			beq 	_ASFail
.018db6	60		rts				rts
.018db7					_ASFail:
.018db7	20 4e 85	jsr $01854e			jsr ERR_Handler
>018dba	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018dc1					Command_POKE:
.018dc1	a9 01		lda #$01			lda 	#1
.018dc3	80 06		bra $018dcb			bra 	CmdPoke_Main
.018dc5					Command_DOKE:
.018dc5	a9 02		lda #$02			lda 	#2
.018dc7	80 02		bra $018dcb			bra 	CmdPoke_Main
.018dc9					Command_LOKE:
.018dc9	a9 04		lda #$04			lda 	#4
.018dcb					CmdPoke_Main:
.018dcb	48		pha				pha
.018dcc	20 26 91	jsr $019126			jsr 	EvaluateInteger 			; get two parameters.
.018dcf	e8		inx				inx
.018dd0	e8		inx				inx
.018dd1	e8		inx				inx
.018dd2	e8		inx				inx
.018dd3	e8		inx				inx
.018dd4	e8		inx				inx
.018dd5	20 72 97	jsr $019772			jsr 	CheckNextComma
.018dd8	20 28 91	jsr $019128			jsr 	EvaluateIntegerX
.018ddb	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018ddd	85 1a		sta $1a				sta 	zLTemp1
.018ddf	a5 81		lda $81				lda 	XS_Mantissa+1
.018de1	85 1b		sta $1b				sta 	zLTemp1+1
.018de3	a5 82		lda $82				lda 	XS_Mantissa+2
.018de5	85 1c		sta $1c				sta 	zLTemp1+2
.018de7	a5 83		lda $83				lda 	XS_Mantissa+3
.018de9	85 1d		sta $1d				sta 	zLTemp1+3
.018deb	68		pla				pla 								; get count
.018dec	5a		phy				phy 								; save Y
.018ded	20 fd 96	jsr $0196fd			jsr 	MemWrite 					; write it out
.018df0	7a		ply				ply 								; restore Y and done.
.018df1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018df2					Command_NEW:
.018df2	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018df4	85 16		sta $16				sta 	zCodePtr+0
.018df6	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018df8	85 17		sta $17				sta 	zCodePtr+1
.018dfa	a9 00		lda #$00			lda 	#0
.018dfc	85 18		sta $18				sta 	zCodePtr+2
.018dfe	85 19		sta $19				sta 	zCodePtr+3
.018e00	a0 03		ldy #$03			ldy 	#3
.018e02	a0 00		ldy #$00			ldy 	#0
.018e04	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018e06	97 16		sta [$16],y			sta 	[zCodePtr],y
.018e08	20 0e 97	jsr $01970e			jsr 	UpdateProgramEnd 			; update program end.
.018e0b	4c 07 88	jmp $018807			jmp 	WarmStart
.018e0e					Command_OLD:
.018e0e	ea		nop				nop
.018e0f	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018e11	85 16		sta $16				sta 	zCodePtr+0
.018e13	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018e15	85 17		sta $17				sta 	zCodePtr+1
.018e17	a9 00		lda #$00			lda 	#0
.018e19	85 18		sta $18				sta 	zCodePtr+2
.018e1b	85 19		sta $19				sta 	zCodePtr+3
.018e1d	a0 03		ldy #$03			ldy 	#3
.018e1f					_COL_Find:
.018e1f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e21	c8		iny				iny
.018e22	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018e24	f0 18		beq $018e3e			beq 	_COL_Found
.018e26	98		tya				tya
.018e27	c9 00		cmp #$00			cmp 	#0
.018e29	d0 f4		bne $018e1f			bne 	_COL_Find 					; can't find old EOL, give up.
.018e2b	20 4e 85	jsr $01854e			jsr ERR_Handler
>018e2e	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018e36	43 6f 72 72 75 70 74 00
.018e3e					_COL_Found:
.018e3e	98		tya				tya
.018e3f	48		pha				pha
.018e40	a0 00		ldy #$00			ldy 	#0
.018e42	68		pla				pla
.018e43	97 16		sta [$16],y			sta 	[zCodePtr],y
.018e45	20 0e 97	jsr $01970e			jsr 	UpdateProgramEnd 			; reset variable pointer
.018e48	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018e49					Command_GOTO:
.018e49	20 b8 8e	jsr $018eb8			jsr 	GotoGetLineNumber
.018e4c					CmdGOTO:
.018e4c	a2 00		ldx #$00			ldx 	#0
.018e4e	4c d5 8e	jmp $018ed5			jmp 	GotoChangeToLineNumberX
.018e51					Command_GOSUB:
.018e51	20 b8 8e	jsr $018eb8			jsr 	GotoGetLineNumber
.018e54					CmdGOSUB:
.018e54	20 d9 84	jsr $0184d9			jsr 	StackSavePosition
.018e57	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018e59	20 92 84	jsr $018492			jsr 	StackPushFrame
.018e5c	a2 00		ldx #$00			ldx		#0
.018e5e	4c d5 8e	jmp $018ed5			jmp 	GotoChangeToLineNumberX
.018e61					Command_RETURN:
.018e61	a9 10		lda #$10			lda 	#(SMark_Gosub << 4)
.018e63	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018e66	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition
.018e69	60		rts				rts
.018e6a					Command_ON:
.018e6a	a2 00		ldx #$00			ldx 	#0 							; get the ON.
.018e6c	20 c2 95	jsr $0195c2			jsr 	SLIByteParameter
.018e6f	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.018e71	f0 42		beq $018eb5			beq 	_CONFail 					; can't be zero.
.018e73	aa		tax				tax 								; save in X.
.018e74	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e76	c8		iny				iny
.018e77	48		pha				pha
.018e78	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.018e7a	f0 07		beq $018e83			beq 	_CONOkayToken
.018e7c	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.018e7e	f0 03		beq $018e83			beq 	_CONOkayToken
.018e80	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.018e83					_CONOkayToken:
.018e83	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.018e84					_CONFindNumber:
.018e84	20 b8 8e	jsr $018eb8			jsr 	GotoGetLineNumber 			; get a line number.
.018e87	fa		plx				plx 								; restore count
.018e88	ca		dex				dex  								; decrement, exit if zero.
.018e89	f0 06		beq $018e91			beq 	_CONFound
.018e8b	da		phx				phx 								; push back
.018e8c	20 72 97	jsr $019772			jsr 	CheckNextComma				; check for comma
.018e8f	80 f3		bra $018e84			bra 	_CONFindNumber
.018e91					_CONFound:
.018e91	68		pla				pla 								; get token
.018e92	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.018e94	f0 b6		beq $018e4c			beq		CmdGOTO 					; then just branch.
.018e96					_CONEndOfCmd:
.018e96	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e98	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018e9a	f0 b8		beq $018e54			beq 	CMDGosub
.018e9c	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018e9e	f0 b4		beq $018e54			beq 	CMDGosub
.018ea0	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018ea2	c8		iny				iny 								; skip
.018ea3	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018ea5	90 0c		bcc $018eb3			bcc 	_SEDone 					; so just skip over it.
.018ea7	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018ea9	90 07		bcc $018eb2			bcc 	_SEDouble
.018eab	98		tya				tya 								; this is Y + 1
.018eac	18		clc				clc
.018ead	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018eaf	a8		tay				tay 								; back in Y.
.018eb0	88		dey				dey 								; fix up, one for the +1, one for the iny
.018eb1	88		dey				dey
.018eb2					_SEDouble:
.018eb2	c8		iny				iny
.018eb3					_SEDone:
.018eb3	80 e1		bra $018e96			bra 	_CONEndOfCmd
.018eb5					_CONFail:
.018eb5	4c 3d 85	jmp $01853d			jmp 	BadParamError
.018eb8					GotoGetLineNumber:
.018eb8	20 26 91	jsr $019126			jsr 	EvaluateInteger
.018ebb	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018ebd	05 83		ora $83				ora 	XS_Mantissa+3
.018ebf	d0 01		bne $018ec2			bne 	_GLINError
.018ec1	60		rts				rts
.018ec2					_GLINError:
.018ec2	20 4e 85	jsr $01854e			jsr ERR_Handler
>018ec5	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018ecd	20 4e 75 6d 62 65 72 00
.018ed5					GotoChangeToLineNumberX:
.018ed5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.018ed7	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018ed9	f0 37		beq $018f12			beq 	_GCTLFail
.018edb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018edd	85 16		sta $16				sta 	zCodePtr+0
.018edf	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018ee1	85 17		sta $17				sta 	zCodePtr+1
.018ee3	a9 00		lda #$00			lda 	#0
.018ee5	85 18		sta $18				sta 	zCodePtr+2
.018ee7	85 19		sta $19				sta 	zCodePtr+3
.018ee9	a0 03		ldy #$03			ldy 	#3
.018eeb					_GCTLLoop:
.018eeb	a0 00		ldy #$00			ldy 	#0
.018eed	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eef	c9 00		cmp #$00			cmp 	#0
.018ef1	f0 1f		beq $018f12			beq 	_GCTLFail
.018ef3	c8		iny				iny
.018ef4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ef6	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.018ef8	d0 07		bne $018f01			bne 	_GCTLNext
.018efa	c8		iny				iny
.018efb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018efd	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.018eff	f0 0f		beq $018f10			beq 	_GCTLExit
.018f01					_GCTLNext:
.018f01	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018f03	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018f05	18		clc				clc
.018f06	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018f08	85 16		sta $16				sta 	zCodePtr
.018f0a	90 02		bcc $018f0e			bcc 	_SNLNoCarry
.018f0c	e6 17		inc $17				inc 	zCodePtr+1
.018f0e					_SNLNoCarry:
.018f0e	80 db		bra $018eeb			bra 	_GCTLLoop 					; try next line.
.018f10					_GCTLExit:
.018f10	c8		iny				iny
.018f11	60		rts				rts
.018f12					_GCTLFail:
.018f12	20 4e 85	jsr $01854e			jsr ERR_Handler
>018f15	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018f1d	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018f25					Command_CLR:
.018f25					ResetRunStatus:
.018f25	20 47 98	jsr $019847			jsr 	VariableClear
.018f28	20 80 84	jsr $018480			jsr 	StackReset
.018f2b	a9 00		lda #$00			lda 	#HighMemory & $FF
.018f2d	8d 00 03	sta $0300			sta 	StringPtr
.018f30	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018f32	8d 01 03	sta $0301			sta 	StringPtr+1
.018f35	20 11 9a	jsr $019a11			jsr 	ArrayResetDefault
.018f38	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018f39					Command_STOP:
.018f39	20 4e 85	jsr $01854e			jsr ERR_Handler
>018f3c	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.018f41					Command_WHILE:
.018f41	20 d9 84	jsr $0184d9			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.018f44	20 26 91	jsr $019126			jsr 	EvaluateInteger 			; calculate the while loop value.
.018f47	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018f49	05 81		ora $81				ora 	XS_Mantissa+1
.018f4b	05 82		ora $82				ora 	XS_Mantissa+2
.018f4d	05 83		ora $83				ora 	XS_Mantissa+3
.018f4f	f0 06		beq $018f57			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.018f51	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.018f53	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push on stack
.018f56	60		rts				rts
.018f57					_CWHSkip:
.018f57	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.018f59	20 f3 83	jsr $0183f3			jsr 	StructureSearchSingle
.018f5c	c8		iny				iny
.018f5d	60		rts				rts
.018f5e					Command_WEND:
.018f5e	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.018f60	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018f63	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition
.018f66	80 d9		bra $018f41			bra 	Command_WHILE 				; and do the while again.
.018f68	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018f69					Command_REPEAT:
.018f69	20 d9 84	jsr $0184d9			jsr 	StackSavePosition			; save position into stack
.018f6c	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018f6e	20 92 84	jsr $018492			jsr 	StackPushFrame 				; push on stack
.018f71	60		rts				rts
.018f72					Command_UNTIL:
.018f72	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame
.018f74	20 a9 84	jsr $0184a9			jsr 	StackPopFrame
.018f77	20 26 91	jsr $019126			jsr 	EvaluateInteger				; work out UNTIL
.018f7a	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018f7c	05 81		ora $81				ora 	XS_Mantissa+1
.018f7e	05 82		ora $82				ora 	XS_Mantissa+2
.018f80	05 83		ora $83				ora 	XS_Mantissa+3
.018f82	d0 08		bne $018f8c			bne 	_CUTExit 					; if not, just exit
.018f84	20 f6 84	jsr $0184f6			jsr 	StackRestorePosition 		; otherwise loop round again.
.018f87	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018f89	20 92 84	jsr $018492			jsr 	StackPushFrame 				; fix the stack back.
.018f8c					_CUTExit:
.018f8c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018f8d					EVESyntax:
.018f8d	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.018f90					EvaluateExpression:
.018f90	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018f92					EvaluateExpressionX:
.018f92	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018f94					EvaluateExpressionXA:
.018f94	48		pha				pha 								; save precedence on stack.
.018f95	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018f97	f0 f4		beq $018f8d			beq 	EVESyntax 					; end of line, syntax error.
.018f99	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018f9b	b0 03		bcs $018fa0			bcs 	_EVNotVariable
.018f9d	4c 6a 90	jmp $01906a			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018fa0					_EVNotVariable:
.018fa0	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018fa2	90 e9		bcc $018f8d			bcc 	EVESyntax
.018fa4	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018fa6	b0 58		bcs $019000			bcs 	_EVNotInteger
.018fa8	20 98 90	jsr $019098			jsr 	EvaluateGetInteger
.018fab					_EVCheckDecimal:
.018fab	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fad	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018faf	d0 05		bne $018fb6			bne 	_EVGotAtom 					; no, get atom.
.018fb1					_EVIsDecimal:
.018fb1	20 be 90	jsr $0190be			jsr 	EVGetDecimal 				; extend to the decimal part.
.018fb4	80 00		bra $018fb6			bra 	_EVGotAtom 					; and continue to got atom.
.018fb6					_EVGotAtom:
.018fb6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fb8	10 44		bpl $018ffe			bpl 	_EVExitDrop 				; must be a token.
.018fba	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018fbc	b0 40		bcs $018ffe			bcs 	_EVExitDrop
.018fbe	68		pla				pla 								; get current precedence
.018fbf	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018fc1	da		phx				phx 								; save X
.018fc2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fc4	aa		tax				tax 								; put in X
.018fc5	bf 03 86 01	lda $018603,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018fc9	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018fcb	fa		plx				plx 								; restore X
.018fcc	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018fce	90 2f		bcc $018fff			bcc 	_EVExit 					; exit if too low.
.018fd0	f0 2d		beq $018fff			beq 	_EVExit 					; exit if equals
.018fd2	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018fd4	48		pha				pha
.018fd5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018fd7	48		pha				pha
.018fd8	c8		iny				iny
.018fd9	da		phx				phx 								; save current position
.018fda	e8		inx				inx
.018fdb	e8		inx				inx
.018fdc	e8		inx				inx
.018fdd	e8		inx				inx
.018fde	e8		inx				inx
.018fdf	e8		inx				inx
.018fe0	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018fe2	20 94 8f	jsr $018f94			jsr 	EvaluateExpressionXA 		; do the RHS.
.018fe5	fa		plx				plx 								; restore X
.018fe6	68		pla				pla 								; get the binary operator in A.
.018fe7					_EVCallA:
.018fe7	da		phx				phx 								; save X again
.018fe8	0a		asl a				asl 	a 							; double, lose the MSB.
.018fe9	aa		tax				tax									; put in X
.018fea	bf b2 85 01	lda $0185b2,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018fee	8d 11 03	sta $0311			sta 	LocalVector+1
.018ff1	bf b3 85 01	lda $0185b3,x			lda 	VectorTable+1,x
.018ff5	8d 12 03	sta $0312			sta 	LocalVector+2
.018ff8	fa		plx				plx 								; restore X
.018ff9	20 73 90	jsr $019073			jsr 	EVCallLocalVector
.018ffc	80 b8		bra $018fb6			bra 	_EVGotAtom 					; and loop back.
.018ffe					_EVExitDrop:
.018ffe	68		pla				pla
.018fff					_EVExit:
.018fff	60		rts				rts
.019000					_EVNotInteger:
.019000	c8		iny				iny
.019001	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.019003	d0 16		bne $01901b			bne 	_EVNotMinus
.019005	20 07 91	jsr $019107			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019008	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01900a	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.01900c	f0 05		beq $019013			beq 	_EVMinusFloat
.01900e	20 d0 9c	jsr $019cd0			jsr 	IntegerNegateAlways 		; negation
.019011	80 a3		bra $018fb6			bra 	_EVGotAtom 					; and go back.
.019013					_EVMinusFloat:
.019013	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.019015	49 80		eor #$80			eor 	#$80
.019017	95 85		sta $85,x			sta 	XS_Type,x
.019019	80 9b		bra $018fb6			bra 	_EVGotAtom
.01901b					_EVNotMinus:
.01901b	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.01901d	d0 17		bne $019036			bne 	_EVNotParenthesis
.01901f	20 92 8f	jsr $018f92			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.019022	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019024	c8		iny				iny
.019025	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.019027	f0 8d		beq $018fb6			beq 	_EVGotAtom
.019029	20 4e 85	jsr $01854e			jsr ERR_Handler
>01902c	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>019034	29 00
.019036					_EVNotParenthesis:
.019036	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019038	d0 0c		bne $019046			bne 	_EVNotNot
.01903a	20 07 91	jsr $019107			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.01903d	20 66 a1	jsr $01a166			jsr 	FPUToInteger 				; make it an integer - if possible.
.019040	20 ec 90	jsr $0190ec			jsr 	NotInteger 					; do the not calculation
.019043	4c b6 8f	jmp $018fb6			jmp 	_EVGotAtom
.019046					_EVNotNot:
.019046	c9 fe		cmp #$fe			cmp 	#$FE
.019048	d0 12		bne $01905c			bne 	_EVNotString
.01904a	20 e5 97	jsr $0197e5			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.01904d	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.01904f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019051	a5 21		lda $21				lda 	zTempStr+1
.019053	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019055	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019057	95 85		sta $85,x			sta 	XS_Type,x
.019059	4c b6 8f	jmp $018fb6			jmp 	_EVGotAtom
.01905c					_EVNotString:
.01905c	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.01905e	90 04		bcc $019064			bcc 	_EVBadElement
.019060	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.019062	90 03		bcc $019067			bcc 	_EVUnaryFunction
.019064					_EVBadElement:
.019064	4c 1f 85	jmp $01851f			jmp 	SyntaxError
.019067					_EVUnaryFunction:
.019067	4c e7 8f	jmp $018fe7			jmp 	_EVCallA
.01906a					_EVVariableHandler:
.01906a	20 0b 98	jsr $01980b			jsr 	VariableFind 				; locate a variable
.01906d	20 53 9b	jsr $019b53			jsr 	VariableGet 				; copy into memory.
.019070	4c b6 8f	jmp $018fb6			jmp 	_EVGotAtom 					; and go round.
.019073					EVCallLocalVector:
.019073	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.019076					EVShiftMantissaLeft6:
.019076	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019078	95 84		sta $84,x			sta 	XS_Exponent,x
.01907a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01907c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01907e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019080	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019082	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019084	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019086	a9 00		lda #$00			lda 	#0
.019088	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01908a	20 8d 90	jsr $01908d			jsr 	_EVSMLShift 					; call it here to do it twice
.01908d					_EVSMLShift:
.01908d	56 84		lsr $84,x			lsr 	XS_Exponent,x
.01908f	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.019091	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.019093	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.019095	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019097	60		rts				rts
.019098					EvaluateGetInteger:
.019098	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01909a	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.01909c	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.01909e	a9 00		lda #$00			lda 	#0
.0190a0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190a2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190a4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190a6	1a		inc a				inc 	a 							; set to type 1 (integer)
.0190a7	95 85		sta $85,x			sta 	XS_Type,x
.0190a9					_EVCheckNextInteger:
.0190a9	c8		iny				iny
.0190aa	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190ac	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.0190ae	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.0190b0	b0 0b		bcs $0190bd			bcs 	_EVEndInteger
.0190b2	48		pha				pha 								; save it.
.0190b3	20 76 90	jsr $019076			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.0190b6	68		pla				pla
.0190b7	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.0190b9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190bb	80 ec		bra $0190a9			bra 	_EVCheckNextInteger
.0190bd					_EVEndInteger:
.0190bd	60		rts				rts
.0190be					EVGetDecimal:
.0190be	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.0190c0	8d 15 03	sta $0315			sta 	Num_Buffer
.0190c3	da		phx				phx
.0190c4	c8		iny				iny
.0190c5	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190c7	c8		iny				iny
.0190c8	3a		dec a				dec 	a								; convert to a string length.
.0190c9	3a		dec a				dec 	a
.0190ca	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.0190cc					_EVGDCopy:
.0190cc	48		pha				pha 									; save count
.0190cd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190cf	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.0190d2	e8		inx				inx 									; forward ....
.0190d3	c8		iny				iny
.0190d4	68		pla				pla 									; get count
.0190d5	3a		dec a				dec 	a 								; until zero
.0190d6	d0 f4		bne $0190cc			bne 	_EVGDCopy
.0190d8	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.0190db	fa		plx				plx 									; restore X
.0190dc	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0190de	85 1e		sta $1e				sta 	zGenPtr
.0190e0	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0190e2	85 1f		sta $1f				sta 	zGenPtr+1
.0190e4	5a		phy				phy 									; save Y
.0190e5	a0 00		ldy #$00			ldy 	#0 								; start position
.0190e7	20 20 a3	jsr $01a320			jsr 	FPFromString 					; convert current
.0190ea	7a		ply				ply 									; restore Y
.0190eb	60		rts				rts
.0190ec					NotInteger:
.0190ec	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0190ee	49 ff		eor #$ff			eor 	#$FF
.0190f0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190f2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190f4	49 ff		eor #$ff			eor 	#$FF
.0190f6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190f8	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0190fa	49 ff		eor #$ff			eor 	#$FF
.0190fc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190fe	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019100	49 ff		eor #$ff			eor 	#$FF
.019102	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019104	60		rts				rts
.019105					EvaluateGetAtom:
.019105	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019107					EvaluateGetAtomX:
.019107	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019109	20 94 8f	jsr $018f94			jsr 	EvaluateExpressionXA
.01910c	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.01910e	29 0f		and #$0f			and 	#15
.019110	c9 02		cmp #$02			cmp 	#2
.019112	b0 01		bcs $019115			bcs 	EvaluateType
.019114	60		rts				rts
.019115					EvaluateType:
.019115	4c 2f 85	jmp $01852f			jmp 	TypeError
.019118					EvaluateNumber:
.019118	a2 00		ldx #$00			ldx 	#0
.01911a					EvaluateNumberX:
.01911a	20 92 8f	jsr $018f92			jsr 	EvaluateExpressionX
.01911d	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.01911f	29 0f		and #$0f			and 	#15
.019121	c9 02		cmp #$02			cmp 	#2
.019123	b0 f0		bcs $019115			bcs 	EvaluateType
.019125	60		rts				rts
.019126					EvaluateInteger:
.019126	a2 00		ldx #$00			ldx 	#0
.019128					EvaluateIntegerX:
.019128	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX
.01912b	20 66 a1	jsr $01a166			jsr 	FPUToInteger
.01912e	60		rts				rts
.01912f					EvaluateString:
.01912f	a2 00		ldx #$00			ldx 	#0
.019131					EvaluateStringX:
.019131	20 92 8f	jsr $018f92			jsr 	EvaluateExpressionX
.019134	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.019136	29 0f		and #$0f			and 	#15
.019138	c9 02		cmp #$02			cmp 	#2
.01913a	d0 d9		bne $019115			bne 	EvaluateType
.01913c	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.01913e	85 1e		sta $1e				sta 	zGenPtr
.019140	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019142	85 1f		sta $1f				sta 	zGenPtr+1
.019144	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.019145					BinaryOp_And:
.019145	20 99 91	jsr $019199			jsr 	BinaryMakeBothInteger
.019148	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01914a	35 86		and $86,x			and 	XS2_Mantissa+0,x
.01914c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01914e	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019150	35 87		and $87,x			and 	XS2_Mantissa+1,x
.019152	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019154	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019156	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019158	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01915a	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01915c	35 89		and $89,x			and 	XS2_Mantissa+3,x
.01915e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019160	60		rts				rts
.019161					BinaryOp_Or:
.019161	20 99 91	jsr $019199			jsr 	BinaryMakeBothInteger
.019164	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019166	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019168	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01916a	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01916c	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01916e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019170	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019172	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019174	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019176	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019178	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01917a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01917c	60		rts				rts
.01917d					BinaryOp_Eor:
.01917d					BinaryOp_Xor:
.01917d	20 99 91	jsr $019199			jsr 	BinaryMakeBothInteger
.019180	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019182	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.019184	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019186	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019188	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.01918a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01918c	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01918e	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.019190	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019192	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019194	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019196	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019198	60		rts				rts
.019199					BinaryMakeBothInteger:
.019199	da		phx				phx 								; save X
.01919a	e8		inx				inx
.01919b	e8		inx				inx
.01919c	e8		inx				inx
.01919d	e8		inx				inx
.01919e	e8		inx				inx
.01919f	e8		inx				inx
.0191a0	20 a4 91	jsr $0191a4			jsr 	BinaryMakeInteger 			; convert to integer.
.0191a3	fa		plx				plx 								; restore X and fall through.
.0191a4					BinaryMakeInteger:
.0191a4	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0191a6	29 0f		and #$0f			and 	#15 						; check type zero
.0191a8	f0 04		beq $0191ae			beq 	_BMIConvert 				; if float convert to integer.
.0191aa	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.0191ab	90 04		bcc $0191b1			bcc 	_BMIError
.0191ad	60		rts				rts
.0191ae					_BMIConvert:
.0191ae	4c 66 a1	jmp $01a166			jmp 	FPUToInteger 				; convert to integer
.0191b1					_BMIError:
.0191b1	4c 2f 85	jmp $01852f			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.0191b4					Binary_Equal:
.0191b4	20 fb 91	jsr $0191fb			jsr 	CompareValues
.0191b7	09 00		ora #$00			ora 	#0
.0191b9	f0 04		beq $0191bf			beq 	CCTrue
.0191bb	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0191bd	80 02		bra $0191c1			bra 	CCWrite
.0191bf	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0191c1	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0191c3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0191c5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0191c7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0191c9	a9 01		lda #$01			lda 	#1
.0191cb	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0191cd	60		rts				rts
.0191ce					Binary_NotEqual:
.0191ce	20 fb 91	jsr $0191fb			jsr 	CompareValues
.0191d1	09 00		ora #$00			ora 	#0
.0191d3	f0 e6		beq $0191bb			beq 	CCFalse
.0191d5	80 e8		bra $0191bf			bra 	CCTrue
.0191d7					Binary_Less:
.0191d7	20 fb 91	jsr $0191fb			jsr 	CompareValues
.0191da	09 00		ora #$00			ora 	#0
.0191dc	30 e1		bmi $0191bf			bmi 	CCTrue
.0191de	80 db		bra $0191bb			bra 	CCFalse
.0191e0					Binary_LessEqual:
.0191e0	20 fb 91	jsr $0191fb			jsr 	CompareValues
.0191e3	c9 01		cmp #$01			cmp 	#1
.0191e5	d0 d8		bne $0191bf			bne 	CCTrue
.0191e7	80 d2		bra $0191bb			bra 	CCFalse
.0191e9					Binary_GreaterEqual:
.0191e9	20 fb 91	jsr $0191fb			jsr 	CompareValues
.0191ec	09 00		ora #$00			ora 	#0
.0191ee	10 cf		bpl $0191bf			bpl 	CCTrue
.0191f0	80 c9		bra $0191bb			bra 	CCFalse
.0191f2					Binary_Greater:
.0191f2	20 fb 91	jsr $0191fb			jsr 	CompareValues
.0191f5	c9 01		cmp #$01			cmp 	#1
.0191f7	f0 c6		beq $0191bf			beq 	CCTrue
.0191f9	80 c0		bra $0191bb			bra 	CCFalse
.0191fb					CompareValues:
.0191fb	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0191fd	35 8b		and $8b,x			and 	XS2_Type,x
.0191ff	c9 02		cmp #$02			cmp 	#2
.019201	f0 11		beq $019214			beq 	_CVString
.019203	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019205	35 8b		and $8b,x			and 	XS2_Type,x
.019207	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019208	90 03		bcc $01920d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01920a	4c 56 92	jmp $019256			jmp 	CompareInteger32 							; so execute code at \1
.01920d					_BCFloat:
.01920d	20 fa 92	jsr $0192fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019210	4c 5f a0	jmp $01a05f			jmp 	FPCompare 							; and execute code at \2
.019213	60		rts				rts
.019214					_CVString:
.019214	da		phx				phx 								; save XY
.019215	5a		phy				phy
.019216	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019218	85 1a		sta $1a				sta		zLTemp1+0
.01921a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01921c	85 1b		sta $1b				sta 	zLTemp1+1
.01921e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019220	85 1c		sta $1c				sta 	zLTemp1+2
.019222	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019224	85 1d		sta $1d				sta 	zLTemp1+3
.019226	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019228	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01922a	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01922c	90 02		bcc $019230			bcc 	_CVCommon
.01922e	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.019230					_CVCommon:
.019230	aa		tax				tax 								; put shorter string length in zero.
.019231	f0 0c		beq $01923f			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.019233					_CVCompare:
.019233	c8		iny				iny 								; next character
.019234	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.019236	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019238	90 13		bcc $01924d			bcc 	_CVReturnLess 				; <
.01923a	d0 15		bne $019251			bne 	_CVReturnGreater 			; >
.01923c	ca		dex				dex 								; until common length matched.
.01923d	d0 f4		bne $019233			bne 	_CVCompare
.01923f					_CVMatch:
.01923f	a0 00		ldy #$00			ldy 	#0
.019241	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019243	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019245	90 06		bcc $01924d			bcc 	_CVReturnLess 				; <
.019247	d0 08		bne $019251			bne 	_CVReturnGreater 			; >
.019249	a9 00		lda #$00			lda 	#0
.01924b	80 06		bra $019253			bra 	_CVExit 					; same common, same length, same string
.01924d					_CVReturnLess:
.01924d	a9 ff		lda #$ff			lda 	#$FF
.01924f	80 02		bra $019253			bra 	_CVExit
.019251					_CVReturnGreater:
.019251	a9 01		lda #$01			lda 	#$01
.019253					_CVExit:
.019253	7a		ply				ply
.019254	fa		plx				plx
.019255	60		rts				rts
.019256					CompareInteger32:
.019256	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019258	49 80		eor #$80			eor 	#$80
.01925a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01925c	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.01925e	49 80		eor #$80			eor 	#$80
.019260	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.019262	20 e0 92	jsr $0192e0			jsr 	SubInteger32 				; subtraction
.019265	90 0d		bcc $019274			bcc 	_CI32Less 					; cc return -1
.019267	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019269	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01926b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01926d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01926f	f0 02		beq $019273			beq 	_CI32Exit
.019271	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.019273					_CI32Exit:
.019273	60		rts				rts
.019274					_CI32Less:
.019274	a9 ff		lda #$ff			lda 	#$FF
.019276	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019277					BinaryOp_Add:
.019277	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019279	35 8b		and $8b,x			and 	XS2_Type,x
.01927b	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.01927d	d0 11		bne $019290			bne 	_BOAString
.01927f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019281	35 8b		and $8b,x			and 	XS2_Type,x
.019283	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019284	90 03		bcc $019289			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019286	4c c6 92	jmp $0192c6			jmp 	AddInteger32 							; so execute code at \1
.019289					_BCFloat:
.019289	20 fa 92	jsr $0192fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01928c	4c 3a 9e	jmp $019e3a			jmp 	FPAdd 							; and execute code at \2
.01928f	60		rts				rts
.019290					_BOAString:
.019290	4c 14 93	jmp $019314			jmp 	ConcatenateString 			; concatenate two strings.
.019293					BinaryOp_Subtract:
.019293	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019295	35 8b		and $8b,x			and 	XS2_Type,x
.019297	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019298	90 03		bcc $01929d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01929a	4c e0 92	jmp $0192e0			jmp 	SubInteger32 							; so execute code at \1
.01929d					_BCFloat:
.01929d	20 fa 92	jsr $0192fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192a0	4c 32 9e	jmp $019e32			jmp 	FPSubtract 							; and execute code at \2
.0192a3	60		rts				rts
.0192a4					BinaryOp_Multiply:
.0192a4	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192a6	35 8b		and $8b,x			and 	XS2_Type,x
.0192a8	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192a9	90 03		bcc $0192ae			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192ab	4c 0b 9c	jmp $019c0b			jmp 	MulInteger32 							; so execute code at \1
.0192ae					_BCFloat:
.0192ae	20 fa 92	jsr $0192fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192b1	4c 61 9f	jmp $019f61			jmp 	FPMultiply 							; and execute code at \2
.0192b4	60		rts				rts
.0192b5					BinaryOp_Divide:
.0192b5	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0192b7	35 8b		and $8b,x			and 	XS2_Type,x
.0192b9	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0192ba	90 03		bcc $0192bf			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0192bc	4c 49 9c	jmp $019c49			jmp 	DivInteger32 							; so execute code at \1
.0192bf					_BCFloat:
.0192bf	20 fa 92	jsr $0192fa			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0192c2	4c ee 9e	jmp $019eee			jmp 	FPDivide 							; and execute code at \2
.0192c5	60		rts				rts
.0192c6					AddInteger32:
.0192c6	18		clc				clc
.0192c7	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192c9	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0192cb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192cd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192cf	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0192d1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192d3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0192d5	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0192d7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192d9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0192db	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0192dd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192df	60		rts				rts
.0192e0					SubInteger32:
.0192e0	38		sec				sec
.0192e1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192e3	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0192e5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192e7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192e9	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0192eb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192ed	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0192ef	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0192f1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192f3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0192f5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0192f7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192f9	60		rts				rts
.0192fa					BinaryMakeBothFloat:
.0192fa	da		phx				phx 								; save X
.0192fb	e8		inx				inx
.0192fc	e8		inx				inx
.0192fd	e8		inx				inx
.0192fe	e8		inx				inx
.0192ff	e8		inx				inx
.019300	e8		inx				inx
.019301	20 05 93	jsr $019305			jsr 	BinaryMakeFloat 			; convert to float.
.019304	fa		plx				plx 								; restore X and fall through.
.019305					BinaryMakeFloat:
.019305	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019307	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019308	b0 04		bcs $01930e			bcs 	_BMFConvert
.01930a	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.01930b	b0 04		bcs $019311			bcs 	_BMFError
.01930d	60		rts				rts
.01930e					_BMFConvert:
.01930e	4c 1a a1	jmp $01a11a			jmp 	FPUToFloat 					; convert to float
.019311					_BMFError:
.019311	4c 2f 85	jmp $01852f			jmp 	TypeError
.019314					ConcatenateString:
.019314	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019316	85 1a		sta $1a				sta		zLTemp1+0
.019318	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01931a	85 1b		sta $1b				sta 	zLTemp1+1
.01931c	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01931e	85 1c		sta $1c				sta 	zLTemp1+2
.019320	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019322	85 1d		sta $1d				sta 	zLTemp1+3
.019324	5a		phy				phy
.019325	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019327	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019329	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.01932b	7a		ply				ply
.01932c	b0 33		bcs $019361			bcs 	_CSError					; check in range.
.01932e	c9 fe		cmp #$fe			cmp 	#maxString+1
.019330	b0 2f		bcs $019361			bcs 	_CSError
.019332	20 aa 97	jsr $0197aa			jsr 	AllocateTempString 			; store the result
.019335	20 4c 93	jsr $01934c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019338	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.01933a	85 1a		sta $1a				sta 	zLTemp1
.01933c	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01933e	85 1b		sta $1b				sta 	zLTemp1+1
.019340	20 4c 93	jsr $01934c			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019343	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.019345	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019347	a5 21		lda $21				lda 	zTempStr+1
.019349	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01934b	60		rts				rts
.01934c					_CSCopyString:
.01934c	da		phx				phx
.01934d	5a		phy				phy
.01934e	a0 00		ldy #$00			ldy 	#0 							; get length
.019350	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019352	f0 0a		beq $01935e			beq 	_CSCSExit 					; if zero, exit
.019354	aa		tax				tax 								; put in X
.019355					_CSCSLoop:
.019355	c8		iny				iny 								; get next char
.019356	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019358	20 d5 97	jsr $0197d5			jsr		WriteTempString 			; copy out
.01935b	ca		dex				dex 								; do whole string
.01935c	d0 f7		bne $019355			bne 	_CSCSLoop
.01935e					_CSCSExit:
.01935e	7a		ply				ply
.01935f	fa		plx				plx
.019360	60		rts				rts
.019361					_CSError:
.019361	20 4e 85	jsr $01854e			jsr ERR_Handler
>019364	53 74 72 69 6e 67 20 74			.text "String too long",0
>01936c	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019374					Unary_Sgn:
.019374	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX 			; get value
.019377	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; check right bracket.
.01937a	20 98 93	jsr $019398			jsr 	GetSignCurrent 				; get sign.
.01937d	09 00		ora #$00			ora 	#0
.01937f	10 08		bpl $019389			bpl		UnarySetAInteger			; if 0,1 return that.
.019381	80 00		bra $019383			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019383					UnarySetAMinus1:
.019383	a9 ff		lda #$ff			lda 	#$FF
.019385	95 80		sta $80,x			sta 	XS_Mantissa,x
.019387	80 04		bra $01938d			bra 	UnarySetAFill
.019389					UnarySetAInteger:
.019389	95 80		sta $80,x			sta 	XS_Mantissa,x
.01938b	a9 00		lda #$00			lda 	#0
.01938d					UnarySetAFill:
.01938d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01938f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019391	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019393	a9 01		lda #$01			lda 	#1
.019395	95 85		sta $85,x			sta 	XS_Type,x
.019397	60		rts				rts
.019398					GetSignCurrent:
.019398	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.01939a	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01939b	90 15		bcc $0193b2			bcc 	_GSCFloat
.01939d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01939f	30 0e		bmi $0193af			bmi 	_GSCMinus1
.0193a1	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0193a3	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0193a5	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193a7	d0 03		bne $0193ac			bne 	_GSCPlus1
.0193a9					_GSCZero:
.0193a9	a9 00		lda #$00			lda 	#0
.0193ab	60		rts				rts
.0193ac					_GSCPlus1:
.0193ac	a9 01		lda #$01			lda 	#$01
.0193ae	60		rts				rts
.0193af					_GSCMinus1:
.0193af	a9 ff		lda #$ff			lda 	#$FF
.0193b1	60		rts				rts
.0193b2					_GSCFloat:
.0193b2	34 85		bit $85,x			bit 	XS_Type,x
.0193b4	70 f3		bvs $0193a9			bvs 	_GSCZero
.0193b6	30 f7		bmi $0193af			bmi 	_GSCMinus1
.0193b8	80 f2		bra $0193ac			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0193ba					Unary_Abs:
.0193ba	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX 			; get value
.0193bd	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; check right bracket.
.0193c0	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0193c2	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0193c4	f0 07		beq $0193cd			beq 	_UAMinusFloat
.0193c6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.0193c8	10 09		bpl $0193d3			bpl 	_UAExit
.0193ca	4c d0 9c	jmp $019cd0			jmp 	IntegerNegateAlways 		; negation
.0193cd					_UAMinusFloat:
.0193cd	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.0193cf	29 7f		and #$7f			and		#$7F
.0193d1	95 85		sta $85,x			sta 	XS_Type,x
.0193d3					_UAExit:
.0193d3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0193d4					Unary_Peek:
.0193d4	a9 01		lda #$01			lda 	#1
.0193d6	80 06		bra $0193de			bra 	UPMain
.0193d8					Unary_Deek:
.0193d8	a9 02		lda #$02			lda 	#2
.0193da	80 02		bra $0193de			bra 	UPMain
.0193dc					Unary_Leek:
.0193dc	a9 04		lda #$04			lda 	#4
.0193de					UPMain:
.0193de	48		pha				pha 								; set bytes to copy.
.0193df	20 28 91	jsr $019128			jsr 	EvaluateIntegerX 			; numeric parameter
.0193e2	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.0193e5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0193e7	85 1a		sta $1a				sta 	zLTemp1
.0193e9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193eb	85 1b		sta $1b				sta 	zLTemp1+1
.0193ed	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193ef	85 1c		sta $1c				sta 	zLTemp1+2
.0193f1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193f3	85 1d		sta $1d				sta 	zLTemp1+3
.0193f5	a9 00		lda #$00			lda 	#0 							; clear target area
.0193f7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193f9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193fb	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193fd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193ff	68		pla				pla 								; restore bytes to copy
.019400	da		phx				phx 								; save XY
.019401	5a		phy				phy
.019402	20 ec 96	jsr $0196ec			jsr 	MemRead 					; read the bytes in
.019405	7a		ply				ply 								; restore and exit
.019406	fa		plx				plx
.019407	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019408					Unary_Pos:
.019408	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX 			; get value
.01940b	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; check right bracket.
.01940e	20 1b 85	jsr $01851b			jsr 	CharGetPosition 			; get the position
.019411	4c 89 93	jmp $019389			jmp		UnarySetAInteger			; if 0,1 return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019414					Unary_Mod:
.019414	20 3c 94	jsr $01943c			jsr 	_UMParameter 				; first parameter
.019417	20 72 97	jsr $019772			jsr 	CheckNextComma
.01941a	da		phx				phx 								; second parameter
.01941b	e8		inx				inx
.01941c	e8		inx				inx
.01941d	e8		inx				inx
.01941e	e8		inx				inx
.01941f	e8		inx				inx
.019420	e8		inx				inx
.019421	20 3c 94	jsr $01943c			jsr 	_UMParameter
.019424	fa		plx				plx
.019425	20 6a 97	jsr $01976a			jsr 	CheckNextRParen
.019428	20 49 9c	jsr $019c49			jsr 	DivInteger32 				; divide
.01942b	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.01942d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01942f	a5 1b		lda $1b				lda 	zLTemp1+1
.019431	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019433	a5 1c		lda $1c				lda 	zLTemp1+2
.019435	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019437	a5 1d		lda $1d				lda 	zLTemp1+3
.019439	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01943b	60		rts				rts
.01943c					_UMParameter:
.01943c	20 28 91	jsr $019128			jsr 	EvaluateIntegerX 			; get value
.01943f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019441	10 03		bpl $019446			bpl 	_UMNotSigned
.019443	20 d0 9c	jsr $019cd0			jsr 	IntegerNegateAlways
.019446					_UMNotSigned:
.019446	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019447					Unary_Usr:
.019447	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX 			; numeric parameter
.01944a	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.01944d	da		phx				phx 								; save XY
.01944e	5a		phy				phy
.01944f	ea		nop				nop
.019450	22 0c 03 00	jsl $00030c			jsl 	UserVector
.019454	7a		ply				ply 								; and exit
.019455	fa		plx				plx
.019456	60		rts				rts
.019457					USRDefault:
.019457	20 4e 85	jsr $01854e			jsr ERR_Handler
>01945a	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019462	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019469					Unary_Val:
.019469	20 31 91	jsr $019131			jsr 	EvaluateStringX 			; get string
.01946c	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; check right bracket.
.01946f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.019471	85 1e		sta $1e				sta 	zGenPtr
.019473	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019475	85 1f		sta $1f				sta 	zGenPtr+1
.019477	5a		phy				phy
.019478	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.01947a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.01947c	f0 54		beq $0194d2			beq 	_UVBadNumber
.01947e	48		pha				pha 								; save length.
.01947f	1a		inc a				inc 	a 							; one for the length, one for the terminator
.019480	1a		inc a				inc 	a
.019481	20 aa 97	jsr $0197aa			jsr 	AllocateTempString
.019484	c8		iny				iny 								; move to the next.
.019485	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.019487	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.019489	8d a0 03	sta $03a0			sta 	ValSign
.01948c	d0 04		bne $019492			bne 	_UVNotMinus
.01948e	c8		iny				iny 								; skip over it.
.01948f	68		pla				pla 								; decrement character count.
.019490	3a		dec a				dec 	a
.019491	48		pha				pha
.019492					_UVNotMinus:
.019492	68		pla				pla 								; this is the count.
.019493	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019494	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019496	c8		iny				iny
.019497	20 d5 97	jsr $0197d5			jsr 	WriteTempString
.01949a	68		pla				pla
.01949b	3a		dec a				dec 	a
.01949c	d0 f5		bne $019493			bne 	_UVCopy
.01949e	20 d5 97	jsr $0197d5			jsr 	WriteTempString 			; make it ASCIIZ
.0194a1	18		clc				clc
.0194a2	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.0194a4	69 01		adc #$01			adc 	#1
.0194a6	85 1e		sta $1e				sta 	zGenPtr
.0194a8	a5 21		lda $21				lda 	zTempStr+1
.0194aa	69 00		adc #$00			adc 	#0
.0194ac	85 1f		sta $1f				sta 	zGenPtr+1
.0194ae	18		clc				clc
.0194af	20 a2 9d	jsr $019da2			jsr 	IntFromString 				; first bit.
.0194b2	b0 1e		bcs $0194d2			bcs 	_UVBadNumber
.0194b4	20 20 a3	jsr $01a320			jsr 	FPFromString				; try for a float part.
.0194b7	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0194ba	d0 10		bne $0194cc			bne 	_UVNotNegative
.0194bc	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0194be	4a		lsr a				lsr 	a
.0194bf	b0 08		bcs $0194c9			bcs 	_UVInteger
.0194c1	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.0194c3	09 80		ora #$80			ora 	#$80
.0194c5	95 85		sta $85,x			sta 	XS_Type,x
.0194c7	80 03		bra $0194cc			bra 	_UVNotNegative
.0194c9					_UVInteger:
.0194c9	20 d0 9c	jsr $019cd0			jsr 	IntegerNegateAlways 		; sign it.
.0194cc					_UVNotNegative:
.0194cc	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.0194ce	d0 02		bne $0194d2			bne 	_UVBadNumber
.0194d0	7a		ply				ply
.0194d1	60		rts				rts
.0194d2					_UVBadNumber:
.0194d2	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0194d5					Unary_Str:
.0194d5	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX 			; numeric parameter
.0194d8	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.0194db	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0194dd	8d 14 03	sta $0314			sta 	NumBufX
.0194e0	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0194e2	4a		lsr a				lsr 	a
.0194e3	b0 05		bcs $0194ea			bcs 	_USInt 						; if msb set do as integer
.0194e5	20 65 a2	jsr $01a265			jsr 	FPToString 					; call fp to str otherwise
.0194e8	80 03		bra $0194ed			bra 	_USDuplicate
.0194ea	20 ed 9c	jsr $019ced	_USInt:	jsr 	IntToString
.0194ed					_USDuplicate:
.0194ed	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0194f0	1a		inc a				inc 	a 							; one more for length
.0194f1	20 aa 97	jsr $0197aa			jsr 	AllocateTempString 			; allocate space for it.
.0194f4	5a		phy				phy 								; save Y
.0194f5	a0 00		ldy #$00			ldy 	#0 							; start copying
.0194f7	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0194fa	20 d5 97	jsr $0197d5			jsr 	WriteTempString
.0194fd	c8		iny				iny
.0194fe	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.019501	d0 f4		bne $0194f7			bne 	_USCopy
.019503	7a		ply				ply 								; restore Y
.019504	4c df 96	jmp $0196df			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019507					Unary_Asc:
.019507	20 31 91	jsr $019131			jsr 	EvaluateStringX 			; string parameter
.01950a	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.01950d	5a		phy				phy 								; get the string length
.01950e	a0 00		ldy #$00			ldy 	#0
.019510	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019512	f0 07		beq $01951b			beq 	_UAIllegal 					; must be at least one character
.019514	c8		iny				iny
.019515	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.019517	7a		ply				ply
.019518	4c 89 93	jmp $019389			jmp 	UnarySetAInteger
.01951b					_UAIllegal:
.01951b	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01951e					Unary_Len:
.01951e	20 31 91	jsr $019131			jsr 	EvaluateStringX 			; string parameter
.019521	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.019524	5a		phy				phy 								; get the string length
.019525	a0 00		ldy #$00			ldy 	#0
.019527	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019529	7a		ply				ply
.01952a	4c 89 93	jmp $019389			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.01952d					Unary_Mid:
.01952d	20 31 91	jsr $019131			jsr 	EvaluateStringX 				; get string.
.019530	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019532	48		pha				pha
.019533	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019535	48		pha				pha
.019536	20 72 97	jsr $019772			jsr 	CheckNextComma 					; skip comma
.019539	20 c2 95	jsr $0195c2			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01953c	48		pha				pha 									; and push it.
.01953d	20 72 97	jsr $019772			jsr 	CheckNextComma 					; skip comma
.019540	20 c2 95	jsr $0195c2			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019543	48		pha				pha 									; and push it.
.019544	80 41		bra $019587			bra 	SLIProcess
.019546					Unary_Left:
.019546	20 31 91	jsr $019131			jsr 	EvaluateStringX 				; get string.
.019549	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01954b	48		pha				pha
.01954c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01954e	48		pha				pha
.01954f	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019551	48		pha				pha
.019552	20 72 97	jsr $019772			jsr 	CheckNextComma 					; skip comma
.019555	20 c2 95	jsr $0195c2			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019558	48		pha				pha 									; and push it.
.019559	80 2c		bra $019587			bra 	SLIProcess
.01955b					Unary_Right:
.01955b	20 31 91	jsr $019131			jsr 	EvaluateStringX 				; get string.
.01955e	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019560	48		pha				pha
.019561	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019563	48		pha				pha
.019564	da		phx				phx 									; get the string length and push on stack.
.019565	a2 00		ldx #$00			ldx 	#0
.019567	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.019569	fa		plx				plx
.01956a	48		pha				pha
.01956b	20 72 97	jsr $019772			jsr 	CheckNextComma 					; skip comma
.01956e	20 c2 95	jsr $0195c2			jsr 	SLIByteParameter 				; get a byte parameter.
.019571	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019574	68		pla				pla 									; restore string length.
.019575	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019576	38		sec				sec
.019577	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.01957a	f0 02		beq $01957e			beq 	_URStart 						; if <= 0 start from 1.
.01957c	10 02		bpl $019580			bpl 	_UROkay
.01957e					_URStart:
.01957e	a9 01		lda #$01			lda 	#1
.019580					_UROkay:
.019580	48		pha				pha 									; push start
.019581	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019584	48		pha				pha
.019585	80 00		bra $019587			bra 	SLIProcess
.019587					SLIProcess:
.019587	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 				; closing right bracket.
.01958a	68		pla				pla
.01958b	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01958e	1a		inc a				inc 	a 								; allocate +1 for it.
.01958f	20 aa 97	jsr $0197aa			jsr 	AllocateTempString
.019592	68		pla				pla 									; pop start number off stack.
.019593	f0 3b		beq $0195d0			beq 	SLIError 						; exit if start = 0
.019595	8d a1 03	sta $03a1			sta 	SliceStart
.019598	68		pla				pla  									; pop string address.
.019599	85 1f		sta $1f				sta 	zGenPtr+1
.01959b	68		pla				pla
.01959c	85 1e		sta $1e				sta 	zGenPtr
.01959e	da		phx				phx
.01959f	5a		phy				phy
.0195a0	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.0195a2	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0195a5					_SLICopy:
.0195a5	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0195a8	f0 12		beq $0195bc			beq 	_SLIExit
.0195aa	ce a2 03	dec $03a2			dec 	SliceCount
.0195ad	98		tya				tya 									; index of character
.0195ae	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0195b0	f0 02		beq $0195b4			beq 	_SLIOk 							; if equal, okay.
.0195b2	b0 08		bcs $0195bc			bcs 	_SLIExit 						; if past end, then exit.
.0195b4	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0195b6	c8		iny				iny
.0195b7	20 d5 97	jsr $0197d5			jsr 	WriteTempString
.0195ba	80 e9		bra $0195a5			bra 	_SLICopy 						; go round till copied characters
.0195bc					_SLIExit:
.0195bc	7a		ply				ply 									; restore YX
.0195bd	fa		plx				plx
.0195be	4c df 96	jmp $0196df			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0195c1	ea		nop				nop
.0195c2					SLIByteParameter:
.0195c2	20 28 91	jsr $019128			jsr 	EvaluateIntegerX 				; get integer
.0195c5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.0195c7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0195c9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0195cb	d0 03		bne $0195d0			bne 	SLIError
.0195cd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195cf	60		rts				rts
.0195d0					SLIError:
.0195d0	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0195d3					Unary_Hex:
.0195d3	20 28 91	jsr $019128			jsr 	EvaluateIntegerX 			; numeric parameter
.0195d6	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.0195d9	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0195db	20 aa 97	jsr $0197aa			jsr 	AllocateTempString			; allocate string space
.0195de	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0195e0	20 04 96	jsr $019604			jsr 	_UHConvert
.0195e3	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195e5	20 04 96	jsr $019604			jsr 	_UHConvert
.0195e8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195ea	20 04 96	jsr $019604			jsr 	_UHConvert
.0195ed	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195ef	20 04 96	jsr $019604			jsr 	_UHConvert
.0195f2	5a		phy				phy 								; get length of new string
.0195f3	a0 00		ldy #$00			ldy 	#0
.0195f5	b1 20		lda ($20),y			lda 	(zTempStr),y
.0195f7	7a		ply				ply
.0195f8	c9 00		cmp #$00			cmp 	#0
.0195fa	d0 05		bne $019601			bne 	_UHExit 					; if it was non zero okay
.0195fc	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0195fe	20 d5 97	jsr $0197d5			jsr 	WriteTempString
.019601					_UHExit:
.019601	4c df 96	jmp $0196df			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019604					_UHConvert:
.019604	48		pha				pha
.019605	4a		lsr a				lsr 	a 							; do MSB
.019606	4a		lsr a				lsr 	a
.019607	4a		lsr a				lsr 	a
.019608	4a		lsr a				lsr 	a
.019609	20 0d 96	jsr $01960d			jsr 	_UHNibble
.01960c	68		pla				pla 								; do LSB
.01960d					_UHNibble:
.01960d	29 0f		and #$0f			and 	#15 						; get nibble
.01960f	d0 0c		bne $01961d			bne 	_UHNonZero
.019611	5a		phy				phy									; get the length
.019612	a0 00		ldy #$00			ldy 	#0
.019614	b1 20		lda ($20),y			lda 	(zTempStr),y
.019616	7a		ply				ply
.019617	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019619	f0 0d		beq $019628			beq 	_UHExit2
.01961b	a9 00		lda #$00			lda 	#0
.01961d					_UHNonZero:
.01961d	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01961f	90 02		bcc $019623			bcc 	_UHDigit
.019621	69 06		adc #$06			adc 	#7-1
.019623					_UHDigit:
.019623	69 30		adc #$30			adc 	#48
.019625	20 d5 97	jsr $0197d5			jsr 	WriteTempString				; output.
.019628					_UHExit2:
.019628	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019629					Unary_Dec:
.019629	20 31 91	jsr $019131			jsr 	EvaluateStringX 			; string parameter
.01962c	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.01962f	5a		phy				phy
.019630	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019632	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019634	f0 41		beq $019677			beq 	_UDFail 					; must fail if zero.
.019636	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.019639	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.01963b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01963d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01963f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019641	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019643	a9 01		lda #$01			lda 	#1
.019645	95 85		sta $85,x			sta 	XS_Type,x
.019647					_UDConvertLoop:
.019647	5a		phy				phy 								; shift mantissa left 4
.019648	a0 04		ldy #$04			ldy 	#4
.01964a					_UDShift:
.01964a	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01964c	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01964e	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019650	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019652	88		dey				dey
.019653	d0 f5		bne $01964a			bne 	_UDShift
.019655	7a		ply				ply
.019656	c8		iny				iny 								; next character
.019657	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019659	20 7a 96	jsr $01967a			jsr 	ConvertUpper 				; convert to U/C
.01965c	c9 30		cmp #$30			cmp 	#"0"
.01965e	90 17		bcc $019677			bcc 	_UDFail
.019660	c9 3a		cmp #$3a			cmp 	#"9"+1
.019662	90 06		bcc $01966a			bcc 	_UDOkay
.019664	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.019666	c9 10		cmp #$10			cmp 	#16
.019668	b0 0d		bcs $019677			bcs 	_UDFail
.01966a					_UDOkay:
.01966a	29 0f		and #$0f			and 	#15 						; nibble only
.01966c	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01966e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019670	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.019673	d0 d2		bne $019647			bne 	_UDConvertLoop
.019675	7a		ply				ply
.019676	60		rts				rts
.019677					_UDFail:
.019677	4c 3d 85	jmp $01853d			jmp 	BadParamError
.01967a					ConvertUpper:
.01967a	c9 61		cmp #$61			cmp 	#"a"
.01967c	90 07		bcc $019685			bcc 	_CUExit
.01967e	c9 7b		cmp #$7b			cmp 	#"z"+1
.019680	b0 03		bcs $019685			bcs 	_CUExit
.019682	38		sec				sec
.019683	e9 20		sbc #$20			sbc 	#32
.019685	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019686					Unary_Chr:
.019686	20 28 91	jsr $019128			jsr 	EvaluateIntegerX			; numeric parameter
.019689	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; right bracket.
.01968c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01968e	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019690	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019692	d0 0d		bne $0196a1			bne 	_UCChar
.019694	a9 01		lda #$01			lda 	#1 							; one character string
.019696	20 aa 97	jsr $0197aa			jsr 	AllocateTempString
.019699	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01969b	20 d5 97	jsr $0197d5			jsr 	WriteTempString
.01969e	4c df 96	jmp $0196df			jmp 	UnaryReturnTempStr
.0196a1					_UCChar:
.0196a1	4c 3d 85	jmp $01853d			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0196a4					Unary_Spc:
.0196a4	20 c2 95	jsr $0195c2			jsr 	SLIByteParameter 			; check space.
.0196a7	20 6a 97	jsr $01976a			jsr 	CheckNextRParen
.0196aa	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0196ac					UnarySpcCreate:
.0196ac	c9 fe		cmp #$fe			cmp 	#maxString+1
.0196ae	b0 14		bcs $0196c4			bcs 	_USSize
.0196b0	48		pha				pha 								; save length
.0196b1	1a		inc a				inc 	a 							; allocate one more.
.0196b2	20 aa 97	jsr $0197aa			jsr 	AllocateTempString
.0196b5	68		pla				pla 								; get length
.0196b6	f0 27		beq $0196df			beq 	UnaryReturnTempStr 			; return the current temp string
.0196b8					_USLoop:
.0196b8	48		pha				pha
.0196b9	a9 20		lda #$20			lda 	#" "
.0196bb	20 d5 97	jsr $0197d5			jsr 	WriteTempString
.0196be	68		pla				pla
.0196bf	3a		dec a				dec 	a
.0196c0	d0 f6		bne $0196b8			bne 	_USLoop
.0196c2	80 1b		bra $0196df			bra 	UnaryReturnTempStr
.0196c4					_USSize:
.0196c4	4c 3d 85	jmp $01853d			jmp 	BadParamError
.0196c7					Unary_Tab:
.0196c7	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.0196c9	20 c2 95	jsr $0195c2			jsr 	SLIByteParameter
.0196cc	20 6a 97	jsr $01976a			jsr 	CheckNextRParen
.0196cf	20 1b 85	jsr $01851b			jsr 	CharGetPosition 			; were are we ?
.0196d2	85 10		sta $10				sta 	zTemp1
.0196d4	38		sec				sec
.0196d5	a5 80		lda $80				lda 	XS_Mantissa+0 				; return chars required.
.0196d7	e5 10		sbc $10				sbc 	zTemp1
.0196d9	b0 d1		bcs $0196ac			bcs 	UnarySpcCreate
.0196db	a9 00		lda #$00			lda 	#0
.0196dd	80 cd		bra $0196ac			bra 	UnarySpcCreate
.0196df					UnaryReturnTempStr:
.0196df	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0196e1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196e3	a5 21		lda $21				lda 	zTempStr+1
.0196e5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196e7	a9 02		lda #$02			lda 	#2 							; set type to string
.0196e9	95 85		sta $85,x			sta 	XS_Type,x
.0196eb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0196ec					MemRead:
.0196ec	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0196ef	a0 00		ldy #$00			ldy 	#0 							; start from here
.0196f1	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0196f3	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0196f5	c8		iny				iny 								; next to copy
.0196f6	e8		inx				inx
.0196f7	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0196fa	d0 f5		bne $0196f1			bne 	_MLoop1
.0196fc	60		rts				rts
.0196fd					MemWrite:
.0196fd	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.019700	a0 00		ldy #$00			ldy 	#0 							; start from here
.019702	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019704	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.019706	c8		iny				iny 								; next to copy
.019707	e8		inx				inx
.019708	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.01970b	d0 f5		bne $019702			bne 	_MLoop1
.01970d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01970e					UpdateProgramEnd:
.01970e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019710	85 16		sta $16				sta 	zCodePtr+0
.019712	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019714	85 17		sta $17				sta 	zCodePtr+1
.019716	a9 00		lda #$00			lda 	#0
.019718	85 18		sta $18				sta 	zCodePtr+2
.01971a	85 19		sta $19				sta 	zCodePtr+3
.01971c	a0 03		ldy #$03			ldy 	#3
.01971e					_UPDLoop:
.01971e	a0 00		ldy #$00			ldy 	#0
.019720	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019722	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019724	f0 0f		beq $019735			beq 	_UPDFoundEnd
.019726	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019728	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01972a	18		clc				clc
.01972b	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01972d	85 16		sta $16				sta 	zCodePtr
.01972f	90 02		bcc $019733			bcc 	_SNLNoCarry
.019731	e6 17		inc $17				inc 	zCodePtr+1
.019733					_SNLNoCarry:
.019733	80 e9		bra $01971e			bra 	_UPDLoop
.019735					_UPDFoundEnd:
.019735	18		clc				clc 								; end of program 2 on.
.019736	a5 16		lda $16				lda 	zCodePtr
.019738	69 02		adc #$02			adc 	#2
.01973a	8d 04 03	sta $0304			sta 	endOfProgram
.01973d	a5 17		lda $17				lda 	zCodePtr+1
.01973f	69 00		adc #$00			adc 	#0
.019741	8d 05 03	sta $0305			sta 	endOfProgram+1
.019744	a5 18		lda $18				lda 	zCodePtr+2
.019746	69 00		adc #$00			adc		#0
.019748	8d 06 03	sta $0306			sta 	endOfProgram+2
.01974b	a5 19		lda $19				lda 	zCodePtr+3
.01974d	69 00		adc #$00			adc 	#0
.01974f	8d 07 03	sta $0307			sta 	endOfProgram+3
.019752	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019753					CheckNextToken:
.019753	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019755	d0 02		bne $019759			bne 	CTFail 						; no, then fail
.019757	c8		iny				iny
.019758	60		rts				rts
.019759					CTFail:
.019759	20 4e 85	jsr $01854e			jsr ERR_Handler
>01975c	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019764	74 6f 6b 65 6e 00
.01976a					CheckNextRParen:
.01976a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01976c	c9 be		cmp #$be			cmp 	#token_rparen
.01976e	d0 e9		bne $019759			bne 	CTFail
.019770	c8		iny				iny
.019771	60		rts				rts
.019772					CheckNextComma:
.019772	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019774	c9 bf		cmp #$bf			cmp 	#token_comma
.019776	d0 e1		bne $019759			bne 	CTFail
.019778	c8		iny				iny
.019779	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01977a					StringConcrete:
.01977a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.01977c	85 10		sta $10				sta 	zTemp1
.01977e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019780	85 11		sta $11				sta 	zTemp1+1
.019782	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019784	18		clc				clc 								; from the string pointer
.019785	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019788	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.01978a	8d 00 03	sta $0300			sta 	StringPtr
.01978d	85 12		sta $12				sta 	zTemp2
.01978f	ad 01 03	lda $0301			lda 	StringPtr+1
.019792	e9 00		sbc #$00			sbc 	#0
.019794	8d 01 03	sta $0301			sta 	StringPtr+1
.019797	85 13		sta $13				sta 	zTemp2+1
.019799	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.01979b	1a		inc a				inc 	a
.01979c	aa		tax				tax
.01979d	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.01979f	91 12		sta ($12),y			sta 	(zTemp2),y
.0197a1	c8		iny				iny
.0197a2	ca		dex				dex
.0197a3	d0 f8		bne $01979d			bne 	_SCCopy
.0197a5	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.0197a7	a6 12		ldx $12				ldx 	zTemp2
.0197a9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.0197aa					AllocateTempString:
.0197aa	48		pha				pha 								; save required count.
.0197ab	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.0197ad	d0 0b		bne $0197ba			bne 	_ATSInitialised
.0197af	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.0197b2	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0197b4	ad 01 03	lda $0301			lda 	StringPtr+1
.0197b7	3a		dec a				dec 	a
.0197b8	85 21		sta $21				sta 	zTempStr+1
.0197ba					_ATSInitialised:
.0197ba	68		pla				pla 								; get required count back.
.0197bb	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0197bd	1a		inc a				inc 	a
.0197be	18		clc				clc
.0197bf	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0197c1	85 20		sta $20				sta 	zTempStr
.0197c3	a9 ff		lda #$ff			lda 	#$FF
.0197c5	65 21		adc $21				adc 	zTempStr+1
.0197c7	85 21		sta $21				sta 	zTempStr+1
.0197c9	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0197cb	5a		phy				phy
.0197cc	a8		tay				tay
.0197cd	91 20		sta ($20),y			sta 	(zTempStr),y
.0197cf	7a		ply				ply
.0197d0	1a		inc a				inc 	a 							; reset the write index.
.0197d1	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0197d4	60		rts				rts
.0197d5					WriteTempString:
.0197d5	5a		phy				phy 								; save Y
.0197d6	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0197d9	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0197db	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0197de	98		tya				tya 								; unchanged Y is now length
.0197df	a0 00		ldy #$00			ldy 	#0
.0197e1	91 20		sta ($20),y			sta 	(zTempStr),y
.0197e3	7a		ply				ply 								; restore Y and exit
.0197e4	60		rts				rts
.0197e5					CreateTempStringCopy:
.0197e5	da		phx				phx 								; save X
.0197e6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197e8	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0197e9	20 aa 97	jsr $0197aa			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0197ec	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197ee	c8		iny				iny
.0197ef	3a		dec a				dec 	a 							; make the actual length in charactes
.0197f0	3a		dec a				dec 	a
.0197f1	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0197f3	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0197f5	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0197f7	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0197f9	f0 0e		beq $019809			beq 	_CTSCExit
.0197fb					_CTSCLoop:
.0197fb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0197fd	c8		iny				iny
.0197fe	5a		phy				phy 								; save in Y
.0197ff	e8		inx				inx 								; bump index
.019800	da		phx				phx 								; index into Y
.019801	7a		ply				ply
.019802	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.019804	7a		ply				ply 								; restore Y
.019805	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.019807	d0 f2		bne $0197fb			bne 	_CTSCLoop
.019809					_CTSCExit:
.019809	fa		plx				plx 								; restore X
.01980a	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.01980b					VariableFind:
.01980b	20 76 98	jsr $019876			jsr 	VariableExtract 		; find out all about it ....
.01980e	20 0f 9b	jsr $019b0f			jsr 	VariableLocate 			; does it already exist ?
.019811	b0 03		bcs $019816			bcs 	_VFExists 				; if so, use that.
.019813	20 02 99	jsr $019902			jsr 	VariableCreate 			; otherwise create it.
.019816					_VFExists:
.019816	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019818	29 01		and #$01			and 	#1
.01981a	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01981c	d0 28		bne $019846			bne 	_VFSingleElement
.01981e					_VFNextIndex:
.01981e	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019820	48		pha				pha
.019821	a5 23		lda $23				lda 	zVarDataPtr+1
.019823	48		pha				pha
.019824	a5 24		lda $24				lda 	zVarType
.019826	48		pha				pha
.019827	20 28 91	jsr $019128			jsr 	EvaluateIntegerX 		; calculate the index.
.01982a	68		pla				pla 							; restore and index.
.01982b	85 24		sta $24				sta 	zVarType
.01982d	68		pla				pla
.01982e	85 23		sta $23				sta 	zVarDataPtr+1
.019830	68		pla				pla
.019831	85 22		sta $22				sta 	zVarDataPtr
.019833	20 8d 99	jsr $01998d			jsr 	ArrayIndexFollow 		; do the index.
.019836	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019838	29 01		and #$01			and 	#1
.01983a	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.01983c	d0 05		bne $019843			bne 	_VFArrayDone 			; if so then exit.
.01983e	20 72 97	jsr $019772			jsr 	CheckNextComma 			; comma should follow
.019841	80 db		bra $01981e			bra 	_VFNextIndex
.019843					_VFArrayDone:
.019843	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 		; check closing right bracket.
.019846					_VFSingleElement:
.019846	60		rts				rts
.019847					VariableClear:
.019847	48		pha				pha 							; save registers
.019848	da		phx				phx
.019849	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.01984b	8a		txa				txa
.01984c	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.01984f	e8		inx				inx
.019850	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019852	d0 f8		bne $01984c			bne 	_VCLoop
.019854	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019856	8d 02 03	sta $0302			sta 	VarMemPtr
.019859	a9 30		lda #$30			lda 	#VariableMemory >> 8
.01985b	8d 03 03	sta $0303			sta 	VarMemPtr+1
.01985e	fa		plx				plx 							; restore registers
.01985f	68		pla				pla
.019860	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019861					VariableNameError:
.019861	20 4e 85	jsr $01854e			jsr ERR_Handler
>019864	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>01986c	61 62 6c 65 20 4e 61 6d 65 00
.019876					VariableExtract:
.019876	da		phx				phx 							; save X.
.019877	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019879	8d 95 03	sta $0395			sta 	Var_Type
.01987c	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.01987f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019881	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019883	f0 dc		beq $019861			beq 	VariableNameError
.019885	c9 1b		cmp #$1b			cmp 	#26+1
.019887	b0 d8		bcs $019861			bcs 	VariableNameError
.019889	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.01988b					_VECopyBuffer:
.01988b	e8		inx				inx
.01988c	e0 1f		cpx #$1f			cpx 	#31 					; too long
.01988e	f0 d1		beq $019861			beq 	VariableNameError
.019890	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019893	18		clc				clc  							; update the hash value for it.
.019894	6d 96 03	adc $0396			adc 	Var_Hash
.019897	8d 96 03	sta $0396			sta 	Var_Hash
.01989a	c8		iny				iny
.01989b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01989d	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.01989f	f0 0e		beq $0198af			beq 	_VECopyEnd
.0198a1	30 0c		bmi $0198af			bmi 	_VECopyEnd
.0198a3	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.0198a5	90 e4		bcc $01988b			bcc 	_VECopyBuffer
.0198a7	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.0198a9	90 04		bcc $0198af			bcc 	_VECopyEnd
.0198ab	c9 3a		cmp #$3a			cmp 	#"9"+1
.0198ad	90 dc		bcc $01988b			bcc 	_VECopyBuffer
.0198af					_VECopyEnd:
.0198af	c8		iny				iny
.0198b0	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.0198b2	90 04		bcc $0198b8			bcc 	_VEDefaultRequired
.0198b4	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.0198b6	90 0b		bcc $0198c3			bcc 	_VEHaveType
.0198b8					_VEDefaultRequired:
.0198b8	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0198ba	f0 04		beq $0198c0			beq 	_VESetType 				; default set above.
.0198bc	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.0198bf	88		dey				dey
.0198c0					_VESetType:
.0198c0	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.0198c3					_VEHaveType:
.0198c3	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.0198c6	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0198c9	09 80		ora #$80			ora 	#$80
.0198cb	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.0198ce	e8		inx				inx 							; offset 3 => length 4.
.0198cf	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.0198d2	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.0198d5	38		sec				sec
.0198d6	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0198d8	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0198d9	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0198da	0a		asl a				asl 	a
.0198db	0a		asl a				asl 	a
.0198dc	8d 98 03	sta $0398			sta 	Var_HashAddress
.0198df	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.0198e2	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0198e4	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0198e5	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.0198e8	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0198ea	8d 98 03	sta $0398			sta 	Var_HashAddress
.0198ed	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0198ef	ad 95 03	lda $0395			lda 	Var_Type
.0198f2	c9 b9		cmp #$b9			cmp 	#token_Hash
.0198f4	f0 07		beq $0198fd			beq 	_VEHaveSize
.0198f6	ca		dex				dex
.0198f7	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0198f9	f0 02		beq $0198fd			beq 	_VEHaveSize
.0198fb	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0198fd					_VEHaveSize:
.0198fd	8e 99 03	stx $0399			stx 	Var_DataSize
.019900	fa		plx				plx
.019901	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019902					VariableCreate:
.019902	da		phx				phx
.019903	5a		phy				phy
.019904	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019907	85 10		sta $10				sta 	zTemp1
.019909	ad 03 03	lda $0303			lda 	VarMemPtr+1
.01990c	85 11		sta $11				sta 	zTemp1+1
.01990e	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019911	18		clc				clc
.019912	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019915	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019917	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.01991a	8d 02 03	sta $0302			sta 	VarMemPtr
.01991d	90 03		bcc $019922			bcc 	_VCNoCarry
.01991f	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019922					_VCNoCarry:
.019922	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019925	85 12		sta $12				sta 	zTemp2
.019927	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019929	85 13		sta $13				sta 	zTemp2+1
.01992b	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.01992d	b1 12		lda ($12),y			lda 	(zTemp2),y
.01992f	91 10		sta ($10),y			sta 	(zTemp1),y
.019931	c8		iny				iny
.019932	b1 12		lda ($12),y			lda 	(zTemp2),y
.019934	91 10		sta ($10),y			sta 	(zTemp1),y
.019936	c8		iny				iny
.019937	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.01993a	91 10		sta ($10),y			sta 	(zTemp1),y
.01993c	c8		iny				iny
.01993d	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.01993f					_VCCopyName:
.01993f	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019942	91 10		sta ($10),y			sta 	(zTemp1),y
.019944	e8		inx				inx
.019945	c8		iny				iny
.019946	ec 97 03	cpx $0397			cpx 	Var_Length
.019949	d0 f4		bne $01993f			bne 	_VCCopyName
.01994b	5a		phy				phy 								; save the data offset.
.01994c	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.01994f	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019951					_VCClearData:
.019951	91 10		sta ($10),y			sta 	(zTemp1),y
.019953	c8		iny				iny
.019954	ca		dex				dex
.019955	d0 fa		bne $019951			bne 	_VCClearData
.019957	68		pla				pla 								; offset to the data
.019958	18		clc				clc
.019959	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.01995b	85 22		sta $22				sta 	zVarDataPtr
.01995d	a5 11		lda $11				lda 	zTemp1+1
.01995f	69 00		adc #$00			adc 	#0
.019961	85 23		sta $23				sta 	zVarDataPtr+1
.019963	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019966	85 24		sta $24				sta 	zVarType
.019968	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.01996a	a0 00		ldy #$00			ldy 	#0
.01996c	91 12		sta ($12),y			sta 	(zTemp2),y
.01996e	c8		iny				iny
.01996f	a5 11		lda $11				lda 	zTemp1+1
.019971	91 12		sta ($12),y			sta 	(zTemp2),y
.019973	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019976	29 01		and #$01			and 	#1
.019978	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.01997a	d0 0e		bne $01998a			bne 	_VCNotArray
.01997c	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.01997e	20 24 9a	jsr $019a24			jsr 	ArrayCreate
.019981	5a		phy				phy 								; save YA at zVarDataPtr
.019982	a0 00		ldy #$00			ldy 	#0
.019984	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019986	c8		iny				iny
.019987	68		pla				pla
.019988	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01998a					_VCNotArray:
.01998a	7a		ply				ply
.01998b	fa		plx				plx
.01998c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.01998d					ArrayIndexFollow:
.01998d	5a		phy				phy
.01998e	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019990	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019992	48		pha				pha
.019993	c8		iny				iny
.019994	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019996	85 23		sta $23				sta 	zVarDataPtr+1
.019998	68		pla				pla
.019999	85 22		sta $22				sta 	zVarDataPtr
.01999b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.01999d	29 80		and #$80			and 	#$80 						; must be zero.
.01999f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0199a1	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0199a3	d0 59		bne $0199fe			bne 	_AIFError
.0199a5	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.0199a7	18		clc				clc
.0199a8	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0199aa	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.0199ac	c8		iny				iny
.0199ad	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.0199af	08		php				php 								; clear bit 7 retaining borrow.
.0199b0	29 7f		and #$7f			and 	#$7F
.0199b2	28		plp				plp
.0199b3	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.0199b5	90 47		bcc $0199fe			bcc 	_AIFError 					; eror if size-current < 0
.0199b7	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.0199b9	0a		asl a				asl 	a 							; (e.g. index * 2)
.0199ba	85 10		sta $10				sta 	zTemp1
.0199bc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199be	2a		rol a				rol 	a
.0199bf	85 11		sta $11				sta 	zTemp1+1
.0199c1	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.0199c3	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.0199c5	30 1d		bmi $0199e4			bmi 	_AIFCalculate
.0199c7	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.0199c9	a5 24		lda $24				lda 	zVarType 					; check that type
.0199cb	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.0199cd	f0 15		beq $0199e4			beq 	_AIFCalculate
.0199cf	06 10		asl $10				asl 	zTemp1			 			; double the index
.0199d1	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.0199d3	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.0199d5	f0 0d		beq $0199e4			beq 	_AIFCalculate
.0199d7	18		clc				clc 								; add the original mantissa in again
.0199d8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0199da	65 10		adc $10				adc 	zTemp1
.0199dc	85 10		sta $10				sta 	zTemp1
.0199de	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199e0	65 11		adc $11				adc 	zTemp1+1
.0199e2	85 11		sta $11				sta 	zTemp1+1
.0199e4					_AIFCalculate:
.0199e4	18		clc				clc 								; add index x 2,4 or 5 to base
.0199e5	a5 22		lda $22				lda 	zVarDataPtr
.0199e7	65 10		adc $10				adc 	zTemp1
.0199e9	85 22		sta $22				sta 	zVarDataPtr
.0199eb	a5 23		lda $23				lda 	zVarDataPtr+1
.0199ed	65 11		adc $11				adc 	zTemp1+1
.0199ef	85 23		sta $23				sta 	zVarDataPtr+1
.0199f1	18		clc				clc 								; add 2 more for the length prefix.
.0199f2	a5 22		lda $22				lda 	zVarDataPtr
.0199f4	69 02		adc #$02			adc 	#2
.0199f6	85 22		sta $22				sta 	zVarDataPtr
.0199f8	90 02		bcc $0199fc			bcc 	_AIFNoBump
.0199fa	e6 23		inc $23				inc 	zVarDataPtr+1
.0199fc					_AIFNoBump:
.0199fc	7a		ply				ply
.0199fd	60		rts				rts
.0199fe					_AIFError:
.0199fe	20 4e 85	jsr $01854e			jsr ERR_Handler
>019a01	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019a09	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019a11					ArrayResetDefault:
.019a11	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019a13	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019a16	a9 00		lda #$00			lda 	#0
.019a18	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019a1b	a9 ff		lda #$ff			lda 	#$FF
.019a1d	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019a20	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019a23	60		rts				rts
.019a24					ArrayCreate:
.019a24	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019a27	0a		asl a				asl 	a
.019a28	85 10		sta $10				sta 	zTemp1
.019a2a	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019a2d	2a		rol a				rol 	a
.019a2e	85 11		sta $11				sta 	zTemp1+1
.019a30	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019a33	10 22		bpl $019a57			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019a35	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019a38	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019a3a	f0 1b		beq $019a57			beq 	_ACSized
.019a3c	06 10		asl $10				asl 	zTemp1 						; double again
.019a3e	26 11		rol $11				rol 	zTemp1+1
.019a40	b0 6f		bcs $019ab1			bcs 	ArrayIndexError 			; too large.
.019a42	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019a44	f0 11		beq $019a57			beq 	_ACSized
.019a46	18		clc				clc 								; add original value x 5 for reals.
.019a47	a5 10		lda $10				lda 	zTemp1
.019a49	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019a4c	85 10		sta $10				sta 	zTemp1
.019a4e	a5 11		lda $11				lda 	zTemp1+1
.019a50	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019a53	85 11		sta $11				sta 	zTemp1+1
.019a55	b0 5a		bcs $019ab1			bcs 	ArrayIndexError
.019a57					_ACSized:
.019a57	18		clc				clc
.019a58	a5 10		lda $10				lda 	zTemp1
.019a5a	69 02		adc #$02			adc 	#2
.019a5c	85 10		sta $10				sta 	zTemp1
.019a5e	90 04		bcc $019a64			bcc 	_ACNoBump
.019a60	e6 10		inc $10				inc 	zTemp1
.019a62	f0 4d		beq $019ab1			beq 	ArrayIndexError
.019a64					_ACNoBump:
.019a64	18		clc				clc
.019a65	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019a68	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019a6a	85 14		sta $14				sta 	zTemp3
.019a6c	65 10		adc $10				adc 	zTemp1
.019a6e	8d 02 03	sta $0302			sta 	VarMemPtr
.019a71	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019a74	85 13		sta $13				sta 	zTemp2+1
.019a76	85 15		sta $15				sta 	zTemp3+1
.019a78	65 11		adc $11				adc 	zTemp1+1
.019a7a	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019a7d	85 11		sta $11				sta 	zTemp1+1
.019a7f	b0 30		bcs $019ab1			bcs 	ArrayIndexError
.019a81	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019a83					_ACClear:
.019a83	98		tya				tya
.019a84	91 12		sta ($12),y			sta 	(zTemp2),y
.019a86	e6 12		inc $12				inc 	zTemp2
.019a88	d0 02		bne $019a8c			bne 	_ACCBump
.019a8a	e6 13		inc $13				inc 	zTemp2+1
.019a8c					_ACCBump:
.019a8c	a5 12		lda $12				lda 	zTemp2
.019a8e	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019a91	d0 f0		bne $019a83			bne 	_ACClear
.019a93	a5 13		lda $13				lda 	zTemp2+1
.019a95	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019a98	d0 e9		bne $019a83			bne 	_ACClear
.019a9a	a0 00		ldy #$00			ldy 	#0
.019a9c	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019a9f	91 14		sta ($14),y			sta 	(zTemp3),y
.019aa1	c8		iny				iny
.019aa2	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019aa5	91 14		sta ($14),y			sta 	(zTemp3),y
.019aa7	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019aaa	10 18		bpl $019ac4			bpl 	ACCFillRecursive
.019aac	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019aae	a5 14		lda $14				lda 	zTemp3
.019ab0	60		rts				rts
.019ab1					ArrayIndexError:
.019ab1	20 4e 85	jsr $01854e			jsr ERR_Handler
>019ab4	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019abc	79 20 69 6e 64 65 78 00
.019ac4					ACCFillRecursive:
.019ac4	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019ac6	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019ac8	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019aca	c8		iny				iny
.019acb	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019acd	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019acf	91 14		sta ($14),y			sta 	(zTemp3),y
.019ad1	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019ad3	48		pha				pha
.019ad4	a5 15		lda $15				lda 	zTemp3+1
.019ad6	48		pha				pha
.019ad7					_ACCFillLoop:
.019ad7	18		clc				clc
.019ad8	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019ada	69 02		adc #$02			adc 	#2
.019adc	85 14		sta $14				sta 	zTemp3
.019ade	90 02		bcc $019ae2			bcc 	_ACCSkip2
.019ae0	e6 15		inc $15				inc 	zTemp3+1
.019ae2					_ACCSkip2:
.019ae2	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019ae4	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019ae6	c8		iny				iny
.019ae7	11 14		ora ($14),y			ora 	(zTemp3),y
.019ae9	d0 21		bne $019b0c			bne 	_ACCExit
.019aeb	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019aed	48		pha				pha
.019aee	a5 15		lda $15				lda 	zTemp3+1
.019af0	48		pha				pha
.019af1	e8		inx				inx
.019af2	e8		inx				inx
.019af3	20 24 9a	jsr $019a24			jsr 	ArrayCreate 				; create array recursively.
.019af6	ca		dex				dex
.019af7	ca		dex				dex
.019af8	85 12		sta $12				sta 	zTemp2 						; save A
.019afa	68		pla				pla
.019afb	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019afd	68		pla				pla
.019afe	85 14		sta $14				sta 	zTemp3
.019b00	98		tya				tya 								; write high bye from Y
.019b01	a0 01		ldy #$01			ldy 	#1
.019b03	91 14		sta ($14),y			sta 	(zTemp3),y
.019b05	88		dey				dey 								; write low byte out.
.019b06	a5 12		lda $12				lda 	zTemp2
.019b08	91 14		sta ($14),y			sta 	(zTemp3),y
.019b0a	80 cb		bra $019ad7			bra 	_ACCFillLoop 				; and try again.
.019b0c					_ACCExit:
.019b0c	7a		ply				ply 								; restore the original address
.019b0d	68		pla				pla
.019b0e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019b0f					VariableLocate:
.019b0f	da		phx				phx
.019b10	5a		phy				phy
.019b11	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019b14	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019b16	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019b18	85 13		sta $13				sta 	zTemp2+1
.019b1a	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019b1c	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b1e	aa		tax				tax
.019b1f	c8		iny				iny
.019b20	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b22	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019b24	86 12		stx $12				stx 	zTemp2
.019b26	05 12		ora $12				ora 	zTemp2 						; got zero
.019b28	18		clc				clc
.019b29	f0 25		beq $019b50			beq 	_VLExit 					; if so, then fail as end of chain.
.019b2b	c8		iny				iny 								; point to hash (offset + 2)
.019b2c	b1 12		lda ($12),y			lda 	(zTemp2),y
.019b2e	cd 96 03	cmp $0396			cmp 	Var_Hash
.019b31	d0 e7		bne $019b1a			bne 	_VLNext 					; try next if different.
.019b33					_VLCompare:
.019b33	c8		iny				iny 								; next character
.019b34	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019b36	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019b39	d0 df		bne $019b1a			bne 	_VLNext 					; fail if different, try next.
.019b3b	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019b3c	90 f5		bcc $019b33			bcc 	_VLCompare
.019b3e	98		tya				tya
.019b3f	38		sec				sec 								; add 1 as Y points to last character
.019b40	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019b42	85 22		sta $22				sta 	zVarDataPtr
.019b44	a5 13		lda $13				lda 	zTemp2+1
.019b46	69 00		adc #$00			adc 	#0
.019b48	85 23		sta $23				sta 	zVarDataPtr+1
.019b4a	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019b4d	85 24		sta $24				sta 	zVarType
.019b4f	38		sec				sec 								; return CS
.019b50	7a		ply		_VLExit:ply
.019b51	fa		plx				plx
.019b52	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019b53					VariableGet:
.019b53	5a		phy				phy
.019b54	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019b56	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b58	95 80		sta $80,x			sta 	XS_Mantissa,x
.019b5a	c8		iny				iny
.019b5b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b5d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b5f	c8		iny				iny
.019b60	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.019b62	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019b64	f0 2c		beq $019b92			beq 	_VGString
.019b66	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019b68	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b6a	c8		iny				iny
.019b6b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019b6d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b6f	c8		iny				iny
.019b70	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019b72	95 85		sta $85,x			sta 	XS_Type,x
.019b74	a5 24		lda $24				lda 	zVarType
.019b76	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019b78	f0 28		beq $019ba2			beq 	_VGExit
.019b7a	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019b7c	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019b7e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019b80	95 84		sta $84,x			sta 	XS_Exponent,x
.019b82	f0 1e		beq $019ba2			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019b84	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019b86	48		pha				pha
.019b87	29 80		and #$80			and 	#$80
.019b89	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019b8b	68		pla				pla
.019b8c	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019b8e	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.019b90	80 10		bra $019ba2			bra 	_VGExit
.019b92					_VGString:
.019b92	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019b94	95 85		sta $85,x			sta 	XS_Type,x
.019b96	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019b98	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019b9a	d0 06		bne $019ba2			bne 	_VGExit 					; if not, exit.
.019b9c	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.019b9e	a9 25		lda #$25			lda 	#zNullString
.019ba0	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.019ba2					_VGExit:
.019ba2	7a		ply				ply
.019ba3	60		rts				rts
.019ba4					VariableSet:
.019ba4	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019ba6	29 02		and #$02			and 	#2 							; if so, it has to be
.019ba8	d0 4b		bne $019bf5			bne 	_VSString
.019baa	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019bac	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019bae	f0 42		beq $019bf2			beq 	_VSBadType
.019bb0	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.019bb2	f0 05		beq $019bb9			beq 	_VSMakeInt
.019bb4	20 1a a1	jsr $01a11a			jsr 	FPUToFloat
.019bb7	80 03		bra $019bbc			bra 	_VSCopy
.019bb9					_VSMakeInt:
.019bb9	20 66 a1	jsr $01a166			jsr 	FPUToInteger
.019bbc					_VSCopy:
.019bbc	5a		phy				phy
.019bbd	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.019bbf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019bc1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bc3	c8		iny				iny
.019bc4	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019bc6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bc8	c8		iny				iny
.019bc9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019bcb	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bcd	c8		iny				iny
.019bce	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019bd0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bd2	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.019bd4	c9 bb		cmp #$bb			cmp 	#token_Percent
.019bd6	f0 18		beq $019bf0			beq 	_VSExit
.019bd8	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.019bda	0a		asl a				asl 	a
.019bdb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.019bdd	08		php				php
.019bde	0a		asl a				asl 	a
.019bdf	28		plp				plp
.019be0	6a		ror a				ror 	a
.019be1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019be3	c8		iny				iny
.019be4	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.019be6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019be8	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.019bea	50 04		bvc $019bf0			bvc 	_VSExit
.019bec	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.019bee	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019bf0					_VSExit:
.019bf0	7a		ply				ply
.019bf1	60		rts				rts
.019bf2					_VSBadType:
.019bf2	4c 2f 85	jmp $01852f			jmp 	TypeError
.019bf5					_VSString:
.019bf5	a5 24		lda $24				lda 	zVarType 					; type must be $
.019bf7	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019bf9	d0 f7		bne $019bf2			bne 	_VSBadType
.019bfb	da		phx				phx
.019bfc	5a		phy				phy
.019bfd	20 7a 97	jsr $01977a			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019c00	a0 01		ldy #$01			ldy 	#1 							; save high byte
.019c02	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c04	88		dey				dey 								; save low byte
.019c05	8a		txa				txa
.019c06	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019c08	7a		ply				ply 								; and exit.
.019c09	fa		plx				plx
.019c0a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019c0b					MulInteger32:
.019c0b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019c0d	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.019c0f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c11	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019c13	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019c15	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019c17	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019c19	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019c1b	a9 00		lda #$00			lda 	#0
.019c1d	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019c1f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c21	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c23	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c25					_BFMMultiply:
.019c25	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019c27	29 01		and #$01			and 	#1
.019c29	f0 03		beq $019c2e			beq 	_BFMNoAdd
.019c2b	20 c6 92	jsr $0192c6			jsr 	AddInteger32
.019c2e					_BFMNoAdd:
.019c2e	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019c30	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019c32	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019c34	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019c36	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019c38	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019c3a	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019c3c	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019c3e	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019c40	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019c42	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019c44	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019c46	d0 dd		bne $019c25			bne 	_BFMMultiply
.019c48	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019c49					DivInteger32:
.019c49	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019c4b	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019c4d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019c4f	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019c51	d0 14		bne $019c67			bne 	_BFDOkay
.019c53	20 4e 85	jsr $01854e			jsr ERR_Handler
>019c56	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019c5e	20 62 79 20 5a 65 72 6f 00
.019c67					_BFDOkay:
.019c67	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019c69	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019c6b	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019c6d	85 1c		sta $1c				sta 	zLTemp1+2
.019c6f	85 1d		sta $1d				sta 	zLTemp1+3
.019c71	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019c74	20 cb 9c	jsr $019ccb			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019c77	da		phx				phx
.019c78	e8		inx				inx
.019c79	e8		inx				inx
.019c7a	e8		inx				inx
.019c7b	e8		inx				inx
.019c7c	e8		inx				inx
.019c7d	e8		inx				inx
.019c7e	20 cb 9c	jsr $019ccb			jsr 	CheckIntegerNegate
.019c81	fa		plx				plx
.019c82	5a		phy				phy 								; Y is the counter
.019c83	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019c85					_BFDLoop:
.019c85	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019c87	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019c89	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019c8b	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019c8d	26 1a		rol $1a				rol 	zLTemp1
.019c8f	26 1b		rol $1b				rol 	zLTemp1+1
.019c91	26 1c		rol $1c				rol 	zLTemp1+2
.019c93	26 1d		rol $1d				rol 	zLTemp1+3
.019c95	38		sec				sec
.019c96	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019c98	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019c9a	48		pha				pha
.019c9b	a5 1b		lda $1b				lda 	zLTemp1+1
.019c9d	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019c9f	48		pha				pha
.019ca0	a5 1c		lda $1c				lda 	zLTemp1+2
.019ca2	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019ca4	48		pha				pha
.019ca5	a5 1d		lda $1d				lda 	zLTemp1+3
.019ca7	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019ca9	90 13		bcc $019cbe			bcc 	_BFDNoAdd
.019cab	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019cad	68		pla				pla
.019cae	85 1c		sta $1c				sta 	zLTemp1+2
.019cb0	68		pla				pla
.019cb1	85 1b		sta $1b				sta 	zLTemp1+1
.019cb3	68		pla				pla
.019cb4	85 1a		sta $1a				sta 	zLTemp1+0
.019cb6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019cb8	09 01		ora #$01			ora 	#1
.019cba	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019cbc	80 03		bra $019cc1			bra 	_BFDNext
.019cbe					_BFDNoAdd:
.019cbe	68		pla				pla 								; Throw away the intermediate calculations
.019cbf	68		pla				pla
.019cc0	68		pla				pla
.019cc1					_BFDNext:
.019cc1	88		dey				dey
.019cc2	d0 c1		bne $019c85			bne 	_BFDLoop
.019cc4	7a		ply				ply 								; restore Y and exit
.019cc5	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019cc8	b0 06		bcs $019cd0			bcs		IntegerNegateAlways 			; negate the result
.019cca	60		rts				rts
.019ccb					CheckIntegerNegate:
.019ccb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ccd	30 01		bmi $019cd0			bmi 	IntegerNegateAlways
.019ccf	60		rts				rts
.019cd0					IntegerNegateAlways:
.019cd0	ee 9e 03	inc $039e			inc 	SignCount
.019cd3	38		sec				sec
.019cd4	a9 00		lda #$00			lda 	#0
.019cd6	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019cd8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019cda	a9 00		lda #$00			lda 	#0
.019cdc	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019cde	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ce0	a9 00		lda #$00			lda 	#0
.019ce2	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019ce4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ce6	a9 00		lda #$00			lda 	#0
.019ce8	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019cea	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cec	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019ced					INTToString:
.019ced	48		pha				pha
.019cee	5a		phy				phy
.019cef	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019cf1	10 08		bpl $019cfb			bpl 		_ITSNotMinus
.019cf3	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019cf5	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter
.019cf8	20 d0 9c	jsr $019cd0			jsr 		IntegerNegateAlways 	; negate the number.
.019cfb					_ITSNotMinus:
.019cfb	a9 00		lda #$00			lda 		#0
.019cfd	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019d00	8a		txa				txa 								; use Y for the mantissa index.
.019d01	a8		tay				tay
.019d02	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019d04					_ITSNextSubtractor:
.019d04	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019d06	8d 9b 03	sta $039b			sta 		NumConvCount
.019d09					_ITSSubtract:
.019d09	38		sec				sec
.019d0a	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019d0d	ff 6b 9d 01	sbc $019d6b,x			sbc 		_ITSSubtractors+0,x
.019d11	48		pha				pha
.019d12	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019d15	ff 6c 9d 01	sbc $019d6c,x			sbc 		_ITSSubtractors+1,x
.019d19	48		pha				pha
.019d1a	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019d1d	ff 6d 9d 01	sbc $019d6d,x			sbc 		_ITSSubtractors+2,x
.019d21	48		pha				pha
.019d22	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019d25	ff 6e 9d 01	sbc $019d6e,x			sbc 		_ITSSubtractors+3,x
.019d29	90 14		bcc $019d3f			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019d2b	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019d2e	68		pla				pla
.019d2f	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019d32	68		pla				pla
.019d33	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019d36	68		pla				pla
.019d37	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019d3a	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019d3d	80 ca		bra $019d09			bra 		_ITSSubtract 			; go round again.
.019d3f					_ITSCantSubtract:
.019d3f	68		pla				pla 								; throw away interim answers
.019d40	68		pla				pla
.019d41	68		pla				pla
.019d42	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019d45	c9 30		cmp #$30			cmp 		#"0"
.019d47	d0 05		bne $019d4e			bne 		_ITSOutputDigit
.019d49	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019d4c	10 09		bpl $019d57			bpl	 		_ITSGoNextSubtractor
.019d4e					_ITSOutputDigit:
.019d4e	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019d51	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019d54	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter 		; output it.
.019d57					_ITSGoNextSubtractor:
.019d57	e8		inx				inx 								; next dword
.019d58	e8		inx				inx
.019d59	e8		inx				inx
.019d5a	e8		inx				inx
.019d5b	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019d5d	d0 a5		bne $019d04			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019d5f	98		tya				tya 								; X is back as the mantissa index
.019d60	aa		tax				tax
.019d61	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019d63	09 30		ora #$30			ora 		#"0"
.019d65	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter
.019d68	7a		ply				ply 								; and exit
.019d69	68		pla				pla
.019d6a	60		rts				rts
.019d6b					_ITSSubtractors:
>019d6b	00 ca 9a 3b					.dword 		1000000000
>019d6f	00 e1 f5 05					.dword 		100000000
>019d73	80 96 98 00					.dword 		10000000
>019d77	40 42 0f 00					.dword 		1000000
>019d7b	a0 86 01 00					.dword 		100000
>019d7f	10 27 00 00					.dword 		10000
>019d83	e8 03 00 00					.dword 		1000
>019d87	64 00 00 00					.dword 		100
>019d8b	0a 00 00 00					.dword 		10
.019d8f					_ITSSubtractorsEnd:
.019d8f					ITSOutputCharacter:
.019d8f	48		pha				pha
.019d90	da		phx				phx
.019d91	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019d94	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019d97	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019d99	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019d9c	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019d9f	fa		plx				plx
.019da0	68		pla				pla
.019da1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019da2					IntFromString:
.019da2	a0 00		ldy #$00			ldy 	#0
.019da4	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019da7					IntFromStringY:
.019da7	48		pha				pha
.019da8	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019daa	95 80		sta $80,x			sta 	XS_Mantissa,x
.019dac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dae	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019db0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019db2	a9 01		lda #$01			lda 	#1
.019db4	95 85		sta $85,x			sta 	XS_Type,x
.019db6					_IFSLoop:
.019db6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019db8	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019dba	90 4e		bcc $019e0a			bcc 	_IFSExit
.019dbc	c9 3a		cmp #$3a			cmp 	#"9"+1
.019dbe	b0 4a		bcs $019e0a			bcs 	_IFSExit
.019dc0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019dc2	c9 0c		cmp #$0c			cmp 	#12
.019dc4	b0 4e		bcs $019e14			bcs 	_IFSOverflow
.019dc6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019dc8	48		pha				pha
.019dc9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019dcb	48		pha				pha
.019dcc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019dce	48		pha				pha
.019dcf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019dd1	48		pha				pha
.019dd2	20 29 9e	jsr $019e29			jsr 	IFSX1ShiftLeft 				; double
.019dd5	20 29 9e	jsr $019e29			jsr 	IFSX1ShiftLeft 				; x 4
.019dd8	18		clc				clc 								; add saved value x 5
.019dd9	68		pla				pla
.019dda	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019ddc	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dde	68		pla				pla
.019ddf	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019de1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019de3	68		pla				pla
.019de4	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019de6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019de8	68		pla				pla
.019de9	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019deb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ded	20 29 9e	jsr $019e29			jsr 	IFSX1ShiftLeft 				; x 10
.019df0	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019df3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019df5	29 0f		and #$0f			and 	#15
.019df7	c8		iny				iny
.019df8	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019dfa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019dfc	90 b8		bcc $019db6			bcc 	_IFSLoop
.019dfe	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019e00	d0 b4		bne $019db6			bne 	_IFSLoop
.019e02	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019e04	d0 b0		bne $019db6			bne 	_IFSLoop
.019e06	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019e08	80 ac		bra $019db6			bra 	_IFSLoop
.019e0a					_IFSExit:
.019e0a	98		tya				tya 								; get offset
.019e0b					_IFSOkay:
.019e0b	38		sec				sec
.019e0c	ad 9c 03	lda $039c			lda 	ExpTemp
.019e0f	f0 01		beq $019e12			beq 	_IFSSkipFail
.019e11	18		clc				clc
.019e12					_IFSSkipFail:
.019e12	68		pla				pla 								; and exit.
.019e13	60		rts				rts
.019e14					_IFSOverflow:
.019e14	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>019e17	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019e1f	20 6f 76 65 72 66 6c 6f 77 00
.019e29					IFSX1ShiftLeft:
.019e29	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019e2b	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019e2d	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019e2f	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019e31	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019e32					FPSubtract:
.019e32	48		pha				pha
.019e33	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019e35	49 80		eor #$80			eor 	#$80
.019e37	95 8b		sta $8b,x			sta 	XS2_Type,x
.019e39	68		pla				pla 								; --- and fall through ---
.019e3a					FPAdd:
.019e3a	48		pha				pha
.019e3b	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019e3d	d0 05		bne $019e44			bne 	_FPA_NegativeLHS
.019e3f	20 5b 9e	jsr $019e5b			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019e42	68		pla				pla
.019e43	60		rts				rts
.019e44					_FPA_NegativeLHS:
.019e44	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019e46	49 80		eor #$80			eor 	#$80
.019e48	95 85		sta $85,x			sta 	XS_Type,x
.019e4a	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019e4c	49 80		eor #$80			eor 	#$80
.019e4e	95 8b		sta $8b,x			sta 	XS2_Type,x
.019e50	20 5b 9e	jsr $019e5b			jsr 	FPAdd_Worker 				; do the add calculation.
.019e53	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019e55	49 80		eor #$80			eor 	#$80
.019e57	95 85		sta $85,x			sta 	XS_Type,x
.019e59	68		pla				pla
.019e5a	60		rts				rts
.019e5b					FPAdd_Worker:
.019e5b	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019e5d	70 07		bvs $019e66			bvs 	_FPAWExit 					; no change.
.019e5f	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019e61	50 07		bvc $019e6a			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019e63	20 d8 a0	jsr $01a0d8			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019e66					_FPAWExit:
.019e66	20 47 a1	jsr $01a147			jsr 	FPUNormalise 				; normalise the result.
.019e69	60		rts				rts
.019e6a					_FPAWMakeSame:
.019e6a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019e6c	38		sec				sec
.019e6d	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019e6f	f0 16		beq $019e87			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019e71	da		phx				phx 								; save X
.019e72	90 06		bcc $019e7a			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019e74	e8		inx				inx
.019e75	e8		inx				inx
.019e76	e8		inx				inx
.019e77	e8		inx				inx
.019e78	e8		inx				inx
.019e79	e8		inx				inx
.019e7a					_FPAWShiftA:
.019e7a	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019e7c	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019e7e	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019e80	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019e82	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019e84	fa		plx				plx 								; restore original X
.019e85	80 e3		bra $019e6a			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019e87					_FPAW_DoArithmetic:
.019e87	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019e89	30 28		bmi $019eb3			bmi 	_FPAW_BNegative
.019e8b	18		clc				clc
.019e8c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019e8e	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019e90	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019e92	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e94	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019e96	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019e98	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019e9a	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019e9c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019e9e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ea0	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019ea2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ea4	90 c0		bcc $019e66			bcc 	_FPAWExit 					; no carry.
.019ea6	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019ea8	38		sec				sec
.019ea9	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019eab	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019ead	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019eaf	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019eb1	80 b3		bra $019e66			bra 	_FPAWExit
.019eb3					_FPAW_BNegative:
.019eb3	38		sec				sec
.019eb4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019eb6	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019eb8	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019eba	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ebc	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019ebe	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ec0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019ec2	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019ec4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ec6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019ec8	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019eca	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ecc	b0 09		bcs $019ed7			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019ece	20 fe a0	jsr $01a0fe			jsr 	FPUNegateInteger			; negate the mantissa
.019ed1	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019ed3	49 80		eor #$80			eor 	#$80
.019ed5	95 85		sta $85,x			sta 	XS_Type,x
.019ed7					_FPAWGoExit:
.019ed7	4c 66 9e	jmp $019e66			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019eda					FPD_IsDivZero:
.019eda	20 4e 85	jsr $01854e			jsr ERR_Handler
>019edd	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019ee5	20 62 79 20 7a 65 72 6f 00
.019eee					FPDivide:
.019eee	48		pha				pha
.019eef	5a		phy				phy
.019ef0	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019ef2	70 e6		bvs $019eda			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019ef4	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019ef6	f0 03		beq $019efb			beq 	_FPDCalculateExp
.019ef8					_FPD_Exit:
.019ef8	7a		ply				ply
.019ef9	68		pla				pla
.019efa	60		rts				rts
.019efb					_FPDCalculateExp:
.019efb	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019efd	49 ff		eor #$ff			eor 	#$FF
.019eff	1a		inc a				inc 	a
.019f00	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019f02	20 d2 9f	jsr $019fd2			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019f05	18		clc				clc 	 							; add 1 to the resulting exponent
.019f06	69 01		adc #$01			adc 	#1
.019f08	b0 54		bcs $019f5e			bcs 	_FPD_Overflow 				; which can overflow.
.019f0a	95 84		sta $84,x			sta 	XS_Exponent,x
.019f0c	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019f0e	85 1a		sta $1a				sta 	zLTemp1+0
.019f10	85 1b		sta $1b				sta 	zLTemp1+1
.019f12	85 1c		sta $1c				sta 	zLTemp1+2
.019f14	85 1d		sta $1d				sta 	zLTemp1+3
.019f16	a0 20		ldy #$20			ldy 	#32 						; times round.
.019f18					_FPD_Loop:
.019f18	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019f19	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019f1b	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019f1d	48		pha				pha
.019f1e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f20	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019f22	48		pha				pha
.019f23	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f25	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019f27	48		pha				pha
.019f28	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f2a	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019f2c	90 13		bcc $019f41			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019f2e	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019f30	68		pla				pla
.019f31	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f33	68		pla				pla
.019f34	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f36	68		pla				pla
.019f37	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f39	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019f3b	09 80		ora #$80			ora 	#$80
.019f3d	85 1d		sta $1d				sta 	zLTemp1+3
.019f3f	80 03		bra $019f44			bra 	_FPD_Rotates
.019f41					_FPD_NoSubtract:
.019f41	68		pla				pla 								; throw away unwanted results
.019f42	68		pla				pla
.019f43	68		pla				pla
.019f44					_FPD_Rotates:
.019f44	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019f46	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019f48	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019f4a	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019f4c	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019f4e	26 1b		rol $1b				rol 	zLTemp1+1
.019f50	26 1c		rol $1c				rol 	zLTemp1+2
.019f52	26 1d		rol $1d				rol 	zLTemp1+3
.019f54	90 02		bcc $019f58			bcc 	_FPD_NoCarry
.019f56	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019f58					_FPD_NoCarry:
.019f58	88		dey				dey 								; do 32 times
.019f59	d0 bd		bne $019f18			bne 	_FPD_Loop
.019f5b	4c b6 9f	jmp $019fb6			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019f5e					_FPD_Overflow:
.019f5e	4c a4 a1	jmp $01a1a4			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019f61					FPMultiply:
.019f61	48		pha				pha
.019f62	5a		phy				phy
.019f63	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019f65	70 07		bvs $019f6e			bvs 	_FPM_Exit
.019f67	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019f69	50 06		bvc $019f71			bvc 	_FPM_CalcExponent
.019f6b	20 d8 a0	jsr $01a0d8			jsr 	FPUCopyX2ToX1
.019f6e					_FPM_Exit:
.019f6e	7a		ply				ply
.019f6f	68		pla				pla
.019f70	60		rts				rts
.019f71					_FPM_CalcExponent:
.019f71	18		clc				clc
.019f72	20 d2 9f	jsr $019fd2			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019f75	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019f77	a9 00		lda #$00			lda 	#0
.019f79	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019f7b	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019f7d	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019f7f	85 1d		sta $1d				sta 	zLTemp1+3
.019f81	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019f83					_FPM_Loop:
.019f83	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019f85	29 01		and #$01			and 	#1
.019f87	18		clc				clc 								; clear carry for the long rotate.
.019f88	f0 19		beq $019fa3			beq 	_FPM_NoAddition
.019f8a	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019f8b	a5 1a		lda $1a				lda 	zLTemp1+0
.019f8d	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019f8f	85 1a		sta $1a				sta 	zLTemp1+0
.019f91	a5 1b		lda $1b				lda 	zLTemp1+1
.019f93	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019f95	85 1b		sta $1b				sta 	zLTemp1+1
.019f97	a5 1c		lda $1c				lda 	zLTemp1+2
.019f99	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019f9b	85 1c		sta $1c				sta 	zLTemp1+2
.019f9d	a5 1d		lda $1d				lda 	zLTemp1+3
.019f9f	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019fa1	85 1d		sta $1d				sta 	zLTemp1+3
.019fa3					_FPM_NoAddition:
.019fa3	66 1d		ror $1d				ror 	3+zLTemp1
.019fa5	66 1c		ror $1c				ror 	2+zLTemp1
.019fa7	66 1b		ror $1b				ror 	1+zLTemp1
.019fa9	66 1a		ror $1a				ror 	0+zLTemp1
.019fab	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019fad	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019faf	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019fb1	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019fb3	88		dey				dey
.019fb4	d0 cd		bne $019f83			bne 	_FPM_Loop 					; do this 32 times.
.019fb6					FPM_CopySignNormalize:
.019fb6	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019fb8	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019fba	a5 1b		lda $1b				lda 	zLTemp1+1
.019fbc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fbe	a5 1c		lda $1c				lda 	zLTemp1+2
.019fc0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fc2	a5 1d		lda $1d				lda 	zLTemp1+3
.019fc4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fc6	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.019fc8	55 8b		eor $8b,x			eor 	XS2_Type,x
.019fca	95 85		sta $85,x			sta 	XS_Type,x
.019fcc	20 47 a1	jsr $01a147			jsr 	FPUNormalise 				; normalise and exit.
.019fcf	7a		ply				ply
.019fd0	68		pla				pla
.019fd1	60		rts				rts
.019fd2					FPCalculateExponent:
.019fd2	18		clc				clc
.019fd3	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019fd5	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.019fd7	b0 08		bcs $019fe1			bcs 	_FPCECarry 					; carry out ?
.019fd9	10 03		bpl $019fde			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019fdb	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019fdd	60		rts				rts
.019fde					_FPCEExpZero:
.019fde	a9 00		lda #$00			lda 	#0
.019fe0	60		rts				rts
.019fe1					_FPCECarry:
.019fe1	30 03		bmi $019fe6			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019fe3	09 80		ora #$80			ora 	#$80 						; put in right range
.019fe5	60		rts				rts
.019fe6					_FPCEOverflow:
.019fe6	4c a4 a1	jmp $01a1a4			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019fe9					FPFractionalPart:
.019fe9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019feb	38		sec				sec 								; this flag tells us to keep the fractional part
.019fec	30 0d		bmi $019ffb			bmi 	FPGetPart
.019fee	60		rts				rts
.019fef					FPIntegerPart:
.019fef	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019ff1	18		clc				clc 								; this flag says keep the integer part.
.019ff2	30 07		bmi $019ffb			bmi 	FPGetPart 					; -ve exponents are 0..127
.019ff4	48		pha				pha
.019ff5	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019ff7	95 85		sta $85,x			sta 	XS_Type,x
.019ff9	68		pla				pla
.019ffa	60		rts				rts
.019ffb					FPGetPart:
.019ffb	48		pha				pha
.019ffc	5a		phy				phy 								; save Y
.019ffd	08		php				php 								; save action
.019ffe	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a000	70 59		bvs $01a05b			bvs 	_FPGP_Exit 					; then do nothing.
.01a002	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a004	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a006	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a008	85 1c		sta $1c				sta 	zLTemp1+2
.01a00a	85 1d		sta $1d				sta 	zLTemp1+3
.01a00c	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a00e	38		sec				sec
.01a00f	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a011	f0 12		beq $01a025			beq 	_FPGP_NoShift 				; ... if any
.01a013	c9 20		cmp #$20			cmp 	#32
.01a015	90 02		bcc $01a019			bcc 	_FPGP_NotMax
.01a017	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a019					_FPGP_NotMax:
.01a019	a8		tay				tay 								; Y is the mask shift count.
.01a01a					_FPGP_ShiftMask:
.01a01a	46 1d		lsr $1d				lsr 	3+zLTemp1
.01a01c	66 1c		ror $1c				ror 	2+zLTemp1
.01a01e	66 1b		ror $1b				ror 	1+zLTemp1
.01a020	66 1a		ror $1a				ror 	0+zLTemp1
.01a022	88		dey				dey
.01a023	d0 f5		bne $01a01a			bne 	_FPGP_ShiftMask
.01a025					_FPGP_NoShift:
.01a025	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a027	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a02a					_FPGP_MaskLoop:
.01a02a	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.01a02d	28		plp				plp 								; if CC we keep the top part, so we
.01a02e	08		php				php		 							; flip the mask.
.01a02f	b0 02		bcs $01a033			bcs		_FPGP_NoFlip
.01a031	49 ff		eor #$ff			eor 	#$FF
.01a033					_FPGP_NoFlip:
.01a033	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a035	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a037	e8		inx				inx
.01a038	c8		iny				iny
.01a039	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a03b	d0 ed		bne $01a02a			bne 	_FPGP_MaskLoop
.01a03d	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a040	28		plp				plp
.01a041	08		php				php 								; get action flag on the stack
.01a042	90 04		bcc $01a048			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a044	a9 00		lda #$00			lda 	#0
.01a046	95 85		sta $85,x			sta 	XS_Type,x
.01a048					_FPGP_NotFractional:
.01a048	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a04a	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a04c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a04e	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a050	f0 05		beq $01a057			beq 	_FPGP_Zero 					; if zero, return zero
.01a052	20 47 a1	jsr $01a147			jsr 	FPUNormalise
.01a055	80 04		bra $01a05b			bra 	_FPGP_Exit 					; and exit
.01a057					_FPGP_Zero:
.01a057	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a059	95 85		sta $85,x			sta 	XS_Type,x
.01a05b					_FPGP_Exit:
.01a05b	68		pla				pla 								; throw saved action flag.
.01a05c	7a		ply				ply
.01a05d	68		pla				pla
.01a05e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a05f					FPCompare:
.01a05f	20 a0 a0	jsr $01a0a0			jsr 	FPFastCompare 				; fast compare try first
.01a062	b0 3b		bcs $01a09f			bcs 	_FPCExit 					; that worked.
.01a064	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a066	48		pha				pha
.01a067	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a069	48		pha				pha
.01a06a	20 32 9e	jsr $019e32			jsr 	FPSubtract 					; calculate X1-X2
.01a06d	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a06f	70 2a		bvs $01a09b			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a071	68		pla				pla
.01a072	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a075	68		pla				pla
.01a076	38		sec				sec
.01a077	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a07a	70 14		bvs $01a090			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a07c	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a07d	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a07f	b0 0f		bcs $01a090			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a081	38		sec				sec
.01a082	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a085	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a087	b0 02		bcs $01a08b			bcs 	_FPCNotRange 				; keep in range.
.01a089	a9 01		lda #$01			lda 	#1
.01a08b					_FPCNotRange:
.01a08b	38		sec				sec
.01a08c	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a08e	b0 0d		bcs $01a09d			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a090					_FPCNotEqual:
.01a090	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a092	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a094	f0 02		beq $01a098			beq 	_FPCNE2
.01a096	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a098	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a099	80 04		bra $01a09f			bra 	_FPCExit
.01a09b					_FPCPullZero:
.01a09b	68		pla				pla 								; throw saved exponents
.01a09c	68		pla				pla
.01a09d					_FPCZero:
.01a09d	a9 00		lda #$00			lda 	#0 							; and return zero
.01a09f					_FPCExit:
.01a09f	60		rts				rts
.01a0a0					FPFastCompare:
.01a0a0	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a0a2	70 23		bvs $01a0c7			bvs 	_FPFLeftZero
.01a0a4	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a0a6	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a0a8	70 25		bvs $01a0cf			bvs 	_FPFSignBit
.01a0aa	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a0ac	0a		asl a				asl 	a 							; put in CS if different.
.01a0ad	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a0af	b0 1e		bcs $01a0cf			bcs 	_FPFSignBit
.01a0b1	38		sec				sec 								; same sign and not-zero. compare exponents
.01a0b2	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a0b4	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a0b6	f0 09		beq $01a0c1			beq 	_FPNoFastCompare
.01a0b8	6a		ror a				ror 	a 							; put carry into bit 7.
.01a0b9	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a0bb	30 02		bmi $01a0bf			bmi		_FPFCNotMinus
.01a0bd	49 80		eor #$80			eor 	#$80
.01a0bf					_FPFCNotMinus:
.01a0bf	80 0e		bra $01a0cf			bra		_FPFSignBit
.01a0c1					_FPNoFastCompare:
.01a0c1	18		clc				clc
.01a0c2	60		rts				rts
.01a0c3					_FPFZero:
.01a0c3	a9 00		lda #$00			lda 	#0
.01a0c5					_FPFExitSet:
.01a0c5	38		sec				sec
.01a0c6	60		rts				rts
.01a0c7					_FPFLeftZero:
.01a0c7	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a0c9	70 f8		bvs $01a0c3			bvs 	_FPFZero
.01a0cb	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a0cd	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a0cf					_FPFSignBit:
.01a0cf	0a		asl a				asl 	a
.01a0d0	a9 01		lda #$01			lda 	#1
.01a0d2	90 f1		bcc $01a0c5			bcc		_FPFExitSet
.01a0d4	a9 ff		lda #$ff			lda 	#$FF
.01a0d6	38		sec				sec
.01a0d7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a0d8					FPUCopyX2ToX1:
.01a0d8	48		pha				pha
.01a0d9	da		phx				phx
.01a0da	5a		phy				phy
.01a0db	a0 08		ldy #$08			ldy 	#8
.01a0dd	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a0df	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a0e1	e8		inx				inx
.01a0e2	88		dey				dey
.01a0e3	10 f8		bpl $01a0dd			bpl 	_FPUC21
.01a0e5	7a		ply				ply
.01a0e6	fa		plx				plx
.01a0e7	68		pla				pla
.01a0e8	60		rts				rts
.01a0e9					FPUSetInteger:
.01a0e9	48		pha				pha
.01a0ea	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a0ec	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a0ee	10 02		bpl $01a0f2			bpl 	_FPUSIExtend
.01a0f0	a9 ff		lda #$ff			lda 	#$FF
.01a0f2					_FPUSIExtend:
.01a0f2	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a0f4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0f6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0f8	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a0fa	95 85		sta $85,x			sta 	XS_Type,x
.01a0fc	68		pla				pla
.01a0fd	60		rts				rts
.01a0fe					FPUNegateInteger:
.01a0fe	48		pha				pha
.01a0ff	38		sec				sec
.01a100	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a102	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a104	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a106	a9 00		lda #$00			lda 	#0
.01a108	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a10a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a10c	a9 00		lda #$00			lda 	#0
.01a10e	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a110	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a112	a9 00		lda #$00			lda 	#0
.01a114	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a116	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a118	68		pla				pla
.01a119	60		rts				rts
.01a11a					FPUToFloat:
.01a11a	48		pha				pha
.01a11b	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a11d	29 0f		and #$0f			and 	#$0F
.01a11f	f0 24		beq $01a145			beq 	_FPUFExit
.01a121	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a123	95 85		sta $85,x			sta 	XS_Type,x
.01a125	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a127	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a129	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a12b	10 07		bpl $01a134			bpl		_FPUFPositive
.01a12d	20 fe a0	jsr $01a0fe			jsr 	FPUNegateInteger 			; negate the mantissa
.01a130	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a132	95 85		sta $85,x			sta 	XS_Type,x
.01a134					_FPUFPositive:
.01a134	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a136	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a138	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a13a	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a13c	d0 04		bne $01a142			bne 	_FPUFNonZero
.01a13e	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a140	95 85		sta $85,x			sta 	XS_Type,x
.01a142					_FPUFNonZero:
.01a142	20 47 a1	jsr $01a147			jsr 	FPUNormalise 				; normalise the floating point.
.01a145					_FPUFExit:
.01a145	68		pla				pla
.01a146	60		rts				rts
.01a147					FPUNormalise:
.01a147	48		pha				pha
.01a148	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a14a	70 18		bvs $01a164			bvs 	_FPUNExit
.01a14c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a14e	f0 10		beq $01a160			beq 	_FPUNSetZero
.01a150					_FPUNLoop:
.01a150	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a152	30 10		bmi $01a164			bmi 	_FPUNExit 					; if so, we are normalised.
.01a154	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a156	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a158	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a15a	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a15c	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a15e	d0 f0		bne $01a150			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a160					_FPUNSetZero:
.01a160	a9 40		lda #$40			lda 	#$40
.01a162	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a164					_FPUNExit:
.01a164	68		pla				pla
.01a165	60		rts				rts
.01a166					FPUToInteger:
.01a166	48		pha				pha
.01a167	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a169	29 01		and #$01			and 	#1
.01a16b	d0 31		bne $01a19e			bne 	_FPUTOI_Exit
.01a16d	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a16f	70 23		bvs $01a194			bvs 	_FPUTOI_Zero
.01a171	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a173	10 1f		bpl $01a194			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a175	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a177	b0 2b		bcs $01a1a4			bcs 	FP_Overflow
.01a179					_FPUToIToInteger:
.01a179	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a17b	c9 a0		cmp #$a0			cmp 	#128+32
.01a17d	f0 0c		beq $01a18b			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a17f	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a181	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a183	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a185	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a187	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a189	80 ee		bra $01a179			bra 	_FPUToIToInteger 			; keep going.
.01a18b					_FPUToICheckSign:
.01a18b	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a18d	10 0f		bpl $01a19e			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a18f	20 fe a0	jsr $01a0fe			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a192	80 0a		bra $01a19e			bra 	_FPUTOI_Exit
.01a194					_FPUTOI_Zero:
.01a194	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a196	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a198	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a19a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a19c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a19e					_FPUToI_Exit:
.01a19e	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a1a0	95 85		sta $85,x			sta 	XS_Type,x
.01a1a2	68		pla				pla
.01a1a3	60		rts				rts
.01a1a4					FP_Overflow:
.01a1a4	20 4e 85	jsr $01854e			jsr ERR_Handler
>01a1a7	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a1af	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a1bf					FPUTimes10:
.01a1bf	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a1c1	85 1a		sta $1a				sta 	ZLTemp1+0
.01a1c3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a1c5	85 1b		sta $1b				sta 	ZLTemp1+1
.01a1c7	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a1c9	85 1c		sta $1c				sta 	ZLTemp1+2
.01a1cb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a1cd	85 1d		sta $1d				sta 	ZLTemp1+3
.01a1cf	20 04 a2	jsr $01a204			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a1d2	20 04 a2	jsr $01a204			jsr 	_FPUT_LSR_ZLTemp1
.01a1d5	18		clc				clc
.01a1d6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a1d8	65 1a		adc $1a				adc 	ZLTemp1+0
.01a1da	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1dc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a1de	65 1b		adc $1b				adc 	ZLTemp1+1
.01a1e0	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1e2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a1e4	65 1c		adc $1c				adc 	ZLTemp1+2
.01a1e6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1e8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a1ea	65 1d		adc $1d				adc 	ZLTemp1+3
.01a1ec	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1ee	90 0a		bcc $01a1fa			bcc 	_FPUTimes10
.01a1f0	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a1f2	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a1f4	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a1f6	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a1f8	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a1fa					_FPUTimes10:
.01a1fa	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a1fc	18		clc				clc
.01a1fd	69 03		adc #$03			adc 	#3
.01a1ff	95 84		sta $84,x			sta 	XS_Exponent,x
.01a201	b0 a1		bcs $01a1a4			bcs 	FP_Overflow 				; error
.01a203	60		rts				rts
.01a204					_FPUT_LSR_ZLTemp1:
.01a204	46 1d		lsr $1d				lsr 	ZLTemp1+3
.01a206	66 1c		ror $1c				ror 	ZLTemp1+2
.01a208	66 1b		ror $1b				ror 	ZLTemp1+1
.01a20a	66 1a		ror $1a				ror 	ZLTemp1+0
.01a20c	60		rts				rts
.01a20d					FPUScale10A:
.01a20d	5a		phy				phy
.01a20e	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a210	f0 37		beq $01a249			beq 	_FPUScaleExit
.01a212	da		phx				phx 								; save X
.01a213	e8		inx				inx
.01a214	e8		inx				inx
.01a215	e8		inx				inx
.01a216	e8		inx				inx
.01a217	e8		inx				inx
.01a218	e8		inx				inx
.01a219	a8		tay				tay 								; save power scalar in Y.
.01a21a	a9 00		lda #$00			lda 	#0
.01a21c	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a21e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a220	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a222	95 85		sta $85,x			sta 	XS_Type,x
.01a224	a9 80		lda #$80			lda 	#$80
.01a226	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a228	a9 81		lda #$81			lda 	#$81
.01a22a	95 84		sta $84,x			sta 	XS_Exponent,x
.01a22c	5a		phy				phy 								; save 10^n on stack.
.01a22d	c0 00		cpy #$00			cpy 	#0
.01a22f	10 05		bpl $01a236			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a231	98		tya				tya
.01a232	49 ff		eor #$ff			eor 	#$FF
.01a234	1a		inc a				inc 	a
.01a235	a8		tay				tay
.01a236					_FPUSAbs:
.01a236	20 bf a1	jsr $01a1bf			jsr 	FPUTimes10
.01a239	88		dey				dey
.01a23a	d0 fa		bne $01a236			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a23c	68		pla				pla 								; restore count in A
.01a23d	fa		plx				plx 								; restore X pointing to number to scale.
.01a23e	0a		asl a				asl 	a
.01a23f	b0 05		bcs $01a246			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a241	20 61 9f	jsr $019f61			jsr 	FPMultiply 					; if clear multiply.
.01a244	80 03		bra $01a249			bra		_FPUScaleExit
.01a246					_FPUSDivide:
.01a246	20 ee 9e	jsr $019eee			jsr 	FPDivide
.01a249					_FPUScaleExit:
.01a249	7a		ply				ply
.01a24a	60		rts				rts
.01a24b					FPUCopyToNext:
.01a24b	a0 06		ldy #$06			ldy 		#6
.01a24d	da		phx				phx
.01a24e					_FPUCopy1:
.01a24e	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a250	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a252	e8		inx				inx
.01a253	88		dey				dey
.01a254	d0 f8		bne $01a24e			bne 	_FPUCopy1
.01a256	fa		plx				plx
.01a257	60		rts				rts
.01a258					FPUCopyFromNext:
.01a258	a0 06		ldy #$06			ldy 		#6
.01a25a	da		phx				phx
.01a25b					_FPUCopy1:
.01a25b	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a25d	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a25f	e8		inx				inx
.01a260	88		dey				dey
.01a261	d0 f8		bne $01a25b			bne 	_FPUCopy1
.01a263	fa		plx				plx
.01a264	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a265					FPToString:
.01a265	48		pha				pha
.01a266	5a		phy				phy
.01a267	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a269	50 0a		bvc $01a275			bvc 		_FPTSIsFloat 			; if zero,
.01a26b					_FPTSZero:
.01a26b	a9 30		lda #$30			lda 		#"0"
.01a26d	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter
.01a270					_FPTSExit:
.01a270	7a		ply				ply
.01a271	68		pla				pla
.01a272	60		rts				rts
.01a273	80 fb		bra $01a270			bra 		_FPTSExit
.01a275					_FPTSIsFloat:
.01a275	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a277	10 09		bpl $01a282			bpl 		_FPTSNotSigned
.01a279	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a27b	95 85		sta $85,x			sta 		XS_Type,x
.01a27d	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a27f	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter
.01a282					_FPTSNotSigned:
.01a282	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a284	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a286	b0 09		bcs $01a291			bcs 		_FPTSExponent
.01a288	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a28a	90 05		bcc $01a291			bcc 		_FPTSExponent 			;
.01a28c					_FPTSStandard:
.01a28c	20 d0 a2	jsr $01a2d0			jsr 		FPTOutputBody 			; output the body.
.01a28f	80 df		bra $01a270			bra 		_FPTSExit
.01a291					_FPTSExponent:
.01a291	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a293	8d 9d 03	sta $039d			sta 		ExpCount
.01a296					_FPTSExponentLoop:
.01a296	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a298	10 0e		bpl $01a2a8			bpl 		_FPTSTimes
.01a29a	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a29c	90 14		bcc $01a2b2			bcc 		_FPTSScaledToExp
.01a29e	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a2a0	20 0d a2	jsr $01a20d			jsr 		FPUScale10A
.01a2a3	ee 9d 03	inc $039d			inc 		ExpCount
.01a2a6	80 ee		bra $01a296			bra 		_FPTSExponentLoop
.01a2a8					_FPTSTimes:
.01a2a8	a9 01		lda #$01			lda 		#1
.01a2aa	20 0d a2	jsr $01a20d			jsr 		FPUScale10A
.01a2ad	ce 9d 03	dec $039d			dec 		ExpCount
.01a2b0	80 e4		bra $01a296			bra 		_FPTSExponentLoop
.01a2b2					_FPTSScaledToExp:
.01a2b2	20 d0 a2	jsr $01a2d0			jsr 		FPTOutputBody 			; output the body.
.01a2b5	a9 65		lda #$65			lda 		#"e"					; output E
.01a2b7	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter
.01a2ba	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a2bd	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a2bf	29 80		and #$80			and 		#$80 					; sign extend it
.01a2c1	f0 02		beq $01a2c5			beq 		_FPTSSExt
.01a2c3	a9 ff		lda #$ff			lda 		#$FF
.01a2c5					_FPTSSExt:
.01a2c5	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a2c7	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a2c9	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a2cb	20 ed 9c	jsr $019ced			jsr 		INTToString 			; output the exponent.
.01a2ce	80 a0		bra $01a270			bra			_FPTSExit 				; and exit.
.01a2d0					FPTOutputBody:
.01a2d0	20 4b a2	jsr $01a24b			jsr 		FPUCopyToNext 			; copy to next slot.
.01a2d3	20 66 a1	jsr $01a166			jsr 		FPUToInteger 			; convert to an integer
.01a2d6	20 ed 9c	jsr $019ced			jsr 		INTToString 			; output the main integer part.
.01a2d9	20 58 a2	jsr $01a258			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a2dc	20 e9 9f	jsr $019fe9			jsr 		FPFractionalPart 		; get the decimal part.
.01a2df	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a2e1	70 3c		bvs $01a31f			bvs 		_FPTOExit 				; if not, exit now.
.01a2e3	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a2e5	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter
.01a2e8					_FPOutLoop:
.01a2e8	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a2ea	70 1d		bvs $01a309			bvs 		_FPStripZeros 			; strip trailing zeros
.01a2ec	20 bf a1	jsr $01a1bf			jsr 		FPUTimes10 				; multiply by 10
.01a2ef	20 4b a2	jsr $01a24b			jsr 		FPUCopyToNext			; copy to next slot.
.01a2f2	20 66 a1	jsr $01a166			jsr 		FPUToInteger 			; convert to integer
.01a2f5	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a2f7	09 30		ora #$30			ora 		#"0"
.01a2f9	20 8f 9d	jsr $019d8f			jsr 		ITSOutputCharacter
.01a2fc	20 58 a2	jsr $01a258			jsr 		FPUCopyFromNext 		; get it back
.01a2ff	20 e9 9f	jsr $019fe9			jsr 		FPFractionalPart 		; get fractional part
.01a302	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a305	c9 0b		cmp #$0b			cmp 	 	#11
.01a307	90 df		bcc $01a2e8			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a309					_FPStripZeros:
.01a309	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a30c					_FPStripLoop:
.01a30c	88		dey				dey 								; back one, if at start then no strip
.01a30d	f0 10		beq $01a31f			beq 		_FPToExit
.01a30f	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a312	c9 30		cmp #$30			cmp 		#"0"
.01a314	f0 f6		beq $01a30c			beq 		_FPStripLoop
.01a316	c8		iny				iny
.01a317	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a319	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a31c	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a31f					_FPTOExit:
.01a31f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a320					FPFromString:
.01a320	48		pha				pha 								; push A
.01a321	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a323	c9 2e		cmp #$2e			cmp 	#"."
.01a325	f0 03		beq $01a32a			beq	 	_FPFIsDecimal
.01a327	4c 86 a3	jmp $01a386			jmp 	_FPFNotDecimal
.01a32a					_FPFIsDecimal:
.01a32a	c8		iny				iny 								; consume the decimal.
.01a32b	20 1a a1	jsr $01a11a			jsr 	FPUToFloat 					; convert the integer to float.
.01a32e	da		phx				phx 								; save X.
.01a32f	5a		phy				phy 								; save decimal start position
.01a330	e8		inx				inx
.01a331	e8		inx				inx
.01a332	e8		inx				inx
.01a333	e8		inx				inx
.01a334	e8		inx				inx
.01a335	e8		inx				inx
.01a336	20 a7 9d	jsr $019da7			jsr 	INTFromStringY 				; get the part after the DP.
.01a339	20 1a a1	jsr $01a11a			jsr 	FPUToFloat 					; convert that to a float.
.01a33c	68		pla				pla 								; calculate - chars consumed.
.01a33d	8c 9c 03	sty $039c			sty 	ExpTemp
.01a340	38		sec				sec
.01a341	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a344	20 0d a2	jsr $01a20d			jsr 	FPUScale10A 				; scale it by 10^AC
.01a347	fa		plx				plx 								; restore original X
.01a348	20 3a 9e	jsr $019e3a			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a34b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a34d	c9 45		cmp #$45			cmp 	#"E"
.01a34f	f0 04		beq $01a355			beq 	_FPFExponent
.01a351	c9 65		cmp #$65			cmp 	#"e"
.01a353	d0 31		bne $01a386			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a355					_FPFExponent:
.01a355	c8		iny				iny 								; skip over E symbol.
.01a356	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a358	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a35a	d0 01		bne $01a35d			bne 	_FPFGotSign
.01a35c	c8		iny				iny 								; if it was - skip over it.
.01a35d					_FPFGotSign:
.01a35d	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a35e	da		phx				phx
.01a35f	e8		inx				inx
.01a360	e8		inx				inx
.01a361	e8		inx				inx
.01a362	e8		inx				inx
.01a363	e8		inx				inx
.01a364	e8		inx				inx
.01a365	20 a7 9d	jsr $019da7			jsr 	INTFromStringY 				; get the exponent
.01a368	fa		plx				plx 								; restore X.
.01a369	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a36b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a36d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a36f	d0 17		bne $01a388			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a371	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a373	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a375	b0 11		bcs $01a388			bcs 	_FPFXOverflow
.01a377	68		pla				pla 								; get direction
.01a378	d0 07		bne $01a381			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a37a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a37c	49 ff		eor #$ff			eor 	#$FF
.01a37e	1a		inc a				inc 	a
.01a37f	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a381					_FPFXScale:
.01a381	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a383	20 0d a2	jsr $01a20d			jsr 	FPUScale10A 				; scale by the exponent.
.01a386					_FPFNotDecimal:
.01a386	68		pla				pla
.01a387	60		rts				rts
.01a388					_FPFXOverflow:
.01a388	20 4e 85	jsr $01854e			jsr 	ERR_Handler
>01a38b	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a393	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a39a					Unary_Rnd:
.01a39a	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX 			; get value
.01a39d	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; check right bracket.
.01a3a0	20 98 93	jsr $019398			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a3a3	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a3a5	30 10		bmi $01a3b7			bmi 	_URSetSeed
.01a3a7	f0 28		beq $01a3d1			beq 	_URMakeRandom 				; if zero return same number.
.01a3a9	da		phx				phx
.01a3aa	a2 00		ldx #$00			ldx 	#0
.01a3ac	20 08 a4	jsr $01a408			jsr 	Random16
.01a3af	a2 02		ldx #$02			ldx 	#2
.01a3b1	20 08 a4	jsr $01a408			jsr 	Random16
.01a3b4	fa		plx				plx
.01a3b5	80 1a		bra $01a3d1			bra 	_URMakeRandom
.01a3b7					_URSetSeed:
.01a3b7	20 1a a1	jsr $01a11a			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a3ba	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a3bc	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a3bf	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a3c1	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a3c4	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a3c6	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a3c9	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a3cb	0a		asl a				asl 	a
.01a3cc	49 db		eor #$db			eor 	#$DB
.01a3ce	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a3d1					_URMakeRandom:
.01a3d1	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a3d4	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a3d7	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a3da	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a3dd	d0 0a		bne $01a3e9			bne 	_URNotZero
.01a3df	a9 47		lda #$47			lda 	#$47
.01a3e1	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a3e4	a9 3d		lda #$3d			lda 	#$3D
.01a3e6	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a3e9					_URNotZero:
.01a3e9	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a3ec	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3ee	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a3f1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3f3	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a3f6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3f8	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a3fb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a3fd	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a3ff	95 85		sta $85,x			sta 	XS_Type,x
.01a401	a9 80		lda #$80			lda 	#$80
.01a403	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a405	4c 47 a1	jmp $01a147			jmp 	FPUNormalise
.01a408					Random16:
.01a408	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a40b	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a40e	90 08		bcc $01a418			bcc 	_R16_NoXor
.01a410	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a413	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a415	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a418					_R16_NoXor:
.01a418	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a419					Unary_Int:
.01a419	20 1a 91	jsr $01911a			jsr 	EvaluateNumberX 			; get value
.01a41c	20 6a 97	jsr $01976a			jsr 	CheckNextRParen 			; check right bracket.
.01a41f	4c 66 a1	jmp $01a166			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a422	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
