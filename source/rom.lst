
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Mon Aug 26 19:48:01 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
=3					ArrayMaxDim = 3 							; number of dimensions.
>0497					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>049f					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>04a1					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>04a3					Tim_SR:		.byte ? 						; Processor Status
>04a4					Tim_A:		.byte ? 						; Processor Registers
>04a5					Tim_X:		.byte ?
>04a6					Tim_Y:		.byte ?
>04a7					Tim_Z:		.byte ?
>04a8					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$8000					HighMemory = $8000
=$4000					VariableMemory = $4000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	0b 64 00 cd 14 05 13 14			.byte	$0b,$64,$00,$cd,$14,$05,$13,$14
>1008	84 6a 00 1d 65 00 cd 01			.byte	$84,$6a,$00,$1d,$65,$00,$cd,$01
>1010	84 40 fd 03 30 be cd 14			.byte	$84,$40,$fd,$03,$30,$be,$cd,$14
>1018	05 13 14 31 84 41 fd 06			.byte	$05,$13,$14,$31,$84,$41,$fd,$06
>1020	32 65 32 34 8d 41 64 00			.byte	$32,$65,$32,$34,$8d,$41,$64,$00
>1028	12 66 00 14 05 13 14 84			.byte	$12,$66,$00,$14,$05,$13,$14,$84
>1030	14 05 13 14 8a 41 fd 03			.byte	$14,$05,$13,$14,$8a,$41,$fd,$03
>1038	30 00 2e 67 00 03 84 8b			.byte	$30,$00,$2e,$67,$00,$03,$84,$8b
>1040	14 05 13 14 be 03 84 03			.byte	$14,$05,$13,$14,$be,$03,$84,$03
>1048	8b 4f 68 be cd 0e 01 0d			.byte	$8b,$4f,$68,$be,$cd,$0e,$01,$0d
>1050	05 b5 84 fe 07 48 65 6c			.byte	$05,$b5,$84,$fe,$07,$48,$65,$6c
>1058	6c 6f be 03 b5 84 fe 09			.byte	$6c,$6f,$be,$03,$b5,$84,$fe,$09
>1060	2c 77 6f 72 6c 64 21 00			.byte	$2c,$77,$6f,$72,$6c,$64,$21,$00
>1068	17 68 00 07 12 05 05 14			.byte	$17,$68,$00,$07,$12,$05,$05,$14
>1070	09 0e 07 31 b5 84 0e 01			.byte	$09,$0e,$07,$31,$b5,$84,$0e,$01
>1078	0d 05 b5 8a 03 b5 00 14			.byte	$0d,$05,$b5,$8a,$03,$b5,$00,$14
>1080	69 00 0c 31 b9 84 a6 07			.byte	$69,$00,$0c,$31,$b9,$84,$a6,$07
>1088	12 05 05 14 09 0e 07 31			.byte	$12,$05,$05,$14,$09,$0e,$07,$31
>1090	b5 bc 00 20 6a 00 d4 14			.byte	$b5,$bc,$00,$20,$6a,$00,$d4,$14
>1098	05 13 14 31 be 01 bb 42			.byte	$05,$13,$14,$31,$be,$01,$bb,$42
>10a0	bc 84 42 be 01 bb 40 bc			.byte	$bc,$84,$42,$be,$01,$bb,$40,$bc
>10a8	84 6a be 01 bb 4a bc 84			.byte	$84,$6a,$be,$01,$bb,$4a,$bc,$84
>10b0	41 63 00 21 6b 00 d4 14			.byte	$41,$63,$00,$21,$6b,$00,$d4,$14
>10b8	05 13 14 31 be 01 ba 42			.byte	$05,$13,$14,$31,$be,$01,$ba,$42
>10c0	bc 84 4c be 01 ba 40 bc			.byte	$bc,$84,$4c,$be,$01,$ba,$40,$bc
>10c8	84 42 4e be 01 ba 4a bc			.byte	$84,$42,$4e,$be,$01,$ba,$4a,$bc
>10d0	84 43 47 00 2a 6c 00 d4			.byte	$84,$43,$47,$00,$2a,$6c,$00,$d4
>10d8	14 05 13 14 31 be 01 b6			.byte	$14,$05,$13,$14,$31,$be,$01,$b6
>10e0	42 bc 84 fe 04 31 32 be			.byte	$42,$bc,$84,$fe,$04,$31,$32,$be
>10e8	01 b6 40 bc 84 fe 05 31			.byte	$01,$b6,$40,$bc,$84,$fe,$05,$31
>10f0	34 32 be 01 b6 4a bc 84			.byte	$34,$32,$be,$01,$b6,$4a,$bc,$84
>10f8	fe 05 31 39 39 00 05 6d			.byte	$fe,$05,$31,$39,$39,$00,$05,$6d
>1100	00 c2 00 00				.byte	$00,$c2,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 9e 86 01	jmp $01869e		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 02	sta $0200			sta 	IFT_XCursor
.018024	8d 01 02	sta $0201			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 02	sta $0200			sta 	IFT_XCursor
.018065	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.018068	ad 01 02	lda $0201			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 02	inc $0201			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 02	sta $0200			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 02	inc $0200			inc 	IFT_XCursor
.018144	ad 00 02	lda $0200			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 02	dec $0201			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 02	sta $0201			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 02	inc $0201			inc 	IFT_YCursor
.01815c	ad 01 02	lda $0201			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 02	lda $0201			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 02	inc $0200			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae a8 04	ldx $04a8			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad a3 04	lda $04a3			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad a4 04	lda $04a4			lda 	TIM_A 						; restore AXYZ
.018281	ae a5 04	ldx $04a5			ldx 	TIM_X
.018284	ac a6 04	ldy $04a6			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d a2 04	sta $04a2			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d a1 04	sta $04a1			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd 9f 04	lda $049f,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d a4 04	sta $04a4			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e a5 04	stx $04a5			stx 	TIM_X
.01838b	8c a6 04	sty $04a6			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d a3 04	sta $04a3			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d a0 04	sta $04a0			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d 9f 04	sta $049f			sta 	TIM_PC 						; high byte
.01839a	ad a0 04	lda $04a0			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce 9f 04	dec $049f			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce a0 04	dec $04a0			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e a8 04	stx $04a8			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d a0 04	sta $04a0			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d 9f 04	sta $049f			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d a3 04	sta $04a3,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018400					SyntaxError:
.018400	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018403	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01840b	72 72 6f 72 00
.018410					TypeError:
.018410	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018413	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01841b	70 65 00
.01841e					BadParamError:
.01841e	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>018421	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018429	6d 65 74 65 72 00
.01842f					ERR_Handler:
.01842f	a0 00		ldy #$00			ldy 	#0
.018431	c8		iny				iny
.018432	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018434	8d 08 03	sta $0308			sta 	XS_Mantissa
.018437	c8		iny				iny
.018438	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01843a	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.01843d	fa		plx				plx 								; address in XY
.01843e	7a		ply				ply
.01843f	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018440	d0 01		bne $018443			bne 	_EHNoSkip
.018442	c8		iny				iny
.018443					_EHNoSkip:
.018443	20 64 84	jsr $018464			jsr 	PrintROMMessage 			; print message from ROM.
.018446	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.018449	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.01844c	f0 0c		beq $01845a			beq 	_EHNoLine
.01844e	a2 5f		ldx #$5f			ldx 	#_EHAt & $FF 				; print " at "
.018450	a0 84		ldy #$84			ldy 	#(_EHAt >> 8) & $FF
.018452	20 64 84	jsr $018464			jsr 	PrintROMMessage
.018455	a2 00		ldx #$00			ldx 	#0 							; Print line number
.018457	20 79 84	jsr $018479			jsr 	Print16BitInteger
.01845a					_EHNoLine:
.01845a	80 fe		bra $01845a			bra 	_EHNoLine
.01845c	4c be 86	jmp $0186be			jmp 	WarmStart
>01845f	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018464					PrintROMMessage:
.018464	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.018466	84 1b		sty $1b				sty 	zLTemp1+1
.018468	4b		phk				phk
.018469	68		pla				pla
.01846a	85 1c		sta $1c				sta 	ZLTemp1+2
.01846c	a0 00		ldy #$00			ldy 	#0
.01846e					_PRMLoop:
.01846e	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018470	f0 06		beq $018478			beq		_PRMExit
.018472	c8		iny				iny
.018473	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018476	80 f6		bra $01846e			bra 	_PRMLoop
.018478					_PRMExit:
.018478	60		rts				rts
.018479					Print16BitInteger:
.018479	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01847b	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.01847e	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.018481	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.018484	aa		tax				tax 								; convert bottom level.
.018485	20 25 96	jsr $019625			jsr 	INTToString 				; make string
.018488	a2 00		ldx #$00			ldx 	#0 							; print buffer
.01848a	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.01848d	f0 06		beq $018495			beq 	_P1Exit
.01848f	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018492	e8		inx				inx
.018493	80 f5		bra $01848a			bra 	_P1Loop
.018495	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.018496					VectorTable:
>018496	ee 89					.word BinaryOp_And         & $FFFF ; $80 and
>018498	16 8a					.word BinaryOp_Or          & $FFFF ; $81 or
>01849a	3e 8a					.word BinaryOp_Xor         & $FFFF ; $82 xor
>01849c	3e 8a					.word BinaryOp_Eor         & $FFFF ; $83 eor
>01849e	82 8a					.word Binary_Equal         & $FFFF ; $84 =
>0184a0	a1 8a					.word Binary_NotEqual      & $FFFF ; $85 <>
>0184a2	aa 8a					.word Binary_Less          & $FFFF ; $86 <
>0184a4	b3 8a					.word Binary_LessEqual     & $FFFF ; $87 <=
>0184a6	c5 8a					.word Binary_Greater       & $FFFF ; $88 >
>0184a8	bc 8a					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0184aa	5a 8b					.word BinaryOp_Add         & $FFFF ; $8a +
>0184ac	7a 8b					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0184ae	8d 8b					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0184b0	a0 8b					.word BinaryOp_Divide      & $FFFF ; $8d /
>0184b2	4a 85					.word NotImplemented       & $FFFF ; $8e ^
>0184b4	4a 85					.word NotImplemented       & $FFFF ; $8f if
>0184b6	4a 85					.word NotImplemented       & $FFFF ; $90 while
>0184b8	4a 85					.word NotImplemented       & $FFFF ; $91 repeat
>0184ba	4a 85					.word NotImplemented       & $FFFF ; $92 for
>0184bc	4a 85					.word NotImplemented       & $FFFF ; $93 then
>0184be	4a 85					.word NotImplemented       & $FFFF ; $94 endif
>0184c0	4a 85					.word NotImplemented       & $FFFF ; $95 wend
>0184c2	4a 85					.word NotImplemented       & $FFFF ; $96 until
>0184c4	4a 85					.word NotImplemented       & $FFFF ; $97 next
>0184c6	4a 85					.word NotImplemented       & $FFFF ; $98 not
>0184c8	4a 85					.word NotImplemented       & $FFFF ; $99 fn(
>0184ca	d4 8c					.word Unary_Abs            & $FFFF ; $9a abs(
>0184cc	2c 8e					.word Unary_Asc            & $FFFF ; $9b asc(
>0184ce	0a 9e					.word Unary_Int            & $FFFF ; $9c int(
>0184d0	f2 8c					.word Unary_Peek           & $FFFF ; $9d peek(
>0184d2	81 9d					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0184d4	66 8d					.word Unary_Usr            & $FFFF ; $9f usr(
>0184d6	6d 8e					.word Unary_Left           & $FFFF ; $a0 left$(
>0184d8	84 8e					.word Unary_Right          & $FFFF ; $a1 right$(
>0184da	52 8e					.word Unary_Mid            & $FFFF ; $a2 mid$(
>0184dc	e6 8f					.word Unary_Spc            & $FFFF ; $a3 spc(
>0184de	f9 8d					.word Unary_Str            & $FFFF ; $a4 str$(
>0184e0	88 8d					.word Unary_Val            & $FFFF ; $a5 val(
>0184e2	43 8e					.word Unary_Len            & $FFFF ; $a6 len(
>0184e4	02 8f					.word Unary_Hex            & $FFFF ; $a7 hex$(
>0184e6	4a 85					.word NotImplemented       & $FFFF ; $a8 sin(
>0184e8	4a 85					.word NotImplemented       & $FFFF ; $a9 cos(
>0184ea	4a 85					.word NotImplemented       & $FFFF ; $aa tan(
>0184ec	4a 85					.word NotImplemented       & $FFFF ; $ab atn(
>0184ee	4a 85					.word NotImplemented       & $FFFF ; $ac exp(
>0184f0	4a 85					.word NotImplemented       & $FFFF ; $ad log(
>0184f2	4a 85					.word NotImplemented       & $FFFF ; $ae sqr(
>0184f4	5c 8f					.word Unary_Dec            & $FFFF ; $af dec(
>0184f6	f6 8c					.word Unary_Deek           & $FFFF ; $b0 deek(
>0184f8	fa 8c					.word Unary_Leek           & $FFFF ; $b1 leek(
>0184fa	2e 8d					.word Unary_Mod            & $FFFF ; $b2 mod(
>0184fc	82 8c					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>0184fe	c4 8f					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018500	4a 85					.word NotImplemented       & $FFFF ; $b5 $
>018502	4a 85					.word NotImplemented       & $FFFF ; $b6 $(
>018504	4a 85					.word NotImplemented       & $FFFF ; $b7 #
>018506	4a 85					.word NotImplemented       & $FFFF ; $b8 #(
>018508	4a 85					.word NotImplemented       & $FFFF ; $b9 %
>01850a	4a 85					.word NotImplemented       & $FFFF ; $ba %(
>01850c	4a 85					.word NotImplemented       & $FFFF ; $bb (
>01850e	4a 85					.word NotImplemented       & $FFFF ; $bc )
>018510	4a 85					.word NotImplemented       & $FFFF ; $bd ,
>018512	46 87					.word Command_COLON        & $FFFF ; $be :
>018514	4a 85					.word NotImplemented       & $FFFF ; $bf ;
>018516	4a 85					.word NotImplemented       & $FFFF ; $c0 def
>018518	fb 87					.word Command_CLR          & $FFFF ; $c1 clr
>01851a	0c 88					.word Command_STOP         & $FFFF ; $c2 stop
>01851c	4a 85					.word NotImplemented       & $FFFF ; $c3 data
>01851e	4a 85					.word NotImplemented       & $FFFF ; $c4 read
>018520	4a 85					.word NotImplemented       & $FFFF ; $c5 dim
>018522	4a 85					.word NotImplemented       & $FFFF ; $c6 to
>018524	4a 85					.word NotImplemented       & $FFFF ; $c7 step
>018526	4a 85					.word NotImplemented       & $FFFF ; $c8 gosub
>018528	4a 85					.word NotImplemented       & $FFFF ; $c9 return
>01852a	4a 85					.word NotImplemented       & $FFFF ; $ca goto
>01852c	68 87					.word Command_END          & $FFFF ; $cb end
>01852e	4a 85					.word NotImplemented       & $FFFF ; $cc input
>018530	47 87					.word Command_LET          & $FFFF ; $cd let
>018532	4a 85					.word NotImplemented       & $FFFF ; $ce list
>018534	4a 85					.word NotImplemented       & $FFFF ; $cf new
>018536	4a 85					.word NotImplemented       & $FFFF ; $d0 old
>018538	4a 85					.word NotImplemented       & $FFFF ; $d1 on
>01853a	4a 85					.word NotImplemented       & $FFFF ; $d2 restore
>01853c	4a 85					.word NotImplemented       & $FFFF ; $d3 poke
>01853e	6c 87					.word Command_PRINT        & $FFFF ; $d4 print
>018540	cc 86					.word Command_RUN          & $FFFF ; $d5 run
>018542	4a 85					.word NotImplemented       & $FFFF ; $d6 wait
>018544	4a 85					.word NotImplemented       & $FFFF ; $d7 doke
>018546	4a 85					.word NotImplemented       & $FFFF ; $d8 loke
>018548	df 87					.word Command_ASSERT       & $FFFF ; $d9 assert
.01854a					NotImplemented:
.01854a	20 2f 84	jsr $01842f			jsr ERR_Handler
>01854d	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>018555	65 6d 65 6e 74 65 64 00
.01855d					BinaryPrecedence:
>01855d	01					.byte 1    ; $80 and
>01855e	01					.byte 1    ; $81 or
>01855f	01					.byte 1    ; $82 xor
>018560	01					.byte 1    ; $83 eor
>018561	02					.byte 2    ; $84 =
>018562	02					.byte 2    ; $85 <>
>018563	02					.byte 2    ; $86 <
>018564	02					.byte 2    ; $87 <=
>018565	02					.byte 2    ; $88 >
>018566	02					.byte 2    ; $89 >=
>018567	03					.byte 3    ; $8a +
>018568	03					.byte 3    ; $8b -
>018569	04					.byte 4    ; $8c *
>01856a	04					.byte 4    ; $8d /
>01856b	05					.byte 5    ; $8e ^
.01856c					KeywordText:
>01856c	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01856f	4f d2					.byte $4f,$d2                          ; $81 or
>018571	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>018574	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>018577	bd					.byte $bd                              ; $84 =
>018578	3c be					.byte $3c,$be                          ; $85 <>
>01857a	bc					.byte $bc                              ; $86 <
>01857b	3c bd					.byte $3c,$bd                          ; $87 <=
>01857d	be					.byte $be                              ; $88 >
>01857e	3e bd					.byte $3e,$bd                          ; $89 >=
>018580	ab					.byte $ab                              ; $8a +
>018581	ad					.byte $ad                              ; $8b -
>018582	aa					.byte $aa                              ; $8c *
>018583	af					.byte $af                              ; $8d /
>018584	de					.byte $de                              ; $8e ^
>018585	49 c6					.byte $49,$c6                          ; $8f if
>018587	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>01858c	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>018592	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>018595	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>018599	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>01859e	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0185a2	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0185a7	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0185ab	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0185ae	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0185b1	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0185b5	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0185b9	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0185bd	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0185c2	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0185c6	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0185ca	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0185d0	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>0185d7	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>0185dc	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>0185e0	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>0185e5	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>0185e9	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>0185ed	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>0185f2	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>0185f6	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>0185fa	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>0185fe	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018602	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018606	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01860a	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01860e	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018612	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018617	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01861c	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018620	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018624	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018629	a4					.byte $a4                              ; $b5 $
>01862a	24 a8					.byte $24,$a8                          ; $b6 $(
>01862c	a3					.byte $a3                              ; $b7 #
>01862d	23 a8					.byte $23,$a8                          ; $b8 #(
>01862f	a5					.byte $a5                              ; $b9 %
>018630	25 a8					.byte $25,$a8                          ; $ba %(
>018632	a8					.byte $a8                              ; $bb (
>018633	a9					.byte $a9                              ; $bc )
>018634	ac					.byte $ac                              ; $bd ,
>018635	ba					.byte $ba                              ; $be :
>018636	bb					.byte $bb                              ; $bf ;
>018637	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>01863a	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>01863d	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>018641	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>018645	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>018649	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>01864c	54 cf					.byte $54,$cf                          ; $c6 to
>01864e	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>018652	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>018657	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>01865d	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>018661	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>018664	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>018669	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>01866c	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>018670	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>018673	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>018676	4f ce					.byte $4f,$ce                          ; $d1 on
>018678	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>01867f	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>018683	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>018688	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>01868b	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>01868f	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>018693	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>018697	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>01869d	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.01869e					BASIC_Start:
.01869e	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0186a1	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0186a4	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0186a6	8d 04 03	sta $0304			sta 	LocalVector
.0186a9	8d 00 03	sta $0300			sta 	UserVector
.0186ac	a9 76		lda #$76			lda 	#USRDefault & $FF 			; reset USR vector
.0186ae	8d 01 03	sta $0301			sta 	UserVector+1
.0186b1	a9 8d		lda #$8d			lda 	#(USRDefault >> 8) & $FF
.0186b3	8d 02 03	sta $0302			sta 	UserVector+2
.0186b6	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0186b8	8d 03 03	sta $0303			sta 	UserVector+3
.0186bb	20 fb 87	jsr $0187fb			jsr 	ResetRunStatus 				; clear everything (CLR command)
.0186be					WarmStart:
.0186be	c2 30		rep #$30			rep 	#$30
.0186c0	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.0186c3	1b		tcs				tcs
.0186c4	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.0186c7	e2 30		sep #$30			sep 	#$30
.0186c9	4c cc 86	jmp $0186cc			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0186cc					Command_RUN:
.0186cc	20 fb 87	jsr $0187fb			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0186cf	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0186d1	85 16		sta $16				sta 	zCodePtr+0
.0186d3	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0186d5	85 17		sta $17				sta 	zCodePtr+1
.0186d7	a9 00		lda #$00			lda 	#0
.0186d9	85 18		sta $18				sta 	zCodePtr+2
.0186db	85 19		sta $19				sta 	zCodePtr+3
.0186dd	a0 03		ldy #$03			ldy 	#3
.0186df					RUN_NewLine:
.0186df	a0 00		ldy #$00			ldy 	#0
.0186e1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0186e3	c8		iny				iny
.0186e4	c8		iny				iny
.0186e5	c8		iny				iny
.0186e6	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0186e8	d0 16		bne $018700			bne 	RUN_NextCommand
.0186ea	4c 0c 88	jmp $01880c			jmp 	Command_STOP 				; go do the command code.
.0186ed					RUN_Skip:
.0186ed	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0186ef	c8		iny				iny 								; skip
.0186f0	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0186f2	90 0c		bcc $018700			bcc 	_SEDone 					; so just skip over it.
.0186f4	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0186f6	90 07		bcc $0186ff			bcc 	_SEDouble
.0186f8	98		tya				tya 								; this is Y + 1
.0186f9	18		clc				clc
.0186fa	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0186fc	a8		tay				tay 								; back in Y.
.0186fd	88		dey				dey 								; fix up, one for the +1, one for the iny
.0186fe	88		dey				dey
.0186ff					_SEDouble:
.0186ff	c8		iny				iny
.018700					_SEDone:
.018700					RUN_NextCommand:
.018700	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.018702	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.018704	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018706	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.018708	f0 e3		beq $0186ed			beq 	RUN_Skip
.01870a	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.01870c	d0 0f		bne $01871d			bne 	RUN_Execute
.01870e					RUN_NextLine:
.01870e	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018710	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018712	18		clc				clc
.018713	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018715	85 16		sta $16				sta 	zCodePtr
.018717	90 02		bcc $01871b			bcc 	_SNLNoCarry
.018719	e6 17		inc $17				inc 	zCodePtr+1
.01871b					_SNLNoCarry:
.01871b	80 c2		bra $0186df			bra 	RUN_NewLine 				; go do the new line code
.01871d					RUN_Execute:
.01871d	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01871f	b0 1e		bcs $01873f			bcs 	RUN_Extension
.018721	c8		iny				iny
.018722	0a		asl a				asl 	a 							; double the character read.
.018723	90 14		bcc $018739			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018725	aa		tax				tax 								; ready to look up.
.018726	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into LocalVector
.01872a	8d 05 03	sta $0305			sta 	LocalVector+1
.01872d	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.018731	8d 06 03	sta $0306			sta 	LocalVector+2
.018734	20 27 89	jsr $018927			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018737	80 c7		bra $018700			bra 	RUN_NextCommand 			; do the next command.
.018739					RUN_Default:
.018739	88		dey				dey
.01873a	20 47 87	jsr $018747			jsr 	Command_LET 				; and try LET.
.01873d	80 c1		bra $018700			bra 	RUN_NextCommand
.01873f					RUN_Extension:
.01873f	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.018741	f0 aa		beq $0186ed			beq 	RUN_Skip 					; skip over it.
.018743	4c 00 84	jmp $018400			jmp 	SyntaxError
.018746					Command_COLON:
.018746	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018747					Command_LET:
.018747	20 f1 90	jsr $0190f1			jsr 	VariableFind 				; get reference to one variable.
.01874a	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.01874c	20 37 90	jsr $019037			jsr 	CheckNextToken
.01874f	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.018751	48		pha				pha
.018752	a5 23		lda $23				lda 	zVarDataPtr+1
.018754	48		pha				pha
.018755	a5 24		lda $24				lda 	zVarType
.018757	48		pha				pha
.018758	20 17 88	jsr $018817			jsr 	EvaluateExpression 			; evaluate the RHS.
.01875b	68		pla				pla 								; restore target variable information.
.01875c	85 24		sta $24				sta 	zVarType
.01875e	68		pla				pla
.01875f	85 23		sta $23				sta 	zVarDataPtr+1
.018761	68		pla				pla
.018762	85 22		sta $22				sta 	zVarDataPtr
.018764	20 a3 94	jsr $0194a3			jsr 	VariableSet 				; set the value out.
.018767	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018768					Command_END:
>018768	02						.byte 	2
.018769	4c be 86	jmp $0186be			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.01876c					Command_PRINT:
.01876c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01876e	c9 00		cmp #$00			cmp 	#0 							; end
.018770	f0 69		beq $0187db			beq 	_CPR_NewLine
.018772	c9 be		cmp #$be			cmp 	#token_Colon
.018774	f0 65		beq $0187db			beq 	_CPR_NewLine
.018776	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.018778	f0 54		beq $0187ce			beq 	_CPR_Skip
.01877a	c9 bd		cmp #$bd			cmp 	#token_Comma
.01877c	f0 4d		beq $0187cb			beq 	_CPR_Tab
.01877e	20 17 88	jsr $018817			jsr 	EvaluateExpression 			; get expression.
.018781	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.018784	29 02		and #$02			and 	#2
.018786	d0 25		bne $0187ad			bne 	_CPR_String 				; if type = 2 output as string.
.018788					_CPR_Number:
.018788	a9 00		lda #$00			lda 	#0 							; reset buffer index
.01878a	8d 04 04	sta $0404			sta 	NumBufX
.01878d	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.018790	4a		lsr a				lsr 	a
.018791	b0 05		bcs $018798			bcs 	_CPRInt 					; if msb set do as integer
.018793	20 39 9c	jsr $019c39			jsr 	FPToString 					; call fp to str otherwise
.018796	80 03		bra $01879b			bra 	_CPRNPrint
.018798	20 25 96	jsr $019625	_CPRInt:jsr 	IntToString
.01879b					_CPRNPrint:
.01879b	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.01879e	c9 2d		cmp #$2d			cmp 	#"-"
.0187a0	f0 05		beq $0187a7			beq 	_CPRNoSpace
.0187a2	a9 20		lda #$20			lda 	#" "						; print the leading space
.0187a4	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.0187a7					_CPRNoSpace:
.0187a7	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.0187a9	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.0187ab	80 06		bra $0187b3			bra 	_CPRPrint
.0187ad					_CPR_String:
.0187ad	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.0187b0	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.0187b3					_CPRPrint:
.0187b3	86 1e		stx $1e				stx 	zGenPtr
.0187b5	85 1f		sta $1f				sta 	zGenPtr+1
.0187b7	5a		phy				phy
.0187b8	a0 00		ldy #$00			ldy 	#0							; get length into X
.0187ba	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0187bc	aa		tax				tax
.0187bd	f0 09		beq $0187c8			beq 	_CPREndPrint 				; nothing to print
.0187bf					_CPRLoop:
.0187bf	c8		iny				iny
.0187c0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.0187c2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0187c5	ca		dex				dex
.0187c6	d0 f7		bne $0187bf			bne 	_CPRLoop
.0187c8					_CPREndPrint:
.0187c8	7a		ply				ply
.0187c9	80 a1		bra $01876c			bra 	Command_Print
.0187cb					_CPR_Tab:
.0187cb	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.0187ce					_CPR_Skip:
.0187ce	c8		iny				iny
.0187cf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0187d1	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.0187d3	f0 09		beq $0187de			beq 	_CPR_Exit
.0187d5	c9 00		cmp #$00			cmp 	#0
.0187d7	d0 93		bne $01876c			bne 	Command_PRINT 				; if not go round again.
.0187d9	80 03		bra $0187de			bra 	_CPR_Exit
.0187db					_CPR_NewLine:
.0187db	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.0187de					_CPR_Exit:
.0187de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.0187df					Command_ASSERT:
.0187df	20 bd 89	jsr $0189bd			jsr 	EvaluateNumber 				; calculate thing being asserted
.0187e2	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.0187e5	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.0187e8	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.0187eb	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.0187ee	f0 01		beq $0187f1			beq 	_ASFail
.0187f0	60		rts				rts
.0187f1					_ASFail:
.0187f1	20 2f 84	jsr $01842f			jsr ERR_Handler
>0187f4	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0187fb					Command_CLR:
.0187fb					ResetRunStatus:
.0187fb	20 2d 91	jsr $01912d			jsr 	VariableClear
.0187fe	a9 00		lda #$00			lda 	#HighMemory & $FF
.018800	8d 00 04	sta $0400			sta 	StringPtr
.018803	a9 80		lda #$80			lda 	#HighMemory >> 8
.018805	8d 01 04	sta $0401			sta 	StringPtr+1
.018808	20 00 93	jsr $019300			jsr 	ArrayResetDefault
.01880b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.01880c					Command_STOP:
.01880c	20 2f 84	jsr $01842f			jsr ERR_Handler
>01880f	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018814					EVESyntax:
.018814	4c 00 84	jmp $018400			jmp 	SyntaxError
.018817					EvaluateExpression:
.018817	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018819					EvaluateExpressionX:
.018819	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01881b					EvaluateExpressionXA:
.01881b	48		pha				pha 								; save precedence on stack.
.01881c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01881e	f0 f4		beq $018814			beq 	EVESyntax 					; end of line, syntax error.
.018820	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018822	b0 03		bcs $018827			bcs 	_EVNotVariable
.018824	4c 1e 89	jmp $01891e			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018827					_EVNotVariable:
.018827	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018829	90 e9		bcc $018814			bcc 	EVESyntax
.01882b	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01882d	b0 7f		bcs $0188ae			bcs 	_EVNotInteger
.01882f	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018831	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018834	a9 00		lda #$00			lda 	#0
.018836	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018839	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01883c	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.01883f	1a		inc a				inc 	a 							; set to type 1 (integer)
.018840	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018843					_EVCheckNextInteger:
.018843	c8		iny				iny
.018844	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018846	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018848	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01884a	b0 0d		bcs $018859			bcs 	_EVCheckDecimal
.01884c	48		pha				pha 								; save it.
.01884d	20 2a 89	jsr $01892a			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018850	68		pla				pla
.018851	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018854	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018857	80 ea		bra $018843			bra 	_EVCheckNextInteger
.018859					_EVCheckDecimal:
.018859	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01885b	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.01885d	d0 05		bne $018864			bne 	_EVGotAtom 					; no, get atom.
.01885f					_EVIsDecimal:
.01885f	20 5a 89	jsr $01895a			jsr 	EVGetDecimal 				; extend to the decimal part.
.018862	80 00		bra $018864			bra 	_EVGotAtom 					; and continue to got atom.
.018864					_EVGotAtom:
.018864	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018866	10 44		bpl $0188ac			bpl 	_EVExitDrop 				; must be a token.
.018868	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.01886a	b0 40		bcs $0188ac			bcs 	_EVExitDrop
.01886c	68		pla				pla 								; get current precedence
.01886d	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.01886f	da		phx				phx 								; save X
.018870	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018872	aa		tax				tax 								; put in X
.018873	bf dd 84 01	lda $0184dd,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018877	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018879	fa		plx				plx 								; restore X
.01887a	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.01887c	90 2f		bcc $0188ad			bcc 	_EVExit 					; exit if too low.
.01887e	f0 2d		beq $0188ad			beq 	_EVExit 					; exit if equals
.018880	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018882	48		pha				pha
.018883	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018885	48		pha				pha
.018886	c8		iny				iny
.018887	da		phx				phx 								; save current position
.018888	e8		inx				inx
.018889	e8		inx				inx
.01888a	e8		inx				inx
.01888b	e8		inx				inx
.01888c	e8		inx				inx
.01888d	e8		inx				inx
.01888e	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018890	20 1b 88	jsr $01881b			jsr 	EvaluateExpressionXA 		; do the RHS.
.018893	fa		plx				plx 								; restore X
.018894	68		pla				pla 								; get the binary operator in A.
.018895					_EVCallA:
.018895	da		phx				phx 								; save X again
.018896	0a		asl a				asl 	a 							; double, lose the MSB.
.018897	aa		tax				tax									; put in X
.018898	bf 96 84 01	lda $018496,x			lda 	VectorTable,x 				; copy address into zGenPtr
.01889c	8d 05 03	sta $0305			sta 	LocalVector+1
.01889f	bf 97 84 01	lda $018497,x			lda 	VectorTable+1,x
.0188a3	8d 06 03	sta $0306			sta 	LocalVector+2
.0188a6	fa		plx				plx 								; restore X
.0188a7	20 27 89	jsr $018927			jsr 	EVCallLocalVector
.0188aa	80 b8		bra $018864			bra 	_EVGotAtom 					; and loop back.
.0188ac					_EVExitDrop:
.0188ac	68		pla				pla
.0188ad					_EVExit:
.0188ad	60		rts				rts
.0188ae					_EVNotInteger:
.0188ae	c8		iny				iny
.0188af	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0188b1	d0 19		bne $0188cc			bne 	_EVNotMinus
.0188b3	20 ab 89	jsr $0189ab			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0188b6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.0188b9	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0188bb	f0 05		beq $0188c2			beq 	_EVMinusFloat
.0188bd	20 00 96	jsr $019600			jsr 	IntegerNegateAlways 		; negation
.0188c0	80 a2		bra $018864			bra 	_EVGotAtom 					; and go back.
.0188c2					_EVMinusFloat:
.0188c2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.0188c5	49 80		eor #$80			eor 	#$80
.0188c7	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0188ca	80 98		bra $018864			bra 	_EVGotAtom
.0188cc					_EVNotMinus:
.0188cc	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.0188ce	d0 17		bne $0188e7			bne 	_EVNotParenthesis
.0188d0	20 19 88	jsr $018819			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0188d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188d5	c8		iny				iny
.0188d6	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.0188d8	f0 8a		beq $018864			beq 	_EVGotAtom
.0188da	20 2f 84	jsr $01842f			jsr ERR_Handler
>0188dd	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0188e5	29 00
.0188e7					_EVNotParenthesis:
.0188e7	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0188e9	d0 0c		bne $0188f7			bne 	_EVNotNot
.0188eb	20 ab 89	jsr $0189ab			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0188ee	20 0e 9b	jsr $019b0e			jsr 	FPUToInteger 				; make it an integer - if possible.
.0188f1	20 88 89	jsr $018988			jsr 	NotInteger 					; do the not calculation
.0188f4	4c 64 88	jmp $018864			jmp 	_EVGotAtom
.0188f7					_EVNotNot:
.0188f7	c9 fe		cmp #$fe			cmp 	#$FE
.0188f9	d0 15		bne $018910			bne 	_EVNotString
.0188fb	20 cb 90	jsr $0190cb			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0188fe	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018900	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018903	a5 21		lda $21				lda 	zTempStr+1
.018905	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018908	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.01890a	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01890d	4c 64 88	jmp $018864			jmp 	_EVGotAtom
.018910					_EVNotString:
.018910	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018912	90 04		bcc $018918			bcc 	_EVBadElement
.018914	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.018916	90 03		bcc $01891b			bcc 	_EVUnaryFunction
.018918					_EVBadElement:
.018918	4c 00 84	jmp $018400			jmp 	SyntaxError
.01891b					_EVUnaryFunction:
.01891b	4c 95 88	jmp $018895			jmp 	_EVCallA
.01891e					_EVVariableHandler:
.01891e	20 f1 90	jsr $0190f1			jsr 	VariableFind 				; locate a variable
.018921	20 42 94	jsr $019442			jsr 	VariableGet 				; copy into memory.
.018924	4c 64 88	jmp $018864			jmp 	_EVGotAtom 					; and go round.
.018927					EVCallLocalVector:
.018927	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.01892a					EVShiftMantissaLeft6:
.01892a	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.01892d	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.018930	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018933	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018936	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018939	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01893c	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01893f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018942	a9 00		lda #$00			lda 	#0
.018944	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018947	20 4a 89	jsr $01894a			jsr 	_EVSMLShift 					; call it here to do it twice
.01894a					_EVSMLShift:
.01894a	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.01894d	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.018950	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.018953	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.018956	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.018959	60		rts				rts
.01895a					EVGetDecimal:
.01895a	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01895c	8d 05 04	sta $0405			sta 	Num_Buffer
.01895f	da		phx				phx
.018960	c8		iny				iny
.018961	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018963	c8		iny				iny
.018964	3a		dec a				dec 	a								; convert to a string length.
.018965	3a		dec a				dec 	a
.018966	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018968					_EVGDCopy:
.018968	48		pha				pha 									; save count
.018969	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01896b	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.01896e	e8		inx				inx 									; forward ....
.01896f	c8		iny				iny
.018970	68		pla				pla 									; get count
.018971	3a		dec a				dec 	a 								; until zero
.018972	d0 f4		bne $018968			bne 	_EVGDCopy
.018974	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018977	fa		plx				plx 									; restore X
.018978	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.01897a	85 1e		sta $1e				sta 	zGenPtr
.01897c	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.01897e	85 1f		sta $1f				sta 	zGenPtr+1
.018980	5a		phy				phy 									; save Y
.018981	a0 00		ldy #$00			ldy 	#0 								; start position
.018983	20 00 9d	jsr $019d00			jsr 	FPFromString 					; convert current
.018986	7a		ply				ply 									; restore Y
.018987	60		rts				rts
.018988					NotInteger:
.018988	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.01898b	49 ff		eor #$ff			eor 	#$FF
.01898d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018990	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018993	49 ff		eor #$ff			eor 	#$FF
.018995	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018998	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01899b	49 ff		eor #$ff			eor 	#$FF
.01899d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0189a0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0189a3	49 ff		eor #$ff			eor 	#$FF
.0189a5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0189a8	60		rts				rts
.0189a9					EvaluateGetAtom:
.0189a9	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0189ab					EvaluateGetAtomX:
.0189ab	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0189ad	20 1b 88	jsr $01881b			jsr 	EvaluateExpressionXA
.0189b0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0189b3	29 0f		and #$0f			and 	#15
.0189b5	c9 02		cmp #$02			cmp 	#2
.0189b7	b0 01		bcs $0189ba			bcs 	EvaluateType
.0189b9	60		rts				rts
.0189ba					EvaluateType:
.0189ba	4c 10 84	jmp $018410			jmp 	TypeError
.0189bd					EvaluateNumber:
.0189bd	a2 00		ldx #$00			ldx 	#0
.0189bf					EvaluateNumberX:
.0189bf	20 19 88	jsr $018819			jsr 	EvaluateExpressionX
.0189c2	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.0189c5	29 0f		and #$0f			and 	#15
.0189c7	c9 02		cmp #$02			cmp 	#2
.0189c9	b0 ef		bcs $0189ba			bcs 	EvaluateType
.0189cb	60		rts				rts
.0189cc					EvaluateInteger:
.0189cc	a2 00		ldx #$00			ldx 	#0
.0189ce					EvaluateIntegerX:
.0189ce	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX
.0189d1	20 0e 9b	jsr $019b0e			jsr 	FPUToInteger
.0189d4	60		rts				rts
.0189d5					EvaluateString:
.0189d5	a2 00		ldx #$00			ldx 	#0
.0189d7					EvaluateStringX:
.0189d7	20 19 88	jsr $018819			jsr 	EvaluateExpressionX
.0189da	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.0189dd	29 0f		and #$0f			and 	#15
.0189df	c9 02		cmp #$02			cmp 	#2
.0189e1	d0 d7		bne $0189ba			bne 	EvaluateType
.0189e3	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0189e6	85 1e		sta $1e				sta 	zGenPtr
.0189e8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0189eb	85 1f		sta $1f				sta 	zGenPtr+1
.0189ed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0189ee					BinaryOp_And:
.0189ee	20 66 8a	jsr $018a66			jsr 	BinaryMakeBothInteger
.0189f1	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.0189f4	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.0189f7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0189fa	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.0189fd	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.018a00	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a03	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a06	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.018a09	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a0c	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a0f	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.018a12	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a15	60		rts				rts
.018a16					BinaryOp_Or:
.018a16	20 66 8a	jsr $018a66			jsr 	BinaryMakeBothInteger
.018a19	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a1c	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.018a1f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a22	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018a25	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.018a28	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a2b	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a2e	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.018a31	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a34	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a37	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.018a3a	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a3d	60		rts				rts
.018a3e					BinaryOp_Eor:
.018a3e					BinaryOp_Xor:
.018a3e	20 66 8a	jsr $018a66			jsr 	BinaryMakeBothInteger
.018a41	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.018a44	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.018a47	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018a4a	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.018a4d	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.018a50	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a53	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.018a56	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.018a59	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a5c	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.018a5f	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.018a62	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a65	60		rts				rts
.018a66					BinaryMakeBothInteger:
.018a66	da		phx				phx 								; save X
.018a67	e8		inx				inx
.018a68	e8		inx				inx
.018a69	e8		inx				inx
.018a6a	e8		inx				inx
.018a6b	e8		inx				inx
.018a6c	e8		inx				inx
.018a6d	20 71 8a	jsr $018a71			jsr 	BinaryMakeInteger 			; convert to integer.
.018a70	fa		plx				plx 								; restore X and fall through.
.018a71					BinaryMakeInteger:
.018a71	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018a74	29 0f		and #$0f			and 	#15 						; check type zero
.018a76	f0 04		beq $018a7c			beq 	_BMIConvert 				; if float convert to integer.
.018a78	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018a79	90 04		bcc $018a7f			bcc 	_BMIError
.018a7b	60		rts				rts
.018a7c					_BMIConvert:
.018a7c	4c 0e 9b	jmp $019b0e			jmp 	FPUToInteger 				; convert to integer
.018a7f					_BMIError:
.018a7f	4c 10 84	jmp $018410			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018a82					Binary_Equal:
.018a82	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018a85	09 00		ora #$00			ora 	#0
.018a87	f0 04		beq $018a8d			beq 	CCTrue
.018a89	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018a8b	80 02		bra $018a8f			bra 	CCWrite
.018a8d	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018a8f	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018a92	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018a95	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018a98	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018a9b	a9 01		lda #$01			lda 	#1
.018a9d	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.018aa0	60		rts				rts
.018aa1					Binary_NotEqual:
.018aa1	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018aa4	09 00		ora #$00			ora 	#0
.018aa6	f0 e1		beq $018a89			beq 	CCFalse
.018aa8	80 e3		bra $018a8d			bra 	CCTrue
.018aaa					Binary_Less:
.018aaa	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018aad	09 00		ora #$00			ora 	#0
.018aaf	30 dc		bmi $018a8d			bmi 	CCTrue
.018ab1	80 d6		bra $018a89			bra 	CCFalse
.018ab3					Binary_LessEqual:
.018ab3	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018ab6	c9 01		cmp #$01			cmp 	#1
.018ab8	d0 d3		bne $018a8d			bne 	CCTrue
.018aba	80 cd		bra $018a89			bra 	CCFalse
.018abc					Binary_GreaterEqual:
.018abc	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018abf	09 00		ora #$00			ora 	#0
.018ac1	10 ca		bpl $018a8d			bpl 	CCTrue
.018ac3	80 c4		bra $018a89			bra 	CCFalse
.018ac5					Binary_Greater:
.018ac5	20 ce 8a	jsr $018ace			jsr 	CompareValues
.018ac8	c9 01		cmp #$01			cmp 	#1
.018aca	f0 c1		beq $018a8d			beq 	CCTrue
.018acc	80 bb		bra $018a89			bra 	CCFalse
.018ace					CompareValues:
.018ace	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.018ad1	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ad4	c9 02		cmp #$02			cmp 	#2
.018ad6	f0 13		beq $018aeb			beq 	_CVString
.018ad8	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018adb	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ade	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018adf	90 03		bcc $018ae4			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ae1	4c 31 8b	jmp $018b31			jmp 	CompareInteger32 							; so execute code at \1
.018ae4					_BCFloat:
.018ae4	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018ae7	4c 1d 9a	jmp $019a1d			jmp 	FPCompare 							; and execute code at \2
.018aea	60		rts				rts
.018aeb					_CVString:
.018aeb	da		phx				phx 								; save XY
.018aec	5a		phy				phy
.018aed	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018af0	85 1a		sta $1a				sta		zLTemp1+0
.018af2	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018af5	85 1b		sta $1b				sta 	zLTemp1+1
.018af7	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018afa	85 1c		sta $1c				sta 	zLTemp1+2
.018afc	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018aff	85 1d		sta $1d				sta 	zLTemp1+3
.018b01	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.018b03	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018b05	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b07	90 02		bcc $018b0b			bcc 	_CVCommon
.018b09	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.018b0b					_CVCommon:
.018b0b	aa		tax				tax 								; put shorter string length in zero.
.018b0c	f0 0c		beq $018b1a			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.018b0e					_CVCompare:
.018b0e	c8		iny				iny 								; next character
.018b0f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.018b11	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b13	90 13		bcc $018b28			bcc 	_CVReturnLess 				; <
.018b15	d0 15		bne $018b2c			bne 	_CVReturnGreater 			; >
.018b17	ca		dex				dex 								; until common length matched.
.018b18	d0 f4		bne $018b0e			bne 	_CVCompare
.018b1a					_CVMatch:
.018b1a	a0 00		ldy #$00			ldy 	#0
.018b1c	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018b1e	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.018b20	90 06		bcc $018b28			bcc 	_CVReturnLess 				; <
.018b22	d0 08		bne $018b2c			bne 	_CVReturnGreater 			; >
.018b24	a9 00		lda #$00			lda 	#0
.018b26	80 06		bra $018b2e			bra 	_CVExit 					; same common, same length, same string
.018b28					_CVReturnLess:
.018b28	a9 ff		lda #$ff			lda 	#$FF
.018b2a	80 02		bra $018b2e			bra 	_CVExit
.018b2c					_CVReturnGreater:
.018b2c	a9 01		lda #$01			lda 	#$01
.018b2e					_CVExit:
.018b2e	7a		ply				ply
.018b2f	fa		plx				plx
.018b30	60		rts				rts
.018b31					CompareInteger32:
.018b31	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.018b34	49 80		eor #$80			eor 	#$80
.018b36	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018b39	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.018b3c	49 80		eor #$80			eor 	#$80
.018b3e	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.018b41	20 d9 8b	jsr $018bd9			jsr 	SubInteger32 				; subtraction
.018b44	90 11		bcc $018b57			bcc 	_CI32Less 					; cc return -1
.018b46	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.018b49	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018b4c	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018b4f	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018b52	f0 02		beq $018b56			beq 	_CI32Exit
.018b54	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.018b56					_CI32Exit:
.018b56	60		rts				rts
.018b57					_CI32Less:
.018b57	a9 ff		lda #$ff			lda 	#$FF
.018b59	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.018b5a					BinaryOp_Add:
.018b5a	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.018b5d	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b60	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.018b62	d0 13		bne $018b77			bne 	_BOAString
.018b64	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b67	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b6a	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b6b	90 03		bcc $018b70			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b6d	4c b3 8b	jmp $018bb3			jmp 	AddInteger32 							; so execute code at \1
.018b70					_BCFloat:
.018b70	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b73	4c 91 97	jmp $019791			jmp 	FPAdd 							; and execute code at \2
.018b76	60		rts				rts
.018b77					_BOAString:
.018b77	4c 1a 8c	jmp $018c1a			jmp 	ConcatenateString 			; concatenate two strings.
.018b7a					BinaryOp_Subtract:
.018b7a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b7d	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b80	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b81	90 03		bcc $018b86			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b83	4c d9 8b	jmp $018bd9			jmp 	SubInteger32 							; so execute code at \1
.018b86					_BCFloat:
.018b86	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b89	4c 87 97	jmp $019787			jmp 	FPSubtract 							; and execute code at \2
.018b8c	60		rts				rts
.018b8d					BinaryOp_Multiply:
.018b8d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018b90	3d 13 03	and $0313,x			and 	XS2_Type,x
.018b93	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018b94	90 03		bcc $018b99			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018b96	4c 13 95	jmp $019513			jmp 	MulInteger32 							; so execute code at \1
.018b99					_BCFloat:
.018b99	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018b9c	4c fd 98	jmp $0198fd			jmp 	FPMultiply 							; and execute code at \2
.018b9f	60		rts				rts
.018ba0					BinaryOp_Divide:
.018ba0	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.018ba3	3d 13 03	and $0313,x			and 	XS2_Type,x
.018ba6	4a		lsr a				lsr 	a 							; shift bit 0 into C
.018ba7	90 03		bcc $018bac			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.018ba9	4c 6a 95	jmp $01956a			jmp 	DivInteger32 							; so execute code at \1
.018bac					_BCFloat:
.018bac	20 ff 8b	jsr $018bff			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.018baf	4c 75 98	jmp $019875			jmp 	FPDivide 							; and execute code at \2
.018bb2	60		rts				rts
.018bb3					AddInteger32:
.018bb3	18		clc				clc
.018bb4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bb7	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.018bba	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018bbd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018bc0	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.018bc3	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018bc6	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018bc9	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.018bcc	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018bcf	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018bd2	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.018bd5	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bd8	60		rts				rts
.018bd9					SubInteger32:
.018bd9	38		sec				sec
.018bda	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018bdd	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.018be0	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018be3	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018be6	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.018be9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018bec	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018bef	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.018bf2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018bf5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018bf8	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.018bfb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018bfe	60		rts				rts
.018bff					BinaryMakeBothFloat:
.018bff	da		phx				phx 								; save X
.018c00	e8		inx				inx
.018c01	e8		inx				inx
.018c02	e8		inx				inx
.018c03	e8		inx				inx
.018c04	e8		inx				inx
.018c05	e8		inx				inx
.018c06	20 0a 8c	jsr $018c0a			jsr 	BinaryMakeFloat 			; convert to float.
.018c09	fa		plx				plx 								; restore X and fall through.
.018c0a					BinaryMakeFloat:
.018c0a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.018c0d	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.018c0e	b0 04		bcs $018c14			bcs 	_BMFConvert
.018c10	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.018c11	b0 04		bcs $018c17			bcs 	_BMFError
.018c13	60		rts				rts
.018c14					_BMFConvert:
.018c14	4c af 9a	jmp $019aaf			jmp 	FPUToFloat 					; convert to float
.018c17					_BMFError:
.018c17	4c 10 84	jmp $018410			jmp 	TypeError
.018c1a					ConcatenateString:
.018c1a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.018c1d	85 1a		sta $1a				sta		zLTemp1+0
.018c1f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018c22	85 1b		sta $1b				sta 	zLTemp1+1
.018c24	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.018c27	85 1c		sta $1c				sta 	zLTemp1+2
.018c29	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018c2c	85 1d		sta $1d				sta 	zLTemp1+3
.018c2e	5a		phy				phy
.018c2f	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.018c31	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.018c33	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.018c35	7a		ply				ply
.018c36	b0 37		bcs $018c6f			bcs 	_CSError					; check in range.
.018c38	c9 fe		cmp #$fe			cmp 	#maxString+1
.018c3a	b0 33		bcs $018c6f			bcs 	_CSError
.018c3c	20 90 90	jsr $019090			jsr 	AllocateTempString 			; store the result
.018c3f	20 5a 8c	jsr $018c5a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018c42	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.018c45	85 1a		sta $1a				sta 	zLTemp1
.018c47	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.018c4a	85 1b		sta $1b				sta 	zLTemp1+1
.018c4c	20 5a 8c	jsr $018c5a			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.018c4f	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.018c51	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018c54	a5 21		lda $21				lda 	zTempStr+1
.018c56	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018c59	60		rts				rts
.018c5a					_CSCopyString:
.018c5a	da		phx				phx
.018c5b	5a		phy				phy
.018c5c	a0 00		ldy #$00			ldy 	#0 							; get length
.018c5e	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c60	f0 0a		beq $018c6c			beq 	_CSCSExit 					; if zero, exit
.018c62	aa		tax				tax 								; put in X
.018c63					_CSCSLoop:
.018c63	c8		iny				iny 								; get next char
.018c64	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.018c66	20 bb 90	jsr $0190bb			jsr		WriteTempString 			; copy out
.018c69	ca		dex				dex 								; do whole string
.018c6a	d0 f7		bne $018c63			bne 	_CSCSLoop
.018c6c					_CSCSExit:
.018c6c	7a		ply				ply
.018c6d	fa		plx				plx
.018c6e	60		rts				rts
.018c6f					_CSError:
.018c6f	20 2f 84	jsr $01842f			jsr ERR_Handler
>018c72	53 74 72 69 6e 67 20 74			.text "String too long",0
>018c7a	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.018c82					Unary_Sgn:
.018c82	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.018c85	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.018c88	20 ac 8c	jsr $018cac			jsr 	GetSignCurrent 				; get sign.
.018c8b	09 00		ora #$00			ora 	#0
.018c8d	10 09		bpl $018c98			bpl		UnarySetAInteger			; if 0,1 return that.
.018c8f	80 00		bra $018c91			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.018c91					UnarySetAMinus1:
.018c91	a9 ff		lda #$ff			lda 	#$FF
.018c93	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018c96	80 05		bra $018c9d			bra 	UnarySetAFill
.018c98					UnarySetAInteger:
.018c98	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.018c9b	a9 00		lda #$00			lda 	#0
.018c9d					UnarySetAFill:
.018c9d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018ca0	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018ca3	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018ca6	a9 01		lda #$01			lda 	#1
.018ca8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018cab	60		rts				rts
.018cac					GetSignCurrent:
.018cac	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.018caf	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.018cb0	90 19		bcc $018ccb			bcc 	_GSCFloat
.018cb2	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018cb5	30 11		bmi $018cc8			bmi 	_GSCMinus1
.018cb7	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018cba	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.018cbd	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018cc0	d0 03		bne $018cc5			bne 	_GSCPlus1
.018cc2					_GSCZero:
.018cc2	a9 00		lda #$00			lda 	#0
.018cc4	60		rts				rts
.018cc5					_GSCPlus1:
.018cc5	a9 01		lda #$01			lda 	#$01
.018cc7	60		rts				rts
.018cc8					_GSCMinus1:
.018cc8	a9 ff		lda #$ff			lda 	#$FF
.018cca	60		rts				rts
.018ccb					_GSCFloat:
.018ccb	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.018cce	70 f2		bvs $018cc2			bvs 	_GSCZero
.018cd0	30 f6		bmi $018cc8			bmi 	_GSCMinus1
.018cd2	80 f1		bra $018cc5			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.018cd4					Unary_Abs:
.018cd4	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.018cd7	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.018cda	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018cdd	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018cdf	f0 08		beq $018ce9			beq 	_UAMinusFloat
.018ce1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.018ce4	10 0b		bpl $018cf1			bpl 	_UAExit
.018ce6	4c 00 96	jmp $019600			jmp 	IntegerNegateAlways 		; negation
.018ce9					_UAMinusFloat:
.018ce9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.018cec	29 7f		and #$7f			and		#$7F
.018cee	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018cf1					_UAExit:
.018cf1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.018cf2					Unary_Peek:
.018cf2	a9 01		lda #$01			lda 	#1
.018cf4	80 06		bra $018cfc			bra 	UPMain
.018cf6					Unary_Deek:
.018cf6	a9 02		lda #$02			lda 	#2
.018cf8	80 02		bra $018cfc			bra 	UPMain
.018cfa					Unary_Leek:
.018cfa	a9 04		lda #$04			lda 	#4
.018cfc					UPMain:
.018cfc	48		pha				pha 								; set bytes to copy.
.018cfd	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; numeric parameter
.018d00	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018d03	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.018d06	85 1a		sta $1a				sta 	zLTemp1
.018d08	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d0b	85 1b		sta $1b				sta 	zLTemp1+1
.018d0d	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018d10	85 1c		sta $1c				sta 	zLTemp1+2
.018d12	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.018d15	85 1d		sta $1d				sta 	zLTemp1+3
.018d17	a9 00		lda #$00			lda 	#0 							; clear target area
.018d19	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d1c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d1f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d22	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d25	68		pla				pla 								; restore bytes to copy
.018d26	da		phx				phx 								; save XY
.018d27	5a		phy				phy
.018d28	20 25 90	jsr $019025			jsr 	MemRead 					; read the bytes in
.018d2b	7a		ply				ply 								; restore and exit
.018d2c	fa		plx				plx
.018d2d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.018d2e					Unary_Mod:
.018d2e	20 5a 8d	jsr $018d5a			jsr 	_UMParameter 				; first parameter
.018d31	20 56 90	jsr $019056			jsr 	CheckNextComma
.018d34	da		phx				phx 								; second parameter
.018d35	e8		inx				inx
.018d36	e8		inx				inx
.018d37	e8		inx				inx
.018d38	e8		inx				inx
.018d39	e8		inx				inx
.018d3a	e8		inx				inx
.018d3b	20 5a 8d	jsr $018d5a			jsr 	_UMParameter
.018d3e	fa		plx				plx
.018d3f	20 4e 90	jsr $01904e			jsr 	CheckNextRParen
.018d42	20 6a 95	jsr $01956a			jsr 	DivInteger32 				; divide
.018d45	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.018d47	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018d4a	a5 1b		lda $1b				lda 	zLTemp1+1
.018d4c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018d4f	a5 1c		lda $1c				lda 	zLTemp1+2
.018d51	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018d54	a5 1d		lda $1d				lda 	zLTemp1+3
.018d56	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018d59	60		rts				rts
.018d5a					_UMParameter:
.018d5a	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; get value
.018d5d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.018d60	10 03		bpl $018d65			bpl 	_UMNotSigned
.018d62	20 00 96	jsr $019600			jsr 	IntegerNegateAlways
.018d65					_UMNotSigned:
.018d65	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.018d66					Unary_Usr:
.018d66	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; numeric parameter
.018d69	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018d6c	da		phx				phx 								; save XY
.018d6d	5a		phy				phy
.018d6e	ea		nop				nop
.018d6f	22 00 03 00	jsl $000300			jsl 	UserVector
.018d73	7a		ply				ply 								; and exit
.018d74	fa		plx				plx
.018d75	60		rts				rts
.018d76					USRDefault:
.018d76	20 2f 84	jsr $01842f			jsr ERR_Handler
>018d79	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>018d81	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.018d88					Unary_Val:
.018d88	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; get string
.018d8b	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.018d8e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.018d91	85 1e		sta $1e				sta 	zGenPtr
.018d93	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018d96	85 1f		sta $1f				sta 	zGenPtr+1
.018d98	5a		phy				phy
.018d99	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.018d9b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.018d9d	f0 57		beq $018df6			beq 	_UVBadNumber
.018d9f	48		pha				pha 								; save length.
.018da0	1a		inc a				inc 	a 							; one for the length, one for the terminator
.018da1	1a		inc a				inc 	a
.018da2	20 90 90	jsr $019090			jsr 	AllocateTempString
.018da5	c8		iny				iny 								; move to the next.
.018da6	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.018da8	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.018daa	8d 90 04	sta $0490			sta 	ValSign
.018dad	d0 04		bne $018db3			bne 	_UVNotMinus
.018daf	c8		iny				iny 								; skip over it.
.018db0	68		pla				pla 								; decrement character count.
.018db1	3a		dec a				dec 	a
.018db2	48		pha				pha
.018db3					_UVNotMinus:
.018db3	68		pla				pla 								; this is the count.
.018db4	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.018db5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018db7	c8		iny				iny
.018db8	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018dbb	68		pla				pla
.018dbc	3a		dec a				dec 	a
.018dbd	d0 f5		bne $018db4			bne 	_UVCopy
.018dbf	20 bb 90	jsr $0190bb			jsr 	WriteTempString 			; make it ASCIIZ
.018dc2	18		clc				clc
.018dc3	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.018dc5	69 01		adc #$01			adc 	#1
.018dc7	85 1e		sta $1e				sta 	zGenPtr
.018dc9	a5 21		lda $21				lda 	zTempStr+1
.018dcb	69 00		adc #$00			adc 	#0
.018dcd	85 1f		sta $1f				sta 	zGenPtr+1
.018dcf	18		clc				clc
.018dd0	20 dc 96	jsr $0196dc			jsr 	IntFromString 				; first bit.
.018dd3	b0 21		bcs $018df6			bcs 	_UVBadNumber
.018dd5	20 00 9d	jsr $019d00			jsr 	FPFromString				; try for a float part.
.018dd8	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.018ddb	d0 13		bne $018df0			bne 	_UVNotNegative
.018ddd	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.018de0	4a		lsr a				lsr 	a
.018de1	b0 0a		bcs $018ded			bcs 	_UVInteger
.018de3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.018de6	09 80		ora #$80			ora 	#$80
.018de8	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018deb	80 03		bra $018df0			bra 	_UVNotNegative
.018ded					_UVInteger:
.018ded	20 00 96	jsr $019600			jsr 	IntegerNegateAlways 		; sign it.
.018df0					_UVNotNegative:
.018df0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.018df2	d0 02		bne $018df6			bne 	_UVBadNumber
.018df4	7a		ply				ply
.018df5	60		rts				rts
.018df6					_UVBadNumber:
.018df6	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.018df9					Unary_Str:
.018df9	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; numeric parameter
.018dfc	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018dff	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018e01	8d 04 04	sta $0404			sta 	NumBufX
.018e04	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.018e07	4a		lsr a				lsr 	a
.018e08	b0 05		bcs $018e0f			bcs 	_USInt 						; if msb set do as integer
.018e0a	20 39 9c	jsr $019c39			jsr 	FPToString 					; call fp to str otherwise
.018e0d	80 03		bra $018e12			bra 	_USDuplicate
.018e0f	20 25 96	jsr $019625	_USInt:	jsr 	IntToString
.018e12					_USDuplicate:
.018e12	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.018e15	1a		inc a				inc 	a 							; one more for length
.018e16	20 90 90	jsr $019090			jsr 	AllocateTempString 			; allocate space for it.
.018e19	5a		phy				phy 								; save Y
.018e1a	a0 00		ldy #$00			ldy 	#0 							; start copying
.018e1c	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.018e1f	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018e22	c8		iny				iny
.018e23	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.018e26	d0 f4		bne $018e1c			bne 	_USCopy
.018e28	7a		ply				ply 								; restore Y
.018e29	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.018e2c					Unary_Asc:
.018e2c	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; string parameter
.018e2f	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018e32	5a		phy				phy 								; get the string length
.018e33	a0 00		ldy #$00			ldy 	#0
.018e35	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e37	f0 07		beq $018e40			beq 	_UAIllegal 					; must be at least one character
.018e39	c8		iny				iny
.018e3a	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.018e3c	7a		ply				ply
.018e3d	4c 98 8c	jmp $018c98			jmp 	UnarySetAInteger
.018e40					_UAIllegal:
.018e40	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.018e43					Unary_Len:
.018e43	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; string parameter
.018e46	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018e49	5a		phy				phy 								; get the string length
.018e4a	a0 00		ldy #$00			ldy 	#0
.018e4c	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018e4e	7a		ply				ply
.018e4f	4c 98 8c	jmp $018c98			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.018e52					Unary_Mid:
.018e52	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 				; get string.
.018e55	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e58	48		pha				pha
.018e59	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e5c	48		pha				pha
.018e5d	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e60	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter (start)
.018e63	48		pha				pha 									; and push it.
.018e64	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e67	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.018e6a	48		pha				pha 									; and push it.
.018e6b	80 45		bra $018eb2			bra 	SLIProcess
.018e6d					Unary_Left:
.018e6d	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 				; get string.
.018e70	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e73	48		pha				pha
.018e74	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e77	48		pha				pha
.018e78	a9 01		lda #$01			lda 	#1 								; push start position (1)
.018e7a	48		pha				pha
.018e7b	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e7e	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.018e81	48		pha				pha 									; and push it.
.018e82	80 2e		bra $018eb2			bra 	SLIProcess
.018e84					Unary_Right:
.018e84	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 				; get string.
.018e87	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.018e8a	48		pha				pha
.018e8b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018e8e	48		pha				pha
.018e8f	da		phx				phx 									; get the string length and push on stack.
.018e90	a2 00		ldx #$00			ldx 	#0
.018e92	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.018e94	fa		plx				plx
.018e95	48		pha				pha
.018e96	20 56 90	jsr $019056			jsr 	CheckNextComma 					; skip comma
.018e99	20 ed 8e	jsr $018eed			jsr 	SLIByteParameter 				; get a byte parameter.
.018e9c	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.018e9f	68		pla				pla 									; restore string length.
.018ea0	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.018ea1	38		sec				sec
.018ea2	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.018ea5	f0 02		beq $018ea9			beq 	_URStart 						; if <= 0 start from 1.
.018ea7	10 02		bpl $018eab			bpl 	_UROkay
.018ea9					_URStart:
.018ea9	a9 01		lda #$01			lda 	#1
.018eab					_UROkay:
.018eab	48		pha				pha 									; push start
.018eac	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.018eaf	48		pha				pha
.018eb0	80 00		bra $018eb2			bra 	SLIProcess
.018eb2					SLIProcess:
.018eb2	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 				; closing right bracket.
.018eb5	68		pla				pla
.018eb6	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.018eb9	1a		inc a				inc 	a 								; allocate +1 for it.
.018eba	20 90 90	jsr $019090			jsr 	AllocateTempString
.018ebd	68		pla				pla 									; pop start number off stack.
.018ebe	f0 3f		beq $018eff			beq 	SLIError 						; exit if start = 0
.018ec0	8d 91 04	sta $0491			sta 	SliceStart
.018ec3	68		pla				pla  									; pop string address.
.018ec4	85 1f		sta $1f				sta 	zGenPtr+1
.018ec6	68		pla				pla
.018ec7	85 1e		sta $1e				sta 	zGenPtr
.018ec9	da		phx				phx
.018eca	5a		phy				phy
.018ecb	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.018ecd	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.018ed0					_SLICopy:
.018ed0	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.018ed3	f0 12		beq $018ee7			beq 	_SLIExit
.018ed5	ce 92 04	dec $0492			dec 	SliceCount
.018ed8	98		tya				tya 									; index of character
.018ed9	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.018edb	f0 02		beq $018edf			beq 	_SLIOk 							; if equal, okay.
.018edd	b0 08		bcs $018ee7			bcs 	_SLIExit 						; if past end, then exit.
.018edf	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.018ee1	c8		iny				iny
.018ee2	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018ee5	80 e9		bra $018ed0			bra 	_SLICopy 						; go round till copied characters
.018ee7					_SLIExit:
.018ee7	7a		ply				ply 									; restore YX
.018ee8	fa		plx				plx
.018ee9	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr 				; return new temporary string.
.018eec	ea		nop				nop
.018eed					SLIByteParameter:
.018eed	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 				; get integer
.018ef0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.018ef3	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ef6	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ef9	d0 04		bne $018eff			bne 	SLIError
.018efb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018efe	60		rts				rts
.018eff					SLIError:
.018eff	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.018f02					Unary_Hex:
.018f02	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; numeric parameter
.018f05	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018f08	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.018f0a	20 90 90	jsr $019090			jsr 	AllocateTempString			; allocate string space
.018f0d	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.018f10	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f13	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.018f16	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f19	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.018f1c	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f1f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018f22	20 37 8f	jsr $018f37			jsr 	_UHConvert
.018f25	5a		phy				phy 								; get length of new string
.018f26	a0 00		ldy #$00			ldy 	#0
.018f28	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f2a	7a		ply				ply
.018f2b	c9 00		cmp #$00			cmp 	#0
.018f2d	d0 05		bne $018f34			bne 	_UHExit 					; if it was non zero okay
.018f2f	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.018f31	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018f34					_UHExit:
.018f34	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr 			; return new temporary string.
.018f37					_UHConvert:
.018f37	48		pha				pha
.018f38	4a		lsr a				lsr 	a 							; do MSB
.018f39	4a		lsr a				lsr 	a
.018f3a	4a		lsr a				lsr 	a
.018f3b	4a		lsr a				lsr 	a
.018f3c	20 40 8f	jsr $018f40			jsr 	_UHNibble
.018f3f	68		pla				pla 								; do LSB
.018f40					_UHNibble:
.018f40	29 0f		and #$0f			and 	#15 						; get nibble
.018f42	d0 0c		bne $018f50			bne 	_UHNonZero
.018f44	5a		phy				phy									; get the length
.018f45	a0 00		ldy #$00			ldy 	#0
.018f47	b1 20		lda ($20),y			lda 	(zTempStr),y
.018f49	7a		ply				ply
.018f4a	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.018f4c	f0 0d		beq $018f5b			beq 	_UHExit2
.018f4e	a9 00		lda #$00			lda 	#0
.018f50					_UHNonZero:
.018f50	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.018f52	90 02		bcc $018f56			bcc 	_UHDigit
.018f54	69 06		adc #$06			adc 	#7-1
.018f56					_UHDigit:
.018f56	69 30		adc #$30			adc 	#48
.018f58	20 bb 90	jsr $0190bb			jsr 	WriteTempString				; output.
.018f5b					_UHExit2:
.018f5b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.018f5c					Unary_Dec:
.018f5c	20 d7 89	jsr $0189d7			jsr 	EvaluateStringX 			; string parameter
.018f5f	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018f62	5a		phy				phy
.018f63	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.018f65	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018f67	f0 4c		beq $018fb5			beq 	_UDFail 					; must fail if zero.
.018f69	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.018f6c	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.018f6e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018f71	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.018f74	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.018f77	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.018f7a	a9 01		lda #$01			lda 	#1
.018f7c	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.018f7f					_UDConvertLoop:
.018f7f	5a		phy				phy 								; shift mantissa left 4
.018f80	a0 04		ldy #$04			ldy 	#4
.018f82					_UDShift:
.018f82	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.018f85	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.018f88	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.018f8b	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.018f8e	88		dey				dey
.018f8f	d0 f1		bne $018f82			bne 	_UDShift
.018f91	7a		ply				ply
.018f92	c8		iny				iny 								; next character
.018f93	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.018f95	20 b8 8f	jsr $018fb8			jsr 	ConvertUpper 				; convert to U/C
.018f98	c9 30		cmp #$30			cmp 	#"0"
.018f9a	90 19		bcc $018fb5			bcc 	_UDFail
.018f9c	c9 3a		cmp #$3a			cmp 	#"9"+1
.018f9e	90 06		bcc $018fa6			bcc 	_UDOkay
.018fa0	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.018fa2	c9 10		cmp #$10			cmp 	#16
.018fa4	b0 0f		bcs $018fb5			bcs 	_UDFail
.018fa6					_UDOkay:
.018fa6	29 0f		and #$0f			and 	#15 						; nibble only
.018fa8	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.018fab	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.018fae	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.018fb1	d0 cc		bne $018f7f			bne 	_UDConvertLoop
.018fb3	7a		ply				ply
.018fb4	60		rts				rts
.018fb5					_UDFail:
.018fb5	4c 1e 84	jmp $01841e			jmp 	BadParamError
.018fb8					ConvertUpper:
.018fb8	c9 61		cmp #$61			cmp 	#"a"
.018fba	90 07		bcc $018fc3			bcc 	_CUExit
.018fbc	c9 7b		cmp #$7b			cmp 	#"z"+1
.018fbe	b0 03		bcs $018fc3			bcs 	_CUExit
.018fc0	38		sec				sec
.018fc1	e9 20		sbc #$20			sbc 	#32
.018fc3	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.018fc4					Unary_Chr:
.018fc4	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX			; numeric parameter
.018fc7	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018fca	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018fcd	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018fd0	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018fd3	d0 0e		bne $018fe3			bne 	_UCChar
.018fd5	a9 01		lda #$01			lda 	#1 							; one character string
.018fd7	20 90 90	jsr $019090			jsr 	AllocateTempString
.018fda	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.018fdd	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.018fe0	4c 15 90	jmp $019015			jmp 	UnaryReturnTempStr
.018fe3					_UCChar:
.018fe3	4c 1e 84	jmp $01841e			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.018fe6					Unary_Spc:
.018fe6	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 			; numeric parameter
.018fe9	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; right bracket.
.018fec	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.018fef	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.018ff2	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.018ff5	d0 1b		bne $019012			bne 	_USSize
.018ff7	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.018ffa	c9 fe		cmp #$fe			cmp 	#maxString+1
.018ffc	b0 14		bcs $019012			bcs 	_USSize
.018ffe	48		pha				pha 								; save length
.018fff	1a		inc a				inc 	a 							; allocate one more.
.019000	20 90 90	jsr $019090			jsr 	AllocateTempString
.019003	68		pla				pla 								; get length
.019004	f0 0f		beq $019015			beq 	UnaryReturnTempStr 			; return the current temp string
.019006					_USLoop:
.019006	48		pha				pha
.019007	a9 20		lda #$20			lda 	#" "
.019009	20 bb 90	jsr $0190bb			jsr 	WriteTempString
.01900c	68		pla				pla
.01900d	3a		dec a				dec 	a
.01900e	d0 f6		bne $019006			bne 	_USLoop
.019010	80 03		bra $019015			bra 	UnaryReturnTempStr
.019012					_USSize:
.019012	4c 1e 84	jmp $01841e			jmp 	BadParamError
.019015					UnaryReturnTempStr:
.019015	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.019017	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01901a	a5 21		lda $21				lda 	zTempStr+1
.01901c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01901f	a9 02		lda #$02			lda 	#2 							; set type to string
.019021	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019024	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019025					MemRead:
.019025	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.019028	a0 00		ldy #$00			ldy 	#0 							; start from here
.01902a	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01902c	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.01902f	c8		iny				iny 								; next to copy
.019030	e8		inx				inx
.019031	cc 8e 04	cpy $048e			cpy 	SignCount 					; do required # of bytes.
.019034	d0 f4		bne $01902a			bne 	_MLoop1
.019036	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019037					CheckNextToken:
.019037	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019039	d0 02		bne $01903d			bne 	CTFail 						; no, then fail
.01903b	c8		iny				iny
.01903c	60		rts				rts
.01903d					CTFail:
.01903d	20 2f 84	jsr $01842f			jsr ERR_Handler
>019040	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019048	74 6f 6b 65 6e 00
.01904e					CheckNextRParen:
.01904e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019050	c9 bc		cmp #$bc			cmp 	#token_rparen
.019052	d0 e9		bne $01903d			bne 	CTFail
.019054	c8		iny				iny
.019055	60		rts				rts
.019056					CheckNextComma:
.019056	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019058	c9 bd		cmp #$bd			cmp 	#token_comma
.01905a	d0 e1		bne $01903d			bne 	CTFail
.01905c	c8		iny				iny
.01905d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.01905e					StringConcrete:
.01905e	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019061	85 10		sta $10				sta 	zTemp1
.019063	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019066	85 11		sta $11				sta 	zTemp1+1
.019068	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.01906a	18		clc				clc 								; from the string pointer
.01906b	ad 00 04	lda $0400			lda 	StringPtr 					; and put in zTemp2 as well
.01906e	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019070	8d 00 04	sta $0400			sta 	StringPtr
.019073	85 12		sta $12				sta 	zTemp2
.019075	ad 01 04	lda $0401			lda 	StringPtr+1
.019078	e9 00		sbc #$00			sbc 	#0
.01907a	8d 01 04	sta $0401			sta 	StringPtr+1
.01907d	85 13		sta $13				sta 	zTemp2+1
.01907f	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019081	1a		inc a				inc 	a
.019082	aa		tax				tax
.019083	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019085	91 12		sta ($12),y			sta 	(zTemp2),y
.019087	c8		iny				iny
.019088	ca		dex				dex
.019089	d0 f8		bne $019083			bne 	_SCCopy
.01908b	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.01908d	a6 12		ldx $12				ldx 	zTemp2
.01908f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019090					AllocateTempString:
.019090	48		pha				pha 								; save required count.
.019091	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.019093	d0 0b		bne $0190a0			bne 	_ATSInitialised
.019095	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019098	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.01909a	ad 01 04	lda $0401			lda 	StringPtr+1
.01909d	3a		dec a				dec 	a
.01909e	85 21		sta $21				sta 	zTempStr+1
.0190a0					_ATSInitialised:
.0190a0	68		pla				pla 								; get required count back.
.0190a1	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0190a3	1a		inc a				inc 	a
.0190a4	18		clc				clc
.0190a5	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0190a7	85 20		sta $20				sta 	zTempStr
.0190a9	a9 ff		lda #$ff			lda 	#$FF
.0190ab	65 21		adc $21				adc 	zTempStr+1
.0190ad	85 21		sta $21				sta 	zTempStr+1
.0190af	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0190b1	5a		phy				phy
.0190b2	a8		tay				tay
.0190b3	91 20		sta ($20),y			sta 	(zTempStr),y
.0190b5	7a		ply				ply
.0190b6	1a		inc a				inc 	a 							; reset the write index.
.0190b7	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.0190ba	60		rts				rts
.0190bb					WriteTempString:
.0190bb	5a		phy				phy 								; save Y
.0190bc	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.0190bf	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0190c1	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.0190c4	98		tya				tya 								; unchanged Y is now length
.0190c5	a0 00		ldy #$00			ldy 	#0
.0190c7	91 20		sta ($20),y			sta 	(zTempStr),y
.0190c9	7a		ply				ply 								; restore Y and exit
.0190ca	60		rts				rts
.0190cb					CreateTempStringCopy:
.0190cb	da		phx				phx 								; save X
.0190cc	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190ce	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0190cf	20 90 90	jsr $019090			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0190d2	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190d4	c8		iny				iny
.0190d5	3a		dec a				dec 	a 							; make the actual length in charactes
.0190d6	3a		dec a				dec 	a
.0190d7	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0190d9	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0190db	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0190dd	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0190df	f0 0e		beq $0190ef			beq 	_CTSCExit
.0190e1					_CTSCLoop:
.0190e1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0190e3	c8		iny				iny
.0190e4	5a		phy				phy 								; save in Y
.0190e5	e8		inx				inx 								; bump index
.0190e6	da		phx				phx 								; index into Y
.0190e7	7a		ply				ply
.0190e8	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0190ea	7a		ply				ply 								; restore Y
.0190eb	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0190ed	d0 f2		bne $0190e1			bne 	_CTSCLoop
.0190ef					_CTSCExit:
.0190ef	fa		plx				plx 								; restore X
.0190f0	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0190f1					VariableFind:
.0190f1	20 5c 91	jsr $01915c			jsr 	VariableExtract 		; find out all about it ....
.0190f4	20 fe 93	jsr $0193fe			jsr 	VariableLocate 			; does it already exist ?
.0190f7	b0 03		bcs $0190fc			bcs 	_VFExists 				; if so, use that.
.0190f9	20 e8 91	jsr $0191e8			jsr 	VariableCreate 			; otherwise create it.
.0190fc					_VFExists:
.0190fc	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.0190fe	29 01		and #$01			and 	#1
.019100	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019102	d0 28		bne $01912c			bne 	_VFSingleElement
.019104					_VFNextIndex:
.019104	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019106	48		pha				pha
.019107	a5 23		lda $23				lda 	zVarDataPtr+1
.019109	48		pha				pha
.01910a	a5 24		lda $24				lda 	zVarType
.01910c	48		pha				pha
.01910d	20 ce 89	jsr $0189ce			jsr 	EvaluateIntegerX 		; calculate the index.
.019110	68		pla				pla 							; restore and index.
.019111	85 24		sta $24				sta 	zVarType
.019113	68		pla				pla
.019114	85 23		sta $23				sta 	zVarDataPtr+1
.019116	68		pla				pla
.019117	85 22		sta $22				sta 	zVarDataPtr
.019119	20 73 92	jsr $019273			jsr 	ArrayIndexFollow 		; do the index.
.01911c	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.01911e	29 01		and #$01			and 	#1
.019120	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019122	d0 05		bne $019129			bne 	_VFArrayDone 			; if so then exit.
.019124	20 56 90	jsr $019056			jsr 	CheckNextComma 			; comma should follow
.019127	80 db		bra $019104			bra 	_VFNextIndex
.019129					_VFArrayDone:
.019129	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 		; check closing right bracket.
.01912c					_VFSingleElement:
.01912c	60		rts				rts
.01912d					VariableClear:
.01912d	48		pha				pha 							; save registers
.01912e	da		phx				phx
.01912f	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019131	8a		txa				txa
.019132	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.019135	e8		inx				inx
.019136	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019138	d0 f8		bne $019132			bne 	_VCLoop
.01913a	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.01913c	8d 02 04	sta $0402			sta 	VarMemPtr
.01913f	a9 40		lda #$40			lda 	#VariableMemory >> 8
.019141	8d 03 04	sta $0403			sta 	VarMemPtr+1
.019144	fa		plx				plx 							; restore registers
.019145	68		pla				pla
.019146	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019147					VariableNameError:
.019147	20 2f 84	jsr $01842f			jsr ERR_Handler
>01914a	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019152	61 62 6c 65 20 4e 61 6d 65 00
.01915c					VariableExtract:
.01915c	da		phx				phx 							; save X.
.01915d	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.01915f	8d 85 04	sta $0485			sta 	Var_Type
.019162	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019165	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019167	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019169	f0 dc		beq $019147			beq 	VariableNameError
.01916b	c9 1b		cmp #$1b			cmp 	#26+1
.01916d	b0 d8		bcs $019147			bcs 	VariableNameError
.01916f	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019171					_VECopyBuffer:
.019171	e8		inx				inx
.019172	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019174	f0 d1		beq $019147			beq 	VariableNameError
.019176	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.019179	18		clc				clc  							; update the hash value for it.
.01917a	6d 86 04	adc $0486			adc 	Var_Hash
.01917d	8d 86 04	sta $0486			sta 	Var_Hash
.019180	c8		iny				iny
.019181	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019183	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019185	f0 0e		beq $019195			beq 	_VECopyEnd
.019187	30 0c		bmi $019195			bmi 	_VECopyEnd
.019189	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.01918b	90 e4		bcc $019171			bcc 	_VECopyBuffer
.01918d	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.01918f	90 04		bcc $019195			bcc 	_VECopyEnd
.019191	c9 3a		cmp #$3a			cmp 	#"9"+1
.019193	90 dc		bcc $019171			bcc 	_VECopyBuffer
.019195					_VECopyEnd:
.019195	c8		iny				iny
.019196	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.019198	90 04		bcc $01919e			bcc 	_VEDefaultRequired
.01919a	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.01919c	90 0b		bcc $0191a9			bcc 	_VEHaveType
.01919e					_VEDefaultRequired:
.01919e	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0191a0	f0 04		beq $0191a6			beq 	_VESetType 				; default set above.
.0191a2	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.0191a5	88		dey				dey
.0191a6					_VESetType:
.0191a6	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.0191a9					_VEHaveType:
.0191a9	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.0191ac	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0191af	09 80		ora #$80			ora 	#$80
.0191b1	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.0191b4	e8		inx				inx 							; offset 3 => length 4.
.0191b5	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.0191b8	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.0191bb	38		sec				sec
.0191bc	e9 b5		sbc #$b5			sbc 	#token_Dollar
.0191be	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0191bf	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0191c0	0a		asl a				asl 	a
.0191c1	0a		asl a				asl 	a
.0191c2	8d 88 04	sta $0488			sta 	Var_HashAddress
.0191c5	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.0191c8	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0191ca	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0191cb	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.0191ce	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0191d0	8d 88 04	sta $0488			sta 	Var_HashAddress
.0191d3	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0191d5	ad 85 04	lda $0485			lda 	Var_Type
.0191d8	c9 b7		cmp #$b7			cmp 	#token_Hash
.0191da	f0 07		beq $0191e3			beq 	_VEHaveSize
.0191dc	ca		dex				dex
.0191dd	c9 b9		cmp #$b9			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0191df	f0 02		beq $0191e3			beq 	_VEHaveSize
.0191e1	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0191e3					_VEHaveSize:
.0191e3	8e 89 04	stx $0489			stx 	Var_DataSize
.0191e6	fa		plx				plx
.0191e7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0191e8					VariableCreate:
.0191e8	da		phx				phx
.0191e9	5a		phy				phy
.0191ea	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.0191ed	85 10		sta $10				sta 	zTemp1
.0191ef	ad 03 04	lda $0403			lda 	VarMemPtr+1
.0191f2	85 11		sta $11				sta 	zTemp1+1
.0191f4	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.0191f7	18		clc				clc
.0191f8	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.0191fb	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.0191fd	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.019200	8d 02 04	sta $0402			sta 	VarMemPtr
.019203	90 03		bcc $019208			bcc 	_VCNoCarry
.019205	ee 03 04	inc $0403			inc 	VarMemPtr+1
.019208					_VCNoCarry:
.019208	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01920b	85 12		sta $12				sta 	zTemp2
.01920d	a9 04		lda #$04			lda 	#HashTableBase >> 8
.01920f	85 13		sta $13				sta 	zTemp2+1
.019211	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019213	b1 12		lda ($12),y			lda 	(zTemp2),y
.019215	91 10		sta ($10),y			sta 	(zTemp1),y
.019217	c8		iny				iny
.019218	b1 12		lda ($12),y			lda 	(zTemp2),y
.01921a	91 10		sta ($10),y			sta 	(zTemp1),y
.01921c	c8		iny				iny
.01921d	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.019220	91 10		sta ($10),y			sta 	(zTemp1),y
.019222	c8		iny				iny
.019223	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019225					_VCCopyName:
.019225	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.019228	91 10		sta ($10),y			sta 	(zTemp1),y
.01922a	e8		inx				inx
.01922b	c8		iny				iny
.01922c	ec 87 04	cpx $0487			cpx 	Var_Length
.01922f	d0 f4		bne $019225			bne 	_VCCopyName
.019231	5a		phy				phy 								; save the data offset.
.019232	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.019235	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019237					_VCClearData:
.019237	91 10		sta ($10),y			sta 	(zTemp1),y
.019239	c8		iny				iny
.01923a	ca		dex				dex
.01923b	d0 fa		bne $019237			bne 	_VCClearData
.01923d	68		pla				pla 								; offset to the data
.01923e	18		clc				clc
.01923f	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019241	85 22		sta $22				sta 	zVarDataPtr
.019243	a5 11		lda $11				lda 	zTemp1+1
.019245	69 00		adc #$00			adc 	#0
.019247	85 23		sta $23				sta 	zVarDataPtr+1
.019249	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.01924c	85 24		sta $24				sta 	zVarType
.01924e	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019250	a0 00		ldy #$00			ldy 	#0
.019252	91 12		sta ($12),y			sta 	(zTemp2),y
.019254	c8		iny				iny
.019255	a5 11		lda $11				lda 	zTemp1+1
.019257	91 12		sta ($12),y			sta 	(zTemp2),y
.019259	ad 85 04	lda $0485			lda 	Var_Type 					; array ? if so create the empty one.
.01925c	29 01		and #$01			and 	#1
.01925e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019260	d0 0e		bne $019270			bne 	_VCNotArray
.019262	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019264	20 13 93	jsr $019313			jsr 	ArrayCreate
.019267	5a		phy				phy 								; save YA at zVarDataPtr
.019268	a0 00		ldy #$00			ldy 	#0
.01926a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01926c	c8		iny				iny
.01926d	68		pla				pla
.01926e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019270					_VCNotArray:
.019270	7a		ply				ply
.019271	fa		plx				plx
.019272	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019273					ArrayIndexFollow:
.019273	5a		phy				phy
.019274	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019276	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019278	48		pha				pha
.019279	c8		iny				iny
.01927a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01927c	85 23		sta $23				sta 	zVarDataPtr+1
.01927e	68		pla				pla
.01927f	85 22		sta $22				sta 	zVarDataPtr
.019281	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019284	29 80		and #$80			and 	#$80 						; must be zero.
.019286	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019289	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.01928c	d0 5f		bne $0192ed			bne 	_AIFError
.01928e	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019290	18		clc				clc
.019291	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019293	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019296	c8		iny				iny
.019297	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019299	08		php				php 								; clear bit 7 retaining borrow.
.01929a	29 7f		and #$7f			and 	#$7F
.01929c	28		plp				plp
.01929d	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.0192a0	90 4b		bcc $0192ed			bcc 	_AIFError 					; eror if size-current < 0
.0192a2	bd 08 03	lda $0308,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.0192a5	0a		asl a				asl 	a 							; (e.g. index * 2)
.0192a6	85 10		sta $10				sta 	zTemp1
.0192a8	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192ab	2a		rol a				rol 	a
.0192ac	85 11		sta $11				sta 	zTemp1+1
.0192ae	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.0192b0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.0192b2	30 1f		bmi $0192d3			bmi 	_AIFCalculate
.0192b4	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.0192b6	a5 24		lda $24				lda 	zVarType 					; check that type
.0192b8	c9 b5		cmp #$b5			cmp 	#token_Dollar 				; if string, use x 2
.0192ba	f0 17		beq $0192d3			beq 	_AIFCalculate
.0192bc	06 10		asl $10				asl 	zTemp1			 			; double the index
.0192be	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.0192c0	c9 b9		cmp #$b9			cmp 	#token_Percent 				; if integer, use x 4
.0192c2	f0 0f		beq $0192d3			beq 	_AIFCalculate
.0192c4	18		clc				clc 								; add the original mantissa in again
.0192c5	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0192c8	65 10		adc $10				adc 	zTemp1
.0192ca	85 10		sta $10				sta 	zTemp1
.0192cc	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0192cf	65 11		adc $11				adc 	zTemp1+1
.0192d1	85 11		sta $11				sta 	zTemp1+1
.0192d3					_AIFCalculate:
.0192d3	18		clc				clc 								; add index x 2,4 or 5 to base
.0192d4	a5 22		lda $22				lda 	zVarDataPtr
.0192d6	65 10		adc $10				adc 	zTemp1
.0192d8	85 22		sta $22				sta 	zVarDataPtr
.0192da	a5 23		lda $23				lda 	zVarDataPtr+1
.0192dc	65 11		adc $11				adc 	zTemp1+1
.0192de	85 23		sta $23				sta 	zVarDataPtr+1
.0192e0	18		clc				clc 								; add 2 more for the length prefix.
.0192e1	a5 22		lda $22				lda 	zVarDataPtr
.0192e3	69 02		adc #$02			adc 	#2
.0192e5	85 22		sta $22				sta 	zVarDataPtr
.0192e7	90 02		bcc $0192eb			bcc 	_AIFNoBump
.0192e9	e6 23		inc $23				inc 	zVarDataPtr+1
.0192eb					_AIFNoBump:
.0192eb	7a		ply				ply
.0192ec	60		rts				rts
.0192ed					_AIFError:
.0192ed	20 2f 84	jsr $01842f			jsr ERR_Handler
>0192f0	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0192f8	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019300					ArrayResetDefault:
.019300	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019302	8d 97 04	sta $0497			sta 	ArrayDef+0
.019305	a9 00		lda #$00			lda 	#0
.019307	8d 98 04	sta $0498			sta 	ArrayDef+1
.01930a	a9 ff		lda #$ff			lda 	#$FF
.01930c	8d 99 04	sta $0499			sta 	ArrayDef+2 					; $FFFF implies no second element.
.01930f	8d 9a 04	sta $049a			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019312	60		rts				rts
.019313					ArrayCreate:
.019313	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019316	0a		asl a				asl 	a
.019317	85 10		sta $10				sta 	zTemp1
.019319	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.01931c	2a		rol a				rol 	a
.01931d	85 11		sta $11				sta 	zTemp1+1
.01931f	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019322	10 22		bpl $019346			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019324	ad 85 04	lda $0485			lda 	Var_Type 					; check the type
.019327	c9 b6		cmp #$b6			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019329	f0 1b		beq $019346			beq 	_ACSized
.01932b	06 10		asl $10				asl 	zTemp1 						; double again
.01932d	26 11		rol $11				rol 	zTemp1+1
.01932f	b0 6f		bcs $0193a0			bcs 	ArrayIndexError 			; too large.
.019331	c9 ba		cmp #$ba			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019333	f0 11		beq $019346			beq 	_ACSized
.019335	18		clc				clc 								; add original value x 5 for reals.
.019336	a5 10		lda $10				lda 	zTemp1
.019338	7d 97 04	adc $0497,x			adc 	ArrayDef+0,x
.01933b	85 10		sta $10				sta 	zTemp1
.01933d	a5 11		lda $11				lda 	zTemp1+1
.01933f	7d 98 04	adc $0498,x			adc 	ArrayDef+1,x
.019342	85 11		sta $11				sta 	zTemp1+1
.019344	b0 5a		bcs $0193a0			bcs 	ArrayIndexError
.019346					_ACSized:
.019346	18		clc				clc
.019347	a5 10		lda $10				lda 	zTemp1
.019349	69 02		adc #$02			adc 	#2
.01934b	85 10		sta $10				sta 	zTemp1
.01934d	90 04		bcc $019353			bcc 	_ACNoBump
.01934f	e6 10		inc $10				inc 	zTemp1
.019351	f0 4d		beq $0193a0			beq 	ArrayIndexError
.019353					_ACNoBump:
.019353	18		clc				clc
.019354	ad 02 04	lda $0402			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019357	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019359	85 14		sta $14				sta 	zTemp3
.01935b	65 10		adc $10				adc 	zTemp1
.01935d	8d 02 04	sta $0402			sta 	VarMemPtr
.019360	ad 03 04	lda $0403			lda 	VarMemPtr+1
.019363	85 13		sta $13				sta 	zTemp2+1
.019365	85 15		sta $15				sta 	zTemp3+1
.019367	65 11		adc $11				adc 	zTemp1+1
.019369	8d 03 04	sta $0403			sta 	VarMemPtr+1
.01936c	85 11		sta $11				sta 	zTemp1+1
.01936e	b0 30		bcs $0193a0			bcs 	ArrayIndexError
.019370	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019372					_ACClear:
.019372	98		tya				tya
.019373	91 12		sta ($12),y			sta 	(zTemp2),y
.019375	e6 12		inc $12				inc 	zTemp2
.019377	d0 02		bne $01937b			bne 	_ACCBump
.019379	e6 13		inc $13				inc 	zTemp2+1
.01937b					_ACCBump:
.01937b	a5 12		lda $12				lda 	zTemp2
.01937d	cd 02 04	cmp $0402			cmp 	VarMemPtr
.019380	d0 f0		bne $019372			bne 	_ACClear
.019382	a5 13		lda $13				lda 	zTemp2+1
.019384	cd 03 04	cmp $0403			cmp 	VarMemPtr+1
.019387	d0 e9		bne $019372			bne 	_ACClear
.019389	a0 00		ldy #$00			ldy 	#0
.01938b	bd 97 04	lda $0497,x			lda 	ArrayDef+0,x 				; copy the size into the start
.01938e	91 14		sta ($14),y			sta 	(zTemp3),y
.019390	c8		iny				iny
.019391	bd 98 04	lda $0498,x			lda 	ArrayDef+1,x
.019394	91 14		sta ($14),y			sta 	(zTemp3),y
.019396	bd 9a 04	lda $049a,x			lda 	ArrayDef+3,x 				; have we reached the end
.019399	10 18		bpl $0193b3			bpl 	ACCFillRecursive
.01939b	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.01939d	a5 14		lda $14				lda 	zTemp3
.01939f	60		rts				rts
.0193a0					ArrayIndexError:
.0193a0	20 2f 84	jsr $01842f			jsr ERR_Handler
>0193a3	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0193ab	79 20 69 6e 64 65 78 00
.0193b3					ACCFillRecursive:
.0193b3	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.0193b5	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.0193b7	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.0193b9	c8		iny				iny
.0193ba	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.0193bc	09 80		ora #$80			ora 	#$80 						; an array of pointers
.0193be	91 14		sta ($14),y			sta 	(zTemp3),y
.0193c0	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.0193c2	48		pha				pha
.0193c3	a5 15		lda $15				lda 	zTemp3+1
.0193c5	48		pha				pha
.0193c6					_ACCFillLoop:
.0193c6	18		clc				clc
.0193c7	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.0193c9	69 02		adc #$02			adc 	#2
.0193cb	85 14		sta $14				sta 	zTemp3
.0193cd	90 02		bcc $0193d1			bcc 	_ACCSkip2
.0193cf	e6 14		inc $14				inc 	zTemp3
.0193d1					_ACCSkip2:
.0193d1	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.0193d3	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.0193d5	c8		iny				iny
.0193d6	11 14		ora ($14),y			ora 	(zTemp3),y
.0193d8	d0 21		bne $0193fb			bne 	_ACCExit
.0193da	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.0193dc	48		pha				pha
.0193dd	a5 15		lda $15				lda 	zTemp3+1
.0193df	48		pha				pha
.0193e0	e8		inx				inx
.0193e1	e8		inx				inx
.0193e2	20 13 93	jsr $019313			jsr 	ArrayCreate 				; create array recursively.
.0193e5	ca		dex				dex
.0193e6	ca		dex				dex
.0193e7	85 12		sta $12				sta 	zTemp2 						; save A
.0193e9	68		pla				pla
.0193ea	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.0193ec	68		pla				pla
.0193ed	85 14		sta $14				sta 	zTemp3
.0193ef	98		tya				tya 								; write high bye from Y
.0193f0	a0 01		ldy #$01			ldy 	#1
.0193f2	91 14		sta ($14),y			sta 	(zTemp3),y
.0193f4	88		dey				dey 								; write low byte out.
.0193f5	a5 12		lda $12				lda 	zTemp2
.0193f7	91 14		sta ($14),y			sta 	(zTemp3),y
.0193f9	80 cb		bra $0193c6			bra 	_ACCFillLoop 				; and try again.
.0193fb					_ACCExit:
.0193fb	7a		ply				ply 								; restore the original address
.0193fc	68		pla				pla
.0193fd	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.0193fe					VariableLocate:
.0193fe	da		phx				phx
.0193ff	5a		phy				phy
.019400	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019403	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019405	a9 04		lda #$04			lda 	#HashTableBase >> 8
.019407	85 13		sta $13				sta 	zTemp2+1
.019409	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.01940b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01940d	aa		tax				tax
.01940e	c8		iny				iny
.01940f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019411	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019413	86 12		stx $12				stx 	zTemp2
.019415	05 12		ora $12				ora 	zTemp2 						; got zero
.019417	18		clc				clc
.019418	f0 25		beq $01943f			beq 	_VLExit 					; if so, then fail as end of chain.
.01941a	c8		iny				iny 								; point to hash (offset + 2)
.01941b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01941d	cd 86 04	cmp $0486			cmp 	Var_Hash
.019420	d0 e7		bne $019409			bne 	_VLNext 					; try next if different.
.019422					_VLCompare:
.019422	c8		iny				iny 								; next character
.019423	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019425	d9 02 04	cmp $0402,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019428	d0 df		bne $019409			bne 	_VLNext 					; fail if different, try next.
.01942a	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.01942b	90 f5		bcc $019422			bcc 	_VLCompare
.01942d	98		tya				tya
.01942e	38		sec				sec 								; add 1 as Y points to last character
.01942f	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019431	85 22		sta $22				sta 	zVarDataPtr
.019433	a5 13		lda $13				lda 	zTemp2+1
.019435	69 00		adc #$00			adc 	#0
.019437	85 23		sta $23				sta 	zVarDataPtr+1
.019439	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.01943c	85 24		sta $24				sta 	zVarType
.01943e	38		sec				sec 								; return CS
.01943f	7a		ply		_VLExit:ply
.019440	fa		plx				plx
.019441	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019442					VariableGet:
.019442	5a		phy				phy
.019443	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019445	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019447	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.01944a	c8		iny				iny
.01944b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01944d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019450	c8		iny				iny
.019451	ad 85 04	lda $0485			lda 	Var_Type 					; if it is a string, set up for that.
.019454	c9 b5		cmp #$b5			cmp 	#token_Dollar
.019456	f0 35		beq $01948d			beq 	_VGString
.019458	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01945a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01945d	c8		iny				iny
.01945e	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019460	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019463	c8		iny				iny
.019464	a9 01		lda #$01			lda 	#1 							; set type to 1.
.019466	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019469	ad 85 04	lda $0485			lda 	Var_Type
.01946c	c9 b9		cmp #$b9			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01946e	f0 31		beq $0194a1			beq 	_VGExit
.019470	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019472	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.019475	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.019477	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.01947a	f0 25		beq $0194a1			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01947c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01947f	48		pha				pha
.019480	29 80		and #$80			and 	#$80
.019482	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.019485	68		pla				pla
.019486	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.019488	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01948b	80 14		bra $0194a1			bra 	_VGExit
.01948d					_VGString:
.01948d	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01948f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019492	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019495	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019498	d0 07		bne $0194a1			bne 	_VGExit 					; if not, exit.
.01949a	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.01949c	a9 25		lda #$25			lda 	#zNullString
.01949e	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.0194a1					_VGExit:
.0194a1	7a		ply				ply
.0194a2	60		rts				rts
.0194a3					VariableSet:
.0194a3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.0194a6	29 02		and #$02			and 	#2 							; if so, it has to be
.0194a8	d0 53		bne $0194fd			bne 	_VSString
.0194aa	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.0194ac	c9 b5		cmp #$b5			cmp 	#token_Dollar
.0194ae	f0 4a		beq $0194fa			beq 	_VSBadType
.0194b0	c9 b9		cmp #$b9			cmp 	#token_Percent 				; type convert to float/int
.0194b2	f0 05		beq $0194b9			beq 	_VSMakeInt
.0194b4	20 af 9a	jsr $019aaf			jsr 	FPUToFloat
.0194b7	80 03		bra $0194bc			bra 	_VSCopy
.0194b9					_VSMakeInt:
.0194b9	20 0e 9b	jsr $019b0e			jsr 	FPUToInteger
.0194bc					_VSCopy:
.0194bc	5a		phy				phy
.0194bd	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.0194bf	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0194c2	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0194c4	c8		iny				iny
.0194c5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0194c8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0194ca	c8		iny				iny
.0194cb	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0194ce	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0194d0	c8		iny				iny
.0194d1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0194d4	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0194d6	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.0194d8	c9 b9		cmp #$b9			cmp 	#token_Percent
.0194da	f0 1c		beq $0194f8			beq 	_VSExit
.0194dc	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.0194df	0a		asl a				asl 	a
.0194e0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.0194e3	08		php				php
.0194e4	0a		asl a				asl 	a
.0194e5	28		plp				plp
.0194e6	6a		ror a				ror 	a
.0194e7	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0194e9	c8		iny				iny
.0194ea	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.0194ed	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0194ef	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.0194f2	50 04		bvc $0194f8			bvc 	_VSExit
.0194f4	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.0194f6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0194f8					_VSExit:
.0194f8	7a		ply				ply
.0194f9	60		rts				rts
.0194fa					_VSBadType:
.0194fa	4c 10 84	jmp $018410			jmp 	TypeError
.0194fd					_VSString:
.0194fd	a5 24		lda $24				lda 	zVarType 					; type must be $
.0194ff	c9 b5		cmp #$b5			cmp 	#token_Dollar
.019501	d0 f7		bne $0194fa			bne 	_VSBadType
.019503	da		phx				phx
.019504	5a		phy				phy
.019505	20 5e 90	jsr $01905e			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.019508	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01950a	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.01950c	88		dey				dey 								; save low byte
.01950d	8a		txa				txa
.01950e	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019510	7a		ply				ply 								; and exit.
.019511	fa		plx				plx
.019512	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.019513					MulInteger32:
.019513	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.019516	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.019519	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.01951c	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.01951f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019522	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.019525	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019528	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.01952b	a9 00		lda #$00			lda 	#0
.01952d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.019530	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019533	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019536	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019539					_BFMMultiply:
.019539	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01953c	29 01		and #$01			and 	#1
.01953e	f0 03		beq $019543			beq 	_BFMNoAdd
.019540	20 b3 8b	jsr $018bb3			jsr 	AddInteger32
.019543					_BFMNoAdd:
.019543	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019546	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.019549	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.01954c	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.01954f	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019552	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.019555	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.019558	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.01955b	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01955e	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.019561	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.019564	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.019567	d0 d0		bne $019539			bne 	_BFMMultiply
.019569	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01956a					DivInteger32:
.01956a	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.01956d	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.019570	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019573	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019576	d0 14		bne $01958c			bne 	_BFDOkay
.019578	20 2f 84	jsr $01842f			jsr ERR_Handler
>01957b	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019583	20 62 79 20 5a 65 72 6f 00
.01958c					_BFDOkay:
.01958c	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01958e	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019590	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019592	85 1c		sta $1c				sta 	zLTemp1+2
.019594	85 1d		sta $1d				sta 	zLTemp1+3
.019596	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.019599	20 fa 95	jsr $0195fa			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01959c	da		phx				phx
.01959d	e8		inx				inx
.01959e	e8		inx				inx
.01959f	e8		inx				inx
.0195a0	e8		inx				inx
.0195a1	e8		inx				inx
.0195a2	e8		inx				inx
.0195a3	20 fa 95	jsr $0195fa			jsr 	CheckIntegerNegate
.0195a6	fa		plx				plx
.0195a7	5a		phy				phy 								; Y is the counter
.0195a8	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.0195aa					_BFDLoop:
.0195aa	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.0195ad	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.0195b0	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.0195b3	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.0195b6	26 1a		rol $1a				rol 	zLTemp1
.0195b8	26 1b		rol $1b				rol 	zLTemp1+1
.0195ba	26 1c		rol $1c				rol 	zLTemp1+2
.0195bc	26 1d		rol $1d				rol 	zLTemp1+3
.0195be	38		sec				sec
.0195bf	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.0195c1	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.0195c4	48		pha				pha
.0195c5	a5 1b		lda $1b				lda 	zLTemp1+1
.0195c7	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0195ca	48		pha				pha
.0195cb	a5 1c		lda $1c				lda 	zLTemp1+2
.0195cd	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0195d0	48		pha				pha
.0195d1	a5 1d		lda $1d				lda 	zLTemp1+3
.0195d3	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0195d6	90 15		bcc $0195ed			bcc 	_BFDNoAdd
.0195d8	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.0195da	68		pla				pla
.0195db	85 1c		sta $1c				sta 	zLTemp1+2
.0195dd	68		pla				pla
.0195de	85 1b		sta $1b				sta 	zLTemp1+1
.0195e0	68		pla				pla
.0195e1	85 1a		sta $1a				sta 	zLTemp1+0
.0195e3	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.0195e6	09 01		ora #$01			ora 	#1
.0195e8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0195eb	80 03		bra $0195f0			bra 	_BFDNext
.0195ed					_BFDNoAdd:
.0195ed	68		pla				pla 								; Throw away the intermediate calculations
.0195ee	68		pla				pla
.0195ef	68		pla				pla
.0195f0					_BFDNext:
.0195f0	88		dey				dey
.0195f1	d0 b7		bne $0195aa			bne 	_BFDLoop
.0195f3	7a		ply				ply 								; restore Y and exit
.0195f4	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.0195f7	b0 07		bcs $019600			bcs		IntegerNegateAlways 			; negate the result
.0195f9	60		rts				rts
.0195fa					CheckIntegerNegate:
.0195fa	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0195fd	30 01		bmi $019600			bmi 	IntegerNegateAlways
.0195ff	60		rts				rts
.019600					IntegerNegateAlways:
.019600	ee 8e 04	inc $048e			inc 	SignCount
.019603	38		sec				sec
.019604	a9 00		lda #$00			lda 	#0
.019606	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019609	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01960c	a9 00		lda #$00			lda 	#0
.01960e	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019611	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019614	a9 00		lda #$00			lda 	#0
.019616	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019619	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01961c	a9 00		lda #$00			lda 	#0
.01961e	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019621	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019624	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019625					INTToString:
.019625	48		pha				pha
.019626	5a		phy				phy
.019627	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.01962a	10 08		bpl $019634			bpl 		_ITSNotMinus
.01962c	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01962e	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter
.019631	20 00 96	jsr $019600			jsr 		IntegerNegateAlways 	; negate the number.
.019634					_ITSNotMinus:
.019634	a9 00		lda #$00			lda 		#0
.019636	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.019639	8a		txa				txa 								; use Y for the mantissa index.
.01963a	a8		tay				tay
.01963b	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01963d					_ITSNextSubtractor:
.01963d	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01963f	8d 8b 04	sta $048b			sta 		NumConvCount
.019642					_ITSSubtract:
.019642	38		sec				sec
.019643	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019646	ff a5 96 01	sbc $0196a5,x			sbc 		_ITSSubtractors+0,x
.01964a	48		pha				pha
.01964b	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.01964e	ff a6 96 01	sbc $0196a6,x			sbc 		_ITSSubtractors+1,x
.019652	48		pha				pha
.019653	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.019656	ff a7 96 01	sbc $0196a7,x			sbc 		_ITSSubtractors+2,x
.01965a	48		pha				pha
.01965b	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.01965e	ff a8 96 01	sbc $0196a8,x			sbc 		_ITSSubtractors+3,x
.019662	90 14		bcc $019678			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019664	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019667	68		pla				pla
.019668	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.01966b	68		pla				pla
.01966c	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.01966f	68		pla				pla
.019670	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.019673	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.019676	80 ca		bra $019642			bra 		_ITSSubtract 			; go round again.
.019678					_ITSCantSubtract:
.019678	68		pla				pla 								; throw away interim answers
.019679	68		pla				pla
.01967a	68		pla				pla
.01967b	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.01967e	c9 30		cmp #$30			cmp 		#"0"
.019680	d0 05		bne $019687			bne 		_ITSOutputDigit
.019682	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019685	10 09		bpl $019690			bpl	 		_ITSGoNextSubtractor
.019687					_ITSOutputDigit:
.019687	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.01968a	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.01968d	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter 		; output it.
.019690					_ITSGoNextSubtractor:
.019690	e8		inx				inx 								; next dword
.019691	e8		inx				inx
.019692	e8		inx				inx
.019693	e8		inx				inx
.019694	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019696	d0 a5		bne $01963d			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019698	98		tya				tya 								; X is back as the mantissa index
.019699	aa		tax				tax
.01969a	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01969d	09 30		ora #$30			ora 		#"0"
.01969f	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter
.0196a2	7a		ply				ply 								; and exit
.0196a3	68		pla				pla
.0196a4	60		rts				rts
.0196a5					_ITSSubtractors:
>0196a5	00 ca 9a 3b					.dword 		1000000000
>0196a9	00 e1 f5 05					.dword 		100000000
>0196ad	80 96 98 00					.dword 		10000000
>0196b1	40 42 0f 00					.dword 		1000000
>0196b5	a0 86 01 00					.dword 		100000
>0196b9	10 27 00 00					.dword 		10000
>0196bd	e8 03 00 00					.dword 		1000
>0196c1	64 00 00 00					.dword 		100
>0196c5	0a 00 00 00					.dword 		10
.0196c9					_ITSSubtractorsEnd:
.0196c9					ITSOutputCharacter:
.0196c9	48		pha				pha
.0196ca	da		phx				phx
.0196cb	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.0196ce	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.0196d1	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.0196d3	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.0196d6	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.0196d9	fa		plx				plx
.0196da	68		pla				pla
.0196db	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.0196dc					IntFromString:
.0196dc	a0 00		ldy #$00			ldy 	#0
.0196de	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.0196e1					IntFromStringY:
.0196e1	48		pha				pha
.0196e2	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.0196e4	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0196e7	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0196ea	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0196ed	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.0196f0	a9 01		lda #$01			lda 	#1
.0196f2	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0196f5					_IFSLoop:
.0196f5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.0196f7	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.0196f9	90 60		bcc $01975b			bcc 	_IFSExit
.0196fb	c9 3a		cmp #$3a			cmp 	#"9"+1
.0196fd	b0 5c		bcs $01975b			bcs 	_IFSExit
.0196ff	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019702	c9 0c		cmp #$0c			cmp 	#12
.019704	b0 5f		bcs $019765			bcs 	_IFSOverflow
.019706	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019709	48		pha				pha
.01970a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.01970d	48		pha				pha
.01970e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019711	48		pha				pha
.019712	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019715	48		pha				pha
.019716	20 7a 97	jsr $01977a			jsr 	IFSX1ShiftLeft 				; double
.019719	20 7a 97	jsr $01977a			jsr 	IFSX1ShiftLeft 				; x 4
.01971c	18		clc				clc 								; add saved value x 5
.01971d	68		pla				pla
.01971e	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019721	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019724	68		pla				pla
.019725	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.019728	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01972b	68		pla				pla
.01972c	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.01972f	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019732	68		pla				pla
.019733	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.019736	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019739	20 7a 97	jsr $01977a			jsr 	IFSX1ShiftLeft 				; x 10
.01973c	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.01973f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019741	29 0f		and #$0f			and 	#15
.019743	c8		iny				iny
.019744	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.019747	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.01974a	90 a9		bcc $0196f5			bcc 	_IFSLoop
.01974c	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01974f	d0 a4		bne $0196f5			bne 	_IFSLoop
.019751	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.019754	d0 9f		bne $0196f5			bne 	_IFSLoop
.019756	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.019759	80 9a		bra $0196f5			bra 	_IFSLoop
.01975b					_IFSExit:
.01975b	98		tya				tya 								; get offset
.01975c					_IFSOkay:
.01975c	38		sec				sec
.01975d	ad 8c 04	lda $048c			lda 	ExpTemp
.019760	f0 01		beq $019763			beq 	_IFSSkipFail
.019762	18		clc				clc
.019763					_IFSSkipFail:
.019763	68		pla				pla 								; and exit.
.019764	60		rts				rts
.019765					_IFSOverflow:
.019765	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019768	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019770	20 6f 76 65 72 66 6c 6f 77 00
.01977a					IFSX1ShiftLeft:
.01977a	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.01977d	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.019780	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.019783	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.019786	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019787					FPSubtract:
.019787	48		pha				pha
.019788	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01978b	49 80		eor #$80			eor 	#$80
.01978d	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.019790	68		pla				pla 								; --- and fall through ---
.019791					FPAdd:
.019791	48		pha				pha
.019792	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019795	d0 05		bne $01979c			bne 	_FPA_NegativeLHS
.019797	20 b9 97	jsr $0197b9			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01979a	68		pla				pla
.01979b	60		rts				rts
.01979c					_FPA_NegativeLHS:
.01979c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01979f	49 80		eor #$80			eor 	#$80
.0197a1	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0197a4	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.0197a7	49 80		eor #$80			eor 	#$80
.0197a9	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.0197ac	20 b9 97	jsr $0197b9			jsr 	FPAdd_Worker 				; do the add calculation.
.0197af	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.0197b2	49 80		eor #$80			eor 	#$80
.0197b4	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0197b7	68		pla				pla
.0197b8	60		rts				rts
.0197b9					FPAdd_Worker:
.0197b9	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.0197bc	70 08		bvs $0197c6			bvs 	_FPAWExit 					; no change.
.0197be	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.0197c1	50 07		bvc $0197ca			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.0197c3	20 5e 9a	jsr $019a5e			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.0197c6					_FPAWExit:
.0197c6	20 e6 9a	jsr $019ae6			jsr 	FPUNormalise 				; normalise the result.
.0197c9	60		rts				rts
.0197ca					_FPAWMakeSame:
.0197ca	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.0197cd	38		sec				sec
.0197ce	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.0197d1	f0 1b		beq $0197ee			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.0197d3	da		phx				phx 								; save X
.0197d4	90 06		bcc $0197dc			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.0197d6	e8		inx				inx
.0197d7	e8		inx				inx
.0197d8	e8		inx				inx
.0197d9	e8		inx				inx
.0197da	e8		inx				inx
.0197db	e8		inx				inx
.0197dc					_FPAWShiftA:
.0197dc	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.0197df	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.0197e2	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.0197e5	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.0197e8	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.0197eb	fa		plx				plx 								; restore original X
.0197ec	80 dc		bra $0197ca			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.0197ee					_FPAW_DoArithmetic:
.0197ee	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.0197f1	30 39		bmi $01982c			bmi 	_FPAW_BNegative
.0197f3	18		clc				clc
.0197f4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.0197f7	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.0197fa	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0197fd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019800	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019803	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019806	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019809	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01980c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01980f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019812	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019815	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019818	90 ac		bcc $0197c6			bcc 	_FPAWExit 					; no carry.
.01981a	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01981d	38		sec				sec
.01981e	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019821	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019824	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019827	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01982a	80 9a		bra $0197c6			bra 	_FPAWExit
.01982c					_FPAW_BNegative:
.01982c	38		sec				sec
.01982d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.019830	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.019833	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019836	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019839	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.01983c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.01983f	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019842	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.019845	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019848	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.01984b	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.01984e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019851	b0 0b		bcs $01985e			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019853	20 8b 9a	jsr $019a8b			jsr 	FPUNegateInteger			; negate the mantissa
.019856	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.019859	49 80		eor #$80			eor 	#$80
.01985b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01985e					_FPAWGoExit:
.01985e	4c c6 97	jmp $0197c6			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019861					FPD_IsDivZero:
.019861	20 2f 84	jsr $01842f			jsr ERR_Handler
>019864	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01986c	20 62 79 20 7a 65 72 6f 00
.019875					FPDivide:
.019875	48		pha				pha
.019876	5a		phy				phy
.019877	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.01987a	70 e5		bvs $019861			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01987c	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01987f	f0 03		beq $019884			beq 	_FPDCalculateExp
.019881					_FPD_Exit:
.019881	7a		ply				ply
.019882	68		pla				pla
.019883	60		rts				rts
.019884					_FPDCalculateExp:
.019884	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019887	49 ff		eor #$ff			eor 	#$FF
.019889	1a		inc a				inc 	a
.01988a	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.01988d	20 81 99	jsr $019981			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019890	18		clc				clc 	 							; add 1 to the resulting exponent
.019891	69 01		adc #$01			adc 	#1
.019893	b0 65		bcs $0198fa			bcs 	_FPD_Overflow 				; which can overflow.
.019895	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019898	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01989a	85 1a		sta $1a				sta 	zLTemp1+0
.01989c	85 1b		sta $1b				sta 	zLTemp1+1
.01989e	85 1c		sta $1c				sta 	zLTemp1+2
.0198a0	85 1d		sta $1d				sta 	zLTemp1+3
.0198a2	a0 20		ldy #$20			ldy 	#32 						; times round.
.0198a4					_FPD_Loop:
.0198a4	38		sec				sec 								; calculate X1-X2 stacking result because we might
.0198a5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.0198a8	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.0198ab	48		pha				pha
.0198ac	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.0198af	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.0198b2	48		pha				pha
.0198b3	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.0198b6	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.0198b9	48		pha				pha
.0198ba	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.0198bd	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.0198c0	90 17		bcc $0198d9			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.0198c2	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.0198c5	68		pla				pla
.0198c6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.0198c9	68		pla				pla
.0198ca	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.0198cd	68		pla				pla
.0198ce	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.0198d1	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.0198d3	09 80		ora #$80			ora 	#$80
.0198d5	85 1d		sta $1d				sta 	zLTemp1+3
.0198d7	80 03		bra $0198dc			bra 	_FPD_Rotates
.0198d9					_FPD_NoSubtract:
.0198d9	68		pla				pla 								; throw away unwanted results
.0198da	68		pla				pla
.0198db	68		pla				pla
.0198dc					_FPD_Rotates:
.0198dc	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.0198df	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.0198e2	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.0198e5	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.0198e8	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.0198ea	26 1b		rol $1b				rol 	zLTemp1+1
.0198ec	26 1c		rol $1c				rol 	zLTemp1+2
.0198ee	26 1d		rol $1d				rol 	zLTemp1+3
.0198f0	90 02		bcc $0198f4			bcc 	_FPD_NoCarry
.0198f2	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.0198f4					_FPD_NoCarry:
.0198f4	88		dey				dey 								; do 32 times
.0198f5	d0 ad		bne $0198a4			bne 	_FPD_Loop
.0198f7	4c 5e 99	jmp $01995e			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.0198fa					_FPD_Overflow:
.0198fa	4c 5b 9b	jmp $019b5b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.0198fd					FPMultiply:
.0198fd	48		pha				pha
.0198fe	5a		phy				phy
.0198ff	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019902	70 08		bvs $01990c			bvs 	_FPM_Exit
.019904	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019907	50 06		bvc $01990f			bvc 	_FPM_CalcExponent
.019909	20 5e 9a	jsr $019a5e			jsr 	FPUCopyX2ToX1
.01990c					_FPM_Exit:
.01990c	7a		ply				ply
.01990d	68		pla				pla
.01990e	60		rts				rts
.01990f					_FPM_CalcExponent:
.01990f	18		clc				clc
.019910	20 81 99	jsr $019981			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019913	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.019916	a9 00		lda #$00			lda 	#0
.019918	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01991a	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01991c	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01991e	85 1d		sta $1d				sta 	zLTemp1+3
.019920	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019922					_FPM_Loop:
.019922	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.019925	29 01		and #$01			and 	#1
.019927	18		clc				clc 								; clear carry for the long rotate.
.019928	f0 1d		beq $019947			beq 	_FPM_NoAddition
.01992a	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01992b	a5 1a		lda $1a				lda 	zLTemp1+0
.01992d	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.019930	85 1a		sta $1a				sta 	zLTemp1+0
.019932	a5 1b		lda $1b				lda 	zLTemp1+1
.019934	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.019937	85 1b		sta $1b				sta 	zLTemp1+1
.019939	a5 1c		lda $1c				lda 	zLTemp1+2
.01993b	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.01993e	85 1c		sta $1c				sta 	zLTemp1+2
.019940	a5 1d		lda $1d				lda 	zLTemp1+3
.019942	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.019945	85 1d		sta $1d				sta 	zLTemp1+3
.019947					_FPM_NoAddition:
.019947	66 1d		ror $1d				ror 	3+zLTemp1
.019949	66 1c		ror $1c				ror 	2+zLTemp1
.01994b	66 1b		ror $1b				ror 	1+zLTemp1
.01994d	66 1a		ror $1a				ror 	0+zLTemp1
.01994f	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019952	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019955	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019958	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.01995b	88		dey				dey
.01995c	d0 c4		bne $019922			bne 	_FPM_Loop 					; do this 32 times.
.01995e					FPM_CopySignNormalize:
.01995e	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019960	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019963	a5 1b		lda $1b				lda 	zLTemp1+1
.019965	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019968	a5 1c		lda $1c				lda 	zLTemp1+2
.01996a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.01996d	a5 1d		lda $1d				lda 	zLTemp1+3
.01996f	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019972	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.019975	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.019978	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.01997b	20 e6 9a	jsr $019ae6			jsr 	FPUNormalise 				; normalise and exit.
.01997e	7a		ply				ply
.01997f	68		pla				pla
.019980	60		rts				rts
.019981					FPCalculateExponent:
.019981	18		clc				clc
.019982	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019985	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.019988	b0 08		bcs $019992			bcs 	_FPCECarry 					; carry out ?
.01998a	10 03		bpl $01998f			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01998c	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01998e	60		rts				rts
.01998f					_FPCEExpZero:
.01998f	a9 00		lda #$00			lda 	#0
.019991	60		rts				rts
.019992					_FPCECarry:
.019992	30 03		bmi $019997			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019994	09 80		ora #$80			ora 	#$80 						; put in right range
.019996	60		rts				rts
.019997					_FPCEOverflow:
.019997	4c 5b 9b	jmp $019b5b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01999a					FPFractionalPart:
.01999a	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01999d	38		sec				sec 								; this flag tells us to keep the fractional part
.01999e	30 0f		bmi $0199af			bmi 	FPGetPart
.0199a0	60		rts				rts
.0199a1					FPIntegerPart:
.0199a1	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.0199a4	18		clc				clc 								; this flag says keep the integer part.
.0199a5	30 08		bmi $0199af			bmi 	FPGetPart 					; -ve exponents are 0..127
.0199a7	48		pha				pha
.0199a8	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.0199aa	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.0199ad	68		pla				pla
.0199ae	60		rts				rts
.0199af					FPGetPart:
.0199af	48		pha				pha
.0199b0	5a		phy				phy 								; save Y
.0199b1	08		php				php 								; save action
.0199b2	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.0199b5	70 62		bvs $019a19			bvs 	_FPGP_Exit 					; then do nothing.
.0199b7	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.0199b9	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.0199bb	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.0199bd	85 1c		sta $1c				sta 	zLTemp1+2
.0199bf	85 1d		sta $1d				sta 	zLTemp1+3
.0199c1	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.0199c4	38		sec				sec
.0199c5	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.0199c7	f0 12		beq $0199db			beq 	_FPGP_NoShift 				; ... if any
.0199c9	c9 20		cmp #$20			cmp 	#32
.0199cb	90 02		bcc $0199cf			bcc 	_FPGP_NotMax
.0199cd	a9 20		lda #$20			lda 	#32 						; max of 32.
.0199cf					_FPGP_NotMax:
.0199cf	a8		tay				tay 								; Y is the mask shift count.
.0199d0					_FPGP_ShiftMask:
.0199d0	46 1d		lsr $1d				lsr 	3+zLTemp1
.0199d2	66 1c		ror $1c				ror 	2+zLTemp1
.0199d4	66 1b		ror $1b				ror 	1+zLTemp1
.0199d6	66 1a		ror $1a				ror 	0+zLTemp1
.0199d8	88		dey				dey
.0199d9	d0 f5		bne $0199d0			bne 	_FPGP_ShiftMask
.0199db					_FPGP_NoShift:
.0199db	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.0199dd	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.0199e0					_FPGP_MaskLoop:
.0199e0	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.0199e3	28		plp				plp 								; if CC we keep the top part, so we
.0199e4	08		php				php		 							; flip the mask.
.0199e5	b0 02		bcs $0199e9			bcs		_FPGP_NoFlip
.0199e7	49 ff		eor #$ff			eor 	#$FF
.0199e9					_FPGP_NoFlip:
.0199e9	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.0199ec	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.0199ef	e8		inx				inx
.0199f0	c8		iny				iny
.0199f1	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.0199f3	d0 eb		bne $0199e0			bne 	_FPGP_MaskLoop
.0199f5	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.0199f8	28		plp				plp
.0199f9	08		php				php 								; get action flag on the stack
.0199fa	90 05		bcc $019a01			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.0199fc	a9 00		lda #$00			lda 	#0
.0199fe	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a01					_FPGP_NotFractional:
.019a01	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019a04	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019a07	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019a0a	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019a0d	f0 05		beq $019a14			beq 	_FPGP_Zero 					; if zero, return zero
.019a0f	20 e6 9a	jsr $019ae6			jsr 	FPUNormalise
.019a12	80 05		bra $019a19			bra 	_FPGP_Exit 					; and exit
.019a14					_FPGP_Zero:
.019a14	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019a16	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a19					_FPGP_Exit:
.019a19	68		pla				pla 								; throw saved action flag.
.019a1a	7a		ply				ply
.019a1b	68		pla				pla
.019a1c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019a1d					FPCompare:
.019a1d	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019a20	48		pha				pha
.019a21	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.019a24	48		pha				pha
.019a25	20 87 97	jsr $019787			jsr 	FPSubtract 					; calculate X1-X2
.019a28	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019a2b	70 2c		bvs $019a59			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019a2d	68		pla				pla
.019a2e	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.019a31	68		pla				pla
.019a32	38		sec				sec
.019a33	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.019a36	70 15		bvs $019a4d			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019a38	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019a39	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019a3b	b0 10		bcs $019a4d			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019a3d	38		sec				sec
.019a3e	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.019a41	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019a43	b0 02		bcs $019a47			bcs 	_FPCNotRange 				; keep in range.
.019a45	a9 01		lda #$01			lda 	#1
.019a47					_FPCNotRange:
.019a47	38		sec				sec
.019a48	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019a4b	b0 0e		bcs $019a5b			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019a4d					_FPCNotEqual:
.019a4d	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019a50	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019a52	f0 02		beq $019a56			beq 	_FPCNE2
.019a54	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019a56	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019a57	80 04		bra $019a5d			bra 	_FPCExit
.019a59					_FPCPullZero:
.019a59	68		pla				pla 								; throw saved exponents
.019a5a	68		pla				pla
.019a5b					_FPCZero:
.019a5b	a9 00		lda #$00			lda 	#0 							; and return zero
.019a5d					_FPCExit:
.019a5d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019a5e					FPUCopyX2ToX1:
.019a5e	48		pha				pha
.019a5f	da		phx				phx
.019a60	5a		phy				phy
.019a61	a0 08		ldy #$08			ldy 	#8
.019a63	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.019a66	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019a69	e8		inx				inx
.019a6a	88		dey				dey
.019a6b	10 f6		bpl $019a63			bpl 	_FPUC21
.019a6d	7a		ply				ply
.019a6e	fa		plx				plx
.019a6f	68		pla				pla
.019a70	60		rts				rts
.019a71					FPUSetInteger:
.019a71	48		pha				pha
.019a72	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019a75	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019a77	10 02		bpl $019a7b			bpl 	_FPUSIExtend
.019a79	a9 ff		lda #$ff			lda 	#$FF
.019a7b					_FPUSIExtend:
.019a7b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019a7e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019a81	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019a84	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019a86	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019a89	68		pla				pla
.019a8a	60		rts				rts
.019a8b					FPUNegateInteger:
.019a8b	48		pha				pha
.019a8c	38		sec				sec
.019a8d	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019a8f	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.019a92	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019a95	a9 00		lda #$00			lda 	#0
.019a97	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.019a9a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019a9d	a9 00		lda #$00			lda 	#0
.019a9f	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.019aa2	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019aa5	a9 00		lda #$00			lda 	#0
.019aa7	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.019aaa	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019aad	68		pla				pla
.019aae	60		rts				rts
.019aaf					FPUToFloat:
.019aaf	48		pha				pha
.019ab0	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.019ab3	29 0f		and #$0f			and 	#$0F
.019ab5	f0 2d		beq $019ae4			beq 	_FPUFExit
.019ab7	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019ab9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019abc	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019abe	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.019ac1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019ac4	10 08		bpl $019ace			bpl		_FPUFPositive
.019ac6	20 8b 9a	jsr $019a8b			jsr 	FPUNegateInteger 			; negate the mantissa
.019ac9	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019acb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019ace					_FPUFPositive:
.019ace	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019ad1	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.019ad4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.019ad7	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.019ada	d0 05		bne $019ae1			bne 	_FPUFNonZero
.019adc	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019ade	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019ae1					_FPUFNonZero:
.019ae1	20 e6 9a	jsr $019ae6			jsr 	FPUNormalise 				; normalise the floating point.
.019ae4					_FPUFExit:
.019ae4	68		pla				pla
.019ae5	60		rts				rts
.019ae6					FPUNormalise:
.019ae6	48		pha				pha
.019ae7	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019aea	70 20		bvs $019b0c			bvs 	_FPUNExit
.019aec	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019aef	f0 16		beq $019b07			beq 	_FPUNSetZero
.019af1					_FPUNLoop:
.019af1	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019af4	30 16		bmi $019b0c			bmi 	_FPUNExit 					; if so, we are normalised.
.019af6	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.019af9	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.019afc	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.019aff	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.019b02	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.019b05	d0 ea		bne $019af1			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019b07					_FPUNSetZero:
.019b07	a9 40		lda #$40			lda 	#$40
.019b09	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.019b0c					_FPUNExit:
.019b0c	68		pla				pla
.019b0d	60		rts				rts
.019b0e					FPUToInteger:
.019b0e	48		pha				pha
.019b0f	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.019b12	29 01		and #$01			and 	#1
.019b14	d0 3e		bne $019b54			bne 	_FPUTOI_Exit
.019b16	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.019b19	70 2b		bvs $019b46			bvs 	_FPUTOI_Zero
.019b1b	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019b1e	10 26		bpl $019b46			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019b20	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019b22	b0 37		bcs $019b5b			bcs 	FP_Overflow
.019b24					_FPUToIToInteger:
.019b24	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019b27	c9 a0		cmp #$a0			cmp 	#128+32
.019b29	f0 11		beq $019b3c			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019b2b	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.019b2e	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.019b31	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019b34	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019b37	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019b3a	80 e8		bra $019b24			bra 	_FPUToIToInteger 			; keep going.
.019b3c					_FPUToICheckSign:
.019b3c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.019b3f	10 13		bpl $019b54			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019b41	20 8b 9a	jsr $019a8b			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019b44	80 0e		bra $019b54			bra 	_FPUTOI_Exit
.019b46					_FPUTOI_Zero:
.019b46	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019b48	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019b4b	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019b4e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019b51	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019b54					_FPUToI_Exit:
.019b54	a9 01		lda #$01			lda 	#1 							; set type to integer
.019b56	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019b59	68		pla				pla
.019b5a	60		rts				rts
.019b5b					FP_Overflow:
.019b5b	20 2f 84	jsr $01842f			jsr ERR_Handler
>019b5e	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019b66	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019b76					FPUTimes10:
.019b76	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019b79	85 1a		sta $1a				sta 	ZLTemp1+0
.019b7b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019b7e	85 1b		sta $1b				sta 	ZLTemp1+1
.019b80	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019b83	85 1c		sta $1c				sta 	ZLTemp1+2
.019b85	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019b88	85 1d		sta $1d				sta 	ZLTemp1+3
.019b8a	20 ce 9b	jsr $019bce			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019b8d	20 ce 9b	jsr $019bce			jsr 	_FPUT_LSR_ZLTemp1
.019b90	18		clc				clc
.019b91	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019b94	65 1a		adc $1a				adc 	ZLTemp1+0
.019b96	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019b99	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.019b9c	65 1b		adc $1b				adc 	ZLTemp1+1
.019b9e	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019ba1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.019ba4	65 1c		adc $1c				adc 	ZLTemp1+2
.019ba6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019ba9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.019bac	65 1d		adc $1d				adc 	ZLTemp1+3
.019bae	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019bb1	90 0f		bcc $019bc2			bcc 	_FPUTimes10
.019bb3	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.019bb6	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.019bb9	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.019bbc	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.019bbf	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.019bc2					_FPUTimes10:
.019bc2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019bc5	18		clc				clc
.019bc6	69 03		adc #$03			adc 	#3
.019bc8	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019bcb	b0 8e		bcs $019b5b			bcs 	FP_Overflow 				; error
.019bcd	60		rts				rts
.019bce					_FPUT_LSR_ZLTemp1:
.019bce	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019bd0	66 1c		ror $1c				ror 	ZLTemp1+2
.019bd2	66 1b		ror $1b				ror 	ZLTemp1+1
.019bd4	66 1a		ror $1a				ror 	ZLTemp1+0
.019bd6	60		rts				rts
.019bd7					FPUScale10A:
.019bd7	5a		phy				phy
.019bd8	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019bda	f0 3d		beq $019c19			beq 	_FPUScaleExit
.019bdc	da		phx				phx 								; save X
.019bdd	e8		inx				inx
.019bde	e8		inx				inx
.019bdf	e8		inx				inx
.019be0	e8		inx				inx
.019be1	e8		inx				inx
.019be2	e8		inx				inx
.019be3	a8		tay				tay 								; save power scalar in Y.
.019be4	a9 00		lda #$00			lda 	#0
.019be6	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019be9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019bec	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019bef	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019bf2	a9 80		lda #$80			lda 	#$80
.019bf4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019bf7	a9 81		lda #$81			lda 	#$81
.019bf9	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.019bfc	5a		phy				phy 								; save 10^n on stack.
.019bfd	c0 00		cpy #$00			cpy 	#0
.019bff	10 05		bpl $019c06			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019c01	98		tya				tya
.019c02	49 ff		eor #$ff			eor 	#$FF
.019c04	1a		inc a				inc 	a
.019c05	a8		tay				tay
.019c06					_FPUSAbs:
.019c06	20 76 9b	jsr $019b76			jsr 	FPUTimes10
.019c09	88		dey				dey
.019c0a	d0 fa		bne $019c06			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019c0c	68		pla				pla 								; restore count in A
.019c0d	fa		plx				plx 								; restore X pointing to number to scale.
.019c0e	0a		asl a				asl 	a
.019c0f	b0 05		bcs $019c16			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019c11	20 fd 98	jsr $0198fd			jsr 	FPMultiply 					; if clear multiply.
.019c14	80 03		bra $019c19			bra		_FPUScaleExit
.019c16					_FPUSDivide:
.019c16	20 75 98	jsr $019875			jsr 	FPDivide
.019c19					_FPUScaleExit:
.019c19	7a		ply				ply
.019c1a	60		rts				rts
.019c1b					FPUCopyToNext:
.019c1b	a0 06		ldy #$06			ldy 		#6
.019c1d	da		phx				phx
.019c1e					_FPUCopy1:
.019c1e	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.019c21	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.019c24	e8		inx				inx
.019c25	88		dey				dey
.019c26	d0 f6		bne $019c1e			bne 	_FPUCopy1
.019c28	fa		plx				plx
.019c29	60		rts				rts
.019c2a					FPUCopyFromNext:
.019c2a	a0 06		ldy #$06			ldy 		#6
.019c2c	da		phx				phx
.019c2d					_FPUCopy1:
.019c2d	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.019c30	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.019c33	e8		inx				inx
.019c34	88		dey				dey
.019c35	d0 f6		bne $019c2d			bne 	_FPUCopy1
.019c37	fa		plx				plx
.019c38	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.019c39					FPToString:
.019c39	48		pha				pha
.019c3a	5a		phy				phy
.019c3b	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.019c3e	50 0a		bvc $019c4a			bvc 		_FPTSIsFloat 			; if zero,
.019c40					_FPTSZero:
.019c40	a9 30		lda #$30			lda 		#"0"
.019c42	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter
.019c45					_FPTSExit:
.019c45	7a		ply				ply
.019c46	68		pla				pla
.019c47	60		rts				rts
.019c48	80 fb		bra $019c45			bra 		_FPTSExit
.019c4a					_FPTSIsFloat:
.019c4a	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.019c4d	10 0a		bpl $019c59			bpl 		_FPTSNotSigned
.019c4f	a9 00		lda #$00			lda 		#0 						; clear sign flag
.019c51	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.019c54	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019c56	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter
.019c59					_FPTSNotSigned:
.019c59	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.019c5c	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.019c5e	b0 09		bcs $019c69			bcs 		_FPTSExponent
.019c60	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.019c62	90 05		bcc $019c69			bcc 		_FPTSExponent 			;
.019c64					_FPTSStandard:
.019c64	20 ad 9c	jsr $019cad			jsr 		FPTOutputBody 			; output the body.
.019c67	80 dc		bra $019c45			bra 		_FPTSExit
.019c69					_FPTSExponent:
.019c69	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.019c6b	8d 8d 04	sta $048d			sta 		ExpCount
.019c6e					_FPTSExponentLoop:
.019c6e	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.019c71	10 0e		bpl $019c81			bpl 		_FPTSTimes
.019c73	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.019c75	90 14		bcc $019c8b			bcc 		_FPTSScaledToExp
.019c77	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.019c79	20 d7 9b	jsr $019bd7			jsr 		FPUScale10A
.019c7c	ee 8d 04	inc $048d			inc 		ExpCount
.019c7f	80 ed		bra $019c6e			bra 		_FPTSExponentLoop
.019c81					_FPTSTimes:
.019c81	a9 01		lda #$01			lda 		#1
.019c83	20 d7 9b	jsr $019bd7			jsr 		FPUScale10A
.019c86	ce 8d 04	dec $048d			dec 		ExpCount
.019c89	80 e3		bra $019c6e			bra 		_FPTSExponentLoop
.019c8b					_FPTSScaledToExp:
.019c8b	20 ad 9c	jsr $019cad			jsr 		FPTOutputBody 			; output the body.
.019c8e	a9 65		lda #$65			lda 		#"e"					; output E
.019c90	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter
.019c93	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.019c96	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.019c99	29 80		and #$80			and 		#$80 					; sign extend it
.019c9b	f0 02		beq $019c9f			beq 		_FPTSSExt
.019c9d	a9 ff		lda #$ff			lda 		#$FF
.019c9f					_FPTSSExt:
.019c9f	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.019ca2	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.019ca5	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.019ca8	20 25 96	jsr $019625			jsr 		INTToString 			; output the exponent.
.019cab	80 98		bra $019c45			bra			_FPTSExit 				; and exit.
.019cad					FPTOutputBody:
.019cad	20 1b 9c	jsr $019c1b			jsr 		FPUCopyToNext 			; copy to next slot.
.019cb0	20 0e 9b	jsr $019b0e			jsr 		FPUToInteger 			; convert to an integer
.019cb3	20 25 96	jsr $019625			jsr 		INTToString 			; output the main integer part.
.019cb6	20 2a 9c	jsr $019c2a			jsr 		FPUCopyFromNext 		; get the fractional part back.
.019cb9	20 9a 99	jsr $01999a			jsr 		FPFractionalPart 		; get the decimal part.
.019cbc	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.019cbf	70 3e		bvs $019cff			bvs 		_FPTOExit 				; if not, exit now.
.019cc1	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.019cc3	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter
.019cc6					_FPOutLoop:
.019cc6	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.019cc9	70 1e		bvs $019ce9			bvs 		_FPStripZeros 			; strip trailing zeros
.019ccb	20 76 9b	jsr $019b76			jsr 		FPUTimes10 				; multiply by 10
.019cce	20 1b 9c	jsr $019c1b			jsr 		FPUCopyToNext			; copy to next slot.
.019cd1	20 0e 9b	jsr $019b0e			jsr 		FPUToInteger 			; convert to integer
.019cd4	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.019cd7	09 30		ora #$30			ora 		#"0"
.019cd9	20 c9 96	jsr $0196c9			jsr 		ITSOutputCharacter
.019cdc	20 2a 9c	jsr $019c2a			jsr 		FPUCopyFromNext 		; get it back
.019cdf	20 9a 99	jsr $01999a			jsr 		FPFractionalPart 		; get fractional part
.019ce2	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.019ce5	c9 0b		cmp #$0b			cmp 	 	#11
.019ce7	90 dd		bcc $019cc6			bcc 		_FPOutLoop 				; if so, keep going till zero.
.019ce9					_FPStripZeros:
.019ce9	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.019cec					_FPStripLoop:
.019cec	88		dey				dey 								; back one, if at start then no strip
.019ced	f0 10		beq $019cff			beq 		_FPToExit
.019cef	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.019cf2	c9 30		cmp #$30			cmp 		#"0"
.019cf4	f0 f6		beq $019cec			beq 		_FPStripLoop
.019cf6	c8		iny				iny
.019cf7	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.019cf9	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.019cfc	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.019cff					_FPTOExit:
.019cff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.019d00					FPFromString:
.019d00	48		pha				pha 								; push A
.019d01	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.019d03	c9 2e		cmp #$2e			cmp 	#"."
.019d05	f0 03		beq $019d0a			beq	 	_FPFIsDecimal
.019d07	4c 6d 9d	jmp $019d6d			jmp 	_FPFNotDecimal
.019d0a					_FPFIsDecimal:
.019d0a	c8		iny				iny 								; consume the decimal.
.019d0b	20 af 9a	jsr $019aaf			jsr 	FPUToFloat 					; convert the integer to float.
.019d0e	da		phx				phx 								; save X.
.019d0f	5a		phy				phy 								; save decimal start position
.019d10	e8		inx				inx
.019d11	e8		inx				inx
.019d12	e8		inx				inx
.019d13	e8		inx				inx
.019d14	e8		inx				inx
.019d15	e8		inx				inx
.019d16	20 e1 96	jsr $0196e1			jsr 	INTFromStringY 				; get the part after the DP.
.019d19	20 af 9a	jsr $019aaf			jsr 	FPUToFloat 					; convert that to a float.
.019d1c	68		pla				pla 								; calculate - chars consumed.
.019d1d	8c 8c 04	sty $048c			sty 	ExpTemp
.019d20	38		sec				sec
.019d21	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.019d24	20 d7 9b	jsr $019bd7			jsr 	FPUScale10A 				; scale it by 10^AC
.019d27	fa		plx				plx 								; restore original X
.019d28	20 91 97	jsr $019791			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.019d2b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.019d2d	c9 45		cmp #$45			cmp 	#"E"
.019d2f	f0 04		beq $019d35			beq 	_FPFExponent
.019d31	c9 65		cmp #$65			cmp 	#"e"
.019d33	d0 38		bne $019d6d			bne 	_FPFNotDecimal 				; no, then exit normally.
.019d35					_FPFExponent:
.019d35	c8		iny				iny 								; skip over E symbol.
.019d36	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.019d38	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.019d3a	d0 01		bne $019d3d			bne 	_FPFGotSign
.019d3c	c8		iny				iny 								; if it was - skip over it.
.019d3d					_FPFGotSign:
.019d3d	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.019d3e	da		phx				phx
.019d3f	e8		inx				inx
.019d40	e8		inx				inx
.019d41	e8		inx				inx
.019d42	e8		inx				inx
.019d43	e8		inx				inx
.019d44	e8		inx				inx
.019d45	20 e1 96	jsr $0196e1			jsr 	INTFromStringY 				; get the exponent
.019d48	fa		plx				plx 								; restore X.
.019d49	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.019d4c	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.019d4f	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.019d52	d0 1b		bne $019d6f			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.019d54	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.019d57	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.019d59	b0 14		bcs $019d6f			bcs 	_FPFXOverflow
.019d5b	68		pla				pla 								; get direction
.019d5c	d0 09		bne $019d67			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.019d5e	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.019d61	49 ff		eor #$ff			eor 	#$FF
.019d63	1a		inc a				inc 	a
.019d64	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.019d67					_FPFXScale:
.019d67	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.019d6a	20 d7 9b	jsr $019bd7			jsr 	FPUScale10A 				; scale by the exponent.
.019d6d					_FPFNotDecimal:
.019d6d	68		pla				pla
.019d6e	60		rts				rts
.019d6f					_FPFXOverflow:
.019d6f	20 2f 84	jsr $01842f			jsr 	ERR_Handler
>019d72	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>019d7a	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.019d81					Unary_Rnd:
.019d81	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.019d84	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.019d87	20 ac 8c	jsr $018cac			jsr 	GetSignCurrent 				; get sign -1,0,1.
.019d8a	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.019d8c	30 10		bmi $019d9e			bmi 	_URSetSeed
.019d8e	f0 2c		beq $019dbc			beq 	_URMakeRandom 				; if zero return same number.
.019d90	da		phx				phx
.019d91	a2 00		ldx #$00			ldx 	#0
.019d93	20 f9 9d	jsr $019df9			jsr 	Random16
.019d96	a2 02		ldx #$02			ldx 	#2
.019d98	20 f9 9d	jsr $019df9			jsr 	Random16
.019d9b	fa		plx				plx
.019d9c	80 1e		bra $019dbc			bra 	_URMakeRandom
.019d9e					_URSetSeed:
.019d9e	20 af 9a	jsr $019aaf			jsr 	FPUToFloat 					; make it a float to twiddle it.
.019da1	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.019da4	8d 93 04	sta $0493			sta 	RandomSeed+0
.019da7	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.019daa	8d 94 04	sta $0494			sta 	RandomSeed+1
.019dad	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.019db0	8d 95 04	sta $0495			sta 	RandomSeed+2
.019db3	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.019db6	0a		asl a				asl 	a
.019db7	49 db		eor #$db			eor 	#$DB
.019db9	8d 96 04	sta $0496			sta 	RandomSeed+3
.019dbc					_URMakeRandom:
.019dbc	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.019dbf	0d 94 04	ora $0494			ora 	RandomSeed+1
.019dc2	0d 95 04	ora $0495			ora 	RandomSeed+2
.019dc5	0d 96 04	ora $0496			ora 	RandomSeed+3
.019dc8	d0 0a		bne $019dd4			bne 	_URNotZero
.019dca	a9 47		lda #$47			lda 	#$47
.019dcc	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.019dcf	a9 3d		lda #$3d			lda 	#$3D
.019dd1	8d 96 04	sta $0496			sta 	RandomSeed+3
.019dd4					_URNotZero:
.019dd4	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.019dd7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.019dda	ad 94 04	lda $0494			lda 	RandomSeed+1
.019ddd	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.019de0	ad 95 04	lda $0495			lda 	RandomSeed+2
.019de3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.019de6	ad 96 04	lda $0496			lda 	RandomSeed+3
.019de9	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.019dec	a9 00		lda #$00			lda 	#$00 						; set type to float.
.019dee	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.019df1	a9 80		lda #$80			lda 	#$80
.019df3	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.019df6	4c e6 9a	jmp $019ae6			jmp 	FPUNormalise
.019df9					Random16:
.019df9	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.019dfc	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.019dff	90 08		bcc $019e09			bcc 	_R16_NoXor
.019e01	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.019e04	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.019e06	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.019e09					_R16_NoXor:
.019e09	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.019e0a					Unary_Int:
.019e0a	20 bf 89	jsr $0189bf			jsr 	EvaluateNumberX 			; get value
.019e0d	20 4e 90	jsr $01904e			jsr 	CheckNextRParen 			; check right bracket.
.019e10	4c 0e 9b	jmp $019b0e			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>019e13	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
