
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Thu Sep  5 11:16:58 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/macros/65816/macros_32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$2000					VariableMemory = $2000
.012000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>012000	0a 0a 00 92 09 84 41 c8			.byte	$0a,$0a,$00,$92,$09,$84,$41,$c8
>012008	43 00 0a 14 00 92 0a 84			.byte	$43,$00,$0a,$14,$00,$92,$0a,$84
>012010	41 c8 44 00 09 1e 00 0b			.byte	$41,$c8,$44,$00,$09,$1e,$00,$0b
>012018	84 09 8a 0a 00 0a 28 00			.byte	$84,$09,$8a,$0a,$00,$0a,$28,$00
>012020	d6 09 bf 0a bf 0b 00 06			.byte	$d6,$09,$bf,$0a,$bf,$0b,$00,$06
>012028	32 00 97 0a 00 06 3c 00			.byte	$32,$00,$97,$0a,$00,$06,$3c,$00
>012030	97 09 00 05 46 00 c4 00			.byte	$97,$09,$00,$05,$46,$00,$c4,$00
>012038	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 13 88 01	jmp $018813		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ea	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f2	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; go to next line.
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.018281	ae ca 03	ldx $03ca			ldx 	TIM_X
.018284	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d c9 03	sta $03c9			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e ca 03	stx $03ca			stx 	TIM_X
.01838b	8c cb 03	sty $03cb			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d c8 03	sta $03c8			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.01839a	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce c4 03	dec $03c4			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d c4 03	sta $03c4			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018413	85 18		sta $18				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 19		inc $19				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; then exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 86 85	jsr $018586			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 86 85	jsr $018586			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848d					SkipEndOfCommand:
.01848d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01848f	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018491	f0 19		beq $0184ac			beq 	_SOCExit
.018493	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018495	f0 15		beq $0184ac			beq 	_SOCExit
.018497	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018499	c8		iny				iny 								; skip
.01849a	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01849c	90 0c		bcc $0184aa			bcc 	_SEDone 					; so just skip over it.
.01849e	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0184a0	90 07		bcc $0184a9			bcc 	_SEDouble
.0184a2	98		tya				tya 								; this is Y + 1
.0184a3	18		clc				clc
.0184a4	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.0184a6	a8		tay				tay 								; back in Y.
.0184a7	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a8	88		dey				dey
.0184a9					_SEDouble:
.0184a9	c8		iny				iny
.0184aa					_SEDone:
.0184aa	80 e1		bra $01848d			bra 	SkipEndOfCommand
.0184ac					_SOCExit:
.0184ac	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184ad					StackReset:
.0184ad	48		pha				pha
.0184ae	5a		phy				phy
.0184af	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.0184b1	85 28		sta $28				sta 	zBasicSP
.0184b3	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.0184b5	85 29		sta $29				sta 	zBasicSP+1
.0184b7	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b9	98		tya				tya 								; be a legal token.
.0184ba	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184bc	7a		ply				ply
.0184bd	68		pla				pla
.0184be	60		rts				rts
.0184bf					StackPushFrame:
.0184bf	48		pha				pha
.0184c0	5a		phy				phy
.0184c1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184c2	48		pha				pha 								; save it.
.0184c3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184c5	18		clc				clc 								; add to Basic Stack
.0184c6	65 28		adc $28				adc 	zBasicSP
.0184c8	85 28		sta $28				sta 	zBasicSP
.0184ca	90 02		bcc $0184ce			bcc 	_SPFNoBump
.0184cc	e6 29		inc $29				inc 	zBasicSP+1
.0184ce					_SPFNoBump:
.0184ce	a0 00		ldy #$00			ldy 	#0
.0184d0	68		pla				pla
.0184d1	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184d3	7a		ply				ply
.0184d4	68		pla				pla
.0184d5	60		rts				rts
.0184d6					StackPopFrame:
.0184d6	48		pha				pha
.0184d7	5a		phy				phy
.0184d8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184da	51 28		eor ($28),y			eor 	(zBasicSP),y
.0184dc	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184de	d0 12		bne $0184f2			bne 	SPFError 					; mixed structures
.0184e0	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.0184e2	29 0f		and #$0f			and 	#$0F
.0184e4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e6	38		sec				sec
.0184e7	65 28		adc $28				adc 	zBasicSP
.0184e9	85 28		sta $28				sta 	zBasicSP
.0184eb	b0 02		bcs $0184ef			bcs 	_SPFNoBump
.0184ed	c6 29		dec $29				dec 	zBasicSP+1
.0184ef					_SPFNoBump:
.0184ef	7a		ply				ply
.0184f0	68		pla				pla
.0184f1	60		rts				rts
.0184f2					SPFError:
.0184f2	20 86 85	jsr $018586			jsr ERR_Handler
>0184f5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fd	72 75 63 74 75 72 65 73 00
.018506					StackSavePosition:
.018506	98		tya				tya
.018507	5a		phy				phy
.018508	a0 05		ldy #$05			ldy 	#5
.01850a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01850c	a0 01		ldy #$01			ldy 	#1
.01850e	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.018510	91 28		sta ($28),y			sta 	(zBasicSP),y
.018512	c8		iny				iny
.018513	a5 19		lda $19				lda 	zCodePtr+1
.018515	91 28		sta ($28),y			sta 	(zBasicSP),y
.018517	c8		iny				iny
.018518	a5 1a		lda $1a				lda 	zCodePtr+2
.01851a	91 28		sta ($28),y			sta 	(zBasicSP),y
.01851c	c8		iny				iny
.01851d	a5 1b		lda $1b				lda 	zCodePtr+3
.01851f	91 28		sta ($28),y			sta 	(zBasicSP),y
.018521	7a		ply				ply
.018522	60		rts				rts
.018523					StackRestorePosition:
.018523	5a		phy				phy
.018524	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018526	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018528	85 18		sta $18				sta 	zCodePtr+0
.01852a	c8		iny				iny
.01852b	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852d	85 19		sta $19				sta 	zCodePtr+1
.01852f	c8		iny				iny
.018530	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018532	85 1a		sta $1a				sta 	zCodePtr+2
.018534	c8		iny				iny
.018535	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018537	85 1b		sta $1b				sta 	zCodePtr+3
.018539	c8		iny				iny
.01853a	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.01853c	7a		ply				ply 								; restore Y
.01853d	a8		tay				tay
.01853e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853f					VIOCharPrint:
.01853f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018542					VIOCharGet:
.018542	20 e6 81	jsr $0181e6			jsr 	IF_GetKey
.018545	c9 00		cmp #$00			cmp 	#0
.018547	f0 02		beq $01854b			beq 	_VCG0
.018549	38		sec				sec
.01854a	60		rts				rts
.01854b	18		clc		_VCG0:	clc
.01854c	60		rts				rts
.01854d					VIOCheckBreak:
.01854d	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak
.018550					VIOCharGetPosition:
.018550	ad 00 05	lda $0500			lda 	IFT_XCursor
.018553	60		rts				rts
.018554					VIOReadLine:
.018554	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018557					SyntaxError:
.018557	20 86 85	jsr $018586			jsr 	ERR_Handler
>01855a	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018562	72 72 6f 72 00
.018567					TypeError:
.018567	20 86 85	jsr $018586			jsr 	ERR_Handler
>01856a	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018572	70 65 00
.018575					BadParamError:
.018575	20 86 85	jsr $018586			jsr 	ERR_Handler
>018578	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018580	6d 65 74 65 72 00
.018586					ERR_Handler:
.018586	a0 00		ldy #$00			ldy 	#0
.018588	c8		iny				iny
.018589	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01858b	85 80		sta $80				sta 	XS_Mantissa
.01858d	c8		iny				iny
.01858e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018590	85 81		sta $81				sta 	XS_Mantissa+1
.018592	fa		plx				plx 								; address in XY
.018593	7a		ply				ply
.018594	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018595	d0 01		bne $018598			bne 	_EHNoSkip
.018597	c8		iny				iny
.018598					_EHNoSkip:
.018598	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage 			; print message from ROM.
.01859b	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859d	05 81		ora $81				ora 	XS_Mantissa+1
.01859f	f0 0c		beq $0185ad			beq 	_EHNoLine
.0185a1	a2 b7		ldx #$b7			ldx 	#_EHAt & $FF 				; print " at "
.0185a3	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a5	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage
.0185a8	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185aa	20 d1 85	jsr $0185d1			jsr 	Print16BitInteger
.0185ad					_EHNoLine:
.0185ad	80 fe		bra $0185ad			bra 	_EHNoLine
.0185af	a9 0d		lda #$0d			lda 	#13
.0185b1	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185b4	4c 59 88	jmp $018859			jmp 	ErrorStart 					; normally warm start, no message.
>0185b7	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185bc					PrintROMMessage:
.0185bc	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.0185be	84 1d		sty $1d				sty 	zLTemp1+1
.0185c0	4b		phk				phk 								; get current code page
.0185c1	68		pla				pla
.0185c2	85 1e		sta $1e				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185c4	a0 00		ldy #$00			ldy 	#0
.0185c6					_PRMLoop:
.0185c6	b7 1c		lda [$1c],y			lda 	[zLTemp1],y 				; 65816
.0185c8	f0 06		beq $0185d0			beq		_PRMExit 					; character $00 => exit
.0185ca	c8		iny				iny  								; bump Y and print it.
.0185cb	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185ce	80 f6		bra $0185c6			bra 	_PRMLoop
.0185d0					_PRMExit:
.0185d0	60		rts				rts
.0185d1					Print16BitInteger:
.0185d1	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185d3	85 82		sta $82				sta 	XS_Mantissa+2
.0185d5	85 83		sta $83				sta 	XS_Mantissa+3
.0185d7					Print32BitInteger:
.0185d7	a9 00		lda #$00			lda 	#0
.0185d9	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185dc	aa		tax				tax 								; convert bottom level.
.0185dd	20 e2 a1	jsr $01a1e2			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185e0	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185e2	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185e5	f0 06		beq $0185ed			beq 	_P1Exit
.0185e7	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.0185ea	e8		inx				inx
.0185eb	80 f5		bra $0185e2			bra 	_P1Loop
.0185ed	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185ef					VectorTable:
>0185ef	0e 94					.word BinaryOp_And         & $FFFF ; $80 and
>0185f1	2a 94					.word BinaryOp_Or          & $FFFF ; $81 or
>0185f3	46 94					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185f5	46 94					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185f7	7d 94					.word Binary_Equal         & $FFFF ; $84 =
>0185f9	86 94					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185fb	8f 94					.word Binary_Less          & $FFFF ; $86 <
>0185fd	98 94					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185ff	aa 94					.word Binary_Greater       & $FFFF ; $88 >
>018601	a1 94					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>018603	42 95					.word BinaryOp_Add         & $FFFF ; $8a +
>018605	5e 95					.word BinaryOp_Subtract    & $FFFF ; $8b -
>018607	6f 95					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018609	80 95					.word BinaryOp_Divide      & $FFFF ; $8d /
>01860b	ad 86					.word NotImplemented       & $FFFF ; $8e ^
>01860d	9c 8d					.word Command_IF           & $FFFF ; $8f if
>01860f	0a 92					.word Command_WHILE        & $FFFF ; $90 while
>018611	32 92					.word Command_REPEAT       & $FFFF ; $91 repeat
>018613	ee 89					.word Command_FOR          & $FFFF ; $92 for
>018615	ad 86					.word NotImplemented       & $FFFF ; $93 then
>018617	f9 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018619	27 92					.word Command_WEND         & $FFFF ; $95 wend
>01861b	3b 92					.word Command_UNTIL        & $FFFF ; $96 until
>01861d	6b 8a					.word Command_NEXT         & $FFFF ; $97 next
>01861f	ad 86					.word NotImplemented       & $FFFF ; $98 not
>018621	ad 86					.word NotImplemented       & $FFFF ; $99 fn(
>018623	7b 96					.word Unary_Abs            & $FFFF ; $9a abs(
>018625	d6 97					.word Unary_Asc            & $FFFF ; $9b asc(
>018627	00 a9					.word Unary_Int            & $FFFF ; $9c int(
>018629	95 96					.word Unary_Peek           & $FFFF ; $9d peek(
>01862b	81 a8					.word Unary_Rnd            & $FFFF ; $9e rnd(
>01862d	08 97					.word Unary_Usr            & $FFFF ; $9f usr(
>01862f	15 98					.word Unary_Left           & $FFFF ; $a0 left$(
>018631	2a 98					.word Unary_Right          & $FFFF ; $a1 right$(
>018633	fc 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018635	75 99					.word Unary_Spc            & $FFFF ; $a3 spc(
>018637	a4 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018639	29 97					.word Unary_Val            & $FFFF ; $a5 val(
>01863b	ed 97					.word Unary_Len            & $FFFF ; $a6 len(
>01863d	a2 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01863f	ad 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018641	ad 86					.word NotImplemented       & $FFFF ; $a9 cos(
>018643	ad 86					.word NotImplemented       & $FFFF ; $aa tan(
>018645	ad 86					.word NotImplemented       & $FFFF ; $ab atn(
>018647	ad 86					.word NotImplemented       & $FFFF ; $ac exp(
>018649	ad 86					.word NotImplemented       & $FFFF ; $ad log(
>01864b	ad 86					.word NotImplemented       & $FFFF ; $ae sqr(
>01864d	f8 98					.word Unary_Dec            & $FFFF ; $af dec(
>01864f	99 96					.word Unary_Deek           & $FFFF ; $b0 deek(
>018651	9d 96					.word Unary_Leek           & $FFFF ; $b1 leek(
>018653	d5 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>018655	35 96					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018657	57 99					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018659	c9 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>01865b	98 99					.word Unary_Tab            & $FFFF ; $b6 tab(
>01865d	ad 86					.word NotImplemented       & $FFFF ; $b7 $
>01865f	ad 86					.word NotImplemented       & $FFFF ; $b8 $(
>018661	ad 86					.word NotImplemented       & $FFFF ; $b9 #
>018663	ad 86					.word NotImplemented       & $FFFF ; $ba #(
>018665	ad 86					.word NotImplemented       & $FFFF ; $bb %
>018667	ad 86					.word NotImplemented       & $FFFF ; $bc %(
>018669	ad 86					.word NotImplemented       & $FFFF ; $bd (
>01866b	ad 86					.word NotImplemented       & $FFFF ; $be )
>01866d	ad 86					.word NotImplemented       & $FFFF ; $bf ,
>01866f	ed 89					.word Command_COLON        & $FFFF ; $c0 :
>018671	ad 86					.word NotImplemented       & $FFFF ; $c1 ;
>018673	ad 86					.word NotImplemented       & $FFFF ; $c2 def
>018675	eb 91					.word Command_CLR          & $FFFF ; $c3 clr
>018677	02 92					.word Command_STOP         & $FFFF ; $c4 stop
>018679	44 8b					.word Command_DATA         & $FFFF ; $c5 data
>01867b	1e 8b					.word Command_READ         & $FFFF ; $c6 read
>01867d	94 88					.word Command_DIM          & $FFFF ; $c7 dim
>01867f	ad 86					.word NotImplemented       & $FFFF ; $c8 to
>018681	ad 86					.word NotImplemented       & $FFFF ; $c9 step
>018683	31 91					.word Command_GOSUB        & $FFFF ; $ca gosub
>018685	41 91					.word Command_RETURN       & $FFFF ; $cb return
>018687	29 91					.word Command_GOTO         & $FFFF ; $cc goto
>018689	98 8d					.word Command_END          & $FFFF ; $cd end
>01868b	67 8c					.word Command_INPUT        & $FFFF ; $ce input
>01868d	e2 8b					.word Command_LET          & $FFFF ; $cf let
>01868f	ff 8d					.word Command_LIST         & $FFFF ; $d0 list
>018691	d3 90					.word Command_NEW          & $FFFF ; $d1 new
>018693	ef 90					.word Command_OLD          & $FFFF ; $d2 old
>018695	4a 91					.word Command_ON           & $FFFF ; $d3 on
>018697	47 8b					.word Command_RESTORE      & $FFFF ; $d4 restore
>018699	a2 90					.word Command_POKE         & $FFFF ; $d5 poke
>01869b	f3 8f					.word Command_PRINT        & $FFFF ; $d6 print
>01869d	5f 89					.word Command_RUN          & $FFFF ; $d7 run
>01869f	1f 89					.word Command_WAIT         & $FFFF ; $d8 wait
>0186a1	4d 8c					.word Command_SYS          & $FFFF ; $d9 sys
>0186a3	a6 90					.word Command_DOKE         & $FFFF ; $da doke
>0186a5	aa 90					.word Command_LOKE         & $FFFF ; $db loke
>0186a7	8a 90					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a9	03 8c					.word Command_GET          & $FFFF ; $dd get
>0186ab	f3 8d					.word Command_ELSE         & $FFFF ; $de else
.0186ad					NotImplemented:
.0186ad	20 86 85	jsr $018586			jsr ERR_Handler
>0186b0	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b8	65 6d 65 6e 74 65 64 00
.0186c0					BinaryPrecedence:
>0186c0	01					.byte 1    ; $80 and
>0186c1	01					.byte 1    ; $81 or
>0186c2	01					.byte 1    ; $82 xor
>0186c3	01					.byte 1    ; $83 eor
>0186c4	02					.byte 2    ; $84 =
>0186c5	02					.byte 2    ; $85 <>
>0186c6	02					.byte 2    ; $86 <
>0186c7	02					.byte 2    ; $87 <=
>0186c8	02					.byte 2    ; $88 >
>0186c9	02					.byte 2    ; $89 >=
>0186ca	03					.byte 3    ; $8a +
>0186cb	03					.byte 3    ; $8b -
>0186cc	04					.byte 4    ; $8c *
>0186cd	04					.byte 4    ; $8d /
>0186ce	05					.byte 5    ; $8e ^
.0186cf					KeywordText:
>0186cf	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186d2	4f d2					.byte $4f,$d2                          ; $81 or
>0186d4	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186d7	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186da	bd					.byte $bd                              ; $84 =
>0186db	3c be					.byte $3c,$be                          ; $85 <>
>0186dd	bc					.byte $bc                              ; $86 <
>0186de	3c bd					.byte $3c,$bd                          ; $87 <=
>0186e0	be					.byte $be                              ; $88 >
>0186e1	3e bd					.byte $3e,$bd                          ; $89 >=
>0186e3	ab					.byte $ab                              ; $8a +
>0186e4	ad					.byte $ad                              ; $8b -
>0186e5	aa					.byte $aa                              ; $8c *
>0186e6	af					.byte $af                              ; $8d /
>0186e7	de					.byte $de                              ; $8e ^
>0186e8	49 c6					.byte $49,$c6                          ; $8f if
>0186ea	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186ef	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186f5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186fc	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>018701	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>018705	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>01870a	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>01870e	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018711	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>018714	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018718	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>01871c	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018720	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>018725	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018729	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>01872d	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>018733	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>01873a	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01873f	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>018743	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018748	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>01874c	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018750	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018755	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018759	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>01875d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018761	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018765	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018769	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>01876d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018771	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018775	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>01877a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01877f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>018783	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018787	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>01878c	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018790	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018794	a4					.byte $a4                              ; $b7 $
>018795	24 a8					.byte $24,$a8                          ; $b8 $(
>018797	a3					.byte $a3                              ; $b9 #
>018798	23 a8					.byte $23,$a8                          ; $ba #(
>01879a	a5					.byte $a5                              ; $bb %
>01879b	25 a8					.byte $25,$a8                          ; $bc %(
>01879d	a8					.byte $a8                              ; $bd (
>01879e	a9					.byte $a9                              ; $be )
>01879f	ac					.byte $ac                              ; $bf ,
>0187a0	ba					.byte $ba                              ; $c0 :
>0187a1	bb					.byte $bb                              ; $c1 ;
>0187a2	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>0187a5	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a8	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187ac	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187b0	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187b4	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187b7	54 cf					.byte $54,$cf                          ; $c8 to
>0187b9	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187bd	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187c2	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c8	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187cc	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187cf	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187d4	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187d7	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187db	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187de	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187e1	4f ce					.byte $4f,$ce                          ; $d3 on
>0187e3	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187ea	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ee	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187f3	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187f6	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187fa	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187fd	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>018801	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>018805	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>01880b	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>01880e	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>018812	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.018813					BASIC_Start:
.018813	c2 30		rep #$30			rep 	#$30
.018815	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018818	1b		tcs				tcs
.018819	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01881c	e2 30		sep #$30			sep 	#$30
.01881e	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.018821	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018824	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018826	8d 10 03	sta $0310			sta 	LocalVector
.018829	8d 0c 03	sta $030c			sta 	UserVector
.01882c	a9 17		lda #$17			lda 	#USRDefault & $FF 			; reset USR vector to a default
.01882e	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.018831	a9 97		lda #$97			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.018833	8d 0e 03	sta $030e			sta 	UserVector+2
.018836	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018838	8d 0f 03	sta $030f			sta 	UserVector+3
.01883b	20 df 99	jsr $0199df			jsr 	UpdateProgramEnd 			; update the program end.
.01883e	20 eb 91	jsr $0191eb			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018841	c2 30		rep #$30			rep 	#$30
.018843	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018846	1b		tcs				tcs
.018847	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01884a	e2 30		sep #$30			sep 	#$30
.01884c	4c 5f 89	jmp $01895f			jmp 	COMMAND_Run
.01884f	20 d3 90	jsr $0190d3			jsr 	Command_NEW 				; new command, will not return.
.018852					WarmStart:
.018852	a2 8a		ldx #$8a			ldx 	#ReadyMsg & $FF 			; Print READY.
.018854	a0 88		ldy #$88			ldy 	#(ReadyMsg >> 8) & $FF
.018856	20 bc 85	jsr $0185bc			jsr 	PrintROMMessage
.018859					ErrorStart:
.018859	c2 30		rep #$30			rep 	#$30
.01885b	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.01885e	1b		tcs				tcs
.01885f	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018862	e2 30		sep #$30			sep 	#$30
.018864	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine 				; read line in.
.018867	a9 66		lda #$66			lda 	#IFT_LineBuffer & $FF 		; tokenise it.
.018869	a2 05		ldx #$05			ldx 	#IFT_LineBuffer >> 8
.01886b	20 76 9b	jsr $019b76			jsr 	TokeniseString
.01886e	ad 03 04	lda $0403			lda 	TokeniseBuffer+3 			; what is first.
.018871	29 c0		and #$c0			and 	#$C0 						; is it a number 4000-7FFF
.018873	c9 40		cmp #$40			cmp 	#$40
.018875	f0 1b		beq $018892			beq 	EditLine 					; if true, go to edit line.
.018877	a9 00		lda #$00			lda 	#(TokeniseBuffer) & $FF
.018879	85 18		sta $18				sta 	zCodePtr+0
.01887b	a9 04		lda #$04			lda 	#((TokeniseBuffer) >> 8) & $FF
.01887d	85 19		sta $19				sta 	zCodePtr+1
.01887f	a9 00		lda #$00			lda 	#(TokeniseBuffer) >> 16
.018881	85 1a		sta $1a				sta 	zCodePtr+2
.018883	85 1b		sta $1b				sta 	zCodePtr+3
.018885	a0 03		ldy #$03			ldy 	#3
.018887	4c 93 89	jmp $018993			jmp 	RUN_NextCommand
.01888a					ReadyMsg:
>01888a	52 65 61 64 79 2e 0d 00				.text 	"Ready.",13,0
.018892					EditLine:
.018892	80 fe		bra $018892			bra 	EditLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018894					Command_DIM:
.018894	98		tya				tya
.018895	48		pha				pha 								; push on stack.
.018896	20 6b 9d	jsr $019d6b			jsr 	VariableExtract 			; get the identifier
.018899	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.01889c	29 01		and #$01			and 	#1
.01889e	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.0188a0	d0 6f		bne $018911			bne 	_CDIError
.0188a2	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.0188a4	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.0188a7					_CDIGetDimension:
.0188a7	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.0188aa	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.0188ac	f0 63		beq $018911			beq 	_CDIError
.0188ae	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; evaluate an index size
.0188b1	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.0188b3	29 80		and #$80			and 	#$80
.0188b5	05 82		ora $82				ora 	XS_Mantissa+2
.0188b7	05 83		ora $83				ora 	XS_Mantissa+3
.0188b9	d0 56		bne $018911			bne 	_CDIError
.0188bb	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.0188be	18		clc				clc 								; add 1 - max index => size.
.0188bf	a5 80		lda $80				lda 	XS_Mantissa+0
.0188c1	69 01		adc #$01			adc 	#1
.0188c3	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.0188c6	a5 81		lda $81				lda 	XS_Mantissa+1
.0188c8	69 00		adc #$00			adc 	#0
.0188ca	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.0188cd	30 42		bmi $018911			bmi 	_CDIError 					; could be dim a(32767)
.0188cf	e8		inx				inx 								; bump index.
.0188d0	e8		inx				inx
.0188d1	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.0188d4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188d6	c8		iny				iny
.0188d7	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.0188d9	f0 cc		beq $0188a7			beq 	_CDIGetDimension
.0188db	88		dey				dey
.0188dc	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; closing ) present ?
.0188df	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.0188e2	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.0188e4	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.0188e7					_CDICopy:
.0188e7	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.0188ea	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188ed	ca		dex				dex
.0188ee	10 f7		bpl $0188e7			bpl 	_CDICopy
.0188f0	68		pla				pla									; position of array identifier
.0188f1	85 10		sta $10				sta 	zTemp1
.0188f3	98		tya				tya
.0188f4	48		pha				pha
.0188f5	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188f7	a8		tay				tay
.0188f8	20 6b 9d	jsr $019d6b			jsr 	VariableExtract 			; get the identifier
.0188fb	20 04 a0	jsr $01a004			jsr 	VariableLocate 				; check if it exists already.
.0188fe	b0 11		bcs $018911			bcs 	_CDIError
.018900	20 f7 9d	jsr $019df7			jsr 	VariableCreate 				; create it using the current ArrayDef
.018903	68		pla				pla 								; restore code position
.018904	a8		tay				tay
.018905	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018907	c8		iny				iny
.018908	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.01890a	f0 88		beq $018894			beq 	Command_DIM
.01890c	88		dey				dey
.01890d	20 06 9f	jsr $019f06			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.018910	60		rts				rts
.018911					_CDIError:
.018911	20 86 85	jsr $018586			jsr ERR_Handler
>018914	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.01891c					_CDISyntax:
.01891c	4c 57 85	jmp $018557			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.01891f					Command_WAIT:
.01891f	20 ef 93	jsr $0193ef			jsr		EvaluateInteger 			; get address to monitor
.018922	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.018924	20 43 9a	jsr $019a43			jsr 	CheckNextComma
.018927	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX
.01892a	a9 00		lda #$00			lda 	#0							; set default xor value.
.01892c	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.01892e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018930	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.018932	d0 06		bne $01893a			bne 	_CWAXorDefault
.018934	c8		iny				iny
.018935	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.018937	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX
.01893a					_CWAXorDefault:
.01893a	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.01893c	85 1c		sta $1c				sta 	zLTemp1
.01893e	a5 81		lda $81				lda 	XS_Mantissa+1
.018940	85 1d		sta $1d				sta 	zLTemp1+1
.018942	a5 82		lda $82				lda 	XS_Mantissa+2
.018944	85 1e		sta $1e				sta 	zLTemp1+2
.018946					_CWAWaitLoop:
.018946	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; exit on break.
.018949	c9 00		cmp #$00			cmp 	#0
.01894b	d0 11		bne $01895e			bne 	_CWAWaitExit
.01894d	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.01894f	a2 00		ldx #$00			ldx 	#0
.018951	5a		phy				phy 								; this is the same routine as PEEK.
.018952	20 bd 99	jsr $0199bd			jsr 	MemRead
.018955	7a		ply				ply
.018956	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.018958	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.01895a	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.01895c	f0 e8		beq $018946			beq 	_CWAWaitLoop 				; and loop if zero.
.01895e					_CWAWaitExit:
.01895e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.01895f					Command_RUN:
.01895f	20 eb 91	jsr $0191eb			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018962	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018964	85 18		sta $18				sta 	zCodePtr+0
.018966	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.018968	85 19		sta $19				sta 	zCodePtr+1
.01896a	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.01896c	85 1a		sta $1a				sta 	zCodePtr+2
.01896e	85 1b		sta $1b				sta 	zCodePtr+3
.018970	a0 03		ldy #$03			ldy 	#3
.018972					RUN_NewLine:
.018972	a0 00		ldy #$00			ldy 	#0
.018974	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018976	c8		iny				iny
.018977	c8		iny				iny
.018978	c8		iny				iny
.018979	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.01897b	d0 16		bne $018993			bne 	RUN_NextCommand
.01897d	4c 98 8d	jmp $018d98			jmp 	Command_END 				; go do the command code.
.018980					RUN_Skip:
.018980	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018982	c8		iny				iny 								; skip
.018983	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018985	90 0c		bcc $018993			bcc 	_SEDone 					; so just skip over it.
.018987	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018989	90 07		bcc $018992			bcc 	_SEDouble
.01898b	98		tya				tya 								; this is Y + 1
.01898c	18		clc				clc
.01898d	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.01898f	a8		tay				tay 								; back in Y.
.018990	88		dey				dey 								; fix up, one for the +1, one for the iny
.018991	88		dey				dey
.018992					_SEDouble:
.018992	c8		iny				iny
.018993					_SEDone:
.018993					RUN_NextCommand:
.018993	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.018996	69 10		adc #$10			adc 	#16 						; one time in 16
.018998	8d a8 03	sta $03a8			sta 	BreakCount
.01899b	90 0a		bcc $0189a7			bcc 	RUN_NoCheckBreak
.01899d	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check for break
.0189a0	c9 00		cmp #$00			cmp 	#0
.0189a2	f0 03		beq $0189a7			beq 	RUN_NoCheckBreak
.0189a4	4c 02 92	jmp $019202			jmp 	Command_STOP 				; stop on BREAK.
.0189a7					RUN_NoCheckBreak:
.0189a7	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.0189a9	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.0189ab	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0189ad	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.0189af	f0 cf		beq $018980			beq 	RUN_Skip
.0189b1	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.0189b3	d0 0f		bne $0189c4			bne 	RUN_Execute
.0189b5					RUN_NextLine:
.0189b5	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0189b7	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0189b9	18		clc				clc
.0189ba	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0189bc	85 18		sta $18				sta 	zCodePtr
.0189be	90 02		bcc $0189c2			bcc 	_SNLNoCarry
.0189c0	e6 19		inc $19				inc 	zCodePtr+1
.0189c2					_SNLNoCarry:
.0189c2	80 ae		bra $018972			bra 	RUN_NewLine 				; go do the new line code
.0189c4					RUN_Execute:
.0189c4	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.0189c6	b0 1e		bcs $0189e6			bcs 	RUN_Extension
.0189c8	c8		iny				iny
.0189c9	0a		asl a				asl 	a 							; double the character read.
.0189ca	90 14		bcc $0189e0			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.0189cc	aa		tax				tax 								; ready to look up.
.0189cd	bf ef 85 01	lda $0185ef,x			lda 	VectorTable,x 				; copy address into LocalVector
.0189d1	8d 11 03	sta $0311			sta 	LocalVector+1
.0189d4	bf f0 85 01	lda $0185f0,x			lda 	VectorTable+1,x
.0189d8	8d 12 03	sta $0312			sta 	LocalVector+2
.0189db	20 3c 93	jsr $01933c			jsr 	EVCallLocalVector 			; execute the appropriate code.
.0189de	80 b3		bra $018993			bra 	RUN_NextCommand 			; do the next command.
.0189e0					RUN_Default:
.0189e0	88		dey				dey
.0189e1	20 e2 8b	jsr $018be2			jsr 	Command_LET 				; and try LET.
.0189e4	80 ad		bra $018993			bra 	RUN_NextCommand
.0189e6					RUN_Extension:
.0189e6	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.0189e8	f0 96		beq $018980			beq 	RUN_Skip 					; skip over it.
.0189ea	4c 57 85	jmp $018557			jmp 	SyntaxError
.0189ed					Command_COLON:
.0189ed	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189ee					Command_FOR:
.0189ee	20 e2 8b	jsr $018be2			jsr 	Command_LET 				; do the A = 99 bit
.0189f1	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.0189f3	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189f5	f0 71		beq $018a68			beq 	_CFOError
.0189f7	48		pha				pha 								; save the variable type.
.0189f8	5a		phy				phy 								; save type/variable address.
.0189f9	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189fb	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189fd	c8		iny				iny
.0189fe	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.018a00	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a02	c8		iny				iny
.018a03	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.018a05	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a07	7a		ply				ply
.018a08	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.018a0a	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.018a0d	a9 c8		lda #$c8			lda 	#token_TO
.018a0f	20 24 9a	jsr $019a24			jsr 	CheckNextToken
.018a12	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.018a14	20 59 92	jsr $019259			jsr 	EvaluateExpression
.018a17	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a19	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.018a1b	c9 c9		cmp #$c9			cmp 	#token_STEP
.018a1d	d0 06		bne $018a25			bne 	_CFOStep1
.018a1f	c8		iny				iny
.018a20	20 5b 92	jsr $01925b			jsr 	EvaluateExpressionX 		; get STEP value.
.018a23	80 0e		bra $018a33			bra 	_CFOHaveStep
.018a25					_CFOStep1:
.018a25	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.018a27	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018a29	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018a2b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018a2d	a9 01		lda #$01			lda 	#1
.018a2f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a31	95 85		sta $85,x			sta 	XS_Type,x
.018a33					_CFOHaveStep:
.018a33	68		pla				pla 								; restore variable type
.018a34	a2 00		ldx #$00			ldx 	#0
.018a36	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.018a38	f0 0a		beq $018a44			beq 	_CFOInteger
.018a3a	20 01 a6	jsr $01a601			jsr 	FPUToFloat
.018a3d	a2 06		ldx #$06			ldx 	#6
.018a3f	20 01 a6	jsr $01a601			jsr 	FPUToFloat
.018a42	80 08		bra $018a4c			bra 	_CFOEndConv
.018a44					_CFOInteger:
.018a44	20 4d a6	jsr $01a64d			jsr 	FPUToInteger
.018a47	a2 06		ldx #$06			ldx 	#6
.018a49	20 4d a6	jsr $01a64d			jsr 	FPUToInteger
.018a4c					_CFOEndConv:
.018a4c	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a4f	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a51	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push the loop address frame.
.018a54	5a		phy				phy
.018a55	a0 00		ldy #$00			ldy 	#0
.018a57					_CFOCopy:
.018a57	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a5a	c8		iny				iny
.018a5b	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a5d	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a5f	d0 f6		bne $018a57			bne 	_CFOCopy
.018a61	7a		ply				ply
.018a62	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a64	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018a67	60		rts				rts
.018a68					_CFOError:
.018a68	4c 67 85	jmp $018567			jmp 	TypeError 					; wrong type.
.018a6b					Command_NEXT:
.018a6b	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a6d	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.018a6f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a71	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a73	f0 07		beq $018a7c			beq 	_CNextNoVariable
.018a75	c9 40		cmp #$40			cmp 	#$40
.018a77	b0 03		bcs $018a7c			bcs 	_CNextNoVariable
.018a79	20 00 9d	jsr $019d00			jsr 	VariableFind
.018a7c					_CNextNoVariable:
.018a7c	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.018a7e	48		pha				pha
.018a7f	a5 29		lda $29				lda 	zBasicSP+1
.018a81	48		pha				pha
.018a82	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a84	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a87	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a89	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a8c	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a8e	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018a91	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a93	f0 11		beq $018aa6			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a95	5a		phy				phy 								; check addresses match.
.018a96	a0 02		ldy #$02			ldy 	#2
.018a98	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a9a	c5 24		cmp $24				cmp 	zVarDataPtr
.018a9c	d0 69		bne $018b07			bne 	_CNextWrong
.018a9e	c8		iny				iny
.018a9f	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aa1	c5 25		cmp $25				cmp 	zVarDataPtr+1
.018aa3	d0 62		bne $018b07			bne 	_CNextWrong
.018aa5	7a		ply				ply
.018aa6					_CNextGetTarget:
.018aa6	5a		phy				phy
.018aa7	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018aa9	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018aab	85 26		sta $26				sta 	zVarType
.018aad	c8		iny				iny
.018aae	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ab0	85 24		sta $24				sta 	zVarDataPtr
.018ab2	c8		iny				iny
.018ab3	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ab5	85 25		sta $25				sta 	zVarDataPtr+1
.018ab7	a2 0c		ldx #$0c			ldx 	#12
.018ab9	20 48 a0	jsr $01a048			jsr 	VariableGet 				; get that variable value into expr[2]
.018abc	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018abe	a0 0b		ldy #$0b			ldy 	#11
.018ac0					_CNXCopy:
.018ac0	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018ac2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ac4	e8		inx				inx
.018ac5	c8		iny				iny
.018ac6	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018ac8	d0 f6		bne $018ac0			bne 	_CNXCopy
.018aca	7a		ply				ply
.018acb	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018acd	20 59 96	jsr $019659			jsr 	GetSignCurrent
.018ad0	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018ad3	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018ad5	20 42 95	jsr $019542			jsr 	BinaryOp_Add
.018ad8	20 99 a0	jsr $01a099			jsr 	VariableSet					; and write variable back.
.018adb	a2 00		ldx #$00			ldx 	#0
.018add	20 c6 94	jsr $0194c6			jsr 	CompareValues
.018ae0	09 00		ora #$00			ora 	#0
.018ae2	f0 05		beq $018ae9			beq 	_CNXAgain 					; if true, then do it again.
.018ae4	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018ae7	d0 0f		bne $018af8			bne 	_CNXLoopDone
.018ae9					_CNXAgain:
.018ae9	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018aeb	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018aee	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018af1	68		pla				pla
.018af2	85 29		sta $29				sta 	zBasicSP+1
.018af4	68		pla				pla
.018af5	85 28		sta $28				sta 	zBasicSP
.018af7					_CNXExit:
.018af7	60		rts				rts
.018af8					_CNXLoopDone:
.018af8	68		pla				pla 								; throw away saved to Basic Stack Pointer
.018af9	68		pla				pla
.018afa	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018afc	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018afe	d0 f7		bne $018af7			bne 	_CNXExit
.018b00	c8		iny				iny
.018b01	20 00 9d	jsr $019d00			jsr 	VariableFind 				; identify the variable
.018b04	4c 7c 8a	jmp $018a7c			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018b07					_CNextWrong:
.018b07	20 86 85	jsr $018586			jsr ERR_Handler
>018b0a	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018b12	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018b1e					Command_READ:
.018b1e	20 00 9d	jsr $019d00			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018b21	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018b23	48		pha				pha
.018b24	a5 25		lda $25				lda 	zVarDataPtr+1
.018b26	48		pha				pha
.018b27	a5 26		lda $26				lda 	zVarType
.018b29	48		pha				pha
.018b2a	20 70 8b	jsr $018b70			jsr 	READGetDataItem 			; get the next data item
.018b2d	68		pla				pla 								; restore target variable information.
.018b2e	85 26		sta $26				sta 	zVarType
.018b30	68		pla				pla
.018b31	85 25		sta $25				sta 	zVarDataPtr+1
.018b33	68		pla				pla
.018b34	85 24		sta $24				sta 	zVarDataPtr
.018b36	a2 00		ldx #$00			ldx 	#0
.018b38	20 99 a0	jsr $01a099			jsr 	VariableSet 				; set the value out.
.018b3b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b3d	c8		iny				iny
.018b3e	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b40	f0 dc		beq $018b1e			beq 	Command_READ 				; found, do another READ
.018b42	88		dey				dey
.018b43	60		rts				rts
.018b44					Command_DATA:
.018b44	4c 8d 84	jmp $01848d			jmp 	SkipEndOfCommand
.018b47					Command_RESTORE:
.018b47	48		pha				pha
.018b48	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018b4a	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018b4d	8d be 03	sta $03be			sta 	DataLPtr+1
.018b50	68		pla				pla
.018b51	60		rts				rts
.018b52					READSwapPointers:
.018b52	98		tya				tya
.018b53	48		pha				pha 								; save it
.018b54	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b57	a8		tay				tay
.018b58	68		pla				pla 								; get code offset and save in DataIndex
.018b59	8d c1 03	sta $03c1			sta 	DataIndex
.018b5c	da		phx				phx
.018b5d	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b5f					_RSWLoop:
.018b5f	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b62	48		pha				pha
.018b63	b5 18		lda $18,x			lda 	zCodePtr+0,x
.018b65	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b68	68		pla				pla
.018b69	95 18		sta $18,x			sta 	zCodePtr+0,x
.018b6b	ca		dex				dex
.018b6c	10 f1		bpl $018b5f			bpl 	_RSWLoop
.018b6e	fa		plx				plx
.018b6f	60		rts				rts
.018b70					READGetDataItem:
.018b70	20 52 8b	jsr $018b52			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b73	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.018b75	05 19		ora $19				ora 	zCodePtr+1
.018b77	d0 12		bne $018b8b			bne 	_RGDIIsInitialised
.018b79	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018b7b	85 18		sta $18				sta 	zCodePtr+0
.018b7d	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.018b7f	85 19		sta $19				sta 	zCodePtr+1
.018b81	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.018b83	85 1a		sta $1a				sta 	zCodePtr+2
.018b85	85 1b		sta $1b				sta 	zCodePtr+3
.018b87	a0 03		ldy #$03			ldy 	#3
.018b89	80 06		bra $018b91			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b8b					_RGDIIsInitialised:
.018b8b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b8d	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b8f	f0 49		beq $018bda			beq 	_RGDISkipEvaluateExit
.018b91					_RGDIFindData:
.018b91	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b93	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b95	f0 19		beq $018bb0			beq 	_RGDIFindNextLine
.018b97	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b99	f0 3f		beq $018bda			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b9b	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018b9d	c8		iny				iny 								; skip
.018b9e	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018ba0	90 0c		bcc $018bae			bcc 	_SEDone 					; so just skip over it.
.018ba2	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018ba4	90 07		bcc $018bad			bcc 	_SEDouble
.018ba6	98		tya				tya 								; this is Y + 1
.018ba7	18		clc				clc
.018ba8	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018baa	a8		tay				tay 								; back in Y.
.018bab	88		dey				dey 								; fix up, one for the +1, one for the iny
.018bac	88		dey				dey
.018bad					_SEDouble:
.018bad	c8		iny				iny
.018bae					_SEDone:
.018bae	80 e1		bra $018b91			bra 	_RGDIFindData
.018bb0					_RGDIFindNextLine:
.018bb0	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018bb2	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018bb4	18		clc				clc
.018bb5	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018bb7	85 18		sta $18				sta 	zCodePtr
.018bb9	90 02		bcc $018bbd			bcc 	_SNLNoCarry
.018bbb	e6 19		inc $19				inc 	zCodePtr+1
.018bbd					_SNLNoCarry:
.018bbd	a0 00		ldy #$00			ldy 	#0
.018bbf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018bc1	48		pha				pha
.018bc2	c8		iny				iny
.018bc3	c8		iny				iny
.018bc4	c8		iny				iny
.018bc5	68		pla				pla
.018bc6	d0 c9		bne $018b91			bne 	_RGDIFindData 				; back to scanning.
.018bc8	20 52 8b	jsr $018b52			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018bcb	20 86 85	jsr $018586			jsr ERR_Handler
>018bce	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018bd6	61 74 61 00
.018bda					_RGDISkipEvaluateExit:
.018bda	c8		iny				iny
.018bdb	20 59 92	jsr $019259			jsr 	EvaluateExpression 			; evaluate the expression
.018bde	20 52 8b	jsr $018b52			jsr 	ReadSwapPointers 			; swap the pointers around.
.018be1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018be2					Command_LET:
.018be2	20 00 9d	jsr $019d00			jsr 	VariableFind 				; get reference to one variable.
.018be5	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018be7	20 24 9a	jsr $019a24			jsr 	CheckNextToken
.018bea	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018bec	48		pha				pha
.018bed	a5 25		lda $25				lda 	zVarDataPtr+1
.018bef	48		pha				pha
.018bf0	a5 26		lda $26				lda 	zVarType
.018bf2	48		pha				pha
.018bf3	20 59 92	jsr $019259			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018bf6	68		pla				pla 								; restore target variable information.
.018bf7	85 26		sta $26				sta 	zVarType
.018bf9	68		pla				pla
.018bfa	85 25		sta $25				sta 	zVarDataPtr+1
.018bfc	68		pla				pla
.018bfd	85 24		sta $24				sta 	zVarDataPtr
.018bff	20 99 a0	jsr $01a099			jsr 	VariableSet 				; set the value out.
.018c02	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018c03					Command_GET:
.018c03					_CGLoop:
.018c03	20 00 9d	jsr $019d00			jsr 	VariableFind 				; get a variable.
.018c06	20 42 85	jsr $018542			jsr 	VIOCharGet 					; get character
.018c09	b0 02		bcs $018c0d			bcs 	_CGNoKey
.018c0b	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018c0d					_CGNoKey:
.018c0d	48		pha				pha
.018c0e	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.018c10	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018c12	f0 1e		beq $018c32			beq 	_CGString
.018c14	68		pla				pla 								; put character in slot.
.018c15	85 80		sta $80				sta 	XS_Mantissa
.018c17	a9 00		lda #$00			lda 	#0
.018c19	85 81		sta $81				sta 	XS_Mantissa+1
.018c1b	85 82		sta $82				sta 	XS_Mantissa+2
.018c1d	85 83		sta $83				sta 	XS_Mantissa+3
.018c1f	a9 01		lda #$01			lda 	#1 							; type integer
.018c21	85 85		sta $85				sta 	XS_Type
.018c23					_CGWriteSetNext:
.018c23	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018c25	20 99 a0	jsr $01a099			jsr 	VariableSet
.018c28	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c2a	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018c2c	d0 03		bne $018c31			bne 	_CGExit
.018c2e	c8		iny				iny
.018c2f	80 d2		bra $018c03			bra 	_CGLoop 					; and get another.
.018c31					_CGExit:
.018c31	60		rts				rts
.018c32					_CGString:
.018c32	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018c34	20 88 9a	jsr $019a88			jsr 	AllocateTempString 			; initially empty.
.018c37	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.018c39	85 80		sta $80				sta 	XS_Mantissa
.018c3b	a5 23		lda $23				lda 	zTempStr+1
.018c3d	85 81		sta $81				sta 	XS_Mantissa+1
.018c3f	a9 02		lda #$02			lda 	#2
.018c41	85 85		sta $85				sta 	XS_Type
.018c43	68		pla				pla 								; get A
.018c44	c9 00		cmp #$00			cmp 	#0
.018c46	f0 db		beq $018c23			beq 	_CGWriteSetNext
.018c48	20 b3 9a	jsr $019ab3			jsr 	WriteTempString 			; write it into string
.018c4b	80 d6		bra $018c23			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018c4d					Command_SYS:
.018c4d	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; address to call.
.018c50	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c52	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c55	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c57	8d 11 03	sta $0311			sta 	LocalVector+1
.018c5a	a5 82		lda $82				lda 	XS_Mantissa+2
.018c5c	8d 12 03	sta $0312			sta 	LocalVector+2
.018c5f	22 64 8c 01	jsl $018c64			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c63	60		rts				rts
.018c64					_CSYLocalCall:
.018c64	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c67					Command_INPUT:
.018c67	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c69	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c6c	8d c3 03	sta $03c3		sta 	InputRetry
.018c6f					_CILoop:
.018c6f	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c71	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.018c73	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c75	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c77	d0 15		bne $018c8e		bne 	_CINoPrompt
.018c79	c8		iny				iny
.018c7a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c7c	aa		tax			tax 									; into X
.018c7d	c8		iny				iny
.018c7e	ca		dex			dex 									; deduct marker/prompt length
.018c7f	ca		dex			dex
.018c80	f0 ed		beq $018c6f		beq 	_CILoop 						; nothing.
.018c82					_CIShowPrompt:
.018c82	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c84	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018c87	c8		iny				iny
.018c88	ca		dex			dex
.018c89	d0 f7		bne $018c82		bne 	_CIShowPrompt
.018c8b	80 e2		bra $018c6f		bra 	_CILoop
.018c8d					_CIAdvance:
.018c8d	c8		iny				iny
.018c8e					_CINoPrompt:
.018c8e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c90	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c92	f0 f9		beq $018c8d		beq 	_CIAdvance
.018c94	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c96	f0 f5		beq $018c8d		beq 	_CIAdvance
.018c98	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c9a	f0 04		beq $018ca0		beq 	_CIExit
.018c9c	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c9e	d0 01		bne $018ca1		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018ca0					_CIExit:
.018ca0	60		rts			rts
.018ca1					_CIIsVariable:
.018ca1	20 00 9d	jsr $019d00		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018ca4	a5 26		lda $26			lda 	zVarType
.018ca6	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018ca8	f0 40		beq $018cea		beq 	_CIIsString
.018caa					_CINGetText:
.018caa	a9 00		lda #$00		lda 	#0
.018cac	8d 14 03	sta $0314		sta 	NumBufX
.018caf					_CINSkip:
.018caf	20 49 8d	jsr $018d49		jsr 	CIGetCharacter 					; get character skip spaces
.018cb2	c9 20		cmp #$20		cmp 	#" "
.018cb4	f0 f9		beq $018caf		beq 	_CINSkip
.018cb6	c9 2c		cmp #$2c		cmp 	#","
.018cb8	f0 f5		beq $018caf		beq 	_CINSkip
.018cba					_CINLoop:
.018cba	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018cbd	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018cc0	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018cc2	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018cc5	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018cc8	20 49 8d	jsr $018d49		jsr 	CIGetCharacter 					; get next character
.018ccb	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018ccd	f0 08		beq $018cd7		beq 	_CINCopied
.018ccf	c9 2c		cmp #$2c		cmp 	#","
.018cd1	f0 04		beq $018cd7		beq 	_CINCopied
.018cd3	c9 21		cmp #$21		cmp 	#" "+1
.018cd5	b0 e3		bcs $018cba		bcs 	_CINLoop
.018cd7					_CINCopied:
.018cd7	a2 00		ldx #$00		ldx 	#0
.018cd9	20 68 97	jsr $019768		jsr 	ConvertNumBuffer 				; convert number
.018cdc	b0 05		bcs $018ce3		bcs 	_CINFailed 						; didn't work.
.018cde	20 99 a0	jsr $01a099		jsr 	VariableSet 					; set variable.
.018ce1	80 8c		bra $018c6f		bra 	_CILoop 						; go round again.
.018ce3					_CINFailed:
.018ce3	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018ce5	8d c2 03	sta $03c2		sta 	InputAvailable
.018ce8	80 c0		bra $018caa		bra 	_CINGetText 					; and try again
.018cea					_CIIsString:
.018cea	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.018cec	20 88 9a	jsr $019a88		jsr 	AllocateTempString
.018cef	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.018cf1	8d 14 03	sta $0314		sta 	NumBufX
.018cf4					_CISSkip:
.018cf4	20 49 8d	jsr $018d49		jsr 	CIGetCharacter 					; get character skip spaces
.018cf7	c9 20		cmp #$20		cmp 	#" "
.018cf9	f0 f9		beq $018cf4		beq 	_CISSkip
.018cfb	80 03		bra $018d00		bra 	_CISInputProcess 				; handle that as the first character
.018cfd					_CISInput:
.018cfd	20 49 8d	jsr $018d49		jsr 	CIGetCharacter
.018d00					_CISInputProcess:
.018d00	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.018d02	f0 31		beq $018d35		beq 	_CISDone
.018d04	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.018d06	d0 05		bne $018d0d		bne 	_CISNotColon
.018d08	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.018d0b	10 28		bpl $018d35		bpl 	_CISDone 						; if quote flag zero, done
.018d0d					_CISNotColon:
.018d0d	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.018d0f	f0 1a		beq $018d2b		beq 	_CISIsQuote						; if so handle that code.
.018d11	20 b3 9a	jsr $019ab3		jsr 	WriteTempString 				; write to the temporary string
.018d14	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.018d17	10 e4		bpl $018cfd		bpl 	_CISInput
.018d19	20 86 85	jsr $018586			jsr ERR_Handler
>018d1c	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>018d24	6f 20 6c 6f 6e 67 00
.018d2b					_CISIsQuote:
.018d2b	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.018d2e	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.018d30	8d 14 03	sta $0314		sta 	NumBufX
.018d33	d0 c8		bne $018cfd		bne 	_CISInput 						; if entered quote mode, get next character
.018d35					_CISDone:
.018d35	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.018d37	85 80		sta $80			sta 	XS_Mantissa+0
.018d39	a5 23		lda $23			lda 	zTempStr+1
.018d3b	85 81		sta $81			sta 	XS_Mantissa+1
.018d3d	a9 02		lda #$02		lda 	#2
.018d3f	85 85		sta $85			sta 	XS_Type
.018d41	a2 00		ldx #$00		ldx 	#0
.018d43	20 99 a0	jsr $01a099		jsr 	VariableSet 					; set variable.
.018d46	4c 6f 8c	jmp $018c6f		jmp 	_CILoop 						; and try again
.018d49					CIGetCharacter:
.018d49	5a		phy			phy
.018d4a	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018d4d	f0 0c		beq $018d5b		beq 	_CIGCNewLine 					; no, needs a new line.
.018d4f	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018d52	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018d54	f0 03		beq $018d59		beq 	_CIGCNoInc
.018d56	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018d59					_CIGCNoInc:
.018d59	7a		ply			ply
.018d5a	60		rts			rts
.018d5b					_CIGCNewLine:
.018d5b	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018d5e	a9 3f		lda #$3f		lda 	#"?"
.018d60	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d63	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018d66	f0 03		beq $018d6b		beq 	_CIGCPrompt 					; if so, then print ? again
.018d68	20 3f 85	jsr $01853f		jsr 	VIOCharPrint
.018d6b					_CIGCPrompt:
.018d6b	a0 01		ldy #$01		ldy 	#1
.018d6d	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018d70					_CIGCBackOne:
.018d70	88		dey			dey
.018d71					_CIGCLoop:
.018d71	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018d73	f0 fb		beq $018d70		beq 	_CIGCBackOne
.018d75	20 42 85	jsr $018542		jsr 	VIOCharGet 						; get a character
.018d78	f0 f7		beq $018d71		beq 	_CIGCLoop 						; wait until key pressed
.018d7a	c9 08		cmp #$08		cmp 	#8 								; backspace
.018d7c	f0 10		beq $018d8e		beq 	_CIGCBackSpace
.018d7e	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo character
.018d81	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018d84	c8		iny			iny
.018d85	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018d87	d0 e8		bne $018d71		bne 	_CIGCLoop
.018d89	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018d8c	7a		ply			ply 									; restore Y
.018d8d	60		rts			rts
.018d8e					_CIGCBackSpace:
.018d8e	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018d90	f0 df		beq $018d71		beq 	_CIGCLoop
.018d92	20 3f 85	jsr $01853f		jsr 	VIOCharPrint 					; echo BS
.018d95	88		dey			dey 									; go back one.
.018d96	80 d9		bra $018d71		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018d98					Command_END:
>018d98	02						.byte 	2
.018d99	4c 52 88	jmp $018852			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018d9c					Command_IF:
.018d9c	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; check success.
.018d9f	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018da1	05 81		ora $81				ora 	XS_Mantissa+1
.018da3	05 82		ora $82				ora 	XS_Mantissa+2
.018da5	05 83		ora $83				ora 	XS_Mantissa+3
.018da7	aa		tax				tax 								; put into X.
.018da8	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018daa	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018dac	d0 2c		bne $018dda			bne 	_FIFExtended
.018dae	c8		iny				iny
.018daf	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018db1	f0 0b		beq $018dbe			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018db3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018db5	29 c0		and #$c0			and 	#$C0 						; is it a number
.018db7	c9 40		cmp #$40			cmp 	#$40
.018db9	d0 1e		bne $018dd9			bne 	_FIFContinue 				; if not, do what ever follows.
.018dbb	4c 29 91	jmp $019129			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018dbe					_FIFEndOfLine:
.018dbe	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dc0	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018dc2	f0 15		beq $018dd9			beq 	_FIFContinue
.018dc4	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018dc6	c8		iny				iny 								; skip
.018dc7	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018dc9	90 0c		bcc $018dd7			bcc 	_SEDone 					; so just skip over it.
.018dcb	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018dcd	90 07		bcc $018dd6			bcc 	_SEDouble
.018dcf	98		tya				tya 								; this is Y + 1
.018dd0	18		clc				clc
.018dd1	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018dd3	a8		tay				tay 								; back in Y.
.018dd4	88		dey				dey 								; fix up, one for the +1, one for the iny
.018dd5	88		dey				dey
.018dd6					_SEDouble:
.018dd6	c8		iny				iny
.018dd7					_SEDone:
.018dd7	80 e5		bra $018dbe			bra 	_FIFEndOfLine
.018dd9					_FIFContinue:
.018dd9	60		rts				rts
.018dda					_FIFExtended:
.018dda	da		phx				phx 								; save result
.018ddb	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018ddd	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.018de0	68		pla				pla 								; restore result
.018de1	f0 01		beq $018de4			beq 	_FIXSkip 					; if zero then it has failed.
.018de3	60		rts				rts 								; test passed, so continue executing
.018de4					_FIXSkip:
.018de4	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018de6	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018de8	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018deb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ded	c8		iny				iny
.018dee	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018df0	f0 07		beq $018df9			beq 	Command_ENDIF
.018df2	60		rts				rts
.018df3					Command_ELSE:
.018df3	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018df5	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018df8	c8		iny				iny
.018df9					Command_ENDIF:
.018df9	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018dfb	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.018dfe	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018dff					Command_LIST:
.018dff	20 8c 8f	jsr $018f8c			jsr 	ListGetRange				; get any parameters
.018e02	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.018e04	85 18		sta $18				sta 	zCodePtr+0
.018e06	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.018e08	85 19		sta $19				sta 	zCodePtr+1
.018e0a	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.018e0c	85 1a		sta $1a				sta 	zCodePtr+2
.018e0e	85 1b		sta $1b				sta 	zCodePtr+3
.018e10	a0 03		ldy #$03			ldy 	#3
.018e12	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018e14	8d bc 03	sta $03bc			sta 	LastListIndent
.018e17	8d bb 03	sta $03bb			sta 	ListIndent
.018e1a					_CILLoop:
.018e1a	a0 00		ldy #$00			ldy 	#0
.018e1c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e1e	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018e20	f0 23		beq $018e45			beq 	_CILExit
.018e22	20 4d 85	jsr $01854d			jsr 	VIOCheckBreak 				; check break
.018e25	c9 00		cmp #$00			cmp 	#0
.018e27	d0 1c		bne $018e45			bne 	_CILExit
.018e29	20 d3 8f	jsr $018fd3			jsr 	ListCheckRange 				; check current line in range.
.018e2c	b0 08		bcs $018e36			bcs		_CILNext
.018e2e	a0 00		ldy #$00			ldy 	#0
.018e30	c8		iny				iny
.018e31	c8		iny				iny
.018e32	c8		iny				iny
.018e33	20 48 8e	jsr $018e48			jsr 	ListLine 					; list one line.
.018e36					_CILNext:
.018e36	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018e38	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018e3a	18		clc				clc
.018e3b	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018e3d	85 18		sta $18				sta 	zCodePtr
.018e3f	90 02		bcc $018e43			bcc 	_SNLNoCarry
.018e41	e6 19		inc $19				inc 	zCodePtr+1
.018e43					_SNLNoCarry:
.018e43	80 d5		bra $018e1a			bra 	_CILLoop
.018e45					_CILExit:
.018e45	4c 52 88	jmp $018852			jmp 	WarmStart
.018e48					ListLine:
.018e48	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018e4b	8d bc 03	sta $03bc			sta 	LastListIndent
.018e4e					_LICountIndent:
.018e4e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e50	c9 00		cmp #$00			cmp 	#0
.018e52	f0 2f		beq $018e83			beq 	_LIDoneIndent
.018e54	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018e56	90 16		bcc $018e6e			bcc 	_LICINext
.018e58	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e5a	b0 12		bcs $018e6e			bcs 	_LICINext
.018e5c	ee bb 03	inc $03bb			inc 	ListIndent
.018e5f	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018e61	90 0b		bcc $018e6e			bcc 	_LICINext
.018e63	ce bb 03	dec $03bb			dec 	ListIndent
.018e66	ce bb 03	dec $03bb			dec 	ListIndent
.018e69	10 03		bpl $018e6e			bpl 	_LICINext
.018e6b	ee bb 03	inc $03bb			inc 	ListIndent
.018e6e					_LICINext:
.018e6e	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018e70	c8		iny				iny 								; skip
.018e71	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018e73	90 0c		bcc $018e81			bcc 	_SEDone 					; so just skip over it.
.018e75	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018e77	90 07		bcc $018e80			bcc 	_SEDouble
.018e79	98		tya				tya 								; this is Y + 1
.018e7a	18		clc				clc
.018e7b	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018e7d	a8		tay				tay 								; back in Y.
.018e7e	88		dey				dey 								; fix up, one for the +1, one for the iny
.018e7f	88		dey				dey
.018e80					_SEDouble:
.018e80	c8		iny				iny
.018e81					_SEDone:
.018e81	80 cb		bra $018e4e			bra 	_LICountIndent
.018e83					_LIDoneIndent:
.018e83	a0 00		ldy #$00			ldy 	#0
.018e85	c8		iny				iny
.018e86	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e88	85 80		sta $80				sta 	XS_Mantissa
.018e8a	c8		iny				iny
.018e8b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e8d	85 81		sta $81				sta 	XS_Mantissa+1
.018e8f	20 d1 85	jsr $0185d1			jsr 	Print16BitInteger 			; print integer.
.018e92	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018e94	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018e97	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018e9a	90 03		bcc $018e9f			bcc 	_LISmaller
.018e9c	ad bc 03	lda $03bc			lda 	LastListIndent
.018e9f					_LISmaller:
.018e9f	0a		asl a				asl 	a 							; double indent
.018ea0	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018ea2	38		sec				sec
.018ea3	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018ea5	aa		tax				tax 								; print spaces to column 6
.018ea6					_LISpace:
.018ea6	a9 20		lda #$20			lda 	#" "
.018ea8	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018eab	e8		inx				inx
.018eac	e0 06		cpx #$06			cpx 	#6
.018eae	d0 f6		bne $018ea6			bne 	_LISpace
.018eb0					_LIDecode:
.018eb0	c8		iny				iny
.018eb1	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018eb3	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018eb5	f0 0f		beq $018ec6			beq 	_LIExit
.018eb7	30 12		bmi $018ecb			bmi 	_LIToken
.018eb9	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018ebb	b0 50		bcs $018f0d			bcs 	_LIInteger
.018ebd	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018ebf	69 20		adc #$20			adc 	#$20
.018ec1	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC 				; print in LC
.018ec4	80 ea		bra $018eb0			bra 	_LIDecode
.018ec6					_LIExit:
.018ec6	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018ec8	4c 7c 8f	jmp $018f7c			jmp 	ListPrintLC
.018ecb					_LIToken:
.018ecb	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018ecd	90 49		bcc $018f18			bcc		_LICommandToken
.018ecf	48		pha				pha 								; save in case end
.018ed0	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018ed2	c9 fe		cmp #$fe			cmp 	#$FE
.018ed4	f0 17		beq $018eed			beq 	_LIPrint
.018ed6	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018ed8	c9 fd		cmp #$fd			cmp 	#$FD
.018eda	f0 11		beq $018eed			beq 	_LIPrint
.018edc	a9 52		lda #$52			lda 	#'R'						; must be REM
.018ede	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018ee1	a9 45		lda #$45			lda 	#'E'
.018ee3	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018ee6	a9 4d		lda #$4d			lda 	#'M'
.018ee8	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018eeb	a2 20		ldx #$20			ldx 	#' '
.018eed					_LIPrint:
.018eed	8a		txa				txa
.018eee	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018ef1	c8		iny				iny
.018ef2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ef4	aa		tax				tax 								; put in X
.018ef5	ca		dex				dex
.018ef6					_LILoop:
.018ef6	ca		dex				dex 								; exit when count reached zero.
.018ef7	f0 08		beq $018f01			beq 	_LIEnd
.018ef9	c8		iny				iny
.018efa	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018efc	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018eff	80 f5		bra $018ef6			bra 	_LILoop
.018f01	68		pla		_LIEnd:	pla 								; get A back
.018f02	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018f04	d0 aa		bne $018eb0			bne 	_LIDecode
.018f06	a9 22		lda #$22			lda 	#'"'
.018f08	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018f0b	80 a3		bra $018eb0			bra 	_LIDecode
.018f0d					_LIInteger:
.018f0d	a2 00		ldx #$00			ldx 	#0
.018f0f	20 61 93	jsr $019361			jsr 	EvaluateGetInteger 			; get an atom
.018f12	88		dey				dey
.018f13	20 d7 85	jsr $0185d7			jsr 	Print32BitInteger 			; print integer.
.018f16	80 98		bra $018eb0			bra 	_LIDecode
.018f18					_LICommandToken:
.018f18	5a		phy				phy 								; save Y
.018f19	48		pha				pha 								; save token
.018f1a	a2 cf		ldx #$cf			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018f1c	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018f1e	86 1c		stx $1c				stx 	zLTemp1
.018f20	85 1d		sta $1d				sta 	zLTemp1+1
.018f22	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018f24	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018f26	68		pla				pla 								; get token
.018f27	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018f29	f0 16		beq $018f41			beq 	_LIFoundToken
.018f2b	aa		tax				tax
.018f2c					_LITokenLoop:
.018f2c	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018f2e					_LIFindEnd:
.018f2e	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f30	c8		iny				iny
.018f31	0a		asl a				asl 	a
.018f32	90 fa		bcc $018f2e			bcc 	_LIFindEnd
.018f34	98		tya				tya 								; that is step to the next
.018f35	18		clc				clc 								; we don't bother bumping the 3rd byte
.018f36	65 1c		adc $1c				adc 	zLTemp1 					; here.
.018f38	85 1c		sta $1c				sta 	zLTemp1
.018f3a	90 02		bcc $018f3e			bcc 	_LINoBump
.018f3c	e6 1d		inc $1d				inc 	zLTemp1+1
.018f3e					_LINoBump:
.018f3e	ca		dex				dex 								; no go round again.
.018f3f	d0 eb		bne $018f2c			bne 	_LITokenLoop
.018f41					_LIFoundToken:
.018f41	a0 00		ldy #$00			ldy 	#0
.018f43					_LIPrintToken:
.018f43	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018f45	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018f47	d0 16		bne $018f5f			bne 	_LINoPrefixSpace
.018f49	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018f4b	90 12		bcc $018f5f			bcc 	_LINoPrefixSpace
.018f4d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f4f	b0 0e		bcs $018f5f			bcs 	_LINoPrefixSpace
.018f51	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018f54	e0 20		cpx #$20			cpx 	#" "
.018f56	f0 07		beq $018f5f			beq 	_LINoPrefixSpace
.018f58	48		pha				pha
.018f59	a9 20		lda #$20			lda 	#" "
.018f5b	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018f5e	68		pla				pla
.018f5f					_LINoPrefixSpace:
.018f5f	c8		iny				iny
.018f60	48		pha				pha 								; save it
.018f61	29 7f		and #$7f			and 	#$7F
.018f63	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018f66	68		pla				pla
.018f67	10 da		bpl $018f43			bpl 	_LIPrintToken 				; go back if not end
.018f69	7a		ply				ply 								; restore Y
.018f6a	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018f6c	c9 41		cmp #$41			cmp 	#"A"
.018f6e	90 09		bcc $018f79			bcc 	_LINotLetter2
.018f70	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f72	b0 05		bcs $018f79			bcs 	_LINotLetter2
.018f74	a9 20		lda #$20			lda 	#" " 						; add spacing
.018f76	20 7c 8f	jsr $018f7c			jsr 	ListPrintLC
.018f79					_LINotLetter2:
.018f79	4c b0 8e	jmp $018eb0			jmp 	_LIDecode
.018f7c					ListPrintLC:
.018f7c	8d ba 03	sta $03ba			sta 	LastPrinted
.018f7f	c9 41		cmp #$41			cmp 	#"A"
.018f81	90 06		bcc $018f89			bcc 	_LPLC0
.018f83	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f85	b0 02		bcs $018f89			bcs 	_LPLC0
.018f87	69 20		adc #$20			adc 	#$20
.018f89	4c 3f 85	jmp $01853f	_LPLC0:	jmp 	VIOCharPrint
.018f8c					ListGetRange:
.018f8c	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018f8e					_LGRClear:
.018f8e	a9 00		lda #$00			lda 	#0
.018f90	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f92	ca		dex				dex
.018f93	10 f9		bpl $018f8e			bpl 	_LGRClear
.018f95	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f97	c9 00		cmp #$00			cmp 	#0 							; nothing
.018f99	f0 21		beq $018fbc			beq 	_LGRBlank
.018f9b	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018f9d	f0 1d		beq $018fbc			beq 	_LGRBlank
.018f9f	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018fa1	f0 18		beq $018fbb			beq 	_LGREnd 					; then it's LIST ,x
.018fa3	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; get the first number into bottom
.018fa6	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fa8	c9 bf		cmp #$bf			cmp 	#token_Comma
.018faa	f0 0f		beq $018fbb			beq 	_LGREnd 					; then it is LIST a,b
.018fac	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018fae	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018fb0	a5 81		lda $81				lda 	XS_Mantissa+1
.018fb2	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fb4					_LGRBumpExit:
.018fb4	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018fb6	d0 02		bne $018fba			bne 	_LGRBump2
.018fb8	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018fba					_LGRBump2:
.018fba	60		rts				rts
.018fbb					_LGREnd:
.018fbb	c8		iny				iny
.018fbc					_LGRBlank:
.018fbc	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018fbe	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018fc0	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018fc2	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fc4	c9 00		cmp #$00			cmp 	#0
.018fc6	f0 f2		beq $018fba			beq 	_LGRBump2
.018fc8	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018fc9	b0 ef		bcs $018fba			bcs 	_LGRBump2
.018fcb	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018fcd	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX
.018fd0	80 e2		bra $018fb4			bra 	_LGRBumpExit
.018fd2	60		rts				rts
.018fd3					ListCheckRange:
.018fd3	c8		iny				iny
.018fd4	a2 00		ldx #$00			ldx 	#0 							; test low
.018fd6	20 e3 8f	jsr $018fe3			jsr 	_LCRCompare
.018fd9	90 06		bcc $018fe1			bcc 	_LCRFail
.018fdb	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018fdd	20 e3 8f	jsr $018fe3			jsr 	_LCRCompare
.018fe0	60		rts				rts
.018fe1					_LCRFail:
.018fe1	38		sec				sec
.018fe2	60		rts				rts
.018fe3					_LCRCompare:
.018fe3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fe5	38		sec				sec
.018fe6	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018fe8	08		php				php
.018fe9	c8		iny				iny
.018fea	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fec	28		plp				plp
.018fed	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018fef	08		php				php
.018ff0	88		dey				dey
.018ff1	28		plp				plp
.018ff2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018ff3					Command_PRINT:
.018ff3					_CPR_Loop:
.018ff3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ff5	c9 00		cmp #$00			cmp 	#0 							; end
.018ff7	f0 25		beq $01901e			beq 	_CPR_GoNewLine
.018ff9	c9 c0		cmp #$c0			cmp 	#token_Colon
.018ffb	f0 21		beq $01901e			beq 	_CPR_GoNewLine
.018ffd	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018fff	f0 75		beq $019076			beq 	_CPR_Skip
.019001	c9 bf		cmp #$bf			cmp 	#token_Comma
.019003	f0 58		beq $01905d			beq 	_CPR_Tab
.019005	20 59 92	jsr $019259			jsr 	EvaluateExpression 			; get expression.
.019008	a5 85		lda $85				lda 	XS_Type 					; get type.
.01900a	29 02		and #$02			and 	#2
.01900c	d0 28		bne $019036			bne 	_CPR_String 				; if type = 2 output as string.
.01900e					_CPR_Number:
.01900e	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019010	8d 14 03	sta $0314			sta 	NumBufX
.019013	aa		tax				tax
.019014	a5 85		lda $85				lda 	XS_Type 					; get type
.019016	4a		lsr a				lsr 	a
.019017	b0 08		bcs $019021			bcs 	_CPRInt 					; if msb set do as integer
.019019	20 4c a7	jsr $01a74c			jsr 	FPToString 					; do the floa
.01901c	80 06		bra $019024			bra 	_CPRNPrint
.01901e					_CPR_GoNewLine:
.01901e	4c 84 90	jmp $019084			jmp 	_CPR_NewLine
.019021					_CPRInt:
.019021	20 e2 a1	jsr $01a1e2			jsr 	IntToString
.019024					_CPRNPrint:
.019024	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.019027	c9 2d		cmp #$2d			cmp 	#"-"
.019029	f0 05		beq $019030			beq 	_CPRNoSpace
.01902b	a9 20		lda #$20			lda 	#" "						; print the leading space
.01902d	20 3f 85	jsr $01853f			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.019030					_CPRNoSpace:
.019030	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.019032	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.019034	80 04		bra $01903a			bra 	_CPRPrint
.019036					_CPR_String:
.019036	a6 80		ldx $80				ldx 	XS_Mantissa
.019038	a5 81		lda $81				lda 	XS_Mantissa+1
.01903a					_CPRPrint:
.01903a	86 20		stx $20				stx 	zGenPtr
.01903c	85 21		sta $21				sta 	zGenPtr+1
.01903e	5a		phy				phy
.01903f	a0 00		ldy #$00			ldy 	#0							; get length into X
.019041	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019043	aa		tax				tax
.019044	f0 09		beq $01904f			beq 	_CPREndPrint 				; nothing to print
.019046					_CPRLoop:
.019046	c8		iny				iny
.019047	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019049	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01904c	ca		dex				dex
.01904d	d0 f7		bne $019046			bne 	_CPRLoop
.01904f					_CPREndPrint:
.01904f	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.019051	29 02		and #$02			and 	#2
.019053	d0 05		bne $01905a			bne 	_CPRNoTrail
.019055	a9 20		lda #$20			lda 	#" "
.019057	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01905a					_CPRNoTrail:
.01905a	7a		ply				ply
.01905b	80 96		bra $018ff3			bra 	_CPR_Loop
.01905d					_CPR_Tab:
.01905d	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.019060					_CPR_CalcSpaces:
.019060	38		sec				sec 								; calculate position mod 10.
.019061	e9 0a		sbc #$0a			sbc 	#10
.019063	b0 fb		bcs $019060			bcs 	_CPR_CalcSpaces
.019065	69 0a		adc #$0a			adc 	#10
.019067	f0 0d		beq $019076			beq 	_CPR_Skip 					; nothing to print
.019069	aa		tax				tax 								; print out spaces to mod 10
.01906a					_CPRTabSpaces:
.01906a	a9 20		lda #$20			lda 	#" "
.01906c	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.01906f	e8		inx				inx
.019070	e0 0a		cpx #$0a			cpx 	#10
.019072	d0 f6		bne $01906a			bne 	_CPRTabSpaces
.019074	80 e7		bra $01905d			bra 	_CPR_Tab
.019076					_CPR_Skip:
.019076	c8		iny				iny
.019077	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019079	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01907b	f0 0c		beq $019089			beq 	_CPR_Exit
.01907d	c9 00		cmp #$00			cmp 	#0
.01907f	f0 08		beq $019089			beq 	_CPR_Exit 					; if not go round again.
.019081	4c f3 8f	jmp $018ff3			jmp 	_CPR_Loop
.019084					_CPR_NewLine:
.019084	a9 0d		lda #$0d			lda 	#13
.019086	20 3f 85	jsr $01853f			jsr 	VIOCharPrint
.019089					_CPR_Exit:
.019089	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.01908a					Command_ASSERT:
.01908a	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.01908d	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.01908f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019091	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019093	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019095	f0 01		beq $019098			beq 	_ASFail
.019097	60		rts				rts
.019098					_ASFail:
.019098	20 86 85	jsr $018586			jsr ERR_Handler
>01909b	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.0190a2					Command_POKE:
.0190a2	a9 01		lda #$01			lda 	#1 							; 1 byte
.0190a4	80 06		bra $0190ac			bra 	CmdPoke_Main
.0190a6					Command_DOKE:
.0190a6	a9 02		lda #$02			lda 	#2 							; 2 bytes
.0190a8	80 02		bra $0190ac			bra 	CmdPoke_Main
.0190aa					Command_LOKE:
.0190aa	a9 04		lda #$04			lda 	#4							; 4 bytes
.0190ac					CmdPoke_Main:
.0190ac	48		pha				pha
.0190ad	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; get two parameters. First is address
.0190b0	e8		inx				inx
.0190b1	e8		inx				inx
.0190b2	e8		inx				inx
.0190b3	e8		inx				inx
.0190b4	e8		inx				inx
.0190b5	e8		inx				inx
.0190b6	20 43 9a	jsr $019a43			jsr 	CheckNextComma
.0190b9	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX 			; second is the data.
.0190bc	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.0190be	85 1c		sta $1c				sta 	zLTemp1
.0190c0	a5 81		lda $81				lda 	XS_Mantissa+1
.0190c2	85 1d		sta $1d				sta 	zLTemp1+1
.0190c4	a5 82		lda $82				lda 	XS_Mantissa+2
.0190c6	85 1e		sta $1e				sta 	zLTemp1+2
.0190c8	a5 83		lda $83				lda 	XS_Mantissa+3
.0190ca	85 1f		sta $1f				sta 	zLTemp1+3
.0190cc	68		pla				pla 								; get count
.0190cd	5a		phy				phy 								; save Y
.0190ce	20 ce 99	jsr $0199ce			jsr 	MemWrite 					; write it out
.0190d1	7a		ply				ply 								; restore Y and done.
.0190d2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.0190d3					Command_NEW:
.0190d3	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190d5	85 18		sta $18				sta 	zCodePtr+0
.0190d7	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0190d9	85 19		sta $19				sta 	zCodePtr+1
.0190db	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0190dd	85 1a		sta $1a				sta 	zCodePtr+2
.0190df	85 1b		sta $1b				sta 	zCodePtr+3
.0190e1	a0 03		ldy #$03			ldy 	#3
.0190e3	a0 00		ldy #$00			ldy 	#0
.0190e5	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.0190e7	97 18		sta [$18],y			sta 	[zCodePtr],y
.0190e9	20 df 99	jsr $0199df			jsr 	UpdateProgramEnd 			; update program end.
.0190ec	4c 52 88	jmp $018852			jmp 	WarmStart 					; and always warmstart, can't be running program.
.0190ef					Command_OLD:
.0190ef	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0190f1	85 18		sta $18				sta 	zCodePtr+0
.0190f3	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0190f5	85 19		sta $19				sta 	zCodePtr+1
.0190f7	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0190f9	85 1a		sta $1a				sta 	zCodePtr+2
.0190fb	85 1b		sta $1b				sta 	zCodePtr+3
.0190fd	a0 03		ldy #$03			ldy 	#3
.0190ff					_COL_Find:
.0190ff	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019101	c8		iny				iny
.019102	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.019104	f0 18		beq $01911e			beq 	_COL_Found
.019106	98		tya				tya
.019107	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.019109	d0 f4		bne $0190ff			bne 	_COL_Find 					; can't find old EOL, give up.
.01910b	20 86 85	jsr $018586			jsr ERR_Handler
>01910e	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>019116	43 6f 72 72 75 70 74 00
.01911e					_COL_Found:
.01911e	98		tya				tya
.01911f	48		pha				pha
.019120	a0 00		ldy #$00			ldy 	#0
.019122	68		pla				pla
.019123	97 18		sta [$18],y			sta 	[zCodePtr],y
.019125	20 df 99	jsr $0199df			jsr 	UpdateProgramEnd 			; reset variable pointer
.019128	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.019129					Command_GOTO:
.019129	20 7e 91	jsr $01917e			jsr 	GotoGetLineNumber 			; get line number
.01912c					CmdGOTO:
.01912c	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.01912e	4c 9b 91	jmp $01919b			jmp 	GotoChangeToLineNumberX
.019131					Command_GOSUB:
.019131	20 7e 91	jsr $01917e			jsr 	GotoGetLineNumber 			; get line number
.019134					CmdGOSUB:
.019134	20 06 85	jsr $018506			jsr 	StackSavePosition 			; save position on stack and push frame
.019137	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.019139	20 bf 84	jsr $0184bf			jsr 	StackPushFrame
.01913c	a2 00		ldx #$00			ldx		#0 							; go to that line number
.01913e	4c 9b 91	jmp $01919b			jmp 	GotoChangeToLineNumberX
.019141					Command_RETURN:
.019141	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.019143	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019146	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; restore position.
.019149	60		rts				rts
.01914a					Command_ON:
.01914a	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.01914c	20 91 98	jsr $019891			jsr 	SLIByteParameter
.01914f	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019151	f0 28		beq $01917b			beq 	_CONFail 					; can't be zero, error if it is.
.019153	aa		tax				tax 								; save in X.
.019154	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019156	c8		iny				iny
.019157	48		pha				pha 								; so we can check what we're doing later.
.019158	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01915a	f0 07		beq $019163			beq 	_CONOkayToken
.01915c	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.01915e	f0 03		beq $019163			beq 	_CONOkayToken
.019160	4c 57 85	jmp $018557			jmp 	SyntaxError
.019163					_CONOkayToken:
.019163	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019164					_CONFindNumber:
.019164	20 7e 91	jsr $01917e			jsr 	GotoGetLineNumber 			; get a line number.
.019167	fa		plx				plx 								; restore count
.019168	ca		dex				dex  								; decrement, exit if zero.
.019169	f0 06		beq $019171			beq 	_CONFound
.01916b	da		phx				phx 								; push back
.01916c	20 43 9a	jsr $019a43			jsr 	CheckNextComma				; check for comma
.01916f	80 f3		bra $019164			bra 	_CONFindNumber 				; go round again.
.019171					_CONFound:
.019171	68		pla				pla 								; get token to decide what to do
.019172	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019174	f0 b6		beq $01912c			beq		CmdGOTO 					; then just branch.
.019176	20 8d 84	jsr $01848d			jsr 	SkipEndOfCommand 			; go to end of command
.019179	80 b9		bra $019134			bra 	CmdGOSUB 					; and do a GOSUB.
.01917b					_CONFail:
.01917b	4c 75 85	jmp $018575			jmp 	BadParamError
.01917e					GotoGetLineNumber:
.01917e	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; get integer into mantissa.0
.019181	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019183	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.019185	d0 01		bne $019188			bne 	_GLINError
.019187	60		rts				rts
.019188					_GLINError:
.019188	20 86 85	jsr $018586			jsr ERR_Handler
>01918b	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019193	20 4e 75 6d 62 65 72 00
.01919b					GotoChangeToLineNumberX:
.01919b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.01919d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01919f	f0 37		beq $0191d8			beq 	_GCTLFail 					; if so, no can do.
.0191a1	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0191a3	85 18		sta $18				sta 	zCodePtr+0
.0191a5	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0191a7	85 19		sta $19				sta 	zCodePtr+1
.0191a9	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0191ab	85 1a		sta $1a				sta 	zCodePtr+2
.0191ad	85 1b		sta $1b				sta 	zCodePtr+3
.0191af	a0 03		ldy #$03			ldy 	#3
.0191b1					_GCTLLoop:
.0191b1	a0 00		ldy #$00			ldy 	#0
.0191b3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191b5	c9 00		cmp #$00			cmp 	#0
.0191b7	f0 1f		beq $0191d8			beq 	_GCTLFail
.0191b9	c8		iny				iny
.0191ba	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191bc	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.0191be	d0 07		bne $0191c7			bne 	_GCTLNext
.0191c0	c8		iny				iny
.0191c1	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0191c3	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.0191c5	f0 0f		beq $0191d6			beq 	_GCTLExit
.0191c7					_GCTLNext:
.0191c7	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0191c9	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0191cb	18		clc				clc
.0191cc	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0191ce	85 18		sta $18				sta 	zCodePtr
.0191d0	90 02		bcc $0191d4			bcc 	_SNLNoCarry
.0191d2	e6 19		inc $19				inc 	zCodePtr+1
.0191d4					_SNLNoCarry:
.0191d4	80 db		bra $0191b1			bra 	_GCTLLoop 					; try next line.
.0191d6					_GCTLExit:
.0191d6	c8		iny				iny
.0191d7	60		rts				rts
.0191d8					_GCTLFail:
.0191d8	20 86 85	jsr $018586			jsr ERR_Handler
>0191db	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>0191e3	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.0191eb					Command_CLR:
.0191eb					ResetRunStatus:
.0191eb	20 3c 9d	jsr $019d3c			jsr 	VariableClear
.0191ee	20 ad 84	jsr $0184ad			jsr 	StackReset
.0191f1	a9 00		lda #$00			lda 	#HighMemory & $FF
.0191f3	8d 00 03	sta $0300			sta 	StringPtr
.0191f6	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0191f8	8d 01 03	sta $0301			sta 	StringPtr+1
.0191fb	20 06 9f	jsr $019f06			jsr 	ArrayResetDefault
.0191fe	20 47 8b	jsr $018b47			jsr 	Command_RESTORE
.019201	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.019202					Command_STOP:
.019202	20 86 85	jsr $018586			jsr ERR_Handler
>019205	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.01920a					Command_WHILE:
.01920a	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.01920d	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 			; calculate the while loop value.
.019210	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.019212	05 81		ora $81				ora 	XS_Mantissa+1
.019214	05 82		ora $82				ora 	XS_Mantissa+2
.019216	05 83		ora $83				ora 	XS_Mantissa+3
.019218	f0 06		beq $019220			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.01921a	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.01921c	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.01921f	60		rts				rts
.019220					_CWHSkip:
.019220	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.019222	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.019225	c8		iny				iny
.019226	60		rts				rts
.019227					Command_WEND:
.019227	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.019229	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.01922c	20 23 85	jsr $018523			jsr 	StackRestorePosition
.01922f	80 d9		bra $01920a			bra 	Command_WHILE 				; and do the while again.
.019231	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.019232					Command_REPEAT:
.019232	20 06 85	jsr $018506			jsr 	StackSavePosition			; save position into stack
.019235	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019237	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; push on stack
.01923a	60		rts				rts
.01923b					Command_UNTIL:
.01923b	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.01923d	20 d6 84	jsr $0184d6			jsr 	StackPopFrame
.019240	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger				; work out the UNTIL expression.
.019243	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.019245	05 81		ora $81				ora 	XS_Mantissa+1
.019247	05 82		ora $82				ora 	XS_Mantissa+2
.019249	05 83		ora $83				ora 	XS_Mantissa+3
.01924b	d0 08		bne $019255			bne 	_CUTExit 					; if not, just exit
.01924d	20 23 85	jsr $018523			jsr 	StackRestorePosition 		; otherwise loop round again.
.019250	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019252	20 bf 84	jsr $0184bf			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.019255					_CUTExit:
.019255	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.019256					EVESyntax:
.019256	4c 57 85	jmp $018557			jmp 	SyntaxError
.019259					EvaluateExpression:
.019259	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01925b					EvaluateExpressionX:
.01925b	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01925d					EvaluateExpressionXA:
.01925d	48		pha				pha 								; save precedence on stack.
.01925e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019260	f0 f4		beq $019256			beq 	EVESyntax 					; end of line, syntax error.
.019262	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019264	b0 03		bcs $019269			bcs 	_EVNotVariable
.019266	4c 33 93	jmp $019333			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.019269					_EVNotVariable:
.019269	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01926b	90 e9		bcc $019256			bcc 	EVESyntax
.01926d	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.01926f	b0 58		bcs $0192c9			bcs 	_EVNotInteger
.019271	20 61 93	jsr $019361			jsr 	EvaluateGetInteger
.019274					_EVCheckDecimal:
.019274	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019276	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.019278	d0 05		bne $01927f			bne 	_EVGotAtom 					; no, get atom.
.01927a					_EVIsDecimal:
.01927a	20 87 93	jsr $019387			jsr 	EVGetDecimal 				; extend to the decimal part.
.01927d	80 00		bra $01927f			bra 	_EVGotAtom 					; and continue to got atom.
.01927f					_EVGotAtom:
.01927f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019281	10 44		bpl $0192c7			bpl 	_EVExitDrop 				; must be a token.
.019283	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019285	b0 40		bcs $0192c7			bcs 	_EVExitDrop
.019287	68		pla				pla 								; get current precedence
.019288	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.01928a	da		phx				phx 								; save X
.01928b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01928d	aa		tax				tax 								; put in X
.01928e	bf 40 86 01	lda $018640,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019292	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.019294	fa		plx				plx 								; restore X
.019295	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.019297	90 2f		bcc $0192c8			bcc 	_EVExit 					; exit if too low.
.019299	f0 2d		beq $0192c8			beq 	_EVExit 					; exit if equals
.01929b	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.01929d	48		pha				pha
.01929e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192a0	48		pha				pha
.0192a1	c8		iny				iny
.0192a2	da		phx				phx 								; save current position
.0192a3	e8		inx				inx
.0192a4	e8		inx				inx
.0192a5	e8		inx				inx
.0192a6	e8		inx				inx
.0192a7	e8		inx				inx
.0192a8	e8		inx				inx
.0192a9	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.0192ab	20 5d 92	jsr $01925d			jsr 	EvaluateExpressionXA 		; do the RHS.
.0192ae	fa		plx				plx 								; restore X
.0192af	68		pla				pla 								; get the binary operator in A.
.0192b0					_EVCallA:
.0192b0	da		phx				phx 								; save X again
.0192b1	0a		asl a				asl 	a 							; double, lose the MSB.
.0192b2	aa		tax				tax									; put in X
.0192b3	bf ef 85 01	lda $0185ef,x			lda 	VectorTable,x 				; copy address into zGenPtr
.0192b7	8d 11 03	sta $0311			sta 	LocalVector+1
.0192ba	bf f0 85 01	lda $0185f0,x			lda 	VectorTable+1,x
.0192be	8d 12 03	sta $0312			sta 	LocalVector+2
.0192c1	fa		plx				plx 								; restore X
.0192c2	20 3c 93	jsr $01933c			jsr 	EVCallLocalVector
.0192c5	80 b8		bra $01927f			bra 	_EVGotAtom 					; and loop back.
.0192c7					_EVExitDrop:
.0192c7	68		pla				pla
.0192c8					_EVExit:
.0192c8	60		rts				rts
.0192c9					_EVNotInteger:
.0192c9	c8		iny				iny
.0192ca	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.0192cc	d0 16		bne $0192e4			bne 	_EVNotMinus
.0192ce	20 d0 93	jsr $0193d0			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.0192d1	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0192d3	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0192d5	f0 05		beq $0192dc			beq 	_EVMinusFloat
.0192d7	20 c5 a1	jsr $01a1c5			jsr 	IntegerNegateAlways 		; negation
.0192da	80 a3		bra $01927f			bra 	_EVGotAtom 					; and go back.
.0192dc					_EVMinusFloat:
.0192dc	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.0192de	49 80		eor #$80			eor 	#$80
.0192e0	95 85		sta $85,x			sta 	XS_Type,x
.0192e2	80 9b		bra $01927f			bra 	_EVGotAtom
.0192e4					_EVNotMinus:
.0192e4	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.0192e6	d0 17		bne $0192ff			bne 	_EVNotParenthesis
.0192e8	20 5b 92	jsr $01925b			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.0192eb	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0192ed	c8		iny				iny
.0192ee	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0192f0	f0 8d		beq $01927f			beq 	_EVGotAtom
.0192f2	20 86 85	jsr $018586			jsr ERR_Handler
>0192f5	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0192fd	29 00
.0192ff					_EVNotParenthesis:
.0192ff	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.019301	d0 0c		bne $01930f			bne 	_EVNotNot
.019303	20 d0 93	jsr $0193d0			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.019306	20 4d a6	jsr $01a64d			jsr 	FPUToInteger 				; make it an integer - if possible.
.019309	20 b5 93	jsr $0193b5			jsr 	NotInteger 					; do the not calculation
.01930c	4c 7f 92	jmp $01927f			jmp 	_EVGotAtom
.01930f					_EVNotNot:
.01930f	c9 fe		cmp #$fe			cmp 	#$FE
.019311	d0 12		bne $019325			bne 	_EVNotString
.019313	20 c3 9a	jsr $019ac3			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.019316	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.019318	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01931a	a5 23		lda $23				lda 	zTempStr+1
.01931c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01931e	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.019320	95 85		sta $85,x			sta 	XS_Type,x
.019322	4c 7f 92	jmp $01927f			jmp 	_EVGotAtom
.019325					_EVNotString:
.019325	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.019327	90 04		bcc $01932d			bcc 	_EVBadElement
.019329	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.01932b	90 03		bcc $019330			bcc 	_EVUnaryFunction
.01932d					_EVBadElement:
.01932d	4c 57 85	jmp $018557			jmp 	SyntaxError
.019330					_EVUnaryFunction:
.019330	4c b0 92	jmp $0192b0			jmp 	_EVCallA
.019333					_EVVariableHandler:
.019333	20 00 9d	jsr $019d00			jsr 	VariableFind 				; locate a variable
.019336	20 48 a0	jsr $01a048			jsr 	VariableGet 				; copy into memory.
.019339	4c 7f 92	jmp $01927f			jmp 	_EVGotAtom 					; and go round.
.01933c					EVCallLocalVector:
.01933c	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.01933f					EVShiftMantissaLeft6:
.01933f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.019341	95 84		sta $84,x			sta 	XS_Exponent,x
.019343	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019345	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019347	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019349	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01934b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01934d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01934f	a9 00		lda #$00			lda 	#0
.019351	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019353	20 56 93	jsr $019356			jsr 	_EVSMLShift 					; call it here to do it twice
.019356					_EVSMLShift:
.019356	56 84		lsr $84,x			lsr 	XS_Exponent,x
.019358	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01935a	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.01935c	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.01935e	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019360	60		rts				rts
.019361					EvaluateGetInteger:
.019361	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019363	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019365	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019367	a9 00		lda #$00			lda 	#0
.019369	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01936b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01936d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01936f	1a		inc a				inc 	a 							; set to type 1 (integer)
.019370	95 85		sta $85,x			sta 	XS_Type,x
.019372					_EVCheckNextInteger:
.019372	c8		iny				iny
.019373	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019375	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.019377	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.019379	b0 0b		bcs $019386			bcs 	_EVEndInteger
.01937b	48		pha				pha 								; save it.
.01937c	20 3f 93	jsr $01933f			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.01937f	68		pla				pla
.019380	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019382	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019384	80 ec		bra $019372			bra 	_EVCheckNextInteger
.019386					_EVEndInteger:
.019386	60		rts				rts
.019387					EVGetDecimal:
.019387	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.019389	8d 15 03	sta $0315			sta 	Num_Buffer
.01938c	da		phx				phx
.01938d	c8		iny				iny
.01938e	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019390	c8		iny				iny
.019391	3a		dec a				dec 	a								; convert to a string length.
.019392	3a		dec a				dec 	a
.019393	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019395					_EVGDCopy:
.019395	48		pha				pha 									; save count
.019396	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019398	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01939b	e8		inx				inx 									; forward ....
.01939c	c8		iny				iny
.01939d	68		pla				pla 									; get count
.01939e	3a		dec a				dec 	a 								; until zero
.01939f	d0 f4		bne $019395			bne 	_EVGDCopy
.0193a1	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.0193a4	fa		plx				plx 									; restore X
.0193a5	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.0193a7	85 20		sta $20				sta 	zGenPtr
.0193a9	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.0193ab	85 21		sta $21				sta 	zGenPtr+1
.0193ad	5a		phy				phy 									; save Y
.0193ae	a0 00		ldy #$00			ldy 	#0 								; start position
.0193b0	20 07 a8	jsr $01a807			jsr 	FPFromString 					; convert current
.0193b3	7a		ply				ply 									; restore Y
.0193b4	60		rts				rts
.0193b5					NotInteger:
.0193b5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193b7	49 ff		eor #$ff			eor 	#$FF
.0193b9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193bb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193bd	49 ff		eor #$ff			eor 	#$FF
.0193bf	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193c1	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193c3	49 ff		eor #$ff			eor 	#$FF
.0193c5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193c7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0193c9	49 ff		eor #$ff			eor 	#$FF
.0193cb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193cd	60		rts				rts
.0193ce					EvaluateGetAtom:
.0193ce	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.0193d0					EvaluateGetAtomX:
.0193d0	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.0193d2	20 5d 92	jsr $01925d			jsr 	EvaluateExpressionXA
.0193d5	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.0193d7	29 0f		and #$0f			and 	#15
.0193d9	c9 02		cmp #$02			cmp 	#2
.0193db	b0 01		bcs $0193de			bcs 	EvaluateType
.0193dd	60		rts				rts
.0193de					EvaluateType:
.0193de	4c 67 85	jmp $018567			jmp 	TypeError
.0193e1					EvaluateNumber:
.0193e1	a2 00		ldx #$00			ldx 	#0
.0193e3					EvaluateNumberX:
.0193e3	20 5b 92	jsr $01925b			jsr 	EvaluateExpressionX
.0193e6	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.0193e8	29 0f		and #$0f			and 	#15
.0193ea	c9 02		cmp #$02			cmp 	#2
.0193ec	b0 f0		bcs $0193de			bcs 	EvaluateType
.0193ee	60		rts				rts
.0193ef					EvaluateInteger:
.0193ef	a2 00		ldx #$00			ldx 	#0
.0193f1					EvaluateIntegerX:
.0193f1	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX
.0193f4	20 4d a6	jsr $01a64d			jsr 	FPUToInteger
.0193f7	60		rts				rts
.0193f8					EvaluateString:
.0193f8	a2 00		ldx #$00			ldx 	#0
.0193fa					EvaluateStringX:
.0193fa	20 5b 92	jsr $01925b			jsr 	EvaluateExpressionX
.0193fd	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0193ff	29 0f		and #$0f			and 	#15
.019401	c9 02		cmp #$02			cmp 	#2
.019403	d0 d9		bne $0193de			bne 	EvaluateType
.019405	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.019407	85 20		sta $20				sta 	zGenPtr
.019409	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01940b	85 21		sta $21				sta 	zGenPtr+1
.01940d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.01940e					BinaryOp_And:
.01940e	20 62 94	jsr $019462			jsr 	BinaryMakeBothInteger
.019411	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.019413	35 86		and $86,x			and 	XS2_Mantissa+0,x
.019415	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019417	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019419	35 87		and $87,x			and 	XS2_Mantissa+1,x
.01941b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01941d	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01941f	35 88		and $88,x			and 	XS2_Mantissa+2,x
.019421	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019423	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019425	35 89		and $89,x			and 	XS2_Mantissa+3,x
.019427	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019429	60		rts				rts
.01942a					BinaryOp_Or:
.01942a	20 62 94	jsr $019462			jsr 	BinaryMakeBothInteger
.01942d	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01942f	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.019431	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019433	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019435	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019437	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019439	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01943b	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01943d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01943f	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.019441	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019443	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019445	60		rts				rts
.019446					BinaryOp_Eor:
.019446					BinaryOp_Xor:
.019446	20 62 94	jsr $019462			jsr 	BinaryMakeBothInteger
.019449	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.01944b	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.01944d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01944f	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019451	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019453	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019455	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019457	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.019459	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01945b	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01945d	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.01945f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019461	60		rts				rts
.019462					BinaryMakeBothInteger:
.019462	da		phx				phx 								; save X
.019463	e8		inx				inx
.019464	e8		inx				inx
.019465	e8		inx				inx
.019466	e8		inx				inx
.019467	e8		inx				inx
.019468	e8		inx				inx
.019469	20 6d 94	jsr $01946d			jsr 	BinaryMakeInteger 			; convert to integer.
.01946c	fa		plx				plx 								; restore X and fall through.
.01946d					BinaryMakeInteger:
.01946d	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.01946f	29 0f		and #$0f			and 	#15 						; check type zero
.019471	f0 04		beq $019477			beq 	_BMIConvert 				; if float convert to integer.
.019473	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019474	90 04		bcc $01947a			bcc 	_BMIError
.019476	60		rts				rts
.019477					_BMIConvert:
.019477	4c 4d a6	jmp $01a64d			jmp 	FPUToInteger 				; convert to integer
.01947a					_BMIError:
.01947a	4c 67 85	jmp $018567			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.01947d					Binary_Equal:
.01947d	20 c6 94	jsr $0194c6			jsr 	CompareValues 				; compare the values
.019480	09 00		ora #$00			ora 	#0 							; true if 0
.019482	f0 33		beq $0194b7			beq 	CCTrue
.019484	80 2d		bra $0194b3			bra 	CCFalse
.019486					Binary_NotEqual:
.019486	20 c6 94	jsr $0194c6			jsr 	CompareValues
.019489	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.01948b	f0 26		beq $0194b3			beq 	CCFalse
.01948d	80 28		bra $0194b7			bra 	CCTrue
.01948f					Binary_Less:
.01948f	20 c6 94	jsr $0194c6			jsr 	CompareValues
.019492	09 00		ora #$00			ora 	#0 							; true if -1
.019494	30 21		bmi $0194b7			bmi 	CCTrue
.019496	80 1b		bra $0194b3			bra 	CCFalse
.019498					Binary_LessEqual:
.019498	20 c6 94	jsr $0194c6			jsr 	CompareValues
.01949b	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.01949d	d0 18		bne $0194b7			bne 	CCTrue
.01949f	80 12		bra $0194b3			bra 	CCFalse
.0194a1					Binary_GreaterEqual:
.0194a1	20 c6 94	jsr $0194c6			jsr 	CompareValues
.0194a4	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.0194a6	10 0f		bpl $0194b7			bpl 	CCTrue
.0194a8	80 09		bra $0194b3			bra 	CCFalse
.0194aa					Binary_Greater:
.0194aa	20 c6 94	jsr $0194c6			jsr 	CompareValues 				; true if 1
.0194ad	c9 01		cmp #$01			cmp 	#1
.0194af	f0 06		beq $0194b7			beq 	CCTrue
.0194b1	80 00		bra $0194b3			bra 	CCFalse
.0194b3	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.0194b5	80 02		bra $0194b9			bra 	CCWrite
.0194b7	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.0194b9	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.0194bb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194bd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0194bf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194c1	a9 01		lda #$01			lda 	#1
.0194c3	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.0194c5	60		rts				rts
.0194c6					CompareValues:
.0194c6	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.0194c8	35 8b		and $8b,x			and 	XS2_Type,x
.0194ca	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.0194cc	f0 11		beq $0194df			beq 	_CVString					; comparison routine.
.0194ce	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194d0	35 8b		and $8b,x			and 	XS2_Type,x
.0194d2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0194d3	90 03		bcc $0194d8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0194d5	4c 21 95	jmp $019521			jmp 	CompareInteger32 							; so execute code at \1
.0194d8					_BCFloat:
.0194d8	20 bb 95	jsr $0195bb			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0194db	4c 46 a5	jmp $01a546			jmp 	FPCompare 							; and execute code at \2
.0194de	60		rts				rts
.0194df					_CVString:
.0194df	da		phx				phx 								; save XY
.0194e0	5a		phy				phy
.0194e1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0194e3	85 1c		sta $1c				sta		zLTemp1+0
.0194e5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0194e7	85 1d		sta $1d				sta 	zLTemp1+1
.0194e9	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0194eb	85 1e		sta $1e				sta 	zLTemp1+2
.0194ed	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194ef	85 1f		sta $1f				sta 	zLTemp1+3
.0194f1	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0194f3	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194f5	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194f7	90 02		bcc $0194fb			bcc 	_CVCommon
.0194f9	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.0194fb					_CVCommon:
.0194fb	aa		tax				tax 								; put shorter string length in zero.
.0194fc	f0 0c		beq $01950a			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0194fe					_CVCompare:
.0194fe	c8		iny				iny 								; next character
.0194ff	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.019501	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.019503	90 13		bcc $019518			bcc 	_CVReturnLess 				; <
.019505	d0 15		bne $01951c			bne 	_CVReturnGreater 			; >
.019507	ca		dex				dex 								; until common length matched.
.019508	d0 f4		bne $0194fe			bne 	_CVCompare
.01950a					_CVMatch:
.01950a	a0 00		ldy #$00			ldy 	#0
.01950c	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.01950e	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.019510	90 06		bcc $019518			bcc 	_CVReturnLess 				; <
.019512	d0 08		bne $01951c			bne 	_CVReturnGreater 			; >
.019514	a9 00		lda #$00			lda 	#0
.019516	80 06		bra $01951e			bra 	_CVExit
.019518					_CVReturnLess:
.019518	a9 ff		lda #$ff			lda 	#$FF
.01951a	80 02		bra $01951e			bra 	_CVExit
.01951c					_CVReturnGreater:
.01951c	a9 01		lda #$01			lda 	#$01
.01951e					_CVExit:
.01951e	7a		ply				ply
.01951f	fa		plx				plx
.019520	60		rts				rts
.019521					CompareInteger32:
.019521	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019523	49 80		eor #$80			eor 	#$80
.019525	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019527	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.019529	49 80		eor #$80			eor 	#$80
.01952b	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.01952d	20 a1 95	jsr $0195a1			jsr 	SubInteger32 				; subtraction
.019530	90 0d		bcc $01953f			bcc 	_CI32Less 					; cc return -1
.019532	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019534	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019536	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019538	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01953a	f0 02		beq $01953e			beq 	_CI32Exit
.01953c	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.01953e					_CI32Exit:
.01953e	60		rts				rts
.01953f					_CI32Less:
.01953f	a9 ff		lda #$ff			lda 	#$FF
.019541	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019542					BinaryOp_Add:
.019542	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019544	35 8b		and $8b,x			and 	XS2_Type,x
.019546	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.019548	d0 11		bne $01955b			bne 	_BOAString 					; so go do the string code.
.01954a	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01954c	35 8b		and $8b,x			and 	XS2_Type,x
.01954e	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01954f	90 03		bcc $019554			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019551	4c 87 95	jmp $019587			jmp 	AddInteger32 							; so execute code at \1
.019554					_BCFloat:
.019554	20 bb 95	jsr $0195bb			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019557	4c 31 a3	jmp $01a331			jmp 	FPAdd 							; and execute code at \2
.01955a	60		rts				rts
.01955b					_BOAString:
.01955b	4c d5 95	jmp $0195d5			jmp 	ConcatenateString 			; concatenate two strings.
.01955e					BinaryOp_Subtract:
.01955e	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019560	35 8b		and $8b,x			and 	XS2_Type,x
.019562	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019563	90 03		bcc $019568			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019565	4c a1 95	jmp $0195a1			jmp 	SubInteger32 							; so execute code at \1
.019568					_BCFloat:
.019568	20 bb 95	jsr $0195bb			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01956b	4c 29 a3	jmp $01a329			jmp 	FPSubtract 							; and execute code at \2
.01956e	60		rts				rts
.01956f					BinaryOp_Multiply:
.01956f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019571	35 8b		and $8b,x			and 	XS2_Type,x
.019573	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019574	90 03		bcc $019579			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019576	4c 00 a1	jmp $01a100			jmp 	MulInteger32 							; so execute code at \1
.019579					_BCFloat:
.019579	20 bb 95	jsr $0195bb			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01957c	4c 48 a4	jmp $01a448			jmp 	FPMultiply 							; and execute code at \2
.01957f	60		rts				rts
.019580					BinaryOp_Divide:
.019580	20 bb 95	jsr $0195bb			jsr 	BinaryMakeBothFloat
.019583	20 d5 a3	jsr $01a3d5			jsr 	FPDivide
.019586	60		rts				rts
.019587					AddInteger32:
.019587	18		clc				clc
.019588	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01958a	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01958c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01958e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019590	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019592	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019594	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019596	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019598	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01959a	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01959c	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01959e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195a0	60		rts				rts
.0195a1					SubInteger32:
.0195a1	38		sec				sec
.0195a2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0195a4	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0195a6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195a8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195aa	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0195ac	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195ae	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0195b0	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0195b2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0195b4	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0195b6	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.0195b8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0195ba	60		rts				rts
.0195bb					BinaryMakeBothFloat:
.0195bb	da		phx				phx 								; save X
.0195bc	e8		inx				inx
.0195bd	e8		inx				inx
.0195be	e8		inx				inx
.0195bf	e8		inx				inx
.0195c0	e8		inx				inx
.0195c1	e8		inx				inx
.0195c2	20 c6 95	jsr $0195c6			jsr 	BinaryMakeFloat 			; convert to float.
.0195c5	fa		plx				plx 								; restore X and fall through.
.0195c6					BinaryMakeFloat:
.0195c6	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.0195c8	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.0195c9	b0 04		bcs $0195cf			bcs 	_BMFConvert
.0195cb	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.0195cc	b0 04		bcs $0195d2			bcs 	_BMFError
.0195ce	60		rts				rts
.0195cf					_BMFConvert:
.0195cf	4c 01 a6	jmp $01a601			jmp 	FPUToFloat 					; convert to float, only float builds of course
.0195d2					_BMFError:
.0195d2	4c 67 85	jmp $018567			jmp 	TypeError
.0195d5					ConcatenateString:
.0195d5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.0195d7	85 1c		sta $1c				sta		zLTemp1+0
.0195d9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0195db	85 1d		sta $1d				sta 	zLTemp1+1
.0195dd	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.0195df	85 1e		sta $1e				sta 	zLTemp1+2
.0195e1	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195e3	85 1f		sta $1f				sta 	zLTemp1+3
.0195e5	5a		phy				phy
.0195e6	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0195e8	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.0195ea	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.0195ec	7a		ply				ply
.0195ed	b0 33		bcs $019622			bcs 	_CSError					; check in range.
.0195ef	c9 fe		cmp #$fe			cmp 	#maxString+1
.0195f1	b0 2f		bcs $019622			bcs 	_CSError
.0195f3	20 88 9a	jsr $019a88			jsr 	AllocateTempString 			; store the result
.0195f6	20 0d 96	jsr $01960d			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195f9	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0195fb	85 1c		sta $1c				sta 	zLTemp1
.0195fd	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195ff	85 1d		sta $1d				sta 	zLTemp1+1
.019601	20 0d 96	jsr $01960d			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019604	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.019606	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019608	a5 23		lda $23				lda 	zTempStr+1
.01960a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01960c	60		rts				rts
.01960d					_CSCopyString:
.01960d	da		phx				phx
.01960e	5a		phy				phy
.01960f	a0 00		ldy #$00			ldy 	#0 							; get length
.019611	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019613	f0 0a		beq $01961f			beq 	_CSCSExit 					; if zero, exit immediately
.019615	aa		tax				tax 								; put in X which is the counter.
.019616					_CSCSLoop:
.019616	c8		iny				iny 								; get next char
.019617	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.019619	20 b3 9a	jsr $019ab3			jsr		WriteTempString 			; copy out to new string
.01961c	ca		dex				dex 								; do whole string
.01961d	d0 f7		bne $019616			bne 	_CSCSLoop
.01961f					_CSCSExit:
.01961f	7a		ply				ply
.019620	fa		plx				plx
.019621	60		rts				rts
.019622					_CSError:
.019622	20 86 85	jsr $018586			jsr ERR_Handler
>019625	53 74 72 69 6e 67 20 74			.text "String too long",0
>01962d	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.019635					Unary_Sgn:
.019635	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX 			; get value
.019638	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; check right bracket.
.01963b	20 59 96	jsr $019659			jsr 	GetSignCurrent 				; get sign.
.01963e	09 00		ora #$00			ora 	#0
.019640	10 08		bpl $01964a			bpl		UnarySetAInteger			; if 0,1 return that.
.019642	80 00		bra $019644			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.019644					UnarySetAMinus1:
.019644	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019646	95 80		sta $80,x			sta 	XS_Mantissa,x
.019648	80 04		bra $01964e			bra 	UnarySetAFill
.01964a					UnarySetAInteger:
.01964a	95 80		sta $80,x			sta 	XS_Mantissa,x
.01964c	a9 00		lda #$00			lda 	#0
.01964e					UnarySetAFill:
.01964e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019650	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019652	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019654	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019656	95 85		sta $85,x			sta 	XS_Type,x
.019658	60		rts				rts
.019659					GetSignCurrent:
.019659	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.01965b	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.01965c	90 15		bcc $019673			bcc 	_GSCFloat 					; if clear do the float code.
.01965e	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.019660	30 0e		bmi $019670			bmi 	_GSCMinus1
.019662	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.019664	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019666	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019668	d0 03		bne $01966d			bne 	_GSCPlus1 					; check if zero by oring all together.
.01966a					_GSCZero:
.01966a	a9 00		lda #$00			lda 	#0
.01966c	60		rts				rts
.01966d					_GSCPlus1:
.01966d	a9 01		lda #$01			lda 	#$01
.01966f	60		rts				rts
.019670					_GSCMinus1:
.019670	a9 ff		lda #$ff			lda 	#$FF
.019672	60		rts				rts
.019673					_GSCFloat:
.019673	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.019675	70 f3		bvs $01966a			bvs 	_GSCZero 					; if zero flag set return zero
.019677	30 f7		bmi $019670			bmi 	_GSCMinus1 					; if sign set return -1
.019679	80 f2		bra $01966d			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.01967b					Unary_Abs:
.01967b	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX 			; get value
.01967e	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; check right bracket.
.019681	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019683	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019685	f0 07		beq $01968e			beq 	_UAMinusFloat
.019687	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019689	10 09		bpl $019694			bpl 	_UAExit
.01968b	4c c5 a1	jmp $01a1c5			jmp 	IntegerNegateAlways 		; if so negate it.
.01968e					_UAMinusFloat:
.01968e	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.019690	29 7f		and #$7f			and		#$7F
.019692	95 85		sta $85,x			sta 	XS_Type,x
.019694					_UAExit:
.019694	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019695					Unary_Peek:
.019695	a9 01		lda #$01			lda 	#1 							; 1 byte
.019697	80 06		bra $01969f			bra 	UPMain
.019699					Unary_Deek:
.019699	a9 02		lda #$02			lda 	#2 							; 2 bytes
.01969b	80 02		bra $01969f			bra 	UPMain
.01969d					Unary_Leek:
.01969d	a9 04		lda #$04			lda 	#4 							; 4 bytes
.01969f					UPMain:
.01969f	48		pha				pha 								; save bytes to copy.
.0196a0	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.0196a3	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.0196a6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0196a8	85 1c		sta $1c				sta 	zLTemp1
.0196aa	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196ac	85 1d		sta $1d				sta 	zLTemp1+1
.0196ae	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0196b0	85 1e		sta $1e				sta 	zLTemp1+2
.0196b2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0196b4	85 1f		sta $1f				sta 	zLTemp1+3
.0196b6	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.0196b8	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.0196ba	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196bc	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196be	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196c0	68		pla				pla 								; restore bytes to copy
.0196c1	da		phx				phx 								; save XY
.0196c2	5a		phy				phy
.0196c3	20 bd 99	jsr $0199bd			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.0196c6	7a		ply				ply 								; restore and exit
.0196c7	fa		plx				plx
.0196c8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.0196c9					Unary_Pos:
.0196c9	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.0196cc	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; check right bracket.
.0196cf	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; get the position
.0196d2	4c 4a 96	jmp $01964a			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.0196d5					Unary_Mod:
.0196d5	20 fd 96	jsr $0196fd			jsr 	_UMParameter 				; first parameter, get |param|
.0196d8	20 43 9a	jsr $019a43			jsr 	CheckNextComma
.0196db	da		phx				phx 								; second parameter, get |param|
.0196dc	e8		inx				inx
.0196dd	e8		inx				inx
.0196de	e8		inx				inx
.0196df	e8		inx				inx
.0196e0	e8		inx				inx
.0196e1	e8		inx				inx
.0196e2	20 fd 96	jsr $0196fd			jsr 	_UMParameter
.0196e5	fa		plx				plx
.0196e6	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen
.0196e9	20 3e a1	jsr $01a13e			jsr 	DivInteger32 				; divide, which handily leaves ....
.0196ec	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0196ee	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196f0	a5 1d		lda $1d				lda 	zLTemp1+1
.0196f2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196f4	a5 1e		lda $1e				lda 	zLTemp1+2
.0196f6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196f8	a5 1f		lda $1f				lda 	zLTemp1+3
.0196fa	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196fc	60		rts				rts
.0196fd					_UMParameter:
.0196fd	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX 			; get value
.019700	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.019702	10 03		bpl $019707			bpl 	_UMNotSigned
.019704	20 c5 a1	jsr $01a1c5			jsr 	IntegerNegateAlways
.019707					_UMNotSigned:
.019707	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019708					Unary_Usr:
.019708	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX 			; numeric parameter
.01970b	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.01970e	da		phx				phx 								; save XY
.01970f	5a		phy				phy
.019710	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.019714	7a		ply				ply 								; restore YX and exit with whatever the
.019715	fa		plx				plx 								; routine called has chosen to do with it.
.019716	60		rts				rts
.019717					USRDefault:
.019717	20 86 85	jsr $018586			jsr ERR_Handler
>01971a	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>019722	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019729					Unary_Val:
.019729	20 fa 93	jsr $0193fa			jsr 	EvaluateStringX 			; get string
.01972c	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; check right bracket.
.01972f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.019731	85 20		sta $20				sta 	zGenPtr
.019733	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019735	85 21		sta $21				sta 	zGenPtr+1
.019737	da		phx				phx
.019738	5a		phy				phy
.019739	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.01973b	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.01973d	f0 1b		beq $01975a			beq 	UVBadNumber
.01973f	aa		tax				tax
.019740					_UVCopy1:
.019740	c8		iny				iny
.019741	c0 18		cpy #$18			cpy 	#24 						; too long
.019743	f0 15		beq $01975a			beq 	UVBadNumber
.019745	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.019747	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.01974a	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.01974c	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.01974f	ca		dex				dex
.019750	d0 ee		bne $019740			bne 	_UVCopy1
.019752	7a		ply				ply
.019753	fa		plx				plx
.019754	20 68 97	jsr $019768			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.019757	b0 01		bcs $01975a			bcs 	UVBadNumber
.019759	60		rts				rts
.01975a					UVBadNumber:
.01975a	20 86 85	jsr $018586			jsr ERR_Handler
>01975d	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>019765	65 72 00
.019768					ConvertNumBuffer:
.019768	5a		phy				phy
.019769	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.01976b	85 20		sta $20				sta 	zGenPtr
.01976d	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01976f	85 21		sta $21				sta 	zGenPtr+1
.019771	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.019774	c9 2d		cmp #$2d			cmp 	#"-"
.019776	d0 02		bne $01977a			bne 	_UVNotMinus1
.019778	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.01977a					_UVNotMinus1:
.01977a	20 97 a2	jsr $01a297			jsr 	IntFromString 				; get integer
.01977d	b0 22		bcs $0197a1			bcs 	_UVFail
.01977f	20 07 a8	jsr $01a807			jsr 	FPFromString 				; possibly float it.
.019782	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.019784	d0 1b		bne $0197a1			bne 	_UVFail 					; no, exit.
.019786	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.019789	c9 2d		cmp #$2d			cmp 	#"-"
.01978b	d0 11		bne $01979e			bne 	_UVNotMinus2
.01978d	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.01978f	29 0f		and #$0f			and 	#$0F
.019791	f0 05		beq $019798			beq 	_UVNegateFloat
.019793	20 c5 a1	jsr $01a1c5			jsr 	IntegerNegateAlways
.019796	80 06		bra $01979e			bra 	_UVNotMinus2
.019798					_UVNegateFloat:
.019798	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.01979a	09 80		ora #$80			ora 	#$80
.01979c	95 85		sta $85,x			sta 	XS_Type,x
.01979e					_UVNotMinus2:
.01979e	7a		ply				ply
.01979f	18		clc				clc
.0197a0	60		rts				rts
.0197a1	7a		ply		_UVFail:ply
.0197a2	38		sec				sec
.0197a3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0197a4					Unary_Str:
.0197a4	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX 			; numeric parameter
.0197a7	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.0197aa	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0197ac	8d 14 03	sta $0314			sta 	NumBufX
.0197af	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0197b1	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.0197b2	b0 05		bcs $0197b9			bcs 	_USInt 						; if msb set do as integer
.0197b4	20 4c a7	jsr $01a74c			jsr 	FPToString 					; call fp to str otherwise
.0197b7	80 03		bra $0197bc			bra 	_USDuplicate
.0197b9	20 e2 a1	jsr $01a1e2	_USInt:	jsr 	IntToString					; call int to str.
.0197bc					_USDuplicate:
.0197bc	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0197bf	1a		inc a				inc 	a 							; one more for length
.0197c0	20 88 9a	jsr $019a88			jsr 	AllocateTempString 			; allocate space for it.
.0197c3	5a		phy				phy 								; save Y
.0197c4	a0 00		ldy #$00			ldy 	#0 							; start copying
.0197c6	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0197c9	20 b3 9a	jsr $019ab3			jsr 	WriteTempString
.0197cc	c8		iny				iny
.0197cd	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0197d0	d0 f4		bne $0197c6			bne 	_USCopy
.0197d2	7a		ply				ply 								; restore Y
.0197d3	4c b0 99	jmp $0199b0			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.0197d6					Unary_Asc:
.0197d6	20 fa 93	jsr $0193fa			jsr 	EvaluateStringX 			; string parameter
.0197d9	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.0197dc	5a		phy				phy 								; get the string length
.0197dd	a0 00		ldy #$00			ldy 	#0
.0197df	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197e1	f0 07		beq $0197ea			beq 	_UAIllegal 					; must be at least one character, 0 => error
.0197e3	c8		iny				iny
.0197e4	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.0197e6	7a		ply				ply
.0197e7	4c 4a 96	jmp $01964a			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.0197ea					_UAIllegal:
.0197ea	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0197ed					Unary_Len:
.0197ed	20 fa 93	jsr $0193fa			jsr 	EvaluateStringX 			; string parameter
.0197f0	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.0197f3	5a		phy				phy 								; get the string length
.0197f4	a0 00		ldy #$00			ldy 	#0
.0197f6	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197f8	7a		ply				ply
.0197f9	4c 4a 96	jmp $01964a			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0197fc					Unary_Mid:
.0197fc	20 fa 93	jsr $0193fa			jsr 	EvaluateStringX 				; get string.
.0197ff	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019801	48		pha				pha
.019802	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019804	48		pha				pha
.019805	20 43 9a	jsr $019a43			jsr 	CheckNextComma 					; skip comma
.019808	20 91 98	jsr $019891			jsr 	SLIByteParameter 				; get a byte parameter (start)
.01980b	48		pha				pha 									; and push it.
.01980c	20 43 9a	jsr $019a43			jsr 	CheckNextComma 					; skip comma
.01980f	20 91 98	jsr $019891			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019812	48		pha				pha 									; and push it.
.019813	80 41		bra $019856			bra 	SLIProcess
.019815					Unary_Left:
.019815	20 fa 93	jsr $0193fa			jsr 	EvaluateStringX 				; get string.
.019818	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01981a	48		pha				pha
.01981b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01981d	48		pha				pha
.01981e	a9 01		lda #$01			lda 	#1 								; push start position (1)
.019820	48		pha				pha
.019821	20 43 9a	jsr $019a43			jsr 	CheckNextComma 					; skip comma
.019824	20 91 98	jsr $019891			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019827	48		pha				pha 									; and push it.
.019828	80 2c		bra $019856			bra 	SLIProcess
.01982a					Unary_Right:
.01982a	20 fa 93	jsr $0193fa			jsr 	EvaluateStringX 				; get string.
.01982d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01982f	48		pha				pha
.019830	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019832	48		pha				pha
.019833	da		phx				phx 									; get the string length and push on stack.
.019834	a2 00		ldx #$00			ldx 	#0
.019836	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.019838	fa		plx				plx
.019839	48		pha				pha
.01983a	20 43 9a	jsr $019a43			jsr 	CheckNextComma 					; skip comma
.01983d	20 91 98	jsr $019891			jsr 	SLIByteParameter 				; get a byte parameter.
.019840	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019843	68		pla				pla 									; restore string length.
.019844	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019845	38		sec				sec
.019846	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019849	f0 02		beq $01984d			beq 	_URStart 						; if <= 0 start from 1.
.01984b	10 02		bpl $01984f			bpl 	_UROkay
.01984d					_URStart:
.01984d	a9 01		lda #$01			lda 	#1
.01984f					_UROkay:
.01984f	48		pha				pha 									; push start
.019850	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019853	48		pha				pha
.019854	80 00		bra $019856			bra 	SLIProcess
.019856					SLIProcess:
.019856	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 				; closing right bracket.
.019859	68		pla				pla
.01985a	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01985d	1a		inc a				inc 	a 								; allocate +1 for it.
.01985e	20 88 9a	jsr $019a88			jsr 	AllocateTempString
.019861	68		pla				pla 									; pop start number off stack.
.019862	f0 3b		beq $01989f			beq 	SLIError 						; exit if start = 0
.019864	8d a1 03	sta $03a1			sta 	SliceStart
.019867	68		pla				pla  									; pop string address.
.019868	85 21		sta $21				sta 	zGenPtr+1
.01986a	68		pla				pla
.01986b	85 20		sta $20				sta 	zGenPtr
.01986d	da		phx				phx
.01986e	5a		phy				phy
.01986f	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.019871	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.019874					_SLICopy:
.019874	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019877	f0 12		beq $01988b			beq 	_SLIExit
.019879	ce a2 03	dec $03a2			dec 	SliceCount
.01987c	98		tya				tya 									; index of character
.01987d	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.01987f	f0 02		beq $019883			beq 	_SLIOk 							; if equal, okay.
.019881	b0 08		bcs $01988b			bcs 	_SLIExit 						; if past end, then exit.
.019883	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019885	c8		iny				iny
.019886	20 b3 9a	jsr $019ab3			jsr 	WriteTempString
.019889	80 e9		bra $019874			bra 	_SLICopy 						; go round till copied characters
.01988b					_SLIExit:
.01988b	7a		ply				ply 									; restore YX
.01988c	fa		plx				plx
.01988d	4c b0 99	jmp $0199b0			jmp 	UnaryReturnTempStr 				; return new temporary string.
.019890	ea		nop				nop
.019891					SLIByteParameter:
.019891	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX 				; get integer
.019894	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019896	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019898	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01989a	d0 03		bne $01989f			bne 	SLIError
.01989c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01989e	60		rts				rts
.01989f					SLIError:
.01989f	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0198a2					Unary_Hex:
.0198a2	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX 			; numeric parameter
.0198a5	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.0198a8	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0198aa	20 88 9a	jsr $019a88			jsr 	AllocateTempString			; allocate string space
.0198ad	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0198af	20 d3 98	jsr $0198d3			jsr 	_UHConvert
.0198b2	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0198b4	20 d3 98	jsr $0198d3			jsr 	_UHConvert
.0198b7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0198b9	20 d3 98	jsr $0198d3			jsr 	_UHConvert
.0198bc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0198be	20 d3 98	jsr $0198d3			jsr 	_UHConvert
.0198c1	5a		phy				phy 								; get length of new string
.0198c2	a0 00		ldy #$00			ldy 	#0
.0198c4	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198c6	7a		ply				ply
.0198c7	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.0198c9	d0 05		bne $0198d0			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.0198cb	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0198cd	20 b3 9a	jsr $019ab3			jsr 	WriteTempString
.0198d0					_UHExit:
.0198d0	4c b0 99	jmp $0199b0			jmp 	UnaryReturnTempStr 			; return new temporary string.
.0198d3					_UHConvert:
.0198d3	48		pha				pha
.0198d4	4a		lsr a				lsr 	a 							; do MSB
.0198d5	4a		lsr a				lsr 	a
.0198d6	4a		lsr a				lsr 	a
.0198d7	4a		lsr a				lsr 	a
.0198d8	20 dc 98	jsr $0198dc			jsr 	_UHNibble
.0198db	68		pla				pla 								; do LSB
.0198dc					_UHNibble:
.0198dc	29 0f		and #$0f			and 	#15 						; get nibble
.0198de	d0 0c		bne $0198ec			bne 	_UHNonZero 					; if not zero, write it out anyway.
.0198e0	5a		phy				phy									; get the length
.0198e1	a0 00		ldy #$00			ldy 	#0
.0198e3	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198e5	7a		ply				ply
.0198e6	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.0198e8	f0 0d		beq $0198f7			beq 	_UHExit2
.0198ea	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.0198ec					_UHNonZero:
.0198ec	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0198ee	90 02		bcc $0198f2			bcc 	_UHDigit
.0198f0	69 06		adc #$06			adc 	#7-1
.0198f2					_UHDigit:
.0198f2	69 30		adc #$30			adc 	#48
.0198f4	20 b3 9a	jsr $019ab3			jsr 	WriteTempString				; output to temp string.
.0198f7					_UHExit2:
.0198f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0198f8					Unary_Dec:
.0198f8	20 fa 93	jsr $0193fa			jsr 	EvaluateStringX 			; string parameter
.0198fb	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.0198fe	5a		phy				phy
.0198ff	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.019901	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019903	f0 43		beq $019948			beq 	_UDFail 					; must fail if zero.
.019905	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.019908	a9 00		lda #$00			lda 	#0 							; set result to zero
.01990a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01990c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01990e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019910	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019912	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019914	95 85		sta $85,x			sta 	XS_Type,x
.019916					_UDConvertLoop:
.019916	5a		phy				phy 								; shift mantissa left 4
.019917	a0 04		ldy #$04			ldy 	#4
.019919					_UDShift:
.019919	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01991b	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01991d	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01991f	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019921	88		dey				dey
.019922	d0 f5		bne $019919			bne 	_UDShift
.019924	7a		ply				ply
.019925	c8		iny				iny 								; next character
.019926	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.019928	20 4b 99	jsr $01994b			jsr 	ConvertUpper 				; convert to U/C
.01992b	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.01992d	90 19		bcc $019948			bcc 	_UDFail
.01992f	c9 3a		cmp #$3a			cmp 	#"9"+1
.019931	90 08		bcc $01993b			bcc 	_UDOkay
.019933	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.019935	90 11		bcc $019948			bcc 	_UDFail 					; fails if between 9 and @
.019937	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.019939	b0 0d		bcs $019948			bcs 	_UDFail
.01993b					_UDOkay:
.01993b	29 0f		and #$0f			and 	#15 						; nibble only
.01993d	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.01993f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019941	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.019944	d0 d0		bne $019916			bne 	_UDConvertLoop
.019946	7a		ply				ply
.019947	60		rts				rts
.019948					_UDFail:
.019948	4c 75 85	jmp $018575			jmp 	BadParamError
.01994b					ConvertUpper:
.01994b	c9 61		cmp #$61			cmp 	#"a"
.01994d	90 07		bcc $019956			bcc 	_CUExit
.01994f	c9 7b		cmp #$7b			cmp 	#"z"+1
.019951	b0 03		bcs $019956			bcs 	_CUExit
.019953	38		sec				sec
.019954	e9 20		sbc #$20			sbc 	#32
.019956	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019957					Unary_Chr:
.019957	20 f1 93	jsr $0193f1			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.01995a	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; right bracket.
.01995d	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01995f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019961	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019963	d0 0d		bne $019972			bne 	_UCChar
.019965	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019967	20 88 9a	jsr $019a88			jsr 	AllocateTempString			; allocate it.
.01996a	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.01996c	20 b3 9a	jsr $019ab3			jsr 	WriteTempString
.01996f	4c b0 99	jmp $0199b0			jmp 	UnaryReturnTempStr 			; and return that string.
.019972					_UCChar:
.019972	4c 75 85	jmp $018575			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019975					Unary_Spc:
.019975	20 91 98	jsr $019891			jsr 	SLIByteParameter 			; get number of spaces
.019978	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; skip )
.01997b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.01997d					UnarySpcCreate:
.01997d	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.01997f	b0 14		bcs $019995			bcs 	_USSize
.019981	48		pha				pha 								; save length
.019982	1a		inc a				inc 	a 							; allocate one more.
.019983	20 88 9a	jsr $019a88			jsr 	AllocateTempString
.019986	68		pla				pla 								; get length
.019987	f0 27		beq $0199b0			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.019989					_USLoop:
.019989	48		pha				pha
.01998a	a9 20		lda #$20			lda 	#" "
.01998c	20 b3 9a	jsr $019ab3			jsr 	WriteTempString
.01998f	68		pla				pla
.019990	3a		dec a				dec 	a
.019991	d0 f6		bne $019989			bne 	_USLoop
.019993	80 1b		bra $0199b0			bra 	UnaryReturnTempStr 			; and return the temporary space.
.019995					_USSize:
.019995	4c 75 85	jmp $018575			jmp 	BadParamError
.019998					Unary_Tab:
.019998	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.01999a	20 91 98	jsr $019891			jsr 	SLIByteParameter
.01999d	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen
.0199a0	20 50 85	jsr $018550			jsr 	VIOCharGetPosition 			; were are we ?
.0199a3	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.0199a5	38		sec				sec
.0199a6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.0199a8	e5 10		sbc $10				sbc 	zTemp1
.0199aa	b0 d1		bcs $01997d			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.0199ac	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.0199ae	80 cd		bra $01997d			bra 	UnarySpcCreate
.0199b0					UnaryReturnTempStr:
.0199b0	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.0199b2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0199b4	a5 23		lda $23				lda 	zTempStr+1
.0199b6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0199b8	a9 02		lda #$02			lda 	#2 							; set type to string
.0199ba	95 85		sta $85,x			sta 	XS_Type,x
.0199bc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0199bd					MemRead:
.0199bd	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199c0	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199c2	b7 1c		lda [$1c],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0199c4	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0199c6	c8		iny				iny 								; next to copy
.0199c7	e8		inx				inx
.0199c8	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199cb	d0 f5		bne $0199c2			bne 	_MLoop1
.0199cd	60		rts				rts
.0199ce					MemWrite:
.0199ce	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0199d1	a0 00		ldy #$00			ldy 	#0 							; start from here
.0199d3	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0199d5	97 1c		sta [$1c],y			sta 	[zlTemp1],y 				; write it out
.0199d7	c8		iny				iny 								; next to copy
.0199d8	e8		inx				inx
.0199d9	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0199dc	d0 f5		bne $0199d3			bne 	_MLoop1
.0199de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0199df					UpdateProgramEnd:
.0199df	a9 00		lda #$00			lda 	#(BasicProgram) & $FF
.0199e1	85 18		sta $18				sta 	zCodePtr+0
.0199e3	a9 20		lda #$20			lda 	#((BasicProgram) >> 8) & $FF
.0199e5	85 19		sta $19				sta 	zCodePtr+1
.0199e7	a9 01		lda #$01			lda 	#(BasicProgram) >> 16
.0199e9	85 1a		sta $1a				sta 	zCodePtr+2
.0199eb	85 1b		sta $1b				sta 	zCodePtr+3
.0199ed	a0 03		ldy #$03			ldy 	#3
.0199ef					_UPDLoop:
.0199ef	a0 00		ldy #$00			ldy 	#0
.0199f1	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199f3	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0199f5	f0 0f		beq $019a06			beq 	_UPDFoundEnd
.0199f7	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0199f9	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0199fb	18		clc				clc
.0199fc	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0199fe	85 18		sta $18				sta 	zCodePtr
.019a00	90 02		bcc $019a04			bcc 	_SNLNoCarry
.019a02	e6 19		inc $19				inc 	zCodePtr+1
.019a04					_SNLNoCarry:
.019a04	80 e9		bra $0199ef			bra 	_UPDLoop
.019a06					_UPDFoundEnd:
.019a06	18		clc				clc 								; end of program 2 on.
.019a07	a5 18		lda $18				lda 	zCodePtr
.019a09	69 02		adc #$02			adc 	#2
.019a0b	8d 04 03	sta $0304			sta 	endOfProgram
.019a0e	a5 19		lda $19				lda 	zCodePtr+1
.019a10	69 00		adc #$00			adc 	#0
.019a12	8d 05 03	sta $0305			sta 	endOfProgram+1
.019a15	a5 1a		lda $1a				lda 	zCodePtr+2
.019a17	69 00		adc #$00			adc		#0
.019a19	8d 06 03	sta $0306			sta 	endOfProgram+2
.019a1c	a5 1b		lda $1b				lda 	zCodePtr+3
.019a1e	69 00		adc #$00			adc 	#0
.019a20	8d 07 03	sta $0307			sta 	endOfProgram+3
.019a23	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019a24					CheckNextToken:
.019a24	d7 18		cmp [$18],y			cmp 	[zCodePtr],y
.019a26	d0 02		bne $019a2a			bne 	CTFail 						; no, then fail
.019a28	c8		iny				iny
.019a29	60		rts				rts
.019a2a					CTFail:
.019a2a	20 86 85	jsr $018586			jsr ERR_Handler
>019a2d	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019a35	74 6f 6b 65 6e 00
.019a3b					CheckNextRParen:
.019a3b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a3d	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.019a3f	d0 e9		bne $019a2a			bne 	CTFail 						; fail if not
.019a41	c8		iny				iny
.019a42	60		rts				rts
.019a43					CheckNextComma:
.019a43	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a45	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.019a47	d0 e1		bne $019a2a			bne 	CTFail 						; fail if not
.019a49	c8		iny				iny
.019a4a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019a4b					StringConcrete:
.019a4b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.019a4d	85 10		sta $10				sta 	zTemp1
.019a4f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a51	85 11		sta $11				sta 	zTemp1+1
.019a53	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019a55	b1 10		lda ($10),y			lda 	(zTemp1),y
.019a57	f0 26		beq $019a7f			beq		_SCEmpty 					; concreting it wastes memory.
.019a59	18		clc				clc 								; from the string pointer
.019a5a	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019a5d	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019a5f	8d 00 03	sta $0300			sta 	StringPtr
.019a62	85 12		sta $12				sta 	zTemp2
.019a64	ad 01 03	lda $0301			lda 	StringPtr+1
.019a67	e9 00		sbc #$00			sbc 	#0
.019a69	8d 01 03	sta $0301			sta 	StringPtr+1
.019a6c	85 13		sta $13				sta 	zTemp2+1
.019a6e	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019a70	1a		inc a				inc 	a
.019a71	aa		tax				tax
.019a72	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019a74	91 12		sta ($12),y			sta 	(zTemp2),y
.019a76	c8		iny				iny
.019a77	ca		dex				dex
.019a78	d0 f8		bne $019a72			bne 	_SCCopy
.019a7a	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019a7c	a6 12		ldx $12				ldx 	zTemp2
.019a7e	60		rts				rts
.019a7f					_SCEmpty:
.019a7f	a9 00		lda #$00			lda 	#0
.019a81	85 27		sta $27				sta 	zNullString
.019a83	a9 00		lda #$00			lda 	#zNullString >> 8
.019a85	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.019a87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019a88					AllocateTempString:
.019a88	48		pha				pha 								; save required count.
.019a89	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.019a8b	d0 0b		bne $019a98			bne 	_ATSInitialised
.019a8d	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019a90	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.019a92	ad 01 03	lda $0301			lda 	StringPtr+1
.019a95	3a		dec a				dec 	a 							; allow the page.
.019a96	85 23		sta $23				sta 	zTempStr+1
.019a98					_ATSInitialised:
.019a98	68		pla				pla 								; get required count back.
.019a99	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.019a9b	1a		inc a				inc 	a
.019a9c	18		clc				clc
.019a9d	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.019a9f	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.019aa1	a9 ff		lda #$ff			lda 	#$FF
.019aa3	65 23		adc $23				adc 	zTempStr+1
.019aa5	85 23		sta $23				sta 	zTempStr+1
.019aa7	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019aa9	5a		phy				phy
.019aaa	a8		tay				tay
.019aab	91 22		sta ($22),y			sta 	(zTempStr),y
.019aad	7a		ply				ply
.019aae	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019aaf	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019ab2	60		rts				rts
.019ab3					WriteTempString:
.019ab3	5a		phy				phy 								; save Y
.019ab4	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019ab7	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.019ab9	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019abc	98		tya				tya 								; unchanged Y is now length
.019abd	a0 00		ldy #$00			ldy 	#0
.019abf	91 22		sta ($22),y			sta 	(zTempStr),y
.019ac1	7a		ply				ply 								; restore Y and exit
.019ac2	60		rts				rts
.019ac3					CreateTempStringCopy:
.019ac3	da		phx				phx 								; save X
.019ac4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019ac6	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019ac7	20 88 9a	jsr $019a88			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019aca	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019acc	c8		iny				iny
.019acd	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019ace	3a		dec a				dec 	a 							; for the marker and the length.
.019acf	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019ad1	81 22		sta ($22,x)			sta 	(zTempStr,x)
.019ad3	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.019ad5	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019ad7	f0 0e		beq $019ae7			beq 	_CTSCExit
.019ad9					_CTSCLoop:
.019ad9	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019adb	c8		iny				iny
.019adc	5a		phy				phy 								; save Y
.019add	e8		inx				inx 								; bump index
.019ade	da		phx				phx 								; save that
.019adf	7a		ply				ply 								; index into Y
.019ae0	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.019ae2	7a		ply				ply 								; restore Y
.019ae3	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.019ae5	d0 f2		bne $019ad9			bne 	_CTSCLoop
.019ae7					_CTSCExit:
.019ae7	fa		plx				plx 								; restore X
.019ae8	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.019ae9					TokeniseKeyword:
.019ae9	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.019aea	18		clc				clc
.019aeb	65 20		adc $20				adc 	zGenPtr
.019aed	85 20		sta $20				sta 	zGenPtr
.019aef	90 02		bcc $019af3			bcc 	_TKWNoBump
.019af1	e6 21		inc $21				inc 	zGenPtr+1
.019af3					_TKWNoBump:
.019af3	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.019af5	da		phx				phx
.019af6	a9 cf		lda #$cf			lda 	#KeyWordText & $FF 			; scan this table.
.019af8	a2 86		ldx #$86			ldx 	#(KeyWordText >> 8) & $FF
.019afa	20 05 9b	jsr $019b05			jsr 	TKWScanTokenTable
.019afd	fa		plx				plx
.019afe	90 04		bcc $019b04			bcc 	_TKWNoWrite
.019b00	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.019b03	e8		inx				inx
.019b04					_TKWNoWrite:
.019b04	60		rts				rts
.019b05					TKWScanTokenTable:
.019b05	86 1d		stx $1d				stx 	zLTemp1+1
.019b07	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.019b09	a9 01		lda #$01			lda 	#KeywordText >> 16 				; 24 bit addresses in the 65816
.019b0b	85 1e		sta $1e				sta 	zLTemp1+2 						; lovely.
.019b0d	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.019b0f	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.019b11	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019b13	20 20 9c	jsr $019c20			jsr 	TOKCapitalise 					; save this in zTemp3
.019b16	85 14		sta $14				sta 	zTemp3
.019b18	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.019b1a	85 15		sta $15				sta 	zTemp3+1
.019b1c					_TKWScanLoop:
.019b1c	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b1e	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.019b20	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.019b22	d0 26		bne $019b4a			bne		_TKWNext 						; if it doesn't match, go to next.
.019b24	20 69 9b	jsr $019b69			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b27	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.019b29					_TKWCompareFull:
.019b29	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b2b	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.019b2d	85 16		sta $16				sta 	zTemp4
.019b2f	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.019b31	20 20 9c	jsr $019c20			jsr 	TOKCapitalise 					; make it U/C
.019b34	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.019b36	d0 12		bne $019b4a			bne 	_TKWNext 						; failed, go to next slot.
.019b38	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b3a	c8		iny				iny 									; bump pointer
.019b3b	0a		asl a				asl 	a 								; shift bit 7 into C
.019b3c	90 eb		bcc $019b29			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.019b3e	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.019b40	90 08		bcc $019b4a			bcc 	_TKWNext 						; if shorter, the original was better
.019b42	84 12		sty $12				sty 	zTemp2							; update longest match.
.019b44	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.019b46	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.019b48	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.019b4a					_TKWNext:
.019b4a	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b4c	c8		iny				iny 									; next one.
.019b4d	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.019b4e	90 fa		bcc $019b4a			bcc 	_TKWNext
.019b50	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.019b52	98		tya				tya 									; has Y gone negative.
.019b53	10 03		bpl $019b58			bpl 	_TKWNoYZero
.019b55	20 69 9b	jsr $019b69			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b58					_TKWNoYZero:
.019b58	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b5a	d0 c0		bne $019b1c			bne 	_TKWScanLoop 					; if not, try the next one.
.019b5c	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.019b5e	f0 05		beq $019b65			beq 	_TKWFail 						; if zero, none found.
.019b60	a8		tay				tay 									; return the token in zTemp2, length => y
.019b61	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.019b63	38		sec				sec
.019b64	60		rts				rts
.019b65					_TKWFail:
.019b65	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.019b67	18		clc				clc
.019b68	60		rts				rts
.019b69					_TKWClearY:
.019b69	98		tya				tya
.019b6a	18		clc				clc
.019b6b	65 1c		adc $1c				adc 	zLTemp1
.019b6d	85 1c		sta $1c				sta 	zLTemp1
.019b6f	90 02		bcc $019b73			bcc 	_TKWCNoBump
.019b71	e6 1d		inc $1d				inc 	zLTemp1+1
.019b73					_TKWCNoBump:
.019b73	a0 00		ldy #$00			ldy 	#0
.019b75	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.019b76					TokeniseString:
.019b76	85 20		sta $20				sta 	zGenPtr 					; save source
.019b78	86 21		stx $21				stx 	zGenPtr+1
.019b7a	a0 00		ldy #$00			ldy 	#0 							; source
.019b7c	a2 03		ldx #$03			ldx 	#3 							; target
.019b7e	8c 00 04	sty $0400			sty 	TokeniseBuffer+0 			; write three NULLs. So it looks like
.019b81	8c 01 04	sty $0401			sty 	TokeniseBuffer+1 			; there's a line number zero.
.019b84	8c 02 04	sty $0402			sty 	TokeniseBuffer+2
.019b87					_TSMainLoop:
.019b87					_TSSkipSpaces:
.019b87	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.019b89	c8		iny				iny
.019b8a	c9 20		cmp #$20			cmp 	#" "
.019b8c	f0 f9		beq $019b87			beq 	_TSSkipSpaces
.019b8e	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.019b90	90 0a		bcc $019b9c			bcc 	_TSNotConstant
.019b92	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b94	b0 06		bcs $019b9c			bcs 	_TSNotConstant
.019b96	88		dey				dey 								; point back to start
.019b97	20 bb 9c	jsr $019cbb			jsr 	TokeniseConstant 			; tokenise a constant
.019b9a	80 eb		bra $019b87			bra 	_TSMainLoop			 		; and loop back.
.019b9c					_TSNotConstant:
.019b9c	c9 20		cmp #$20			cmp 	#32 						; end of line.
.019b9e	90 52		bcc $019bf2			bcc 	_TSExit
.019ba0	c9 22		cmp #$22			cmp		#'"'						; quoted string
.019ba2	f0 55		beq $019bf9			beq 	_TSQuotedString
.019ba4	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.019ba6	f0 56		beq $019bfe			beq 	_TSDecimal
.019ba8	20 20 9c	jsr $019c20			jsr 	TOKCapitalise 				; make U/C
.019bab	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.019bad	d0 05		bne $019bb4			bne 	_TSNoRemCheck
.019baf	20 03 9c	jsr $019c03			jsr 	TOKCheckREM
.019bb2	b0 d3		bcs $019b87			bcs 	_TSMainLoop 				; and if REM okay, go back.
.019bb4					_TSNoRemCheck:
.019bb4	88		dey				dey 								; point to character
.019bb5	20 e9 9a	jsr $019ae9			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.019bb8	b0 cd		bcs $019b87			bcs 	_TSMainLoop					; true if tokenised okay.
.019bba	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.019bbc	20 20 9c	jsr $019c20			jsr 	TOKCapitalise
.019bbf	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.019bc1	90 04		bcc $019bc7			bcc 	_TSSingle
.019bc3	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019bc5	90 0d		bcc $019bd4			bcc 	_TSAlphaNumeric
.019bc7					_TSSingle:
.019bc7	c8		iny				iny 								; skip over output
.019bc8	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.019bca	09 80		ora #$80			ora 	#128
.019bcc	f0 b9		beq $019b87			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.019bce	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bd1	e8		inx				inx
.019bd2	80 b3		bra $019b87			bra 	_TSMainLoop
.019bd4					_TSAlphaNumeric:
.019bd4	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.019bd6	20 20 9c	jsr $019c20			jsr 	TOKCapitalise
.019bd9	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.019bdb	90 aa		bcc $019b87			bcc 	_TSMainLoop
.019bdd	c9 3a		cmp #$3a			cmp 	#"9"+1
.019bdf	90 0a		bcc $019beb			bcc 	_TSANOkay
.019be1	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.019be3	90 a2		bcc $019b87			bcc 	_TSMainLoop
.019be5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019be7	b0 9e		bcs $019b87			bcs 	_TSMainLoop
.019be9	29 3f		and #$3f			and 	#63 						; write it out
.019beb					_TSANOkay:
.019beb	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bee	e8		inx				inx
.019bef	c8		iny				iny
.019bf0	80 e2		bra $019bd4			bra 	_TSAlphaNumeric
.019bf2	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.019bf4	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019bf7	8a		txa				txa 								; return length of tokenised line in bytes.
.019bf8	60		rts				rts
.019bf9					_TSQuotedString:
.019bf9	20 59 9c	jsr $019c59			jsr 	TokeniseQuotedString
.019bfc	80 89		bra $019b87			bra 	_TSMainLoop
.019bfe					_TSDecimal:
.019bfe	20 7f 9c	jsr $019c7f			jsr 	TokeniseDecimalString
.019c01	80 84		bra $019b87			bra 	_TSMainLoop
.019c03					TOKCheckREM:
.019c03	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.019c05	20 20 9c	jsr $019c20			jsr 	TOKCapitalise
.019c08	c9 45		cmp #$45			cmp 	#"E"
.019c0a	d0 12		bne $019c1e			bne 	_TCRFail
.019c0c	c8		iny				iny
.019c0d	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.019c0f	88		dey				dey
.019c10	20 20 9c	jsr $019c20			jsr 	TOKCapitalise
.019c13	c9 4d		cmp #$4d			cmp 	#"M"
.019c15	d0 07		bne $019c1e			bne 	_TCRFail
.019c17	c8		iny				iny									; point to first character
.019c18	c8		iny				iny
.019c19	20 2b 9c	jsr $019c2b			jsr 	TokeniseREMString 			; tokenise REM
.019c1c	38		sec				sec
.019c1d	60		rts				rts
.019c1e					_TCRFail:
.019c1e	18		clc				clc
.019c1f	60		rts				rts
.019c20					TOKCapitalise:
.019c20	c9 61		cmp #$61			cmp 	#"a"
.019c22	90 06		bcc $019c2a			bcc 	_TOKCExit
.019c24	c9 7b		cmp #$7b			cmp 	#"z"+1
.019c26	b0 02		bcs $019c2a			bcs 	_TOKCExit
.019c28	49 20		eor #$20			eor 	#$20
.019c2a					_TOKCExit:
.019c2a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.019c2b					TokeniseREMString:
.019c2b	86 10		stx $10				stx 	zTemp1 						; save position
.019c2d	a9 ff		lda #$ff			lda 	#$FF 						; write marker
.019c2f	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c32	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.019c35	e8		inx				inx 								; bump, and one space for the count.
.019c36	e8		inx				inx
.019c37					_TSRSkip:
.019c37	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c39	c8		iny				iny
.019c3a	c9 20		cmp #$20			cmp 	#" "
.019c3c	f0 f9		beq $019c37			beq 	_TSRSkip
.019c3e	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.019c40	f0 31		beq $019c73			beq 	SequenceExit 				; ... that's it.
.019c42					_TSRCopy:
.019c42	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.019c45	e8		inx				inx
.019c46	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.019c48	f0 05		beq $019c4f			beq 	_TSRExit 					; zero is exit
.019c4a	c8		iny				iny 								; bump pointer
.019c4b	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.019c4d	d0 f3		bne $019c42			bne 	_TSRCopy
.019c4f					_TSRExit:
.019c4f	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.019c52	c9 20		cmp #$20			cmp 	#" "
.019c54	d0 1d		bne $019c73			bne 	SequenceExit
.019c56	ca		dex				dex 								; go back - will bump into $FF eventually.
.019c57	80 f6		bra $019c4f			bra 	_TSRExit
.019c59					TokeniseQuotedString:
.019c59	86 10		stx $10				stx 	zTemp1 						; save position
.019c5b	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019c5d	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c60	e8		inx				inx 								; bump, and one space for the count.
.019c61	e8		inx				inx
.019c62					_TSQCopy:
.019c62	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c64	c9 20		cmp #$20			cmp 	#" "
.019c66	90 0b		bcc $019c73			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.019c68	c8		iny				iny
.019c69	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.019c6b	f0 06		beq $019c73			beq 	SequenceExit
.019c6d	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.019c70	e8		inx				inx
.019c71	80 ef		bra $019c62			bra 	_TSQCopy
.019c73					SequenceExit:
.019c73	8a		txa				txa 								; current position
.019c74	38		sec				sec 								; subtract start.
.019c75	e5 10		sbc $10				sbc 	zTemp1
.019c77	da		phx				phx 								; copy that in
.019c78	a6 10		ldx $10				ldx 	zTemp1
.019c7a	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.019c7d	fa		plx				plx
.019c7e	60		rts				rts
.019c7f					TokeniseDecimalString:
.019c7f	86 10		stx $10				stx 	zTemp1 						; save position
.019c81	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.019c83	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c86	e8		inx				inx 								; bump, and one space for the count.
.019c87	e8		inx				inx
.019c88	20 a9 9c	jsr $019ca9			jsr 	_TDSCopyNumber 				; copy a number.
.019c8b	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.019c8d	20 20 9c	jsr $019c20			jsr 	TOKCapitalise
.019c90	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.019c92	d0 df		bne $019c73			bne 	SequenceExit 				; exit now.
.019c94	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.019c97	e8		inx				inx
.019c98	c8		iny				iny
.019c99	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.019c9b	c9 2d		cmp #$2d			cmp 	#"-"
.019c9d	d0 05		bne $019ca4			bne 	_TDSNoMinusExponent
.019c9f	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.019ca2	e8		inx				inx
.019ca3	c8		iny				iny
.019ca4					_TDSNoMinusExponent:
.019ca4	20 a9 9c	jsr $019ca9			jsr 	_TDSCopyNumber 				; do the exponent
.019ca7	80 ca		bra $019c73			bra 	SequenceExit
.019ca9					_TDSCopyNumber:
.019ca9	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019cab	c9 30		cmp #$30			cmp 	#"0"
.019cad	90 0b		bcc $019cba			bcc 	_TDSCNExit
.019caf	c9 3a		cmp #$3a			cmp 	#"9"+1
.019cb1	b0 07		bcs $019cba			bcs 	_TDSCNExit
.019cb3	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019cb6	e8		inx				inx
.019cb7	c8		iny				iny
.019cb8	80 ef		bra $019ca9			bra 	_TDSCopyNumber
.019cba					_TDSCNExit:
.019cba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.019cbb					TokeniseConstant:
.019cbb	da		phx				phx 								; save X
.019cbc	a2 00		ldx #$00			ldx 	#0
.019cbe	20 99 a2	jsr $01a299			jsr 	IntFromStringY 				; get the integer out.
.019cc1	b0 37		bcs $019cfa			bcs 	_TCQ 						; should not happen.
.019cc3	fa		plx				plx 								; restore X.
.019cc4	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.019cc6	85 10		sta $10				sta 	zTemp1
.019cc8					_TCRotate:
.019cc8	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.019cca	29 c0		and #$c0			and 	#$C0
.019ccc	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.019cce	05 82		ora $82				ora 	XS_Mantissa+2
.019cd0	05 83		ora $83				ora 	XS_Mantissa+3
.019cd2	f0 16		beq $019cea			beq 	_TCDone						; if so, at the bottom.
.019cd4	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.019cd6	29 3f		and #$3f			and 	#$3F
.019cd8	48		pha				pha
.019cd9	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.019cdb	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.019cdd					_TCShiftRight:
.019cdd	46 83		lsr $83				lsr 	XS_Mantissa+3
.019cdf	66 82		ror $82				ror 	XS_Mantissa+2
.019ce1	66 81		ror $81				ror 	XS_Mantissa+1
.019ce3	66 80		ror $80				ror 	XS_Mantissa+0
.019ce5	3a		dec a				dec 	a
.019ce6	d0 f5		bne $019cdd			bne 	_TCShiftRight
.019ce8	80 de		bra $019cc8			bra 	_TCRotate 					; and go round again.
.019cea	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.019cec					_TCWrite:
.019cec	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.019cee	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019cf1	e8		inx				inx
.019cf2	c6 10		dec $10				dec 	zTemp1 						; done all of them
.019cf4	30 03		bmi $019cf9			bmi 	_TCExit 					; no , more to pop
.019cf6	68		pla				pla
.019cf7	80 f3		bra $019cec			bra 	_TCWrite 					; until everything's off.
.019cf9					_TCExit:
.019cf9	60		rts				rts
.019cfa					_TCQ:
.019cfa	20 86 85	jsr $018586			jsr ERR_Handler
>019cfd	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019d00					VariableFind:
.019d00	20 6b 9d	jsr $019d6b			jsr 	VariableExtract 		; find out all about it ....
.019d03	20 04 a0	jsr $01a004			jsr 	VariableLocate 			; does it already exist ?
.019d06	b0 03		bcs $019d0b			bcs 	_VFExists 				; if so, use that.
.019d08	20 f7 9d	jsr $019df7			jsr 	VariableCreate 			; otherwise create it.
.019d0b					_VFExists:
.019d0b	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.019d0d	29 01		and #$01			and 	#1
.019d0f	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d11	d0 28		bne $019d3b			bne 	_VFSingleElement
.019d13					_VFNextIndex:
.019d13	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019d15	48		pha				pha
.019d16	a5 25		lda $25				lda 	zVarDataPtr+1
.019d18	48		pha				pha
.019d19	a5 26		lda $26				lda 	zVarType
.019d1b	48		pha				pha
.019d1c	20 ef 93	jsr $0193ef			jsr 	EvaluateInteger 		; calculate the index.
.019d1f	68		pla				pla 							; restore and index.
.019d20	85 26		sta $26				sta 	zVarType
.019d22	68		pla				pla
.019d23	85 25		sta $25				sta 	zVarDataPtr+1
.019d25	68		pla				pla
.019d26	85 24		sta $24				sta 	zVarDataPtr
.019d28	20 82 9e	jsr $019e82			jsr 	ArrayIndexFollow 		; do the index.
.019d2b	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.019d2d	29 01		and #$01			and 	#1
.019d2f	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019d31	d0 05		bne $019d38			bne 	_VFArrayDone 			; if so then exit.
.019d33	20 43 9a	jsr $019a43			jsr 	CheckNextComma 			; comma should follow
.019d36	80 db		bra $019d13			bra 	_VFNextIndex
.019d38					_VFArrayDone:
.019d38	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 		; check closing right bracket.
.019d3b					_VFSingleElement:
.019d3b	60		rts				rts
.019d3c					VariableClear:
.019d3c	48		pha				pha 							; save registers
.019d3d	da		phx				phx
.019d3e	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019d40	8a		txa				txa
.019d41	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019d44	e8		inx				inx
.019d45	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019d47	d0 f8		bne $019d41			bne 	_VCLoop
.019d49	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019d4b	8d 02 03	sta $0302			sta 	VarMemPtr
.019d4e	a9 20		lda #$20			lda 	#VariableMemory >> 8
.019d50	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019d53	fa		plx				plx 							; restore registers
.019d54	68		pla				pla
.019d55	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019d56					VariableNameError:
.019d56	20 86 85	jsr $018586			jsr ERR_Handler
>019d59	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019d61	61 62 6c 65 20 4e 61 6d 65 00
.019d6b					VariableExtract:
.019d6b	da		phx				phx 							; save X.
.019d6c	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019d6e	8d 95 03	sta $0395			sta 	Var_Type
.019d71	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019d74	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d76	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019d78	f0 dc		beq $019d56			beq 	VariableNameError
.019d7a	c9 1b		cmp #$1b			cmp 	#26+1
.019d7c	b0 d8		bcs $019d56			bcs 	VariableNameError
.019d7e	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019d80					_VECopyBuffer:
.019d80	e8		inx				inx
.019d81	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019d83	f0 d1		beq $019d56			beq 	VariableNameError
.019d85	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019d88	18		clc				clc  							; update the hash value for it.
.019d89	6d 96 03	adc $0396			adc 	Var_Hash
.019d8c	8d 96 03	sta $0396			sta 	Var_Hash
.019d8f	c8		iny				iny
.019d90	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d92	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019d94	f0 0e		beq $019da4			beq 	_VECopyEnd
.019d96	30 0c		bmi $019da4			bmi 	_VECopyEnd
.019d98	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019d9a	90 e4		bcc $019d80			bcc 	_VECopyBuffer
.019d9c	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019d9e	90 04		bcc $019da4			bcc 	_VECopyEnd
.019da0	c9 3a		cmp #$3a			cmp 	#"9"+1
.019da2	90 dc		bcc $019d80			bcc 	_VECopyBuffer
.019da4					_VECopyEnd:
.019da4	c8		iny				iny
.019da5	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019da7	90 04		bcc $019dad			bcc 	_VEDefaultRequired
.019da9	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019dab	90 0b		bcc $019db8			bcc 	_VEHaveType
.019dad					_VEDefaultRequired:
.019dad	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019daf	f0 04		beq $019db5			beq 	_VESetType 				; default set above.
.019db1	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019db4	88		dey				dey
.019db5					_VESetType:
.019db5	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019db8					_VEHaveType:
.019db8	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019dbb	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019dbe	09 80		ora #$80			ora 	#$80
.019dc0	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019dc3	e8		inx				inx 							; offset 3 => length 4.
.019dc4	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019dc7	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019dca	38		sec				sec
.019dcb	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019dcd	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019dce	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019dcf	0a		asl a				asl 	a
.019dd0	0a		asl a				asl 	a
.019dd1	8d 98 03	sta $0398			sta 	Var_HashAddress
.019dd4	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019dd7	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019dd9	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019dda	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019ddd	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019ddf	8d 98 03	sta $0398			sta 	Var_HashAddress
.019de2	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019de4	ad 95 03	lda $0395			lda 	Var_Type
.019de7	c9 b9		cmp #$b9			cmp 	#token_Hash
.019de9	f0 07		beq $019df2			beq 	_VEHaveSize
.019deb	ca		dex				dex
.019dec	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019dee	f0 02		beq $019df2			beq 	_VEHaveSize
.019df0	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019df2					_VEHaveSize:
.019df2	8e 99 03	stx $0399			stx 	Var_DataSize
.019df5	fa		plx				plx
.019df6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019df7					VariableCreate:
.019df7	da		phx				phx
.019df8	5a		phy				phy
.019df9	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019dfc	85 10		sta $10				sta 	zTemp1
.019dfe	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019e01	85 11		sta $11				sta 	zTemp1+1
.019e03	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019e06	18		clc				clc
.019e07	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019e0a	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019e0c	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019e0f	8d 02 03	sta $0302			sta 	VarMemPtr
.019e12	90 03		bcc $019e17			bcc 	_VCNoCarry
.019e14	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019e17					_VCNoCarry:
.019e17	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019e1a	85 12		sta $12				sta 	zTemp2
.019e1c	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019e1e	85 13		sta $13				sta 	zTemp2+1
.019e20	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019e22	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e24	91 10		sta ($10),y			sta 	(zTemp1),y
.019e26	c8		iny				iny
.019e27	b1 12		lda ($12),y			lda 	(zTemp2),y
.019e29	91 10		sta ($10),y			sta 	(zTemp1),y
.019e2b	c8		iny				iny
.019e2c	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019e2f	91 10		sta ($10),y			sta 	(zTemp1),y
.019e31	c8		iny				iny
.019e32	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019e34					_VCCopyName:
.019e34	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019e37	91 10		sta ($10),y			sta 	(zTemp1),y
.019e39	e8		inx				inx
.019e3a	c8		iny				iny
.019e3b	ec 97 03	cpx $0397			cpx 	Var_Length
.019e3e	d0 f4		bne $019e34			bne 	_VCCopyName
.019e40	5a		phy				phy 								; save the data offset.
.019e41	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019e44	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019e46					_VCClearData:
.019e46	91 10		sta ($10),y			sta 	(zTemp1),y
.019e48	c8		iny				iny
.019e49	ca		dex				dex
.019e4a	d0 fa		bne $019e46			bne 	_VCClearData
.019e4c	68		pla				pla 								; offset to the data
.019e4d	18		clc				clc
.019e4e	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019e50	85 24		sta $24				sta 	zVarDataPtr
.019e52	a5 11		lda $11				lda 	zTemp1+1
.019e54	69 00		adc #$00			adc 	#0
.019e56	85 25		sta $25				sta 	zVarDataPtr+1
.019e58	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019e5b	85 26		sta $26				sta 	zVarType
.019e5d	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019e5f	a0 00		ldy #$00			ldy 	#0
.019e61	91 12		sta ($12),y			sta 	(zTemp2),y
.019e63	c8		iny				iny
.019e64	a5 11		lda $11				lda 	zTemp1+1
.019e66	91 12		sta ($12),y			sta 	(zTemp2),y
.019e68	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019e6b	29 01		and #$01			and 	#1
.019e6d	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019e6f	d0 0e		bne $019e7f			bne 	_VCNotArray
.019e71	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019e73	20 19 9f	jsr $019f19			jsr 	ArrayCreate
.019e76	5a		phy				phy 								; save YA at zVarDataPtr
.019e77	a0 00		ldy #$00			ldy 	#0
.019e79	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e7b	c8		iny				iny
.019e7c	68		pla				pla
.019e7d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e7f					_VCNotArray:
.019e7f	7a		ply				ply
.019e80	fa		plx				plx
.019e81	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019e82					ArrayIndexFollow:
.019e82	5a		phy				phy
.019e83	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019e85	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019e87	48		pha				pha
.019e88	c8		iny				iny
.019e89	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e8b	85 25		sta $25				sta 	zVarDataPtr+1
.019e8d	68		pla				pla
.019e8e	85 24		sta $24				sta 	zVarDataPtr
.019e90	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019e92	29 80		and #$80			and 	#$80 						; must be zero.
.019e94	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e96	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e98	d0 59		bne $019ef3			bne 	_AIFError
.019e9a	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019e9c	18		clc				clc
.019e9d	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e9f	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019ea1	c8		iny				iny
.019ea2	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019ea4	08		php				php 								; clear bit 7 retaining borrow.
.019ea5	29 7f		and #$7f			and 	#$7F
.019ea7	28		plp				plp
.019ea8	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019eaa	90 47		bcc $019ef3			bcc 	_AIFError 					; eror if size-current < 0
.019eac	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019eae	0a		asl a				asl 	a 							; (e.g. index * 2)
.019eaf	85 10		sta $10				sta 	zTemp1
.019eb1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019eb3	2a		rol a				rol 	a
.019eb4	85 11		sta $11				sta 	zTemp1+1
.019eb6	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019eb8	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019eba	30 1d		bmi $019ed9			bmi 	_AIFCalculate
.019ebc	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.019ebe	a5 26		lda $26				lda 	zVarType 					; check that type
.019ec0	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019ec2	f0 15		beq $019ed9			beq 	_AIFCalculate
.019ec4	06 10		asl $10				asl 	zTemp1			 			; double the index
.019ec6	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019ec8	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019eca	f0 0d		beq $019ed9			beq 	_AIFCalculate
.019ecc	18		clc				clc 								; add the original mantissa in again
.019ecd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019ecf	65 10		adc $10				adc 	zTemp1
.019ed1	85 10		sta $10				sta 	zTemp1
.019ed3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ed5	65 11		adc $11				adc 	zTemp1+1
.019ed7	85 11		sta $11				sta 	zTemp1+1
.019ed9					_AIFCalculate:
.019ed9	18		clc				clc 								; add index x 2,4 or 5 to base
.019eda	a5 24		lda $24				lda 	zVarDataPtr
.019edc	65 10		adc $10				adc 	zTemp1
.019ede	85 24		sta $24				sta 	zVarDataPtr
.019ee0	a5 25		lda $25				lda 	zVarDataPtr+1
.019ee2	65 11		adc $11				adc 	zTemp1+1
.019ee4	85 25		sta $25				sta 	zVarDataPtr+1
.019ee6	18		clc				clc 								; add 2 more for the length prefix.
.019ee7	a5 24		lda $24				lda 	zVarDataPtr
.019ee9	69 02		adc #$02			adc 	#2
.019eeb	85 24		sta $24				sta 	zVarDataPtr
.019eed	90 02		bcc $019ef1			bcc 	_AIFNoBump
.019eef	e6 25		inc $25				inc 	zVarDataPtr+1
.019ef1					_AIFNoBump:
.019ef1	7a		ply				ply
.019ef2	60		rts				rts
.019ef3					_AIFError:
.019ef3	20 86 85	jsr $018586			jsr ERR_Handler
>019ef6	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019efe	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019f06					ArrayResetDefault:
.019f06	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019f08	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019f0b	a9 00		lda #$00			lda 	#0
.019f0d	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019f10	a9 ff		lda #$ff			lda 	#$FF
.019f12	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019f15	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019f18	60		rts				rts
.019f19					ArrayCreate:
.019f19	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019f1c	0a		asl a				asl 	a
.019f1d	85 10		sta $10				sta 	zTemp1
.019f1f	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f22	2a		rol a				rol 	a
.019f23	85 11		sta $11				sta 	zTemp1+1
.019f25	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019f28	10 22		bpl $019f4c			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019f2a	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019f2d	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019f2f	f0 1b		beq $019f4c			beq 	_ACSized
.019f31	06 10		asl $10				asl 	zTemp1 						; double again
.019f33	26 11		rol $11				rol 	zTemp1+1
.019f35	b0 6f		bcs $019fa6			bcs 	ArrayIndexError 			; too large.
.019f37	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019f39	f0 11		beq $019f4c			beq 	_ACSized
.019f3b	18		clc				clc 								; add original value x 5 for reals.
.019f3c	a5 10		lda $10				lda 	zTemp1
.019f3e	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019f41	85 10		sta $10				sta 	zTemp1
.019f43	a5 11		lda $11				lda 	zTemp1+1
.019f45	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019f48	85 11		sta $11				sta 	zTemp1+1
.019f4a	b0 5a		bcs $019fa6			bcs 	ArrayIndexError
.019f4c					_ACSized:
.019f4c	18		clc				clc
.019f4d	a5 10		lda $10				lda 	zTemp1
.019f4f	69 02		adc #$02			adc 	#2
.019f51	85 10		sta $10				sta 	zTemp1
.019f53	90 04		bcc $019f59			bcc 	_ACNoBump
.019f55	e6 10		inc $10				inc 	zTemp1
.019f57	f0 4d		beq $019fa6			beq 	ArrayIndexError
.019f59					_ACNoBump:
.019f59	18		clc				clc
.019f5a	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019f5d	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019f5f	85 14		sta $14				sta 	zTemp3
.019f61	65 10		adc $10				adc 	zTemp1
.019f63	8d 02 03	sta $0302			sta 	VarMemPtr
.019f66	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019f69	85 13		sta $13				sta 	zTemp2+1
.019f6b	85 15		sta $15				sta 	zTemp3+1
.019f6d	65 11		adc $11				adc 	zTemp1+1
.019f6f	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019f72	85 11		sta $11				sta 	zTemp1+1
.019f74	b0 30		bcs $019fa6			bcs 	ArrayIndexError
.019f76	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019f78					_ACClear:
.019f78	98		tya				tya
.019f79	91 12		sta ($12),y			sta 	(zTemp2),y
.019f7b	e6 12		inc $12				inc 	zTemp2
.019f7d	d0 02		bne $019f81			bne 	_ACCBump
.019f7f	e6 13		inc $13				inc 	zTemp2+1
.019f81					_ACCBump:
.019f81	a5 12		lda $12				lda 	zTemp2
.019f83	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019f86	d0 f0		bne $019f78			bne 	_ACClear
.019f88	a5 13		lda $13				lda 	zTemp2+1
.019f8a	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019f8d	d0 e9		bne $019f78			bne 	_ACClear
.019f8f	a0 00		ldy #$00			ldy 	#0
.019f91	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019f94	91 14		sta ($14),y			sta 	(zTemp3),y
.019f96	c8		iny				iny
.019f97	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f9a	91 14		sta ($14),y			sta 	(zTemp3),y
.019f9c	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019f9f	10 18		bpl $019fb9			bpl 	ACCFillRecursive
.019fa1	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019fa3	a5 14		lda $14				lda 	zTemp3
.019fa5	60		rts				rts
.019fa6					ArrayIndexError:
.019fa6	20 86 85	jsr $018586			jsr ERR_Handler
>019fa9	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019fb1	79 20 69 6e 64 65 78 00
.019fb9					ACCFillRecursive:
.019fb9	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019fbb	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019fbd	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019fbf	c8		iny				iny
.019fc0	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019fc2	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019fc4	91 14		sta ($14),y			sta 	(zTemp3),y
.019fc6	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019fc8	48		pha				pha
.019fc9	a5 15		lda $15				lda 	zTemp3+1
.019fcb	48		pha				pha
.019fcc					_ACCFillLoop:
.019fcc	18		clc				clc
.019fcd	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019fcf	69 02		adc #$02			adc 	#2
.019fd1	85 14		sta $14				sta 	zTemp3
.019fd3	90 02		bcc $019fd7			bcc 	_ACCSkip2
.019fd5	e6 15		inc $15				inc 	zTemp3+1
.019fd7					_ACCSkip2:
.019fd7	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019fd9	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019fdb	c8		iny				iny
.019fdc	11 14		ora ($14),y			ora 	(zTemp3),y
.019fde	d0 21		bne $01a001			bne 	_ACCExit
.019fe0	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019fe2	48		pha				pha
.019fe3	a5 15		lda $15				lda 	zTemp3+1
.019fe5	48		pha				pha
.019fe6	e8		inx				inx
.019fe7	e8		inx				inx
.019fe8	20 19 9f	jsr $019f19			jsr 	ArrayCreate 				; create array recursively.
.019feb	ca		dex				dex
.019fec	ca		dex				dex
.019fed	85 12		sta $12				sta 	zTemp2 						; save A
.019fef	68		pla				pla
.019ff0	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019ff2	68		pla				pla
.019ff3	85 14		sta $14				sta 	zTemp3
.019ff5	98		tya				tya 								; write high bye from Y
.019ff6	a0 01		ldy #$01			ldy 	#1
.019ff8	91 14		sta ($14),y			sta 	(zTemp3),y
.019ffa	88		dey				dey 								; write low byte out.
.019ffb	a5 12		lda $12				lda 	zTemp2
.019ffd	91 14		sta ($14),y			sta 	(zTemp3),y
.019fff	80 cb		bra $019fcc			bra 	_ACCFillLoop 				; and try again.
.01a001					_ACCExit:
.01a001	7a		ply				ply 								; restore the original address
.01a002	68		pla				pla
.01a003	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.01a004					VariableLocate:
.01a004	da		phx				phx
.01a005	5a		phy				phy
.01a006	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.01a009	85 12		sta $12				sta 	zTemp2 						; points to first address.
.01a00b	a9 03		lda #$03			lda 	#HashTableBase >> 8
.01a00d	85 13		sta $13				sta 	zTemp2+1
.01a00f	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.01a011	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a013	aa		tax				tax
.01a014	c8		iny				iny
.01a015	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a017	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.01a019	86 12		stx $12				stx 	zTemp2
.01a01b	05 12		ora $12				ora 	zTemp2 						; got zero
.01a01d	18		clc				clc
.01a01e	f0 25		beq $01a045			beq 	_VLExit 					; if so, then fail as end of chain.
.01a020	c8		iny				iny 								; point to hash (offset + 2)
.01a021	b1 12		lda ($12),y			lda 	(zTemp2),y
.01a023	cd 96 03	cmp $0396			cmp 	Var_Hash
.01a026	d0 e7		bne $01a00f			bne 	_VLNext 					; try next if different.
.01a028					_VLCompare:
.01a028	c8		iny				iny 								; next character
.01a029	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.01a02b	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.01a02e	d0 df		bne $01a00f			bne 	_VLNext 					; fail if different, try next.
.01a030	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.01a031	90 f5		bcc $01a028			bcc 	_VLCompare
.01a033	98		tya				tya
.01a034	38		sec				sec 								; add 1 as Y points to last character
.01a035	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01a037	85 24		sta $24				sta 	zVarDataPtr
.01a039	a5 13		lda $13				lda 	zTemp2+1
.01a03b	69 00		adc #$00			adc 	#0
.01a03d	85 25		sta $25				sta 	zVarDataPtr+1
.01a03f	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.01a042	85 26		sta $26				sta 	zVarType
.01a044	38		sec				sec 								; return CS
.01a045	7a		ply		_VLExit:ply
.01a046	fa		plx				plx
.01a047	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.01a048					VariableGet:
.01a048	5a		phy				phy
.01a049	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.01a04b	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a04d	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a04f	c8		iny				iny
.01a050	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a052	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a054	c8		iny				iny
.01a055	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.01a057	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a059	f0 2c		beq $01a087			beq 	_VGString
.01a05b	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01a05d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a05f	c8		iny				iny
.01a060	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a062	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a064	c8		iny				iny
.01a065	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01a067	95 85		sta $85,x			sta 	XS_Type,x
.01a069	a5 26		lda $26				lda 	zVarType
.01a06b	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01a06d	f0 28		beq $01a097			beq 	_VGExit
.01a06f	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01a071	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01a073	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01a075	95 84		sta $84,x			sta 	XS_Exponent,x
.01a077	f0 1e		beq $01a097			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01a079	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01a07b	48		pha				pha
.01a07c	29 80		and #$80			and 	#$80
.01a07e	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.01a080	68		pla				pla
.01a081	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.01a083	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01a085	80 10		bra $01a097			bra 	_VGExit
.01a087					_VGString:
.01a087	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01a089	95 85		sta $85,x			sta 	XS_Type,x
.01a08b	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.01a08d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a08f	d0 06		bne $01a097			bne 	_VGExit 					; if not, exit.
.01a091	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.01a093	a9 27		lda #$27			lda 	#zNullString
.01a095	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01a097					_VGExit:
.01a097	7a		ply				ply
.01a098	60		rts				rts
.01a099					VariableSet:
.01a099	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01a09b	29 02		and #$02			and 	#2 							; if so, it has to be
.01a09d	d0 4b		bne $01a0ea			bne 	_VSString
.01a09f	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.01a0a1	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0a3	f0 42		beq $01a0e7			beq 	_VSBadType
.01a0a5	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01a0a7	f0 05		beq $01a0ae			beq 	_VSMakeInt
.01a0a9	20 01 a6	jsr $01a601			jsr 	FPUToFloat
.01a0ac	80 03		bra $01a0b1			bra 	_VSCopy
.01a0ae					_VSMakeInt:
.01a0ae	20 4d a6	jsr $01a64d			jsr 	FPUToInteger
.01a0b1					_VSCopy:
.01a0b1	5a		phy				phy
.01a0b2	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01a0b4	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a0b6	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0b8	c8		iny				iny
.01a0b9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0bb	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0bd	c8		iny				iny
.01a0be	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0c0	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0c2	c8		iny				iny
.01a0c3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0c5	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0c7	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.01a0c9	c9 bb		cmp #$bb			cmp 	#token_Percent
.01a0cb	f0 18		beq $01a0e5			beq 	_VSExit
.01a0cd	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01a0cf	0a		asl a				asl 	a
.01a0d0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01a0d2	08		php				php
.01a0d3	0a		asl a				asl 	a
.01a0d4	28		plp				plp
.01a0d5	6a		ror a				ror 	a
.01a0d6	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0d8	c8		iny				iny
.01a0d9	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.01a0db	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0dd	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.01a0df	50 04		bvc $01a0e5			bvc 	_VSExit
.01a0e1	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.01a0e3	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0e5					_VSExit:
.01a0e5	7a		ply				ply
.01a0e6	60		rts				rts
.01a0e7					_VSBadType:
.01a0e7	4c 67 85	jmp $018567			jmp 	TypeError
.01a0ea					_VSString:
.01a0ea	a5 26		lda $26				lda 	zVarType 					; type must be $
.01a0ec	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0ee	d0 f7		bne $01a0e7			bne 	_VSBadType
.01a0f0	da		phx				phx
.01a0f1	5a		phy				phy
.01a0f2	20 4b 9a	jsr $019a4b			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01a0f5	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01a0f7	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0f9	88		dey				dey 								; save low byte
.01a0fa	8a		txa				txa
.01a0fb	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0fd	7a		ply				ply 								; and exit.
.01a0fe	fa		plx				plx
.01a0ff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01a100					MulInteger32:
.01a100	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01a102	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01a104	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a106	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01a108	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a10a	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01a10c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a10e	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.01a110	a9 00		lda #$00			lda 	#0
.01a112	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.01a114	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a116	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a118	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a11a					_BFMMultiply:
.01a11a	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01a11c	29 01		and #$01			and 	#1
.01a11e	f0 03		beq $01a123			beq 	_BFMNoAdd
.01a120	20 87 95	jsr $019587			jsr 	AddInteger32 					; co-opt this code
.01a123					_BFMNoAdd:
.01a123	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01a125	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01a127	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01a129	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01a12b	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01a12d	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.01a12f	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01a131	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01a133	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01a135	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01a137	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01a139	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01a13b	d0 dd		bne $01a11a			bne 	_BFMMultiply
.01a13d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01a13e					DivInteger32:
.01a13e	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.01a140	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01a142	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a144	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a146	d0 14		bne $01a15c			bne 	_BFDOkay
.01a148	20 86 85	jsr $018586			jsr ERR_Handler
>01a14b	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01a153	20 62 79 20 5a 65 72 6f 00
.01a15c					_BFDOkay:
.01a15c	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01a15e	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01a160	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01a162	85 1e		sta $1e				sta 	zLTemp1+2
.01a164	85 1f		sta $1f				sta 	zLTemp1+3
.01a166	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01a169	20 c0 a1	jsr $01a1c0			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01a16c	da		phx				phx
.01a16d	e8		inx				inx
.01a16e	e8		inx				inx
.01a16f	e8		inx				inx
.01a170	e8		inx				inx
.01a171	e8		inx				inx
.01a172	e8		inx				inx
.01a173	20 c0 a1	jsr $01a1c0			jsr 	CheckIntegerNegate
.01a176	fa		plx				plx
.01a177	5a		phy				phy 								; Y is the counter
.01a178	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01a17a					_BFDLoop:
.01a17a	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01a17c	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a17e	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a180	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a182	26 1c		rol $1c				rol 	zLTemp1
.01a184	26 1d		rol $1d				rol 	zLTemp1+1
.01a186	26 1e		rol $1e				rol 	zLTemp1+2
.01a188	26 1f		rol $1f				rol 	zLTemp1+3
.01a18a	38		sec				sec
.01a18b	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01a18d	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a18f	48		pha				pha
.01a190	a5 1d		lda $1d				lda 	zLTemp1+1
.01a192	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a194	48		pha				pha
.01a195	a5 1e		lda $1e				lda 	zLTemp1+2
.01a197	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a199	48		pha				pha
.01a19a	a5 1f		lda $1f				lda 	zLTemp1+3
.01a19c	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a19e	90 13		bcc $01a1b3			bcc 	_BFDNoAdd
.01a1a0	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.01a1a2	68		pla				pla
.01a1a3	85 1e		sta $1e				sta 	zLTemp1+2
.01a1a5	68		pla				pla
.01a1a6	85 1d		sta $1d				sta 	zLTemp1+1
.01a1a8	68		pla				pla
.01a1a9	85 1c		sta $1c				sta 	zLTemp1+0
.01a1ab	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01a1ad	09 01		ora #$01			ora 	#1
.01a1af	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1b1	80 03		bra $01a1b6			bra 	_BFDNext
.01a1b3					_BFDNoAdd:
.01a1b3	68		pla				pla 								; Throw away the intermediate calculations
.01a1b4	68		pla				pla
.01a1b5	68		pla				pla
.01a1b6					_BFDNext:
.01a1b6	88		dey				dey
.01a1b7	d0 c1		bne $01a17a			bne 	_BFDLoop
.01a1b9	7a		ply				ply 								; restore Y
.01a1ba	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.01a1bd	b0 06		bcs $01a1c5			bcs		IntegerNegateAlways 		; negate the result
.01a1bf	60		rts				rts
.01a1c0					CheckIntegerNegate:
.01a1c0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.01a1c2	30 01		bmi $01a1c5			bmi 	IntegerNegateAlways 		; if so negate it
.01a1c4	60		rts				rts
.01a1c5					IntegerNegateAlways:
.01a1c5	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.01a1c8	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.01a1c9	a9 00		lda #$00			lda 	#0
.01a1cb	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a1cd	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a1cf	a9 00		lda #$00			lda 	#0
.01a1d1	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a1d3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1d5	a9 00		lda #$00			lda 	#0
.01a1d7	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a1d9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1db	a9 00		lda #$00			lda 	#0
.01a1dd	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a1df	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1e1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01a1e2					INTToString:
.01a1e2	48		pha				pha
.01a1e3	5a		phy				phy
.01a1e4	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01a1e6	10 08		bpl $01a1f0			bpl 		_ITSNotMinus
.01a1e8	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a1ea	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter
.01a1ed	20 c5 a1	jsr $01a1c5			jsr 		IntegerNegateAlways 	; negate the number.
.01a1f0					_ITSNotMinus:
.01a1f0	a9 00		lda #$00			lda 		#0
.01a1f2	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01a1f5	8a		txa				txa 								; use Y for the mantissa index.
.01a1f6	a8		tay				tay
.01a1f7	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01a1f9					_ITSNextSubtractor:
.01a1f9	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01a1fb	8d 9b 03	sta $039b			sta 		NumConvCount
.01a1fe					_ITSSubtract:
.01a1fe	38		sec				sec
.01a1ff	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01a202	ff 60 a2 01	sbc $01a260,x			sbc 		_ITSSubtractors+0,x
.01a206	48		pha				pha
.01a207	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01a20a	ff 61 a2 01	sbc $01a261,x			sbc 		_ITSSubtractors+1,x
.01a20e	48		pha				pha
.01a20f	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01a212	ff 62 a2 01	sbc $01a262,x			sbc 		_ITSSubtractors+2,x
.01a216	48		pha				pha
.01a217	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01a21a	ff 63 a2 01	sbc $01a263,x			sbc 		_ITSSubtractors+3,x
.01a21e	90 14		bcc $01a234			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01a220	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01a223	68		pla				pla
.01a224	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01a227	68		pla				pla
.01a228	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01a22b	68		pla				pla
.01a22c	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.01a22f	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.01a232	80 ca		bra $01a1fe			bra 		_ITSSubtract 			; go round again.
.01a234					_ITSCantSubtract:
.01a234	68		pla				pla 								; throw away interim answers
.01a235	68		pla				pla
.01a236	68		pla				pla
.01a237	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01a23a	c9 30		cmp #$30			cmp 		#"0"
.01a23c	d0 05		bne $01a243			bne 		_ITSOutputDigit
.01a23e	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01a241	10 09		bpl $01a24c			bpl	 		_ITSGoNextSubtractor
.01a243					_ITSOutputDigit:
.01a243	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.01a246	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01a249	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter 		; output it.
.01a24c					_ITSGoNextSubtractor:
.01a24c	e8		inx				inx 								; next dword
.01a24d	e8		inx				inx
.01a24e	e8		inx				inx
.01a24f	e8		inx				inx
.01a250	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01a252	d0 a5		bne $01a1f9			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01a254	98		tya				tya 								; X is back as the mantissa index
.01a255	aa		tax				tax
.01a256	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01a258	09 30		ora #$30			ora 		#"0"
.01a25a	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter
.01a25d	7a		ply				ply 								; and exit
.01a25e	68		pla				pla
.01a25f	60		rts				rts
.01a260					_ITSSubtractors:
>01a260	00 ca 9a 3b					.dword 		1000000000
>01a264	00 e1 f5 05					.dword 		100000000
>01a268	80 96 98 00					.dword 		10000000
>01a26c	40 42 0f 00					.dword 		1000000
>01a270	a0 86 01 00					.dword 		100000
>01a274	10 27 00 00					.dword 		10000
>01a278	e8 03 00 00					.dword 		1000
>01a27c	64 00 00 00					.dword 		100
>01a280	0a 00 00 00					.dword 		10
.01a284					_ITSSubtractorsEnd:
.01a284					ITSOutputCharacter:
.01a284	48		pha				pha
.01a285	da		phx				phx
.01a286	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01a289	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01a28c	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01a28e	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.01a291	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.01a294	fa		plx				plx
.01a295	68		pla				pla
.01a296	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01a297					IntFromString:
.01a297	a0 00		ldy #$00			ldy 	#0
.01a299					IntFromStringY:
.01a299	a9 00		lda #$00			lda 	#0
.01a29b	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.01a29e	48		pha				pha
.01a29f	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01a2a1	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a2a3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2a5	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2a7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2a9	a9 01		lda #$01			lda 	#1
.01a2ab	95 85		sta $85,x			sta 	XS_Type,x
.01a2ad					_IFSLoop:
.01a2ad	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.01a2af	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01a2b1	90 4e		bcc $01a301			bcc 	_IFSExit
.01a2b3	c9 3a		cmp #$3a			cmp 	#"9"+1
.01a2b5	b0 4a		bcs $01a301			bcs 	_IFSExit
.01a2b7	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01a2b9	c9 0c		cmp #$0c			cmp 	#12
.01a2bb	b0 4e		bcs $01a30b			bcs 	_IFSOverflow
.01a2bd	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a2bf	48		pha				pha
.01a2c0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a2c2	48		pha				pha
.01a2c3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a2c5	48		pha				pha
.01a2c6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a2c8	48		pha				pha
.01a2c9	20 20 a3	jsr $01a320			jsr 	IFSX1ShiftLeft 				; double
.01a2cc	20 20 a3	jsr $01a320			jsr 	IFSX1ShiftLeft 				; x 4
.01a2cf	18		clc				clc 								; add saved value x 5
.01a2d0	68		pla				pla
.01a2d1	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2d3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2d5	68		pla				pla
.01a2d6	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a2d8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a2da	68		pla				pla
.01a2db	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a2dd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a2df	68		pla				pla
.01a2e0	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a2e2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a2e4	20 20 a3	jsr $01a320			jsr 	IFSX1ShiftLeft 				; x 10
.01a2e7	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a2ea	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.01a2ec	29 0f		and #$0f			and 	#15
.01a2ee	c8		iny				iny
.01a2ef	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2f1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2f3	90 b8		bcc $01a2ad			bcc 	_IFSLoop
.01a2f5	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a2f7	d0 b4		bne $01a2ad			bne 	_IFSLoop
.01a2f9	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a2fb	d0 b0		bne $01a2ad			bne 	_IFSLoop
.01a2fd	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a2ff	80 ac		bra $01a2ad			bra 	_IFSLoop
.01a301					_IFSExit:
.01a301	98		tya				tya 								; get offset
.01a302					_IFSOkay:
.01a302	38		sec				sec
.01a303	ad 9c 03	lda $039c			lda 	ExpTemp
.01a306	f0 01		beq $01a309			beq 	_IFSSkipFail
.01a308	18		clc				clc
.01a309					_IFSSkipFail:
.01a309	68		pla				pla 								; and exit.
.01a30a	60		rts				rts
.01a30b					_IFSOverflow:
.01a30b	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a30e	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a316	20 6f 76 65 72 66 6c 6f 77 00
.01a320					IFSX1ShiftLeft:
.01a320	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a322	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a324	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a326	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a328	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a329					FPSubtract:
.01a329	48		pha				pha
.01a32a	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a32c	49 80		eor #$80			eor 	#$80
.01a32e	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a330	68		pla				pla 								; --- and fall through ---
.01a331					FPAdd:
.01a331	48		pha				pha
.01a332	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a334	d0 05		bne $01a33b			bne 	_FPA_NegativeLHS
.01a336	20 52 a3	jsr $01a352			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a339	68		pla				pla
.01a33a	60		rts				rts
.01a33b					_FPA_NegativeLHS:
.01a33b	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a33d	49 80		eor #$80			eor 	#$80
.01a33f	95 85		sta $85,x			sta 	XS_Type,x
.01a341	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a343	49 80		eor #$80			eor 	#$80
.01a345	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a347	20 52 a3	jsr $01a352			jsr 	FPAdd_Worker 				; do the add calculation.
.01a34a	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a34c	49 80		eor #$80			eor 	#$80
.01a34e	95 85		sta $85,x			sta 	XS_Type,x
.01a350	68		pla				pla
.01a351	60		rts				rts
.01a352					FPAdd_Worker:
.01a352	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a354	70 07		bvs $01a35d			bvs 	_FPAWExit 					; no change.
.01a356	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a358	50 07		bvc $01a361			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a35a	20 bf a5	jsr $01a5bf			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a35d					_FPAWExit:
.01a35d	20 2e a6	jsr $01a62e			jsr 	FPUNormalise 				; normalise the result.
.01a360	60		rts				rts
.01a361					_FPAWMakeSame:
.01a361	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a363	38		sec				sec
.01a364	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a366	f0 16		beq $01a37e			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a368	da		phx				phx 								; save X
.01a369	90 06		bcc $01a371			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a36b	e8		inx				inx
.01a36c	e8		inx				inx
.01a36d	e8		inx				inx
.01a36e	e8		inx				inx
.01a36f	e8		inx				inx
.01a370	e8		inx				inx
.01a371					_FPAWShiftA:
.01a371	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a373	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a375	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a377	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a379	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a37b	fa		plx				plx 								; restore original X
.01a37c	80 e3		bra $01a361			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a37e					_FPAW_DoArithmetic:
.01a37e	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a380	30 20		bmi $01a3a2			bmi 	_FPAW_BNegative
.01a382	c2 30		rep #$30			rep 	#$30
.01a384	18		clc				clc
.01a385	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a387	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a389	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a38b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a38d	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a38f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a391	e2 30		sep #$30			sep 	#$30
.01a393	90 c8		bcc $01a35d			bcc 	_FPAWExit 					; no carry.
.01a395	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a397	38		sec				sec
.01a398	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a39a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a39c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a39e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a3a0	80 bb		bra $01a35d			bra 	_FPAWExit
.01a3a2					_FPAW_BNegative:
.01a3a2	c2 30		rep #$30			rep 	#$30
.01a3a4	38		sec				sec
.01a3a5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a3a7	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a3a9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3ab	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a3ad	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a3af	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3b1	e2 30		sep #$30			sep 	#$30
.01a3b3	b0 09		bcs $01a3be			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a3b5	20 e5 a5	jsr $01a5e5			jsr 	FPUNegateInteger			; negate the mantissa
.01a3b8	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a3ba	49 80		eor #$80			eor 	#$80
.01a3bc	95 85		sta $85,x			sta 	XS_Type,x
.01a3be					_FPAWGoExit:
.01a3be	4c 5d a3	jmp $01a35d			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a3c1					FPD_IsDivZero:
.01a3c1	20 86 85	jsr $018586			jsr ERR_Handler
>01a3c4	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a3cc	20 62 79 20 7a 65 72 6f 00
.01a3d5					FPDivide:
.01a3d5	48		pha				pha
.01a3d6	5a		phy				phy
.01a3d7	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a3d9	70 e6		bvs $01a3c1			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a3db	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a3dd	f0 03		beq $01a3e2			beq 	_FPDCalculateExp
.01a3df					_FPD_Exit:
.01a3df	7a		ply				ply
.01a3e0	68		pla				pla
.01a3e1	60		rts				rts
.01a3e2					_FPDCalculateExp:
.01a3e2	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a3e4	49 ff		eor #$ff			eor 	#$FF
.01a3e6	1a		inc a				inc 	a
.01a3e7	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a3e9	20 b9 a4	jsr $01a4b9			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a3ec	18		clc				clc 	 							; add 1 to the resulting exponent
.01a3ed	69 01		adc #$01			adc 	#1
.01a3ef	b0 54		bcs $01a445			bcs 	_FPD_Overflow 				; which can overflow.
.01a3f1	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3f3	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a3f5	85 1c		sta $1c				sta 	zLTemp1+0
.01a3f7	85 1d		sta $1d				sta 	zLTemp1+1
.01a3f9	85 1e		sta $1e				sta 	zLTemp1+2
.01a3fb	85 1f		sta $1f				sta 	zLTemp1+3
.01a3fd	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a3ff					_FPD_Loop:
.01a3ff	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a400	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a402	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a404	48		pha				pha
.01a405	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a407	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a409	48		pha				pha
.01a40a	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a40c	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a40e	48		pha				pha
.01a40f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a411	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a413	90 13		bcc $01a428			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a415	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a417	68		pla				pla
.01a418	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a41a	68		pla				pla
.01a41b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a41d	68		pla				pla
.01a41e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a420	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.01a422	09 80		ora #$80			ora 	#$80
.01a424	85 1f		sta $1f				sta 	zLTemp1+3
.01a426	80 03		bra $01a42b			bra 	_FPD_Rotates
.01a428					_FPD_NoSubtract:
.01a428	68		pla				pla 								; throw away unwanted results
.01a429	68		pla				pla
.01a42a	68		pla				pla
.01a42b					_FPD_Rotates:
.01a42b	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a42d	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a42f	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a431	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a433	06 1c		asl $1c				asl 	0+zLTemp1
.01a435	26 1d		rol $1d				rol 	1+zLTemp1
.01a437	26 1e		rol $1e				rol 	2+zLTemp1
.01a439	26 1f		rol $1f				rol 	3+zLTemp1
.01a43b	90 02		bcc $01a43f			bcc 	_FPD_NoCarry
.01a43d	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.01a43f					_FPD_NoCarry:
.01a43f	88		dey				dey 								; do 32 times
.01a440	d0 bd		bne $01a3ff			bne 	_FPD_Loop
.01a442	4c 9d a4	jmp $01a49d			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a445					_FPD_Overflow:
.01a445	4c 8b a6	jmp $01a68b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a448					FPMultiply:
.01a448	48		pha				pha
.01a449	5a		phy				phy
.01a44a	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a44c	70 07		bvs $01a455			bvs 	_FPM_Exit
.01a44e	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a450	50 06		bvc $01a458			bvc 	_FPM_CalcExponent
.01a452	20 bf a5	jsr $01a5bf			jsr 	FPUCopyX2ToX1
.01a455					_FPM_Exit:
.01a455	7a		ply				ply
.01a456	68		pla				pla
.01a457	60		rts				rts
.01a458					_FPM_CalcExponent:
.01a458	18		clc				clc
.01a459	20 b9 a4	jsr $01a4b9			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a45c	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a45e	a9 00		lda #$00			lda 	#0
.01a460	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a462	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a464	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a466	85 1f		sta $1f				sta 	zLTemp1+3
.01a468	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a46a					_FPM_Loop:
.01a46a	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a46c	29 01		and #$01			and 	#1
.01a46e	18		clc				clc 								; clear carry for the long rotate.
.01a46f	f0 19		beq $01a48a			beq 	_FPM_NoAddition
.01a471	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a472	a5 1c		lda $1c				lda 	zLTemp1+0
.01a474	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a476	85 1c		sta $1c				sta 	zLTemp1+0
.01a478	a5 1d		lda $1d				lda 	zLTemp1+1
.01a47a	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a47c	85 1d		sta $1d				sta 	zLTemp1+1
.01a47e	a5 1e		lda $1e				lda 	zLTemp1+2
.01a480	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a482	85 1e		sta $1e				sta 	zLTemp1+2
.01a484	a5 1f		lda $1f				lda 	zLTemp1+3
.01a486	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a488	85 1f		sta $1f				sta 	zLTemp1+3
.01a48a					_FPM_NoAddition:
.01a48a	66 1f		ror $1f				ror 	3+zLTemp1
.01a48c	66 1e		ror $1e				ror 	2+zLTemp1
.01a48e	66 1d		ror $1d				ror 	1+zLTemp1
.01a490	66 1c		ror $1c				ror 	0+zLTemp1
.01a492	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a494	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a496	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a498	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a49a	88		dey				dey
.01a49b	d0 cd		bne $01a46a			bne 	_FPM_Loop 					; do this 32 times.
.01a49d					FPM_CopySignNormalize:
.01a49d	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a49f	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a4a1	a5 1d		lda $1d				lda 	zLTemp1+1
.01a4a3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a4a5	a5 1e		lda $1e				lda 	zLTemp1+2
.01a4a7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a4a9	a5 1f		lda $1f				lda 	zLTemp1+3
.01a4ab	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a4ad	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a4af	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a4b1	95 85		sta $85,x			sta 	XS_Type,x
.01a4b3	20 2e a6	jsr $01a62e			jsr 	FPUNormalise 				; normalise and exit.
.01a4b6	7a		ply				ply
.01a4b7	68		pla				pla
.01a4b8	60		rts				rts
.01a4b9					FPCalculateExponent:
.01a4b9	18		clc				clc
.01a4ba	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a4bc	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a4be	b0 08		bcs $01a4c8			bcs 	_FPCECarry 					; carry out ?
.01a4c0	10 03		bpl $01a4c5			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a4c2	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a4c4	60		rts				rts
.01a4c5					_FPCEExpZero:
.01a4c5	a9 00		lda #$00			lda 	#0
.01a4c7	60		rts				rts
.01a4c8					_FPCECarry:
.01a4c8	30 03		bmi $01a4cd			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a4ca	09 80		ora #$80			ora 	#$80 						; put in right range
.01a4cc	60		rts				rts
.01a4cd					_FPCEOverflow:
.01a4cd	4c 8b a6	jmp $01a68b			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a4d0					FPFractionalPart:
.01a4d0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a4d2	38		sec				sec 								; this flag tells us to keep the fractional part
.01a4d3	30 0d		bmi $01a4e2			bmi 	FPGetPart
.01a4d5	60		rts				rts
.01a4d6					FPIntegerPart:
.01a4d6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a4d8	18		clc				clc 								; this flag says keep the integer part.
.01a4d9	30 07		bmi $01a4e2			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a4db	48		pha				pha
.01a4dc	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a4de	95 85		sta $85,x			sta 	XS_Type,x
.01a4e0	68		pla				pla
.01a4e1	60		rts				rts
.01a4e2					FPGetPart:
.01a4e2	48		pha				pha
.01a4e3	5a		phy				phy 								; save Y
.01a4e4	08		php				php 								; save action
.01a4e5	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a4e7	70 59		bvs $01a542			bvs 	_FPGP_Exit 					; then do nothing.
.01a4e9	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a4eb	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a4ed	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a4ef	85 1e		sta $1e				sta 	zLTemp1+2
.01a4f1	85 1f		sta $1f				sta 	zLTemp1+3
.01a4f3	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a4f5	38		sec				sec
.01a4f6	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a4f8	f0 12		beq $01a50c			beq 	_FPGP_NoShift 				; ... if any
.01a4fa	c9 20		cmp #$20			cmp 	#32
.01a4fc	90 02		bcc $01a500			bcc 	_FPGP_NotMax
.01a4fe	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a500					_FPGP_NotMax:
.01a500	a8		tay				tay 								; Y is the mask shift count.
.01a501					_FPGP_ShiftMask:
.01a501	46 1f		lsr $1f				lsr 	3+zLTemp1
.01a503	66 1e		ror $1e				ror 	2+zLTemp1
.01a505	66 1d		ror $1d				ror 	1+zLTemp1
.01a507	66 1c		ror $1c				ror 	0+zLTemp1
.01a509	88		dey				dey
.01a50a	d0 f5		bne $01a501			bne 	_FPGP_ShiftMask
.01a50c					_FPGP_NoShift:
.01a50c	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a50e	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a511					_FPGP_MaskLoop:
.01a511	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.01a514	28		plp				plp 								; if CC we keep the top part, so we
.01a515	08		php				php		 							; flip the mask.
.01a516	b0 02		bcs $01a51a			bcs		_FPGP_NoFlip
.01a518	49 ff		eor #$ff			eor 	#$FF
.01a51a					_FPGP_NoFlip:
.01a51a	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a51c	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a51e	e8		inx				inx
.01a51f	c8		iny				iny
.01a520	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a522	d0 ed		bne $01a511			bne 	_FPGP_MaskLoop
.01a524	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a527	28		plp				plp
.01a528	08		php				php 								; get action flag on the stack
.01a529	90 04		bcc $01a52f			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a52b	a9 00		lda #$00			lda 	#0
.01a52d	95 85		sta $85,x			sta 	XS_Type,x
.01a52f					_FPGP_NotFractional:
.01a52f	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a531	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a533	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a535	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a537	f0 05		beq $01a53e			beq 	_FPGP_Zero 					; if zero, return zero
.01a539	20 2e a6	jsr $01a62e			jsr 	FPUNormalise
.01a53c	80 04		bra $01a542			bra 	_FPGP_Exit 					; and exit
.01a53e					_FPGP_Zero:
.01a53e	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a540	95 85		sta $85,x			sta 	XS_Type,x
.01a542					_FPGP_Exit:
.01a542	68		pla				pla 								; throw saved action flag.
.01a543	7a		ply				ply
.01a544	68		pla				pla
.01a545	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a546					FPCompare:
.01a546	20 87 a5	jsr $01a587			jsr 	FPFastCompare 				; fast compare try first
.01a549	b0 3b		bcs $01a586			bcs 	_FPCExit 					; that worked.
.01a54b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a54d	48		pha				pha
.01a54e	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a550	48		pha				pha
.01a551	20 29 a3	jsr $01a329			jsr 	FPSubtract 					; calculate X1-X2
.01a554	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a556	70 2a		bvs $01a582			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exponents
.01a558	68		pla				pla
.01a559	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a55c	68		pla				pla
.01a55d	38		sec				sec
.01a55e	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a561	70 14		bvs $01a577			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a563	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a564	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a566	b0 0f		bcs $01a577			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a568	38		sec				sec
.01a569	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a56c	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a56e	b0 02		bcs $01a572			bcs 	_FPCNotRange 				; keep in range.
.01a570	a9 01		lda #$01			lda 	#1
.01a572					_FPCNotRange:
.01a572	38		sec				sec
.01a573	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a575	b0 0d		bcs $01a584			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a577					_FPCNotEqual:
.01a577	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a579	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a57b	f0 02		beq $01a57f			beq 	_FPCNE2
.01a57d	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a57f	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a580	80 04		bra $01a586			bra 	_FPCExit
.01a582					_FPCPullZero:
.01a582	68		pla				pla 								; throw saved exponents
.01a583	68		pla				pla
.01a584					_FPCZero:
.01a584	a9 00		lda #$00			lda 	#0 							; and return zero
.01a586					_FPCExit:
.01a586	60		rts				rts
.01a587					FPFastCompare:
.01a587	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a589	70 23		bvs $01a5ae			bvs 	_FPFLeftZero 				; return invert sign of n2 (0-n2)
.01a58b	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero ?
.01a58d	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of n1 (n1-0)
.01a58f	70 25		bvs $01a5b6			bvs 	_FPFSignBit
.01a591	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a593	0a		asl a				asl 	a 							; put in CS if different.
.01a594	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a596	b0 1e		bcs $01a5b6			bcs 	_FPFSignBit
.01a598	38		sec				sec 								; same sign and not-zero. compare exponents
.01a599	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a59b	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a59d	f0 09		beq $01a5a8			beq 	_FPNoFastCompare
.01a59f	6a		ror a				ror 	a 							; put carry into bit 7.
.01a5a0	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a5a2	30 02		bmi $01a5a6			bmi		_FPFCNotMinus
.01a5a4	49 80		eor #$80			eor 	#$80
.01a5a6					_FPFCNotMinus:
.01a5a6	80 0e		bra $01a5b6			bra		_FPFSignBit
.01a5a8					_FPNoFastCompare:
.01a5a8	18		clc				clc
.01a5a9	60		rts				rts
.01a5aa					_FPFZero:
.01a5aa	a9 00		lda #$00			lda 	#0
.01a5ac					_FPFExitSet:
.01a5ac	38		sec				sec
.01a5ad	60		rts				rts
.01a5ae					_FPFLeftZero:
.01a5ae	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a5b0	70 f8		bvs $01a5aa			bvs 	_FPFZero
.01a5b2	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a5b4	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a5b6					_FPFSignBit:
.01a5b6	0a		asl a				asl 	a
.01a5b7	a9 01		lda #$01			lda 	#1
.01a5b9	90 f1		bcc $01a5ac			bcc		_FPFExitSet
.01a5bb	a9 ff		lda #$ff			lda 	#$FF
.01a5bd	38		sec				sec
.01a5be	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a5bf					FPUCopyX2ToX1:
.01a5bf	48		pha				pha									; save AXY
.01a5c0	da		phx				phx
.01a5c1	5a		phy				phy
.01a5c2	a0 08		ldy #$08			ldy 	#8 							; copy the whole mantissa
.01a5c4	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a5c6	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a5c8	e8		inx				inx
.01a5c9	88		dey				dey
.01a5ca	10 f8		bpl $01a5c4			bpl 	_FPUC21
.01a5cc	7a		ply				ply 								; restore and exit
.01a5cd	fa		plx				plx
.01a5ce	68		pla				pla
.01a5cf	60		rts				rts
.01a5d0					FPUSetInteger:
.01a5d0	48		pha				pha
.01a5d1	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a5d3	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a5d5	10 02		bpl $01a5d9			bpl 	_FPUSIExtend 				; so sign extend it into the mantissa
.01a5d7	a9 ff		lda #$ff			lda 	#$FF
.01a5d9					_FPUSIExtend:
.01a5d9	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a5db	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5dd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5df	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a5e1	95 85		sta $85,x			sta 	XS_Type,x
.01a5e3	68		pla				pla
.01a5e4	60		rts				rts
.01a5e5					FPUNegateInteger:
.01a5e5	48		pha				pha
.01a5e6	38		sec				sec
.01a5e7	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a5e9	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a5eb	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a5ed	a9 00		lda #$00			lda 	#0
.01a5ef	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a5f1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a5f3	a9 00		lda #$00			lda 	#0
.01a5f5	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a5f7	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5f9	a9 00		lda #$00			lda 	#0
.01a5fb	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a5fd	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5ff	68		pla				pla
.01a600	60		rts				rts
.01a601					FPUToFloat:
.01a601	48		pha				pha
.01a602	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a604	29 0f		and #$0f			and 	#$0F 						; (e.g. type is zero)
.01a606	f0 24		beq $01a62c			beq 	_FPUFExit
.01a608	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a60a	95 85		sta $85,x			sta 	XS_Type,x
.01a60c	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a60e	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a610	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a612	10 07		bpl $01a61b			bpl		_FPUFPositive
.01a614	20 e5 a5	jsr $01a5e5			jsr 	FPUNegateInteger 			; negate the mantissa
.01a617	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a619	95 85		sta $85,x			sta 	XS_Type,x
.01a61b					_FPUFPositive:
.01a61b	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a61d	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a61f	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a621	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a623	d0 04		bne $01a629			bne 	_FPUFNonZero
.01a625	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a627	95 85		sta $85,x			sta 	XS_Type,x
.01a629					_FPUFNonZero:
.01a629	20 2e a6	jsr $01a62e			jsr 	FPUNormalise 				; normalise the floating point.
.01a62c					_FPUFExit:
.01a62c	68		pla				pla
.01a62d	60		rts				rts
.01a62e					FPUNormalise:
.01a62e	48		pha				pha
.01a62f	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a631	70 18		bvs $01a64b			bvs 	_FPUNExit
.01a633	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a635	f0 10		beq $01a647			beq 	_FPUNSetZero 				; (e.g. the float value zero)
.01a637					_FPUNLoop:
.01a637	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a639	30 10		bmi $01a64b			bmi 	_FPUNExit 					; if so, we are normalised.
.01a63b	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a63d	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a63f	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a641	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a643	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a645	d0 f0		bne $01a637			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a647					_FPUNSetZero:
.01a647	a9 40		lda #$40			lda 	#$40
.01a649	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a64b					_FPUNExit:
.01a64b	68		pla				pla
.01a64c	60		rts				rts
.01a64d					FPUToInteger:
.01a64d	48		pha				pha
.01a64e	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a650	29 01		and #$01			and 	#1
.01a652	d0 31		bne $01a685			bne 	_FPUTOI_Exit
.01a654	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a656	70 23		bvs $01a67b			bvs 	_FPUTOI_Zero
.01a658	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a65a	10 1f		bpl $01a67b			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a65c	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a65e	b0 2b		bcs $01a68b			bcs 	FP_Overflow 				; can't cope with that as an integer.
.01a660					_FPUToIToInteger:
.01a660	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a662	c9 a0		cmp #$a0			cmp 	#128+32
.01a664	f0 0c		beq $01a672			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a666	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a668	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a66a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a66c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a66e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a670	80 ee		bra $01a660			bra 	_FPUToIToInteger 			; keep going.
.01a672					_FPUToICheckSign:
.01a672	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a674	10 0f		bpl $01a685			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a676	20 e5 a5	jsr $01a5e5			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a679	80 0a		bra $01a685			bra 	_FPUTOI_Exit
.01a67b					_FPUTOI_Zero:
.01a67b	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a67d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a67f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a681	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a683	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a685					_FPUToI_Exit:
.01a685	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a687	95 85		sta $85,x			sta 	XS_Type,x
.01a689	68		pla				pla
.01a68a	60		rts				rts
.01a68b					FP_Overflow:
.01a68b	20 86 85	jsr $018586			jsr ERR_Handler
>01a68e	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a696	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a6a6					FPUTimes10:
.01a6a6	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a6a8	85 1c		sta $1c				sta 	ZLTemp1+0
.01a6aa	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6ac	85 1d		sta $1d				sta 	ZLTemp1+1
.01a6ae	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6b0	85 1e		sta $1e				sta 	ZLTemp1+2
.01a6b2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6b4	85 1f		sta $1f				sta 	ZLTemp1+3
.01a6b6	20 eb a6	jsr $01a6eb			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a6b9	20 eb a6	jsr $01a6eb			jsr 	_FPUT_LSR_ZLTemp1
.01a6bc	18		clc				clc
.01a6bd	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a6bf	65 1c		adc $1c				adc 	ZLTemp1+0
.01a6c1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a6c3	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a6c5	65 1d		adc $1d				adc 	ZLTemp1+1
.01a6c7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a6c9	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a6cb	65 1e		adc $1e				adc 	ZLTemp1+2
.01a6cd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a6cf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a6d1	65 1f		adc $1f				adc 	ZLTemp1+3
.01a6d3	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a6d5	90 0a		bcc $01a6e1			bcc 	_FPUTimes10
.01a6d7	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a6d9	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a6db	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a6dd	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a6df	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a6e1					_FPUTimes10:
.01a6e1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a6e3	18		clc				clc
.01a6e4	69 03		adc #$03			adc 	#3
.01a6e6	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6e8	b0 a1		bcs $01a68b			bcs 	FP_Overflow 				; error
.01a6ea	60		rts				rts
.01a6eb					_FPUT_LSR_ZLTemp1:
.01a6eb	46 1f		lsr $1f				lsr 	ZLTemp1+3
.01a6ed	66 1e		ror $1e				ror 	ZLTemp1+2
.01a6ef	66 1d		ror $1d				ror 	ZLTemp1+1
.01a6f1	66 1c		ror $1c				ror 	ZLTemp1+0
.01a6f3	60		rts				rts
.01a6f4					FPUScale10A:
.01a6f4	5a		phy				phy
.01a6f5	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a6f7	f0 37		beq $01a730			beq 	_FPUScaleExit
.01a6f9	da		phx				phx 								; save X
.01a6fa	e8		inx				inx
.01a6fb	e8		inx				inx
.01a6fc	e8		inx				inx
.01a6fd	e8		inx				inx
.01a6fe	e8		inx				inx
.01a6ff	e8		inx				inx
.01a700	a8		tay				tay 								; save power scalar in Y.
.01a701	a9 00		lda #$00			lda 	#0
.01a703	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0 in float.
.01a705	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a707	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a709	95 85		sta $85,x			sta 	XS_Type,x
.01a70b	a9 80		lda #$80			lda 	#$80
.01a70d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a70f	a9 81		lda #$81			lda 	#$81
.01a711	95 84		sta $84,x			sta 	XS_Exponent,x
.01a713	5a		phy				phy 								; save 10^n (e.g. the scalar) on stack.
.01a714	c0 00		cpy #$00			cpy 	#0
.01a716	10 05		bpl $01a71d			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a718	98		tya				tya
.01a719	49 ff		eor #$ff			eor 	#$FF
.01a71b	1a		inc a				inc 	a
.01a71c	a8		tay				tay
.01a71d					_FPUSAbs:
.01a71d	20 a6 a6	jsr $01a6a6			jsr 	FPUTimes10
.01a720	88		dey				dey
.01a721	d0 fa		bne $01a71d			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a723	68		pla				pla 								; restore count in A
.01a724	fa		plx				plx 								; restore X pointing to number to scale.
.01a725	0a		asl a				asl 	a
.01a726	b0 05		bcs $01a72d			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a728	20 48 a4	jsr $01a448			jsr 	FPMultiply 					; if clear multiply.
.01a72b	80 03		bra $01a730			bra		_FPUScaleExit
.01a72d					_FPUSDivide:
.01a72d	20 d5 a3	jsr $01a3d5			jsr 	FPDivide
.01a730					_FPUScaleExit:
.01a730	7a		ply				ply
.01a731	60		rts				rts
.01a732					FPUCopyToNext:
.01a732	a0 06		ldy #$06			ldy 		#6
.01a734	da		phx				phx
.01a735					_FPUCopy1:
.01a735	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a737	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a739	e8		inx				inx
.01a73a	88		dey				dey
.01a73b	d0 f8		bne $01a735			bne 	_FPUCopy1
.01a73d	fa		plx				plx
.01a73e	60		rts				rts
.01a73f					FPUCopyFromNext:
.01a73f	a0 06		ldy #$06			ldy 		#6
.01a741	da		phx				phx
.01a742					_FPUCopy1:
.01a742	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a744	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a746	e8		inx				inx
.01a747	88		dey				dey
.01a748	d0 f8		bne $01a742			bne 	_FPUCopy1
.01a74a	fa		plx				plx
.01a74b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a74c					FPToString:
.01a74c	48		pha				pha
.01a74d	5a		phy				phy
.01a74e	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a750	50 0a		bvc $01a75c			bvc 		_FPTSIsFloat 			; if zero,
.01a752					_FPTSZero:
.01a752	a9 30		lda #$30			lda 		#"0"
.01a754	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter
.01a757					_FPTSExit:
.01a757	7a		ply				ply
.01a758	68		pla				pla
.01a759	60		rts				rts
.01a75a	80 fb		bra $01a757			bra 		_FPTSExit
.01a75c					_FPTSIsFloat:
.01a75c	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a75e	10 09		bpl $01a769			bpl 		_FPTSNotSigned
.01a760	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a762	95 85		sta $85,x			sta 		XS_Type,x
.01a764	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a766	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter
.01a769					_FPTSNotSigned:
.01a769	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a76b	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a76d	b0 09		bcs $01a778			bcs 		_FPTSExponent
.01a76f	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a771	90 05		bcc $01a778			bcc 		_FPTSExponent 			;
.01a773					_FPTSStandard:
.01a773	20 b7 a7	jsr $01a7b7			jsr 		FPTOutputBody 			; output the body.
.01a776	80 df		bra $01a757			bra 		_FPTSExit
.01a778					_FPTSExponent:
.01a778	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a77a	8d 9d 03	sta $039d			sta 		ExpCount
.01a77d					_FPTSExponentLoop:
.01a77d	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a77f	10 0e		bpl $01a78f			bpl 		_FPTSTimes
.01a781	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a783	90 14		bcc $01a799			bcc 		_FPTSScaledToExp
.01a785	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a787	20 f4 a6	jsr $01a6f4			jsr 		FPUScale10A
.01a78a	ee 9d 03	inc $039d			inc 		ExpCount
.01a78d	80 ee		bra $01a77d			bra 		_FPTSExponentLoop
.01a78f					_FPTSTimes:
.01a78f	a9 01		lda #$01			lda 		#1
.01a791	20 f4 a6	jsr $01a6f4			jsr 		FPUScale10A
.01a794	ce 9d 03	dec $039d			dec 		ExpCount
.01a797	80 e4		bra $01a77d			bra 		_FPTSExponentLoop
.01a799					_FPTSScaledToExp:
.01a799	20 b7 a7	jsr $01a7b7			jsr 		FPTOutputBody 			; output the body.
.01a79c	a9 65		lda #$65			lda 		#"e"					; output E
.01a79e	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter
.01a7a1	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a7a4	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a7a6	29 80		and #$80			and 		#$80 					; sign extend it
.01a7a8	f0 02		beq $01a7ac			beq 		_FPTSSExt
.01a7aa	a9 ff		lda #$ff			lda 		#$FF
.01a7ac					_FPTSSExt:
.01a7ac	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a7ae	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a7b0	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a7b2	20 e2 a1	jsr $01a1e2			jsr 		INTToString 			; output the exponent.
.01a7b5	80 a0		bra $01a757			bra			_FPTSExit 				; and exit.
.01a7b7					FPTOutputBody:
.01a7b7	20 32 a7	jsr $01a732			jsr 		FPUCopyToNext 			; copy to next slot.
.01a7ba	20 4d a6	jsr $01a64d			jsr 		FPUToInteger 			; convert to an integer
.01a7bd	20 e2 a1	jsr $01a1e2			jsr 		INTToString 			; output the main integer part.
.01a7c0	20 3f a7	jsr $01a73f			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a7c3	20 d0 a4	jsr $01a4d0			jsr 		FPFractionalPart 		; get the decimal part.
.01a7c6	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a7c8	70 3c		bvs $01a806			bvs 		_FPTOExit 				; if not, exit now.
.01a7ca	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a7cc	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter
.01a7cf					_FPOutLoop:
.01a7cf	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a7d1	70 1d		bvs $01a7f0			bvs 		_FPStripZeros 			; strip trailing zeros
.01a7d3	20 a6 a6	jsr $01a6a6			jsr 		FPUTimes10 				; multiply by 10
.01a7d6	20 32 a7	jsr $01a732			jsr 		FPUCopyToNext			; copy to next slot.
.01a7d9	20 4d a6	jsr $01a64d			jsr 		FPUToInteger 			; convert to integer
.01a7dc	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a7de	09 30		ora #$30			ora 		#"0"
.01a7e0	20 84 a2	jsr $01a284			jsr 		ITSOutputCharacter
.01a7e3	20 3f a7	jsr $01a73f			jsr 		FPUCopyFromNext 		; get it back
.01a7e6	20 d0 a4	jsr $01a4d0			jsr 		FPFractionalPart 		; get fractional part
.01a7e9	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a7ec	c9 0b		cmp #$0b			cmp 	 	#11
.01a7ee	90 df		bcc $01a7cf			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a7f0					_FPStripZeros:
.01a7f0	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a7f3					_FPStripLoop:
.01a7f3	88		dey				dey 								; back one, if at start then no strip
.01a7f4	f0 10		beq $01a806			beq 		_FPToExit
.01a7f6	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a7f9	c9 30		cmp #$30			cmp 		#"0"
.01a7fb	f0 f6		beq $01a7f3			beq 		_FPStripLoop
.01a7fd	c8		iny				iny
.01a7fe	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a800	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a803	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a806					_FPTOExit:
.01a806	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a807					FPFromString:
.01a807	48		pha				pha 								; push A
.01a808	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a80a	c9 2e		cmp #$2e			cmp 	#"."
.01a80c	f0 03		beq $01a811			beq	 	_FPFIsDecimal
.01a80e	4c 6d a8	jmp $01a86d			jmp 	_FPFNotDecimal
.01a811					_FPFIsDecimal:
.01a811	c8		iny				iny 								; consume the decimal.
.01a812	20 01 a6	jsr $01a601			jsr 	FPUToFloat 					; convert the integer to float.
.01a815	da		phx				phx 								; save X.
.01a816	5a		phy				phy 								; save decimal start position
.01a817	e8		inx				inx
.01a818	e8		inx				inx
.01a819	e8		inx				inx
.01a81a	e8		inx				inx
.01a81b	e8		inx				inx
.01a81c	e8		inx				inx
.01a81d	20 99 a2	jsr $01a299			jsr 	INTFromStringY 				; get the part after the DP.
.01a820	20 01 a6	jsr $01a601			jsr 	FPUToFloat 					; convert that to a float.
.01a823	68		pla				pla 								; calculate - chars consumed.
.01a824	8c 9c 03	sty $039c			sty 	ExpTemp
.01a827	38		sec				sec
.01a828	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a82b	20 f4 a6	jsr $01a6f4			jsr 	FPUScale10A 				; scale it by 10^AC
.01a82e	fa		plx				plx 								; restore original X
.01a82f	20 31 a3	jsr $01a331			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a832	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.01a834	c9 45		cmp #$45			cmp 	#"E"
.01a836	f0 04		beq $01a83c			beq 	_FPFExponent
.01a838	c9 65		cmp #$65			cmp 	#"e"
.01a83a	d0 31		bne $01a86d			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a83c					_FPFExponent:
.01a83c	c8		iny				iny 								; skip over E symbol.
.01a83d	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.01a83f	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a841	d0 01		bne $01a844			bne 	_FPFGotSign
.01a843	c8		iny				iny 								; if it was - skip over it.
.01a844					_FPFGotSign:
.01a844	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a845	da		phx				phx
.01a846	e8		inx				inx
.01a847	e8		inx				inx
.01a848	e8		inx				inx
.01a849	e8		inx				inx
.01a84a	e8		inx				inx
.01a84b	e8		inx				inx
.01a84c	20 99 a2	jsr $01a299			jsr 	INTFromStringY 				; get the exponent
.01a84f	fa		plx				plx 								; restore X.
.01a850	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a852	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a854	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a856	d0 17		bne $01a86f			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a858	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a85a	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a85c	b0 11		bcs $01a86f			bcs 	_FPFXOverflow
.01a85e	68		pla				pla 								; get direction
.01a85f	d0 07		bne $01a868			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a861	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a863	49 ff		eor #$ff			eor 	#$FF
.01a865	1a		inc a				inc 	a
.01a866	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a868					_FPFXScale:
.01a868	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a86a	20 f4 a6	jsr $01a6f4			jsr 	FPUScale10A 				; scale by the exponent.
.01a86d					_FPFNotDecimal:
.01a86d	68		pla				pla
.01a86e	60		rts				rts
.01a86f					_FPFXOverflow:
.01a86f	20 86 85	jsr $018586			jsr 	ERR_Handler
>01a872	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a87a	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a881					Unary_Rnd:
.01a881	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX 			; get value
.01a884	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; check right bracket.
.01a887	20 59 96	jsr $019659			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a88a	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a88c	30 10		bmi $01a89e			bmi 	_URSetSeed
.01a88e	f0 28		beq $01a8b8			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a890	da		phx				phx
.01a891	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a893	20 ef a8	jsr $01a8ef			jsr 	Random16
.01a896	a2 02		ldx #$02			ldx 	#2
.01a898	20 ef a8	jsr $01a8ef			jsr 	Random16
.01a89b	fa		plx				plx
.01a89c	80 1a		bra $01a8b8			bra 	_URMakeRandom
.01a89e					_URSetSeed:
.01a89e	20 01 a6	jsr $01a601			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a8a1	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a8a3	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a8a6	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a8a8	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a8ab	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a8ad	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a8b0	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a8b2	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a8b3	49 db		eor #$db			eor 	#$DB
.01a8b5	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8b8					_URMakeRandom:
.01a8b8	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a8bb	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a8be	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a8c1	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a8c4	d0 0a		bne $01a8d0			bne 	_URNotZero
.01a8c6	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a8c8	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a8cb	a9 3d		lda #$3d			lda 	#$3D
.01a8cd	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a8d0					_URNotZero:
.01a8d0	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a8d3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a8d5	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a8d8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a8da	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a8dd	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a8df	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a8e2	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a8e4	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a8e6	95 85		sta $85,x			sta 	XS_Type,x
.01a8e8	a9 80		lda #$80			lda 	#$80
.01a8ea	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a8ec	4c 2e a6	jmp $01a62e			jmp 	FPUNormalise 				; and normalise.
.01a8ef					Random16:
.01a8ef	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a8f2	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a8f5	90 08		bcc $01a8ff			bcc 	_R16_NoXor
.01a8f7	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a8fa	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a8fc	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a8ff					_R16_NoXor:
.01a8ff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a900					Unary_Int:
.01a900	20 e3 93	jsr $0193e3			jsr 	EvaluateNumberX 			; get value
.01a903	20 3b 9a	jsr $019a3b			jsr 	CheckNextRParen 			; check right bracket.
.01a906	4c 4d a6	jmp $01a64d			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a909	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
