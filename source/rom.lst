
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Sun Aug 25 21:02:50 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="4510"					cpu = "4510"
="mega65"				hardware = "mega65"
=1					exitonend = 1
=0					autorun = 0
=0					loadtest = 0
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/float/fpmacros.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/mega65/src_mega65.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0200					IFT_XCursor:.byte ?							; current logical position on screen
>0201					IFT_YCursor:.byte ?
>0202					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0266					IFT_LineBuffer: .fill 100 					; line input buffer.
>0300					UserVector .fill 4 							; USR(x) calls this.
>0304					LocalVector .fill 4 						; Indirect calls call this.
>0308					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>030c					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>030d					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=782					XS2_Mantissa = XS_Mantissa+XS_Size
=786					XS2_Exponent = XS_Exponent+XS_Size
=787					XS2_Type = XS_Type+XS_Size
=788					XS3_Mantissa = XS_Mantissa+XS_Size*2
=792					XS3_Exponent = XS_Exponent+XS_Size*2
=793					XS3_Type = XS_Type+XS_Size*2
>0400					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0402					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0404					NumBufX 	.byte 	?						; buffer index position
>0405					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0425					HashTableBase:
>0425								.fill	HashTableCount * HashTableSize * 2
.0485					HashTableEnd:
=$405					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0485					Var_Type    .byte ? 						; type of variable (as a type token)
>0486					Var_Hash 	.byte ? 						; hash of identifier name.
>0487					Var_Length 	.byte ? 						; length of variable name
>0488					Var_HashAddress .byte ?						; low byte of hash table entry.
>0489					Var_DataSize .byte ?						; size of one element.
>048a					NumSuppress	.byte 	?						; leading zero suppression flag
>048b					NumConvCount .byte 	? 						; count for conversions.
>048c					ExpTemp:	.byte ?							; Working temp for exponents.
>048d					ExpCount:	.byte ? 						; Count of decimal exponents.
>048e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>048f					TempStringWriteIndex: .byte ? 				; Write offset.
>0490					ValSign: 	.byte ? 						; sign flag for val()
>0491					SliceStart:	.byte ? 						; string slice parts
>0492					SliceCount:	.byte ?
>0493					RandomSeed:	.dword ? 						; Random seed.
>0497					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>0499					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>049b					Tim_SR:		.byte ? 						; Processor Status
>049c					Tim_A:		.byte ? 						; Processor Registers
>049d					Tim_X:		.byte ?
>049e					Tim_Y:		.byte ?
>049f					Tim_Z:		.byte ?
>04a0					Tim_SP:		.word ?							; Stack Pointer (just in cases)

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/mega65.asm

=$7000					HighMemory = $7000
=$4000					VariableMemory = $4000
.8000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>8000	0e 64 00 cd 14 05 13 14			.byte	$0e,$64,$00,$cd,$14,$05,$13,$14
>8008	84 6a fd 03 35 00 1d 65			.byte	$84,$6a,$fd,$03,$35,$00,$1d,$65
>8010	00 cd 01 84 40 fd 03 30			.byte	$00,$cd,$01,$84,$40,$fd,$03,$30
>8018	be cd 14 05 13 14 31 84			.byte	$be,$cd,$14,$05,$13,$14,$31,$84
>8020	41 fd 06 32 65 32 34 8d			.byte	$41,$fd,$06,$32,$65,$32,$34,$8d
>8028	41 64 00 0c 66 00 cd 02			.byte	$41,$64,$00,$0c,$66,$00,$cd,$02
>8030	31 32 b9 84 8b 42 00 08			.byte	$31,$32,$b9,$84,$8b,$42,$00,$08
>8038	67 00 03 84 8b 40 00 05			.byte	$67,$00,$03,$84,$8b,$40,$00,$05
>8040	68 00 c2 00 00				.byte	$68,$00,$c2,$00,$00

;******  Return to file: modules/hardware/mega65.asm

.a000					StartROM:
.a000	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.a002	9a		txs				txs
.a003	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; reset external interface
.a006	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.a009	4c b1 ad	jmp $adb1		jmp BASIC_Start

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.a00c					IFT_ClearScreen:
.a00c	48		pha				pha
.a00d	da		phx				phx
.a00e	5a		phy				phy
.a00f	20 b4 a1	jsr $a1b4			jsr 	IF_Home 					; home cursor
.a012	a2 19		ldx #$19			ldx 	#IF_Height 					; this many lines.
.a014					_IFT_CS0:
.a014	a0 50		ldy #$50			ldy 	#IF_Width 					; this many chars/line
.a016					_IFT_CS1:
.a016	a9 20		lda #$20			lda 	#' '						; clear line.
.a018	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a01b	88		dey				dey
.a01c	d0 f8		bne $a016			bne 	_IFT_CS1
.a01e	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; next line down
.a021	ca		dex				dex
.a022	d0 f0		bne $a014			bne 	_IFT_CS0
.a024	7a		ply				ply
.a025	fa		plx				plx
.a026	68		pla				pla
.a027					IFT_HomeCursor:
.a027	48		pha				pha
.a028	20 b4 a1	jsr $a1b4			jsr 	IF_Home
.a02b	a9 00		lda #$00			lda 	#0
.a02d	8d 00 02	sta $0200			sta 	IFT_XCursor
.a030	8d 01 02	sta $0201			sta 	IFT_YCursor
.a033	68		pla				pla
.a034	60		rts				rts
.a035					IFT_UpLine:
.a035	48		pha				pha
.a036	ad 01 02	lda $0201			lda  	IFT_YCursor 				; get Y
.a039	3a		dec a				dec 	a 							; line above
.a03a	30 03		bmi $a03f			bmi 	_IFTULExit 					; too far, abort
.a03c	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos					; set to that line.
.a03f					_IFTULExit:
.a03f	68		pla				pla
.a040	60		rts				rts
.a041					IFT_PrintCharacter:
.a041	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.a043	f0 23		beq $a068			beq 	IFT_NewLine
.a045	48		pha				pha
.a046	20 80 a0	jsr $a080			jsr 	IFT_UpperCase 				; make upper case
.a049	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write out.
.a04c	ee 00 02	inc $0200			inc 	IFT_XCursor 				; bump x cursor
.a04f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; reached RHS ?
.a052	c9 50		cmp #$50			cmp 	#IF_Width
.a054	d0 03		bne $a059			bne 	_IFT_PCNotEOL
.a056	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; if so do new line.
.a059					_IFT_PCNotEOL:
.a059	68		pla				pla
.a05a	60		rts				rts
.a05b					IFT_Tab:
.a05b	a9 20		lda #$20			lda 	#" " 						; space
.a05d	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a060	ad 00 02	lda $0200			lda 	IFT_XCursor 				; until x % 8 == 0
.a063	29 07		and #$07			and 	#7
.a065	d0 f4		bne $a05b			bne 	IFT_Tab
.a067	60		rts				rts
.a068					IFT_NewLine:
.a068	48		pha				pha
.a069	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine 					; new line on actual screen.
.a06c	a9 00		lda #$00			lda 	#0 							; reset x position
.a06e	8d 00 02	sta $0200			sta 	IFT_XCursor
.a071	ee 01 02	inc $0201			inc 	IFT_YCursor 				; move down.
.a074	ad 01 02	lda $0201			lda 	IFT_YCursor
.a077	c9 19		cmp #$19			cmp 	#IF_Height 					; reached bottom.
.a079	d0 03		bne $a07e			bne 	_IFT_NL_NotEOS
.a07b	20 8b a0	jsr $a08b			jsr 	IFT_Scroll 					; scroll screen up.
.a07e					_IFT_NL_NotEOS:
.a07e	68		pla				pla
.a07f	60		rts				rts
.a080					IFT_UpperCase:
.a080	c9 61		cmp #$61			cmp 	#"a"
.a082	90 06		bcc $a08a			bcc 	_IFT_UCExit
.a084	c9 7b		cmp #$7b			cmp 	#"z"+1
.a086	b0 02		bcs $a08a			bcs 	_IFT_UCExit
.a088	49 20		eor #$20			eor 	#$20
.a08a					_IFT_UCExit:
.a08a	60		rts				rts
.a08b					IFT_Scroll:
.a08b	48		pha				pha 								; save AXY
.a08c	da		phx				phx
.a08d	5a		phy				phy
.a08e	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.a090					_IFT_SLoop:
.a090	20 b0 a0	jsr $a0b0			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.a093	e8		inx				inx
.a094	e0 18		cpx #$18			cpx 	#IF_Height-1				; do whole screen
.a096	d0 f8		bne $a090			bne 	_IFT_SLoop
.a098	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a09a	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a09d	a2 50		ldx #$50			ldx 	#IF_Width 					; blank line
.a09f					_IFT_SBlank:
.a09f	a9 20		lda #$20			lda 	#32
.a0a1	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0a4	ca		dex				dex
.a0a5	d0 f8		bne $a09f			bne 	_IFT_SBlank
.a0a7	a9 18		lda #$18			lda 	#IF_Height-1 				; move to X = 0,Y = A
.a0a9	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0ac	7a		ply				ply
.a0ad	fa		plx				plx
.a0ae	68		pla				pla
.a0af	60		rts				rts
.a0b0					_IFT_ScrollLine:
.a0b0	da		phx				phx
.a0b1	da		phx				phx
.a0b2	8a		txa				txa 								; copy line into buffer.
.a0b3	1a		inc a				inc 	a 							; next line down.
.a0b4	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0b7	a2 00		ldx #$00			ldx 	#0
.a0b9					_IFTScrollCopy1:
.a0b9	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a0bc	9d 02 02	sta $0202,x			sta 	IFT_Buffer,x
.a0bf	e8		inx				inx
.a0c0	e0 50		cpx #$50			cpx 	#IF_Width
.a0c2	d0 f5		bne $a0b9			bne 	_IFTScrollCopy1
.a0c4	68		pla				pla
.a0c5	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a0c8	a2 00		ldx #$00			ldx 	#0
.a0ca					_IFTScrollCopy2:
.a0ca	bd 02 02	lda $0202,x			lda 	IFT_Buffer,x
.a0cd	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a0d0	e8		inx				inx
.a0d1	e0 50		cpx #$50			cpx 	#IF_Width
.a0d3	d0 f5		bne $a0ca			bne 	_IFTScrollCopy2
.a0d5	fa		plx				plx
.a0d6	60		rts				rts
.a0d7					IFT_SetYPos:
.a0d7	48		pha				pha
.a0d8	da		phx				phx
.a0d9	aa		tax				tax
.a0da	20 27 a0	jsr $a027			jsr 	IFT_HomeCursor
.a0dd	e0 00		cpx #$00			cpx 	#0
.a0df	f0 09		beq $a0ea			beq 	_IFT_MOAExit
.a0e1					_IFT_MOALoop:
.a0e1	20 c3 a1	jsr $a1c3			jsr 	IF_NewLine
.a0e4	ee 01 02	inc $0201			inc 	IFT_YCursor
.a0e7	ca		dex				dex
.a0e8	d0 f7		bne $a0e1			bne		_IFT_MOALoop
.a0ea					_IFT_MOAExit:
.a0ea	fa		plx				plx
.a0eb	68		pla				pla
.a0ec	60		rts				rts
.a0ed					IFT_GetKeyCursor:
.a0ed	20 f5 a0	jsr $a0f5			jsr 	_IFT_FlipCursor 			; reverse current
.a0f0					_IFT_GKCWait:
.a0f0	20 06 a2	jsr $a206			jsr 	IF_GetKey 					; get key
.a0f3	f0 fb		beq $a0f0			beq 	_IFT_GKCWait
.a0f5					_IFT_FlipCursor:
.a0f5	48		pha				pha 								; save
.a0f6	20 d5 a1	jsr $a1d5			jsr 	IF_Read 					; read
.a0f9	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a0fc	49 80		eor #$80			eor 	#$80 						; reverse
.a0fe	20 e3 a1	jsr $a1e3			jsr 	IF_Write 					; write
.a101	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a104	68		pla				pla
.a105	60		rts				rts
.a106					IFT_ReadLine:
.a106	48		pha				pha
.a107					_IFT_RLLoop:
.a107	20 ed a0	jsr $a0ed			jsr 	IFT_GetKeyCursor 			; get keystroke
.a10a	c9 0d		cmp #$0d			cmp 	#13							; return
.a10c	f0 7d		beq $a18b			beq 	_IFT_RLExit
.a10e	c9 20		cmp #$20			cmp 	#32 						; control character
.a110	90 05		bcc $a117			bcc 	_IFT_Control
.a112	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.a115	80 f0		bra $a107			bra 	_IFT_RLLoop
.a117					_IFT_Control:
.a117	c9 01		cmp #$01			cmp 	#"A"-64
.a119	f0 26		beq $a141			beq 	_IFT_Left
.a11b	c9 04		cmp #$04			cmp 	#"D"-64
.a11d	f0 2e		beq $a14d			beq 	_IFT_Right
.a11f	c9 17		cmp #$17			cmp 	#"W"-64
.a121	f0 36		beq $a159			beq 	_IFT_Up
.a123	c9 13		cmp #$13			cmp 	#"S"-64
.a125	f0 3e		beq $a165			beq 	_IFT_Down
.a127	c9 08		cmp #$08			cmp 	#"H"-64
.a129	f0 09		beq $a134			beq 	_IFT_Backspace
.a12b	c9 1a		cmp #$1a			cmp 	#"Z"-64
.a12d	d0 d8		bne $a107			bne 	_IFT_RLLoop
.a12f	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen				; clear CTL-Z
.a132	80 d3		bra $a107			bra 	_IFT_RLLoop
.a134					_IFT_Backspace:
.a134	ad 00 02	lda $0200			lda 	IFT_XCursor 				; check not start of line.
.a137	f0 ce		beq $a107			beq 	_IFT_RLLoop
.a139	20 ee a1	jsr $a1ee			jsr 	IF_LeftOne
.a13c	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.a13e	20 e3 a1	jsr $a1e3			jsr 	IF_Write
.a141					_IFT_Left:
.a141	ce 00 02	dec $0200			dec 	IFT_XCursor 				; left CTL-W
.a144	10 29		bpl $a16f			bpl 	_IFT_Reposition
.a146	a9 4f		lda #$4f			lda 	#IF_Width-1
.a148					_IFT_SetX:
.a148	8d 00 02	sta $0200			sta 	IFT_XCursor
.a14b	80 22		bra $a16f			bra 	_IFT_Reposition
.a14d					_IFT_Right:
.a14d	ee 00 02	inc $0200			inc 	IFT_XCursor
.a150	ad 00 02	lda $0200			lda 	IFT_XCursor
.a153	49 50		eor #$50			eor 	#IF_Width
.a155	f0 f1		beq $a148			beq 	_IFT_SetX
.a157	80 16		bra $a16f			bra 	_IFT_Reposition
.a159					_IFT_Up:
.a159	ce 01 02	dec $0201			dec 	IFT_YCursor
.a15c	10 11		bpl $a16f			bpl 	_IFT_Reposition
.a15e	a9 18		lda #$18			lda 	#IF_Height-1
.a160					_IFT_SetY:
.a160	8d 01 02	sta $0201			sta 	IFT_YCursor
.a163	80 0a		bra $a16f			bra 	_IFT_Reposition
.a165					_IFT_Down:
.a165	ee 01 02	inc $0201			inc 	IFT_YCursor
.a168	ad 01 02	lda $0201			lda 	IFT_YCursor
.a16b	49 19		eor #$19			eor 	#IF_Height
.a16d	f0 f1		beq $a160			beq 	_IFT_SetY
.a16f					_IFT_Reposition:
.a16f	ad 00 02	lda $0200			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.a172	48		pha				pha
.a173	ad 01 02	lda $0201			lda 	IFT_YCursor
.a176	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a179	68		pla				pla
.a17a	aa		tax				tax
.a17b	e0 00		cpx #$00			cpx 	#0
.a17d	f0 88		beq $a107			beq 	_IFT_RLLoop
.a17f					_IFT_MoveRight:
.a17f	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a182	ee 00 02	inc $0200			inc 	IFT_XCursor
.a185	ca		dex				dex
.a186	d0 f7		bne $a17f			bne 	_IFT_MoveRight
.a188	4c 07 a1	jmp $a107			jmp 	_IFT_RLLoop
.a18b					_IFT_RLExit:
.a18b	ad 01 02	lda $0201			lda 	IFT_YCursor 				; go to start of line.
.a18e	20 d7 a0	jsr $a0d7			jsr 	IFT_SetYPos
.a191	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.a193					_IFT_RLRead:
.a193	20 d5 a1	jsr $a1d5			jsr 	IF_Read
.a196	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a199	e8		inx				inx
.a19a	e0 50		cpx #$50			cpx 	#IF_Width
.a19c	d0 f5		bne $a193			bne 	_IFT_RLRead
.a19e					_IFT_RL_Trim:
.a19e	ca		dex				dex 	 							; previous char
.a19f	30 07		bmi $a1a8			bmi 	_IFT_Found 					; gone too far
.a1a1	bd 66 02	lda $0266,x			lda 	IFT_LineBuffer,x			; go back if space
.a1a4	c9 20		cmp #$20			cmp 	#" "
.a1a6	f0 f6		beq $a19e			beq 	_IFT_RL_Trim
.a1a8					_IFT_Found:
.a1a8	e8		inx				inx 								; forward to non-space
.a1a9	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.a1ab	9d 66 02	sta $0266,x			sta 	IFT_LineBuffer,x
.a1ae	68		pla				pla
.a1af	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.a1b1	a0 02		ldy #$02			ldy 	#IFT_LineBuffer >> 8
.a1b3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_mega65.asm

=80					IF_Width 	= 80 							; characters across
=25					IF_Height 	= 25 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line
=6					IF_XPos 	= 6 							; current position, horizontal.
=8					IF_FarPtr 	= 8 							; far pointer (4 bytes)
=$1000					IF_Screen = $1000							; 2k screen RAM here
=$800					IF_CharSet = $800							; 2k character set (0-7F) here
.a1b4					IF_Home:
.a1b4	48		pha				pha 								; reset cursor position
.a1b5	a9 00		lda #$00			lda 	#IF_Screen & $FF
.a1b7	85 04		sta $04				sta 	IF_Pos
.a1b9	a9 10		lda #$10			lda 	#IF_Screen >> 8
.a1bb	85 05		sta $05				sta 	IF_Pos+1
.a1bd	a9 00		lda #$00			lda 	#0
.a1bf	85 06		sta $06				sta 	IF_XPos
.a1c1	68		pla				pla
.a1c2	60		rts				rts
.a1c3					IF_NewLine:
.a1c3	48		pha				pha
.a1c4	a9 00		lda #$00			lda 	#0 							; back to start of line
.a1c6	85 06		sta $06				sta 	IF_XPos
.a1c8	18		clc				clc 								; down one line
.a1c9	a5 04		lda $04				lda 	IF_Pos
.a1cb	69 50		adc #$50			adc 	#80
.a1cd	85 04		sta $04				sta 	IF_Pos
.a1cf	90 02		bcc $a1d3			bcc 	_IF_NoCarry 				; carry through.
.a1d1	e6 05		inc $05				inc 	IF_Pos+1
.a1d3					_IF_NoCarry:
.a1d3	68		pla				pla
.a1d4	60		rts				rts
.a1d5					IF_Read:
.a1d5	5a		phy				phy 								; save current Y
.a1d6	a4 06		ldy $06				ldy 	IF_XPos 					; read character at current position
.a1d8	b1 04		lda ($04),y			lda 	(IF_Pos),y
.a1da	49 20		eor #$20			eor 	#$20
.a1dc	18		clc				clc
.a1dd	69 20		adc #$20			adc 	#$20
.a1df	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1e1	7a		ply				ply									; restore Y
.a1e2	60		rts				rts
.a1e3					IF_Write:
.a1e3	5a		phy				phy 								; save current Y
.a1e4	a4 06		ldy $06				ldy 	IF_XPos 					; write character at current position
.a1e6	29 bf		and #$bf			and 	#63+128 					; PETSCII
.a1e8	91 04		sta ($04),y			sta 	(IF_Pos),y
.a1ea	e6 06		inc $06				inc 	IF_XPos 					; step right.
.a1ec	7a		ply				ply									; restore Y
.a1ed	60		rts				rts
.a1ee					IF_LeftOne:
.a1ee	c6 06		dec $06				dec 	IF_XPos
.a1f0	60		rts				rts
.a1f1					IF_CheckBreak:
.a1f1	db		phz				phz
.a1f2	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress 			; point to keyboard
.a1f5	e6 08		inc $08				inc 	IF_FarPtr 					; point to modifiers.
.a1f7	ea		nop				nop 								; read modifiers.
.a1f8	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a1fa	fb		plz				plz 								; restore Z
.a1fb	29 05		and #$05			and 	#5							; break is LeftShift+Ctrl
.a1fd	c9 05		cmp #$05			cmp 	#5
.a1ff	f0 02		beq $a203			beq 	_IF_CBExit
.a201	a9 00		lda #$00			lda 	#0
.a203					_IF_CBExit:
.a203	c9 00		cmp #$00			cmp 	#0
.a205	60		rts				rts
.a206					IF_GetKey:
.a206	db		phz				phz
.a207	20 3a a2	jsr $a23a			jsr 	IF_SetupKeyAddress
.a20a	ea		nop				nop 								; read keyboard
.a20b	b2 08		lda ($08),z			lda 	(IF_FarPtr),z
.a20d	c9 14		cmp #$14			cmp 	#20
.a20f	d0 02		bne $a213			bne 	_KMNo
.a211	a9 08		lda #$08			lda 	#"H"-64
.a213					_KMNo:
.a213	c9 91		cmp #$91			cmp 	#145
.a215	d0 02		bne $a219			bne 	_KMNo
.a217	a9 17		lda #$17			lda 	#"W"-64
.a219					_KMNo:
.a219	c9 11		cmp #$11			cmp 	#17
.a21b	d0 02		bne $a21f			bne 	_KMNo
.a21d	a9 13		lda #$13			lda 	#"S"-64
.a21f					_KMNo:
.a21f	c9 9d		cmp #$9d			cmp 	#157
.a221	d0 02		bne $a225			bne 	_KMNo
.a223	a9 01		lda #$01			lda 	#"A"-64
.a225					_KMNo:
.a225	c9 1d		cmp #$1d			cmp 	#29
.a227	d0 02		bne $a22b			bne 	_KMNo
.a229	a9 04		lda #$04			lda 	#"D"-64
.a22b					_KMNo:
.a22b	c9 00		cmp #$00			cmp 	#0
.a22d	f0 07		beq $a236			beq 	_IFGKEmpty
.a22f	48		pha				pha
.a230	a9 00		lda #$00			lda 	#0
.a232	ea		nop				nop
.a233	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a235	68		pla				pla
.a236					_IFGKEmpty:
.a236	fb		plz				plz
.a237	c9 00		cmp #$00			cmp 	#0 							; set Z
.a239	60		rts				rts
.a23a					IF_SetupKeyAddress:
.a23a	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to read keyboard.
.a23c	85 0b		sta $0b				sta 	IF_FarPtr+3
.a23e	a9 fd		lda #$fd			lda 	#$FD
.a240	85 0a		sta $0a				sta 	IF_FarPtr+2
.a242	a9 36		lda #$36			lda 	#$36
.a244	85 09		sta $09				sta 	IF_FarPtr+1
.a246	a9 10		lda #$10			lda 	#$10
.a248	85 08		sta $08				sta 	IF_FarPtr+0
.a24a	a3 00		ldz #$00			ldz 	#0
.a24c	60		rts				rts
.a24d					IF_Reset:
.a24d	48		pha				pha 								; save registers
.a24e	da		phx				phx
.a24f	5a		phy				phy
.a250	a9 0f		lda #$0f			lda 	#$0F 						; set up to write to video system.
.a252	85 0b		sta $0b				sta 	IF_FarPtr+3
.a254	a9 fd		lda #$fd			lda 	#$FD
.a256	85 0a		sta $0a				sta 	IF_FarPtr+2
.a258	a9 30		lda #$30			lda 	#$30
.a25a	85 09		sta $09				sta 	IF_FarPtr+1
.a25c	a9 00		lda #$00			lda 	#$00
.a25e	85 08		sta $08				sta 	IF_FarPtr+0
.a260	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a262	a9 47		lda #$47			lda 	#$47
.a264	ea		nop				nop
.a265	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a267	a3 2f		ldz #$2f			ldz 	#$2F 						; address already set up
.a269	a9 53		lda #$53			lda 	#$53
.a26b	ea		nop				nop
.a26c	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a26e	a3 30		ldz #$30			ldz 	#$30 						; address already set up
.a270	a9 40		lda #$40			lda 	#$40
.a272	ea		nop				nop
.a273	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a275	a3 31		ldz #$31			ldz 	#$31 						; address already set up
.a277	a9 c0		lda #$c0			lda 	#$80+$40
.a279	ea		nop				nop
.a27a	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a27c	a3 20		ldz #$20			ldz 	#$20 						; address already set up
.a27e	a9 00		lda #$00			lda 	#0
.a280	ea		nop				nop
.a281	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a283	a3 21		ldz #$21			ldz 	#$21 						; address already set up
.a285	a9 00		lda #$00			lda 	#0
.a287	ea		nop				nop
.a288	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a28a	a3 54		ldz #$54			ldz 	#$54 						; address already set up
.a28c	a9 40		lda #$40			lda 	#$40
.a28e	ea		nop				nop
.a28f	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a291	a3 01		ldz #$01			ldz 	#$01 						; address already set up
.a293	a9 ff		lda #$ff			lda 	#$FF
.a295	ea		nop				nop
.a296	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a298	a3 00		ldz #$00			ldz 	#$00 						; address already set up
.a29a	a9 ff		lda #$ff			lda 	#$FF
.a29c	ea		nop				nop
.a29d	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a29f	a3 16		ldz #$16			ldz 	#$16 						; address already set up
.a2a1	a9 cc		lda #$cc			lda 	#$CC
.a2a3	ea		nop				nop
.a2a4	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2a6	a3 18		ldz #$18			ldz 	#$18 						; address already set up
.a2a8	a9 42		lda #$42			lda 	#$42
.a2aa	ea		nop				nop
.a2ab	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2ad	a3 11		ldz #$11			ldz 	#$11 						; address already set up
.a2af	a9 1b		lda #$1b			lda 	#$1B
.a2b1	ea		nop				nop
.a2b2	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2b4	a9 00		lda #$00			lda 	#$00						; colour RAM at $1F800-1FFFF (2kb)
.a2b6	85 0b		sta $0b				sta 	IF_FarPtr+3
.a2b8	a9 01		lda #$01			lda 	#$01
.a2ba	85 0a		sta $0a				sta 	IF_FarPtr+2
.a2bc	a9 f8		lda #$f8			lda 	#$F8
.a2be	85 09		sta $09				sta 	IF_FarPtr+1
.a2c0	a9 00		lda #$00			lda 	#$00
.a2c2	85 08		sta $08				sta 	IF_FarPtr+0
.a2c4	a3 00		ldz #$00			ldz 	#0
.a2c6					_EXTClearColorRam:
.a2c6	a9 05		lda #$05			lda 	#5							; fill that with this colour.
.a2c8	ea		nop				nop
.a2c9	92 08		sta ($08),z			sta 	(IF_FarPtr),z
.a2cb	3b		dez				dez
.a2cc	d0 f8		bne $a2c6			bne 	_EXTClearColorRam
.a2ce	e6 09		inc $09				inc 	IF_FarPtr+1
.a2d0	d0 f4		bne $a2c6			bne 	_EXTClearColorRam
.a2d2	a2 00		ldx #$00			ldx 	#0 							; copy PET Font into memory.
.a2d4					_EXTCopyCBMFont:
.a2d4	bd 15 a3	lda $a315,x			lda 	IF_CBMFont,x 				; +$800 uses the lower case c/set
.a2d7	9d 00 08	sta $0800,x			sta 	IF_CharSet,x
.a2da	49 ff		eor #$ff			eor 	#$FF
.a2dc	9d 00 0c	sta $0c00,x			sta 	IF_CharSet+$400,x
.a2df	bd 15 a4	lda $a415,x			lda 	IF_CBMFont+$100,x
.a2e2	9d 00 09	sta $0900,x			sta 	IF_CharSet+$100,x
.a2e5	49 ff		eor #$ff			eor 	#$FF
.a2e7	9d 00 0d	sta $0d00,x			sta 	IF_CharSet+$500,x
.a2ea	bd 15 a5	lda $a515,x			lda 	IF_CBMFont+$200,x
.a2ed	9d 00 0a	sta $0a00,x			sta 	IF_CharSet+$200,x
.a2f0	49 ff		eor #$ff			eor 	#$FF
.a2f2	9d 00 0e	sta $0e00,x			sta 	IF_CharSet+$600,x
.a2f5	bd 15 a6	lda $a615,x			lda 	IF_CBMFont+$300,x
.a2f8	9d 00 0b	sta $0b00,x			sta 	IF_CharSet+$300,x
.a2fb	49 ff		eor #$ff			eor 	#$FF
.a2fd	9d 00 0f	sta $0f00,x			sta 	IF_CharSet+$700,x
.a300	ca		dex				dex
.a301	d0 d1		bne $a2d4			bne 	_EXTCopyCBMFont
.a303	a9 3b		lda #$3b			lda 	#$3F-4  					; puts ROM back in the map (the -4)
.a305	85 01		sta $01				sta 	$01
.a307	a9 00		lda #$00			lda 	#$00						; do not map bytes 0000-7FFF
.a309	a2 00		ldx #$00			ldx 	#$00						; (so we use the RAM physically at $0000-$7FFF)
.a30b	a0 00		ldy #$00			ldy 	#$00 						; 8000-FFFF offset by $200. The lower 8 bits are $00
.a30d	a3 f2		ldz #$f2			ldz 	#$F2 						; so this is an actual offset of $20000. So the space at
.a30f	5c		map				map
.a310	ea		nop				eom
.a311	7a		ply				ply 								; restore and exit.
.a312	fa		plx				plx
.a313	68		pla				pla
.a314	60		rts				rts
.a315					IF_CBMFont:
>a315	1c 22 4a 56 4c 20 1e 00				.binary "pet-font.bin"
>a31d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a32d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a33d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a34d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a35d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a36d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a37d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a38d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a39d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a3ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a3bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a3cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a3dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a3ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a3fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a40d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a41d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a42d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a43d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a44d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a45d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a46d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a47d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a48d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a49d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a4ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a4bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a4cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a4dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a4ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a4fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a50d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a51d	08 1c 3e 7f 7f 1c 3e 00 10 10 10 10 10 10 10 10
>a52d	00 00 00 ff 00 00 00 00 00 00 ff 00 00 00 00 00
>a53d	00 ff 00 00 00 00 00 00 00 00 00 00 00 ff 00 00
>a54d	20 20 20 20 20 20 20 20 04 04 04 04 04 04 04 04
>a55d	00 00 00 00 e0 10 08 08 08 08 08 04 03 00 00 00
>a56d	08 08 08 10 e0 00 00 00 80 80 80 80 80 80 80 ff
>a57d	80 40 20 10 08 04 02 01 01 02 04 08 10 20 40 80
>a58d	ff 80 80 80 80 80 80 80 ff 01 01 01 01 01 01 01
>a59d	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 00 ff 00
>a5ad	36 7f 7f 7f 3e 1c 08 00 40 40 40 40 40 40 40 40
>a5bd	00 00 00 00 03 04 08 08 81 42 24 18 18 24 42 81
>a5cd	00 3c 42 42 42 42 3c 00 08 1c 2a 77 2a 08 08 00
>a5dd	02 02 02 02 02 02 02 02 08 1c 3e 7f 3e 1c 08 00
>a5ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a5fd	08 08 08 08 08 08 08 08 00 00 01 3e 54 14 14 00
>a60d	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a61d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a62d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a63d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>a64d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>a65d	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a66d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>a67d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>a68d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>a69d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>a6ad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>a6bd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a6cd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a6dd	00 00 00 00 00 ff ff ff 01 01 01 01 01 01 01 ff
>a6ed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a6fd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a70d	f0 f0 f0 f0 0f 0f 0f 0f 1c 22 4a 56 4c 20 1e 00
>a71d	18 24 42 7e 42 42 42 00 7c 22 22 3c 22 22 7c 00
>a72d	1c 22 40 40 40 22 1c 00 78 24 22 22 22 24 78 00
>a73d	7e 40 40 78 40 40 7e 00 7e 40 40 78 40 40 40 00
>a74d	1c 22 40 4e 42 22 1c 00 42 42 42 7e 42 42 42 00
>a75d	1c 08 08 08 08 08 1c 00 0e 04 04 04 04 44 38 00
>a76d	42 44 48 70 48 44 42 00 40 40 40 40 40 40 7e 00
>a77d	42 66 5a 5a 42 42 42 00 42 62 52 4a 46 42 42 00
>a78d	18 24 42 42 42 24 18 00 7c 42 42 7c 40 40 40 00
>a79d	18 24 42 42 4a 24 1a 00 7c 42 42 7c 48 44 42 00
>a7ad	3c 42 40 3c 02 42 3c 00 3e 08 08 08 08 08 08 00
>a7bd	42 42 42 42 42 42 3c 00 42 42 42 24 24 18 18 00
>a7cd	42 42 42 5a 5a 66 42 00 42 42 24 18 24 42 42 00
>a7dd	22 22 22 1c 08 08 08 00 7e 02 04 18 20 40 7e 00
>a7ed	3c 20 20 20 20 20 3c 00 00 40 20 10 08 04 02 00
>a7fd	3c 04 04 04 04 04 3c 00 00 08 1c 2a 08 08 08 08
>a80d	00 00 10 20 7f 20 10 00 00 00 00 00 00 00 00 00
>a81d	08 08 08 08 00 00 08 00 24 24 24 00 00 00 00 00
>a82d	24 24 7e 24 7e 24 24 00 08 1e 28 1c 0a 3c 08 00
>a83d	00 62 64 08 10 26 46 00 30 48 48 30 4a 44 3a 00
>a84d	04 08 10 00 00 00 00 00 04 08 10 10 10 08 04 00
>a85d	20 10 08 08 08 10 20 00 08 2a 1c 3e 1c 2a 08 00
>a86d	00 08 08 3e 08 08 00 00 00 00 00 00 00 08 08 10
>a87d	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a88d	00 02 04 08 10 20 40 00 3c 42 46 5a 62 42 3c 00
>a89d	08 18 28 08 08 08 3e 00 3c 42 02 0c 30 40 7e 00
>a8ad	3c 42 02 1c 02 42 3c 00 04 0c 14 24 7e 04 04 00
>a8bd	7e 40 78 04 02 44 38 00 1c 20 40 7c 42 42 3c 00
>a8cd	7e 42 04 08 10 10 10 00 3c 42 42 3c 42 42 3c 00
>a8dd	3c 42 42 3e 02 04 38 00 00 00 08 00 00 08 00 00
>a8ed	00 00 08 00 00 08 08 10 0e 18 30 60 30 18 0e 00
>a8fd	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a90d	3c 42 02 0c 10 00 10 00 00 00 00 00 ff 00 00 00
>a91d	00 00 38 04 3c 44 3a 00 40 40 5c 62 42 62 5c 00
>a92d	00 00 3c 42 40 42 3c 00 02 02 3a 46 42 46 3a 00
>a93d	00 00 3c 42 7e 40 3c 00 0c 12 10 7c 10 10 10 00
>a94d	00 00 3a 46 46 3a 02 3c 40 40 5c 62 42 42 42 00
>a95d	08 00 18 08 08 08 1c 00 04 00 0c 04 04 04 44 38
>a96d	40 40 44 48 50 68 44 00 18 08 08 08 08 08 1c 00
>a97d	00 00 76 49 49 49 49 00 00 00 5c 62 42 42 42 00
>a98d	00 00 3c 42 42 42 3c 00 00 00 5c 62 62 5c 40 40
>a99d	00 00 3a 46 46 3a 02 02 00 00 5c 62 40 40 40 00
>a9ad	00 00 3e 40 3c 02 7c 00 10 10 7c 10 10 12 0c 00
>a9bd	00 00 42 42 42 46 3a 00 00 00 42 42 42 24 18 00
>a9cd	00 00 41 49 49 49 36 00 00 00 42 24 18 24 42 00
>a9dd	00 00 42 42 46 3a 02 3c 00 00 7e 04 18 20 7e 00
>a9ed	08 08 08 08 ff 08 08 08 a0 50 a0 50 a0 50 a0 50
>a9fd	08 08 08 08 08 08 08 08 cc cc 33 33 cc cc 33 33
>aa0d	cc 66 33 99 cc 66 33 99 00 00 00 00 00 00 00 00
>aa1d	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>aa2d	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>aa3d	80 80 80 80 80 80 80 80 aa 55 aa 55 aa 55 aa 55
>aa4d	01 01 01 01 01 01 01 01 00 00 00 00 aa 55 aa 55
>aa5d	99 33 66 cc 99 33 66 cc 03 03 03 03 03 03 03 03
>aa6d	08 08 08 08 0f 08 08 08 00 00 00 00 0f 0f 0f 0f
>aa7d	08 08 08 08 0f 00 00 00 00 00 00 00 f8 08 08 08
>aa8d	00 00 00 00 00 00 ff ff 00 00 00 00 0f 08 08 08
>aa9d	08 08 08 08 ff 00 00 00 00 00 00 00 ff 08 08 08
>aaad	08 08 08 08 f8 08 08 08 c0 c0 c0 c0 c0 c0 c0 c0
>aabd	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>aacd	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>aadd	00 00 00 00 00 ff ff ff 01 02 44 48 50 60 40 00
>aaed	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>aafd	08 08 08 08 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>ab0d	f0 f0 f0 f0 0f 0f 0f 0f

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.ab15					SyntaxError:
.ab15	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab18	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>ab20	72 72 6f 72 00
.ab25					TypeError:
.ab25	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab28	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>ab30	70 65 00
.ab33					BadParamError:
.ab33	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>ab36	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>ab3e	6d 65 74 65 72 00
.ab44					ERR_Handler:
.ab44	a3 00		ldz #$00			ldz 	#0
.ab46	1b		inz				inz
.ab47	ea		nop				nop
.ab48	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ab4a	8d 08 03	sta $0308			sta 	XS_Mantissa
.ab4d	1b		inz				inz
.ab4e	ea		nop				nop
.ab4f	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ab51	8d 09 03	sta $0309			sta 	XS_Mantissa+1
.ab54	fa		plx				plx 								; address in XY
.ab55	7a		ply				ply
.ab56	e8		inx				inx 								; bump, because of RTS/JSR address -1
.ab57	d0 01		bne $ab5a			bne 	_EHNoSkip
.ab59	c8		iny				iny
.ab5a					_EHNoSkip:
.ab5a	20 7b ab	jsr $ab7b			jsr 	PrintROMMessage 			; print message from ROM.
.ab5d	ad 08 03	lda $0308			lda 	XS_Mantissa					; line number = 0
.ab60	0d 09 03	ora $0309			ora 	XS_Mantissa+1
.ab63	f0 0c		beq $ab71			beq 	_EHNoLine
.ab65	a2 76		ldx #$76			ldx 	#_EHAt & $FF 				; print " at "
.ab67	a0 ab		ldy #$ab			ldy 	#(_EHAt >> 8) & $FF
.ab69	20 7b ab	jsr $ab7b			jsr 	PrintROMMessage
.ab6c	a2 00		ldx #$00			ldx 	#0 							; Print line number
.ab6e	20 8c ab	jsr $ab8c			jsr 	Print16BitInteger
.ab71					_EHNoLine:
.ab71	80 fe		bra $ab71			bra 	_EHNoLine
.ab73	4c d1 ad	jmp $add1			jmp 	WarmStart
>ab76	20 61 74 20 00			_EHAt:	.text 	" at ",0
.ab7b					PrintROMMessage:
.ab7b	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.ab7d	84 1b		sty $1b				sty 	zLTemp1+1
.ab7f	a0 00		ldy #$00			ldy 	#0
.ab81					_PRMLoop:
.ab81	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.ab83	f0 06		beq $ab8b			beq		_PRMExit
.ab85	c8		iny				iny
.ab86	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.ab89	80 f6		bra $ab81			bra 	_PRMLoop
.ab8b					_PRMExit:
.ab8b	60		rts				rts
.ab8c					Print16BitInteger:
.ab8c	a9 00		lda #$00			lda 	#0 							; make 32 bit
.ab8e	8d 0a 03	sta $030a			sta 	XS_Mantissa+2
.ab91	8d 0b 03	sta $030b			sta 	XS_Mantissa+3
.ab94	8d 04 04	sta $0404			sta 	NumBufX 					; reset the conversion pointer
.ab97	aa		tax				tax 								; convert bottom level.
.ab98	20 f0 ba	jsr $baf0			jsr 	INTToString 				; make string
.ab9b	a2 00		ldx #$00			ldx 	#0 							; print buffer
.ab9d	bd 05 04	lda $0405,x	_P1Loop:lda 	Num_Buffer,x
.aba0	f0 06		beq $aba8			beq 	_P1Exit
.aba2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aba5	e8		inx				inx
.aba6	80 f5		bra $ab9d			bra 	_P1Loop
.aba8	60		rts		_P1Exit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b4					lastUnaryFunction = $b4
.aba9					VectorTable:
>aba9	05 b1					.word BinaryOp_And         & $FFFF ; $80 and
>abab	2d b1					.word BinaryOp_Or          & $FFFF ; $81 or
>abad	55 b1					.word BinaryOp_Xor         & $FFFF ; $82 xor
>abaf	55 b1					.word BinaryOp_Eor         & $FFFF ; $83 eor
>abb1	99 b1					.word Binary_Equal         & $FFFF ; $84 =
>abb3	b8 b1					.word Binary_NotEqual      & $FFFF ; $85 <>
>abb5	c1 b1					.word Binary_Less          & $FFFF ; $86 <
>abb7	ca b1					.word Binary_LessEqual     & $FFFF ; $87 <=
>abb9	dc b1					.word Binary_Greater       & $FFFF ; $88 >
>abbb	d3 b1					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>abbd	71 b2					.word BinaryOp_Add         & $FFFF ; $8a +
>abbf	91 b2					.word BinaryOp_Subtract    & $FFFF ; $8b -
>abc1	a4 b2					.word BinaryOp_Multiply    & $FFFF ; $8c *
>abc3	b7 b2					.word BinaryOp_Divide      & $FFFF ; $8d /
>abc5	5d ac					.word NotImplemented       & $FFFF ; $8e ^
>abc7	5d ac					.word NotImplemented       & $FFFF ; $8f if
>abc9	5d ac					.word NotImplemented       & $FFFF ; $90 while
>abcb	5d ac					.word NotImplemented       & $FFFF ; $91 repeat
>abcd	5d ac					.word NotImplemented       & $FFFF ; $92 for
>abcf	5d ac					.word NotImplemented       & $FFFF ; $93 then
>abd1	5d ac					.word NotImplemented       & $FFFF ; $94 endif
>abd3	5d ac					.word NotImplemented       & $FFFF ; $95 wend
>abd5	5d ac					.word NotImplemented       & $FFFF ; $96 until
>abd7	5d ac					.word NotImplemented       & $FFFF ; $97 next
>abd9	5d ac					.word NotImplemented       & $FFFF ; $98 not
>abdb	5d ac					.word NotImplemented       & $FFFF ; $99 fn(
>abdd	eb b3					.word Unary_Abs            & $FFFF ; $9a abs(
>abdf	42 b5					.word Unary_Asc            & $FFFF ; $9b asc(
>abe1	d1 c2					.word Unary_Int            & $FFFF ; $9c int(
>abe3	09 b4					.word Unary_Peek           & $FFFF ; $9d peek(
>abe5	48 c2					.word Unary_Rnd            & $FFFF ; $9e rnd(
>abe7	7d b4					.word Unary_Usr            & $FFFF ; $9f usr(
>abe9	83 b5					.word Unary_Left           & $FFFF ; $a0 left$(
>abeb	9a b5					.word Unary_Right          & $FFFF ; $a1 right$(
>abed	68 b5					.word Unary_Mid            & $FFFF ; $a2 mid$(
>abef	fc b6					.word Unary_Spc            & $FFFF ; $a3 spc(
>abf1	0f b5					.word Unary_Str            & $FFFF ; $a4 str$(
>abf3	9e b4					.word Unary_Val            & $FFFF ; $a5 val(
>abf5	59 b5					.word Unary_Len            & $FFFF ; $a6 len(
>abf7	18 b6					.word Unary_Hex            & $FFFF ; $a7 hex$(
>abf9	5d ac					.word NotImplemented       & $FFFF ; $a8 sin(
>abfb	5d ac					.word NotImplemented       & $FFFF ; $a9 cos(
>abfd	5d ac					.word NotImplemented       & $FFFF ; $aa tan(
>abff	5d ac					.word NotImplemented       & $FFFF ; $ab atn(
>ac01	5d ac					.word NotImplemented       & $FFFF ; $ac exp(
>ac03	5d ac					.word NotImplemented       & $FFFF ; $ad log(
>ac05	5d ac					.word NotImplemented       & $FFFF ; $ae sqr(
>ac07	72 b6					.word Unary_Dec            & $FFFF ; $af dec(
>ac09	0d b4					.word Unary_Deek           & $FFFF ; $b0 deek(
>ac0b	11 b4					.word Unary_Leek           & $FFFF ; $b1 leek(
>ac0d	45 b4					.word Unary_Mod            & $FFFF ; $b2 mod(
>ac0f	99 b3					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>ac11	da b6					.word Unary_Chr            & $FFFF ; $b4 chr$(
>ac13	5d ac					.word NotImplemented       & $FFFF ; $b5 $
>ac15	5d ac					.word NotImplemented       & $FFFF ; $b6 $(
>ac17	5d ac					.word NotImplemented       & $FFFF ; $b7 #
>ac19	5d ac					.word NotImplemented       & $FFFF ; $b8 #(
>ac1b	5d ac					.word NotImplemented       & $FFFF ; $b9 %
>ac1d	5d ac					.word NotImplemented       & $FFFF ; $ba %(
>ac1f	5d ac					.word NotImplemented       & $FFFF ; $bb (
>ac21	5d ac					.word NotImplemented       & $FFFF ; $bc )
>ac23	5d ac					.word NotImplemented       & $FFFF ; $bd ,
>ac25	56 ae					.word Command_COLON        & $FFFF ; $be :
>ac27	5d ac					.word NotImplemented       & $FFFF ; $bf ;
>ac29	5d ac					.word NotImplemented       & $FFFF ; $c0 def
>ac2b	0e af					.word Command_CLR          & $FFFF ; $c1 clr
>ac2d	1c af					.word Command_STOP         & $FFFF ; $c2 stop
>ac2f	5d ac					.word NotImplemented       & $FFFF ; $c3 data
>ac31	5d ac					.word NotImplemented       & $FFFF ; $c4 read
>ac33	5d ac					.word NotImplemented       & $FFFF ; $c5 dim
>ac35	5d ac					.word NotImplemented       & $FFFF ; $c6 to
>ac37	5d ac					.word NotImplemented       & $FFFF ; $c7 step
>ac39	5d ac					.word NotImplemented       & $FFFF ; $c8 gosub
>ac3b	5d ac					.word NotImplemented       & $FFFF ; $c9 return
>ac3d	5d ac					.word NotImplemented       & $FFFF ; $ca goto
>ac3f	78 ae					.word Command_END          & $FFFF ; $cb end
>ac41	5d ac					.word NotImplemented       & $FFFF ; $cc input
>ac43	57 ae					.word Command_LET          & $FFFF ; $cd let
>ac45	5d ac					.word NotImplemented       & $FFFF ; $ce list
>ac47	5d ac					.word NotImplemented       & $FFFF ; $cf new
>ac49	5d ac					.word NotImplemented       & $FFFF ; $d0 old
>ac4b	5d ac					.word NotImplemented       & $FFFF ; $d1 on
>ac4d	5d ac					.word NotImplemented       & $FFFF ; $d2 restore
>ac4f	5d ac					.word NotImplemented       & $FFFF ; $d3 poke
>ac51	7d ae					.word Command_PRINT        & $FFFF ; $d4 print
>ac53	d7 ad					.word Command_RUN          & $FFFF ; $d5 run
>ac55	5d ac					.word NotImplemented       & $FFFF ; $d6 wait
>ac57	5d ac					.word NotImplemented       & $FFFF ; $d7 doke
>ac59	5d ac					.word NotImplemented       & $FFFF ; $d8 loke
>ac5b	f2 ae					.word Command_ASSERT       & $FFFF ; $d9 assert
.ac5d					NotImplemented:
.ac5d	20 44 ab	jsr $ab44			jsr ERR_Handler
>ac60	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>ac68	65 6d 65 6e 74 65 64 00
.ac70					BinaryPrecedence:
>ac70	01					.byte 1    ; $80 and
>ac71	01					.byte 1    ; $81 or
>ac72	01					.byte 1    ; $82 xor
>ac73	01					.byte 1    ; $83 eor
>ac74	02					.byte 2    ; $84 =
>ac75	02					.byte 2    ; $85 <>
>ac76	02					.byte 2    ; $86 <
>ac77	02					.byte 2    ; $87 <=
>ac78	02					.byte 2    ; $88 >
>ac79	02					.byte 2    ; $89 >=
>ac7a	03					.byte 3    ; $8a +
>ac7b	03					.byte 3    ; $8b -
>ac7c	04					.byte 4    ; $8c *
>ac7d	04					.byte 4    ; $8d /
>ac7e	05					.byte 5    ; $8e ^
.ac7f					KeywordText:
>ac7f	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>ac82	4f d2					.byte $4f,$d2                          ; $81 or
>ac84	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>ac87	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>ac8a	bd					.byte $bd                              ; $84 =
>ac8b	3c be					.byte $3c,$be                          ; $85 <>
>ac8d	bc					.byte $bc                              ; $86 <
>ac8e	3c bd					.byte $3c,$bd                          ; $87 <=
>ac90	be					.byte $be                              ; $88 >
>ac91	3e bd					.byte $3e,$bd                          ; $89 >=
>ac93	ab					.byte $ab                              ; $8a +
>ac94	ad					.byte $ad                              ; $8b -
>ac95	aa					.byte $aa                              ; $8c *
>ac96	af					.byte $af                              ; $8d /
>ac97	de					.byte $de                              ; $8e ^
>ac98	49 c6					.byte $49,$c6                          ; $8f if
>ac9a	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>ac9f	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>aca5	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>aca8	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>acac	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>acb1	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>acb5	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>acba	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>acbe	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>acc1	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>acc4	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>acc8	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>accc	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>acd0	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>acd5	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>acd9	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>acdd	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>ace3	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>acea	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>acef	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>acf3	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>acf8	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>acfc	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>ad00	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>ad05	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>ad09	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>ad0d	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>ad11	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>ad15	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>ad19	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>ad1d	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>ad21	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>ad25	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>ad2a	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>ad2f	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>ad33	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>ad37	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>ad3c	a4					.byte $a4                              ; $b5 $
>ad3d	24 a8					.byte $24,$a8                          ; $b6 $(
>ad3f	a3					.byte $a3                              ; $b7 #
>ad40	23 a8					.byte $23,$a8                          ; $b8 #(
>ad42	a5					.byte $a5                              ; $b9 %
>ad43	25 a8					.byte $25,$a8                          ; $ba %(
>ad45	a8					.byte $a8                              ; $bb (
>ad46	a9					.byte $a9                              ; $bc )
>ad47	ac					.byte $ac                              ; $bd ,
>ad48	ba					.byte $ba                              ; $be :
>ad49	bb					.byte $bb                              ; $bf ;
>ad4a	44 45 c6				.byte $44,$45,$c6                      ; $c0 def
>ad4d	43 4c d2				.byte $43,$4c,$d2                      ; $c1 clr
>ad50	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c2 stop
>ad54	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c3 data
>ad58	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c4 read
>ad5c	44 49 cd				.byte $44,$49,$cd                      ; $c5 dim
>ad5f	54 cf					.byte $54,$cf                          ; $c6 to
>ad61	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c7 step
>ad65	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
>ad6a	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
>ad70	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $ca goto
>ad74	45 4e c4				.byte $45,$4e,$c4                      ; $cb end
>ad77	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $cc input
>ad7c	4c 45 d4				.byte $4c,$45,$d4                      ; $cd let
>ad7f	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $ce list
>ad83	4e 45 d7				.byte $4e,$45,$d7                      ; $cf new
>ad86	4f 4c c4				.byte $4f,$4c,$c4                      ; $d0 old
>ad89	4f ce					.byte $4f,$ce                          ; $d1 on
>ad8b	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d2 restore
>ad92	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d3 poke
>ad96	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d4 print
>ad9b	52 55 ce				.byte $52,$55,$ce                      ; $d5 run
>ad9e	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d6 wait
>ada2	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $d7 doke
>ada6	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $d8 loke
>adaa	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
>adb0	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_dollar = $b5
=$b6					token_dollarlparen = $b6
=$b7					token_hash = $b7
=$b8					token_hashlparen = $b8
=$b9					token_percent = $b9
=$ba					token_percentlparen = $ba
=$bb					token_lparen = $bb
=$bc					token_rparen = $bc
=$bd					token_comma = $bd
=$be					token_colon = $be
=$bf					token_semicolon = $bf
=$c0					token_def = $c0
=$c1					token_clr = $c1
=$c2					token_stop = $c2
=$c3					token_data = $c3
=$c4					token_read = $c4
=$c5					token_dim = $c5
=$c6					token_to = $c6
=$c7					token_step = $c7
=$c8					token_gosub = $c8
=$c9					token_return = $c9
=$ca					token_goto = $ca
=$cb					token_end = $cb
=$cc					token_input = $cc
=$cd					token_let = $cd
=$ce					token_list = $ce
=$cf					token_new = $cf
=$d0					token_old = $d0
=$d1					token_on = $d1
=$d2					token_restore = $d2
=$d3					token_poke = $d3
=$d4					token_print = $d4
=$d5					token_run = $d5
=$d6					token_wait = $d6
=$d7					token_doke = $d7
=$d8					token_loke = $d8
=$d9					token_assert = $d9

;******  Return to file: modules/basic/core.asm

.adb1					BASIC_Start:
.adb1	20 4d a2	jsr $a24d			jsr 	IF_Reset 					; set up and clear screen.
.adb4	20 0c a0	jsr $a00c			jsr 	IFT_ClearScreen
.adb7	a9 4c		lda #$4c			lda 	#$4C 						; JMP opcode
.adb9	8d 04 03	sta $0304			sta 	LocalVector
.adbc	8d 00 03	sta $0300			sta 	UserVector
.adbf	a9 8c		lda #$8c			lda 	#USRDefault & $FF 			; reset USR vector
.adc1	8d 01 03	sta $0301			sta 	UserVector+1
.adc4	a9 b4		lda #$b4			lda 	#(USRDefault >> 8) & $FF
.adc6	8d 02 03	sta $0302			sta 	UserVector+2
.adc9	a9 00		lda #$00			lda 	#(USRDefault >> 16) & $FF
.adcb	8d 03 03	sta $0303			sta 	UserVector+3
.adce	20 0e af	jsr $af0e			jsr 	ResetRunStatus 				; clear everything (CLR command)
.add1					WarmStart:
.add1	a2 ff		ldx #$ff			ldx 		#$FF 					; empty stack
.add3	9a		txs				txs
.add4	4c d7 ad	jmp $add7			jmp 	COMMAND_Run

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.add7					Command_RUN:
.add7	20 0e af	jsr $af0e			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.adda	a9 00		lda #$00			lda 	#BasicProgram & $FF
.addc	85 16		sta $16				sta 	zCodePtr+0
.adde	a9 80		lda #$80			lda 	#BasicProgram >> 8
.ade0	85 17		sta $17				sta 	zCodePtr+1
.ade2	a9 02		lda #$02			lda 	#2
.ade4	85 18		sta $18				sta 	zCodePtr+2
.ade6	a9 00		lda #$00			lda 	#0
.ade8	85 19		sta $19				sta 	zCodePtr+3
.adea	a3 03		ldz #$03			ldz 	#3
.adec					RUN_NewLine:
.adec	a3 00		ldz #$00			ldz 	#0
.adee	ea		nop				nop
.adef	b2 16		lda ($16),z			lda 	(zCodePtr),z
.adf1	1b		inz				inz
.adf2	1b		inz				inz
.adf3	1b		inz				inz
.adf4	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.adf6	d0 18		bne $ae10			bne 	RUN_NextCommand
.adf8	4c 1c af	jmp $af1c			jmp 	Command_STOP 				; go do the command code.
.adfb					RUN_Skip:
.adfb	ea		nop				nop
.adfc	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read element
.adfe	1b		inz				inz 								; skip
.adff	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.ae01	90 0d		bcc $ae10			bcc 	_SEDone 					; so just skip over it.
.ae03	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.ae05	90 08		bcc $ae0f			bcc 	_SEDouble
.ae07	6b		tza				tza 								; this is Y + 1
.ae08	18		clc				clc
.ae09	ea		nop				nop
.ae0a	72 16		adc ($16),z			adc 	(zCodePtr),z 				; add total length of element
.ae0c	4b		taz				taz 								; back in Y.
.ae0d	3b		dez				dez 								; fix up, one for the +1, one for the iny
.ae0e	3b		dez				dez
.ae0f					_SEDouble:
.ae0f	1b		inz				inz
.ae10					_SEDone:
.ae10					RUN_NextCommand:
.ae10	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.ae12	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.ae14	ea		nop				nop
.ae15	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae17	c9 be		cmp #$be			cmp 	#token_Colon 				; skip over colons
.ae19	f0 e0		beq $adfb			beq 	RUN_Skip
.ae1b	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.ae1d	d0 10		bne $ae2f			bne 	RUN_Execute
.ae1f					RUN_NextLine:
.ae1f	a3 00		ldz #$00			ldz 	#0 							; point to offset
.ae21	ea		nop				nop
.ae22	b2 16		lda ($16),z			lda 	(zCodePtr),z 				; read it
.ae24	18		clc				clc
.ae25	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.ae27	85 16		sta $16				sta 	zCodePtr
.ae29	90 02		bcc $ae2d			bcc 	_SNLNoCarry
.ae2b	e6 17		inc $17				inc 	zCodePtr+1
.ae2d					_SNLNoCarry:
.ae2d	80 bd		bra $adec			bra 	RUN_NewLine 				; go do the new line code
.ae2f					RUN_Execute:
.ae2f	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.ae31	b0 1c		bcs $ae4f			bcs 	RUN_Extension
.ae33	1b		inz				inz
.ae34	0a		asl a				asl 	a 							; double the character read.
.ae35	90 12		bcc $ae49			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.ae37	aa		tax				tax 								; ready to look up.
.ae38	bd a9 ab	lda $aba9,x			lda 	VectorTable,x 				; copy address into LocalVector
.ae3b	8d 05 03	sta $0305			sta 	LocalVector+1
.ae3e	bd aa ab	lda $abaa,x			lda 	VectorTable+1,x
.ae41	8d 06 03	sta $0306			sta 	LocalVector+2
.ae44	20 3c b0	jsr $b03c			jsr 	EVCallLocalVector 			; execute the appropriate code.
.ae47	80 c7		bra $ae10			bra 	RUN_NextCommand 			; do the next command.
.ae49					RUN_Default:
.ae49	3b		dez				dez
.ae4a	20 57 ae	jsr $ae57			jsr 	Command_LET 				; and try LET.
.ae4d	80 c1		bra $ae10			bra 	RUN_NextCommand
.ae4f					RUN_Extension:
.ae4f	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.ae51	f0 a8		beq $adfb			beq 	RUN_Skip 					; skip over it.
.ae53	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.ae56					Command_COLON:
.ae56	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.ae57					Command_LET:
.ae57	20 de b7	jsr $b7de			jsr 	VariableFind 				; get reference to one variable.
.ae5a	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.ae5c	20 50 b7	jsr $b750			jsr 	CheckNextToken
.ae5f	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.ae61	48		pha				pha
.ae62	a5 23		lda $23				lda 	zVarDataPtr+1
.ae64	48		pha				pha
.ae65	a5 24		lda $24				lda 	zVarType
.ae67	48		pha				pha
.ae68	20 27 af	jsr $af27			jsr 	EvaluateExpression 			; evaluate the RHS.
.ae6b	68		pla				pla 								; restore target variable information.
.ae6c	85 24		sta $24				sta 	zVarType
.ae6e	68		pla				pla
.ae6f	85 23		sta $23				sta 	zVarDataPtr+1
.ae71	68		pla				pla
.ae72	85 22		sta $22				sta 	zVarDataPtr
.ae74	20 7c b9	jsr $b97c			jsr 	VariableSet 				; set the value out.
.ae77	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.ae78					Command_END:
.ae78	80 fe		bra $ae78	_halt:	bra 		_halt
.ae7a	4c d1 ad	jmp $add1			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.ae7d					Command_PRINT:
.ae7d	ea		nop				nop
.ae7e	b2 16		lda ($16),z			lda 	(zCodePtr),z
.ae80	c9 00		cmp #$00			cmp 	#0 							; end
.ae82	f0 6a		beq $aeee			beq 	_CPR_NewLine
.ae84	c9 be		cmp #$be			cmp 	#token_Colon
.ae86	f0 66		beq $aeee			beq 	_CPR_NewLine
.ae88	c9 bf		cmp #$bf			cmp 	#token_SemiColon
.ae8a	f0 54		beq $aee0			beq 	_CPR_Skip
.ae8c	c9 bd		cmp #$bd			cmp 	#token_Comma
.ae8e	f0 4d		beq $aedd			beq 	_CPR_Tab
.ae90	20 27 af	jsr $af27			jsr 	EvaluateExpression 			; get expression.
.ae93	ad 0d 03	lda $030d			lda 	XS_Type 					; get type.
.ae96	29 02		and #$02			and 	#2
.ae98	d0 25		bne $aebf			bne 	_CPR_String 				; if type = 2 output as string.
.ae9a					_CPR_Number:
.ae9a	a9 00		lda #$00			lda 	#0 							; reset buffer index
.ae9c	8d 04 04	sta $0404			sta 	NumBufX
.ae9f	ad 0d 03	lda $030d			lda 	XS_Type 					; get type
.aea2	4a		lsr a				lsr 	a
.aea3	b0 05		bcs $aeaa			bcs 	_CPRInt 					; if msb set do as integer
.aea5	20 00 c1	jsr $c100			jsr 	FPToString 					; call fp to str otherwise
.aea8	80 03		bra $aead			bra 	_CPRNPrint
.aeaa	20 f0 ba	jsr $baf0	_CPRInt:jsr 	IntToString
.aead					_CPRNPrint:
.aead	ad 05 04	lda $0405			lda 	Num_Buffer 					; is first character -
.aeb0	c9 2d		cmp #$2d			cmp 	#"-"
.aeb2	f0 05		beq $aeb9			beq 	_CPRNoSpace
.aeb4	a9 20		lda #$20			lda 	#" "						; print the leading space
.aeb6	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; so beloved of MS Basics.
.aeb9					_CPRNoSpace:
.aeb9	a2 04		ldx #$04			ldx 	#(Num_Buffer-1) & $FF
.aebb	a9 04		lda #$04			lda 	#(Num_Buffer-1) >> 8
.aebd	80 06		bra $aec5			bra 	_CPRPrint
.aebf					_CPR_String:
.aebf	ae 08 03	ldx $0308			ldx 	XS_Mantissa
.aec2	ad 09 03	lda $0309			lda 	XS_Mantissa+1
.aec5					_CPRPrint:
.aec5	86 1e		stx $1e				stx 	zGenPtr
.aec7	85 1f		sta $1f				sta 	zGenPtr+1
.aec9	5a		phy				phy
.aeca	a0 00		ldy #$00			ldy 	#0							; get length into X
.aecc	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.aece	aa		tax				tax
.aecf	f0 09		beq $aeda			beq 	_CPREndPrint 				; nothing to print
.aed1					_CPRLoop:
.aed1	c8		iny				iny
.aed2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.aed4	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.aed7	ca		dex				dex
.aed8	d0 f7		bne $aed1			bne 	_CPRLoop
.aeda					_CPREndPrint:
.aeda	7a		ply				ply
.aedb	80 a0		bra $ae7d			bra 	Command_Print
.aedd					_CPR_Tab:
.aedd	20 5b a0	jsr $a05b			jsr 	IFT_Tab
.aee0					_CPR_Skip:
.aee0	1b		inz				inz
.aee1	ea		nop				nop
.aee2	b2 16		lda ($16),z			lda 	(zCodePtr),z
.aee4	c9 be		cmp #$be			cmp 	#token_Colon 				; colon or $00, exit
.aee6	f0 09		beq $aef1			beq 	_CPR_Exit
.aee8	c9 00		cmp #$00			cmp 	#0
.aeea	d0 91		bne $ae7d			bne 	Command_PRINT 				; if not go round again.
.aeec	80 03		bra $aef1			bra 	_CPR_Exit
.aeee					_CPR_NewLine:
.aeee	20 68 a0	jsr $a068			jsr 	IFT_NewLine
.aef1					_CPR_Exit:
.aef1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.aef2					Command_ASSERT:
.aef2	20 d4 b0	jsr $b0d4			jsr 	EvaluateNumber 				; calculate thing being asserted
.aef5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.aef8	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.aefb	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.aefe	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.af01	f0 01		beq $af04			beq 	_ASFail
.af03	60		rts				rts
.af04					_ASFail:
.af04	20 44 ab	jsr $ab44			jsr ERR_Handler
>af07	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.af0e					Command_CLR:
.af0e					ResetRunStatus:
.af0e	20 ea b7	jsr $b7ea			jsr 	VariableClear
.af11	a9 00		lda #$00			lda 	#HighMemory & $FF
.af13	8d 00 04	sta $0400			sta 	StringPtr
.af16	a9 70		lda #$70			lda 	#HighMemory >> 8
.af18	8d 01 04	sta $0401			sta 	StringPtr+1
.af1b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.af1c					Command_STOP:
.af1c	20 44 ab	jsr $ab44			jsr ERR_Handler
>af1f	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.af24					EVESyntax:
.af24	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.af27					EvaluateExpression:
.af27	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.af29					EvaluateExpressionX:
.af29	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.af2b					EvaluateExpressionXA:
.af2b	48		pha				pha 								; save precedence on stack.
.af2c	ea		nop				nop
.af2d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af2f	f0 f3		beq $af24			beq 	EVESyntax 					; end of line, syntax error.
.af31	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.af33	b0 03		bcs $af38			bcs 	_EVNotVariable
.af35	4c 33 b0	jmp $b033			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.af38					_EVNotVariable:
.af38	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.af3a	90 e8		bcc $af24			bcc 	EVESyntax
.af3c	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.af3e	b3 82 00	bcs $afc2			bcs 	_EVNotInteger
.af41	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.af43	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.af46	a9 00		lda #$00			lda 	#0
.af48	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.af4b	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.af4e	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.af51	1a		inc a				inc 	a 							; set to type 1 (integer)
.af52	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.af55					_EVCheckNextInteger:
.af55	1b		inz				inz
.af56	ea		nop				nop
.af57	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af59	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.af5b	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.af5d	b0 0d		bcs $af6c			bcs 	_EVCheckDecimal
.af5f	48		pha				pha 								; save it.
.af60	20 3f b0	jsr $b03f			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.af63	68		pla				pla
.af64	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.af67	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.af6a	80 e9		bra $af55			bra 	_EVCheckNextInteger
.af6c					_EVCheckDecimal:
.af6c	ea		nop				nop
.af6d	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af6f	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.af71	d0 05		bne $af78			bne 	_EVGotAtom 					; no, get atom.
.af73					_EVIsDecimal:
.af73	20 6f b0	jsr $b06f			jsr 	EVGetDecimal 				; extend to the decimal part.
.af76	80 00		bra $af78			bra 	_EVGotAtom 					; and continue to got atom.
.af78					_EVGotAtom:
.af78	ea		nop				nop
.af79	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af7b	10 43		bpl $afc0			bpl 	_EVExitDrop 				; must be a token.
.af7d	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.af7f	b0 3f		bcs $afc0			bcs 	_EVExitDrop
.af81	68		pla				pla 								; get current precedence
.af82	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.af84	da		phx				phx 								; save X
.af85	ea		nop				nop
.af86	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af88	aa		tax				tax 								; put in X
.af89	bd f0 ab	lda $abf0,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.af8c	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.af8e	fa		plx				plx 								; restore X
.af8f	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.af91	90 2e		bcc $afc1			bcc 	_EVExit 					; exit if too low.
.af93	f0 2c		beq $afc1			beq 	_EVExit 					; exit if equals
.af95	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.af97	48		pha				pha
.af98	ea		nop				nop
.af99	b2 16		lda ($16),z			lda 	(zCodePtr),z
.af9b	48		pha				pha
.af9c	1b		inz				inz
.af9d	da		phx				phx 								; save current position
.af9e	e8		inx				inx
.af9f	e8		inx				inx
.afa0	e8		inx				inx
.afa1	e8		inx				inx
.afa2	e8		inx				inx
.afa3	e8		inx				inx
.afa4	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.afa6	20 2b af	jsr $af2b			jsr 	EvaluateExpressionXA 		; do the RHS.
.afa9	fa		plx				plx 								; restore X
.afaa	68		pla				pla 								; get the binary operator in A.
.afab					_EVCallA:
.afab	da		phx				phx 								; save X again
.afac	0a		asl a				asl 	a 							; double, lose the MSB.
.afad	aa		tax				tax									; put in X
.afae	bd a9 ab	lda $aba9,x			lda 	VectorTable,x 				; copy address into zGenPtr
.afb1	8d 05 03	sta $0305			sta 	LocalVector+1
.afb4	bd aa ab	lda $abaa,x			lda 	VectorTable+1,x
.afb7	8d 06 03	sta $0306			sta 	LocalVector+2
.afba	fa		plx				plx 								; restore X
.afbb	20 3c b0	jsr $b03c			jsr 	EVCallLocalVector
.afbe	80 b8		bra $af78			bra 	_EVGotAtom 					; and loop back.
.afc0					_EVExitDrop:
.afc0	68		pla				pla
.afc1					_EVExit:
.afc1	60		rts				rts
.afc2					_EVNotInteger:
.afc2	1b		inz				inz
.afc3	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.afc5	d0 19		bne $afe0			bne 	_EVNotMinus
.afc7	20 c2 b0	jsr $b0c2			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.afca	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.afcd	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.afcf	f0 05		beq $afd6			beq 	_EVMinusFloat
.afd1	20 cb ba	jsr $bacb			jsr 	IntegerNegateAlways 		; negation
.afd4	80 a2		bra $af78			bra 	_EVGotAtom 					; and go back.
.afd6					_EVMinusFloat:
.afd6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; invert the sign bit.
.afd9	49 80		eor #$80			eor 	#$80
.afdb	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.afde	80 98		bra $af78			bra 	_EVGotAtom
.afe0					_EVNotMinus:
.afe0	c9 bb		cmp #$bb			cmp 	#token_lparen 				; is it left parenthesis
.afe2	d0 18		bne $affc			bne 	_EVNotParenthesis
.afe4	20 29 af	jsr $af29			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.afe7	ea		nop				nop
.afe8	b2 16		lda ($16),z			lda 	(zCodePtr),z
.afea	1b		inz				inz
.afeb	c9 bc		cmp #$bc			cmp 	#token_rparen 				; okay if right bracket.
.afed	f0 89		beq $af78			beq 	_EVGotAtom
.afef	20 44 ab	jsr $ab44			jsr ERR_Handler
>aff2	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>affa	29 00
.affc					_EVNotParenthesis:
.affc	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.affe	d0 0c		bne $b00c			bne 	_EVNotNot
.b000	20 c2 b0	jsr $b0c2			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.b003	20 d5 bf	jsr $bfd5			jsr 	FPUToInteger 				; make it an integer - if possible.
.b006	20 9f b0	jsr $b09f			jsr 	NotInteger 					; do the not calculation
.b009	4c 78 af	jmp $af78			jmp 	_EVGotAtom
.b00c					_EVNotNot:
.b00c	c9 fe		cmp #$fe			cmp 	#$FE
.b00e	d0 15		bne $b025			bne 	_EVNotString
.b010	20 b5 b7	jsr $b7b5			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.b013	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.b015	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b018	a5 21		lda $21				lda 	zTempStr+1
.b01a	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b01d	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.b01f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b022	4c 78 af	jmp $af78			jmp 	_EVGotAtom
.b025					_EVNotString:
.b025	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.b027	90 04		bcc $b02d			bcc 	_EVBadElement
.b029	c9 b5		cmp #$b5			cmp 	#lastUnaryFunction+1
.b02b	90 03		bcc $b030			bcc 	_EVUnaryFunction
.b02d					_EVBadElement:
.b02d	4c 15 ab	jmp $ab15			jmp 	SyntaxError
.b030					_EVUnaryFunction:
.b030	4c ab af	jmp $afab			jmp 	_EVCallA
.b033					_EVVariableHandler:
.b033	20 de b7	jsr $b7de			jsr 	VariableFind 				; locate a variable
.b036	20 1d b9	jsr $b91d			jsr 	VariableGet 				; copy into memory.
.b039	4c 78 af	jmp $af78			jmp 	_EVGotAtom 					; and go round.
.b03c					EVCallLocalVector:
.b03c	6c 05 03	jmp ($0305)			jmp 	(LocalVector+1)
.b03f					EVShiftMantissaLeft6:
.b03f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.b042	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.b045	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b048	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b04b	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b04e	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b051	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b054	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b057	a9 00		lda #$00			lda 	#0
.b059	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b05c	20 5f b0	jsr $b05f			jsr 	_EVSMLShift 					; call it here to do it twice
.b05f					_EVSMLShift:
.b05f	5e 0c 03	lsr $030c,x			lsr 	XS_Exponent,x
.b062	7e 0b 03	ror $030b,x			ror 	XS_Mantissa+3,x
.b065	7e 0a 03	ror $030a,x			ror 	XS_Mantissa+2,x
.b068	7e 09 03	ror $0309,x			ror 	XS_Mantissa+1,x
.b06b	7e 08 03	ror $0308,x			ror 	XS_Mantissa+0,x
.b06e	60		rts				rts
.b06f					EVGetDecimal:
.b06f	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.b071	8d 05 04	sta $0405			sta 	Num_Buffer
.b074	da		phx				phx
.b075	1b		inz				inz
.b076	ea		nop				nop
.b077	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b079	1b		inz				inz
.b07a	3a		dec a				dec 	a								; convert to a string length.
.b07b	3a		dec a				dec 	a
.b07c	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.b07e					_EVGDCopy:
.b07e	48		pha				pha 									; save count
.b07f	ea		nop				nop
.b080	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b082	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.b085	e8		inx				inx 									; forward ....
.b086	1b		inz				inz
.b087	68		pla				pla 									; get count
.b088	3a		dec a				dec 	a 								; until zero
.b089	d0 f3		bne $b07e			bne 	_EVGDCopy
.b08b	9d 05 04	sta $0405,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.b08e	fa		plx				plx 									; restore X
.b08f	a9 05		lda #$05			lda 	#Num_Buffer & $FF 				; set zGenPtr
.b091	85 1e		sta $1e				sta 	zGenPtr
.b093	a9 04		lda #$04			lda 	#Num_Buffer >> 8
.b095	85 1f		sta $1f				sta 	zGenPtr+1
.b097	5a		phy				phy 									; save Y
.b098	a0 00		ldy #$00			ldy 	#0 								; start position
.b09a	20 c7 c1	jsr $c1c7			jsr 	FPFromString 					; convert current
.b09d	7a		ply				ply 									; restore Y
.b09e	60		rts				rts
.b09f					NotInteger:
.b09f	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b0a2	49 ff		eor #$ff			eor 	#$FF
.b0a4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b0a7	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b0aa	49 ff		eor #$ff			eor 	#$FF
.b0ac	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b0af	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b0b2	49 ff		eor #$ff			eor 	#$FF
.b0b4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b0b7	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b0ba	49 ff		eor #$ff			eor 	#$FF
.b0bc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b0bf	60		rts				rts
.b0c0					EvaluateGetAtom:
.b0c0	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.b0c2					EvaluateGetAtomX:
.b0c2	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.b0c4	20 2b af	jsr $af2b			jsr 	EvaluateExpressionXA
.b0c7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.b0ca	29 0f		and #$0f			and 	#15
.b0cc	c9 02		cmp #$02			cmp 	#2
.b0ce	b0 01		bcs $b0d1			bcs 	EvaluateType
.b0d0	60		rts				rts
.b0d1					EvaluateType:
.b0d1	4c 25 ab	jmp $ab25			jmp 	TypeError
.b0d4					EvaluateNumber:
.b0d4	a2 00		ldx #$00			ldx 	#0
.b0d6					EvaluateNumberX:
.b0d6	20 29 af	jsr $af29			jsr 	EvaluateExpressionX
.b0d9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 0/1
.b0dc	29 0f		and #$0f			and 	#15
.b0de	c9 02		cmp #$02			cmp 	#2
.b0e0	b0 ef		bcs $b0d1			bcs 	EvaluateType
.b0e2	60		rts				rts
.b0e3					EvaluateInteger:
.b0e3	a2 00		ldx #$00			ldx 	#0
.b0e5					EvaluateIntegerX:
.b0e5	20 d6 b0	jsr $b0d6			jsr 	EvaluateNumberX
.b0e8	20 d5 bf	jsr $bfd5			jsr 	FPUToInteger
.b0eb	60		rts				rts
.b0ec					EvaluateString:
.b0ec	a2 00		ldx #$00			ldx 	#0
.b0ee					EvaluateStringX:
.b0ee	20 29 af	jsr $af29			jsr 	EvaluateExpressionX
.b0f1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 						; check type is 2
.b0f4	29 0f		and #$0f			and 	#15
.b0f6	c9 02		cmp #$02			cmp 	#2
.b0f8	d0 d7		bne $b0d1			bne 	EvaluateType
.b0fa	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.b0fd	85 1e		sta $1e				sta 	zGenPtr
.b0ff	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b102	85 1f		sta $1f				sta 	zGenPtr+1
.b104	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.b105					BinaryOp_And:
.b105	20 7d b1	jsr $b17d			jsr 	BinaryMakeBothInteger
.b108	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b10b	3d 0e 03	and $030e,x			and 	XS2_Mantissa+0,x
.b10e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b111	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b114	3d 0f 03	and $030f,x			and 	XS2_Mantissa+1,x
.b117	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b11a	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b11d	3d 10 03	and $0310,x			and 	XS2_Mantissa+2,x
.b120	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b123	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b126	3d 11 03	and $0311,x			and 	XS2_Mantissa+3,x
.b129	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b12c	60		rts				rts
.b12d					BinaryOp_Or:
.b12d	20 7d b1	jsr $b17d			jsr 	BinaryMakeBothInteger
.b130	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b133	1d 0e 03	ora $030e,x			ora 	XS2_Mantissa+0,x
.b136	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b139	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b13c	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.b13f	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b142	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b145	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.b148	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b14b	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b14e	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.b151	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b154	60		rts				rts
.b155					BinaryOp_Eor:
.b155					BinaryOp_Xor:
.b155	20 7d b1	jsr $b17d			jsr 	BinaryMakeBothInteger
.b158	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x
.b15b	5d 0e 03	eor $030e,x			eor 	XS2_Mantissa+0,x
.b15e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b161	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.b164	5d 0f 03	eor $030f,x			eor 	XS2_Mantissa+1,x
.b167	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b16a	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.b16d	5d 10 03	eor $0310,x			eor 	XS2_Mantissa+2,x
.b170	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b173	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.b176	5d 11 03	eor $0311,x			eor 	XS2_Mantissa+3,x
.b179	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b17c	60		rts				rts
.b17d					BinaryMakeBothInteger:
.b17d	da		phx				phx 								; save X
.b17e	e8		inx				inx
.b17f	e8		inx				inx
.b180	e8		inx				inx
.b181	e8		inx				inx
.b182	e8		inx				inx
.b183	e8		inx				inx
.b184	20 88 b1	jsr $b188			jsr 	BinaryMakeInteger 			; convert to integer.
.b187	fa		plx				plx 								; restore X and fall through.
.b188					BinaryMakeInteger:
.b188	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b18b	29 0f		and #$0f			and 	#15 						; check type zero
.b18d	f0 04		beq $b193			beq 	_BMIConvert 				; if float convert to integer.
.b18f	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.b190	90 04		bcc $b196			bcc 	_BMIError
.b192	60		rts				rts
.b193					_BMIConvert:
.b193	4c d5 bf	jmp $bfd5			jmp 	FPUToInteger 				; convert to integer
.b196					_BMIError:
.b196	4c 25 ab	jmp $ab25			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.b199					Binary_Equal:
.b199	20 e5 b1	jsr $b1e5			jsr 	CompareValues
.b19c	09 00		ora #$00			ora 	#0
.b19e	f0 04		beq $b1a4			beq 	CCTrue
.b1a0	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.b1a2	80 02		bra $b1a6			bra 	CCWrite
.b1a4	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.b1a6	9d 08 03	sta $0308,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.b1a9	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b1ac	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b1af	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b1b2	a9 01		lda #$01			lda 	#1
.b1b4	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; set type to integer whatever.
.b1b7	60		rts				rts
.b1b8					Binary_NotEqual:
.b1b8	20 e5 b1	jsr $b1e5			jsr 	CompareValues
.b1bb	09 00		ora #$00			ora 	#0
.b1bd	f0 e1		beq $b1a0			beq 	CCFalse
.b1bf	80 e3		bra $b1a4			bra 	CCTrue
.b1c1					Binary_Less:
.b1c1	20 e5 b1	jsr $b1e5			jsr 	CompareValues
.b1c4	09 00		ora #$00			ora 	#0
.b1c6	30 dc		bmi $b1a4			bmi 	CCTrue
.b1c8	80 d6		bra $b1a0			bra 	CCFalse
.b1ca					Binary_LessEqual:
.b1ca	20 e5 b1	jsr $b1e5			jsr 	CompareValues
.b1cd	c9 01		cmp #$01			cmp 	#1
.b1cf	d0 d3		bne $b1a4			bne 	CCTrue
.b1d1	80 cd		bra $b1a0			bra 	CCFalse
.b1d3					Binary_GreaterEqual:
.b1d3	20 e5 b1	jsr $b1e5			jsr 	CompareValues
.b1d6	09 00		ora #$00			ora 	#0
.b1d8	10 ca		bpl $b1a4			bpl 	CCTrue
.b1da	80 c4		bra $b1a0			bra 	CCFalse
.b1dc					Binary_Greater:
.b1dc	20 e5 b1	jsr $b1e5			jsr 	CompareValues
.b1df	c9 01		cmp #$01			cmp 	#1
.b1e1	f0 c1		beq $b1a4			beq 	CCTrue
.b1e3	80 bb		bra $b1a0			bra 	CCFalse
.b1e5					CompareValues:
.b1e5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and the types together
.b1e8	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1eb	c9 02		cmp #$02			cmp 	#2
.b1ed	f0 13		beq $b202			beq 	_CVString
.b1ef	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b1f2	3d 13 03	and $0313,x			and 	XS2_Type,x
.b1f5	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b1f6	90 03		bcc $b1fb			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b1f8	4c 48 b2	jmp $b248			jmp 	CompareInteger32 							; so execute code at \1
.b1fb					_BCFloat:
.b1fb	20 16 b3	jsr $b316			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b1fe	4c e4 be	jmp $bee4			jmp 	FPCompare 							; and execute code at \2
.b201	60		rts				rts
.b202					_CVString:
.b202	da		phx				phx 								; save XY
.b203	5a		phy				phy
.b204	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b207	85 1a		sta $1a				sta		zLTemp1+0
.b209	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b20c	85 1b		sta $1b				sta 	zLTemp1+1
.b20e	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b211	85 1c		sta $1c				sta 	zLTemp1+2
.b213	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b216	85 1d		sta $1d				sta 	zLTemp1+3
.b218	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.b21a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b21c	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b21e	90 02		bcc $b222			bcc 	_CVCommon
.b220	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.b222					_CVCommon:
.b222	aa		tax				tax 								; put shorter string length in zero.
.b223	f0 0c		beq $b231			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.b225					_CVCompare:
.b225	c8		iny				iny 								; next character
.b226	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.b228	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b22a	90 13		bcc $b23f			bcc 	_CVReturnLess 				; <
.b22c	d0 15		bne $b243			bne 	_CVReturnGreater 			; >
.b22e	ca		dex				dex 								; until common length matched.
.b22f	d0 f4		bne $b225			bne 	_CVCompare
.b231					_CVMatch:
.b231	a0 00		ldy #$00			ldy 	#0
.b233	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b235	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.b237	90 06		bcc $b23f			bcc 	_CVReturnLess 				; <
.b239	d0 08		bne $b243			bne 	_CVReturnGreater 			; >
.b23b	a9 00		lda #$00			lda 	#0
.b23d	80 06		bra $b245			bra 	_CVExit 					; same common, same length, same string
.b23f					_CVReturnLess:
.b23f	a9 ff		lda #$ff			lda 	#$FF
.b241	80 02		bra $b245			bra 	_CVExit
.b243					_CVReturnGreater:
.b243	a9 01		lda #$01			lda 	#$01
.b245					_CVExit:
.b245	7a		ply				ply
.b246	fa		plx				plx
.b247	60		rts				rts
.b248					CompareInteger32:
.b248	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.b24b	49 80		eor #$80			eor 	#$80
.b24d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b250	bd 11 03	lda $0311,x			lda 	XS2_Mantissa+3,x
.b253	49 80		eor #$80			eor 	#$80
.b255	9d 11 03	sta $0311,x			sta 	XS2_Mantissa+3,x
.b258	20 f0 b2	jsr $b2f0			jsr 	SubInteger32 				; subtraction
.b25b	90 11		bcc $b26e			bcc 	_CI32Less 					; cc return -1
.b25d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; check if zero
.b260	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b263	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b266	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b269	f0 02		beq $b26d			beq 	_CI32Exit
.b26b	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.b26d					_CI32Exit:
.b26d	60		rts				rts
.b26e					_CI32Less:
.b26e	a9 ff		lda #$ff			lda 	#$FF
.b270	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.b271					BinaryOp_Add:
.b271	bd 0d 03	lda $030d,x			lda 	XS_Type,x  					; and types together
.b274	3d 13 03	and $0313,x			and 	XS2_Type,x
.b277	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.b279	d0 13		bne $b28e			bne 	_BOAString
.b27b	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b27e	3d 13 03	and $0313,x			and 	XS2_Type,x
.b281	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b282	90 03		bcc $b287			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b284	4c ca b2	jmp $b2ca			jmp 	AddInteger32 							; so execute code at \1
.b287					_BCFloat:
.b287	20 16 b3	jsr $b316			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b28a	4c 58 bc	jmp $bc58			jmp 	FPAdd 							; and execute code at \2
.b28d	60		rts				rts
.b28e					_BOAString:
.b28e	4c 31 b3	jmp $b331			jmp 	ConcatenateString 			; concatenate two strings.
.b291					BinaryOp_Subtract:
.b291	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b294	3d 13 03	and $0313,x			and 	XS2_Type,x
.b297	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b298	90 03		bcc $b29d			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b29a	4c f0 b2	jmp $b2f0			jmp 	SubInteger32 							; so execute code at \1
.b29d					_BCFloat:
.b29d	20 16 b3	jsr $b316			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b2a0	4c 4e bc	jmp $bc4e			jmp 	FPSubtract 							; and execute code at \2
.b2a3	60		rts				rts
.b2a4					BinaryOp_Multiply:
.b2a4	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b2a7	3d 13 03	and $0313,x			and 	XS2_Type,x
.b2aa	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b2ab	90 03		bcc $b2b0			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b2ad	4c de b9	jmp $b9de			jmp 	MulInteger32 							; so execute code at \1
.b2b0					_BCFloat:
.b2b0	20 16 b3	jsr $b316			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b2b3	4c c4 bd	jmp $bdc4			jmp 	FPMultiply 							; and execute code at \2
.b2b6	60		rts				rts
.b2b7					BinaryOp_Divide:
.b2b7	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; and 2 type bytes together.
.b2ba	3d 13 03	and $0313,x			and 	XS2_Type,x
.b2bd	4a		lsr a				lsr 	a 							; shift bit 0 into C
.b2be	90 03		bcc $b2c3			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.b2c0	4c 35 ba	jmp $ba35			jmp 	DivInteger32 							; so execute code at \1
.b2c3					_BCFloat:
.b2c3	20 16 b3	jsr $b316			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.b2c6	4c 3c bd	jmp $bd3c			jmp 	FPDivide 							; and execute code at \2
.b2c9	60		rts				rts
.b2ca					AddInteger32:
.b2ca	18		clc				clc
.b2cb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b2ce	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.b2d1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2d4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2d7	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.b2da	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b2dd	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b2e0	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.b2e3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b2e6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b2e9	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.b2ec	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b2ef	60		rts				rts
.b2f0					SubInteger32:
.b2f0	38		sec				sec
.b2f1	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b2f4	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.b2f7	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b2fa	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b2fd	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.b300	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b303	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b306	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.b309	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b30c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b30f	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.b312	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b315	60		rts				rts
.b316					BinaryMakeBothFloat:
.b316	da		phx				phx 								; save X
.b317	e8		inx				inx
.b318	e8		inx				inx
.b319	e8		inx				inx
.b31a	e8		inx				inx
.b31b	e8		inx				inx
.b31c	e8		inx				inx
.b31d	20 21 b3	jsr $b321			jsr 	BinaryMakeFloat 			; convert to float.
.b320	fa		plx				plx 								; restore X and fall through.
.b321					BinaryMakeFloat:
.b321	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type byte.
.b324	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.b325	b0 04		bcs $b32b			bcs 	_BMFConvert
.b327	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.b328	b0 04		bcs $b32e			bcs 	_BMFError
.b32a	60		rts				rts
.b32b					_BMFConvert:
.b32b	4c 76 bf	jmp $bf76			jmp 	FPUToFloat 					; convert to float
.b32e					_BMFError:
.b32e	4c 25 ab	jmp $ab25			jmp 	TypeError
.b331					ConcatenateString:
.b331	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.b334	85 1a		sta $1a				sta		zLTemp1+0
.b336	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b339	85 1b		sta $1b				sta 	zLTemp1+1
.b33b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x
.b33e	85 1c		sta $1c				sta 	zLTemp1+2
.b340	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b343	85 1d		sta $1d				sta 	zLTemp1+3
.b345	5a		phy				phy
.b346	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.b348	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.b34a	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.b34c	7a		ply				ply
.b34d	b0 37		bcs $b386			bcs 	_CSError					; check in range.
.b34f	c9 fe		cmp #$fe			cmp 	#maxString+1
.b351	b0 33		bcs $b386			bcs 	_CSError
.b353	20 7a b7	jsr $b77a			jsr 	AllocateTempString 			; store the result
.b356	20 71 b3	jsr $b371			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b359	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.b35c	85 1a		sta $1a				sta 	zLTemp1
.b35e	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x
.b361	85 1b		sta $1b				sta 	zLTemp1+1
.b363	20 71 b3	jsr $b371			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.b366	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.b368	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b36b	a5 21		lda $21				lda 	zTempStr+1
.b36d	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b370	60		rts				rts
.b371					_CSCopyString:
.b371	da		phx				phx
.b372	5a		phy				phy
.b373	a0 00		ldy #$00			ldy 	#0 							; get length
.b375	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b377	f0 0a		beq $b383			beq 	_CSCSExit 					; if zero, exit
.b379	aa		tax				tax 								; put in X
.b37a					_CSCSLoop:
.b37a	c8		iny				iny 								; get next char
.b37b	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.b37d	20 a5 b7	jsr $b7a5			jsr		WriteTempString 			; copy out
.b380	ca		dex				dex 								; do whole string
.b381	d0 f7		bne $b37a			bne 	_CSCSLoop
.b383					_CSCSExit:
.b383	7a		ply				ply
.b384	fa		plx				plx
.b385	60		rts				rts
.b386					_CSError:
.b386	20 44 ab	jsr $ab44			jsr ERR_Handler
>b389	53 74 72 69 6e 67 20 74			.text "String too long",0
>b391	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.b399					Unary_Sgn:
.b399	20 d6 b0	jsr $b0d6			jsr 	EvaluateNumberX 			; get value
.b39c	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; check right bracket.
.b39f	20 c3 b3	jsr $b3c3			jsr 	GetSignCurrent 				; get sign.
.b3a2	09 00		ora #$00			ora 	#0
.b3a4	10 09		bpl $b3af			bpl		UnarySetAInteger			; if 0,1 return that.
.b3a6	80 00		bra $b3a8			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.b3a8					UnarySetAMinus1:
.b3a8	a9 ff		lda #$ff			lda 	#$FF
.b3aa	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b3ad	80 05		bra $b3b4			bra 	UnarySetAFill
.b3af					UnarySetAInteger:
.b3af	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b3b2	a9 00		lda #$00			lda 	#0
.b3b4					UnarySetAFill:
.b3b4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b3b7	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b3ba	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b3bd	a9 01		lda #$01			lda 	#1
.b3bf	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b3c2	60		rts				rts
.b3c3					GetSignCurrent:
.b3c3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; identify type.
.b3c6	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.b3c7	90 19		bcc $b3e2			bcc 	_GSCFloat
.b3c9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b3cc	30 11		bmi $b3df			bmi 	_GSCMinus1
.b3ce	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b3d1	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b3d4	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b3d7	d0 03		bne $b3dc			bne 	_GSCPlus1
.b3d9					_GSCZero:
.b3d9	a9 00		lda #$00			lda 	#0
.b3db	60		rts				rts
.b3dc					_GSCPlus1:
.b3dc	a9 01		lda #$01			lda 	#$01
.b3de	60		rts				rts
.b3df					_GSCMinus1:
.b3df	a9 ff		lda #$ff			lda 	#$FF
.b3e1	60		rts				rts
.b3e2					_GSCFloat:
.b3e2	3c 0d 03	bit $030d,x			bit 	XS_Type,x
.b3e5	70 f2		bvs $b3d9			bvs 	_GSCZero
.b3e7	30 f6		bmi $b3df			bmi 	_GSCMinus1
.b3e9	80 f1		bra $b3dc			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.b3eb					Unary_Abs:
.b3eb	20 d6 b0	jsr $b0d6			jsr 	EvaluateNumberX 			; get value
.b3ee	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; check right bracket.
.b3f1	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b3f4	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.b3f6	f0 08		beq $b400			beq 	_UAMinusFloat
.b3f8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; check MSB
.b3fb	10 0b		bpl $b408			bpl 	_UAExit
.b3fd	4c cb ba	jmp $bacb			jmp 	IntegerNegateAlways 		; negation
.b400					_UAMinusFloat:
.b400	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; clear the sign bit.
.b403	29 7f		and #$7f			and		#$7F
.b405	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b408					_UAExit:
.b408	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.b409					Unary_Peek:
.b409	a9 01		lda #$01			lda 	#1
.b40b	80 06		bra $b413			bra 	UPMain
.b40d					Unary_Deek:
.b40d	a9 02		lda #$02			lda 	#2
.b40f	80 02		bra $b413			bra 	UPMain
.b411					Unary_Leek:
.b411	a9 04		lda #$04			lda 	#4
.b413					UPMain:
.b413	48		pha				pha 								; set bytes to copy.
.b414	20 e5 b0	jsr $b0e5			jsr 	EvaluateIntegerX 			; numeric parameter
.b417	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b41a	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.b41d	85 1a		sta $1a				sta 	zLTemp1
.b41f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b422	85 1b		sta $1b				sta 	zLTemp1+1
.b424	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b427	85 1c		sta $1c				sta 	zLTemp1+2
.b429	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b42c	85 1d		sta $1d				sta 	zLTemp1+3
.b42e	a9 00		lda #$00			lda 	#0 							; clear target area
.b430	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b433	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b436	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b439	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b43c	68		pla				pla 								; restore bytes to copy
.b43d	da		phx				phx 								; save XY
.b43e	5a		phy				phy
.b43f	20 3b b7	jsr $b73b			jsr 	MemRead 					; read the bytes in
.b442	7a		ply				ply 								; restore and exit
.b443	fa		plx				plx
.b444	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.b445					Unary_Mod:
.b445	20 71 b4	jsr $b471			jsr 	_UMParameter 				; first parameter
.b448	20 71 b7	jsr $b771			jsr 	CheckNextComma
.b44b	da		phx				phx 								; second parameter
.b44c	e8		inx				inx
.b44d	e8		inx				inx
.b44e	e8		inx				inx
.b44f	e8		inx				inx
.b450	e8		inx				inx
.b451	e8		inx				inx
.b452	20 71 b4	jsr $b471			jsr 	_UMParameter
.b455	fa		plx				plx
.b456	20 68 b7	jsr $b768			jsr 	CheckNextRParen
.b459	20 35 ba	jsr $ba35			jsr 	DivInteger32 				; divide
.b45c	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.b45e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b461	a5 1b		lda $1b				lda 	zLTemp1+1
.b463	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b466	a5 1c		lda $1c				lda 	zLTemp1+2
.b468	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b46b	a5 1d		lda $1d				lda 	zLTemp1+3
.b46d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b470	60		rts				rts
.b471					_UMParameter:
.b471	20 e5 b0	jsr $b0e5			jsr 	EvaluateIntegerX 			; get value
.b474	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; absolute value
.b477	10 03		bpl $b47c			bpl 	_UMNotSigned
.b479	20 cb ba	jsr $bacb			jsr 	IntegerNegateAlways
.b47c					_UMNotSigned:
.b47c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.b47d					Unary_Usr:
.b47d	20 d6 b0	jsr $b0d6			jsr 	EvaluateNumberX 			; numeric parameter
.b480	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b483	da		phx				phx 								; save XY
.b484	5a		phy				phy
.b485	ea		nop				nop
.b486	20 00 03	jsr $0300			jsr 	UserVector 					; call the USR function.
.b489	7a		ply				ply 								; and exit
.b48a	fa		plx				plx
.b48b	60		rts				rts
.b48c					USRDefault:
.b48c	20 44 ab	jsr $ab44			jsr ERR_Handler
>b48f	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>b497	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.b49e					Unary_Val:
.b49e	20 ee b0	jsr $b0ee			jsr 	EvaluateStringX 			; get string
.b4a1	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; check right bracket.
.b4a4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.b4a7	85 1e		sta $1e				sta 	zGenPtr
.b4a9	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b4ac	85 1f		sta $1f				sta 	zGenPtr+1
.b4ae	5a		phy				phy
.b4af	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.b4b1	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.b4b3	f0 57		beq $b50c			beq 	_UVBadNumber
.b4b5	48		pha				pha 								; save length.
.b4b6	1a		inc a				inc 	a 							; one for the length, one for the terminator
.b4b7	1a		inc a				inc 	a
.b4b8	20 7a b7	jsr $b77a			jsr 	AllocateTempString
.b4bb	c8		iny				iny 								; move to the next.
.b4bc	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.b4be	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.b4c0	8d 90 04	sta $0490			sta 	ValSign
.b4c3	d0 04		bne $b4c9			bne 	_UVNotMinus
.b4c5	c8		iny				iny 								; skip over it.
.b4c6	68		pla				pla 								; decrement character count.
.b4c7	3a		dec a				dec 	a
.b4c8	48		pha				pha
.b4c9					_UVNotMinus:
.b4c9	68		pla				pla 								; this is the count.
.b4ca	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.b4cb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b4cd	c8		iny				iny
.b4ce	20 a5 b7	jsr $b7a5			jsr 	WriteTempString
.b4d1	68		pla				pla
.b4d2	3a		dec a				dec 	a
.b4d3	d0 f5		bne $b4ca			bne 	_UVCopy
.b4d5	20 a5 b7	jsr $b7a5			jsr 	WriteTempString 			; make it ASCIIZ
.b4d8	18		clc				clc
.b4d9	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.b4db	69 01		adc #$01			adc 	#1
.b4dd	85 1e		sta $1e				sta 	zGenPtr
.b4df	a5 21		lda $21				lda 	zTempStr+1
.b4e1	69 00		adc #$00			adc 	#0
.b4e3	85 1f		sta $1f				sta 	zGenPtr+1
.b4e5	18		clc				clc
.b4e6	20 a3 bb	jsr $bba3			jsr 	IntFromString 				; first bit.
.b4e9	b0 21		bcs $b50c			bcs 	_UVBadNumber
.b4eb	20 c7 c1	jsr $c1c7			jsr 	FPFromString				; try for a float part.
.b4ee	ad 90 04	lda $0490			lda 	ValSign 					; was it negative
.b4f1	d0 13		bne $b506			bne 	_UVNotNegative
.b4f3	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check if integer
.b4f6	4a		lsr a				lsr 	a
.b4f7	b0 0a		bcs $b503			bcs 	_UVInteger
.b4f9	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; set sign bit
.b4fc	09 80		ora #$80			ora 	#$80
.b4fe	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b501	80 03		bra $b506			bra 	_UVNotNegative
.b503					_UVInteger:
.b503	20 cb ba	jsr $bacb			jsr 	IntegerNegateAlways 		; sign it.
.b506					_UVNotNegative:
.b506	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.b508	d0 02		bne $b50c			bne 	_UVBadNumber
.b50a	7a		ply				ply
.b50b	60		rts				rts
.b50c					_UVBadNumber:
.b50c	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.b50f					Unary_Str:
.b50f	20 d6 b0	jsr $b0d6			jsr 	EvaluateNumberX 			; numeric parameter
.b512	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b515	a9 00		lda #$00			lda 	#0 							; reset buffer index
.b517	8d 04 04	sta $0404			sta 	NumBufX
.b51a	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get type
.b51d	4a		lsr a				lsr 	a
.b51e	b0 05		bcs $b525			bcs 	_USInt 						; if msb set do as integer
.b520	20 00 c1	jsr $c100			jsr 	FPToString 					; call fp to str otherwise
.b523	80 03		bra $b528			bra 	_USDuplicate
.b525	20 f0 ba	jsr $baf0	_USInt:	jsr 	IntToString
.b528					_USDuplicate:
.b528	ad 04 04	lda $0404			lda 	NumBufX 					; chars in buffer
.b52b	1a		inc a				inc 	a 							; one more for length
.b52c	20 7a b7	jsr $b77a			jsr 	AllocateTempString 			; allocate space for it.
.b52f	5a		phy				phy 								; save Y
.b530	a0 00		ldy #$00			ldy 	#0 							; start copying
.b532	b9 05 04	lda $0405,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.b535	20 a5 b7	jsr $b7a5			jsr 	WriteTempString
.b538	c8		iny				iny
.b539	cc 04 04	cpy $0404			cpy 	NumBufX 					; done the lot
.b53c	d0 f4		bne $b532			bne 	_USCopy
.b53e	7a		ply				ply 								; restore Y
.b53f	4c 2b b7	jmp $b72b			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.b542					Unary_Asc:
.b542	20 ee b0	jsr $b0ee			jsr 	EvaluateStringX 			; string parameter
.b545	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b548	5a		phy				phy 								; get the string length
.b549	a0 00		ldy #$00			ldy 	#0
.b54b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b54d	f0 07		beq $b556			beq 	_UAIllegal 					; must be at least one character
.b54f	c8		iny				iny
.b550	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.b552	7a		ply				ply
.b553	4c af b3	jmp $b3af			jmp 	UnarySetAInteger
.b556					_UAIllegal:
.b556	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.b559					Unary_Len:
.b559	20 ee b0	jsr $b0ee			jsr 	EvaluateStringX 			; string parameter
.b55c	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b55f	5a		phy				phy 								; get the string length
.b560	a0 00		ldy #$00			ldy 	#0
.b562	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b564	7a		ply				ply
.b565	4c af b3	jmp $b3af			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.b568					Unary_Mid:
.b568	20 ee b0	jsr $b0ee			jsr 	EvaluateStringX 				; get string.
.b56b	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b56e	48		pha				pha
.b56f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b572	48		pha				pha
.b573	20 71 b7	jsr $b771			jsr 	CheckNextComma 					; skip comma
.b576	20 03 b6	jsr $b603			jsr 	SLIByteParameter 				; get a byte parameter (start)
.b579	48		pha				pha 									; and push it.
.b57a	20 71 b7	jsr $b771			jsr 	CheckNextComma 					; skip comma
.b57d	20 03 b6	jsr $b603			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.b580	48		pha				pha 									; and push it.
.b581	80 45		bra $b5c8			bra 	SLIProcess
.b583					Unary_Left:
.b583	20 ee b0	jsr $b0ee			jsr 	EvaluateStringX 				; get string.
.b586	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b589	48		pha				pha
.b58a	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b58d	48		pha				pha
.b58e	a9 01		lda #$01			lda 	#1 								; push start position (1)
.b590	48		pha				pha
.b591	20 71 b7	jsr $b771			jsr 	CheckNextComma 					; skip comma
.b594	20 03 b6	jsr $b603			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.b597	48		pha				pha 									; and push it.
.b598	80 2e		bra $b5c8			bra 	SLIProcess
.b59a					Unary_Right:
.b59a	20 ee b0	jsr $b0ee			jsr 	EvaluateStringX 				; get string.
.b59d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 				; push address on stack
.b5a0	48		pha				pha
.b5a1	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b5a4	48		pha				pha
.b5a5	da		phx				phx 									; get the string length and push on stack.
.b5a6	a2 00		ldx #$00			ldx 	#0
.b5a8	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.b5aa	fa		plx				plx
.b5ab	48		pha				pha
.b5ac	20 71 b7	jsr $b771			jsr 	CheckNextComma 					; skip comma
.b5af	20 03 b6	jsr $b603			jsr 	SLIByteParameter 				; get a byte parameter.
.b5b2	8d 8e 04	sta $048e			sta 	SignCount 						; save in temporary.
.b5b5	68		pla				pla 									; restore string length.
.b5b6	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.b5b7	38		sec				sec
.b5b8	ed 8e 04	sbc $048e			sbc 	SignCount 						; subtract characters needed, gives start position.
.b5bb	f0 02		beq $b5bf			beq 	_URStart 						; if <= 0 start from 1.
.b5bd	10 02		bpl $b5c1			bpl 	_UROkay
.b5bf					_URStart:
.b5bf	a9 01		lda #$01			lda 	#1
.b5c1					_UROkay:
.b5c1	48		pha				pha 									; push start
.b5c2	ad 8e 04	lda $048e			lda 	SignCount 						; push count of characters
.b5c5	48		pha				pha
.b5c6	80 00		bra $b5c8			bra 	SLIProcess
.b5c8					SLIProcess:
.b5c8	20 68 b7	jsr $b768			jsr 	CheckNextRParen 				; closing right bracket.
.b5cb	68		pla				pla
.b5cc	8d 92 04	sta $0492			sta 	SliceCount 						; count in signcount
.b5cf	1a		inc a				inc 	a 								; allocate +1 for it.
.b5d0	20 7a b7	jsr $b77a			jsr 	AllocateTempString
.b5d3	68		pla				pla 									; pop start number off stack.
.b5d4	f0 3f		beq $b615			beq 	SLIError 						; exit if start = 0
.b5d6	8d 91 04	sta $0491			sta 	SliceStart
.b5d9	68		pla				pla  									; pop string address.
.b5da	85 1f		sta $1f				sta 	zGenPtr+1
.b5dc	68		pla				pla
.b5dd	85 1e		sta $1e				sta 	zGenPtr
.b5df	da		phx				phx
.b5e0	5a		phy				phy
.b5e1	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.b5e3	ac 91 04	ldy $0491			ldy 	SliceStart 						; start of the string (+1 for count)
.b5e6					_SLICopy:
.b5e6	ad 92 04	lda $0492			lda 	SliceCount 						; done count characters
.b5e9	f0 12		beq $b5fd			beq 	_SLIExit
.b5eb	ce 92 04	dec $0492			dec 	SliceCount
.b5ee	98		tya				tya 									; index of character
.b5ef	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.b5f1	f0 02		beq $b5f5			beq 	_SLIOk 							; if equal, okay.
.b5f3	b0 08		bcs $b5fd			bcs 	_SLIExit 						; if past end, then exit.
.b5f5	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.b5f7	c8		iny				iny
.b5f8	20 a5 b7	jsr $b7a5			jsr 	WriteTempString
.b5fb	80 e9		bra $b5e6			bra 	_SLICopy 						; go round till copied characters
.b5fd					_SLIExit:
.b5fd	7a		ply				ply 									; restore YX
.b5fe	fa		plx				plx
.b5ff	4c 2b b7	jmp $b72b			jmp 	UnaryReturnTempStr 				; return new temporary string.
.b602	ea		nop				nop
.b603					SLIByteParameter:
.b603	20 e5 b0	jsr $b0e5			jsr 	EvaluateIntegerX 				; get integer
.b606	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.b609	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b60c	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b60f	d0 04		bne $b615			bne 	SLIError
.b611	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b614	60		rts				rts
.b615					SLIError:
.b615	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.b618					Unary_Hex:
.b618	20 e5 b0	jsr $b0e5			jsr 	EvaluateIntegerX 			; numeric parameter
.b61b	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b61e	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.b620	20 7a b7	jsr $b77a			jsr 	AllocateTempString			; allocate string space
.b623	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.b626	20 4d b6	jsr $b64d			jsr 	_UHConvert
.b629	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b62c	20 4d b6	jsr $b64d			jsr 	_UHConvert
.b62f	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b632	20 4d b6	jsr $b64d			jsr 	_UHConvert
.b635	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b638	20 4d b6	jsr $b64d			jsr 	_UHConvert
.b63b	5a		phy				phy 								; get length of new string
.b63c	a0 00		ldy #$00			ldy 	#0
.b63e	b1 20		lda ($20),y			lda 	(zTempStr),y
.b640	7a		ply				ply
.b641	c9 00		cmp #$00			cmp 	#0
.b643	d0 05		bne $b64a			bne 	_UHExit 					; if it was non zero okay
.b645	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.b647	20 a5 b7	jsr $b7a5			jsr 	WriteTempString
.b64a					_UHExit:
.b64a	4c 2b b7	jmp $b72b			jmp 	UnaryReturnTempStr 			; return new temporary string.
.b64d					_UHConvert:
.b64d	48		pha				pha
.b64e	4a		lsr a				lsr 	a 							; do MSB
.b64f	4a		lsr a				lsr 	a
.b650	4a		lsr a				lsr 	a
.b651	4a		lsr a				lsr 	a
.b652	20 56 b6	jsr $b656			jsr 	_UHNibble
.b655	68		pla				pla 								; do LSB
.b656					_UHNibble:
.b656	29 0f		and #$0f			and 	#15 						; get nibble
.b658	d0 0c		bne $b666			bne 	_UHNonZero
.b65a	5a		phy				phy									; get the length
.b65b	a0 00		ldy #$00			ldy 	#0
.b65d	b1 20		lda ($20),y			lda 	(zTempStr),y
.b65f	7a		ply				ply
.b660	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.b662	f0 0d		beq $b671			beq 	_UHExit2
.b664	a9 00		lda #$00			lda 	#0
.b666					_UHNonZero:
.b666	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.b668	90 02		bcc $b66c			bcc 	_UHDigit
.b66a	69 06		adc #$06			adc 	#7-1
.b66c					_UHDigit:
.b66c	69 30		adc #$30			adc 	#48
.b66e	20 a5 b7	jsr $b7a5			jsr 	WriteTempString				; output.
.b671					_UHExit2:
.b671	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.b672					Unary_Dec:
.b672	20 ee b0	jsr $b0ee			jsr 	EvaluateStringX 			; string parameter
.b675	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b678	5a		phy				phy
.b679	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.b67b	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.b67d	f0 4c		beq $b6cb			beq 	_UDFail 					; must fail if zero.
.b67f	8d 8e 04	sta $048e			sta 	SignCount 					; use SignCount as a counter
.b682	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.b684	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b687	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b68a	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b68d	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b690	a9 01		lda #$01			lda 	#1
.b692	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b695					_UDConvertLoop:
.b695	5a		phy				phy 								; shift mantissa left 4
.b696	a0 04		ldy #$04			ldy 	#4
.b698					_UDShift:
.b698	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.b69b	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.b69e	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.b6a1	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.b6a4	88		dey				dey
.b6a5	d0 f1		bne $b698			bne 	_UDShift
.b6a7	7a		ply				ply
.b6a8	c8		iny				iny 								; next character
.b6a9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.b6ab	20 ce b6	jsr $b6ce			jsr 	ConvertUpper 				; convert to U/C
.b6ae	c9 30		cmp #$30			cmp 	#"0"
.b6b0	90 19		bcc $b6cb			bcc 	_UDFail
.b6b2	c9 3a		cmp #$3a			cmp 	#"9"+1
.b6b4	90 06		bcc $b6bc			bcc 	_UDOkay
.b6b6	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.b6b8	c9 10		cmp #$10			cmp 	#16
.b6ba	b0 0f		bcs $b6cb			bcs 	_UDFail
.b6bc					_UDOkay:
.b6bc	29 0f		and #$0f			and 	#15 						; nibble only
.b6be	1d 08 03	ora $0308,x			ora 	XS_Mantissa+0,x
.b6c1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b6c4	ce 8e 04	dec $048e			dec 	SignCount 					; do it for each character
.b6c7	d0 cc		bne $b695			bne 	_UDConvertLoop
.b6c9	7a		ply				ply
.b6ca	60		rts				rts
.b6cb					_UDFail:
.b6cb	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b6ce					ConvertUpper:
.b6ce	c9 61		cmp #$61			cmp 	#"a"
.b6d0	90 07		bcc $b6d9			bcc 	_CUExit
.b6d2	c9 7b		cmp #$7b			cmp 	#"z"+1
.b6d4	b0 03		bcs $b6d9			bcs 	_CUExit
.b6d6	38		sec				sec
.b6d7	e9 20		sbc #$20			sbc 	#32
.b6d9	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.b6da					Unary_Chr:
.b6da	20 e5 b0	jsr $b0e5			jsr 	EvaluateIntegerX			; numeric parameter
.b6dd	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b6e0	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b6e3	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b6e6	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b6e9	d0 0e		bne $b6f9			bne 	_UCChar
.b6eb	a9 01		lda #$01			lda 	#1 							; one character string
.b6ed	20 7a b7	jsr $b77a			jsr 	AllocateTempString
.b6f0	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.b6f3	20 a5 b7	jsr $b7a5			jsr 	WriteTempString
.b6f6	4c 2b b7	jmp $b72b			jmp 	UnaryReturnTempStr
.b6f9					_UCChar:
.b6f9	4c 33 ab	jmp $ab33			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.b6fc					Unary_Spc:
.b6fc	20 e5 b0	jsr $b0e5			jsr 	EvaluateIntegerX 			; numeric parameter
.b6ff	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; right bracket.
.b702	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.b705	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.b708	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.b70b	d0 1b		bne $b728			bne 	_USSize
.b70d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b710	c9 fe		cmp #$fe			cmp 	#maxString+1
.b712	b0 14		bcs $b728			bcs 	_USSize
.b714	48		pha				pha 								; save length
.b715	1a		inc a				inc 	a 							; allocate one more.
.b716	20 7a b7	jsr $b77a			jsr 	AllocateTempString
.b719	68		pla				pla 								; get length
.b71a	f0 0f		beq $b72b			beq 	UnaryReturnTempStr 			; return the current temp string
.b71c					_USLoop:
.b71c	48		pha				pha
.b71d	a9 20		lda #$20			lda 	#" "
.b71f	20 a5 b7	jsr $b7a5			jsr 	WriteTempString
.b722	68		pla				pla
.b723	3a		dec a				dec 	a
.b724	d0 f6		bne $b71c			bne 	_USLoop
.b726	80 03		bra $b72b			bra 	UnaryReturnTempStr
.b728					_USSize:
.b728	4c 33 ab	jmp $ab33			jmp 	BadParamError
.b72b					UnaryReturnTempStr:
.b72b	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.b72d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.b730	a5 21		lda $21				lda 	zTempStr+1
.b732	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b735	a9 02		lda #$02			lda 	#2 							; set type to string
.b737	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b73a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/4510.asm

.b73b	db		phz		MemRead:phz
.b73c	8d 8e 04	sta $048e			sta 	SignCount 					; save count
.b73f	a3 00		ldz #$00			ldz 	#0 							; start from here
.b741	ea		nop		_MLoop1:nop
.b742	b2 1a		lda ($1a),z			lda 	(zlTemp1),z 				; read the long address
.b744	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; copy into mantissa
.b747	1b		inz				inz 								; next to copy
.b748	e8		inx				inx
.b749	dc 8e 04	cpz $048e			cpz 	SignCount 					; do required # of bytes.
.b74c	d0 f3		bne $b741			bne 	_MLoop1
.b74e	fb		plz				plz
.b74f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.b750					CheckNextToken:
.b750	ea		nop				nop
.b751	d2 16		cmp ($16),z			cmp 	(zCodePtr),z
.b753	d0 02		bne $b757			bne 	CTFail 						; no, then fail
.b755	1b		inz				inz
.b756	60		rts				rts
.b757					CTFail:
.b757	20 44 ab	jsr $ab44			jsr ERR_Handler
>b75a	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>b762	74 6f 6b 65 6e 00
.b768					CheckNextRParen:
.b768	ea		nop				nop
.b769	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b76b	c9 bc		cmp #$bc			cmp 	#token_rparen
.b76d	d0 e8		bne $b757			bne 	CTFail
.b76f	1b		inz				inz
.b770	60		rts				rts
.b771					CheckNextComma:
.b771	ea		nop				nop
.b772	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b774	c9 bd		cmp #$bd			cmp 	#token_comma
.b776	d0 df		bne $b757			bne 	CTFail
.b778	1b		inz				inz
.b779	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.b77a					AllocateTempString:
.b77a	48		pha				pha 								; save required count.
.b77b	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.b77d	d0 0b		bne $b78a			bne 	_ATSInitialised
.b77f	ad 00 04	lda $0400			lda 	StringPtr 					; set temporary string ptr 1 page below available
.b782	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.b784	ad 01 04	lda $0401			lda 	StringPtr+1
.b787	3a		dec a				dec 	a
.b788	85 21		sta $21				sta 	zTempStr+1
.b78a					_ATSInitialised:
.b78a	68		pla				pla 								; get required count back.
.b78b	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.b78d	1a		inc a				inc 	a
.b78e	18		clc				clc
.b78f	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.b791	85 20		sta $20				sta 	zTempStr
.b793	a9 ff		lda #$ff			lda 	#$FF
.b795	65 21		adc $21				adc 	zTempStr+1
.b797	85 21		sta $21				sta 	zTempStr+1
.b799	a9 00		lda #$00			lda 	#0 							; clear temp string.
.b79b	5a		phy				phy
.b79c	a8		tay				tay
.b79d	91 20		sta ($20),y			sta 	(zTempStr),y
.b79f	7a		ply				ply
.b7a0	1a		inc a				inc 	a 							; reset the write index.
.b7a1	8d 8f 04	sta $048f			sta 	TempStringWriteIndex
.b7a4	60		rts				rts
.b7a5					WriteTempString:
.b7a5	5a		phy				phy 								; save Y
.b7a6	ac 8f 04	ldy $048f			ldy 	TempStringWriteIndex	 	; write position.
.b7a9	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.b7ab	ee 8f 04	inc $048f			inc 	TempStringWriteIndex 		; increment the write position.
.b7ae	98		tya				tya 								; unchanged Y is now length
.b7af	a0 00		ldy #$00			ldy 	#0
.b7b1	91 20		sta ($20),y			sta 	(zTempStr),y
.b7b3	7a		ply				ply 								; restore Y and exit
.b7b4	60		rts				rts
.b7b5					CreateTempStringCopy:
.b7b5	da		phx				phx 								; save X
.b7b6	ea		nop				nop
.b7b7	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7b9	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.b7ba	20 7a b7	jsr $b77a			jsr 	AllocateTempString 			; allocate memory for temporary string.
.b7bd	ea		nop				nop
.b7be	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7c0	1b		inz				inz
.b7c1	3a		dec a				dec 	a 							; make the actual length in charactes
.b7c2	3a		dec a				dec 	a
.b7c3	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.b7c5	81 20		sta ($20,x)			sta 	(zTempStr,x)
.b7c7	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.b7c9	09 00		ora #$00			ora 	#0 							; if zero already, exit
.b7cb	f0 0f		beq $b7dc			beq 	_CTSCExit
.b7cd					_CTSCLoop:
.b7cd	ea		nop				nop
.b7ce	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b7d0	1b		inz				inz
.b7d1	5a		phy				phy 								; save in Y
.b7d2	e8		inx				inx 								; bump index
.b7d3	da		phx				phx 								; index into Y
.b7d4	7a		ply				ply
.b7d5	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.b7d7	7a		ply				ply 								; restore Y
.b7d8	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.b7da	d0 f1		bne $b7cd			bne 	_CTSCLoop
.b7dc					_CTSCExit:
.b7dc	fa		plx				plx 								; restore X
.b7dd	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.b7de					VariableFind:
.b7de	20 19 b8	jsr $b819			jsr 	VariableExtract 		; find out all about it ....
.b7e1	20 1b b9	jsr $b91b			jsr 	VariableLocate 			; does it already exist ?
.b7e4	b0 03		bcs $b7e9			bcs 	_VFExists 				; if so, use that.
.b7e6	20 a7 b8	jsr $b8a7			jsr 	VariableCreate 			; otherwise create it.
.b7e9					_VFExists:
.b7e9	60		rts				rts
.b7ea					VariableClear:
.b7ea	48		pha				pha 							; save registers
.b7eb	da		phx				phx
.b7ec	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.b7ee	8a		txa				txa
.b7ef	9d 25 04	sta $0425,x	_VCLoop:sta 	HashTableBase,x
.b7f2	e8		inx				inx
.b7f3	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.b7f5	d0 f8		bne $b7ef			bne 	_VCLoop
.b7f7	a9 00		lda #$00			lda 	#VariableMemory & $FF	; reset the free variable memory pointer
.b7f9	8d 02 04	sta $0402			sta 	VarMemPtr
.b7fc	a9 40		lda #$40			lda 	#VariableMemory >> 8
.b7fe	8d 03 04	sta $0403			sta 	VarMemPtr+1
.b801	fa		plx				plx 							; restore registers
.b802	68		pla				pla
.b803	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.b804					VariableNameError:
.b804	20 44 ab	jsr $ab44			jsr ERR_Handler
>b807	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>b80f	61 62 6c 65 20 4e 61 6d 65 00
.b819					VariableExtract:
.b819	da		phx				phx 							; save X.
.b81a	a9 b8		lda #$b8			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.b81c	8d 85 04	sta $0485			sta 	Var_Type
.b81f	8d 86 04	sta $0486			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.b822	ea		nop				nop
.b823	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b825	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.b827	f0 db		beq $b804			beq 	VariableNameError
.b829	c9 1b		cmp #$1b			cmp 	#26+1
.b82b	b0 d7		bcs $b804			bcs 	VariableNameError
.b82d	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.b82f					_VECopyBuffer:
.b82f	e8		inx				inx
.b830	e0 1f		cpx #$1f			cpx 	#31 					; too long
.b832	f0 d0		beq $b804			beq 	VariableNameError
.b834	9d 05 04	sta $0405,x			sta 	Var_Buffer,x 			; save character
.b837	18		clc				clc  							; update the hash value for it.
.b838	6d 86 04	adc $0486			adc 	Var_Hash
.b83b	8d 86 04	sta $0486			sta 	Var_Hash
.b83e	1b		inz				inz
.b83f	ea		nop				nop
.b840	b2 16		lda ($16),z			lda 	(zCodePtr),z
.b842	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.b844	f0 0e		beq $b854			beq 	_VECopyEnd
.b846	30 0c		bmi $b854			bmi 	_VECopyEnd
.b848	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.b84a	90 e3		bcc $b82f			bcc 	_VECopyBuffer
.b84c	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.b84e	90 04		bcc $b854			bcc 	_VECopyEnd
.b850	c9 3a		cmp #$3a			cmp 	#"9"+1
.b852	90 db		bcc $b82f			bcc 	_VECopyBuffer
.b854					_VECopyEnd:
.b854	1b		inz				inz
.b855	c9 b5		cmp #$b5			cmp 	#token_Dollar 			; first type token.
.b857	90 04		bcc $b85d			bcc 	_VEDefaultRequired
.b859	c9 bb		cmp #$bb			cmp 	#token_PercentLParen+1	; last type token.
.b85b	90 0b		bcc $b868			bcc 	_VEHaveType
.b85d					_VEDefaultRequired:
.b85d	c9 bb		cmp #$bb			cmp 	#token_LParen 			; if it ends in ( then use the real array
.b85f	f0 04		beq $b865			beq 	_VESetType 				; default set above.
.b861	ce 85 04	dec $0485			dec 	Var_Type 				; this changes that default to the variable default
.b864	3b		dez				dez
.b865					_VESetType:
.b865	ad 85 04	lda $0485			lda 	Var_Type 				; get type ....
.b868					_VEHaveType:
.b868	8d 85 04	sta $0485			sta 	Var_Type 				; save as type.
.b86b	bd 05 04	lda $0405,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.b86e	09 80		ora #$80			ora 	#$80
.b870	9d 05 04	sta $0405,x			sta 	Var_Buffer,x
.b873	e8		inx				inx 							; offset 3 => length 4.
.b874	8e 87 04	stx $0487			stx 	Var_Length 				; save length of variable name.
.b877	ad 85 04	lda $0485			lda 	Var_Type 				; get offset of var type from first type token
.b87a	38		sec				sec
.b87b	e9 b5		sbc #$b5			sbc 	#token_Dollar
.b87d	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.b87e	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.b87f	0a		asl a				asl 	a
.b880	0a		asl a				asl 	a
.b881	8d 88 04	sta $0488			sta 	Var_HashAddress
.b884	ad 86 04	lda $0486			lda 	Var_Hash 				; get the hash
.b887	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.b889	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.b88a	6d 88 04	adc $0488			adc 	Var_HashAddress 		; add table offset.
.b88d	69 25		adc #$25			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.b88f	8d 88 04	sta $0488			sta 	Var_HashAddress
.b892	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.b894	ad 85 04	lda $0485			lda 	Var_Type
.b897	c9 b7		cmp #$b7			cmp 	#token_Hash
.b899	f0 07		beq $b8a2			beq 	_VEHaveSize
.b89b	ca		dex				dex
.b89c	c9 b9		cmp #$b9			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.b89e	f0 02		beq $b8a2			beq 	_VEHaveSize
.b8a0	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.b8a2					_VEHaveSize:
.b8a2	8e 89 04	stx $0489			stx 	Var_DataSize
.b8a5	fa		plx				plx
.b8a6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.b8a7					VariableCreate:
.b8a7	da		phx				phx
.b8a8	5a		phy				phy
.b8a9	ad 02 04	lda $0402			lda 	VarMemPtr 					; get address of next free into zTemp1
.b8ac	85 10		sta $10				sta 	zTemp1
.b8ae	ad 03 04	lda $0403			lda 	VarMemPtr+1
.b8b1	85 11		sta $11				sta 	zTemp1+1
.b8b3	ad 89 04	lda $0489			lda 	Var_DataSize 				; bytes for the data bit
.b8b6	18		clc				clc
.b8b7	6d 87 04	adc $0487			adc 	Var_Length 					; add the length of the name
.b8ba	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.b8bc	6d 02 04	adc $0402			adc 	VarMemPtr 					; add to variable memory pointer
.b8bf	8d 02 04	sta $0402			sta 	VarMemPtr
.b8c2	90 03		bcc $b8c7			bcc 	_VCNoCarry
.b8c4	ee 03 04	inc $0403			inc 	VarMemPtr+1
.b8c7					_VCNoCarry:
.b8c7	ad 88 04	lda $0488			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.b8ca	85 12		sta $12				sta 	zTemp2
.b8cc	a9 04		lda #$04			lda 	#HashTableBase >> 8
.b8ce	85 13		sta $13				sta 	zTemp2+1
.b8d0	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.b8d2	b1 12		lda ($12),y			lda 	(zTemp2),y
.b8d4	91 10		sta ($10),y			sta 	(zTemp1),y
.b8d6	c8		iny				iny
.b8d7	b1 12		lda ($12),y			lda 	(zTemp2),y
.b8d9	91 10		sta ($10),y			sta 	(zTemp1),y
.b8db	c8		iny				iny
.b8dc	ad 86 04	lda $0486			lda 	Var_Hash 					; write the hash out.
.b8df	91 10		sta ($10),y			sta 	(zTemp1),y
.b8e1	c8		iny				iny
.b8e2	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.b8e4					_VCCopyName:
.b8e4	bd 05 04	lda $0405,x			lda 	Var_Buffer,x
.b8e7	91 10		sta ($10),y			sta 	(zTemp1),y
.b8e9	e8		inx				inx
.b8ea	c8		iny				iny
.b8eb	ec 87 04	cpx $0487			cpx 	Var_Length
.b8ee	d0 f4		bne $b8e4			bne 	_VCCopyName
.b8f0	5a		phy				phy 								; save the data offset.
.b8f1	ae 89 04	ldx $0489			ldx 	Var_DataSize 				; and write the data out.
.b8f4	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.b8f6					_VCClearData:
.b8f6	91 10		sta ($10),y			sta 	(zTemp1),y
.b8f8	c8		iny				iny
.b8f9	ca		dex				dex
.b8fa	d0 fa		bne $b8f6			bne 	_VCClearData
.b8fc	68		pla				pla 								; offset to the data
.b8fd	18		clc				clc
.b8fe	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.b900	85 22		sta $22				sta 	zVarDataPtr
.b902	a5 11		lda $11				lda 	zTemp1+1
.b904	69 00		adc #$00			adc 	#0
.b906	85 23		sta $23				sta 	zVarDataPtr+1
.b908	ad 85 04	lda $0485			lda 	Var_Type 					; and set the type.
.b90b	85 24		sta $24				sta 	zVarType
.b90d	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.b90f	a0 00		ldy #$00			ldy 	#0
.b911	91 12		sta ($12),y			sta 	(zTemp2),y
.b913	c8		iny				iny
.b914	a5 11		lda $11				lda 	zTemp1+1
.b916	91 12		sta ($12),y			sta 	(zTemp2),y
.b918	7a		ply				ply
.b919	fa		plx				plx
.b91a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.b91b					VariableLocate:
.b91b	18		clc				clc
.b91c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.b91d					VariableGet:
.b91d	5a		phy				phy
.b91e	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.b920	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.b922	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.b925	c8		iny				iny
.b926	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.b928	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b92b	c8		iny				iny
.b92c	ad 85 04	lda $0485			lda 	Var_Type 					; if it is a string, set up for that.
.b92f	c9 b5		cmp #$b5			cmp 	#token_Dollar
.b931	f0 33		beq $b966			beq 	_VGString
.b933	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.b935	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.b938	c8		iny				iny
.b939	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.b93b	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.b93e	c8		iny				iny
.b93f	a9 01		lda #$01			lda 	#1 							; set type to 1.
.b941	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b944	ad 85 04	lda $0485			lda 	Var_Type
.b947	c9 b9		cmp #$b9			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.b949	f0 2f		beq $b97a			beq 	_VGExit
.b94b	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.b94d	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; which is the code for zero/float.
.b950	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.b952	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.b955	f0 23		beq $b97a			beq 	_VGExit 					; if exponent is zero ... it's zero.
.b957	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.b95a	48		pha				pha
.b95b	29 80		and #$80			and 	#$80
.b95d	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; this is the type byte.
.b960	68		pla				pla
.b961	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.b963	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.b966					_VGString:
.b966	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.b968	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.b96b	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; is the value there $0000
.b96e	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.b971	d0 07		bne $b97a			bne 	_VGExit 					; if not, exit.
.b973	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.b975	a9 25		lda #$25			lda 	#zNullString
.b977	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; make it point to it.
.b97a					_VGExit:
.b97a	7a		ply				ply
.b97b	60		rts				rts
.b97c					VariableSet:
.b97c	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; is the result a string
.b97f	29 02		and #$02			and 	#2 							; if so, it has to be
.b981	d0 53		bne $b9d6			bne 	_VSString
.b983	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.b985	c9 b5		cmp #$b5			cmp 	#token_Dollar
.b987	f0 4a		beq $b9d3			beq 	_VSBadType
.b989	c9 b9		cmp #$b9			cmp 	#token_Percent 				; type convert to float/int
.b98b	f0 05		beq $b992			beq 	_VSMakeInt
.b98d	20 76 bf	jsr $bf76			jsr 	FPUToFloat
.b990	80 03		bra $b995			bra 	_VSCopy
.b992					_VSMakeInt:
.b992	20 d5 bf	jsr $bfd5			jsr 	FPUToInteger
.b995					_VSCopy:
.b995	5a		phy				phy
.b996	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.b998	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.b99b	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.b99d	c8		iny				iny
.b99e	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b9a1	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.b9a3	c8		iny				iny
.b9a4	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b9a7	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.b9a9	c8		iny				iny
.b9aa	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b9ad	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.b9af	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.b9b1	c9 b9		cmp #$b9			cmp 	#token_Percent
.b9b3	f0 1c		beq $b9d1			beq 	_VSExit
.b9b5	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.b9b8	0a		asl a				asl 	a
.b9b9	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.b9bc	08		php				php
.b9bd	0a		asl a				asl 	a
.b9be	28		plp				plp
.b9bf	6a		ror a				ror 	a
.b9c0	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.b9c2	c8		iny				iny
.b9c3	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; copy the exponent in
.b9c6	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.b9c8	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if the result is non zero
.b9cb	50 04		bvc $b9d1			bvc 	_VSExit
.b9cd	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.b9cf	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.b9d1					_VSExit:
.b9d1	7a		ply				ply
.b9d2	60		rts				rts
.b9d3					_VSBadType:
.b9d3	4c 25 ab	jmp $ab25			jmp 	TypeError
.b9d6					_VSString:
.b9d6	a5 24		lda $24				lda 	zVarType 					; type must be $
.b9d8	c9 b5		cmp #$b5			cmp 	#token_Dollar
.b9da	d0 f7		bne $b9d3			bne 	_VSBadType
.b9dc	80 f8		bra $b9d6			bra 	_VSString

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.b9de					MulInteger32:
.b9de	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.b9e1	9d 14 03	sta $0314,x			sta 	XS3_Mantissa,x
.b9e4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.b9e7	9d 15 03	sta $0315,x			sta 	XS3_Mantissa+1,x
.b9ea	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.b9ed	9d 16 03	sta $0316,x			sta 	XS3_Mantissa+2,x
.b9f0	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.b9f3	9d 17 03	sta $0317,x			sta 	XS3_Mantissa+3,x
.b9f6	a9 00		lda #$00			lda 	#0
.b9f8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 				; zero +0
.b9fb	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.b9fe	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.ba01	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.ba04					_BFMMultiply:
.ba04	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.ba07	29 01		and #$01			and 	#1
.ba09	f0 03		beq $ba0e			beq 	_BFMNoAdd
.ba0b	20 ca b2	jsr $b2ca			jsr 	AddInteger32
.ba0e					_BFMNoAdd:
.ba0e	1e 0e 03	asl $030e,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.ba11	3e 0f 03	rol $030f,x			rol 	XS2_Mantissa+1,x
.ba14	3e 10 03	rol $0310,x			rol 	XS2_Mantissa+2,x
.ba17	3e 11 03	rol $0311,x			rol 	XS2_Mantissa+3,x
.ba1a	5e 17 03	lsr $0317,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.ba1d	7e 16 03	ror $0316,x			ror 	XS3_Mantissa+2,x
.ba20	7e 15 03	ror $0315,x			ror 	XS3_Mantissa+1,x
.ba23	7e 14 03	ror $0314,x			ror 	XS3_Mantissa,x
.ba26	bd 14 03	lda $0314,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.ba29	1d 15 03	ora $0315,x			ora 	XS3_Mantissa+1,x
.ba2c	1d 16 03	ora $0316,x			ora 	XS3_Mantissa+2,x
.ba2f	1d 17 03	ora $0317,x			ora 	XS3_Mantissa+3,x
.ba32	d0 d0		bne $ba04			bne 	_BFMMultiply
.ba34	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.ba35					DivInteger32:
.ba35	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; check for /0
.ba38	1d 0f 03	ora $030f,x			ora 	XS2_Mantissa+1,x
.ba3b	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.ba3e	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.ba41	d0 14		bne $ba57			bne 	_BFDOkay
.ba43	20 44 ab	jsr $ab44			jsr ERR_Handler
>ba46	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>ba4e	20 62 79 20 5a 65 72 6f 00
.ba57					_BFDOkay:
.ba57	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.ba59	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.ba5b	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.ba5d	85 1c		sta $1c				sta 	zLTemp1+2
.ba5f	85 1d		sta $1d				sta 	zLTemp1+3
.ba61	8d 8e 04	sta $048e			sta 	SignCount 					; Count of signs.
.ba64	20 c5 ba	jsr $bac5			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ba67	da		phx				phx
.ba68	e8		inx				inx
.ba69	e8		inx				inx
.ba6a	e8		inx				inx
.ba6b	e8		inx				inx
.ba6c	e8		inx				inx
.ba6d	e8		inx				inx
.ba6e	20 c5 ba	jsr $bac5			jsr 	CheckIntegerNegate
.ba71	fa		plx				plx
.ba72	5a		phy				phy 								; Y is the counter
.ba73	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ba75					_BFDLoop:
.ba75	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.ba78	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.ba7b	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.ba7e	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.ba81	26 1a		rol $1a				rol 	zLTemp1
.ba83	26 1b		rol $1b				rol 	zLTemp1+1
.ba85	26 1c		rol $1c				rol 	zLTemp1+2
.ba87	26 1d		rol $1d				rol 	zLTemp1+3
.ba89	38		sec				sec
.ba8a	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ba8c	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.ba8f	48		pha				pha
.ba90	a5 1b		lda $1b				lda 	zLTemp1+1
.ba92	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.ba95	48		pha				pha
.ba96	a5 1c		lda $1c				lda 	zLTemp1+2
.ba98	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.ba9b	48		pha				pha
.ba9c	a5 1d		lda $1d				lda 	zLTemp1+3
.ba9e	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.baa1	90 15		bcc $bab8			bcc 	_BFDNoAdd
.baa3	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.baa5	68		pla				pla
.baa6	85 1c		sta $1c				sta 	zLTemp1+2
.baa8	68		pla				pla
.baa9	85 1b		sta $1b				sta 	zLTemp1+1
.baab	68		pla				pla
.baac	85 1a		sta $1a				sta 	zLTemp1+0
.baae	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.bab1	09 01		ora #$01			ora 	#1
.bab3	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bab6	80 03		bra $babb			bra 	_BFDNext
.bab8					_BFDNoAdd:
.bab8	68		pla				pla 								; Throw away the intermediate calculations
.bab9	68		pla				pla
.baba	68		pla				pla
.babb					_BFDNext:
.babb	88		dey				dey
.babc	d0 b7		bne $ba75			bne 	_BFDLoop
.babe	7a		ply				ply 								; restore Y and exit
.babf	4e 8e 04	lsr $048e			lsr 	SignCount 					; if sign count odd,
.bac2	b0 07		bcs $bacb			bcs		IntegerNegateAlways 			; negate the result
.bac4	60		rts				rts
.bac5					CheckIntegerNegate:
.bac5	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bac8	30 01		bmi $bacb			bmi 	IntegerNegateAlways
.baca	60		rts				rts
.bacb					IntegerNegateAlways:
.bacb	ee 8e 04	inc $048e			inc 	SignCount
.bace	38		sec				sec
.bacf	a9 00		lda #$00			lda 	#0
.bad1	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bad4	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bad7	a9 00		lda #$00			lda 	#0
.bad9	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.badc	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.badf	a9 00		lda #$00			lda 	#0
.bae1	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bae4	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bae7	a9 00		lda #$00			lda 	#0
.bae9	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.baec	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.baef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.baf0					INTToString:
.baf0	48		pha				pha
.baf1	5a		phy				phy
.baf2	bd 0b 03	lda $030b,x			lda 		XS_Mantissa+3,x 		; check -ve
.baf5	10 08		bpl $baff			bpl 		_ITSNotMinus
.baf7	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.baf9	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter
.bafc	20 cb ba	jsr $bacb			jsr 		IntegerNegateAlways 	; negate the number.
.baff					_ITSNotMinus:
.baff	a9 00		lda #$00			lda 		#0
.bb01	8d 8a 04	sta $048a			sta 		NumSuppress 			; clear the suppression flag.
.bb04	8a		txa				txa 								; use Y for the mantissa index.
.bb05	a8		tay				tay
.bb06	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.bb08					_ITSNextSubtractor:
.bb08	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.bb0a	8d 8b 04	sta $048b			sta 		NumConvCount
.bb0d					_ITSSubtract:
.bb0d	38		sec				sec
.bb0e	b9 08 03	lda $0308,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.bb11	fd 6c bb	sbc $bb6c,x			sbc 		_ITSSubtractors+0,x
.bb14	48		pha				pha
.bb15	b9 09 03	lda $0309,y			lda 		XS_Mantissa+1,y
.bb18	fd 6d bb	sbc $bb6d,x			sbc 		_ITSSubtractors+1,x
.bb1b	48		pha				pha
.bb1c	b9 0a 03	lda $030a,y			lda 		XS_Mantissa+2,y
.bb1f	fd 6e bb	sbc $bb6e,x			sbc 		_ITSSubtractors+2,x
.bb22	48		pha				pha
.bb23	b9 0b 03	lda $030b,y			lda 		XS_Mantissa+3,y
.bb26	fd 6f bb	sbc $bb6f,x			sbc 		_ITSSubtractors+3,x
.bb29	90 14		bcc $bb3f			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.bb2b	99 0b 03	sta $030b,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.bb2e	68		pla				pla
.bb2f	99 0a 03	sta $030a,y			sta 		XS_Mantissa+2,y
.bb32	68		pla				pla
.bb33	99 09 03	sta $0309,y			sta 		XS_Mantissa+1,y
.bb36	68		pla				pla
.bb37	99 08 03	sta $0308,y			sta 		XS_Mantissa+0,y
.bb3a	ee 8b 04	inc $048b			inc 		NumConvCount 			; bump count.
.bb3d	80 ce		bra $bb0d			bra 		_ITSSubtract 			; go round again.
.bb3f					_ITSCantSubtract:
.bb3f	68		pla				pla 								; throw away interim answers
.bb40	68		pla				pla
.bb41	68		pla				pla
.bb42	ad 8b 04	lda $048b			lda 		NumConvCount 			; if not zero then no suppression check
.bb45	c9 30		cmp #$30			cmp 		#"0"
.bb47	d0 05		bne $bb4e			bne 		_ITSOutputDigit
.bb49	ad 8a 04	lda $048a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.bb4c	10 09		bpl $bb57			bpl	 		_ITSGoNextSubtractor
.bb4e					_ITSOutputDigit:
.bb4e	ce 8a 04	dec $048a			dec 		NumSuppress 			; suppression check will be non-zero.
.bb51	ad 8b 04	lda $048b			lda 		NumConvCount 			; count of subtractions
.bb54	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter 		; output it.
.bb57					_ITSGoNextSubtractor:
.bb57	e8		inx				inx 								; next dword
.bb58	e8		inx				inx
.bb59	e8		inx				inx
.bb5a	e8		inx				inx
.bb5b	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.bb5d	d0 a9		bne $bb08			bne 		_ITSNextSubtractor 		; do all the subtractors.
.bb5f	98		tya				tya 								; X is back as the mantissa index
.bb60	aa		tax				tax
.bb61	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.bb64	09 30		ora #$30			ora 		#"0"
.bb66	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter
.bb69	7a		ply				ply 								; and exit
.bb6a	68		pla				pla
.bb6b	60		rts				rts
.bb6c					_ITSSubtractors:
>bb6c	00 ca 9a 3b					.dword 		1000000000
>bb70	00 e1 f5 05					.dword 		100000000
>bb74	80 96 98 00					.dword 		10000000
>bb78	40 42 0f 00					.dword 		1000000
>bb7c	a0 86 01 00					.dword 		100000
>bb80	10 27 00 00					.dword 		10000
>bb84	e8 03 00 00					.dword 		1000
>bb88	64 00 00 00					.dword 		100
>bb8c	0a 00 00 00					.dword 		10
.bb90					_ITSSubtractorsEnd:
.bb90					ITSOutputCharacter:
.bb90	48		pha				pha
.bb91	da		phx				phx
.bb92	ae 04 04	ldx $0404			ldx 	NumBufX 					; save digit
.bb95	9d 05 04	sta $0405,x			sta 	Num_Buffer,x
.bb98	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.bb9a	9d 06 04	sta $0406,x			sta 	Num_Buffer+1,x
.bb9d	ee 04 04	inc $0404			inc 	NumBufX						; bump pointer.
.bba0	fa		plx				plx
.bba1	68		pla				pla
.bba2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.bba3					IntFromString:
.bba3	a0 00		ldy #$00			ldy 	#0
.bba5	8c 8c 04	sty $048c			sty 	ExpTemp 					; this is the converted digit count.
.bba8					IntFromStringY:
.bba8	48		pha				pha
.bba9	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.bbab	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bbae	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bbb1	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bbb4	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bbb7	a9 01		lda #$01			lda 	#1
.bbb9	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bbbc					_IFSLoop:
.bbbc	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.bbbe	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.bbc0	90 60		bcc $bc22			bcc 	_IFSExit
.bbc2	c9 3a		cmp #$3a			cmp 	#"9"+1
.bbc4	b0 5c		bcs $bc22			bcs 	_IFSExit
.bbc6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.bbc9	c9 0c		cmp #$0c			cmp 	#12
.bbcb	b0 5f		bcs $bc2c			bcs 	_IFSOverflow
.bbcd	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.bbd0	48		pha				pha
.bbd1	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bbd4	48		pha				pha
.bbd5	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bbd8	48		pha				pha
.bbd9	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.bbdc	48		pha				pha
.bbdd	20 41 bc	jsr $bc41			jsr 	IFSX1ShiftLeft 				; double
.bbe0	20 41 bc	jsr $bc41			jsr 	IFSX1ShiftLeft 				; x 4
.bbe3	18		clc				clc 								; add saved value x 5
.bbe4	68		pla				pla
.bbe5	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.bbe8	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bbeb	68		pla				pla
.bbec	7d 09 03	adc $0309,x			adc 	XS_Mantissa+1,x
.bbef	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bbf2	68		pla				pla
.bbf3	7d 0a 03	adc $030a,x			adc 	XS_Mantissa+2,x
.bbf6	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bbf9	68		pla				pla
.bbfa	7d 0b 03	adc $030b,x			adc 	XS_Mantissa+3,x
.bbfd	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bc00	20 41 bc	jsr $bc41			jsr 	IFSX1ShiftLeft 				; x 10
.bc03	ee 8c 04	inc $048c			inc 	ExpTemp 					; bump count of digits processed.
.bc06	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.bc08	29 0f		and #$0f			and 	#15
.bc0a	c8		iny				iny
.bc0b	7d 08 03	adc $0308,x			adc 	XS_Mantissa+0,x
.bc0e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bc11	90 a9		bcc $bbbc			bcc 	_IFSLoop
.bc13	fe 09 03	inc $0309,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.bc16	d0 a4		bne $bbbc			bne 	_IFSLoop
.bc18	fe 0a 03	inc $030a,x			inc 	XS_Mantissa+2,x
.bc1b	d0 9f		bne $bbbc			bne 	_IFSLoop
.bc1d	fe 0b 03	inc $030b,x			inc 	XS_Mantissa+3,x
.bc20	80 9a		bra $bbbc			bra 	_IFSLoop
.bc22					_IFSExit:
.bc22	98		tya				tya 								; get offset
.bc23					_IFSOkay:
.bc23	38		sec				sec
.bc24	ad 8c 04	lda $048c			lda 	ExpTemp
.bc27	f0 01		beq $bc2a			beq 	_IFSSkipFail
.bc29	18		clc				clc
.bc2a					_IFSSkipFail:
.bc2a	68		pla				pla 								; and exit.
.bc2b	60		rts				rts
.bc2c					_IFSOverflow:
.bc2c	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>bc2f	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>bc37	20 6f 76 65 72 66 6c 6f 77 00
.bc41					IFSX1ShiftLeft:
.bc41	1e 08 03	asl $0308,x			asl 	XS_Mantissa+0,x
.bc44	3e 09 03	rol $0309,x			rol 	XS_Mantissa+1,x
.bc47	3e 0a 03	rol $030a,x			rol 	XS_Mantissa+2,x
.bc4a	3e 0b 03	rol $030b,x			rol 	XS_Mantissa+3,x
.bc4d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.bc4e					FPSubtract:
.bc4e	48		pha				pha
.bc4f	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.bc52	49 80		eor #$80			eor 	#$80
.bc54	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.bc57	68		pla				pla 								; --- and fall through ---
.bc58					FPAdd:
.bc58	48		pha				pha
.bc59	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.bc5c	d0 05		bne $bc63			bne 	_FPA_NegativeLHS
.bc5e	20 80 bc	jsr $bc80			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.bc61	68		pla				pla
.bc62	60		rts				rts
.bc63					_FPA_NegativeLHS:
.bc63	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.bc66	49 80		eor #$80			eor 	#$80
.bc68	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc6b	bd 13 03	lda $0313,x			lda 	XS2_Type,x 					; flip the sign of B and add
.bc6e	49 80		eor #$80			eor 	#$80
.bc70	9d 13 03	sta $0313,x			sta 	XS2_Type,x
.bc73	20 80 bc	jsr $bc80			jsr 	FPAdd_Worker 				; do the add calculation.
.bc76	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip sign of X1 back
.bc79	49 80		eor #$80			eor 	#$80
.bc7b	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bc7e	68		pla				pla
.bc7f	60		rts				rts
.bc80					FPAdd_Worker:
.bc80	3c 13 03	bit $0313,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.bc83	70 08		bvs $bc8d			bvs 	_FPAWExit 					; no change.
.bc85	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.bc88	50 07		bvc $bc91			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.bc8a	20 25 bf	jsr $bf25			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.bc8d					_FPAWExit:
.bc8d	20 ad bf	jsr $bfad			jsr 	FPUNormalise 				; normalise the result.
.bc90	60		rts				rts
.bc91					_FPAWMakeSame:
.bc91	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.bc94	38		sec				sec
.bc95	fd 12 03	sbc $0312,x			sbc	 	XS2_Exponent,x 				; using subtraction
.bc98	f0 1b		beq $bcb5			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.bc9a	da		phx				phx 								; save X
.bc9b	90 06		bcc $bca3			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.bc9d	e8		inx				inx
.bc9e	e8		inx				inx
.bc9f	e8		inx				inx
.bca0	e8		inx				inx
.bca1	e8		inx				inx
.bca2	e8		inx				inx
.bca3					_FPAWShiftA:
.bca3	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.bca6	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bca9	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bcac	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bcaf	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bcb2	fa		plx				plx 								; restore original X
.bcb3	80 dc		bra $bc91			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.bcb5					_FPAW_DoArithmetic:
.bcb5	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.bcb8	30 39		bmi $bcf3			bmi 	_FPAW_BNegative
.bcba	18		clc				clc
.bcbb	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.bcbe	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bcc1	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bcc4	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bcc7	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bcca	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bccd	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bcd0	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.bcd3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bcd6	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bcd9	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.bcdc	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bcdf	90 ac		bcc $bc8d			bcc 	_FPAWExit 					; no carry.
.bce1	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x 				; so shift exponent up.
.bce4	38		sec				sec
.bce5	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.bce8	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bceb	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bcee	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.bcf1	80 9a		bra $bc8d			bra 	_FPAWExit
.bcf3					_FPAW_BNegative:
.bcf3	38		sec				sec
.bcf4	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x
.bcf7	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa+0,x
.bcfa	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bcfd	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bd00	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bd03	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd06	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bd09	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bd0c	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd0f	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bd12	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bd15	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bd18	b0 0b		bcs $bd25			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.bd1a	20 52 bf	jsr $bf52			jsr 	FPUNegateInteger			; negate the mantissa
.bd1d	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; flip result sign
.bd20	49 80		eor #$80			eor 	#$80
.bd22	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bd25					_FPAWGoExit:
.bd25	4c 8d bc	jmp $bc8d			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.bd28					FPD_IsDivZero:
.bd28	20 44 ab	jsr $ab44			jsr ERR_Handler
>bd2b	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>bd33	20 62 79 20 7a 65 72 6f 00
.bd3c					FPDivide:
.bd3c	48		pha				pha
.bd3d	5a		phy				phy
.bd3e	3c 13 03	bit $0313,x			bit 	XS2_Type,x 					; check if division by zero
.bd41	70 e5		bvs $bd28			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.bd43	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.bd46	f0 03		beq $bd4b			beq 	_FPDCalculateExp
.bd48					_FPD_Exit:
.bd48	7a		ply				ply
.bd49	68		pla				pla
.bd4a	60		rts				rts
.bd4b					_FPDCalculateExp:
.bd4b	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.bd4e	49 ff		eor #$ff			eor 	#$FF
.bd50	1a		inc a				inc 	a
.bd51	9d 12 03	sta $0312,x			sta 	XS2_Exponent,x
.bd54	20 48 be	jsr $be48			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.bd57	18		clc				clc 	 							; add 1 to the resulting exponent
.bd58	69 01		adc #$01			adc 	#1
.bd5a	b0 65		bcs $bdc1			bcs 	_FPD_Overflow 				; which can overflow.
.bd5c	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.bd5f	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.bd61	85 1a		sta $1a				sta 	zLTemp1+0
.bd63	85 1b		sta $1b				sta 	zLTemp1+1
.bd65	85 1c		sta $1c				sta 	zLTemp1+2
.bd67	85 1d		sta $1d				sta 	zLTemp1+3
.bd69	a0 20		ldy #$20			ldy 	#32 						; times round.
.bd6b					_FPD_Loop:
.bd6b	38		sec				sec 								; calculate X1-X2 stacking result because we might
.bd6c	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; not save it.
.bd6f	fd 0e 03	sbc $030e,x			sbc 	XS2_Mantissa,x
.bd72	48		pha				pha
.bd73	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.bd76	fd 0f 03	sbc $030f,x			sbc 	XS2_Mantissa+1,x
.bd79	48		pha				pha
.bd7a	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.bd7d	fd 10 03	sbc $0310,x			sbc 	XS2_Mantissa+2,x
.bd80	48		pha				pha
.bd81	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.bd84	fd 11 03	sbc $0311,x			sbc 	XS2_Mantissa+3,x
.bd87	90 17		bcc $bda0			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.bd89	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x 			; save results out to A
.bd8c	68		pla				pla
.bd8d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bd90	68		pla				pla
.bd91	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bd94	68		pla				pla
.bd95	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bd98	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.bd9a	09 80		ora #$80			ora 	#$80
.bd9c	85 1d		sta $1d				sta 	zLTemp1+3
.bd9e	80 03		bra $bda3			bra 	_FPD_Rotates
.bda0					_FPD_NoSubtract:
.bda0	68		pla				pla 								; throw away unwanted results
.bda1	68		pla				pla
.bda2	68		pla				pla
.bda3					_FPD_Rotates:
.bda3	5e 11 03	lsr $0311,x			lsr 	3+XS2_Mantissa,x
.bda6	7e 10 03	ror $0310,x			ror 	2+XS2_Mantissa,x
.bda9	7e 0f 03	ror $030f,x			ror 	1+XS2_Mantissa,x
.bdac	7e 0e 03	ror $030e,x			ror 	0+XS2_Mantissa,x
.bdaf	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.bdb1	26 1b		rol $1b				rol 	zLTemp1+1
.bdb3	26 1c		rol $1c				rol 	zLTemp1+2
.bdb5	26 1d		rol $1d				rol 	zLTemp1+3
.bdb7	90 02		bcc $bdbb			bcc 	_FPD_NoCarry
.bdb9	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.bdbb					_FPD_NoCarry:
.bdbb	88		dey				dey 								; do 32 times
.bdbc	d0 ad		bne $bd6b			bne 	_FPD_Loop
.bdbe	4c 25 be	jmp $be25			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.bdc1					_FPD_Overflow:
.bdc1	4c 22 c0	jmp $c022			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.bdc4					FPMultiply:
.bdc4	48		pha				pha
.bdc5	5a		phy				phy
.bdc6	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.bdc9	70 08		bvs $bdd3			bvs 	_FPM_Exit
.bdcb	3c 13 03	bit $0313,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.bdce	50 06		bvc $bdd6			bvc 	_FPM_CalcExponent
.bdd0	20 25 bf	jsr $bf25			jsr 	FPUCopyX2ToX1
.bdd3					_FPM_Exit:
.bdd3	7a		ply				ply
.bdd4	68		pla				pla
.bdd5	60		rts				rts
.bdd6					_FPM_CalcExponent:
.bdd6	18		clc				clc
.bdd7	20 48 be	jsr $be48			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.bdda	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; save the result.
.bddd	a9 00		lda #$00			lda 	#0
.bddf	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.bde1	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.bde3	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.bde5	85 1d		sta $1d				sta 	zLTemp1+3
.bde7	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.bde9					_FPM_Loop:
.bde9	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x				; check LSB of long product
.bdec	29 01		and #$01			and 	#1
.bdee	18		clc				clc 								; clear carry for the long rotate.
.bdef	f0 1d		beq $be0e			beq 	_FPM_NoAddition
.bdf1	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.bdf2	a5 1a		lda $1a				lda 	zLTemp1+0
.bdf4	7d 0e 03	adc $030e,x			adc 	XS2_Mantissa+0,x
.bdf7	85 1a		sta $1a				sta 	zLTemp1+0
.bdf9	a5 1b		lda $1b				lda 	zLTemp1+1
.bdfb	7d 0f 03	adc $030f,x			adc 	XS2_Mantissa+1,x
.bdfe	85 1b		sta $1b				sta 	zLTemp1+1
.be00	a5 1c		lda $1c				lda 	zLTemp1+2
.be02	7d 10 03	adc $0310,x			adc 	XS2_Mantissa+2,x
.be05	85 1c		sta $1c				sta 	zLTemp1+2
.be07	a5 1d		lda $1d				lda 	zLTemp1+3
.be09	7d 11 03	adc $0311,x			adc 	XS2_Mantissa+3,x
.be0c	85 1d		sta $1d				sta 	zLTemp1+3
.be0e					_FPM_NoAddition:
.be0e	66 1d		ror $1d				ror 	3+zLTemp1
.be10	66 1c		ror $1c				ror 	2+zLTemp1
.be12	66 1b		ror $1b				ror 	1+zLTemp1
.be14	66 1a		ror $1a				ror 	0+zLTemp1
.be16	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.be19	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.be1c	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.be1f	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.be22	88		dey				dey
.be23	d0 c4		bne $bde9			bne 	_FPM_Loop 					; do this 32 times.
.be25					FPM_CopySignNormalize:
.be25	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.be27	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.be2a	a5 1b		lda $1b				lda 	zLTemp1+1
.be2c	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.be2f	a5 1c		lda $1c				lda 	zLTemp1+2
.be31	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.be34	a5 1d		lda $1d				lda 	zLTemp1+3
.be36	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.be39	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; sign is xor of signs
.be3c	5d 13 03	eor $0313,x			eor 	XS2_Type,x
.be3f	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be42	20 ad bf	jsr $bfad			jsr 	FPUNormalise 				; normalise and exit.
.be45	7a		ply				ply
.be46	68		pla				pla
.be47	60		rts				rts
.be48					FPCalculateExponent:
.be48	18		clc				clc
.be49	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.be4c	7d 12 03	adc $0312,x			adc 	XS2_Exponent,x
.be4f	b0 08		bcs $be59			bcs 	_FPCECarry 					; carry out ?
.be51	10 03		bpl $be56			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.be53	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.be55	60		rts				rts
.be56					_FPCEExpZero:
.be56	a9 00		lda #$00			lda 	#0
.be58	60		rts				rts
.be59					_FPCECarry:
.be59	30 03		bmi $be5e			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.be5b	09 80		ora #$80			ora 	#$80 						; put in right range
.be5d	60		rts				rts
.be5e					_FPCEOverflow:
.be5e	4c 22 c0	jmp $c022			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.be61					FPFractionalPart:
.be61	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.be64	38		sec				sec 								; this flag tells us to keep the fractional part
.be65	30 0f		bmi $be76			bmi 	FPGetPart
.be67	60		rts				rts
.be68					FPIntegerPart:
.be68	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.be6b	18		clc				clc 								; this flag says keep the integer part.
.be6c	30 08		bmi $be76			bmi 	FPGetPart 					; -ve exponents are 0..127
.be6e	48		pha				pha
.be6f	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.be71	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.be74	68		pla				pla
.be75	60		rts				rts
.be76					FPGetPart:
.be76	48		pha				pha
.be77	5a		phy				phy 								; save Y
.be78	08		php				php 								; save action
.be79	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.be7c	70 62		bvs $bee0			bvs 	_FPGP_Exit 					; then do nothing.
.be7e	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.be80	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.be82	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.be84	85 1c		sta $1c				sta 	zLTemp1+2
.be86	85 1d		sta $1d				sta 	zLTemp1+3
.be88	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x				; the number of shifts.
.be8b	38		sec				sec
.be8c	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.be8e	f0 12		beq $bea2			beq 	_FPGP_NoShift 				; ... if any
.be90	c9 20		cmp #$20			cmp 	#32
.be92	90 02		bcc $be96			bcc 	_FPGP_NotMax
.be94	a9 20		lda #$20			lda 	#32 						; max of 32.
.be96					_FPGP_NotMax:
.be96	a8		tay				tay 								; Y is the mask shift count.
.be97					_FPGP_ShiftMask:
.be97	46 1d		lsr $1d				lsr 	3+zLTemp1
.be99	66 1c		ror $1c				ror 	2+zLTemp1
.be9b	66 1b		ror $1b				ror 	1+zLTemp1
.be9d	66 1a		ror $1a				ror 	0+zLTemp1
.be9f	88		dey				dey
.bea0	d0 f5		bne $be97			bne 	_FPGP_ShiftMask
.bea2					_FPGP_NoShift:
.bea2	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.bea4	8e 8c 04	stx $048c			stx 	ExpTemp						; save X
.bea7					_FPGP_MaskLoop:
.bea7	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.beaa	28		plp				plp 								; if CC we keep the top part, so we
.beab	08		php				php		 							; flip the mask.
.beac	b0 02		bcs $beb0			bcs		_FPGP_NoFlip
.beae	49 ff		eor #$ff			eor 	#$FF
.beb0					_FPGP_NoFlip:
.beb0	3d 08 03	and $0308,x			and 	XS_Mantissa,x 				; and into the mantissa.
.beb3	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.beb6	e8		inx				inx
.beb7	c8		iny				iny
.beb8	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.beba	d0 eb		bne $bea7			bne 	_FPGP_MaskLoop
.bebc	ae 8c 04	ldx $048c			ldx 	ExpTemp						; restore X
.bebf	28		plp				plp
.bec0	08		php				php 								; get action flag on the stack
.bec1	90 05		bcc $bec8			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.bec3	a9 00		lda #$00			lda 	#0
.bec5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bec8					_FPGP_NotFractional:
.bec8	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 						; check if \1 zero
.becb	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bece	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bed1	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bed4	f0 05		beq $bedb			beq 	_FPGP_Zero 					; if zero, return zero
.bed6	20 ad bf	jsr $bfad			jsr 	FPUNormalise
.bed9	80 05		bra $bee0			bra 	_FPGP_Exit 					; and exit
.bedb					_FPGP_Zero:
.bedb	a9 40		lda #$40			lda 	#$40 						; set zero flag
.bedd	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bee0					_FPGP_Exit:
.bee0	68		pla				pla 								; throw saved action flag.
.bee1	7a		ply				ply
.bee2	68		pla				pla
.bee3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.bee4					FPCompare:
.bee4	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.bee7	48		pha				pha
.bee8	bd 12 03	lda $0312,x			lda 	XS2_Exponent,x
.beeb	48		pha				pha
.beec	20 4e bc	jsr $bc4e			jsr 	FPSubtract 					; calculate X1-X2
.beef	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.bef2	70 2c		bvs $bf20			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.bef4	68		pla				pla
.bef5	8d 8c 04	sta $048c			sta 	ExpTemp						; save first exponent in temporary reg.
.bef8	68		pla				pla
.bef9	38		sec				sec
.befa	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; calculate AX-BX
.befd	70 15		bvs $bf14			bvs 	_FPCNotEqual				; overflow, can't be equal.
.beff	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.bf00	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.bf02	b0 10		bcs $bf14			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.bf04	38		sec				sec
.bf05	ad 8c 04	lda $048c			lda 	ExpTemp 					; get one of the exponents back.
.bf08	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.bf0a	b0 02		bcs $bf0e			bcs 	_FPCNotRange 				; keep in range.
.bf0c	a9 01		lda #$01			lda 	#1
.bf0e					_FPCNotRange:
.bf0e	38		sec				sec
.bf0f	fd 0c 03	sbc $030c,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.bf12	b0 0e		bcs $bf22			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.bf14					_FPCNotEqual:
.bf14	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.bf17	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.bf19	f0 02		beq $bf1d			beq 	_FPCNE2
.bf1b	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.bf1d	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.bf1e	80 04		bra $bf24			bra 	_FPCExit
.bf20					_FPCPullZero:
.bf20	68		pla				pla 								; throw saved exponents
.bf21	68		pla				pla
.bf22					_FPCZero:
.bf22	a9 00		lda #$00			lda 	#0 							; and return zero
.bf24					_FPCExit:
.bf24	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.bf25					FPUCopyX2ToX1:
.bf25	48		pha				pha
.bf26	da		phx				phx
.bf27	5a		phy				phy
.bf28	a0 08		ldy #$08			ldy 	#8
.bf2a	bd 0e 03	lda $030e,x	_FPUC21:lda 	XS2_Mantissa,x
.bf2d	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.bf30	e8		inx				inx
.bf31	88		dey				dey
.bf32	10 f6		bpl $bf2a			bpl 	_FPUC21
.bf34	7a		ply				ply
.bf35	fa		plx				plx
.bf36	68		pla				pla
.bf37	60		rts				rts
.bf38					FPUSetInteger:
.bf38	48		pha				pha
.bf39	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.bf3c	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.bf3e	10 02		bpl $bf42			bpl 	_FPUSIExtend
.bf40	a9 ff		lda #$ff			lda 	#$FF
.bf42					_FPUSIExtend:
.bf42	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.bf45	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bf48	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bf4b	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.bf4d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bf50	68		pla				pla
.bf51	60		rts				rts
.bf52					FPUNegateInteger:
.bf52	48		pha				pha
.bf53	38		sec				sec
.bf54	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.bf56	fd 08 03	sbc $0308,x			sbc 	XS_Mantissa+0,x
.bf59	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.bf5c	a9 00		lda #$00			lda 	#0
.bf5e	fd 09 03	sbc $0309,x			sbc 	XS_Mantissa+1,x
.bf61	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.bf64	a9 00		lda #$00			lda 	#0
.bf66	fd 0a 03	sbc $030a,x			sbc 	XS_Mantissa+2,x
.bf69	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.bf6c	a9 00		lda #$00			lda 	#0
.bf6e	fd 0b 03	sbc $030b,x			sbc 	XS_Mantissa+3,x
.bf71	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.bf74	68		pla				pla
.bf75	60		rts				rts
.bf76					FPUToFloat:
.bf76	48		pha				pha
.bf77	bd 0d 03	lda $030d,x			lda 	XS_Type,x					; exit if already float.
.bf7a	29 0f		and #$0f			and 	#$0F
.bf7c	f0 2d		beq $bfab			beq 	_FPUFExit
.bf7e	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.bf80	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bf83	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.bf85	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x 				; x mantissa.
.bf88	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.bf8b	10 08		bpl $bf95			bpl		_FPUFPositive
.bf8d	20 52 bf	jsr $bf52			jsr 	FPUNegateInteger 			; negate the mantissa
.bf90	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.bf92	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bf95					_FPUFPositive:
.bf95	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.bf98	1d 09 03	ora $0309,x			ora 	XS_Mantissa+1,x
.bf9b	1d 0a 03	ora $030a,x			ora 	XS_Mantissa+2,x
.bf9e	1d 0b 03	ora $030b,x			ora 	XS_Mantissa+3,x
.bfa1	d0 05		bne $bfa8			bne 	_FPUFNonZero
.bfa3	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.bfa5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.bfa8					_FPUFNonZero:
.bfa8	20 ad bf	jsr $bfad			jsr 	FPUNormalise 				; normalise the floating point.
.bfab					_FPUFExit:
.bfab	68		pla				pla
.bfac	60		rts				rts
.bfad					FPUNormalise:
.bfad	48		pha				pha
.bfae	3c 0d 03	bit $030d,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.bfb1	70 20		bvs $bfd3			bvs 	_FPUNExit
.bfb3	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.bfb6	f0 16		beq $bfce			beq 	_FPUNSetZero
.bfb8					_FPUNLoop:
.bfb8	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.bfbb	30 16		bmi $bfd3			bmi 	_FPUNExit 					; if so, we are normalised.
.bfbd	1e 08 03	asl $0308,x			asl 	0+XS_Mantissa+0,x
.bfc0	3e 09 03	rol $0309,x			rol 	1+XS_Mantissa+0,x
.bfc3	3e 0a 03	rol $030a,x			rol 	2+XS_Mantissa+0,x
.bfc6	3e 0b 03	rol $030b,x			rol 	3+XS_Mantissa+0,x
.bfc9	de 0c 03	dec $030c,x			dec 	XS_Exponent,x 				; decrement exponent
.bfcc	d0 ea		bne $bfb8			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.bfce					_FPUNSetZero:
.bfce	a9 40		lda #$40			lda 	#$40
.bfd0	9d 0d 03	sta $030d,x			sta 	XS_Type,x 					; the result is now zero.
.bfd3					_FPUNExit:
.bfd3	68		pla				pla
.bfd4	60		rts				rts
.bfd5					FPUToInteger:
.bfd5	48		pha				pha
.bfd6	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; if already integer, exit
.bfd9	29 01		and #$01			and 	#1
.bfdb	d0 3e		bne $c01b			bne 	_FPUTOI_Exit
.bfdd	3c 0d 03	bit $030d,x			bit 	XS_Type,x					; if zero, return zero.
.bfe0	70 2b		bvs $c00d			bvs 	_FPUTOI_Zero
.bfe2	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.bfe5	10 26		bpl $c00d			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.bfe7	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.bfe9	b0 37		bcs $c022			bcs 	FP_Overflow
.bfeb					_FPUToIToInteger:
.bfeb	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.bfee	c9 a0		cmp #$a0			cmp 	#128+32
.bff0	f0 11		beq $c003			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.bff2	fe 0c 03	inc $030c,x			inc 	XS_Exponent,X 				; increment Exponent
.bff5	5e 0b 03	lsr $030b,x			lsr 	3+XS_Mantissa,x
.bff8	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.bffb	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.bffe	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.c001	80 e8		bra $bfeb			bra 	_FPUToIToInteger 			; keep going.
.c003					_FPUToICheckSign:
.c003	bd 0d 03	lda $030d,x			lda 	XS_Type,x 					; check sign
.c006	10 13		bpl $c01b			bpl 	_FPUToI_Exit 				; exit if unsigned.
.c008	20 52 bf	jsr $bf52			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.c00b	80 0e		bra $c01b			bra 	_FPUTOI_Exit
.c00d					_FPUTOI_Zero:
.c00d	a9 00		lda #$00			lda 	#0 							; return zero integer.
.c00f	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c012	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c015	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c018	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c01b					_FPUToI_Exit:
.c01b	a9 01		lda #$01			lda 	#1 							; set type to integer
.c01d	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c020	68		pla				pla
.c021	60		rts				rts
.c022					FP_Overflow:
.c022	20 44 ab	jsr $ab44			jsr ERR_Handler
>c025	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>c02d	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.c03d					FPUTimes10:
.c03d	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.c040	85 1a		sta $1a				sta 	ZLTemp1+0
.c042	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c045	85 1b		sta $1b				sta 	ZLTemp1+1
.c047	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c04a	85 1c		sta $1c				sta 	ZLTemp1+2
.c04c	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c04f	85 1d		sta $1d				sta 	ZLTemp1+3
.c051	20 95 c0	jsr $c095			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.c054	20 95 c0	jsr $c095			jsr 	_FPUT_LSR_ZLTemp1
.c057	18		clc				clc
.c058	bd 08 03	lda $0308,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.c05b	65 1a		adc $1a				adc 	ZLTemp1+0
.c05d	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c060	bd 09 03	lda $0309,x			lda 	XS_Mantissa+1,x
.c063	65 1b		adc $1b				adc 	ZLTemp1+1
.c065	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c068	bd 0a 03	lda $030a,x			lda 	XS_Mantissa+2,x
.c06b	65 1c		adc $1c				adc 	ZLTemp1+2
.c06d	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c070	bd 0b 03	lda $030b,x			lda 	XS_Mantissa+3,x
.c073	65 1d		adc $1d				adc 	ZLTemp1+3
.c075	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c078	90 0f		bcc $c089			bcc 	_FPUTimes10
.c07a	7e 0b 03	ror $030b,x			ror 	3+XS_Mantissa,x
.c07d	7e 0a 03	ror $030a,x			ror 	2+XS_Mantissa,x
.c080	7e 09 03	ror $0309,x			ror 	1+XS_Mantissa,x
.c083	7e 08 03	ror $0308,x			ror 	0+XS_Mantissa,x
.c086	fe 0c 03	inc $030c,x			inc 	XS_Exponent,x				; fix exponent
.c089					_FPUTimes10:
.c089	bd 0c 03	lda $030c,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.c08c	18		clc				clc
.c08d	69 03		adc #$03			adc 	#3
.c08f	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c092	b0 8e		bcs $c022			bcs 	FP_Overflow 				; error
.c094	60		rts				rts
.c095					_FPUT_LSR_ZLTemp1:
.c095	46 1d		lsr $1d				lsr 	ZLTemp1+3
.c097	66 1c		ror $1c				ror 	ZLTemp1+2
.c099	66 1b		ror $1b				ror 	ZLTemp1+1
.c09b	66 1a		ror $1a				ror 	ZLTemp1+0
.c09d	60		rts				rts
.c09e					FPUScale10A:
.c09e	5a		phy				phy
.c09f	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.c0a1	f0 3d		beq $c0e0			beq 	_FPUScaleExit
.c0a3	da		phx				phx 								; save X
.c0a4	e8		inx				inx
.c0a5	e8		inx				inx
.c0a6	e8		inx				inx
.c0a7	e8		inx				inx
.c0a8	e8		inx				inx
.c0a9	e8		inx				inx
.c0aa	a8		tay				tay 								; save power scalar in Y.
.c0ab	a9 00		lda #$00			lda 	#0
.c0ad	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.c0b0	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c0b3	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c0b6	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c0b9	a9 80		lda #$80			lda 	#$80
.c0bb	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c0be	a9 81		lda #$81			lda 	#$81
.c0c0	9d 0c 03	sta $030c,x			sta 	XS_Exponent,x
.c0c3	5a		phy				phy 								; save 10^n on stack.
.c0c4	c0 00		cpy #$00			cpy 	#0
.c0c6	10 05		bpl $c0cd			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.c0c8	98		tya				tya
.c0c9	49 ff		eor #$ff			eor 	#$FF
.c0cb	1a		inc a				inc 	a
.c0cc	a8		tay				tay
.c0cd					_FPUSAbs:
.c0cd	20 3d c0	jsr $c03d			jsr 	FPUTimes10
.c0d0	88		dey				dey
.c0d1	d0 fa		bne $c0cd			bne 	_FPUSAbs 					; tos is now 10^|AC|
.c0d3	68		pla				pla 								; restore count in A
.c0d4	fa		plx				plx 								; restore X pointing to number to scale.
.c0d5	0a		asl a				asl 	a
.c0d6	b0 05		bcs $c0dd			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.c0d8	20 c4 bd	jsr $bdc4			jsr 	FPMultiply 					; if clear multiply.
.c0db	80 03		bra $c0e0			bra		_FPUScaleExit
.c0dd					_FPUSDivide:
.c0dd	20 3c bd	jsr $bd3c			jsr 	FPDivide
.c0e0					_FPUScaleExit:
.c0e0	7a		ply				ply
.c0e1	60		rts				rts
.c0e2					FPUCopyToNext:
.c0e2	a0 06		ldy #$06			ldy 		#6
.c0e4	da		phx				phx
.c0e5					_FPUCopy1:
.c0e5	bd 08 03	lda $0308,x			lda 	XS_Mantissa,x
.c0e8	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa,x
.c0eb	e8		inx				inx
.c0ec	88		dey				dey
.c0ed	d0 f6		bne $c0e5			bne 	_FPUCopy1
.c0ef	fa		plx				plx
.c0f0	60		rts				rts
.c0f1					FPUCopyFromNext:
.c0f1	a0 06		ldy #$06			ldy 		#6
.c0f3	da		phx				phx
.c0f4					_FPUCopy1:
.c0f4	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa,x
.c0f7	9d 08 03	sta $0308,x			sta 	XS_Mantissa,x
.c0fa	e8		inx				inx
.c0fb	88		dey				dey
.c0fc	d0 f6		bne $c0f4			bne 	_FPUCopy1
.c0fe	fa		plx				plx
.c0ff	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.c100					FPToString:
.c100	48		pha				pha
.c101	5a		phy				phy
.c102	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; check zero flag
.c105	50 0a		bvc $c111			bvc 		_FPTSIsFloat 			; if zero,
.c107					_FPTSZero:
.c107	a9 30		lda #$30			lda 		#"0"
.c109	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter
.c10c					_FPTSExit:
.c10c	7a		ply				ply
.c10d	68		pla				pla
.c10e	60		rts				rts
.c10f	80 fb		bra $c10c			bra 		_FPTSExit
.c111					_FPTSIsFloat:
.c111	bd 0d 03	lda $030d,x			lda 		XS_Type,x 				; is it signed ?
.c114	10 0a		bpl $c120			bpl 		_FPTSNotSigned
.c116	a9 00		lda #$00			lda 		#0 						; clear sign flag
.c118	9d 0d 03	sta $030d,x			sta 		XS_Type,x
.c11b	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.c11d	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter
.c120					_FPTSNotSigned:
.c120	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x
.c123	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.c125	b0 09		bcs $c130			bcs 		_FPTSExponent
.c127	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.c129	90 05		bcc $c130			bcc 		_FPTSExponent 			;
.c12b					_FPTSStandard:
.c12b	20 74 c1	jsr $c174			jsr 		FPTOutputBody 			; output the body.
.c12e	80 dc		bra $c10c			bra 		_FPTSExit
.c130					_FPTSExponent:
.c130	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.c132	8d 8d 04	sta $048d			sta 		ExpCount
.c135					_FPTSExponentLoop:
.c135	bd 0c 03	lda $030c,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.c138	10 0e		bpl $c148			bpl 		_FPTSTimes
.c13a	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.c13c	90 14		bcc $c152			bcc 		_FPTSScaledToExp
.c13e	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.c140	20 9e c0	jsr $c09e			jsr 		FPUScale10A
.c143	ee 8d 04	inc $048d			inc 		ExpCount
.c146	80 ed		bra $c135			bra 		_FPTSExponentLoop
.c148					_FPTSTimes:
.c148	a9 01		lda #$01			lda 		#1
.c14a	20 9e c0	jsr $c09e			jsr 		FPUScale10A
.c14d	ce 8d 04	dec $048d			dec 		ExpCount
.c150	80 e3		bra $c135			bra 		_FPTSExponentLoop
.c152					_FPTSScaledToExp:
.c152	20 74 c1	jsr $c174			jsr 		FPTOutputBody 			; output the body.
.c155	a9 65		lda #$65			lda 		#"e"					; output E
.c157	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter
.c15a	ad 8d 04	lda $048d			lda 		ExpCount 				; get the exponent
.c15d	9d 08 03	sta $0308,x			sta 		XS_Mantissa,x
.c160	29 80		and #$80			and 		#$80 					; sign extend it
.c162	f0 02		beq $c166			beq 		_FPTSSExt
.c164	a9 ff		lda #$ff			lda 		#$FF
.c166					_FPTSSExt:
.c166	9d 09 03	sta $0309,x			sta 		XS_Mantissa+1,x
.c169	9d 0a 03	sta $030a,x			sta 		XS_Mantissa+2,x
.c16c	9d 0b 03	sta $030b,x			sta 		XS_Mantissa+3,x
.c16f	20 f0 ba	jsr $baf0			jsr 		INTToString 			; output the exponent.
.c172	80 98		bra $c10c			bra			_FPTSExit 				; and exit.
.c174					FPTOutputBody:
.c174	20 e2 c0	jsr $c0e2			jsr 		FPUCopyToNext 			; copy to next slot.
.c177	20 d5 bf	jsr $bfd5			jsr 		FPUToInteger 			; convert to an integer
.c17a	20 f0 ba	jsr $baf0			jsr 		INTToString 			; output the main integer part.
.c17d	20 f1 c0	jsr $c0f1			jsr 		FPUCopyFromNext 		; get the fractional part back.
.c180	20 61 be	jsr $be61			jsr 		FPFractionalPart 		; get the decimal part.
.c183	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; any fractional part.
.c186	70 3e		bvs $c1c6			bvs 		_FPTOExit 				; if not, exit now.
.c188	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.c18a	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter
.c18d					_FPOutLoop:
.c18d	3c 0d 03	bit $030d,x			bit 		XS_Type,x 				; finally reached zero.
.c190	70 1e		bvs $c1b0			bvs 		_FPStripZeros 			; strip trailing zeros
.c192	20 3d c0	jsr $c03d			jsr 		FPUTimes10 				; multiply by 10
.c195	20 e2 c0	jsr $c0e2			jsr 		FPUCopyToNext			; copy to next slot.
.c198	20 d5 bf	jsr $bfd5			jsr 		FPUToInteger 			; convert to integer
.c19b	bd 08 03	lda $0308,x			lda 		XS_Mantissa+0,x 		; print digit.
.c19e	09 30		ora #$30			ora 		#"0"
.c1a0	20 90 bb	jsr $bb90			jsr 		ITSOutputCharacter
.c1a3	20 f1 c0	jsr $c0f1			jsr 		FPUCopyFromNext 		; get it back
.c1a6	20 61 be	jsr $be61			jsr 		FPFractionalPart 		; get fractional part
.c1a9	ad 04 04	lda $0404			lda 		NumBufX 				; done 11 characters yet ?
.c1ac	c9 0b		cmp #$0b			cmp 	 	#11
.c1ae	90 dd		bcc $c18d			bcc 		_FPOutLoop 				; if so, keep going till zero.
.c1b0					_FPStripZeros:
.c1b0	ac 04 04	ldy $0404			ldy 		NumBufX 				; strip trailing zeros.
.c1b3					_FPStripLoop:
.c1b3	88		dey				dey 								; back one, if at start then no strip
.c1b4	f0 10		beq $c1c6			beq 		_FPToExit
.c1b6	b9 05 04	lda $0405,y			lda 		Num_Buffer,y 			; keep going if "0"
.c1b9	c9 30		cmp #$30			cmp 		#"0"
.c1bb	f0 f6		beq $c1b3			beq 		_FPStripLoop
.c1bd	c8		iny				iny
.c1be	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.c1c0	99 05 04	sta $0405,y			sta 		Num_Buffer,y
.c1c3	8c 04 04	sty $0404			sty 		NumBufX 				; update position.
.c1c6					_FPTOExit:
.c1c6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.c1c7					FPFromString:
.c1c7	48		pha				pha 								; push A
.c1c8	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.c1ca	c9 2e		cmp #$2e			cmp 	#"."
.c1cc	f0 03		beq $c1d1			beq	 	_FPFIsDecimal
.c1ce	4c 34 c2	jmp $c234			jmp 	_FPFNotDecimal
.c1d1					_FPFIsDecimal:
.c1d1	c8		iny				iny 								; consume the decimal.
.c1d2	20 76 bf	jsr $bf76			jsr 	FPUToFloat 					; convert the integer to float.
.c1d5	da		phx				phx 								; save X.
.c1d6	5a		phy				phy 								; save decimal start position
.c1d7	e8		inx				inx
.c1d8	e8		inx				inx
.c1d9	e8		inx				inx
.c1da	e8		inx				inx
.c1db	e8		inx				inx
.c1dc	e8		inx				inx
.c1dd	20 a8 bb	jsr $bba8			jsr 	INTFromStringY 				; get the part after the DP.
.c1e0	20 76 bf	jsr $bf76			jsr 	FPUToFloat 					; convert that to a float.
.c1e3	68		pla				pla 								; calculate - chars consumed.
.c1e4	8c 8c 04	sty $048c			sty 	ExpTemp
.c1e7	38		sec				sec
.c1e8	ed 8c 04	sbc $048c			sbc 	ExpTemp 					; this is the shift amount
.c1eb	20 9e c0	jsr $c09e			jsr 	FPUScale10A 				; scale it by 10^AC
.c1ee	fa		plx				plx 								; restore original X
.c1ef	20 58 bc	jsr $bc58			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.c1f2	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.c1f4	c9 45		cmp #$45			cmp 	#"E"
.c1f6	f0 04		beq $c1fc			beq 	_FPFExponent
.c1f8	c9 65		cmp #$65			cmp 	#"e"
.c1fa	d0 38		bne $c234			bne 	_FPFNotDecimal 				; no, then exit normally.
.c1fc					_FPFExponent:
.c1fc	c8		iny				iny 								; skip over E symbol.
.c1fd	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.c1ff	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.c201	d0 01		bne $c204			bne 	_FPFGotSign
.c203	c8		iny				iny 								; if it was - skip over it.
.c204					_FPFGotSign:
.c204	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.c205	da		phx				phx
.c206	e8		inx				inx
.c207	e8		inx				inx
.c208	e8		inx				inx
.c209	e8		inx				inx
.c20a	e8		inx				inx
.c20b	e8		inx				inx
.c20c	20 a8 bb	jsr $bba8			jsr 	INTFromStringY 				; get the exponent
.c20f	fa		plx				plx 								; restore X.
.c210	bd 0f 03	lda $030f,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.c213	1d 11 03	ora $0311,x			ora 	XS2_Mantissa+3,x
.c216	1d 10 03	ora $0310,x			ora 	XS2_Mantissa+2,x
.c219	d0 1b		bne $c236			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.c21b	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.c21e	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.c220	b0 14		bcs $c236			bcs 	_FPFXOverflow
.c222	68		pla				pla 								; get direction
.c223	d0 09		bne $c22e			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.c225	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.c228	49 ff		eor #$ff			eor 	#$FF
.c22a	1a		inc a				inc 	a
.c22b	9d 0e 03	sta $030e,x			sta 	XS2_Mantissa+0,x
.c22e					_FPFXScale:
.c22e	bd 0e 03	lda $030e,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.c231	20 9e c0	jsr $c09e			jsr 	FPUScale10A 				; scale by the exponent.
.c234					_FPFNotDecimal:
.c234	68		pla				pla
.c235	60		rts				rts
.c236					_FPFXOverflow:
.c236	20 44 ab	jsr $ab44			jsr 	ERR_Handler
>c239	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>c241	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.c248					Unary_Rnd:
.c248	20 d6 b0	jsr $b0d6			jsr 	EvaluateNumberX 			; get value
.c24b	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; check right bracket.
.c24e	20 c3 b3	jsr $b3c3			jsr 	GetSignCurrent 				; get sign -1,0,1.
.c251	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.c253	30 10		bmi $c265			bmi 	_URSetSeed
.c255	f0 2c		beq $c283			beq 	_URMakeRandom 				; if zero return same number.
.c257	da		phx				phx
.c258	a2 00		ldx #$00			ldx 	#0
.c25a	20 c0 c2	jsr $c2c0			jsr 	Random16
.c25d	a2 02		ldx #$02			ldx 	#2
.c25f	20 c0 c2	jsr $c2c0			jsr 	Random16
.c262	fa		plx				plx
.c263	80 1e		bra $c283			bra 	_URMakeRandom
.c265					_URSetSeed:
.c265	20 76 bf	jsr $bf76			jsr 	FPUToFloat 					; make it a float to twiddle it.
.c268	bd 08 03	lda $0308,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.c26b	8d 93 04	sta $0493			sta 	RandomSeed+0
.c26e	bd 09 03	lda $0309,x			lda		XS_Mantissa+1,x
.c271	8d 94 04	sta $0494			sta 	RandomSeed+1
.c274	bd 0a 03	lda $030a,x			lda		XS_Mantissa+2,x
.c277	8d 95 04	sta $0495			sta 	RandomSeed+2
.c27a	bd 0b 03	lda $030b,x			lda		XS_Mantissa+3,x
.c27d	0a		asl a				asl 	a
.c27e	49 db		eor #$db			eor 	#$DB
.c280	8d 96 04	sta $0496			sta 	RandomSeed+3
.c283					_URMakeRandom:
.c283	ad 93 04	lda $0493			lda 	RandomSeed+0 				; check if seed is zero.
.c286	0d 94 04	ora $0494			ora 	RandomSeed+1
.c289	0d 95 04	ora $0495			ora 	RandomSeed+2
.c28c	0d 96 04	ora $0496			ora 	RandomSeed+3
.c28f	d0 0a		bne $c29b			bne 	_URNotZero
.c291	a9 47		lda #$47			lda 	#$47
.c293	8d 94 04	sta $0494			sta 	RandomSeed+1				; if it is, make it non zero.
.c296	a9 3d		lda #$3d			lda 	#$3D
.c298	8d 96 04	sta $0496			sta 	RandomSeed+3
.c29b					_URNotZero:
.c29b	ad 93 04	lda $0493			lda 	RandomSeed+0 				; copy seed into mantissa.
.c29e	9d 08 03	sta $0308,x			sta 	XS_Mantissa+0,x
.c2a1	ad 94 04	lda $0494			lda 	RandomSeed+1
.c2a4	9d 09 03	sta $0309,x			sta 	XS_Mantissa+1,x
.c2a7	ad 95 04	lda $0495			lda 	RandomSeed+2
.c2aa	9d 0a 03	sta $030a,x			sta 	XS_Mantissa+2,x
.c2ad	ad 96 04	lda $0496			lda 	RandomSeed+3
.c2b0	9d 0b 03	sta $030b,x			sta 	XS_Mantissa+3,x
.c2b3	a9 00		lda #$00			lda 	#$00 						; set type to float.
.c2b5	9d 0d 03	sta $030d,x			sta 	XS_Type,x
.c2b8	a9 80		lda #$80			lda 	#$80
.c2ba	9d 0c 03	sta $030c,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.c2bd	4c ad bf	jmp $bfad			jmp 	FPUNormalise
.c2c0					Random16:
.c2c0	5e 94 04	lsr $0494,x			lsr 	RandomSeed+1,x				; shift seed right
.c2c3	7e 93 04	ror $0493,x			ror 	RandomSeed,x
.c2c6	90 08		bcc $c2d0			bcc 	_R16_NoXor
.c2c8	bd 94 04	lda $0494,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.c2cb	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.c2cd	9d 94 04	sta $0494,x			sta 	RandomSeed+1,x
.c2d0					_R16_NoXor:
.c2d0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.c2d1					Unary_Int:
.c2d1	20 d6 b0	jsr $b0d6			jsr 	EvaluateNumberX 			; get value
.c2d4	20 68 b7	jsr $b768			jsr 	CheckNextRParen 			; check right bracket.
.c2d7	4c d5 bf	jmp $bfd5			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.c2da					TIM_Error:
.c2da	20 35 a0	jsr $a035			jsr 	IFT_UpLine 					; go up one line.
.c2dd	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.c2df	80 02		bra $c2e3			bra 	TIM_ShowPrompt
.c2e1					TIM_NewCommand:
.c2e1	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.c2e3					TIM_ShowPrompt:
.c2e3	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.c2e6	20 06 a1	jsr $a106			jsr 	IFT_ReadLine	 			; get character, go to next line
.c2e9	20 68 a0	jsr $a068			jsr 	IFT_NewLine					; go to next line.
.c2ec	86 10		stx $10				stx 	zTemp1 						; save line read address
.c2ee	84 11		sty $11				sty 	zTemp1+1
.c2f0	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.c2f2	b1 10		lda ($10),y			lda 	(zTemp1),y
.c2f4	c9 3f		cmp #$3f			cmp 	#"?"
.c2f6	f0 04		beq $c2fc			beq 	TIM_SkipFirst
.c2f8	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.c2fa	d0 01		bne $c2fd			bne 	TIM_NotDot
.c2fc					TIM_SkipFirst:
.c2fc	c8		iny				iny
.c2fd					TIM_NotDot:
.c2fd	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.c2ff	c9 52		cmp #$52			cmp 	#"R"						; show registers
.c301	f0 6e		beq $c371			beq 	TIM_ShowRegisters
.c303	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.c305	f0 12		beq $c319			beq 	TIM_ShowMemory
.c307	c9 47		cmp #$47			cmp 	#"G"						; execute
.c309	f0 49		beq $c354			beq 	TIM_Execute
.c30b	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.c30d	f0 07		beq $c316			beq 	TIM_GoLoadMemory
.c30f	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.c311	d0 c7		bne $c2da			bne 	TIM_Error
.c313	4c 96 c4	jmp $c496			jmp 	TIM_UpdateRegisters
.c316					TIM_GoLoadMemory:
.c316	4c c1 c4	jmp $c4c1			jmp 	TIM_LoadMemory
.c319					TIM_ShowMemory:
.c319	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c31c	b0 bc		bcs $c2da			bcs 	TIM_Error
.c31e	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.c320	85 12		sta $12				sta 	zTemp2
.c322	a5 15		lda $15				lda 	zTemp3+1
.c324	85 13		sta $13				sta 	zTemp2+1
.c326	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.c329	90 08		bcc $c333			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.c32b	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.c32d	85 14		sta $14				sta 	zTemp3
.c32f	a5 13		lda $13				lda 	zTemp2+1
.c331	85 15		sta $15				sta 	zTemp3+1
.c333					_TIMSM_Start:
.c333	20 e7 c3	jsr $c3e7			jsr 	TIM_WriteLine 				; write one line of hex out
.c336	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.c338	18		clc				clc
.c339	69 10		adc #$10			adc 	#16
.c33b	85 12		sta $12				sta 	zTemp2
.c33d	90 02		bcc $c341			bcc 	_TIMSM_NoCarry
.c33f	e6 13		inc $13				inc 	zTemp2+1
.c341					_TIMSM_NoCarry:
.c341	20 f1 a1	jsr $a1f1			jsr 	IF_CheckBreak 				; check CTL+C
.c344	d0 0b		bne $c351			bne 	_TIMSM_Ends 				; if pressed break out.
.c346	38		sec				sec 								; check past the end address in zTemp3
.c347	a5 14		lda $14				lda 	zTemp3
.c349	e5 12		sbc $12				sbc 	zTemp2
.c34b	a5 15		lda $15				lda 	zTemp3+1
.c34d	e5 13		sbc $13				sbc 	zTemp2+1
.c34f	10 e2		bpl $c333			bpl 	_TIMSM_Start
.c351					_TIMSM_Ends:
.c351	4c e1 c2	jmp $c2e1			jmp 	TIM_NewCommand
.c354					TIM_Execute:
.c354	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; get the execute address
.c357	b0 81		bcs $c2da			bcs 	TIM_Error 					; not legitimate
.c359	ae a0 04	ldx $04a0			ldx 	TIM_SP 						; set up SP
.c35c	9a		txs				txs
.c35d	ad 9b 04	lda $049b			lda 	TIM_SR 						; Status for PLP
.c360	48		pha				pha
.c361	ad 9c 04	lda $049c			lda 	TIM_A 						; restore AXYZ
.c364	ae 9d 04	ldx $049d			ldx 	TIM_X
.c367	ac 9e 04	ldy $049e			ldy 	TIM_Y
.c36a	ab 9f 04	ldz $049f			ldz 	TIM_Z
.c36d	28		plp				plp 								; and PS Byte.
.c36e	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.c371					TIM_Start:
.c371					TIM_ShowRegisters:
.c371	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.c374	8d 9a 04	sta $049a			sta 	TIM_IRQ+1
.c377	ad ff ff	lda $ffff			lda 	$FFFF
.c37a	8d 99 04	sta $0499			sta 	TIM_IRQ
.c37d	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.c37f					_TIMSR_Text:
.c37f	bd ab c3	lda $c3ab,x			lda 	_TIMSR_Label,x
.c382	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c385	e8		inx				inx
.c386	e0 23		cpx #$23			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.c388	d0 f5		bne $c37f			bne 	_TIMSR_Text
.c38a	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.c38c					_TIMSR_Skip:
.c38c	e8		inx				inx
.c38d					_TIMSR_LoopSpace:
.c38d	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.c38f	b0 04		bcs $c395			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.c391	8a		txa				txa
.c392	4a		lsr a				lsr 	a
.c393	b0 05		bcs $c39a			bcs 	_TIMSR_NoSpace
.c395					_TIMSR_Space:
.c395	a9 20		lda #$20			lda 	#" "
.c397	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c39a					_TIMSR_NoSpace:
.c39a	bd 97 04	lda $0497,x			lda 	TIM_PC,x 					; output hex value.
.c39d	20 ce c3	jsr $c3ce			jsr 	TIM_WriteHex
.c3a0	e8		inx				inx
.c3a1	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.c3a3	d0 e8		bne $c38d			bne 	_TimSR_LoopSpace
.c3a5	20 68 a0	jsr $a068			jsr 	IFT_NewLine 				; new line
.c3a8	4c e1 c2	jmp $c2e1			jmp	 	TIM_NewCommand 				; new command.
.c3ab					_TIMSR_Label:
>c3ab	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>c3b3	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>c3c3	52
>c3c4	20 5a 52					.text 	" ZR"
>c3c7	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.c3ce					_TIMSR_LabelEnd:
.c3ce					TIM_WriteHex:
.c3ce	48		pha				pha 								; save A
.c3cf	4a		lsr a				lsr 	a 							; shift MSB->LSB
.c3d0	4a		lsr a				lsr 	a
.c3d1	4a		lsr a				lsr 	a
.c3d2	4a		lsr a				lsr 	a
.c3d3	20 d7 c3	jsr $c3d7			jsr 	_TIMWH_Nibble 				; print MSB
.c3d6	68		pla				pla 								; restore and print LSB
.c3d7					_TIMWH_Nibble:
.c3d7	48		pha				pha
.c3d8	29 0f		and #$0f			and 	#15 						; mask out
.c3da	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.c3dc	90 02		bcc $c3e0			bcc 	_TIMWHNoLetter
.c3de	69 06		adc #$06			adc 	#6
.c3e0					_TIMWHNoLetter:
.c3e0	69 30		adc #$30			adc 	#48
.c3e2	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter 			; print it out.
.c3e5	68		pla				pla
.c3e6	60		rts				rts
.c3e7					TIM_WriteLine:
.c3e7	a9 2e		lda #$2e			lda 	#"." 						; prompt
.c3e9	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c3ec	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.c3ee	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c3f1	a5 13		lda $13				lda 	zTemp2+1 					; write address
.c3f3	20 ce c3	jsr $c3ce			jsr 	TIM_WriteHex
.c3f6	a5 12		lda $12				lda 	zTemp2
.c3f8	20 ce c3	jsr $c3ce			jsr 	TIM_WriteHex
.c3fb	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.c3fd					_TIMWL_Loop:
.c3fd	a9 20		lda #$20			lda 	#" "
.c3ff	20 41 a0	jsr $a041			jsr 	IFT_PrintCharacter
.c402	b1 12		lda ($12),y			lda 	(zTemp2),y
.c404	20 ce c3	jsr $c3ce			jsr 	TIM_WriteHex
.c407	c8		iny				iny
.c408	c0 10		cpy #$10			cpy 	#16
.c40a	d0 f1		bne $c3fd			bne 	_TIMWL_Loop
.c40c	4c 68 a0	jmp $a068			jmp 	IFT_NewLine 				; new line and exit
.c40f					TIM_GetHex:
.c40f	c8		iny				iny
.c410	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.c412	c9 20		cmp #$20			cmp 	#32
.c414	f0 f9		beq $c40f			beq 	TIM_GetHex
.c416	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.c418	f0 f5		beq $c40f			beq 	TIM_GetHex
.c41a	20 43 c4	jsr $c443			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.c41d	b0 23		bcs $c442			bcs 	_TIMGH_Exit					; if first bad then exit now.
.c41f	a9 00		lda #$00			lda 	#0 							; zero result
.c421	85 14		sta $14				sta 	zTemp3
.c423	85 15		sta $15				sta 	zTemp3+1
.c425					_TIM_GHLoop:
.c425	20 43 c4	jsr $c443			jsr 	TIM_GetHexCharacter 		; get next character
.c428	b0 17		bcs $c441			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.c42a	c8		iny				iny 								; skip over it.
.c42b	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.c42d	26 15		rol $15				rol 	zTemp3+1
.c42f	06 14		asl $14				asl 	zTemp3 						; now x 2
.c431	26 15		rol $15				rol 	zTemp3+1
.c433	06 14		asl $14				asl 	zTemp3						; now x 4
.c435	26 15		rol $15				rol 	zTemp3+1
.c437	06 14		asl $14				asl 	zTemp3 						; now x 8
.c439	26 15		rol $15				rol 	zTemp3+1
.c43b	05 14		ora $14				ora 	zTemp3 						; OR result in
.c43d	85 14		sta $14				sta 	zTemp3
.c43f	80 e4		bra $c425			bra 	_TIM_GHLoop 				; loop round again.
.c441					_TIMGH_Okay:
.c441	18		clc				clc
.c442					_TIMGH_Exit:
.c442	60		rts				rts
.c443					TIM_GetHexCharacter:
.c443	b1 10		lda ($10),y			lda 	(zTemp1),y
.c445	38		sec				sec
.c446	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.c448	90 0e		bcc $c458			bcc 	_TIM_GHCFail
.c44a	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.c44c	90 0b		bcc $c459			bcc 	_TIM_GHCExit
.c44e	c9 11		cmp #$11			cmp 	#65-48						; < A
.c450	90 06		bcc $c458			bcc		_TIM_GHCFail
.c452	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.c454	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.c456	90 01		bcc $c459			bcc		_TIM_GHCExit
.c458					_TIM_GHCFail:
.c458	38		sec				sec
.c459					_TIM_GHCExit:
.c459	60		rts				rts
.c45a					TIM_BreakVector:
.c45a	da		phx				phx									; save X/A on stack
.c45b	48		pha				pha
.c45c	ba		tsx				tsx 								; X points to S
.c45d	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.c460	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.c462	d0 03		bne $c467			bne 	_TIMBreak					; if set, it's BRK
.c464	68		pla				pla 								; abandon routine.
.c465	fa		plx				plx
.c466	40		rti				rti
.c467					_TIMBreak:
.c467	68		pla				pla 								; save A X Y and maybe Z
.c468	8d 9c 04	sta $049c			sta 	TIM_A
.c46b	fa		plx				plx
.c46c	8e 9d 04	stx $049d			stx 	TIM_X
.c46f	8c 9e 04	sty $049e			sty 	TIM_Y
.c472	9c 9f 04	stz $049f			stz 	TIM_Z
.c475	68		pla				pla 								; get Status Register
.c476	8d 9b 04	sta $049b			sta 	TIM_SR
.c479	68		pla				pla
.c47a	8d 98 04	sta $0498			sta 	TIM_PC+1 					; save calling address
.c47d	68		pla				pla
.c47e	8d 97 04	sta $0497			sta 	TIM_PC 						; high byte
.c481	ad 98 04	lda $0498			lda 	TIM_PC+1 					; dec PC to point right.
.c484	d0 03		bne $c489			bne 	_TIMDecrement 				; brk bumps it.
.c486	ce 97 04	dec $0497			dec 	TIM_PC
.c489					_TIMDecrement:
.c489	ce 98 04	dec $0498			dec 	TIM_PC+1
.c48c	ba		tsx				tsx 								; and copy SP
.c48d	8e a0 04	stx $04a0			stx 	TIM_SP
.c490	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.c492	9a		txs				txs
.c493	4c 71 c3	jmp $c371			jmp 	TIM_Start 					; and start up TIM monitor.
.c496					TIM_UpdateRegisters:
.c496	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; PC
.c499	b0 23		bcs $c4be			bcs 	_TIMURFail
.c49b	a5 14		lda $14				lda 	zTemp3
.c49d	8d 98 04	sta $0498			sta 	Tim_PC+1
.c4a0	a5 15		lda $15				lda 	zTemp3+1
.c4a2	8d 97 04	sta $0497			sta 	Tim_PC
.c4a5	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; ignore IRQ
.c4a8	b0 14		bcs $c4be			bcs 	_TIMURFail
.c4aa	a2 00		ldx #$00			ldx 	#0
.c4ac					_TIM_URLoop:
.c4ac	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; registers
.c4af	b0 0d		bcs $c4be			bcs 	_TIMURFail
.c4b1	a5 14		lda $14				lda 	zTemp3
.c4b3	9d 9b 04	sta $049b,x			sta 	Tim_SR,x
.c4b6	e8		inx				inx
.c4b7	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.c4b9	d0 f1		bne $c4ac			bne 	_TIM_URLoop
.c4bb	4c e1 c2	jmp $c2e1			jmp 	TIM_NewCommand
.c4be					_TIMURFail:
.c4be	4c da c2	jmp $c2da			jmp 	TIM_Error
.c4c1					TIM_LoadMemory:
.c4c1	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; target address => zTemp2
.c4c4	a5 14		lda $14				lda 	zTemp3
.c4c6	85 12		sta $12				sta 	zTemp2
.c4c8	a5 15		lda $15				lda 	zTemp3+1
.c4ca	85 13		sta $13				sta 	zTemp2+1
.c4cc					_TIM_LMLoop:
.c4cc	20 0f c4	jsr $c40f			jsr 	TIM_GetHex 					; next byte ?
.c4cf	b0 0e		bcs $c4df			bcs 	_TIMLMDone 					; no more
.c4d1	a2 00		ldx #$00			ldx 	#0							; write out.
.c4d3	a5 14		lda $14				lda 	zTemp3
.c4d5	81 12		sta ($12,x)			sta 	(zTemp2,x)
.c4d7	e6 12		inc $12				inc 	zTemp2 						; bump address
.c4d9	d0 f1		bne $c4cc			bne 	_TIM_LMLoop
.c4db	e6 13		inc $13				inc 	zTemp2+1
.c4dd	80 ed		bra $c4cc			bra 	_TIM_LMLoop
.c4df					_TIMLMDone:
.c4df	4c e1 c2	jmp $c2e1			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Return to file: basic.asm

.c4e2	80 fe		bra $c4e2	_halt:	bra 		_halt
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 a0						.word 	StartROM
>fffe	5a c4					.word TIM_BreakVector

;******  End of listing
