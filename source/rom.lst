
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -Wall -b -q -L rom.lst -o rom.bin basic.asm
; Tue Sep  3 13:40:32 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=1					autorun = 1
=3					loadtest = 3
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=1					SMark_Gosub 	= 	1 							; 0 is GOSUB/RETURN.
=2					SMark_Repeat 	= 	2 							; 1 is REPEAT/UNTIL.
=3					SMark_While 	= 	3 							; 2 is WHILE/WEND.
=4					SMark_If 		= 	4 							; 3 is IF/ENDIF
=5					SMark_For 		= 	5 							; 4 is FOR/NEXT

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zTemp4: 	.word ?
>0018					zCodePtr:	.dword ? 						; code pointer (long)
>001c					zLTemp1:	.dword ?						; long word (used in multiply)
>0020					zGenPtr:	.word ? 						; general pointer.
>0022					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0024					zVarDataPtr: .word ? 						; position of variable data.
>0026					zVarType: 	.byte ? 						; type of data (token)
>0027					zNullString:.byte ? 						; represents a NULL string.
>0028					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					SignNext:	.byte ? 						; Used for keeping sign of STEP in FOR/NEXT
>03a8					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a9					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b1					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b9					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03ba					LastPrinted:.byte ? 						; last printed char ?
>03bb					ListIndent: .byte ? 						; list indent level
>03bc					LastListIndent:.byte ? 						; previous one.
>03bd					DataLPtr: 	.dword ?						; the data long ptr (swapped with zCodePtr)
>03c1					DataIndex:	.byte ?							; index position.
>03c2					InputAvailable: .byte ? 					; characters available in input buffer.
>03c3					InputRetry:	.byte ? 						; true if INPUT is retrying.
>03c4					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03c6					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03c8					Tim_SR:		.byte ? 						; Processor Status
>03c9					Tim_A:		.byte ? 						; Processor Registers
>03ca					Tim_X:		.byte ?
>03cb					Tim_Y:		.byte ?
>03cc					Tim_Z:		.byte ?
>03cd					Tim_SP:		.word ?							; Stack Pointer (just in cases)
.0400					TokeniseBuffer:
>0400								.fill 	256
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.
>05ca					BasicStack:	.fill 	256 					; and occupy whole pages.
.06ca					EndBasicStack:

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testassign.src

>1000	0c 0a 00 c7 1a 32 12 04			.byte	$0c,$0a,$00,$c7,$1a,$32,$12,$04
>1008	b8 42 be 00 0f 14 00 c7			.byte	$b8,$42,$be,$00,$0f,$14,$00,$c7
>1010	08 34 16 0b 10 bc 42 bf			.byte	$08,$34,$16,$0b,$10,$bc,$42,$bf
>1018	41 be 00 09 1e 00 c7 15			.byte	$41,$be,$00,$09,$1e,$00,$c7,$15
>1020	b8 41 be 00 0b 28 00 c7			.byte	$b8,$41,$be,$00,$0b,$28,$00,$c7
>1028	05 32 02 bd 42 be 00 0c			.byte	$05,$32,$02,$bd,$42,$be,$00,$0c
>1030	32 00 c7 04 37 13 0b b8			.byte	$32,$00,$c7,$04,$37,$13,$0b,$b8
>1038	41 be 00 0c 3c 00 c7 14			.byte	$41,$be,$00,$0c,$3c,$00,$c7,$14
>1040	35 15 10 b8 42 be 00 0d			.byte	$35,$15,$10,$b8,$42,$be,$00,$0d
>1048	46 00 c7 06 34 08 03 05			.byte	$46,$00,$c7,$06,$34,$08,$03,$05
>1050	bc 42 be 00 0c 50 00 c7			.byte	$bc,$42,$be,$00,$0c,$50,$00,$c7
>1058	05 36 14 13 bc 41 be 00			.byte	$05,$36,$14,$13,$bc,$41,$be,$00
>1060	0b 5a 00 c7 14 32 16 bd			.byte	$0b,$5a,$00,$c7,$14,$32,$16,$bd
>1068	42 be 00 0c 64 00 c7 11			.byte	$42,$be,$00,$0c,$64,$00,$c7,$11
>1070	37 09 06 b8 42 be 00 0b			.byte	$37,$09,$06,$b8,$42,$be,$00,$0b
>1078	6e 00 c7 01 35 0e b8 42			.byte	$6e,$00,$c7,$01,$35,$0e,$b8,$42
>1080	be 00 0b 78 00 c7 13 34			.byte	$be,$00,$0b,$78,$00,$c7,$13,$34
>1088	02 ba 42 be 00 13 82 00			.byte	$02,$ba,$42,$be,$00,$13,$82,$00
>1090	cf 02 39 04 0a 07 b9 84			.byte	$cf,$02,$39,$04,$0a,$07,$b9,$84
>1098	42 67 fd 05 38 37 35 00			.byte	$42,$67,$fd,$05,$38,$37,$35,$00
>10a0	11 8c 00 cf 01 b9 84 8b			.byte	$11,$8c,$00,$cf,$01,$b9,$84,$8b
>10a8	43 6f fd 06 34 33 37 35			.byte	$43,$6f,$fd,$06,$34,$33,$37,$35
>10b0	00 10 96 00 cf 04 37 10			.byte	$00,$10,$96,$00,$cf,$04,$37,$10
>10b8	84 47 5a fd 05 31 32 35			.byte	$84,$47,$5a,$fd,$05,$31,$32,$35
>10c0	00 13 a0 00 cf 05 31 19			.byte	$00,$13,$a0,$00,$cf,$05,$31,$19
>10c8	19 84 8b 44 7c fd 06 33			.byte	$19,$84,$8b,$44,$7c,$fd,$06,$33
>10d0	31 32 35 00 10 aa 00 cf			.byte	$31,$32,$35,$00,$10,$aa,$00,$cf
>10d8	18 b9 84 47 5a fd 06 33			.byte	$18,$b9,$84,$47,$5a,$fd,$06,$33
>10e0	31 32 35 00 0a b4 00 cf			.byte	$31,$32,$35,$00,$0a,$b4,$00,$cf
>10e8	13 bb 84 4b 74 00 10 be			.byte	$13,$bb,$84,$4b,$74,$00,$10,$be
>10f0	00 cf 15 30 01 84 8b 49			.byte	$00,$cf,$15,$30,$01,$84,$8b,$49
>10f8	57 fd 04 32 35 00 14 c8			.byte	$57,$fd,$04,$32,$35,$00,$14,$c8
>1100	00 cf 05 31 11 17 09 b9			.byte	$00,$cf,$05,$31,$11,$17,$09,$b9
>1108	84 8b 47 5d fd 05 36 32			.byte	$84,$8b,$47,$5d,$fd,$05,$36,$32
>1110	35 00 12 d2 00 cf 05 32			.byte	$35,$00,$12,$d2,$00,$cf,$05,$32
>1118	0f 0a 10 b9 84 45 47 fd			.byte	$0f,$0a,$10,$b9,$84,$45,$47,$fd
>1120	04 32 35 00 0f dc 00 cf			.byte	$04,$32,$35,$00,$0f,$dc,$00,$cf
>1128	0e 32 0f b9 84 47 fd 04			.byte	$0e,$32,$0f,$b9,$84,$47,$fd,$04
>1130	37 35 00 0d e6 00 cf 19			.byte	$37,$35,$00,$0d,$e6,$00,$cf,$19
>1138	30 03 14 bb 84 46 6e 00			.byte	$30,$03,$14,$bb,$84,$46,$6e,$00
>1140	14 f0 00 cf 05 32 0f 0a			.byte	$14,$f0,$00,$cf,$05,$32,$0f,$0a
>1148	10 b9 84 42 77 fd 06 38			.byte	$10,$b9,$84,$42,$77,$fd,$06,$38
>1150	31 32 35 00 0e fa 00 cf			.byte	$31,$32,$35,$00,$0e,$fa,$00,$cf
>1158	09 b7 84 fe 06 55 30 45			.byte	$09,$b7,$84,$fe,$06,$55,$30,$45
>1160	47 00 0e 04 01 cf 11 37			.byte	$47,$00,$0e,$04,$01,$cf,$11,$37
>1168	08 07 01 bb 84 41 62 00			.byte	$08,$07,$01,$bb,$84,$41,$62,$00
>1170	0e 0e 01 cf 07 b7 84 fe			.byte	$0e,$0e,$01,$cf,$07,$b7,$84,$fe
>1178	06 59 31 49 49 00 13 18			.byte	$06,$59,$31,$49,$49,$00,$13,$18
>1180	01 cf 03 32 08 07 84 8b			.byte	$01,$cf,$03,$32,$08,$07,$84,$8b
>1188	46 64 fd 06 31 38 37 35			.byte	$46,$64,$fd,$06,$31,$38,$37,$35
>1190	00 0e 22 01 cf 16 35 0a			.byte	$00,$0e,$22,$01,$cf,$16,$35,$0a
>1198	0d 0e bb 84 49 7e 00 11			.byte	$0d,$0e,$bb,$84,$49,$7e,$00,$11
>11a0	2c 01 cf 09 34 13 84 43			.byte	$2c,$01,$cf,$09,$34,$13,$84,$43
>11a8	64 fd 06 36 38 37 35 00			.byte	$64,$fd,$06,$36,$38,$37,$35,$00
>11b0	11 36 01 cf 14 34 11 15			.byte	$11,$36,$01,$cf,$14,$34,$11,$15
>11b8	84 41 40 fd 05 38 37 35			.byte	$84,$41,$40,$fd,$05,$38,$37,$35
>11c0	00 10 40 01 cf 0c 31 0b			.byte	$00,$10,$40,$01,$cf,$0c,$31,$0b
>11c8	18 0b 84 46 59 fd 03 30			.byte	$18,$0b,$84,$46,$59,$fd,$03,$30
>11d0	00 12 4a 01 cf 06 31 05			.byte	$00,$12,$4a,$01,$cf,$06,$31,$05
>11d8	10 01 b9 84 8b 41 61 fd			.byte	$10,$01,$b9,$84,$8b,$41,$61,$fd
>11e0	03 35 00 10 54 01 cf 12			.byte	$03,$35,$00,$10,$54,$01,$cf,$12
>11e8	30 14 84 8b 48 56 fd 04			.byte	$30,$14,$84,$8b,$48,$56,$fd,$04
>11f0	32 35 00 11 5e 01 cf 12			.byte	$32,$35,$00,$11,$5e,$01,$cf,$12
>11f8	30 14 84 42 40 fd 06 35			.byte	$30,$14,$84,$42,$40,$fd,$06,$35
>1200	36 32 35 00 0c 68 01 cf			.byte	$36,$32,$35,$00,$0c,$68,$01,$cf
>1208	14 30 19 bb 84 4a 79 00			.byte	$14,$30,$19,$bb,$84,$4a,$79,$00
>1210	0e 72 01 cf 04 38 10 15			.byte	$0e,$72,$01,$cf,$04,$38,$10,$15
>1218	1a bb 84 41 7f 00 13 7c			.byte	$1a,$bb,$84,$41,$7f,$00,$13,$7c
>1220	01 cf 18 32 06 0e 02 84			.byte	$01,$cf,$18,$32,$06,$0e,$02,$84
>1228	49 67 fd 06 34 33 37 35			.byte	$49,$67,$fd,$06,$34,$33,$37,$35
>1230	00 0e 86 01 cf 13 37 0a			.byte	$00,$0e,$86,$01,$cf,$13,$37,$0a
>1238	08 06 bb 84 45 55 00 10			.byte	$08,$06,$bb,$84,$45,$55,$00,$10
>1240	90 01 cf 15 33 05 b9 84			.byte	$90,$01,$cf,$15,$33,$05,$b9,$84
>1248	5e fd 05 33 37 35 00 12			.byte	$5e,$fd,$05,$33,$37,$35,$00,$12
>1250	9a 01 cf 03 32 08 07 84			.byte	$9a,$01,$cf,$03,$32,$08,$07,$84
>1258	46 79 fd 06 36 38 37 35			.byte	$46,$79,$fd,$06,$36,$38,$37,$35
>1260	00 0a a4 01 cf 03 bb 84			.byte	$00,$0a,$a4,$01,$cf,$03,$bb,$84
>1268	49 7a 00 0a ae 01 cf 0e			.byte	$49,$7a,$00,$0a,$ae,$01,$cf,$0e
>1270	bb 84 43 5b 00 0f b8 01			.byte	$bb,$84,$43,$5b,$00,$0f,$b8,$01
>1278	cf 13 37 0a 08 06 bb 84			.byte	$cf,$13,$37,$0a,$08,$06,$bb,$84
>1280	8b 45 58 00 0d c2 01 cf			.byte	$8b,$45,$58,$00,$0d,$c2,$01,$cf
>1288	0f 31 0f 02 bb 84 4b 6c			.byte	$0f,$31,$0f,$02,$bb,$84,$4b,$6c
>1290	00 12 cc 01 cf 04 36 13			.byte	$00,$12,$cc,$01,$cf,$04,$36,$13
>1298	0d b9 84 8b 43 5a fd 04			.byte	$0d,$b9,$84,$8b,$43,$5a,$fd,$04
>12a0	32 35 00 12 d6 01 cf 14			.byte	$32,$35,$00,$12,$d6,$01,$cf,$14
>12a8	37 10 84 8b 41 68 fd 06			.byte	$37,$10,$84,$8b,$41,$68,$fd,$06
>12b0	31 38 37 35 00 13 e0 01			.byte	$31,$38,$37,$35,$00,$13,$e0,$01
>12b8	cf 06 31 05 10 01 b9 84			.byte	$cf,$06,$31,$05,$10,$01,$b9,$84
>12c0	43 60 fd 05 31 32 35 00			.byte	$43,$60,$fd,$05,$31,$32,$35,$00
>12c8	13 ea 01 cf 03 32 08 07			.byte	$13,$ea,$01,$cf,$03,$32,$08,$07
>12d0	84 8b 44 53 fd 06 35 36			.byte	$84,$8b,$44,$53,$fd,$06,$35,$36
>12d8	32 35 00 12 f4 01 cf 14			.byte	$32,$35,$00,$12,$f4,$01,$cf,$14
>12e0	34 11 15 84 48 4a fd 06			.byte	$34,$11,$15,$84,$48,$4a,$fd,$06
>12e8	38 31 32 35 00 14 fe 01			.byte	$38,$31,$32,$35,$00,$14,$fe,$01
>12f0	cf 13 34 02 ba 41 be 84			.byte	$cf,$13,$34,$02,$ba,$41,$be,$84
>12f8	46 62 fd 06 35 36 32 35			.byte	$46,$62,$fd,$06,$35,$36,$32,$35
>1300	00 0a 08 02 cf 13 bb 84			.byte	$00,$0a,$08,$02,$cf,$13,$bb,$84
>1308	42 52 00 14 12 02 cf 14			.byte	$42,$52,$00,$14,$12,$02,$cf,$14
>1310	35 15 10 b8 41 be 84 fe			.byte	$35,$15,$10,$b8,$41,$be,$84,$fe
>1318	07 56 32 4d 41 4f 00 13			.byte	$07,$56,$32,$4d,$41,$4f,$00,$13
>1320	1c 02 cf 0e 36 0d b9 84			.byte	$1c,$02,$cf,$0e,$36,$0d,$b9,$84
>1328	8b 42 50 fd 06 39 33 37			.byte	$8b,$42,$50,$fd,$06,$39,$33,$37
>1330	35 00 0d 26 02 cf 14 37			.byte	$35,$00,$0d,$26,$02,$cf,$14,$37
>1338	13 07 bb 84 41 48 00 12			.byte	$13,$07,$bb,$84,$41,$48,$00,$12
>1340	30 02 cf 05 37 15 1a b9			.byte	$30,$02,$cf,$05,$37,$15,$1a,$b9
>1348	84 8b 47 7f fd 04 37 35			.byte	$84,$8b,$47,$7f,$fd,$04,$37,$35
>1350	00 10 3a 02 cf 0b 39 16			.byte	$00,$10,$3a,$02,$cf,$0b,$39,$16
>1358	19 b7 84 fe 05 4b 38 4f			.byte	$19,$b7,$84,$fe,$05,$4b,$38,$4f
>1360	00 10 44 02 cf 0c 31 0f			.byte	$00,$10,$44,$02,$cf,$0c,$31,$0f
>1368	05 84 8b 42 53 fd 03 30			.byte	$05,$84,$8b,$42,$53,$fd,$03,$30
>1370	00 0f 4e 02 cf 0a 39 01			.byte	$00,$0f,$4e,$02,$cf,$0a,$39,$01
>1378	18 0d b7 84 fe 03 56 00			.byte	$18,$0d,$b7,$84,$fe,$03,$56,$00
>1380	0c 58 02 cf 0f 31 0f 02			.byte	$0c,$58,$02,$cf,$0f,$31,$0f,$02
>1388	bb 84 6b 00 10 62 02 cf			.byte	$bb,$84,$6b,$00,$10,$62,$02,$cf
>1390	0e 32 0f b9 84 8b 45 65			.byte	$0e,$32,$0f,$b9,$84,$8b,$45,$65
>1398	fd 03 30 00 11 6c 02 cf			.byte	$fd,$03,$30,$00,$11,$6c,$02,$cf
>13a0	06 35 06 0f 18 84 8b 49			.byte	$06,$35,$06,$0f,$18,$84,$8b,$49
>13a8	69 fd 03 30 00 14 76 02			.byte	$69,$fd,$03,$30,$00,$14,$76,$02
>13b0	cf 05 37 15 1a b9 84 8b			.byte	$cf,$05,$37,$15,$1a,$b9,$84,$8b
>13b8	41 46 fd 06 36 38 37 35			.byte	$41,$46,$fd,$06,$36,$38,$37,$35
>13c0	00 10 80 02 cf 15 b8 40			.byte	$00,$10,$80,$02,$cf,$15,$b8,$40
>13c8	be 84 fe 06 56 33 47 4d			.byte	$be,$84,$fe,$06,$56,$33,$47,$4d
>13d0	00 11 8a 02 cf 0a 39 01			.byte	$00,$11,$8a,$02,$cf,$0a,$39,$01
>13d8	18 0d b7 84 fe 05 50 37			.byte	$18,$0d,$b7,$84,$fe,$05,$50,$37
>13e0	51 00 0d 94 02 cf 04 39			.byte	$51,$00,$0d,$94,$02,$cf,$04,$39
>13e8	19 bb 84 8b 46 78 00 10			.byte	$19,$bb,$84,$8b,$46,$78,$00,$10
>13f0	9e 02 cf 04 37 10 84 8b			.byte	$9e,$02,$cf,$04,$37,$10,$84,$8b
>13f8	55 fd 05 31 32 35 00 13			.byte	$55,$fd,$05,$31,$32,$35,$00,$13
>1400	a8 02 cf 07 32 08 04 19			.byte	$a8,$02,$cf,$07,$32,$08,$04,$19
>1408	84 8b 44 79 fd 05 36 32			.byte	$84,$8b,$44,$79,$fd,$05,$36,$32
>1410	35 00 13 b2 02 cf 1a 32			.byte	$35,$00,$13,$b2,$02,$cf,$1a,$32
>1418	12 04 b8 41 be 84 fe 06			.byte	$12,$04,$b8,$41,$be,$84,$fe,$06
>1420	4b 36 47 53 00 0f bc 02			.byte	$4b,$36,$47,$53,$00,$0f,$bc,$02
>1428	cf 0c 36 19 b7 84 fe 05			.byte	$cf,$0c,$36,$19,$b7,$84,$fe,$05
>1430	4d 36 46 00 0a c6 02 cf			.byte	$4d,$36,$46,$00,$0a,$c6,$02,$cf
>1438	03 bb 84 49 46 00 14 d0			.byte	$03,$bb,$84,$49,$46,$00,$14,$d0
>1440	02 cf 19 32 13 05 0b 84			.byte	$02,$cf,$19,$32,$13,$05,$0b,$84
>1448	8b 47 5d fd 06 30 36 32			.byte	$8b,$47,$5d,$fd,$06,$30,$36,$32
>1450	35 00 14 da 02 cf 15 35			.byte	$35,$00,$14,$da,$02,$cf,$15,$35
>1458	14 03 11 84 8b 44 51 fd			.byte	$14,$03,$11,$84,$8b,$44,$51,$fd
>1460	06 31 38 37 35 00 11 e4			.byte	$06,$31,$38,$37,$35,$00,$11,$e4
>1468	02 cf 06 34 08 03 05 bc			.byte	$02,$cf,$06,$34,$08,$03,$05,$bc
>1470	41 be 84 8b 43 51 00 0d			.byte	$41,$be,$84,$8b,$43,$51,$00,$0d
>1478	ee 02 cf 14 30 19 bb 84			.byte	$ee,$02,$cf,$14,$30,$19,$bb,$84
>1480	8b 43 43 00 14 f8 02 cf			.byte	$8b,$43,$43,$00,$14,$f8,$02,$cf
>1488	0e 30 0b 0e 01 84 8b 42			.byte	$0e,$30,$0b,$0e,$01,$84,$8b,$42
>1490	6f fd 06 33 31 32 35 00			.byte	$6f,$fd,$06,$33,$31,$32,$35,$00
>1498	13 02 03 cf 05 38 03 04			.byte	$13,$02,$03,$cf,$05,$38,$03,$04
>14a0	17 b7 84 fe 07 58 33 4d			.byte	$17,$b7,$84,$fe,$07,$58,$33,$4d
>14a8	4c 48 00 0e 0c 03 cf 0d			.byte	$4c,$48,$00,$0e,$0c,$03,$cf,$0d
>14b0	31 14 13 bb 84 8b 49 5e			.byte	$31,$14,$13,$bb,$84,$8b,$49,$5e
>14b8	00 11 16 03 cf 0e 39 09			.byte	$00,$11,$16,$03,$cf,$0e,$39,$09
>14c0	b7 84 fe 07 4d 30 59 53			.byte	$b7,$84,$fe,$07,$4d,$30,$59,$53
>14c8	5a 00 0f 20 03 cf 09 b7			.byte	$5a,$00,$0f,$20,$03,$cf,$09,$b7
>14d0	84 fe 07 51 36 59 58 51			.byte	$84,$fe,$07,$51,$36,$59,$58,$51
>14d8	00 0f 2a 03 cf 13 31 0c			.byte	$00,$0f,$2a,$03,$cf,$13,$31,$0c
>14e0	04 b7 84 fe 04 56 33 00			.byte	$04,$b7,$84,$fe,$04,$56,$33,$00
>14e8	12 34 03 cf 05 38 03 04			.byte	$12,$34,$03,$cf,$05,$38,$03,$04
>14f0	17 b7 84 fe 06 43 34 4a			.byte	$17,$b7,$84,$fe,$06,$43,$34,$4a
>14f8	4f 00 10 3e 03 cf 12 30			.byte	$4f,$00,$10,$3e,$03,$cf,$12,$30
>1500	14 84 8b 48 6a fd 04 32			.byte	$14,$84,$8b,$48,$6a,$fd,$04,$32
>1508	35 00 12 48 03 cf 06 33			.byte	$35,$00,$12,$48,$03,$cf,$06,$33
>1510	01 12 0c b9 84 4d fd 05			.byte	$01,$12,$0c,$b9,$84,$4d,$fd,$05
>1518	33 37 35 00 0b 52 03 cf			.byte	$33,$37,$35,$00,$0b,$52,$03,$cf
>1520	13 bb 84 8b 46 6f 00 0f			.byte	$13,$bb,$84,$8b,$46,$6f,$00,$0f
>1528	5c 03 cf 08 33 08 09 84			.byte	$5c,$03,$cf,$08,$33,$08,$09,$84
>1530	49 6c fd 03 35 00 0f 66			.byte	$49,$6c,$fd,$03,$35,$00,$0f,$66
>1538	03 cf 11 84 48 7f fd 06			.byte	$03,$cf,$11,$84,$48,$7f,$fd,$06
>1540	36 38 37 35 00 11 70 03			.byte	$36,$38,$37,$35,$00,$11,$70,$03
>1548	cf 13 31 0c 04 b7 84 fe			.byte	$cf,$13,$31,$0c,$04,$b7,$84,$fe
>1550	06 4a 39 52 48 00 0e 7a			.byte	$06,$4a,$39,$52,$48,$00,$0e,$7a
>1558	03 cf 01 36 09 06 84 49			.byte	$03,$cf,$01,$36,$09,$06,$84,$49
>1560	fd 03 30 00 0e 84 03 cf			.byte	$fd,$03,$30,$00,$0e,$84,$03,$cf
>1568	03 37 17 19 b7 84 fe 03			.byte	$03,$37,$17,$19,$b7,$84,$fe,$03
>1570	49 00 0e 8e 03 cf 18 b9			.byte	$49,$00,$0e,$8e,$03,$cf,$18,$b9
>1578	84 49 6c fd 04 32 35 00			.byte	$84,$49,$6c,$fd,$04,$32,$35,$00
>1580	0e 98 03 cf 04 38 10 15			.byte	$0e,$98,$03,$cf,$04,$38,$10,$15
>1588	1a bb 84 4e 69 00 10 a2			.byte	$1a,$bb,$84,$4e,$69,$00,$10,$a2
>1590	03 cf 12 84 8b 48 5e fd			.byte	$03,$cf,$12,$84,$8b,$48,$5e,$fd
>1598	06 36 38 37 35 00 0f ac			.byte	$06,$36,$38,$37,$35,$00,$0f,$ac
>15a0	03 cf 05 36 14 13 bc 40			.byte	$03,$cf,$05,$36,$14,$13,$bc,$40
>15a8	be 84 4c 59 00 15 b6 03			.byte	$be,$84,$4c,$59,$00,$15,$b6,$03
>15b0	cf 05 31 11 17 09 b9 84			.byte	$cf,$05,$31,$11,$17,$09,$b9,$84
>15b8	8b 46 40 fd 06 35 36 32			.byte	$8b,$46,$40,$fd,$06,$35,$36,$32
>15c0	35 00 12 c0 03 cf 08 38			.byte	$35,$00,$12,$c0,$03,$cf,$08,$38
>15c8	13 0c b9 84 42 48 fd 05			.byte	$13,$0c,$b9,$84,$42,$48,$fd,$05
>15d0	38 37 35 00 10 ca 03 cf			.byte	$38,$37,$35,$00,$10,$ca,$03,$cf
>15d8	14 b9 84 8b 41 68 fd 05			.byte	$14,$b9,$84,$8b,$41,$68,$fd,$05
>15e0	36 32 35 00 13 d4 03 cf			.byte	$36,$32,$35,$00,$13,$d4,$03,$cf
>15e8	1a 31 18 03 16 b9 84 47			.byte	$1a,$31,$18,$03,$16,$b9,$84,$47
>15f0	63 fd 05 38 37 35 00 0e			.byte	$63,$fd,$05,$38,$37,$35,$00,$0e
>15f8	de 03 cf 19 30 03 14 bb			.byte	$de,$03,$cf,$19,$30,$03,$14,$bb
>1600	84 8b 4c 49 00 11 e8 03			.byte	$84,$8b,$4c,$49,$00,$11,$e8,$03
>1608	cf 15 30 01 84 42 73 fd			.byte	$cf,$15,$30,$01,$84,$42,$73,$fd
>1610	06 39 33 37 35 00 10 f2			.byte	$06,$39,$33,$37,$35,$00,$10,$f2
>1618	03 cf 14 b9 84 8b 43 6c			.byte	$03,$cf,$14,$b9,$84,$8b,$43,$6c
>1620	fd 05 36 32 35 00 11 fc			.byte	$fd,$05,$36,$32,$35,$00,$11,$fc
>1628	03 cf 01 36 09 06 84 44			.byte	$03,$cf,$01,$36,$09,$06,$84,$44
>1630	5b fd 05 31 32 35 00 13			.byte	$5b,$fd,$05,$31,$32,$35,$00,$13
>1638	06 04 cf 05 37 15 1a b9			.byte	$06,$04,$cf,$05,$37,$15,$1a,$b9
>1640	84 8b 44 6c fd 05 38 37			.byte	$84,$8b,$44,$6c,$fd,$05,$38,$37
>1648	35 00 0d 10 04 cf 13 31			.byte	$35,$00,$0d,$10,$04,$cf,$13,$31
>1650	0c 04 b7 84 fe 02 00 10			.byte	$0c,$04,$b7,$84,$fe,$02,$00,$10
>1658	1a 04 cf 0c 31 0f 05 84			.byte	$1a,$04,$cf,$0c,$31,$0f,$05,$84
>1660	8b 46 59 fd 03 35 00 12			.byte	$8b,$46,$59,$fd,$03,$35,$00,$12
>1668	24 04 cf 0c 31 0f 05 84			.byte	$24,$04,$cf,$0c,$31,$0f,$05,$84
>1670	49 64 fd 06 35 36 32 35			.byte	$49,$64,$fd,$06,$35,$36,$32,$35
>1678	00 0f 2e 04 cf 0c 36 19			.byte	$00,$0f,$2e,$04,$cf,$0c,$36,$19
>1680	b7 84 fe 05 56 39 55 00			.byte	$b7,$84,$fe,$05,$56,$39,$55,$00
>1688	11 38 04 cf 05 36 01 06			.byte	$11,$38,$04,$cf,$05,$36,$01,$06
>1690	0b 84 8b 46 7e fd 03 35			.byte	$0b,$84,$8b,$46,$7e,$fd,$03,$35
>1698	00 12 42 04 cf 19 32 13			.byte	$00,$12,$42,$04,$cf,$19,$32,$13
>16a0	05 0b 84 8b 47 5c fd 04			.byte	$05,$0b,$84,$8b,$47,$5c,$fd,$04
>16a8	32 35 00 12 4c 04 cf 08			.byte	$32,$35,$00,$12,$4c,$04,$cf,$08
>16b0	34 16 0b 10 bc 40 bf 40			.byte	$34,$16,$0b,$10,$bc,$40,$bf,$40
>16b8	be 84 49 70 00 12 56 04			.byte	$be,$84,$49,$70,$00,$12,$56,$04
>16c0	cf 0e 32 0f b9 84 49 40			.byte	$cf,$0e,$32,$0f,$b9,$84,$49,$40
>16c8	fd 06 36 38 37 35 00 0b			.byte	$fd,$06,$36,$38,$37,$35,$00,$0b
>16d0	60 04 cf 19 bb 84 8b 48			.byte	$60,$04,$cf,$19,$bb,$84,$8b,$48
>16d8	73 00 0f 6a 04 cf 0b 39			.byte	$73,$00,$0f,$6a,$04,$cf,$0b,$39
>16e0	16 19 b7 84 fe 04 4d 33			.byte	$16,$19,$b7,$84,$fe,$04,$4d,$33
>16e8	00 0f 74 04 cf 10 32 1a			.byte	$00,$0f,$74,$04,$cf,$10,$32,$1a
>16f0	03 b7 84 fe 04 52 34 00			.byte	$03,$b7,$84,$fe,$04,$52,$34,$00
>16f8	0e 7e 04 cf 0c 36 19 b7			.byte	$0e,$7e,$04,$cf,$0c,$36,$19,$b7
>1700	84 fe 04 58 34 00 0e 88			.byte	$84,$fe,$04,$58,$34,$00,$0e,$88
>1708	04 cf 0b 36 08 0e 19 bb			.byte	$04,$cf,$0b,$36,$08,$0e,$19,$bb
>1710	84 4b 45 00 0d 92 04 cf			.byte	$84,$4b,$45,$00,$0d,$92,$04,$cf
>1718	1a 38 03 09 bb 84 41 7d			.byte	$1a,$38,$03,$09,$bb,$84,$41,$7d
>1720	00 12 9c 04 cf 14 35 15			.byte	$00,$12,$9c,$04,$cf,$14,$35,$15
>1728	10 b8 42 be 84 fe 05 44			.byte	$10,$b8,$42,$be,$84,$fe,$05,$44
>1730	37 4f 00 11 a6 04 cf 15			.byte	$37,$4f,$00,$11,$a6,$04,$cf,$15
>1738	33 05 b9 84 8b 5c fd 05			.byte	$33,$05,$b9,$84,$8b,$5c,$fd,$05
>1740	33 37 35 00 12 b0 04 cf			.byte	$33,$37,$35,$00,$12,$b0,$04,$cf
>1748	0c 31 0f 05 84 43 64 fd			.byte	$0c,$31,$0f,$05,$84,$43,$64,$fd
>1750	06 35 36 32 35 00 13 ba			.byte	$06,$35,$36,$32,$35,$00,$13,$ba
>1758	04 cf 15 35 14 03 11 84			.byte	$04,$cf,$15,$35,$14,$03,$11,$84
>1760	47 5b fd 06 33 31 32 35			.byte	$47,$5b,$fd,$06,$33,$31,$32,$35
>1768	00 0e c4 04 cf 13 37 0a			.byte	$00,$0e,$c4,$04,$cf,$13,$37,$0a
>1770	08 06 bb 84 46 40 00 14			.byte	$08,$06,$bb,$84,$46,$40,$00,$14
>1778	ce 04 cf 05 37 15 1a b9			.byte	$ce,$04,$cf,$05,$37,$15,$1a,$b9
>1780	84 8b 41 44 fd 06 35 36			.byte	$84,$8b,$41,$44,$fd,$06,$35,$36
>1788	32 35 00 0a d8 04 cf 0e			.byte	$32,$35,$00,$0a,$d8,$04,$cf,$0e
>1790	bb 84 42 7c 00 11 e2 04			.byte	$bb,$84,$42,$7c,$00,$11,$e2,$04
>1798	cf 15 b8 40 be 84 fe 07			.byte	$cf,$15,$b8,$40,$be,$84,$fe,$07
>17a0	4b 32 54 42 41 00 11 ec			.byte	$4b,$32,$54,$42,$41,$00,$11,$ec
>17a8	04 cf 0c 31 0f 05 84 44			.byte	$04,$cf,$0c,$31,$0f,$05,$84,$44
>17b0	55 fd 05 31 32 35 00 10			.byte	$55,$fd,$05,$31,$32,$35,$00,$10
>17b8	f6 04 cf 12 30 14 84 49			.byte	$f6,$04,$cf,$12,$30,$14,$84,$49
>17c0	58 fd 05 36 32 35 00 11			.byte	$58,$fd,$05,$36,$32,$35,$00,$11
>17c8	00 05 cf 08 33 08 09 84			.byte	$00,$05,$cf,$08,$33,$08,$09,$84
>17d0	8b 43 43 fd 04 37 35 00			.byte	$8b,$43,$43,$fd,$04,$37,$35,$00
>17d8	0e 0a 05 cf 03 34 08 b7			.byte	$0e,$0a,$05,$cf,$03,$34,$08,$b7
>17e0	84 fe 04 51 31 00 12 14			.byte	$84,$fe,$04,$51,$31,$00,$12,$14
>17e8	05 cf 08 33 08 09 84 8b			.byte	$05,$cf,$08,$33,$08,$09,$84,$8b
>17f0	46 4f fd 05 33 37 35 00			.byte	$46,$4f,$fd,$05,$33,$37,$35,$00
>17f8	0d 1e 05 cf 1a 38 03 09			.byte	$0d,$1e,$05,$cf,$1a,$38,$03,$09
>1800	bb 84 4e 6a 00 10 28 05			.byte	$bb,$84,$4e,$6a,$00,$10,$28,$05
>1808	cf 0d 34 11 0d b7 84 fe			.byte	$cf,$0d,$34,$11,$0d,$b7,$84,$fe
>1810	05 42 39 44 00 10 32 05			.byte	$05,$42,$39,$44,$00,$10,$32,$05
>1818	cf 05 36 14 13 bc 40 be			.byte	$cf,$05,$36,$14,$13,$bc,$40,$be
>1820	84 8b 43 79 00 0d 3c 05			.byte	$84,$8b,$43,$79,$00,$0d,$3c,$05
>1828	cf 01 31 05 bb 84 8b 44			.byte	$cf,$01,$31,$05,$bb,$84,$8b,$44
>1830	7d 00 10 46 05 cf 08 38			.byte	$7d,$00,$10,$46,$05,$cf,$08,$38
>1838	13 0c b9 84 42 49 fd 03			.byte	$13,$0c,$b9,$84,$42,$49,$fd,$03
>1840	30 00 0d 50 05 cf 19 30			.byte	$30,$00,$0d,$50,$05,$cf,$19,$30
>1848	03 14 bb 84 43 60 00 0e			.byte	$03,$14,$bb,$84,$43,$60,$00,$0e
>1850	5a 05 cf 0a 35 11 19 b7			.byte	$5a,$05,$cf,$0a,$35,$11,$19,$b7
>1858	84 fe 03 41 00 14 64 05			.byte	$84,$fe,$03,$41,$00,$14,$64,$05
>1860	cf 05 31 11 17 09 b9 84			.byte	$cf,$05,$31,$11,$17,$09,$b9,$84
>1868	8b 43 54 fd 05 33 37 35			.byte	$8b,$43,$54,$fd,$05,$33,$37,$35
>1870	00 0f 6e 05 cf 18 30 01			.byte	$00,$0f,$6e,$05,$cf,$18,$30,$01
>1878	11 0b b7 84 fe 03 56 00			.byte	$11,$0b,$b7,$84,$fe,$03,$56,$00
>1880	0f 78 05 cf 01 35 0e b8			.byte	$0f,$78,$05,$cf,$01,$35,$0e,$b8
>1888	42 be 84 fe 03 47 00 11			.byte	$42,$be,$84,$fe,$03,$47,$00,$11
>1890	82 05 cf 0a 38 07 b7 84			.byte	$82,$05,$cf,$0a,$38,$07,$b7,$84
>1898	fe 07 4e 33 57 5a 45 00			.byte	$fe,$07,$4e,$33,$57,$5a,$45,$00
>18a0	12 8c 05 cf 04 37 13 0b			.byte	$12,$8c,$05,$cf,$04,$37,$13,$0b
>18a8	b8 41 be 84 fe 05 59 32			.byte	$b8,$41,$be,$84,$fe,$05,$59,$32
>18b0	4b 00 13 96 05 cf 07 32			.byte	$4b,$00,$13,$96,$05,$cf,$07,$32
>18b8	08 04 19 84 8b 45 7a fd			.byte	$08,$04,$19,$84,$8b,$45,$7a,$fd
>18c0	05 33 37 35 00 11 a0 05			.byte	$05,$33,$37,$35,$00,$11,$a0,$05
>18c8	cf 02 39 05 18 0d b7 84			.byte	$cf,$02,$39,$05,$18,$0d,$b7,$84
>18d0	fe 05 4c 34 48 00 0f aa			.byte	$fe,$05,$4c,$34,$48,$00,$0f,$aa
>18d8	05 cf 13 35 14 1a 0d bb			.byte	$05,$cf,$13,$35,$14,$1a,$0d,$bb
>18e0	84 8b 4c 6d 00 0d b4 05			.byte	$84,$8b,$4c,$6d,$00,$0d,$b4,$05
>18e8	cf 01 31 05 bb 84 8b 4a			.byte	$cf,$01,$31,$05,$bb,$84,$8b,$4a
>18f0	4c 00 14 be 05 cf 06 35			.byte	$4c,$00,$14,$be,$05,$cf,$06,$35
>18f8	06 0f 18 84 8b 47 55 fd			.byte	$06,$0f,$18,$84,$8b,$47,$55,$fd
>1900	06 31 38 37 35 00 13 c8			.byte	$06,$31,$38,$37,$35,$00,$13,$c8
>1908	05 cf 13 34 02 ba 40 be			.byte	$05,$cf,$13,$34,$02,$ba,$40,$be
>1910	84 48 fd 06 33 31 32 35			.byte	$84,$48,$fd,$06,$33,$31,$32,$35
>1918	00 12 d2 05 cf 09 34 13			.byte	$00,$12,$d2,$05,$cf,$09,$34,$13
>1920	84 8b 42 50 fd 06 39 33			.byte	$84,$8b,$42,$50,$fd,$06,$39,$33
>1928	37 35 00 11 dc 05 cf 0b			.byte	$37,$35,$00,$11,$dc,$05,$cf,$0b
>1930	39 16 19 b7 84 fe 06 4b			.byte	$39,$16,$19,$b7,$84,$fe,$06,$4b
>1938	37 56 46 00 13 e6 05 cf			.byte	$37,$56,$46,$00,$13,$e6,$05,$cf
>1940	15 33 05 b9 84 8b 41 70			.byte	$15,$33,$05,$b9,$84,$8b,$41,$70
>1948	fd 06 35 36 32 35 00 0b			.byte	$fd,$06,$35,$36,$32,$35,$00,$0b
>1950	f0 05 cf 19 bb 84 8b 49			.byte	$f0,$05,$cf,$19,$bb,$84,$8b,$49
>1958	40 00 10 fa 05 cf 13 31			.byte	$40,$00,$10,$fa,$05,$cf,$13,$31
>1960	0c 04 b7 84 fe 05 45 31			.byte	$0c,$04,$b7,$84,$fe,$05,$45,$31
>1968	57 00 0d 04 06 cf 1a b7			.byte	$57,$00,$0d,$04,$06,$cf,$1a,$b7
>1970	84 fe 05 4d 35 52 00 11			.byte	$84,$fe,$05,$4d,$35,$52,$00,$11
>1978	0e 06 cf 18 32 06 0e 02			.byte	$0e,$06,$cf,$18,$32,$06,$0e,$02
>1980	84 8b 46 6c fd 03 30 00			.byte	$84,$8b,$46,$6c,$fd,$03,$30,$00
>1988	0e 18 06 cf 05 33 16 04			.byte	$0e,$18,$06,$cf,$05,$33,$16,$04
>1990	0b bb 84 4a 4a 00 0f 22			.byte	$0b,$bb,$84,$4a,$4a,$00,$0f,$22
>1998	06 cf 18 b9 84 8b 41 69			.byte	$06,$cf,$18,$b9,$84,$8b,$41,$69
>19a0	fd 04 37 35 00 10 2c 06			.byte	$fd,$04,$37,$35,$00,$10,$2c,$06
>19a8	cf 05 36 14 13 bc 41 be			.byte	$cf,$05,$36,$14,$13,$bc,$41,$be
>19b0	84 8b 48 58 00 13 36 06			.byte	$84,$8b,$48,$58,$00,$13,$36,$06
>19b8	cf 11 34 0d 03 b9 84 8b			.byte	$cf,$11,$34,$0d,$03,$b9,$84,$8b
>19c0	43 47 fd 05 33 37 35 00			.byte	$43,$47,$fd,$05,$33,$37,$35,$00
>19c8	14 40 06 cf 04 34 1a 12			.byte	$14,$40,$06,$cf,$04,$34,$1a,$12
>19d0	0a b9 84 43 71 fd 06 38			.byte	$0a,$b9,$84,$43,$71,$fd,$06,$38
>19d8	31 32 35 00 12 4a 06 cf			.byte	$31,$32,$35,$00,$12,$4a,$06,$cf
>19e0	02 39 04 0a 07 b9 84 41			.byte	$02,$39,$04,$0a,$07,$b9,$84,$41
>19e8	7b fd 04 32 35 00 0c 54			.byte	$7b,$fd,$04,$32,$35,$00,$0c,$54
>19f0	06 cf 0a 30 03 bb 84 8b			.byte	$06,$cf,$0a,$30,$03,$bb,$84,$8b
>19f8	5a 00 0f 5e 06 cf 06 39			.byte	$5a,$00,$0f,$5e,$06,$cf,$06,$39
>1a00	13 84 8b 5d fd 04 32 35			.byte	$13,$84,$8b,$5d,$fd,$04,$32,$35
>1a08	00 0d 68 06 cf 14 30 19			.byte	$00,$0d,$68,$06,$cf,$14,$30,$19
>1a10	bb 84 8b 4a 6d 00 0e 72			.byte	$bb,$84,$8b,$4a,$6d,$00,$0e,$72
>1a18	06 cf 16 35 0a 0d 0e bb			.byte	$06,$cf,$16,$35,$0a,$0d,$0e,$bb
>1a20	84 42 44 00 10 7c 06 cf			.byte	$84,$42,$44,$00,$10,$7c,$06,$cf
>1a28	14 b9 84 44 55 fd 06 33			.byte	$14,$b9,$84,$44,$55,$fd,$06,$33
>1a30	31 32 35 00 0e 86 06 cf			.byte	$31,$32,$35,$00,$0e,$86,$06,$cf
>1a38	11 37 08 07 01 bb 84 48			.byte	$11,$37,$08,$07,$01,$bb,$84,$48
>1a40	4f 00 0f 90 06 cf 15 b8			.byte	$4f,$00,$0f,$90,$06,$cf,$15,$b8
>1a48	41 be 84 fe 05 4d 31 4a			.byte	$41,$be,$84,$fe,$05,$4d,$31,$4a
>1a50	00 10 9a 06 cf 0b 39 16			.byte	$00,$10,$9a,$06,$cf,$0b,$39,$16
>1a58	19 b7 84 fe 05 56 36 50			.byte	$19,$b7,$84,$fe,$05,$56,$36,$50
>1a60	00 11 a4 06 cf 15 30 01			.byte	$00,$11,$a4,$06,$cf,$15,$30,$01
>1a68	84 48 78 fd 06 35 36 32			.byte	$84,$48,$78,$fd,$06,$35,$36,$32
>1a70	35 00 13 ae 06 cf 11 34			.byte	$35,$00,$13,$ae,$06,$cf,$11,$34
>1a78	0d 03 b9 84 43 64 fd 06			.byte	$0d,$03,$b9,$84,$43,$64,$fd,$06
>1a80	39 33 37 35 00 0d b8 06			.byte	$39,$33,$37,$35,$00,$0d,$b8,$06
>1a88	cf 17 31 03 bb 84 8b 49			.byte	$cf,$17,$31,$03,$bb,$84,$8b,$49
>1a90	78 00 13 c2 06 cf 08 34			.byte	$78,$00,$13,$c2,$06,$cf,$08,$34
>1a98	16 0b 10 bc 40 bf 41 be			.byte	$16,$0b,$10,$bc,$40,$bf,$41,$be
>1aa0	84 8b 45 67 00 11 cc 06			.byte	$84,$8b,$45,$67,$00,$11,$cc,$06
>1aa8	cf 08 38 13 0c b9 84 8b			.byte	$cf,$08,$38,$13,$0c,$b9,$84,$8b
>1ab0	41 5b fd 03 35 00 0b d6			.byte	$41,$5b,$fd,$03,$35,$00,$0b,$d6
>1ab8	06 cf 17 b7 84 fe 03 41			.byte	$06,$cf,$17,$b7,$84,$fe,$03,$41
>1ac0	00 0f e0 06 cf 08 33 08			.byte	$00,$0f,$e0,$06,$cf,$08,$33,$08
>1ac8	09 84 4d fd 04 37 35 00			.byte	$09,$84,$4d,$fd,$04,$37,$35,$00
>1ad0	12 ea 06 cf 0a 35 11 19			.byte	$12,$ea,$06,$cf,$0a,$35,$11,$19
>1ad8	b7 84 fe 07 42 32 44 4e			.byte	$b7,$84,$fe,$07,$42,$32,$44,$4e
>1ae0	50 00 12 f4 06 cf 15 35			.byte	$50,$00,$12,$f4,$06,$cf,$15,$35
>1ae8	14 03 11 84 41 78 fd 05			.byte	$14,$03,$11,$84,$41,$78,$fd,$05
>1af0	31 32 35 00 11 fe 06 cf			.byte	$31,$32,$35,$00,$11,$fe,$06,$cf
>1af8	06 34 08 03 05 bc 41 be			.byte	$06,$34,$08,$03,$05,$bc,$41,$be
>1b00	84 8b 46 6b 00 13 08 07			.byte	$84,$8b,$46,$6b,$00,$13,$08,$07
>1b08	cf 08 34 16 0b 10 bc 40			.byte	$cf,$08,$34,$16,$0b,$10,$bc,$40
>1b10	bf 40 be 84 8b 45 49 00			.byte	$bf,$40,$be,$84,$8b,$45,$49,$00
>1b18	12 12 07 cf 05 37 15 1a			.byte	$12,$12,$07,$cf,$05,$37,$15,$1a
>1b20	b9 84 77 fd 06 30 36 32			.byte	$b9,$84,$77,$fd,$06,$30,$36,$32
>1b28	35 00 11 1c 07 cf 04 37			.byte	$35,$00,$11,$1c,$07,$cf,$04,$37
>1b30	13 0b b8 40 be 84 fe 04			.byte	$13,$0b,$b8,$40,$be,$84,$fe,$04
>1b38	4a 32 00 12 26 07 cf 07			.byte	$4a,$32,$00,$12,$26,$07,$cf,$07
>1b40	32 08 04 19 84 47 6a fd			.byte	$32,$08,$04,$19,$84,$47,$6a,$fd
>1b48	05 33 37 35 00 0f 30 07			.byte	$05,$33,$37,$35,$00,$0f,$30,$07
>1b50	cf 05 36 14 13 bc 41 be			.byte	$cf,$05,$36,$14,$13,$bc,$41,$be
>1b58	84 4a 7f 00 13 3a 07 cf			.byte	$84,$4a,$7f,$00,$13,$3a,$07,$cf
>1b60	14 35 15 10 b8 42 be 84			.byte	$14,$35,$15,$10,$b8,$42,$be,$84
>1b68	fe 06 44 37 4c 46 00 0a			.byte	$fe,$06,$44,$37,$4c,$46,$00,$0a
>1b70	44 07 cf 09 b7 84 fe 02			.byte	$44,$07,$cf,$09,$b7,$84,$fe,$02
>1b78	00 0b 4e 07 cf 19 bb 84			.byte	$00,$0b,$4e,$07,$cf,$19,$bb,$84
>1b80	8b 4a 48 00 10 58 07 cf			.byte	$8b,$4a,$48,$00,$10,$58,$07,$cf
>1b88	06 34 08 03 05 bc 40 be			.byte	$06,$34,$08,$03,$05,$bc,$40,$be
>1b90	84 4b 74 00 15 62 07 cf			.byte	$84,$4b,$74,$00,$15,$62,$07,$cf
>1b98	05 32 0f 0a 10 b9 84 8b			.byte	$05,$32,$0f,$0a,$10,$b9,$84,$8b
>1ba0	46 61 fd 06 30 36 32 35			.byte	$46,$61,$fd,$06,$30,$36,$32,$35
>1ba8	00 0b 6c 07 cf 0e bb 84			.byte	$00,$0b,$6c,$07,$cf,$0e,$bb,$84
>1bb0	8b 49 40 00 11 76 07 cf			.byte	$8b,$49,$40,$00,$11,$76,$07,$cf
>1bb8	17 39 15 02 11 b7 84 fe			.byte	$17,$39,$15,$02,$11,$b7,$84,$fe
>1bc0	05 4a 30 43 00 10 80 07			.byte	$05,$4a,$30,$43,$00,$10,$80,$07
>1bc8	cf 05 38 10 b9 84 47 77			.byte	$cf,$05,$38,$10,$b9,$84,$47,$77
>1bd0	fd 04 37 35 00 13 8a 07			.byte	$fd,$04,$37,$35,$00,$13,$8a,$07
>1bd8	cf 15 33 05 b9 84 8b 43			.byte	$cf,$15,$33,$05,$b9,$84,$8b,$43
>1be0	44 fd 06 39 33 37 35 00			.byte	$44,$fd,$06,$39,$33,$37,$35,$00
>1be8	0e 94 07 cf 14 37 13 07			.byte	$0e,$94,$07,$cf,$14,$37,$13,$07
>1bf0	bb 84 8b 44 78 00 0d 9e			.byte	$bb,$84,$8b,$44,$78,$00,$0d,$9e
>1bf8	07 cf 04 39 19 bb 84 8b			.byte	$07,$cf,$04,$39,$19,$bb,$84,$8b
>1c00	42 71 00 0e a8 07 cf 0b			.byte	$42,$71,$00,$0e,$a8,$07,$cf,$0b
>1c08	36 08 0e 19 bb 84 42 5e			.byte	$36,$08,$0e,$19,$bb,$84,$42,$5e
>1c10	00 12 b2 07 cf 14 37 10			.byte	$00,$12,$b2,$07,$cf,$14,$37,$10
>1c18	84 8b 42 72 fd 06 38 31			.byte	$84,$8b,$42,$72,$fd,$06,$38,$31
>1c20	32 35 00 12 bc 07 cf 01			.byte	$32,$35,$00,$12,$bc,$07,$cf,$01
>1c28	35 0e b8 42 be 84 fe 06			.byte	$35,$0e,$b8,$42,$be,$84,$fe,$06
>1c30	56 38 4a 54 00 13 c6 07			.byte	$56,$38,$4a,$54,$00,$13,$c6,$07
>1c38	cf 03 32 08 07 84 8b 45			.byte	$cf,$03,$32,$08,$07,$84,$8b,$45
>1c40	41 fd 06 36 38 37 35 00			.byte	$41,$fd,$06,$36,$38,$37,$35,$00
>1c48	10 d0 07 cf 11 84 8b 43			.byte	$10,$d0,$07,$cf,$11,$84,$8b,$43
>1c50	5e fd 06 33 31 32 35 00			.byte	$5e,$fd,$06,$33,$31,$32,$35,$00
>1c58	12 da 07 cf 1a 31 18 03			.byte	$12,$da,$07,$cf,$1a,$31,$18,$03
>1c60	16 b9 84 8b 45 52 fd 03			.byte	$16,$b9,$84,$8b,$45,$52,$fd,$03
>1c68	35 00 0e e4 07 cf 18 b9			.byte	$35,$00,$0e,$e4,$07,$cf,$18,$b9
>1c70	84 8b 48 49 fd 03 30 00			.byte	$84,$8b,$48,$49,$fd,$03,$30,$00
>1c78	10 ee 07 cf 04 37 10 84			.byte	$10,$ee,$07,$cf,$04,$37,$10,$84
>1c80	41 6e fd 05 31 32 35 00			.byte	$41,$6e,$fd,$05,$31,$32,$35,$00
>1c88	13 f8 07 cf 05 31 11 17			.byte	$13,$f8,$07,$cf,$05,$31,$11,$17
>1c90	09 b9 84 41 43 fd 05 31			.byte	$09,$b9,$84,$41,$43,$fd,$05,$31
>1c98	32 35 00 11 02 08 cf 15			.byte	$32,$35,$00,$11,$02,$08,$cf,$15
>1ca0	33 05 b9 84 8b 79 fd 05			.byte	$33,$05,$b9,$84,$8b,$79,$fd,$05
>1ca8	36 32 35 00 0f 0c 08 cf			.byte	$36,$32,$35,$00,$0f,$0c,$08,$cf
>1cb0	02 39 05 18 0d b7 84 fe			.byte	$02,$39,$05,$18,$0d,$b7,$84,$fe
>1cb8	03 57 00 12 16 08 cf 05			.byte	$03,$57,$00,$12,$16,$08,$cf,$05
>1cc0	38 03 04 17 b7 84 fe 06			.byte	$38,$03,$04,$17,$b7,$84,$fe,$06
>1cc8	4a 39 59 58 00 12 20 08			.byte	$4a,$39,$59,$58,$00,$12,$20,$08
>1cd0	cf 18 35 03 01 84 48 51			.byte	$cf,$18,$35,$03,$01,$84,$48,$51
>1cd8	fd 06 31 38 37 35 00 13			.byte	$fd,$06,$31,$38,$37,$35,$00,$13
>1ce0	2a 08 cf 15 35 14 03 11			.byte	$2a,$08,$cf,$15,$35,$14,$03,$11
>1ce8	84 42 64 fd 06 31 38 37			.byte	$84,$42,$64,$fd,$06,$31,$38,$37
>1cf0	35 00 0f 34 08 cf 11 84			.byte	$35,$00,$0f,$34,$08,$cf,$11,$84
>1cf8	48 60 fd 06 31 38 37 35			.byte	$48,$60,$fd,$06,$31,$38,$37,$35
>1d00	00 11 3e 08 cf 12 30 14			.byte	$00,$11,$3e,$08,$cf,$12,$30,$14
>1d08	84 48 51 fd 06 30 36 32			.byte	$84,$48,$51,$fd,$06,$30,$36,$32
>1d10	35 00 10 48 08 cf 03 34			.byte	$35,$00,$10,$48,$08,$cf,$03,$34
>1d18	08 b7 84 fe 06 54 35 59			.byte	$08,$b7,$84,$fe,$06,$54,$35,$59
>1d20	47 00 0c 52 08 dc 0c 35			.byte	$47,$00,$0c,$52,$08,$dc,$0c,$35
>1d28	09 12 b9 84 40 00 13 5c			.byte	$09,$12,$b9,$84,$40,$00,$13,$5c
>1d30	08 dc 03 32 08 07 84 8b			.byte	$08,$dc,$03,$32,$08,$07,$84,$8b
>1d38	45 41 fd 06 36 38 37 35			.byte	$45,$41,$fd,$06,$36,$38,$37,$35
>1d40	00 11 66 08 dc 15 30 01			.byte	$00,$11,$66,$08,$dc,$15,$30,$01
>1d48	84 48 78 fd 06 35 36 32			.byte	$84,$48,$78,$fd,$06,$35,$36,$32
>1d50	35 00 11 70 08 dc 0c 31			.byte	$35,$00,$11,$70,$08,$dc,$0c,$31
>1d58	0f 05 84 44 55 fd 05 31			.byte	$0f,$05,$84,$44,$55,$fd,$05,$31
>1d60	32 35 00 12 7a 08 dc 0e			.byte	$32,$35,$00,$12,$7a,$08,$dc,$0e
>1d68	32 0f b9 84 49 40 fd 06			.byte	$32,$0f,$b9,$84,$49,$40,$fd,$06
>1d70	36 38 37 35 00 0a 84 08			.byte	$36,$38,$37,$35,$00,$0a,$84,$08
>1d78	dc 03 bb 84 49 46 00 09			.byte	$dc,$03,$bb,$84,$49,$46,$00,$09
>1d80	8e 08 dc 02 b9 84 40 00			.byte	$8e,$08,$dc,$02,$b9,$84,$40,$00
>1d88	10 98 08 dc 13 31 0c 04			.byte	$10,$98,$08,$dc,$13,$31,$0c,$04
>1d90	b7 84 fe 05 45 31 57 00			.byte	$b7,$84,$fe,$05,$45,$31,$57,$00
>1d98	0c a2 08 dc 10 36 03 17			.byte	$0c,$a2,$08,$dc,$10,$36,$03,$17
>1da0	bb 84 40 00 12 ac 08 dc			.byte	$bb,$84,$40,$00,$12,$ac,$08,$dc
>1da8	04 36 13 0d b9 84 8b 43			.byte	$04,$36,$13,$0d,$b9,$84,$8b,$43
>1db0	5a fd 04 32 35 00 10 b6			.byte	$5a,$fd,$04,$32,$35,$00,$10,$b6
>1db8	08 dc 12 84 8b 48 5e fd			.byte	$08,$dc,$12,$84,$8b,$48,$5e,$fd
>1dc0	06 36 38 37 35 00 09 c0			.byte	$06,$36,$38,$37,$35,$00,$09,$c0
>1dc8	08 dc 0d bb 84 40 00 0b			.byte	$08,$dc,$0d,$bb,$84,$40,$00,$0b
>1dd0	ca 08 dc 0e bb 84 8b 49			.byte	$ca,$08,$dc,$0e,$bb,$84,$8b,$49
>1dd8	40 00 0f d4 08 dc 18 30			.byte	$40,$00,$0f,$d4,$08,$dc,$18,$30
>1de0	01 11 0b b7 84 fe 03 56			.byte	$01,$11,$0b,$b7,$84,$fe,$03,$56
>1de8	00 0d de 08 dc 01 31 05			.byte	$00,$0d,$de,$08,$dc,$01,$31,$05
>1df0	bb 84 8b 4a 4c 00 10 e8			.byte	$bb,$84,$8b,$4a,$4c,$00,$10,$e8
>1df8	08 dc 14 b9 84 44 55 fd			.byte	$08,$dc,$14,$b9,$84,$44,$55,$fd
>1e00	06 33 31 32 35 00 0c f2			.byte	$06,$33,$31,$32,$35,$00,$0c,$f2
>1e08	08 dc 05 30 0a 0a bb 84			.byte	$08,$dc,$05,$30,$0a,$0a,$bb,$84
>1e10	40 00 11 fc 08 dc 05 36			.byte	$40,$00,$11,$fc,$08,$dc,$05,$36
>1e18	01 06 0b 84 8b 46 7e fd			.byte	$01,$06,$0b,$84,$8b,$46,$7e,$fd
>1e20	03 35 00 12 06 09 dc 05			.byte	$03,$35,$00,$12,$06,$09,$dc,$05
>1e28	37 15 1a b9 84 77 fd 06			.byte	$37,$15,$1a,$b9,$84,$77,$fd,$06
>1e30	30 36 32 35 00 0a 10 09			.byte	$30,$36,$32,$35,$00,$0a,$10,$09
>1e38	dc 0c b7 84 fe 02 00 0e			.byte	$dc,$0c,$b7,$84,$fe,$02,$00,$0e
>1e40	1a 09 dc 14 37 13 07 bb			.byte	$1a,$09,$dc,$14,$37,$13,$07,$bb
>1e48	84 8b 44 78 00 0d 24 09			.byte	$84,$8b,$44,$78,$00,$0d,$24,$09
>1e50	dc 04 39 19 bb 84 8b 42			.byte	$dc,$04,$39,$19,$bb,$84,$8b,$42
>1e58	71 00 0e 2e 09 dc 05 33			.byte	$71,$00,$0e,$2e,$09,$dc,$05,$33
>1e60	16 04 0b bb 84 4a 4a 00			.byte	$16,$04,$0b,$bb,$84,$4a,$4a,$00
>1e68	11 38 09 dc 0e 39 09 b7			.byte	$11,$38,$09,$dc,$0e,$39,$09,$b7
>1e70	84 fe 07 4d 30 59 53 5a			.byte	$84,$fe,$07,$4d,$30,$59,$53,$5a
>1e78	00 11 42 09 dc 0a 38 07			.byte	$00,$11,$42,$09,$dc,$0a,$38,$07
>1e80	b7 84 fe 07 4e 33 57 5a			.byte	$b7,$84,$fe,$07,$4e,$33,$57,$5a
>1e88	45 00 11 4c 09 dc 0a 39			.byte	$45,$00,$11,$4c,$09,$dc,$0a,$39
>1e90	01 18 0d b7 84 fe 05 50			.byte	$01,$18,$0d,$b7,$84,$fe,$05,$50
>1e98	37 51 00 0e 56 09 dc 0c			.byte	$37,$51,$00,$0e,$56,$09,$dc,$0c
>1ea0	36 19 b7 84 fe 04 58 34			.byte	$36,$19,$b7,$84,$fe,$04,$58,$34
>1ea8	00 15 60 09 dc 05 32 0f			.byte	$00,$15,$60,$09,$dc,$05,$32,$0f
>1eb0	0a 10 b9 84 8b 46 61 fd			.byte	$0a,$10,$b9,$84,$8b,$46,$61,$fd
>1eb8	06 30 36 32 35 00 0f 6a			.byte	$06,$30,$36,$32,$35,$00,$0f,$6a
>1ec0	09 dc 02 39 05 18 0d b7			.byte	$09,$dc,$02,$39,$05,$18,$0d,$b7
>1ec8	84 fe 03 57 00 0a 74 09			.byte	$84,$fe,$03,$57,$00,$0a,$74,$09
>1ed0	dc 09 b7 84 fe 02 00 12			.byte	$dc,$09,$b7,$84,$fe,$02,$00,$12
>1ed8	7e 09 dc 09 34 13 84 8b			.byte	$7e,$09,$dc,$09,$34,$13,$84,$8b
>1ee0	42 50 fd 06 39 33 37 35			.byte	$42,$50,$fd,$06,$39,$33,$37,$35
>1ee8	00 0e 88 09 dc 04 38 10			.byte	$00,$0e,$88,$09,$dc,$04,$38,$10
>1ef0	15 1a bb 84 4e 69 00 13			.byte	$15,$1a,$bb,$84,$4e,$69,$00,$13
>1ef8	92 09 dc 05 31 19 19 84			.byte	$92,$09,$dc,$05,$31,$19,$19,$84
>1f00	8b 44 7c fd 06 33 31 32			.byte	$8b,$44,$7c,$fd,$06,$33,$31,$32
>1f08	35 00 0b 9c 09 dc 03 31			.byte	$35,$00,$0b,$9c,$09,$dc,$03,$31
>1f10	0c bb 84 40 00 0e a6 09			.byte	$0c,$bb,$84,$40,$00,$0e,$a6,$09
>1f18	dc 03 37 17 19 b7 84 fe			.byte	$dc,$03,$37,$17,$19,$b7,$84,$fe
>1f20	03 49 00 0c b0 09 dc 0f			.byte	$03,$49,$00,$0c,$b0,$09,$dc,$0f
>1f28	31 0f 02 bb 84 6b 00 08			.byte	$31,$0f,$02,$bb,$84,$6b,$00,$08
>1f30	ba 09 dc 0b 84 40 00 0e			.byte	$ba,$09,$dc,$0b,$84,$40,$00,$0e
>1f38	c4 09 dc 13 37 0a 08 06			.byte	$c4,$09,$dc,$13,$37,$0a,$08,$06
>1f40	bb 84 46 40 00 0e ce 09			.byte	$bb,$84,$46,$40,$00,$0e,$ce,$09
>1f48	dc 18 b9 84 8b 48 49 fd			.byte	$dc,$18,$b9,$84,$8b,$48,$49,$fd
>1f50	03 30 00 14 d8 09 dc 06			.byte	$03,$30,$00,$14,$d8,$09,$dc,$06
>1f58	35 06 0f 18 84 8b 47 55			.byte	$35,$06,$0f,$18,$84,$8b,$47,$55
>1f60	fd 06 31 38 37 35 00 12			.byte	$fd,$06,$31,$38,$37,$35,$00,$12
>1f68	e2 09 dc 14 37 10 84 8b			.byte	$e2,$09,$dc,$14,$37,$10,$84,$8b
>1f70	42 72 fd 06 38 31 32 35			.byte	$42,$72,$fd,$06,$38,$31,$32,$35
>1f78	00 11 ec 09 dc 17 39 15			.byte	$00,$11,$ec,$09,$dc,$17,$39,$15
>1f80	02 11 b7 84 fe 05 4a 30			.byte	$02,$11,$b7,$84,$fe,$05,$4a,$30
>1f88	43 00 0f f6 09 dc 08 33			.byte	$43,$00,$0f,$f6,$09,$dc,$08,$33
>1f90	08 09 84 4d fd 04 37 35			.byte	$08,$09,$84,$4d,$fd,$04,$37,$35
>1f98	00 12 00 0a dc 1a 31 18			.byte	$00,$12,$00,$0a,$dc,$1a,$31,$18
>1fa0	03 16 b9 84 8b 45 52 fd			.byte	$03,$16,$b9,$84,$8b,$45,$52,$fd
>1fa8	03 35 00 11 0a 0a dc 01			.byte	$03,$35,$00,$11,$0a,$0a,$dc,$01
>1fb0	36 09 06 84 44 5b fd 05			.byte	$36,$09,$06,$84,$44,$5b,$fd,$05
>1fb8	31 32 35 00 0d 14 0a dc			.byte	$31,$32,$35,$00,$0d,$14,$0a,$dc
>1fc0	1a b7 84 fe 05 4d 35 52			.byte	$1a,$b7,$84,$fe,$05,$4d,$35,$52
>1fc8	00 12 1e 0a dc 0a 35 11			.byte	$00,$12,$1e,$0a,$dc,$0a,$35,$11
>1fd0	19 b7 84 fe 07 42 32 44			.byte	$19,$b7,$84,$fe,$07,$42,$32,$44
>1fd8	4e 50 00 0f 28 0a dc 13			.byte	$4e,$50,$00,$0f,$28,$0a,$dc,$13
>1fe0	35 14 1a 0d bb 84 8b 4c			.byte	$35,$14,$1a,$0d,$bb,$84,$8b,$4c
>1fe8	6d 00 10 32 0a dc 04 37			.byte	$6d,$00,$10,$32,$0a,$dc,$04,$37
>1ff0	10 84 41 6e fd 05 31 32			.byte	$10,$84,$41,$6e,$fd,$05,$31,$32
>1ff8	35 00 12 3c 0a dc 05 38			.byte	$35,$00,$12,$3c,$0a,$dc,$05,$38
>2000	03 04 17 b7 84 fe 06 4a			.byte	$03,$04,$17,$b7,$84,$fe,$06,$4a
>2008	39 59 58 00 14 46 0a dc			.byte	$39,$59,$58,$00,$14,$46,$0a,$dc
>2010	0e 30 0b 0e 01 84 8b 42			.byte	$0e,$30,$0b,$0e,$01,$84,$8b,$42
>2018	6f fd 06 33 31 32 35 00			.byte	$6f,$fd,$06,$33,$31,$32,$35,$00
>2020	12 50 0a dc 07 32 08 04			.byte	$12,$50,$0a,$dc,$07,$32,$08,$04
>2028	19 84 47 6a fd 05 33 37			.byte	$19,$84,$47,$6a,$fd,$05,$33,$37
>2030	35 00 0b 5a 0a dc 12 32			.byte	$35,$00,$0b,$5a,$0a,$dc,$12,$32
>2038	19 bb 84 40 00 10 64 0a			.byte	$19,$bb,$84,$40,$00,$10,$64,$0a
>2040	dc 03 34 08 b7 84 fe 06			.byte	$dc,$03,$34,$08,$b7,$84,$fe,$06
>2048	54 35 59 47 00 0e 6e 0a			.byte	$54,$35,$59,$47,$00,$0e,$6e,$0a
>2050	dc 07 b7 84 fe 06 59 31			.byte	$dc,$07,$b7,$84,$fe,$06,$59,$31
>2058	49 49 00 0c 78 0a dc 19			.byte	$49,$49,$00,$0c,$78,$0a,$dc,$19
>2060	33 09 b7 84 fe 02 00 11			.byte	$33,$09,$b7,$84,$fe,$02,$00,$11
>2068	82 0a dc 18 32 06 0e 02			.byte	$82,$0a,$dc,$18,$32,$06,$0e,$02
>2070	84 8b 46 6c fd 03 30 00			.byte	$84,$8b,$46,$6c,$fd,$03,$30,$00
>2078	13 8c 0a dc 15 35 14 03			.byte	$13,$8c,$0a,$dc,$15,$35,$14,$03
>2080	11 84 42 64 fd 06 31 38			.byte	$11,$84,$42,$64,$fd,$06,$31,$38
>2088	37 35 00 0f 96 0a dc 11			.byte	$37,$35,$00,$0f,$96,$0a,$dc,$11
>2090	84 48 60 fd 06 31 38 37			.byte	$84,$48,$60,$fd,$06,$31,$38,$37
>2098	35 00 09 a0 0a dc 10 b9			.byte	$35,$00,$09,$a0,$0a,$dc,$10,$b9
>20a0	84 40 00 12 aa 0a dc 06			.byte	$84,$40,$00,$12,$aa,$0a,$dc,$06
>20a8	33 01 12 0c b9 84 4d fd			.byte	$33,$01,$12,$0c,$b9,$84,$4d,$fd
>20b0	05 33 37 35 00 10 b4 0a			.byte	$05,$33,$37,$35,$00,$10,$b4,$0a
>20b8	dc 05 38 10 b9 84 47 77			.byte	$dc,$05,$38,$10,$b9,$84,$47,$77
>20c0	fd 04 37 35 00 0a be 0a			.byte	$fd,$04,$37,$35,$00,$0a,$be,$0a
>20c8	dc 0f b7 84 fe 02 00 0d			.byte	$dc,$0f,$b7,$84,$fe,$02,$00,$0d
>20d0	c8 0a dc 08 34 0c 17 11			.byte	$c8,$0a,$dc,$08,$34,$0c,$17,$11
>20d8	bb 84 40 00 0f d2 0a dc			.byte	$bb,$84,$40,$00,$0f,$d2,$0a,$dc
>20e0	06 39 13 84 8b 5d fd 04			.byte	$06,$39,$13,$84,$8b,$5d,$fd,$04
>20e8	32 35 00 0e dc 0a dc 0d			.byte	$32,$35,$00,$0e,$dc,$0a,$dc,$0d
>20f0	31 14 13 bb 84 8b 49 5e			.byte	$31,$14,$13,$bb,$84,$8b,$49,$5e
>20f8	00 0d e6 0a dc 19 30 03			.byte	$00,$0d,$e6,$0a,$dc,$19,$30,$03
>2100	14 bb 84 43 60 00 12 f0			.byte	$14,$bb,$84,$43,$60,$00,$12,$f0
>2108	0a dc 02 39 04 0a 07 b9			.byte	$0a,$dc,$02,$39,$04,$0a,$07,$b9
>2110	84 41 7b fd 04 32 35 00			.byte	$84,$41,$7b,$fd,$04,$32,$35,$00
>2118	11 fa 0a dc 12 30 14 84			.byte	$11,$fa,$0a,$dc,$12,$30,$14,$84
>2120	48 51 fd 06 30 36 32 35			.byte	$48,$51,$fd,$06,$30,$36,$32,$35
>2128	00 0d 04 0b dc 14 30 19			.byte	$00,$0d,$04,$0b,$dc,$14,$30,$19
>2130	bb 84 8b 4a 6d 00 0e 0e			.byte	$bb,$84,$8b,$4a,$6d,$00,$0e,$0e
>2138	0b dc 16 35 0a 0d 0e bb			.byte	$0b,$dc,$16,$35,$0a,$0d,$0e,$bb
>2140	84 42 44 00 13 18 0b dc			.byte	$84,$42,$44,$00,$13,$18,$0b,$dc
>2148	0e 36 0d b9 84 8b 42 50			.byte	$0e,$36,$0d,$b9,$84,$8b,$42,$50
>2150	fd 06 39 33 37 35 00 09			.byte	$fd,$06,$39,$33,$37,$35,$00,$09
>2158	22 0b dc 06 b9 84 40 00			.byte	$22,$0b,$dc,$06,$b9,$84,$40,$00
>2160	0d 2c 0b dc 08 37 0b 10			.byte	$0d,$2c,$0b,$dc,$08,$37,$0b,$10
>2168	0e bb 84 40 00 13 36 0b			.byte	$0e,$bb,$84,$40,$00,$13,$36,$0b
>2170	dc 05 31 11 17 09 b9 84			.byte	$dc,$05,$31,$11,$17,$09,$b9,$84
>2178	41 43 fd 05 31 32 35 00			.byte	$41,$43,$fd,$05,$31,$32,$35,$00
>2180	0d 40 0b dc 1a 38 03 09			.byte	$0d,$40,$0b,$dc,$1a,$38,$03,$09
>2188	bb 84 4e 6a 00 12 4a 0b			.byte	$bb,$84,$4e,$6a,$00,$12,$4a,$0b
>2190	dc 19 32 13 05 0b 84 8b			.byte	$dc,$19,$32,$13,$05,$0b,$84,$8b
>2198	47 5c fd 04 32 35 00 0d			.byte	$47,$5c,$fd,$04,$32,$35,$00,$0d
>21a0	54 0b dc 11 32 12 0c b7			.byte	$54,$0b,$dc,$11,$32,$12,$0c,$b7
>21a8	84 fe 02 00 0b 5e 0b dc			.byte	$84,$fe,$02,$00,$0b,$5e,$0b,$dc
>21b0	13 bb 84 8b 46 6f 00 13			.byte	$13,$bb,$84,$8b,$46,$6f,$00,$13
>21b8	68 0b dc 11 34 0d 03 b9			.byte	$68,$0b,$dc,$11,$34,$0d,$03,$b9
>21c0	84 43 64 fd 06 39 33 37			.byte	$84,$43,$64,$fd,$06,$39,$33,$37
>21c8	35 00 0d 72 0b dc 17 31			.byte	$35,$00,$0d,$72,$0b,$dc,$17,$31
>21d0	03 bb 84 8b 49 78 00 0d			.byte	$03,$bb,$84,$8b,$49,$78,$00,$0d
>21d8	7c 0b dc 12 33 13 0c 18			.byte	$7c,$0b,$dc,$12,$33,$13,$0c,$18
>21e0	bb 84 40 00 10 86 0b dc			.byte	$bb,$84,$40,$00,$10,$86,$0b,$dc
>21e8	0d 34 11 0d b7 84 fe 05			.byte	$0d,$34,$11,$0d,$b7,$84,$fe,$05
>21f0	42 39 44 00 14 90 0b dc			.byte	$42,$39,$44,$00,$14,$90,$0b,$dc
>21f8	04 34 1a 12 0a b9 84 43			.byte	$04,$34,$1a,$12,$0a,$b9,$84,$43
>2200	71 fd 06 38 31 32 35 00			.byte	$71,$fd,$06,$38,$31,$32,$35,$00
>2208	0a 9a 0b dc 0b 32 08 84			.byte	$0a,$9a,$0b,$dc,$0b,$32,$08,$84
>2210	40 00 0b a4 0b dc 17 b7			.byte	$40,$00,$0b,$a4,$0b,$dc,$17,$b7
>2218	84 fe 03 41 00 11 ae 0b			.byte	$84,$fe,$03,$41,$00,$11,$ae,$0b
>2220	dc 15 33 05 b9 84 8b 79			.byte	$dc,$15,$33,$05,$b9,$84,$8b,$79
>2228	fd 05 36 32 35 00 10 b8			.byte	$fd,$05,$36,$32,$35,$00,$10,$b8
>2230	0b dc 0b 39 16 19 b7 84			.byte	$0b,$dc,$0b,$39,$16,$19,$b7,$84
>2238	fe 05 56 36 50 00 10 c2			.byte	$fe,$05,$56,$36,$50,$00,$10,$c2
>2240	0b dc 0c 31 0b 18 0b 84			.byte	$0b,$dc,$0c,$31,$0b,$18,$0b,$84
>2248	46 59 fd 03 30 00 0b cc			.byte	$46,$59,$fd,$03,$30,$00,$0b,$cc
>2250	0b dc 19 bb 84 8b 4a 48			.byte	$0b,$dc,$19,$bb,$84,$8b,$4a,$48
>2258	00 12 d6 0b dc 18 35 03			.byte	$00,$12,$d6,$0b,$dc,$18,$35,$03
>2260	01 84 48 51 fd 06 31 38			.byte	$01,$84,$48,$51,$fd,$06,$31,$38
>2268	37 35 00 11 e0 0b dc 08			.byte	$37,$35,$00,$11,$e0,$0b,$dc,$08
>2270	38 13 0c b9 84 8b 41 5b			.byte	$38,$13,$0c,$b9,$84,$8b,$41,$5b
>2278	fd 03 35 00 0c ea 0b dc			.byte	$fd,$03,$35,$00,$0c,$ea,$0b,$dc
>2280	12 39 19 18 b9 84 40 00			.byte	$12,$39,$19,$18,$b9,$84,$40,$00
>2288	0f f4 0b dc 10 32 1a 03			.byte	$0f,$f4,$0b,$dc,$10,$32,$1a,$03
>2290	b7 84 fe 04 52 34 00 0e			.byte	$b7,$84,$fe,$04,$52,$34,$00,$0e
>2298	fe 0b dc 0b 36 08 0e 19			.byte	$fe,$0b,$dc,$0b,$36,$08,$0e,$19
>22a0	bb 84 42 5e 00 0c 08 0c			.byte	$bb,$84,$42,$5e,$00,$0c,$08,$0c
>22a8	dc 0a 30 03 bb 84 8b 5a			.byte	$dc,$0a,$30,$03,$bb,$84,$8b,$5a
>22b0	00 0e 12 0c dc 11 37 08			.byte	$00,$0e,$12,$0c,$dc,$11,$37,$08
>22b8	07 01 bb 84 48 4f 00 13			.byte	$07,$01,$bb,$84,$48,$4f,$00,$13
>22c0	1c 0c dc 06 31 05 10 01			.byte	$1c,$0c,$dc,$06,$31,$05,$10,$01
>22c8	b9 84 43 60 fd 05 31 32			.byte	$b9,$84,$43,$60,$fd,$05,$31,$32
>22d0	35 00 11 26 0c dc 01 b9			.byte	$35,$00,$11,$26,$0c,$dc,$01,$b9
>22d8	84 8b 43 6f fd 06 34 33			.byte	$84,$8b,$43,$6f,$fd,$06,$34,$33
>22e0	37 35 00 12 30 0c dc 14			.byte	$37,$35,$00,$12,$30,$0c,$dc,$14
>22e8	34 11 15 84 48 4a fd 06			.byte	$34,$11,$15,$84,$48,$4a,$fd,$06
>22f0	38 31 32 35 00 2b 3a 0c			.byte	$38,$31,$32,$35,$00,$2b,$3a,$0c
>22f8	d6 1a 32 12 04 b8 40 be			.byte	$d6,$1a,$32,$12,$04,$b8,$40,$be
>2300	bf fe 02 c0 d6 1a 32 12			.byte	$bf,$fe,$02,$c0,$d6,$1a,$32,$12
>2308	04 b8 41 be bf fe 06 4b			.byte	$04,$b8,$41,$be,$bf,$fe,$06,$4b
>2310	36 47 53 c0 d6 1a 32 12			.byte	$36,$47,$53,$c0,$d6,$1a,$32,$12
>2318	04 b8 42 be bf fe 02 00			.byte	$04,$b8,$42,$be,$bf,$fe,$02,$00
>2320	5b 44 0c d6 08 34 16 0b			.byte	$5b,$44,$0c,$d6,$08,$34,$16,$0b
>2328	10 bc 40 bf 40 be bf 8b			.byte	$10,$bc,$40,$bf,$40,$be,$bf,$8b
>2330	45 49 c0 d6 08 34 16 0b			.byte	$45,$49,$c0,$d6,$08,$34,$16,$0b
>2338	10 bc 40 bf 41 be bf 8b			.byte	$10,$bc,$40,$bf,$41,$be,$bf,$8b
>2340	45 67 c0 d6 08 34 16 0b			.byte	$45,$67,$c0,$d6,$08,$34,$16,$0b
>2348	10 bc 41 bf 40 be bf 40			.byte	$10,$bc,$41,$bf,$40,$be,$bf,$40
>2350	c0 d6 08 34 16 0b 10 bc			.byte	$c0,$d6,$08,$34,$16,$0b,$10,$bc
>2358	41 bf 41 be bf 40 c0 d6			.byte	$41,$bf,$41,$be,$bf,$40,$c0,$d6
>2360	08 34 16 0b 10 bc 42 bf			.byte	$08,$34,$16,$0b,$10,$bc,$42,$bf
>2368	40 be bf 40 c0 d6 08 34			.byte	$40,$be,$bf,$40,$c0,$d6,$08,$34
>2370	16 0b 10 bc 42 bf 41 be			.byte	$16,$0b,$10,$bc,$42,$bf,$41,$be
>2378	bf 40 00 1d 4e 0c d6 15			.byte	$bf,$40,$00,$1d,$4e,$0c,$d6,$15
>2380	b8 40 be bf fe 07 4b 32			.byte	$b8,$40,$be,$bf,$fe,$07,$4b,$32
>2388	54 42 41 c0 d6 15 b8 41			.byte	$54,$42,$41,$c0,$d6,$15,$b8,$41
>2390	be bf fe 05 4d 31 4a 00			.byte	$be,$bf,$fe,$05,$4d,$31,$4a,$00
>2398	21 58 0c d6 05 32 02 bd			.byte	$21,$58,$0c,$d6,$05,$32,$02,$bd
>23a0	40 be bf 40 c0 d6 05 32			.byte	$40,$be,$bf,$40,$c0,$d6,$05,$32
>23a8	02 bd 41 be bf 40 c0 d6			.byte	$02,$bd,$41,$be,$bf,$40,$c0,$d6
>23b0	05 32 02 bd 42 be bf 40			.byte	$05,$32,$02,$bd,$42,$be,$bf,$40
>23b8	00 20 62 0c d6 04 37 13			.byte	$00,$20,$62,$0c,$d6,$04,$37,$13
>23c0	0b b8 40 be bf fe 04 4a			.byte	$0b,$b8,$40,$be,$bf,$fe,$04,$4a
>23c8	32 c0 d6 04 37 13 0b b8			.byte	$32,$c0,$d6,$04,$37,$13,$0b,$b8
>23d0	41 be bf fe 05 59 32 4b			.byte	$41,$be,$bf,$fe,$05,$59,$32,$4b
>23d8	00 30 6c 0c d6 14 35 15			.byte	$00,$30,$6c,$0c,$d6,$14,$35,$15
>23e0	10 b8 40 be bf fe 02 c0			.byte	$10,$b8,$40,$be,$bf,$fe,$02,$c0
>23e8	d6 14 35 15 10 b8 41 be			.byte	$d6,$14,$35,$15,$10,$b8,$41,$be
>23f0	bf fe 07 56 32 4d 41 4f			.byte	$bf,$fe,$07,$56,$32,$4d,$41,$4f
>23f8	c0 d6 14 35 15 10 b8 42			.byte	$c0,$d6,$14,$35,$15,$10,$b8,$42
>2400	be bf fe 06 44 37 4c 46			.byte	$be,$bf,$fe,$06,$44,$37,$4c,$46
>2408	00 2a 76 0c d6 06 34 08			.byte	$00,$2a,$76,$0c,$d6,$06,$34,$08
>2410	03 05 bc 40 be bf 4b 74			.byte	$03,$05,$bc,$40,$be,$bf,$4b,$74
>2418	c0 d6 06 34 08 03 05 bc			.byte	$c0,$d6,$06,$34,$08,$03,$05,$bc
>2420	41 be bf 8b 46 6b c0 d6			.byte	$41,$be,$bf,$8b,$46,$6b,$c0,$d6
>2428	06 34 08 03 05 bc 42 be			.byte	$06,$34,$08,$03,$05,$bc,$42,$be
>2430	bf 40 00 1c 80 0c d6 05			.byte	$bf,$40,$00,$1c,$80,$0c,$d6,$05
>2438	36 14 13 bc 40 be bf 8b			.byte	$36,$14,$13,$bc,$40,$be,$bf,$8b
>2440	43 79 c0 d6 05 36 14 13			.byte	$43,$79,$c0,$d6,$05,$36,$14,$13
>2448	bc 41 be bf 4a 7f 00 21			.byte	$bc,$41,$be,$bf,$4a,$7f,$00,$21
>2450	8a 0c d6 14 32 16 bd 40			.byte	$8a,$0c,$d6,$14,$32,$16,$bd,$40
>2458	be bf 40 c0 d6 14 32 16			.byte	$be,$bf,$40,$c0,$d6,$14,$32,$16
>2460	bd 41 be bf 40 c0 d6 14			.byte	$bd,$41,$be,$bf,$40,$c0,$d6,$14
>2468	32 16 bd 42 be bf 40 00			.byte	$32,$16,$bd,$42,$be,$bf,$40,$00
>2470	27 94 0c d6 11 37 09 06			.byte	$27,$94,$0c,$d6,$11,$37,$09,$06
>2478	b8 40 be bf fe 02 c0 d6			.byte	$b8,$40,$be,$bf,$fe,$02,$c0,$d6
>2480	11 37 09 06 b8 41 be bf			.byte	$11,$37,$09,$06,$b8,$41,$be,$bf
>2488	fe 02 c0 d6 11 37 09 06			.byte	$fe,$02,$c0,$d6,$11,$37,$09,$06
>2490	b8 42 be bf fe 02 00 28			.byte	$b8,$42,$be,$bf,$fe,$02,$00,$28
>2498	9e 0c d6 01 35 0e b8 40			.byte	$9e,$0c,$d6,$01,$35,$0e,$b8,$40
>24a0	be bf fe 02 c0 d6 01 35			.byte	$be,$bf,$fe,$02,$c0,$d6,$01,$35
>24a8	0e b8 41 be bf fe 02 c0			.byte	$0e,$b8,$41,$be,$bf,$fe,$02,$c0
>24b0	d6 01 35 0e b8 42 be bf			.byte	$d6,$01,$35,$0e,$b8,$42,$be,$bf
>24b8	fe 06 56 38 4a 54 00 2e			.byte	$fe,$06,$56,$38,$4a,$54,$00,$2e
>24c0	a8 0c d6 13 34 02 ba 40			.byte	$a8,$0c,$d6,$13,$34,$02,$ba,$40
>24c8	be bf 48 fd 06 33 31 32			.byte	$be,$bf,$48,$fd,$06,$33,$31,$32
>24d0	35 c0 d6 13 34 02 ba 41			.byte	$35,$c0,$d6,$13,$34,$02,$ba,$41
>24d8	be bf 46 62 fd 06 35 36			.byte	$be,$bf,$46,$62,$fd,$06,$35,$36
>24e0	32 35 c0 d6 13 34 02 ba			.byte	$32,$35,$c0,$d6,$13,$34,$02,$ba
>24e8	42 be bf 40 00 1b b2 0c			.byte	$42,$be,$bf,$40,$00,$1b,$b2,$0c
>24f0	d6 fe 14 50 61 73 73 65			.byte	$d6,$fe,$14,$50,$61,$73,$73,$65
>24f8	64 20 41 73 73 69 67 6e			.byte	$64,$20,$41,$73,$73,$69,$67,$6e
>2500	6d 65 6e 74 2e c0 c4 00			.byte	$6d,$65,$6e,$74,$2e,$c0,$c4,$00
>2508	00					.byte	$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c 0b 88 01	jmp $01880b		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 73 83 01	jmp $018373			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a6 81	jsr $0181a6			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d2 81	jsr $0181d2			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 b9 81	jsr $0181b9			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a6 81	jsr $0181a6			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 20		beq $018059			beq 	IFT_NewLine
.018039	c9 08		cmp #$08			cmp 	#8
.01803b	f0 16		beq $018053			beq 	_IFT_Left
.01803d	48		pha				pha
.01803e	20 71 80	jsr $018071			jsr 	IFT_UpperCase 				; make upper case
.018041	20 d2 81	jsr $0181d2			jsr 	IF_Write 					; write out.
.018044	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018047	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.01804a	c9 40		cmp #$40			cmp 	#IF_Width
.01804c	d0 03		bne $018051			bne 	_IFT_PCNotEOL
.01804e	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; if so do new line.
.018051					_IFT_PCNotEOL:
.018051	68		pla				pla
.018052	60		rts				rts
.018053					_IFT_Left:
.018053	48		pha				pha
.018054	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.018057	68		pla				pla
.018058	60		rts				rts
.018059					IFT_NewLine:
.018059	48		pha				pha
.01805a	20 b9 81	jsr $0181b9			jsr 	IF_NewLine 					; new line on actual screen.
.01805d	a9 00		lda #$00			lda 	#0 							; reset x position
.01805f	8d 00 05	sta $0500			sta 	IFT_XCursor
.018062	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018065	ad 01 05	lda $0501			lda 	IFT_YCursor
.018068	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806a	d0 03		bne $01806f			bne 	_IFT_NL_NotEOS
.01806c	20 7c 80	jsr $01807c			jsr 	IFT_Scroll 					; scroll screen up.
.01806f					_IFT_NL_NotEOS:
.01806f	68		pla				pla
.018070	60		rts				rts
.018071					IFT_UpperCase:
.018071	c9 61		cmp #$61			cmp 	#"a"
.018073	90 06		bcc $01807b			bcc 	_IFT_UCExit
.018075	c9 7b		cmp #$7b			cmp 	#"z"+1
.018077	b0 02		bcs $01807b			bcs 	_IFT_UCExit
.018079	49 20		eor #$20			eor 	#$20
.01807b					_IFT_UCExit:
.01807b	60		rts				rts
.01807c					IFT_Scroll:
.01807c	48		pha				pha 								; save AXY
.01807d	da		phx				phx
.01807e	5a		phy				phy
.01807f	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018081					_IFT_SLoop:
.018081	20 a1 80	jsr $0180a1			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018084	e8		inx				inx
.018085	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.018087	d0 f8		bne $018081			bne 	_IFT_SLoop
.018089	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808b	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01808e	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018090					_IFT_SBlank:
.018090	a9 20		lda #$20			lda 	#32
.018092	20 d2 81	jsr $0181d2			jsr 	IF_Write
.018095	ca		dex				dex
.018096	d0 f8		bne $018090			bne 	_IFT_SBlank
.018098	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809a	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01809d	7a		ply				ply
.01809e	fa		plx				plx
.01809f	68		pla				pla
.0180a0	60		rts				rts
.0180a1					_IFT_ScrollLine:
.0180a1	da		phx				phx
.0180a2	da		phx				phx
.0180a3	8a		txa				txa 								; copy line into buffer.
.0180a4	1a		inc a				inc 	a 							; next line down.
.0180a5	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180a8	a2 00		ldx #$00			ldx 	#0
.0180aa					_IFTScrollCopy1:
.0180aa	20 c9 81	jsr $0181c9			jsr 	IF_Read
.0180ad	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b0	e8		inx				inx
.0180b1	e0 40		cpx #$40			cpx 	#IF_Width
.0180b3	d0 f5		bne $0180aa			bne 	_IFTScrollCopy1
.0180b5	68		pla				pla
.0180b6	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.0180b9	a2 00		ldx #$00			ldx 	#0
.0180bb					_IFTScrollCopy2:
.0180bb	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180be	20 d2 81	jsr $0181d2			jsr 	IF_Write
.0180c1	e8		inx				inx
.0180c2	e0 40		cpx #$40			cpx 	#IF_Width
.0180c4	d0 f5		bne $0180bb			bne 	_IFTScrollCopy2
.0180c6	fa		plx				plx
.0180c7	60		rts				rts
.0180c8					IFT_SetYPos:
.0180c8	48		pha				pha
.0180c9	da		phx				phx
.0180ca	aa		tax				tax
.0180cb	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180ce	e0 00		cpx #$00			cpx 	#0
.0180d0	f0 09		beq $0180db			beq 	_IFT_MOAExit
.0180d2					_IFT_MOALoop:
.0180d2	20 b9 81	jsr $0181b9			jsr 	IF_NewLine
.0180d5	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180d8	ca		dex				dex
.0180d9	d0 f7		bne $0180d2			bne		_IFT_MOALoop
.0180db					_IFT_MOAExit:
.0180db	fa		plx				plx
.0180dc	68		pla				pla
.0180dd	60		rts				rts
.0180de					IFT_GetKeyCursor:
.0180de	20 e6 80	jsr $0180e6			jsr 	_IFT_FlipCursor 			; reverse current
.0180e1					_IFT_GKCWait:
.0180e1	20 e3 81	jsr $0181e3			jsr 	IF_GetKey 					; get key
.0180e4	f0 fb		beq $0180e1			beq 	_IFT_GKCWait
.0180e6					_IFT_FlipCursor:
.0180e6	48		pha				pha 								; save
.0180e7	20 c9 81	jsr $0181c9			jsr 	IF_Read 					; read
.0180ea	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.0180ed	49 80		eor #$80			eor 	#$80 						; reverse
.0180ef	20 d2 81	jsr $0181d2			jsr 	IF_Write 					; write
.0180f2	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.0180f5	68		pla				pla
.0180f6	60		rts				rts
.0180f7					IFT_ReadLine:
.0180f7	48		pha				pha
.0180f8					_IFT_RLLoop:
.0180f8	20 de 80	jsr $0180de			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fb	c9 0d		cmp #$0d			cmp 	#13							; return
.0180fd	f0 7d		beq $01817c			beq 	_IFT_RLExit
.0180ff	c9 20		cmp #$20			cmp 	#32 						; control character
.018101	90 05		bcc $018108			bcc 	_IFT_Control
.018103	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018106	80 f0		bra $0180f8			bra 	_IFT_RLLoop
.018108					_IFT_Control:
.018108	c9 01		cmp #$01			cmp 	#"A"-64
.01810a	f0 26		beq $018132			beq 	_IFT_Left
.01810c	c9 04		cmp #$04			cmp 	#"D"-64
.01810e	f0 2e		beq $01813e			beq 	_IFT_Right
.018110	c9 17		cmp #$17			cmp 	#"W"-64
.018112	f0 36		beq $01814a			beq 	_IFT_Up
.018114	c9 13		cmp #$13			cmp 	#"S"-64
.018116	f0 3e		beq $018156			beq 	_IFT_Down
.018118	c9 08		cmp #$08			cmp 	#"H"-64
.01811a	f0 09		beq $018125			beq 	_IFT_Backspace
.01811c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.01811e	d0 d8		bne $0180f8			bne 	_IFT_RLLoop
.018120	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018123	80 d3		bra $0180f8			bra 	_IFT_RLLoop
.018125					_IFT_Backspace:
.018125	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.018128	f0 ce		beq $0180f8			beq 	_IFT_RLLoop
.01812a	20 db 81	jsr $0181db			jsr 	IF_LeftOne
.01812d	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.01812f	20 d2 81	jsr $0181d2			jsr 	IF_Write
.018132					_IFT_Left:
.018132	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018135	10 29		bpl $018160			bpl 	_IFT_Reposition
.018137	a9 3f		lda #$3f			lda 	#IF_Width-1
.018139					_IFT_SetX:
.018139	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813c	80 22		bra $018160			bra 	_IFT_Reposition
.01813e					_IFT_Right:
.01813e	ee 00 05	inc $0500			inc 	IFT_XCursor
.018141	ad 00 05	lda $0500			lda 	IFT_XCursor
.018144	49 40		eor #$40			eor 	#IF_Width
.018146	f0 f1		beq $018139			beq 	_IFT_SetX
.018148	80 16		bra $018160			bra 	_IFT_Reposition
.01814a					_IFT_Up:
.01814a	ce 01 05	dec $0501			dec 	IFT_YCursor
.01814d	10 11		bpl $018160			bpl 	_IFT_Reposition
.01814f	a9 1f		lda #$1f			lda 	#IF_Height-1
.018151					_IFT_SetY:
.018151	8d 01 05	sta $0501			sta 	IFT_YCursor
.018154	80 0a		bra $018160			bra 	_IFT_Reposition
.018156					_IFT_Down:
.018156	ee 01 05	inc $0501			inc 	IFT_YCursor
.018159	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815c	49 20		eor #$20			eor 	#IF_Height
.01815e	f0 f1		beq $018151			beq 	_IFT_SetY
.018160					_IFT_Reposition:
.018160	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018163	48		pha				pha
.018164	ad 01 05	lda $0501			lda 	IFT_YCursor
.018167	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.01816a	68		pla				pla
.01816b	aa		tax				tax
.01816c	e0 00		cpx #$00			cpx 	#0
.01816e	f0 88		beq $0180f8			beq 	_IFT_RLLoop
.018170					_IFT_MoveRight:
.018170	20 c9 81	jsr $0181c9			jsr 	IF_Read
.018173	ee 00 05	inc $0500			inc 	IFT_XCursor
.018176	ca		dex				dex
.018177	d0 f7		bne $018170			bne 	_IFT_MoveRight
.018179	4c f8 80	jmp $0180f8			jmp 	_IFT_RLLoop
.01817c					_IFT_RLExit:
.01817c	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.01817f	20 c8 80	jsr $0180c8			jsr 	IFT_SetYPos
.018182	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018184					_IFT_RLRead:
.018184	20 c9 81	jsr $0181c9			jsr 	IF_Read
.018187	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818a	e8		inx				inx
.01818b	e0 40		cpx #$40			cpx 	#IF_Width
.01818d	d0 f5		bne $018184			bne 	_IFT_RLRead
.01818f					_IFT_RL_Trim:
.01818f	ca		dex				dex 	 							; previous char
.018190	30 07		bmi $018199			bmi 	_IFT_Found 					; gone too far
.018192	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018195	c9 20		cmp #$20			cmp 	#" "
.018197	f0 f6		beq $01818f			beq 	_IFT_RL_Trim
.018199					_IFT_Found:
.018199	e8		inx				inx 								; forward to non-space
.01819a	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819c	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01819f	68		pla				pla
.0181a0	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a2	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a5					IF_Reset:
.0181a5	60		rts				rts
.0181a6					IF_Home:
.0181a6	48		pha				pha
.0181a7	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181a9	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ab	85 04		sta $04				sta 	IF_Pos
.0181ad	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181af	85 05		sta $05				sta 	IF_Pos+1
.0181b1	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b3	85 06		sta $06				sta 	IF_Pos+2
.0181b5	64 07		stz $07				stz 	IF_Pos+3
.0181b7	68		pla				pla
.0181b8	60		rts				rts
.0181b9					IF_NewLine:
.0181b9	48		pha				pha
.0181ba	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bc	18		clc				clc 								; down one line
.0181bd	a5 04		lda $04				lda 	IF_Pos
.0181bf	69 40		adc #$40			adc 	#64
.0181c1	85 04		sta $04				sta 	IF_Pos
.0181c3	90 02		bcc $0181c7			bcc 	_IF_NoCarry 				; carry through.
.0181c5	e6 05		inc $05				inc 	IF_Pos+1
.0181c7					_IF_NoCarry:
.0181c7	68		pla				pla
.0181c8	60		rts				rts
.0181c9					IF_Read:
.0181c9	5a		phy				phy 								; save current Y
.0181ca	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cc	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181ce	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d0	7a		ply				ply									; restore Y
.0181d1	60		rts				rts
.0181d2					IF_Write:
.0181d2	5a		phy				phy 								; save current Y
.0181d3	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d5	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181d7	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d9	7a		ply				ply									; restore Y
.0181da	60		rts				rts
.0181db					IF_LeftOne:
.0181db	c6 08		dec $08				dec 	IF_XPos
.0181dd	60		rts				rts
.0181de					IF_CheckBreak:
.0181de	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e2	60		rts				rts
.0181e3					IF_GetKey:
.0181e3	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181e7	f0 08		beq $0181f1			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181e9	48		pha				pha 								; key pressed, clear queue.
.0181ea	a9 00		lda #$00			lda 	#0
.0181ec	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f0	68		pla				pla
.0181f1					_IFGK_NoKey:
.0181f1	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f4					TIM_Error:
.0181f4	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181f7	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181f9	80 02		bra $0181fd			bra 	TIM_ShowPrompt
.0181fb					TIM_NewCommand:
.0181fb	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.0181fd					TIM_ShowPrompt:
.0181fd	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018200	20 f7 80	jsr $0180f7			jsr 	IFT_ReadLine	 			; get character, go to next line
.018203	20 59 80	jsr $018059			jsr 	IFT_NewLine					; go to next line.
.018206	86 10		stx $10				stx 	zTemp1 						; save line read address
.018208	84 11		sty $11				sty 	zTemp1+1
.01820a	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01820e	c9 3f		cmp #$3f			cmp 	#"?"
.018210	f0 04		beq $018216			beq 	TIM_SkipFirst
.018212	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018214	d0 01		bne $018217			bne 	TIM_NotDot
.018216					TIM_SkipFirst:
.018216	c8		iny				iny
.018217					TIM_NotDot:
.018217	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.018219	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821b	f0 6b		beq $018288			beq 	TIM_ShowRegisters
.01821d	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.01821f	f0 12		beq $018233			beq 	TIM_ShowMemory
.018221	c9 47		cmp #$47			cmp 	#"G"						; execute
.018223	f0 49		beq $01826e			beq 	TIM_Execute
.018225	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.018227	f0 07		beq $018230			beq 	TIM_GoLoadMemory
.018229	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822b	d0 c7		bne $0181f4			bne 	TIM_Error
.01822d	4c ac 83	jmp $0183ac			jmp 	TIM_UpdateRegisters
.018230					TIM_GoLoadMemory:
.018230	4c dc 83	jmp $0183dc			jmp 	TIM_LoadMemory
.018233					TIM_ShowMemory:
.018233	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018236	b0 bc		bcs $0181f4			bcs 	TIM_Error
.018238	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823a	85 12		sta $12				sta 	zTemp2
.01823c	a5 15		lda $15				lda 	zTemp3+1
.01823e	85 13		sta $13				sta 	zTemp2+1
.018240	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018243	90 08		bcc $01824d			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018245	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.018247	85 14		sta $14				sta 	zTemp3
.018249	a5 13		lda $13				lda 	zTemp2+1
.01824b	85 15		sta $15				sta 	zTemp3+1
.01824d					_TIMSM_Start:
.01824d	20 00 83	jsr $018300			jsr 	TIM_WriteLine 				; write one line of hex out
.018250	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018252	18		clc				clc
.018253	69 10		adc #$10			adc 	#16
.018255	85 12		sta $12				sta 	zTemp2
.018257	90 02		bcc $01825b			bcc 	_TIMSM_NoCarry
.018259	e6 13		inc $13				inc 	zTemp2+1
.01825b					_TIMSM_NoCarry:
.01825b	20 de 81	jsr $0181de			jsr 	IF_CheckBreak 				; check CTL+C
.01825e	d0 0b		bne $01826b			bne 	_TIMSM_Ends 				; if pressed break out.
.018260	38		sec				sec 								; check past the end address in zTemp3
.018261	a5 14		lda $14				lda 	zTemp3
.018263	e5 12		sbc $12				sbc 	zTemp2
.018265	a5 15		lda $15				lda 	zTemp3+1
.018267	e5 13		sbc $13				sbc 	zTemp2+1
.018269	10 e2		bpl $01824d			bpl 	_TIMSM_Start
.01826b					_TIMSM_Ends:
.01826b	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand
.01826e					TIM_Execute:
.01826e	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; get the execute address
.018271	b0 81		bcs $0181f4			bcs 	TIM_Error 					; not legitimate
.018273	ae cd 03	ldx $03cd			ldx 	TIM_SP 						; set up SP
.018276	9a		txs				txs
.018277	ad c8 03	lda $03c8			lda 	TIM_SR 						; Status for PLP
.01827a	48		pha				pha
.01827b	ad c9 03	lda $03c9			lda 	TIM_A 						; restore AXYZ
.01827e	ae ca 03	ldx $03ca			ldx 	TIM_X
.018281	ac cb 03	ldy $03cb			ldy 	TIM_Y
.018284	28		plp				plp 								; and PS Byte.
.018285	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.018288					TIM_Start:
.018288					TIM_ShowRegisters:
.018288	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828b	8d c7 03	sta $03c7			sta 	TIM_IRQ+1
.01828e	ad ff ff	lda $ffff			lda 	$FFFF
.018291	8d c6 03	sta $03c6			sta 	TIM_IRQ
.018294	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018296					_TIMSR_Text:
.018296	bf c7 82 01	lda $0182c7,x			lda 	_TIMSR_Label,x
.01829a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01829d	e8		inx				inx
.01829e	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a0	d0 f4		bne $018296			bne 	_TIMSR_Text
.0182a2	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a4					_TIMSR_Skip:
.0182a4	e8		inx				inx
.0182a5					_TIMSR_LoopSpace:
.0182a5	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182a7	b0 04		bcs $0182ad			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182a9	8a		txa				txa
.0182aa	4a		lsr a				lsr 	a
.0182ab	b0 05		bcs $0182b2			bcs 	_TIMSR_NoSpace
.0182ad					_TIMSR_Space:
.0182ad	a9 20		lda #$20			lda 	#" "
.0182af	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b2					_TIMSR_NoSpace:
.0182b2	bd c4 03	lda $03c4,x			lda 	TIM_PC,x 					; output hex value.
.0182b5	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.0182b8	e8		inx				inx
.0182b9	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182bb	f0 e7		beq $0182a4			beq 	_TIMSR_Skip
.0182bd	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182bf	d0 e4		bne $0182a5			bne 	_TimSR_LoopSpace
.0182c1	20 59 80	jsr $018059			jsr 	IFT_NewLine 				; new line
.0182c4	4c fb 81	jmp $0181fb			jmp	 	TIM_NewCommand 				; new command.
.0182c7					_TIMSR_Label:
>0182c7	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182cf	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182df	52
>0182e0	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182e7					_TIMSR_LabelEnd:
.0182e7					TIM_WriteHex:
.0182e7	48		pha				pha 								; save A
.0182e8	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182e9	4a		lsr a				lsr 	a
.0182ea	4a		lsr a				lsr 	a
.0182eb	4a		lsr a				lsr 	a
.0182ec	20 f0 82	jsr $0182f0			jsr 	_TIMWH_Nibble 				; print MSB
.0182ef	68		pla				pla 								; restore and print LSB
.0182f0					_TIMWH_Nibble:
.0182f0	48		pha				pha
.0182f1	29 0f		and #$0f			and 	#15 						; mask out
.0182f3	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f5	90 02		bcc $0182f9			bcc 	_TIMWHNoLetter
.0182f7	69 06		adc #$06			adc 	#6
.0182f9					_TIMWHNoLetter:
.0182f9	69 30		adc #$30			adc 	#48
.0182fb	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.0182fe	68		pla				pla
.0182ff	60		rts				rts
.018300					TIM_WriteLine:
.018300	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018302	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018305	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.018307	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830a	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830c	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.01830f	a5 12		lda $12				lda 	zTemp2
.018311	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.018314	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018316					_TIMWL_Loop:
.018316	a9 20		lda #$20			lda 	#" "
.018318	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831b	b1 12		lda ($12),y			lda 	(zTemp2),y
.01831d	20 e7 82	jsr $0182e7			jsr 	TIM_WriteHex
.018320	c8		iny				iny
.018321	c0 10		cpy #$10			cpy 	#16
.018323	d0 f1		bne $018316			bne 	_TIMWL_Loop
.018325	4c 59 80	jmp $018059			jmp 	IFT_NewLine 				; new line and exit
.018328					TIM_GetHex:
.018328	c8		iny				iny
.018329	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832b	c9 20		cmp #$20			cmp 	#32
.01832d	f0 f9		beq $018328			beq 	TIM_GetHex
.01832f	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018331	f0 f5		beq $018328			beq 	TIM_GetHex
.018333	20 5c 83	jsr $01835c			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018336	b0 23		bcs $01835b			bcs 	_TIMGH_Exit					; if first bad then exit now.
.018338	a9 00		lda #$00			lda 	#0 							; zero result
.01833a	85 14		sta $14				sta 	zTemp3
.01833c	85 15		sta $15				sta 	zTemp3+1
.01833e					_TIM_GHLoop:
.01833e	20 5c 83	jsr $01835c			jsr 	TIM_GetHexCharacter 		; get next character
.018341	b0 17		bcs $01835a			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018343	c8		iny				iny 								; skip over it.
.018344	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018346	26 15		rol $15				rol 	zTemp3+1
.018348	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834a	26 15		rol $15				rol 	zTemp3+1
.01834c	06 14		asl $14				asl 	zTemp3						; now x 4
.01834e	26 15		rol $15				rol 	zTemp3+1
.018350	06 14		asl $14				asl 	zTemp3 						; now x 8
.018352	26 15		rol $15				rol 	zTemp3+1
.018354	05 14		ora $14				ora 	zTemp3 						; OR result in
.018356	85 14		sta $14				sta 	zTemp3
.018358	80 e4		bra $01833e			bra 	_TIM_GHLoop 				; loop round again.
.01835a					_TIMGH_Okay:
.01835a	18		clc				clc
.01835b					_TIMGH_Exit:
.01835b	60		rts				rts
.01835c					TIM_GetHexCharacter:
.01835c	b1 10		lda ($10),y			lda 	(zTemp1),y
.01835e	38		sec				sec
.01835f	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018361	90 0e		bcc $018371			bcc 	_TIM_GHCFail
.018363	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018365	90 0b		bcc $018372			bcc 	_TIM_GHCExit
.018367	c9 11		cmp #$11			cmp 	#65-48						; < A
.018369	90 06		bcc $018371			bcc		_TIM_GHCFail
.01836b	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.01836d	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.01836f	90 01		bcc $018372			bcc		_TIM_GHCExit
.018371					_TIM_GHCFail:
.018371	38		sec				sec
.018372					_TIM_GHCExit:
.018372	60		rts				rts
.018373					TIM_BreakVector:
.018373	da		phx				phx									; save X/A on stack
.018374	48		pha				pha
.018375	ba		tsx				tsx 								; X points to S
.018376	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.018379	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837b	d0 03		bne $018380			bne 	_TIMBreak					; if set, it's BRK
.01837d	68		pla				pla 								; abandon routine.
.01837e	fa		plx				plx
.01837f	40		rti				rti
.018380					_TIMBreak:
.018380	68		pla				pla 								; save A X Y and maybe Z
.018381	8d c9 03	sta $03c9			sta 	TIM_A
.018384	fa		plx				plx
.018385	8e ca 03	stx $03ca			stx 	TIM_X
.018388	8c cb 03	sty $03cb			sty 	TIM_Y
.01838b	68		pla				pla 								; get Status Register
.01838c	8d c8 03	sta $03c8			sta 	TIM_SR
.01838f	68		pla				pla
.018390	8d c5 03	sta $03c5			sta 	TIM_PC+1 					; save calling address
.018393	68		pla				pla
.018394	8d c4 03	sta $03c4			sta 	TIM_PC 						; high byte
.018397	ad c5 03	lda $03c5			lda 	TIM_PC+1 					; dec PC to point right.
.01839a	d0 03		bne $01839f			bne 	_TIMDecrement 				; brk bumps it.
.01839c	ce c4 03	dec $03c4			dec 	TIM_PC
.01839f					_TIMDecrement:
.01839f	ce c5 03	dec $03c5			dec 	TIM_PC+1
.0183a2	ba		tsx				tsx 								; and copy SP
.0183a3	8e cd 03	stx $03cd			stx 	TIM_SP
.0183a6	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183a8	9a		txs				txs
.0183a9	4c 88 82	jmp $018288			jmp 	TIM_Start 					; and start up TIM monitor.
.0183ac					TIM_UpdateRegisters:
.0183ac	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; PC
.0183af	b0 28		bcs $0183d9			bcs 	_TIMURFail
.0183b1	a5 14		lda $14				lda 	zTemp3
.0183b3	8d c5 03	sta $03c5			sta 	Tim_PC+1
.0183b6	a5 15		lda $15				lda 	zTemp3+1
.0183b8	8d c4 03	sta $03c4			sta 	Tim_PC
.0183bb	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; ignore IRQ
.0183be	b0 19		bcs $0183d9			bcs 	_TIMURFail
.0183c0	a2 00		ldx #$00			ldx 	#0
.0183c2					_TIM_URLoop:
.0183c2	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c4	d0 01		bne $0183c7			bne 	_TIM_1
.0183c6	e8		inx				inx
.0183c7					_TIM_1:
.0183c7	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; registers
.0183ca	b0 0d		bcs $0183d9			bcs 	_TIMURFail
.0183cc	a5 14		lda $14				lda 	zTemp3
.0183ce	9d c8 03	sta $03c8,x			sta 	Tim_SR,x
.0183d1	e8		inx				inx
.0183d2	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d4	d0 ec		bne $0183c2			bne 	_TIM_URLoop
.0183d6	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand
.0183d9					_TIMURFail:
.0183d9	4c f4 81	jmp $0181f4			jmp 	TIM_Error
.0183dc					TIM_LoadMemory:
.0183dc	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; target address => zTemp2
.0183df	a5 14		lda $14				lda 	zTemp3
.0183e1	85 12		sta $12				sta 	zTemp2
.0183e3	a5 15		lda $15				lda 	zTemp3+1
.0183e5	85 13		sta $13				sta 	zTemp2+1
.0183e7					_TIM_LMLoop:
.0183e7	20 28 83	jsr $018328			jsr 	TIM_GetHex 					; next byte ?
.0183ea	b0 0e		bcs $0183fa			bcs 	_TIMLMDone 					; no more
.0183ec	a2 00		ldx #$00			ldx 	#0							; write out.
.0183ee	a5 14		lda $14				lda 	zTemp3
.0183f0	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f2	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f4	d0 f1		bne $0183e7			bne 	_TIM_LMLoop
.0183f6	e6 13		inc $13				inc 	zTemp2+1
.0183f8	80 ed		bra $0183e7			bra 	_TIM_LMLoop
.0183fa					_TIMLMDone:
.0183fa	4c fb 81	jmp $0181fb			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.0183fd					StructureSearchSingle:
.0183fd	a2 00		ldx #$00			ldx 	#0 							; we always search for XA. This disables X.
.0183ff					StructureSearchDouble:
.0183ff	85 10		sta $10				sta 	zTemp1 						; save the targets in zTemp1,zTemp1+1
.018401	86 11		stx $11				stx 	zTemp1+1
.018403	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018405	85 12		sta $12				sta 	zTemp2
.018407	80 18		bra $018421			bra 	_SSWLoop 					; jump in, start scanning from here.
.018409					_SSWNextLine:
.018409	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840b	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.01840d	18		clc				clc
.01840e	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018410	85 18		sta $18				sta 	zCodePtr
.018412	90 02		bcc $018416			bcc 	_SNLNoCarry
.018414	e6 19		inc $19				inc 	zCodePtr+1
.018416					_SNLNoCarry:
.018416	a0 00		ldy #$00			ldy 	#0
.018418	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01841a	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841c	f0 54		beq $018472			beq 	_SSWFail
.01841e	c8		iny				iny
.01841f	c8		iny				iny
.018420					_SSWNextSimple:
.018420	c8		iny				iny
.018421					_SSWLoop:
.018421	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018423	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018425	f0 e2		beq $018409			beq 	_SSWNextLine 				; if so, then next line
.018427	10 f7		bpl $018420			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.018429	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842b	d0 08		bne $018435			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.01842d	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.01842f	f0 2d		beq $01845e			beq 	_SSWFound 					; then exit.
.018431	c5 11		cmp $11				cmp 	zTemp1+1
.018433	f0 29		beq $01845e			beq 	_SSWFound
.018435					_SSWCheckUpDown:
.018435	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.018437	90 10		bcc $018449			bcc 	_SSWNext
.018439	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843b	90 08		bcc $018445			bcc 	_SSWPlus
.01843d	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.01843f	b0 08		bcs $018449			bcs 	_SSWNext
.018441	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018443	c6 12		dec $12				dec 	zTemp2
.018445					_SSWPlus:
.018445	e6 12		inc $12				inc 	zTemp2
.018447	30 16		bmi $01845f			bmi 	_SSWUnder					; error if driven -ve
.018449					_SSWNext:
.018449	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.01844b	c8		iny				iny 								; skip
.01844c	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01844e	90 0c		bcc $01845c			bcc 	_SEDone 					; so just skip over it.
.018450	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018452	90 07		bcc $01845b			bcc 	_SEDouble
.018454	98		tya				tya 								; this is Y + 1
.018455	18		clc				clc
.018456	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018458	a8		tay				tay 								; back in Y.
.018459	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845a	88		dey				dey
.01845b					_SEDouble:
.01845b	c8		iny				iny
.01845c					_SEDone:
.01845c	80 c3		bra $018421			bra 	_SSWLoop
.01845e					_SSWFound:
.01845e	60		rts				rts
.01845f					_SSWUnder:
.01845f	20 83 85	jsr $018583			jsr ERR_Handler
>018462	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846a	65 20 6f 72 64 65 72 00
.018472					_SSWFail:
.018472	20 83 85	jsr $018583			jsr ERR_Handler
>018475	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>01847d	6e 64 20 73 74 72 75 63 74 75 72 65 00
.01848a					SkipEndOfCommand:
.01848a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01848c	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.01848e	f0 19		beq $0184a9			beq 	_SOCExit
.018490	c9 c0		cmp #$c0			cmp 	#token_Colon 				; if colon, end of command
.018492	f0 15		beq $0184a9			beq 	_SOCExit
.018494	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018496	c8		iny				iny 								; skip
.018497	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018499	90 0c		bcc $0184a7			bcc 	_SEDone 					; so just skip over it.
.01849b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01849d	90 07		bcc $0184a6			bcc 	_SEDouble
.01849f	98		tya				tya 								; this is Y + 1
.0184a0	18		clc				clc
.0184a1	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.0184a3	a8		tay				tay 								; back in Y.
.0184a4	88		dey				dey 								; fix up, one for the +1, one for the iny
.0184a5	88		dey				dey
.0184a6					_SEDouble:
.0184a6	c8		iny				iny
.0184a7					_SEDone:
.0184a7	80 e1		bra $01848a			bra 	SkipEndOfCommand
.0184a9					_SOCExit:
.0184a9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.0184aa					StackReset:
.0184aa	48		pha				pha
.0184ab	5a		phy				phy
.0184ac	a9 ca		lda #$ca			lda 	#(BasicStack & $FF) 		; reset pointer
.0184ae	85 28		sta $28				sta 	zBasicSP
.0184b0	a9 05		lda #$05			lda 	#(BasicStack >> 8)
.0184b2	85 29		sta $29				sta 	zBasicSP+1
.0184b4	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.0184b6	98		tya				tya 								; be a legal token.
.0184b7	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184b9	7a		ply				ply
.0184ba	68		pla				pla
.0184bb	60		rts				rts
.0184bc					StackPushFrame:
.0184bc	48		pha				pha
.0184bd	5a		phy				phy
.0184be	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184bf	48		pha				pha 								; save it.
.0184c0	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184c2	18		clc				clc 								; add to Basic Stack
.0184c3	65 28		adc $28				adc 	zBasicSP
.0184c5	85 28		sta $28				sta 	zBasicSP
.0184c7	90 02		bcc $0184cb			bcc 	_SPFNoBump
.0184c9	e6 29		inc $29				inc 	zBasicSP+1
.0184cb					_SPFNoBump:
.0184cb	a0 00		ldy #$00			ldy 	#0
.0184cd	68		pla				pla
.0184ce	91 28		sta ($28),y			sta 	(zBasicSP),y
.0184d0	7a		ply				ply
.0184d1	68		pla				pla
.0184d2	60		rts				rts
.0184d3					StackPopFrame:
.0184d3	48		pha				pha
.0184d4	5a		phy				phy
.0184d5	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184d7	51 28		eor ($28),y			eor 	(zBasicSP),y
.0184d9	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184db	d0 12		bne $0184ef			bne 	SPFError 					; mixed structures
.0184dd	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; get size from byte
.0184df	29 0f		and #$0f			and 	#$0F
.0184e1	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184e3	38		sec				sec
.0184e4	65 28		adc $28				adc 	zBasicSP
.0184e6	85 28		sta $28				sta 	zBasicSP
.0184e8	b0 02		bcs $0184ec			bcs 	_SPFNoBump
.0184ea	c6 29		dec $29				dec 	zBasicSP+1
.0184ec					_SPFNoBump:
.0184ec	7a		ply				ply
.0184ed	68		pla				pla
.0184ee	60		rts				rts
.0184ef					SPFError:
.0184ef	20 83 85	jsr $018583			jsr ERR_Handler
>0184f2	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184fa	72 75 63 74 75 72 65 73 00
.018503					StackSavePosition:
.018503	98		tya				tya
.018504	5a		phy				phy
.018505	a0 05		ldy #$05			ldy 	#5
.018507	91 28		sta ($28),y			sta 	(zBasicSP),y
.018509	a0 01		ldy #$01			ldy 	#1
.01850b	a5 18		lda $18				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.01850d	91 28		sta ($28),y			sta 	(zBasicSP),y
.01850f	c8		iny				iny
.018510	a5 19		lda $19				lda 	zCodePtr+1
.018512	91 28		sta ($28),y			sta 	(zBasicSP),y
.018514	c8		iny				iny
.018515	a5 1a		lda $1a				lda 	zCodePtr+2
.018517	91 28		sta ($28),y			sta 	(zBasicSP),y
.018519	c8		iny				iny
.01851a	a5 1b		lda $1b				lda 	zCodePtr+3
.01851c	91 28		sta ($28),y			sta 	(zBasicSP),y
.01851e	7a		ply				ply
.01851f	60		rts				rts
.018520					StackRestorePosition:
.018520	5a		phy				phy
.018521	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018523	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018525	85 18		sta $18				sta 	zCodePtr+0
.018527	c8		iny				iny
.018528	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852a	85 19		sta $19				sta 	zCodePtr+1
.01852c	c8		iny				iny
.01852d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.01852f	85 1a		sta $1a				sta 	zCodePtr+2
.018531	c8		iny				iny
.018532	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018534	85 1b		sta $1b				sta 	zCodePtr+3
.018536	c8		iny				iny
.018537	b1 28		lda ($28),y			lda 	(zBasicSP),y 				; offset
.018539	7a		ply				ply 								; restore Y
.01853a	a8		tay				tay
.01853b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01853c					VIOCharPrint:
.01853c	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.01853f					VIOCharGet:
.01853f	20 e3 81	jsr $0181e3			jsr 	IF_GetKey
.018542	c9 00		cmp #$00			cmp 	#0
.018544	f0 02		beq $018548			beq 	_VCG0
.018546	38		sec				sec
.018547	60		rts				rts
.018548	18		clc		_VCG0:	clc
.018549	60		rts				rts
.01854a					VIOCheckBreak:
.01854a	4c de 81	jmp $0181de			jmp 	IF_CheckBreak
.01854d					VIOCharGetPosition:
.01854d	ad 00 05	lda $0500			lda 	IFT_XCursor
.018550	60		rts				rts
.018551					VIOReadLine:
.018551	4c f7 80	jmp $0180f7			jmp 	IFT_ReadLine

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018554					SyntaxError:
.018554	20 83 85	jsr $018583			jsr 	ERR_Handler
>018557	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>01855f	72 72 6f 72 00
.018564					TypeError:
.018564	20 83 85	jsr $018583			jsr 	ERR_Handler
>018567	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>01856f	70 65 00
.018572					BadParamError:
.018572	20 83 85	jsr $018583			jsr 	ERR_Handler
>018575	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>01857d	6d 65 74 65 72 00
.018583					ERR_Handler:
.018583	a0 00		ldy #$00			ldy 	#0
.018585	c8		iny				iny
.018586	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018588	85 80		sta $80				sta 	XS_Mantissa
.01858a	c8		iny				iny
.01858b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01858d	85 81		sta $81				sta 	XS_Mantissa+1
.01858f	fa		plx				plx 								; address in XY
.018590	7a		ply				ply
.018591	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018592	d0 01		bne $018595			bne 	_EHNoSkip
.018594	c8		iny				iny
.018595					_EHNoSkip:
.018595	20 b4 85	jsr $0185b4			jsr 	PrintROMMessage 			; print message from ROM.
.018598	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01859a	05 81		ora $81				ora 	XS_Mantissa+1
.01859c	f0 0c		beq $0185aa			beq 	_EHNoLine
.01859e	a2 af		ldx #$af			ldx 	#_EHAt & $FF 				; print " at "
.0185a0	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.0185a2	20 b4 85	jsr $0185b4			jsr 	PrintROMMessage
.0185a5	a2 00		ldx #$00			ldx 	#0 							; Print line number
.0185a7	20 c9 85	jsr $0185c9			jsr 	Print16BitInteger
.0185aa					_EHNoLine:
.0185aa	80 fe		bra $0185aa			bra 	_EHNoLine
.0185ac	4c 3c 88	jmp $01883c			jmp 	WarmStart 					; normally warm start.
>0185af	20 61 74 20 00			_EHAt:	.text 	" at ",0
.0185b4					PrintROMMessage:
.0185b4	86 1c		stx $1c				stx 	zLTemp1 					; save addres
.0185b6	84 1d		sty $1d				sty 	zLTemp1+1
.0185b8	4b		phk				phk 								; get current code page
.0185b9	68		pla				pla
.0185ba	85 1e		sta $1e				sta 	ZLTemp1+2 					; put into the 3rd byte so we can use
.0185bc	a0 00		ldy #$00			ldy 	#0
.0185be					_PRMLoop:
.0185be	b7 1c		lda [$1c],y			lda 	[zLTemp1],y 				; 65816
.0185c0	f0 06		beq $0185c8			beq		_PRMExit 					; character $00 => exit
.0185c2	c8		iny				iny  								; bump Y and print it.
.0185c3	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.0185c6	80 f6		bra $0185be			bra 	_PRMLoop
.0185c8					_PRMExit:
.0185c8	60		rts				rts
.0185c9					Print16BitInteger:
.0185c9	a9 00		lda #$00			lda 	#0 							; make 32 bit
.0185cb	85 82		sta $82				sta 	XS_Mantissa+2
.0185cd	85 83		sta $83				sta 	XS_Mantissa+3
.0185cf					Print32BitInteger:
.0185cf	a9 00		lda #$00			lda 	#0
.0185d1	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185d4	aa		tax				tax 								; convert bottom level.
.0185d5	20 94 a1	jsr $01a194			jsr 	INTToString 				; make string from integer in Num_Buffer
.0185d8	a2 00		ldx #$00			ldx 	#0 							; print buffer contents
.0185da	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185dd	f0 06		beq $0185e5			beq 	_P1Exit
.0185df	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.0185e2	e8		inx				inx
.0185e3	80 f5		bra $0185da			bra 	_P1Loop
.0185e5	8a		txa		_P1Exit:txa 								; return chars printed.
.0185e6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185e7					VectorTable:
>0185e7	bf 93					.word BinaryOp_And         & $FFFF ; $80 and
>0185e9	db 93					.word BinaryOp_Or          & $FFFF ; $81 or
>0185eb	f7 93					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185ed	f7 93					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185ef	2e 94					.word Binary_Equal         & $FFFF ; $84 =
>0185f1	37 94					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185f3	40 94					.word Binary_Less          & $FFFF ; $86 <
>0185f5	49 94					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185f7	5b 94					.word Binary_Greater       & $FFFF ; $88 >
>0185f9	52 94					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185fb	f3 94					.word BinaryOp_Add         & $FFFF ; $8a +
>0185fd	0f 95					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185ff	20 95					.word BinaryOp_Multiply    & $FFFF ; $8c *
>018601	31 95					.word BinaryOp_Divide      & $FFFF ; $8d /
>018603	a5 86					.word NotImplemented       & $FFFF ; $8e ^
>018605	4e 8d					.word Command_IF           & $FFFF ; $8f if
>018607	bb 91					.word Command_WHILE        & $FFFF ; $90 while
>018609	e3 91					.word Command_REPEAT       & $FFFF ; $91 repeat
>01860b	a3 89					.word Command_FOR          & $FFFF ; $92 for
>01860d	a5 86					.word NotImplemented       & $FFFF ; $93 then
>01860f	ab 8d					.word Command_ENDIF        & $FFFF ; $94 endif
>018611	d8 91					.word Command_WEND         & $FFFF ; $95 wend
>018613	ec 91					.word Command_UNTIL        & $FFFF ; $96 until
>018615	20 8a					.word Command_NEXT         & $FFFF ; $97 next
>018617	a5 86					.word NotImplemented       & $FFFF ; $98 not
>018619	a5 86					.word NotImplemented       & $FFFF ; $99 fn(
>01861b	36 96					.word Unary_Abs            & $FFFF ; $9a abs(
>01861d	91 97					.word Unary_Asc            & $FFFF ; $9b asc(
>01861f	c2 a8					.word Unary_Int            & $FFFF ; $9c int(
>018621	50 96					.word Unary_Peek           & $FFFF ; $9d peek(
>018623	43 a8					.word Unary_Rnd            & $FFFF ; $9e rnd(
>018625	c3 96					.word Unary_Usr            & $FFFF ; $9f usr(
>018627	d0 97					.word Unary_Left           & $FFFF ; $a0 left$(
>018629	e5 97					.word Unary_Right          & $FFFF ; $a1 right$(
>01862b	b7 97					.word Unary_Mid            & $FFFF ; $a2 mid$(
>01862d	30 99					.word Unary_Spc            & $FFFF ; $a3 spc(
>01862f	5f 97					.word Unary_Str            & $FFFF ; $a4 str$(
>018631	e4 96					.word Unary_Val            & $FFFF ; $a5 val(
>018633	a8 97					.word Unary_Len            & $FFFF ; $a6 len(
>018635	5d 98					.word Unary_Hex            & $FFFF ; $a7 hex$(
>018637	a5 86					.word NotImplemented       & $FFFF ; $a8 sin(
>018639	a5 86					.word NotImplemented       & $FFFF ; $a9 cos(
>01863b	a5 86					.word NotImplemented       & $FFFF ; $aa tan(
>01863d	a5 86					.word NotImplemented       & $FFFF ; $ab atn(
>01863f	a5 86					.word NotImplemented       & $FFFF ; $ac exp(
>018641	a5 86					.word NotImplemented       & $FFFF ; $ad log(
>018643	a5 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018645	b3 98					.word Unary_Dec            & $FFFF ; $af dec(
>018647	54 96					.word Unary_Deek           & $FFFF ; $b0 deek(
>018649	58 96					.word Unary_Leek           & $FFFF ; $b1 leek(
>01864b	90 96					.word Unary_Mod            & $FFFF ; $b2 mod(
>01864d	f0 95					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>01864f	12 99					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018651	84 96					.word Unary_Pos            & $FFFF ; $b5 pos(
>018653	53 99					.word Unary_Tab            & $FFFF ; $b6 tab(
>018655	a5 86					.word NotImplemented       & $FFFF ; $b7 $
>018657	a5 86					.word NotImplemented       & $FFFF ; $b8 $(
>018659	a5 86					.word NotImplemented       & $FFFF ; $b9 #
>01865b	a5 86					.word NotImplemented       & $FFFF ; $ba #(
>01865d	a5 86					.word NotImplemented       & $FFFF ; $bb %
>01865f	a5 86					.word NotImplemented       & $FFFF ; $bc %(
>018661	a5 86					.word NotImplemented       & $FFFF ; $bd (
>018663	a5 86					.word NotImplemented       & $FFFF ; $be )
>018665	a5 86					.word NotImplemented       & $FFFF ; $bf ,
>018667	a2 89					.word Command_COLON        & $FFFF ; $c0 :
>018669	a5 86					.word NotImplemented       & $FFFF ; $c1 ;
>01866b	a5 86					.word NotImplemented       & $FFFF ; $c2 def
>01866d	9c 91					.word Command_CLR          & $FFFF ; $c3 clr
>01866f	b3 91					.word Command_STOP         & $FFFF ; $c4 stop
>018671	f9 8a					.word Command_DATA         & $FFFF ; $c5 data
>018673	d3 8a					.word Command_READ         & $FFFF ; $c6 read
>018675	49 88					.word Command_DIM          & $FFFF ; $c7 dim
>018677	a5 86					.word NotImplemented       & $FFFF ; $c8 to
>018679	a5 86					.word NotImplemented       & $FFFF ; $c9 step
>01867b	e2 90					.word Command_GOSUB        & $FFFF ; $ca gosub
>01867d	f2 90					.word Command_RETURN       & $FFFF ; $cb return
>01867f	da 90					.word Command_GOTO         & $FFFF ; $cc goto
>018681	4a 8d					.word Command_END          & $FFFF ; $cd end
>018683	19 8c					.word Command_INPUT        & $FFFF ; $ce input
>018685	97 8b					.word Command_LET          & $FFFF ; $cf let
>018687	b1 8d					.word Command_LIST         & $FFFF ; $d0 list
>018689	84 90					.word Command_NEW          & $FFFF ; $d1 new
>01868b	a0 90					.word Command_OLD          & $FFFF ; $d2 old
>01868d	fb 90					.word Command_ON           & $FFFF ; $d3 on
>01868f	fc 8a					.word Command_RESTORE      & $FFFF ; $d4 restore
>018691	53 90					.word Command_POKE         & $FFFF ; $d5 poke
>018693	a5 8f					.word Command_PRINT        & $FFFF ; $d6 print
>018695	14 89					.word Command_RUN          & $FFFF ; $d7 run
>018697	d4 88					.word Command_WAIT         & $FFFF ; $d8 wait
>018699	ff 8b					.word Command_SYS          & $FFFF ; $d9 sys
>01869b	57 90					.word Command_DOKE         & $FFFF ; $da doke
>01869d	5b 90					.word Command_LOKE         & $FFFF ; $db loke
>01869f	3b 90					.word Command_ASSERT       & $FFFF ; $dc assert
>0186a1	b5 8b					.word Command_GET          & $FFFF ; $dd get
>0186a3	a5 8d					.word Command_ELSE         & $FFFF ; $de else
.0186a5					NotImplemented:
.0186a5	20 83 85	jsr $018583			jsr ERR_Handler
>0186a8	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>0186b0	65 6d 65 6e 74 65 64 00
.0186b8					BinaryPrecedence:
>0186b8	01					.byte 1    ; $80 and
>0186b9	01					.byte 1    ; $81 or
>0186ba	01					.byte 1    ; $82 xor
>0186bb	01					.byte 1    ; $83 eor
>0186bc	02					.byte 2    ; $84 =
>0186bd	02					.byte 2    ; $85 <>
>0186be	02					.byte 2    ; $86 <
>0186bf	02					.byte 2    ; $87 <=
>0186c0	02					.byte 2    ; $88 >
>0186c1	02					.byte 2    ; $89 >=
>0186c2	03					.byte 3    ; $8a +
>0186c3	03					.byte 3    ; $8b -
>0186c4	04					.byte 4    ; $8c *
>0186c5	04					.byte 4    ; $8d /
>0186c6	05					.byte 5    ; $8e ^
.0186c7					KeywordText:
>0186c7	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>0186ca	4f d2					.byte $4f,$d2                          ; $81 or
>0186cc	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186cf	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186d2	bd					.byte $bd                              ; $84 =
>0186d3	3c be					.byte $3c,$be                          ; $85 <>
>0186d5	bc					.byte $bc                              ; $86 <
>0186d6	3c bd					.byte $3c,$bd                          ; $87 <=
>0186d8	be					.byte $be                              ; $88 >
>0186d9	3e bd					.byte $3e,$bd                          ; $89 >=
>0186db	ab					.byte $ab                              ; $8a +
>0186dc	ad					.byte $ad                              ; $8b -
>0186dd	aa					.byte $aa                              ; $8c *
>0186de	af					.byte $af                              ; $8d /
>0186df	de					.byte $de                              ; $8e ^
>0186e0	49 c6					.byte $49,$c6                          ; $8f if
>0186e2	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186e7	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186ed	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186f0	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186f4	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186f9	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186fd	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>018702	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>018706	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>018709	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>01870c	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>018710	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>018714	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>018718	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>01871d	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>018721	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>018725	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>01872b	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018732	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>018737	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>01873b	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018740	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018744	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>018748	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>01874d	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018751	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018755	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>018759	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>01875d	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018761	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018765	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>018769	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>01876d	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018772	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>018777	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>01877b	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>01877f	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018784	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>018788	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>01878c	a4					.byte $a4                              ; $b7 $
>01878d	24 a8					.byte $24,$a8                          ; $b8 $(
>01878f	a3					.byte $a3                              ; $b9 #
>018790	23 a8					.byte $23,$a8                          ; $ba #(
>018792	a5					.byte $a5                              ; $bb %
>018793	25 a8					.byte $25,$a8                          ; $bc %(
>018795	a8					.byte $a8                              ; $bd (
>018796	a9					.byte $a9                              ; $be )
>018797	ac					.byte $ac                              ; $bf ,
>018798	ba					.byte $ba                              ; $c0 :
>018799	bb					.byte $bb                              ; $c1 ;
>01879a	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>01879d	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>0187a0	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>0187a4	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>0187a8	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>0187ac	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>0187af	54 cf					.byte $54,$cf                          ; $c8 to
>0187b1	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>0187b5	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>0187ba	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>0187c0	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>0187c4	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>0187c7	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187cc	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187cf	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187d3	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187d6	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187d9	4f ce					.byte $4f,$ce                          ; $d3 on
>0187db	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187e2	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187e6	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187eb	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187ee	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187f2	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187f5	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187f9	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187fd	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>018803	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>018806	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>01880a	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.01880b					BASIC_Start:
.01880b	20 a5 81	jsr $0181a5			jsr 	IF_Reset 					; set up and clear screen.
.01880e	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.018811	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.018813	8d 10 03	sta $0310			sta 	LocalVector
.018816	8d 0c 03	sta $030c			sta 	UserVector
.018819	a9 d2		lda #$d2			lda 	#USRDefault & $FF 			; reset USR vector to a default
.01881b	8d 0d 03	sta $030d			sta 	UserVector+1 				; 24 / 16 bit address
.01881e	a9 96		lda #$96			lda 	#(USRDefault >> 8) & $FF 	; e.g. it becomes JMP USRDefault
.018820	8d 0e 03	sta $030e			sta 	UserVector+2
.018823	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.018825	8d 0f 03	sta $030f			sta 	UserVector+3
.018828	20 9a 99	jsr $01999a			jsr 	UpdateProgramEnd 			; update the program end.
.01882b	20 9c 91	jsr $01919c			jsr 	ResetRunStatus 				; clear everything (CLR command)
.01882e	c2 30		rep #$30			rep 	#$30
.018830	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018833	1b		tcs				tcs
.018834	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018837	e2 30		sep #$30			sep 	#$30
.018839	4c 14 89	jmp $018914			jmp 	COMMAND_Run
.01883c					WarmStart:
.01883c	c2 30		rep #$30			rep 	#$30
.01883e	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018841	1b		tcs				tcs
.018842	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018845	e2 30		sep #$30			sep 	#$30
.018847	80 f3		bra $01883c			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.018849					Command_DIM:
.018849	98		tya				tya
.01884a	48		pha				pha 								; push on stack.
.01884b	20 1d 9d	jsr $019d1d			jsr 	VariableExtract 			; get the identifier
.01884e	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018851	29 01		and #$01			and 	#1
.018853	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018855	d0 6f		bne $0188c6			bne 	_CDIError
.018857	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.018859	8d b9 03	sta $03b9			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.01885c					_CDIGetDimension:
.01885c	ad b9 03	lda $03b9			lda 	UsrArrayIdx 				; done too many ?
.01885f	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018861	f0 63		beq $0188c6			beq 	_CDIError
.018863	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; evaluate an index size
.018866	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.018868	29 80		and #$80			and 	#$80
.01886a	05 82		ora $82				ora 	XS_Mantissa+2
.01886c	05 83		ora $83				ora 	XS_Mantissa+3
.01886e	d0 56		bne $0188c6			bne 	_CDIError
.018870	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy into the array table.
.018873	18		clc				clc 								; add 1 - max index => size.
.018874	a5 80		lda $80				lda 	XS_Mantissa+0
.018876	69 01		adc #$01			adc 	#1
.018878	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+0,x
.01887b	a5 81		lda $81				lda 	XS_Mantissa+1
.01887d	69 00		adc #$00			adc 	#0
.01887f	9d b2 03	sta $03b2,x			sta 	UsrArrayDef+1,x
.018882	30 42		bmi $0188c6			bmi 	_CDIError 					; could be dim a(32767)
.018884	e8		inx				inx 								; bump index.
.018885	e8		inx				inx
.018886	8e b9 03	stx $03b9			stx 	UsrArrayIdx
.018889	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01888b	c8		iny				iny
.01888c	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.01888e	f0 cc		beq $01885c			beq 	_CDIGetDimension
.018890	88		dey				dey
.018891	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; closing ) present ?
.018894	ae b9 03	ldx $03b9			ldx 	UsrArrayIdx 				; copy USR array to default
.018897	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.018899	9d aa 03	sta $03aa,x			sta 	ArrayDef+1,x
.01889c					_CDICopy:
.01889c	bd b1 03	lda $03b1,x			lda 	UsrArrayDef,x
.01889f	9d a9 03	sta $03a9,x			sta 	ArrayDef,x
.0188a2	ca		dex				dex
.0188a3	10 f7		bpl $01889c			bpl 	_CDICopy
.0188a5	68		pla				pla									; position of array identifier
.0188a6	85 10		sta $10				sta 	zTemp1
.0188a8	98		tya				tya
.0188a9	48		pha				pha
.0188aa	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.0188ac	a8		tay				tay
.0188ad	20 1d 9d	jsr $019d1d			jsr 	VariableExtract 			; get the identifier
.0188b0	20 b6 9f	jsr $019fb6			jsr 	VariableLocate 				; check if it exists already.
.0188b3	b0 11		bcs $0188c6			bcs 	_CDIError
.0188b5	20 a9 9d	jsr $019da9			jsr 	VariableCreate 				; create it using the current ArrayDef
.0188b8	68		pla				pla 								; restore code position
.0188b9	a8		tay				tay
.0188ba	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188bc	c8		iny				iny
.0188bd	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.0188bf	f0 88		beq $018849			beq 	Command_DIM
.0188c1	88		dey				dey
.0188c2	20 b8 9e	jsr $019eb8			jsr 	ArrayResetDefault 			; subsequent automatic DIMs will be (10)
.0188c5	60		rts				rts
.0188c6					_CDIError:
.0188c6	20 83 85	jsr $018583			jsr ERR_Handler
>0188c9	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188d1					_CDISyntax:
.0188d1	4c 54 85	jmp $018554			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188d4					Command_WAIT:
.0188d4	20 a0 93	jsr $0193a0			jsr		EvaluateInteger 			; get address to monitor
.0188d7	a2 06		ldx #$06			ldx 	#XS_Size 					; get and mask
.0188d9	20 fe 99	jsr $0199fe			jsr 	CheckNextComma
.0188dc	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX
.0188df	a9 00		lda #$00			lda 	#0							; set default xor value.
.0188e1	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188e3	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0188e5	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188e7	d0 06		bne $0188ef			bne 	_CWAXorDefault
.0188e9	c8		iny				iny
.0188ea	a2 0c		ldx #$0c			ldx 	#XS_Size*2					; and get the xor value
.0188ec	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX
.0188ef					_CWAXorDefault:
.0188ef	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188f1	85 1c		sta $1c				sta 	zLTemp1
.0188f3	a5 81		lda $81				lda 	XS_Mantissa+1
.0188f5	85 1d		sta $1d				sta 	zLTemp1+1
.0188f7	a5 82		lda $82				lda 	XS_Mantissa+2
.0188f9	85 1e		sta $1e				sta 	zLTemp1+2
.0188fb					_CWAWaitLoop:
.0188fb	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; exit on break.
.0188fe	c9 00		cmp #$00			cmp 	#0
.018900	d0 11		bne $018913			bne 	_CWAWaitExit
.018902	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.018904	a2 00		ldx #$00			ldx 	#0
.018906	5a		phy				phy 								; this is the same routine as PEEK.
.018907	20 78 99	jsr $019978			jsr 	MemRead
.01890a	7a		ply				ply
.01890b	a5 80		lda $80				lda 	XS_Mantissa+0 				; get byte
.01890d	25 86		and $86				and 	XS_Mantissa+XS_Size 		; and it
.01890f	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2		; eor it.
.018911	f0 e8		beq $0188fb			beq 	_CWAWaitLoop 				; and loop if zero.
.018913					_CWAWaitExit:
.018913	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.018914					Command_RUN:
.018914	20 9c 91	jsr $01919c			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.018917	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018919	85 18		sta $18				sta 	zCodePtr+0
.01891b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01891d	85 19		sta $19				sta 	zCodePtr+1
.01891f	a9 00		lda #$00			lda 	#0
.018921	85 1a		sta $1a				sta 	zCodePtr+2
.018923	85 1b		sta $1b				sta 	zCodePtr+3
.018925	a0 03		ldy #$03			ldy 	#3
.018927					RUN_NewLine:
.018927	a0 00		ldy #$00			ldy 	#0
.018929	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01892b	c8		iny				iny
.01892c	c8		iny				iny
.01892d	c8		iny				iny
.01892e	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.018930	d0 16		bne $018948			bne 	RUN_NextCommand
.018932	4c 4a 8d	jmp $018d4a			jmp 	Command_END 				; go do the command code.
.018935					RUN_Skip:
.018935	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018937	c8		iny				iny 								; skip
.018938	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.01893a	90 0c		bcc $018948			bcc 	_SEDone 					; so just skip over it.
.01893c	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01893e	90 07		bcc $018947			bcc 	_SEDouble
.018940	98		tya				tya 								; this is Y + 1
.018941	18		clc				clc
.018942	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018944	a8		tay				tay 								; back in Y.
.018945	88		dey				dey 								; fix up, one for the +1, one for the iny
.018946	88		dey				dey
.018947					_SEDouble:
.018947	c8		iny				iny
.018948					_SEDone:
.018948					RUN_NextCommand:
.018948	ad a8 03	lda $03a8			lda 	BreakCount 					; break counter
.01894b	69 10		adc #$10			adc 	#16 						; one time in 16
.01894d	8d a8 03	sta $03a8			sta 	BreakCount
.018950	90 0a		bcc $01895c			bcc 	RUN_NoCheckBreak
.018952	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; check for break
.018955	c9 00		cmp #$00			cmp 	#0
.018957	f0 03		beq $01895c			beq 	RUN_NoCheckBreak
.018959	4c b3 91	jmp $0191b3			jmp 	Command_STOP 				; stop on BREAK.
.01895c					RUN_NoCheckBreak:
.01895c	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01895e	85 23		sta $23				sta 	zTempStr+1 					; (initialised when first called)
.018960	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018962	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018964	f0 cf		beq $018935			beq 	RUN_Skip
.018966	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018968	d0 0f		bne $018979			bne 	RUN_Execute
.01896a					RUN_NextLine:
.01896a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01896c	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.01896e	18		clc				clc
.01896f	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018971	85 18		sta $18				sta 	zCodePtr
.018973	90 02		bcc $018977			bcc 	_SNLNoCarry
.018975	e6 19		inc $19				inc 	zCodePtr+1
.018977					_SNLNoCarry:
.018977	80 ae		bra $018927			bra 	RUN_NewLine 				; go do the new line code
.018979					RUN_Execute:
.018979	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01897b	b0 1e		bcs $01899b			bcs 	RUN_Extension
.01897d	c8		iny				iny
.01897e	0a		asl a				asl 	a 							; double the character read.
.01897f	90 14		bcc $018995			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018981	aa		tax				tax 								; ready to look up.
.018982	bf e7 85 01	lda $0185e7,x			lda 	VectorTable,x 				; copy address into LocalVector
.018986	8d 11 03	sta $0311			sta 	LocalVector+1
.018989	bf e8 85 01	lda $0185e8,x			lda 	VectorTable+1,x
.01898d	8d 12 03	sta $0312			sta 	LocalVector+2
.018990	20 ed 92	jsr $0192ed			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018993	80 b3		bra $018948			bra 	RUN_NextCommand 			; do the next command.
.018995					RUN_Default:
.018995	88		dey				dey
.018996	20 97 8b	jsr $018b97			jsr 	Command_LET 				; and try LET.
.018999	80 ad		bra $018948			bra 	RUN_NextCommand
.01899b					RUN_Extension:
.01899b	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01899d	f0 96		beq $018935			beq 	RUN_Skip 					; skip over it.
.01899f	4c 54 85	jmp $018554			jmp 	SyntaxError
.0189a2					Command_COLON:
.0189a2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/for.asm

.0189a3					Command_FOR:
.0189a3	20 97 8b	jsr $018b97			jsr 	Command_LET 				; do the A = 99 bit
.0189a6	a5 26		lda $26				lda 	zVarType 					; obviously has to be integer/real.
.0189a8	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0189aa	f0 71		beq $018a1d			beq 	_CFOError
.0189ac	48		pha				pha 								; save the variable type.
.0189ad	5a		phy				phy 								; save type/variable address.
.0189ae	a0 01		ldy #$01			ldy 	#1							; type at + 1
.0189b0	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189b2	c8		iny				iny
.0189b3	a5 24		lda $24				lda 	zVarDataPtr 				; data low at +2
.0189b5	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189b7	c8		iny				iny
.0189b8	a5 25		lda $25				lda 	zVarDataPtr+1 				; data high at +3
.0189ba	91 28		sta ($28),y			sta 	(zBasicSP),y
.0189bc	7a		ply				ply
.0189bd	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3
.0189bf	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on the stack with FOR marker.
.0189c2	a9 c8		lda #$c8			lda 	#token_TO
.0189c4	20 df 99	jsr $0199df			jsr 	CheckNextToken
.0189c7	a2 00		ldx #$00			ldx 	#0 							; put in Mantissa, bottom
.0189c9	20 0a 92	jsr $01920a			jsr 	EvaluateExpression
.0189cc	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0189ce	a2 06		ldx #$06			ldx 	#XS_Size 					; X to second level
.0189d0	c9 c9		cmp #$c9			cmp 	#token_STEP
.0189d2	d0 06		bne $0189da			bne 	_CFOStep1
.0189d4	c8		iny				iny
.0189d5	20 0c 92	jsr $01920c			jsr 	EvaluateExpressionX 		; get STEP value.
.0189d8	80 0e		bra $0189e8			bra 	_CFOHaveStep
.0189da					_CFOStep1:
.0189da	a9 00		lda #$00			lda 	#0							; set step to integer 1.
.0189dc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0189de	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0189e0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0189e2	a9 01		lda #$01			lda 	#1
.0189e4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0189e6	95 85		sta $85,x			sta 	XS_Type,x
.0189e8					_CFOHaveStep:
.0189e8	68		pla				pla 								; restore variable type
.0189e9	a2 00		ldx #$00			ldx 	#0
.0189eb	c9 bb		cmp #$bb			cmp 	#token_Percent 				; do conversion to type
.0189ed	f0 0a		beq $0189f9			beq 	_CFOInteger
.0189ef	20 c3 a5	jsr $01a5c3			jsr 	FPUToFloat
.0189f2	a2 06		ldx #$06			ldx 	#6
.0189f4	20 c3 a5	jsr $01a5c3			jsr 	FPUToFloat
.0189f7	80 08		bra $018a01			bra 	_CFOEndConv
.0189f9					_CFOInteger:
.0189f9	20 0f a6	jsr $01a60f			jsr 	FPUToInteger
.0189fc	a2 06		ldx #$06			ldx 	#6
.0189fe	20 0f a6	jsr $01a60f			jsr 	FPUToInteger
.018a01					_CFOEndConv:
.018a01	20 03 85	jsr $018503			jsr 	StackSavePosition 			; save the loop position at 1-5
.018a04	a9 55		lda #$55			lda 	#(SMark_For << 4)+SourcePosSize
.018a06	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push the loop address frame.
.018a09	5a		phy				phy
.018a0a	a0 00		ldy #$00			ldy 	#0
.018a0c					_CFOCopy:
.018a0c	b9 80 00	lda $0080,y			lda 	XS_Mantissa+0,y
.018a0f	c8		iny				iny
.018a10	91 28		sta ($28),y			sta 	(zBasicSP),y
.018a12	c0 0c		cpy #$0c			cpy 	#XS_Size*2
.018a14	d0 f6		bne $018a0c			bne 	_CFOCopy
.018a16	7a		ply				ply
.018a17	a9 5c		lda #$5c			lda 	#(SMark_For << 4)+(XS_Size*2)
.018a19	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018a1c	60		rts				rts
.018a1d					_CFOError:
.018a1d	4c 64 85	jmp $018564			jmp 	TypeError 					; wrong type.
.018a20					Command_NEXT:
.018a20	a9 00		lda #$00			lda 	#0 							; set variable data pointer+1 to zero
.018a22	85 25		sta $25				sta 	zVarDataPtr+1 				; this means we don't check
.018a24	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018a26	c9 00		cmp #$00			cmp 	#0 							; EOL
.018a28	f0 07		beq $018a31			beq 	_CNextNoVariable
.018a2a	c9 40		cmp #$40			cmp 	#$40
.018a2c	b0 03		bcs $018a31			bcs 	_CNextNoVariable
.018a2e	20 b2 9c	jsr $019cb2			jsr 	VariableFind
.018a31					_CNextNoVariable:
.018a31	a5 28		lda $28				lda 	zBasicSP 					; save on stack
.018a33	48		pha				pha
.018a34	a5 29		lda $29				lda 	zBasicSP+1
.018a36	48		pha				pha
.018a37	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop loop address frame
.018a39	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a3c	a9 50		lda #$50			lda 	#(SMark_For << 4) 			; pop STEP/TARGET frame.
.018a3e	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a41	a9 50		lda #$50			lda 	#(Smark_For << 4) 			; pop variable address frame.
.018a43	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018a46	a5 25		lda $25				lda 	zVarDataPtr+1 				; if zero, then no variable provided
.018a48	f0 11		beq $018a5b			beq 	_CNextGetTarget 			; e.g. just NEXT not NEXT x
.018a4a	5a		phy				phy 								; check addresses match.
.018a4b	a0 02		ldy #$02			ldy 	#2
.018a4d	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a4f	c5 24		cmp $24				cmp 	zVarDataPtr
.018a51	d0 69		bne $018abc			bne 	_CNextWrong
.018a53	c8		iny				iny
.018a54	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a56	c5 25		cmp $25				cmp 	zVarDataPtr+1
.018a58	d0 62		bne $018abc			bne 	_CNextWrong
.018a5a	7a		ply				ply
.018a5b					_CNextGetTarget:
.018a5b	5a		phy				phy
.018a5c	a0 01		ldy #$01			ldy 	#1 							; restore variable type and data.
.018a5e	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a60	85 26		sta $26				sta 	zVarType
.018a62	c8		iny				iny
.018a63	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a65	85 24		sta $24				sta 	zVarDataPtr
.018a67	c8		iny				iny
.018a68	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a6a	85 25		sta $25				sta 	zVarDataPtr+1
.018a6c	a2 0c		ldx #$0c			ldx 	#12
.018a6e	20 fa 9f	jsr $019ffa			jsr 	VariableGet 				; get that variable value into expr[2]
.018a71	a2 00		ldx #$00			ldx 	#0 							; copy stacked Target/Step into expr[0] and [1]
.018a73	a0 0b		ldy #$0b			ldy 	#11
.018a75					_CNXCopy:
.018a75	b1 28		lda ($28),y			lda 	(zBasicSP),y
.018a77	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018a79	e8		inx				inx
.018a7a	c8		iny				iny
.018a7b	e0 0c		cpx #$0c			cpx 	#XS_Size*2
.018a7d	d0 f6		bne $018a75			bne 	_CNXCopy
.018a7f	7a		ply				ply
.018a80	a2 06		ldx #$06			ldx 	#6 							; point at expr[1] s
.018a82	20 14 96	jsr $019614			jsr 	GetSignCurrent
.018a85	8d a7 03	sta $03a7			sta 	SignNext 					; save in temporary.
.018a88	a2 06		ldx #$06			ldx 	#6 							; add them, however
.018a8a	20 f3 94	jsr $0194f3			jsr 	BinaryOp_Add
.018a8d	20 4b a0	jsr $01a04b			jsr 	VariableSet					; and write variable back.
.018a90	a2 00		ldx #$00			ldx 	#0
.018a92	20 77 94	jsr $019477			jsr 	CompareValues
.018a95	09 00		ora #$00			ora 	#0
.018a97	f0 05		beq $018a9e			beq 	_CNXAgain 					; if true, then do it again.
.018a99	cd a7 03	cmp $03a7			cmp 	SignNext 					; if sign different, then loop has finished.
.018a9c	d0 0f		bne $018aad			bne 	_CNXLoopDone
.018a9e					_CNXAgain:
.018a9e	a9 53		lda #$53			lda 	#(SMark_For << 4) + 3		; re-stack variable address
.018aa0	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018aa3	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; get restore position back, e.g. loop round.
.018aa6	68		pla				pla
.018aa7	85 29		sta $29				sta 	zBasicSP+1
.018aa9	68		pla				pla
.018aaa	85 28		sta $28				sta 	zBasicSP
.018aac					_CNXExit:
.018aac	60		rts				rts
.018aad					_CNXLoopDone:
.018aad	68		pla				pla 								; throw away saved to Basic Stack Pointer
.018aae	68		pla				pla
.018aaf	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ab1	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma ?
.018ab3	d0 f7		bne $018aac			bne 	_CNXExit
.018ab5	c8		iny				iny
.018ab6	20 b2 9c	jsr $019cb2			jsr 	VariableFind 				; identify the variable
.018ab9	4c 31 8a	jmp $018a31			jmp 	_CNextNoVariable 			; go back with variable pre-found
.018abc					_CNextWrong:
.018abc	20 83 85	jsr $018583			jsr ERR_Handler
>018abf	57 72 6f 6e 67 20 4e 65			.text "Wrong Next Variable",0
>018ac7	78 74 20 56 61 72 69 61 62 6c 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/read.asm

.018ad3					Command_READ:
.018ad3	20 b2 9c	jsr $019cb2			jsr 	VariableFind 				; get variable/value into zVarDataPtr,zVarType
.018ad6	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018ad8	48		pha				pha
.018ad9	a5 25		lda $25				lda 	zVarDataPtr+1
.018adb	48		pha				pha
.018adc	a5 26		lda $26				lda 	zVarType
.018ade	48		pha				pha
.018adf	20 25 8b	jsr $018b25			jsr 	READGetDataItem 			; get the next data item
.018ae2	68		pla				pla 								; restore target variable information.
.018ae3	85 26		sta $26				sta 	zVarType
.018ae5	68		pla				pla
.018ae6	85 25		sta $25				sta 	zVarDataPtr+1
.018ae8	68		pla				pla
.018ae9	85 24		sta $24				sta 	zVarDataPtr
.018aeb	a2 00		ldx #$00			ldx 	#0
.018aed	20 4b a0	jsr $01a04b			jsr 	VariableSet 				; set the value out.
.018af0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018af2	c8		iny				iny
.018af3	c9 bf		cmp #$bf			cmp 	#token_Comma
.018af5	f0 dc		beq $018ad3			beq 	Command_READ 				; found, do another READ
.018af7	88		dey				dey
.018af8	60		rts				rts
.018af9					Command_DATA:
.018af9	4c 8a 84	jmp $01848a			jmp 	SkipEndOfCommand
.018afc					Command_RESTORE:
.018afc	48		pha				pha
.018afd	a9 00		lda #$00			lda 	#0 							; this being zero means 'initialise next read'
.018aff	8d bd 03	sta $03bd			sta 	DataLPtr+0
.018b02	8d be 03	sta $03be			sta 	DataLPtr+1
.018b05	68		pla				pla
.018b06	60		rts				rts
.018b07					READSwapPointers:
.018b07	98		tya				tya
.018b08	48		pha				pha 								; save it
.018b09	ad c1 03	lda $03c1			lda 	DataIndex 					; get data offset, and copy to offset
.018b0c	a8		tay				tay
.018b0d	68		pla				pla 								; get code offset and save in DataIndex
.018b0e	8d c1 03	sta $03c1			sta 	DataIndex
.018b11	da		phx				phx
.018b12	a2 03		ldx #$03			ldx 	#3 							; swap the Data Pointers (4 bytes) round.
.018b14					_RSWLoop:
.018b14	bd bd 03	lda $03bd,x			lda 	DataLPtr+0,x
.018b17	48		pha				pha
.018b18	b5 18		lda $18,x			lda 	zCodePtr+0,x
.018b1a	9d bd 03	sta $03bd,x			sta 	DataLPtr+0,x
.018b1d	68		pla				pla
.018b1e	95 18		sta $18,x			sta 	zCodePtr+0,x
.018b20	ca		dex				dex
.018b21	10 f1		bpl $018b14			bpl 	_RSWLoop
.018b23	fa		plx				plx
.018b24	60		rts				rts
.018b25					READGetDataItem:
.018b25	20 07 8b	jsr $018b07			jsr 	ReadSwapPointers 			; swap code and data pointer.
.018b28	a5 18		lda $18				lda		zCodePtr+0 					; initialise ?
.018b2a	05 19		ora $19				ora 	zCodePtr+1
.018b2c	d0 12		bne $018b40			bne 	_RGDIIsInitialised
.018b2e	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018b30	85 18		sta $18				sta 	zCodePtr+0
.018b32	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018b34	85 19		sta $19				sta 	zCodePtr+1
.018b36	a9 00		lda #$00			lda 	#0
.018b38	85 1a		sta $1a				sta 	zCodePtr+2
.018b3a	85 1b		sta $1b				sta 	zCodePtr+3
.018b3c	a0 03		ldy #$03			ldy 	#3
.018b3e	80 06		bra $018b46			bra 	_RGDIFindData 				; locate next data from start and read that.
.018b40					_RGDIIsInitialised:
.018b40	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b42	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b44	f0 49		beq $018b8f			beq 	_RGDISkipEvaluateExit
.018b46					_RGDIFindData:
.018b46	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b48	c9 00		cmp #$00			cmp 	#0 							; end of line
.018b4a	f0 19		beq $018b65			beq 	_RGDIFindNextLine
.018b4c	c9 c5		cmp #$c5			cmp 	#token_DATA 				; found data token
.018b4e	f0 3f		beq $018b8f			beq 	_RGDISkipEvaluateExit 		; then skip it and evaluate
.018b50	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018b52	c8		iny				iny 								; skip
.018b53	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018b55	90 0c		bcc $018b63			bcc 	_SEDone 					; so just skip over it.
.018b57	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018b59	90 07		bcc $018b62			bcc 	_SEDouble
.018b5b	98		tya				tya 								; this is Y + 1
.018b5c	18		clc				clc
.018b5d	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018b5f	a8		tay				tay 								; back in Y.
.018b60	88		dey				dey 								; fix up, one for the +1, one for the iny
.018b61	88		dey				dey
.018b62					_SEDouble:
.018b62	c8		iny				iny
.018b63					_SEDone:
.018b63	80 e1		bra $018b46			bra 	_RGDIFindData
.018b65					_RGDIFindNextLine:
.018b65	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018b67	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018b69	18		clc				clc
.018b6a	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018b6c	85 18		sta $18				sta 	zCodePtr
.018b6e	90 02		bcc $018b72			bcc 	_SNLNoCarry
.018b70	e6 19		inc $19				inc 	zCodePtr+1
.018b72					_SNLNoCarry:
.018b72	a0 00		ldy #$00			ldy 	#0
.018b74	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018b76	48		pha				pha
.018b77	c8		iny				iny
.018b78	c8		iny				iny
.018b79	c8		iny				iny
.018b7a	68		pla				pla
.018b7b	d0 c9		bne $018b46			bne 	_RGDIFindData 				; back to scanning.
.018b7d	20 07 8b	jsr $018b07			jsr 	ReadSwapPointers 			; so we get error in line number of READ
.018b80	20 83 85	jsr $018583			jsr ERR_Handler
>018b83	4f 75 74 20 6f 66 20 44			.text "Out of Data",0
>018b8b	61 74 61 00
.018b8f					_RGDISkipEvaluateExit:
.018b8f	c8		iny				iny
.018b90	20 0a 92	jsr $01920a			jsr 	EvaluateExpression 			; evaluate the expression
.018b93	20 07 8b	jsr $018b07			jsr 	ReadSwapPointers 			; swap the pointers around.
.018b96	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018b97					Command_LET:
.018b97	20 b2 9c	jsr $019cb2			jsr 	VariableFind 				; get reference to one variable.
.018b9a	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018b9c	20 df 99	jsr $0199df			jsr 	CheckNextToken
.018b9f	a5 24		lda $24				lda 	zVarDataPtr 				; save variable info on stack
.018ba1	48		pha				pha
.018ba2	a5 25		lda $25				lda 	zVarDataPtr+1
.018ba4	48		pha				pha
.018ba5	a5 26		lda $26				lda 	zVarType
.018ba7	48		pha				pha
.018ba8	20 0a 92	jsr $01920a			jsr 	EvaluateExpression 			; evaluate the RHS, set X to zero.
.018bab	68		pla				pla 								; restore target variable information.
.018bac	85 26		sta $26				sta 	zVarType
.018bae	68		pla				pla
.018baf	85 25		sta $25				sta 	zVarDataPtr+1
.018bb1	68		pla				pla
.018bb2	85 24		sta $24				sta 	zVarDataPtr
.018bb4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/get.asm

.018bb5					Command_GET:
.018bb5					_CGLoop:
.018bb5	20 b2 9c	jsr $019cb2			jsr 	VariableFind 				; get a variable.
.018bb8	20 3f 85	jsr $01853f			jsr 	VIOCharGet 					; get character
.018bbb	b0 02		bcs $018bbf			bcs 	_CGNoKey
.018bbd	a9 00		lda #$00			lda 	#0 							; if no character return zero
.018bbf					_CGNoKey:
.018bbf	48		pha				pha
.018bc0	a5 26		lda $26				lda 	zVarType 					; look at the data type.
.018bc2	c9 b7		cmp #$b7			cmp 	#token_Dollar
.018bc4	f0 1e		beq $018be4			beq 	_CGString
.018bc6	68		pla				pla 								; put character in slot.
.018bc7	85 80		sta $80				sta 	XS_Mantissa
.018bc9	a9 00		lda #$00			lda 	#0
.018bcb	85 81		sta $81				sta 	XS_Mantissa+1
.018bcd	85 82		sta $82				sta 	XS_Mantissa+2
.018bcf	85 83		sta $83				sta 	XS_Mantissa+3
.018bd1	a9 01		lda #$01			lda 	#1 							; type integer
.018bd3	85 85		sta $85				sta 	XS_Type
.018bd5					_CGWriteSetNext:
.018bd5	a2 00		ldx #$00			ldx 	#0 							; write number/WriteTempString out
.018bd7	20 4b a0	jsr $01a04b			jsr 	VariableSet
.018bda	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018bdc	c9 bf		cmp #$bf			cmp 	#token_Comma 				; if not comma exit
.018bde	d0 03		bne $018be3			bne 	_CGExit
.018be0	c8		iny				iny
.018be1	80 d2		bra $018bb5			bra 	_CGLoop 					; and get another.
.018be3					_CGExit:
.018be3	60		rts				rts
.018be4					_CGString:
.018be4	a9 02		lda #$02			lda 	#2 							; allocate temp string, space for 2.
.018be6	20 43 9a	jsr $019a43			jsr 	AllocateTempString 			; initially empty.
.018be9	a5 22		lda $22				lda 	zTempStr 					; set up to be returned.
.018beb	85 80		sta $80				sta 	XS_Mantissa
.018bed	a5 23		lda $23				lda 	zTempStr+1
.018bef	85 81		sta $81				sta 	XS_Mantissa+1
.018bf1	a9 02		lda #$02			lda 	#2
.018bf3	85 85		sta $85				sta 	XS_Type
.018bf5	68		pla				pla 								; get A
.018bf6	c9 00		cmp #$00			cmp 	#0
.018bf8	f0 db		beq $018bd5			beq 	_CGWriteSetNext
.018bfa	20 6e 9a	jsr $019a6e			jsr 	WriteTempString 			; write it into string
.018bfd	80 d6		bra $018bd5			bra 	_CGWriteSetNext

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018bff					Command_SYS:
.018bff	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; address to call.
.018c02	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018c04	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.018c07	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.018c09	8d 11 03	sta $0311			sta 	LocalVector+1
.018c0c	a5 82		lda $82				lda 	XS_Mantissa+2
.018c0e	8d 12 03	sta $0312			sta 	LocalVector+2
.018c11	22 16 8c 01	jsl $018c16			jsl 	_CSYLocalCall 				; jump depending on 24/16 bit code address
.018c15	60		rts				rts
.018c16					_CSYLocalCall:
.018c16	dc 10 03	jmp [$0310]			jmp 	[LocalVector]		 		; address

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/input.asm

.018c19					Command_INPUT:
.018c19	a9 00		lda #$00		lda 	#0 								; clear number of characters required.
.018c1b	8d c2 03	sta $03c2		sta 	InputAvailable 					; save character count
.018c1e	8d c3 03	sta $03c3		sta 	InputRetry
.018c21					_CILoop:
.018c21	a9 00		lda #$00		lda 	#0 								; this resets temporary string allocation.
.018c23	85 23		sta $23			sta 	zTempStr+1 						; (could get lots of long strings)
.018c25	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c27	c9 fe		cmp #$fe		cmp 	#$FE 							; is it a prompt string
.018c29	d0 15		bne $018c40		bne 	_CINoPrompt
.018c2b	c8		iny				iny
.018c2c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c2e	aa		tax			tax 									; into X
.018c2f	c8		iny				iny
.018c30	ca		dex			dex 									; deduct marker/prompt length
.018c31	ca		dex			dex
.018c32	f0 ed		beq $018c21		beq 	_CILoop 						; nothing.
.018c34					_CIShowPrompt:
.018c34	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c36	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018c39	c8		iny				iny
.018c3a	ca		dex			dex
.018c3b	d0 f7		bne $018c34		bne 	_CIShowPrompt
.018c3d	80 e2		bra $018c21		bra 	_CILoop
.018c3f					_CIAdvance:
.018c3f	c8		iny				iny
.018c40					_CINoPrompt:
.018c40	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018c42	c9 bf		cmp #$bf		cmp 	#token_Comma 					; skip , and ;
.018c44	f0 f9		beq $018c3f		beq 	_CIAdvance
.018c46	c9 c1		cmp #$c1		cmp 	#token_SemiColon
.018c48	f0 f5		beq $018c3f		beq 	_CIAdvance
.018c4a	c9 00		cmp #$00		cmp 	#0 								; exit if 0 or :
.018c4c	f0 04		beq $018c52		beq 	_CIExit
.018c4e	c9 c0		cmp #$c0		cmp 	#token_Colon
.018c50	d0 01		bne $018c53		bne 	_CIIsVariable  					; if not then there#s a variable or should be !
.018c52					_CIExit:
.018c52	60		rts			rts
.018c53					_CIIsVariable:
.018c53	20 b2 9c	jsr $019cb2		jsr 	VariableFind 					; set zVarType and zVarDataPtr accordingly.
.018c56	a5 26		lda $26			lda 	zVarType
.018c58	c9 b7		cmp #$b7		cmp 	#token_Dollar 					; is it a string ?
.018c5a	f0 40		beq $018c9c		beq 	_CIIsString
.018c5c					_CINGetText:
.018c5c	a9 00		lda #$00		lda 	#0
.018c5e	8d 14 03	sta $0314		sta 	NumBufX
.018c61					_CINSkip:
.018c61	20 fb 8c	jsr $018cfb		jsr 	CIGetCharacter 					; get character skip spaces
.018c64	c9 20		cmp #$20		cmp 	#" "
.018c66	f0 f9		beq $018c61		beq 	_CINSkip
.018c68	c9 2c		cmp #$2c		cmp 	#","
.018c6a	f0 f5		beq $018c61		beq 	_CINSkip
.018c6c					_CINLoop:
.018c6c	ae 14 03	ldx $0314		ldx 	NumBufX 						; output character
.018c6f	9d 15 03	sta $0315,x		sta 	Num_Buffer,x
.018c72	a9 00		lda #$00		lda 	#0 								; add trailing NULL
.018c74	9d 16 03	sta $0316,x		sta 	Num_Buffer+1,x
.018c77	ee 14 03	inc $0314		inc 	NumBufX 						; bump ptr
.018c7a	20 fb 8c	jsr $018cfb		jsr 	CIGetCharacter 					; get next character
.018c7d	c9 3a		cmp #$3a		cmp 	#":" 							; stop on : ,
.018c7f	f0 08		beq $018c89		beq 	_CINCopied
.018c81	c9 2c		cmp #$2c		cmp 	#","
.018c83	f0 04		beq $018c89		beq 	_CINCopied
.018c85	c9 21		cmp #$21		cmp 	#" "+1
.018c87	b0 e3		bcs $018c6c		bcs 	_CINLoop
.018c89					_CINCopied:
.018c89	a2 00		ldx #$00		ldx 	#0
.018c8b	20 23 97	jsr $019723		jsr 	ConvertNumBuffer 				; convert number
.018c8e	b0 05		bcs $018c95		bcs 	_CINFailed 						; didn't work.
.018c90	20 4b a0	jsr $01a04b		jsr 	VariableSet 					; set variable.
.018c93	80 8c		bra $018c21		bra 	_CILoop 						; go round again.
.018c95					_CINFailed:
.018c95	a9 00		lda #$00		lda 	#0 								; set to request input next time.
.018c97	8d c2 03	sta $03c2		sta 	InputAvailable
.018c9a	80 c0		bra $018c5c		bra 	_CINGetText 					; and try again
.018c9c					_CIIsString:
.018c9c	a9 82		lda #$82		lda 	#130 							; max of 128 characters
.018c9e	20 43 9a	jsr $019a43		jsr 	AllocateTempString
.018ca1	a9 00		lda #$00		lda 	#0 								; this is the quote flag.
.018ca3	8d 14 03	sta $0314		sta 	NumBufX
.018ca6					_CISSkip:
.018ca6	20 fb 8c	jsr $018cfb		jsr 	CIGetCharacter 					; get character skip spaces
.018ca9	c9 20		cmp #$20		cmp 	#" "
.018cab	f0 f9		beq $018ca6		beq 	_CISSkip
.018cad	80 03		bra $018cb2		bra 	_CISInputProcess 				; handle that as the first character
.018caf					_CISInput:
.018caf	20 fb 8c	jsr $018cfb		jsr 	CIGetCharacter
.018cb2					_CISInputProcess:
.018cb2	c9 0d		cmp #$0d		cmp 	#13 							; EOL ?
.018cb4	f0 31		beq $018ce7		beq 	_CISDone
.018cb6	c9 3a		cmp #$3a		cmp 	#":"							; colon exits if not in quotes. who knows why?
.018cb8	d0 05		bne $018cbf		bne 	_CISNotColon
.018cba	2c 14 03	bit $0314		bit 	NumBufX 						; check quote flag
.018cbd	10 28		bpl $018ce7		bpl 	_CISDone 						; if quote flag zero, done
.018cbf					_CISNotColon:
.018cbf	c9 22		cmp #$22		cmp 	#'"'							; quoted string ?
.018cc1	f0 1a		beq $018cdd		beq 	_CISIsQuote						; if so handle that code.
.018cc3	20 6e 9a	jsr $019a6e		jsr 	WriteTempString 				; write to the temporary string
.018cc6	ad 9f 03	lda $039f		lda 	TempStringWriteIndex 			; string too long ?
.018cc9	10 e4		bpl $018caf		bpl 	_CISInput
.018ccb	20 83 85	jsr $018583			jsr ERR_Handler
>018cce	49 6e 70 75 74 20 74 6f			.text "Input too long",0
>018cd6	6f 20 6c 6f 6e 67 00
.018cdd					_CISIsQuote:
.018cdd	ad 14 03	lda $0314		lda 	NumBufX 						; this is the 'in quote flag'
.018ce0	49 80		eor #$80		eor 	#$80 							; toggle bit 7
.018ce2	8d 14 03	sta $0314		sta 	NumBufX
.018ce5	d0 c8		bne $018caf		bne 	_CISInput 						; if entered quote mode, get next character
.018ce7					_CISDone:
.018ce7	a5 22		lda $22			lda 	zTempStr 						; return the temporary string
.018ce9	85 80		sta $80			sta 	XS_Mantissa+0
.018ceb	a5 23		lda $23			lda 	zTempStr+1
.018ced	85 81		sta $81			sta 	XS_Mantissa+1
.018cef	a9 02		lda #$02		lda 	#2
.018cf1	85 85		sta $85			sta 	XS_Type
.018cf3	a2 00		ldx #$00		ldx 	#0
.018cf5	20 4b a0	jsr $01a04b		jsr 	VariableSet 					; set variable.
.018cf8	4c 21 8c	jmp $018c21		jmp 	_CILoop 						; and try again
.018cfb					CIGetCharacter:
.018cfb	5a		phy			phy
.018cfc	ac c2 03	ldy $03c2		ldy		InputAvailable 					; anything available
.018cff	f0 0c		beq $018d0d		beq 	_CIGCNewLine 					; no, needs a new line.
.018d01	b9 66 05	lda $0566,y		lda 	IFT_LineBuffer,y 				; read line buffer entry
.018d04	c9 0d		cmp #$0d		cmp 	#13 							; got 13 ?
.018d06	f0 03		beq $018d0b		beq 	_CIGCNoInc
.018d08	ee c2 03	inc $03c2		inc 	InputAvailable 					; if not, advance character pointer.
.018d0b					_CIGCNoInc:
.018d0b	7a		ply			ply
.018d0c	60		rts			rts
.018d0d					_CIGCNewLine:
.018d0d	ee c2 03	inc $03c2		inc 	InputAvailable 					; next pointer to 1 (first char this time)
.018d10	a9 3f		lda #$3f		lda 	#"?"
.018d12	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018d15	ac c3 03	ldy $03c3		ldy 	InputRetry 						; retry flag set
.018d18	f0 03		beq $018d1d		beq 	_CIGCPrompt 					; if so, then print ? again
.018d1a	20 3c 85	jsr $01853c		jsr 	VIOCharPrint
.018d1d					_CIGCPrompt:
.018d1d	a0 01		ldy #$01		ldy 	#1
.018d1f	8c c3 03	sty $03c3		sty 	InputRetry 						; set the input retry flag to non-zero
.018d22					_CIGCBackOne:
.018d22	88		dey			dey
.018d23					_CIGCLoop:
.018d23	c0 50		cpy #$50		cpy 	#80 							; stop overflow.
.018d25	f0 fb		beq $018d22		beq 	_CIGCBackOne
.018d27	20 3f 85	jsr $01853f		jsr 	VIOCharGet 						; get a character
.018d2a	f0 f7		beq $018d23		beq 	_CIGCLoop 						; wait until key pressed
.018d2c	c9 08		cmp #$08		cmp 	#8 								; backspace
.018d2e	f0 10		beq $018d40		beq 	_CIGCBackSpace
.018d30	20 3c 85	jsr $01853c		jsr 	VIOCharPrint 					; echo character
.018d33	99 66 05	sta $0566,y		sta		IFT_LineBuffer,y 				; write into buffer and bump
.018d36	c8		iny			iny
.018d37	c9 0d		cmp #$0d		cmp 	#13 							; until CR pressed.
.018d39	d0 e8		bne $018d23		bne 	_CIGCLoop
.018d3b	ad 66 05	lda $0566		lda 	IFT_LineBuffer 					; return first char in buffer
.018d3e	7a		ply			ply 									; restore Y
.018d3f	60		rts			rts
.018d40					_CIGCBackSpace:
.018d40	c0 00		cpy #$00		cpy 	#0 								; can only B/S if not first
.018d42	f0 df		beq $018d23		beq 	_CIGCLoop
.018d44	20 3c 85	jsr $01853c		jsr 	VIOCharPrint 					; echo BS
.018d47	88		dey			dey 									; go back one.
.018d48	80 d9		bra $018d23		bra 	_CIGCLoop

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.018d4a					Command_END:
>018d4a	02						.byte 	2
.018d4b	4c 3c 88	jmp $01883c			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.018d4e					Command_IF:
.018d4e	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; check success.
.018d51	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018d53	05 81		ora $81				ora 	XS_Mantissa+1
.018d55	05 82		ora $82				ora 	XS_Mantissa+2
.018d57	05 83		ora $83				ora 	XS_Mantissa+3
.018d59	aa		tax				tax 								; put into X.
.018d5a	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d5c	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.018d5e	d0 2c		bne $018d8c			bne 	_FIFExtended
.018d60	c8		iny				iny
.018d61	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.018d63	f0 0b		beq $018d70			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.018d65	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d67	29 c0		and #$c0			and 	#$C0 						; is it a number
.018d69	c9 40		cmp #$40			cmp 	#$40
.018d6b	d0 1e		bne $018d8b			bne 	_FIFContinue 				; if not, do what ever follows.
.018d6d	4c da 90	jmp $0190da			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.018d70					_FIFEndOfLine:
.018d70	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d72	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.018d74	f0 15		beq $018d8b			beq 	_FIFContinue
.018d76	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018d78	c8		iny				iny 								; skip
.018d79	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018d7b	90 0c		bcc $018d89			bcc 	_SEDone 					; so just skip over it.
.018d7d	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018d7f	90 07		bcc $018d88			bcc 	_SEDouble
.018d81	98		tya				tya 								; this is Y + 1
.018d82	18		clc				clc
.018d83	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018d85	a8		tay				tay 								; back in Y.
.018d86	88		dey				dey 								; fix up, one for the +1, one for the iny
.018d87	88		dey				dey
.018d88					_SEDouble:
.018d88	c8		iny				iny
.018d89					_SEDone:
.018d89	80 e5		bra $018d70			bra 	_FIFEndOfLine
.018d8b					_FIFContinue:
.018d8b	60		rts				rts
.018d8c					_FIFExtended:
.018d8c	da		phx				phx 								; save result
.018d8d	a9 40		lda #$40			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.018d8f	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.018d92	68		pla				pla 								; restore result
.018d93	f0 01		beq $018d96			beq 	_FIXSkip 					; if zero then it has failed.
.018d95	60		rts				rts 								; test passed, so continue executing
.018d96					_FIXSkip:
.018d96	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.018d98	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.018d9a	20 ff 83	jsr $0183ff			jsr 	StructureSearchDouble
.018d9d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018d9f	c8		iny				iny
.018da0	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018da2	f0 07		beq $018dab			beq 	Command_ENDIF
.018da4	60		rts				rts
.018da5					Command_ELSE:
.018da5	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018da7	20 fd 83	jsr $0183fd			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018daa	c8		iny				iny
.018dab					Command_ENDIF:
.018dab	a9 40		lda #$40			lda 	#(SMark_If << 4)
.018dad	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.018db0	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018db1					Command_LIST:
.018db1	20 3e 8f	jsr $018f3e			jsr 	ListGetRange				; get any parameters
.018db4	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018db6	85 18		sta $18				sta 	zCodePtr+0
.018db8	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018dba	85 19		sta $19				sta 	zCodePtr+1
.018dbc	a9 00		lda #$00			lda 	#0
.018dbe	85 1a		sta $1a				sta 	zCodePtr+2
.018dc0	85 1b		sta $1b				sta 	zCodePtr+3
.018dc2	a0 03		ldy #$03			ldy 	#3
.018dc4	a9 00		lda #$00			lda 	#0 							; reset the indent & last indent
.018dc6	8d bc 03	sta $03bc			sta 	LastListIndent
.018dc9	8d bb 03	sta $03bb			sta 	ListIndent
.018dcc					_CILLoop:
.018dcc	a0 00		ldy #$00			ldy 	#0
.018dce	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018dd0	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018dd2	f0 23		beq $018df7			beq 	_CILExit
.018dd4	20 4a 85	jsr $01854a			jsr 	VIOCheckBreak 				; check break
.018dd7	c9 00		cmp #$00			cmp 	#0
.018dd9	d0 1c		bne $018df7			bne 	_CILExit
.018ddb	20 85 8f	jsr $018f85			jsr 	ListCheckRange 				; check current line in range.
.018dde	b0 08		bcs $018de8			bcs		_CILNext
.018de0	a0 00		ldy #$00			ldy 	#0
.018de2	c8		iny				iny
.018de3	c8		iny				iny
.018de4	c8		iny				iny
.018de5	20 fa 8d	jsr $018dfa			jsr 	ListLine 					; list one line.
.018de8					_CILNext:
.018de8	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018dea	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.018dec	18		clc				clc
.018ded	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.018def	85 18		sta $18				sta 	zCodePtr
.018df1	90 02		bcc $018df5			bcc 	_SNLNoCarry
.018df3	e6 19		inc $19				inc 	zCodePtr+1
.018df5					_SNLNoCarry:
.018df5	80 d5		bra $018dcc			bra 	_CILLoop
.018df7					_CILExit:
.018df7	4c 3c 88	jmp $01883c			jmp 	WarmStart
.018dfa					ListLine:
.018dfa	ad bb 03	lda $03bb			lda 	ListIndent 					; copy current list indent -> last
.018dfd	8d bc 03	sta $03bc			sta 	LastListIndent
.018e00					_LICountIndent:
.018e00	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e02	c9 00		cmp #$00			cmp 	#0
.018e04	f0 2f		beq $018e35			beq 	_LIDoneIndent
.018e06	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus
.018e08	90 16		bcc $018e20			bcc 	_LICINext
.018e0a	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e0c	b0 12		bcs $018e20			bcs 	_LICINext
.018e0e	ee bb 03	inc $03bb			inc 	ListIndent
.018e11	c9 93		cmp #$93			cmp 	#firstKeywordMinus
.018e13	90 0b		bcc $018e20			bcc 	_LICINext
.018e15	ce bb 03	dec $03bb			dec 	ListIndent
.018e18	ce bb 03	dec $03bb			dec 	ListIndent
.018e1b	10 03		bpl $018e20			bpl 	_LICINext
.018e1d	ee bb 03	inc $03bb			inc 	ListIndent
.018e20					_LICINext:
.018e20	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read element
.018e22	c8		iny				iny 								; skip
.018e23	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018e25	90 0c		bcc $018e33			bcc 	_SEDone 					; so just skip over it.
.018e27	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018e29	90 07		bcc $018e32			bcc 	_SEDouble
.018e2b	98		tya				tya 								; this is Y + 1
.018e2c	18		clc				clc
.018e2d	77 18		adc [$18],y			adc 	[zCodePtr],y 				; add total length of element
.018e2f	a8		tay				tay 								; back in Y.
.018e30	88		dey				dey 								; fix up, one for the +1, one for the iny
.018e31	88		dey				dey
.018e32					_SEDouble:
.018e32	c8		iny				iny
.018e33					_SEDone:
.018e33	80 cb		bra $018e00			bra 	_LICountIndent
.018e35					_LIDoneIndent:
.018e35	a0 00		ldy #$00			ldy 	#0
.018e37	c8		iny				iny
.018e38	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e3a	85 80		sta $80				sta 	XS_Mantissa
.018e3c	c8		iny				iny
.018e3d	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e3f	85 81		sta $81				sta 	XS_Mantissa+1
.018e41	20 c9 85	jsr $0185c9			jsr 	Print16BitInteger 			; print integer.
.018e44	85 10		sta $10				sta 	zTemp1 						; save spaces printed.
.018e46	ad bb 03	lda $03bb			lda 	ListIndent 					; smaller of current/prev indent
.018e49	cd bc 03	cmp $03bc			cmp 	LastListIndent
.018e4c	90 03		bcc $018e51			bcc 	_LISmaller
.018e4e	ad bc 03	lda $03bc			lda 	LastListIndent
.018e51					_LISmaller:
.018e51	0a		asl a				asl 	a 							; double indent
.018e52	49 ff		eor #$ff			eor 	#$FF 						; 2's complement arithmetic
.018e54	38		sec				sec
.018e55	65 10		adc $10				adc 	zTemp1 						; "subtract" indent e.g. print more.
.018e57	aa		tax				tax 								; print spaces to column 6
.018e58					_LISpace:
.018e58	a9 20		lda #$20			lda 	#" "
.018e5a	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018e5d	e8		inx				inx
.018e5e	e0 06		cpx #$06			cpx 	#6
.018e60	d0 f6		bne $018e58			bne 	_LISpace
.018e62					_LIDecode:
.018e62	c8		iny				iny
.018e63	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018e65	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018e67	f0 0f		beq $018e78			beq 	_LIExit
.018e69	30 12		bmi $018e7d			bmi 	_LIToken
.018e6b	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018e6d	b0 50		bcs $018ebf			bcs 	_LIInteger
.018e6f	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018e71	69 20		adc #$20			adc 	#$20
.018e73	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC 				; print in LC
.018e76	80 ea		bra $018e62			bra 	_LIDecode
.018e78					_LIExit:
.018e78	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018e7a	4c 2e 8f	jmp $018f2e			jmp 	ListPrintLC
.018e7d					_LIToken:
.018e7d	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018e7f	90 49		bcc $018eca			bcc		_LICommandToken
.018e81	48		pha				pha 								; save in case end
.018e82	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018e84	c9 fe		cmp #$fe			cmp 	#$FE
.018e86	f0 17		beq $018e9f			beq 	_LIPrint
.018e88	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018e8a	c9 fd		cmp #$fd			cmp 	#$FD
.018e8c	f0 11		beq $018e9f			beq 	_LIPrint
.018e8e	a9 52		lda #$52			lda 	#'R'						; must be REM
.018e90	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018e93	a9 45		lda #$45			lda 	#'E'
.018e95	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018e98	a9 4d		lda #$4d			lda 	#'M'
.018e9a	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018e9d	a2 20		ldx #$20			ldx 	#' '
.018e9f					_LIPrint:
.018e9f	8a		txa				txa
.018ea0	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018ea3	c8		iny				iny
.018ea4	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018ea6	aa		tax				tax 								; put in X
.018ea7	ca		dex				dex
.018ea8					_LILoop:
.018ea8	ca		dex				dex 								; exit when count reached zero.
.018ea9	f0 08		beq $018eb3			beq 	_LIEnd
.018eab	c8		iny				iny
.018eac	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018eae	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018eb1	80 f5		bra $018ea8			bra 	_LILoop
.018eb3	68		pla		_LIEnd:	pla 								; get A back
.018eb4	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018eb6	d0 aa		bne $018e62			bne 	_LIDecode
.018eb8	a9 22		lda #$22			lda 	#'"'
.018eba	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018ebd	80 a3		bra $018e62			bra 	_LIDecode
.018ebf					_LIInteger:
.018ebf	a2 00		ldx #$00			ldx 	#0
.018ec1	20 12 93	jsr $019312			jsr 	EvaluateGetInteger 			; get an atom
.018ec4	88		dey				dey
.018ec5	20 cf 85	jsr $0185cf			jsr 	Print32BitInteger 			; print integer.
.018ec8	80 98		bra $018e62			bra 	_LIDecode
.018eca					_LICommandToken:
.018eca	5a		phy				phy 								; save Y
.018ecb	48		pha				pha 								; save token
.018ecc	a2 c7		ldx #$c7			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018ece	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018ed0	86 1c		stx $1c				stx 	zLTemp1
.018ed2	85 1d		sta $1d				sta 	zLTemp1+1
.018ed4	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018ed6	85 1e		sta $1e				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018ed8	68		pla				pla 								; get token
.018ed9	29 7f		and #$7f			and 	#127 						; chuck bit 7.
.018edb	f0 16		beq $018ef3			beq 	_LIFoundToken
.018edd	aa		tax				tax
.018ede					_LITokenLoop:
.018ede	a0 00		ldy #$00			ldy 	#0 							; last character not a token.
.018ee0					_LIFindEnd:
.018ee0	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018ee2	c8		iny				iny
.018ee3	0a		asl a				asl 	a
.018ee4	90 fa		bcc $018ee0			bcc 	_LIFindEnd
.018ee6	98		tya				tya 								; that is step to the next
.018ee7	18		clc				clc 								; we don't bother bumping the 3rd byte
.018ee8	65 1c		adc $1c				adc 	zLTemp1 					; here.
.018eea	85 1c		sta $1c				sta 	zLTemp1
.018eec	90 02		bcc $018ef0			bcc 	_LINoBump
.018eee	e6 1d		inc $1d				inc 	zLTemp1+1
.018ef0					_LINoBump:
.018ef0	ca		dex				dex 								; no go round again.
.018ef1	d0 eb		bne $018ede			bne 	_LITokenLoop
.018ef3					_LIFoundToken:
.018ef3	a0 00		ldy #$00			ldy 	#0
.018ef5					_LIPrintToken:
.018ef5	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.018ef7	c0 00		cpy #$00			cpy 	#0 							; see if needs prefix space
.018ef9	d0 16		bne $018f11			bne 	_LINoPrefixSpace
.018efb	c9 41		cmp #$41			cmp 	#"A" 						; e.g. alphabetic token.
.018efd	90 12		bcc $018f11			bcc 	_LINoPrefixSpace
.018eff	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f01	b0 0e		bcs $018f11			bcs 	_LINoPrefixSpace
.018f03	ae ba 03	ldx $03ba			ldx 	LastPrinted 				; if last was space not required
.018f06	e0 20		cpx #$20			cpx 	#" "
.018f08	f0 07		beq $018f11			beq 	_LINoPrefixSpace
.018f0a	48		pha				pha
.018f0b	a9 20		lda #$20			lda 	#" "
.018f0d	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018f10	68		pla				pla
.018f11					_LINoPrefixSpace:
.018f11	c8		iny				iny
.018f12	48		pha				pha 								; save it
.018f13	29 7f		and #$7f			and 	#$7F
.018f15	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018f18	68		pla				pla
.018f19	10 da		bpl $018ef5			bpl 	_LIPrintToken 				; go back if not end
.018f1b	7a		ply				ply 								; restore Y
.018f1c	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018f1e	c9 41		cmp #$41			cmp 	#"A"
.018f20	90 09		bcc $018f2b			bcc 	_LINotLetter2
.018f22	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f24	b0 05		bcs $018f2b			bcs 	_LINotLetter2
.018f26	a9 20		lda #$20			lda 	#" " 						; add spacing
.018f28	20 2e 8f	jsr $018f2e			jsr 	ListPrintLC
.018f2b					_LINotLetter2:
.018f2b	4c 62 8e	jmp $018e62			jmp 	_LIDecode
.018f2e					ListPrintLC:
.018f2e	8d ba 03	sta $03ba			sta 	LastPrinted
.018f31	c9 41		cmp #$41			cmp 	#"A"
.018f33	90 06		bcc $018f3b			bcc 	_LPLC0
.018f35	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018f37	b0 02		bcs $018f3b			bcs 	_LPLC0
.018f39	69 20		adc #$20			adc 	#$20
.018f3b	4c 3c 85	jmp $01853c	_LPLC0:	jmp 	VIOCharPrint
.018f3e					ListGetRange:
.018f3e	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018f40					_LGRClear:
.018f40	a9 00		lda #$00			lda 	#0
.018f42	95 80		sta $80,x			sta 	XS_Mantissa,x
.018f44	ca		dex				dex
.018f45	10 f9		bpl $018f40			bpl 	_LGRClear
.018f47	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f49	c9 00		cmp #$00			cmp 	#0 							; nothing
.018f4b	f0 21		beq $018f6e			beq 	_LGRBlank
.018f4d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018f4f	f0 1d		beq $018f6e			beq 	_LGRBlank
.018f51	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018f53	f0 18		beq $018f6d			beq 	_LGREnd 					; then it's LIST ,x
.018f55	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; get the first number into bottom
.018f58	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f5a	c9 bf		cmp #$bf			cmp 	#token_Comma
.018f5c	f0 0f		beq $018f6d			beq 	_LGREnd 					; then it is LIST a,b
.018f5e	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018f60	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018f62	a5 81		lda $81				lda 	XS_Mantissa+1
.018f64	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018f66					_LGRBumpExit:
.018f66	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018f68	d0 02		bne $018f6c			bne 	_LGRBump2
.018f6a	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018f6c					_LGRBump2:
.018f6c	60		rts				rts
.018f6d					_LGREnd:
.018f6d	c8		iny				iny
.018f6e					_LGRBlank:
.018f6e	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018f70	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018f72	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018f74	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f76	c9 00		cmp #$00			cmp 	#0
.018f78	f0 f2		beq $018f6c			beq 	_LGRBump2
.018f7a	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018f7b	b0 ef		bcs $018f6c			bcs 	_LGRBump2
.018f7d	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018f7f	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX
.018f82	80 e2		bra $018f66			bra 	_LGRBumpExit
.018f84	60		rts				rts
.018f85					ListCheckRange:
.018f85	c8		iny				iny
.018f86	a2 00		ldx #$00			ldx 	#0 							; test low
.018f88	20 95 8f	jsr $018f95			jsr 	_LCRCompare
.018f8b	90 06		bcc $018f93			bcc 	_LCRFail
.018f8d	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018f8f	20 95 8f	jsr $018f95			jsr 	_LCRCompare
.018f92	60		rts				rts
.018f93					_LCRFail:
.018f93	38		sec				sec
.018f94	60		rts				rts
.018f95					_LCRCompare:
.018f95	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f97	38		sec				sec
.018f98	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018f9a	08		php				php
.018f9b	c8		iny				iny
.018f9c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018f9e	28		plp				plp
.018f9f	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018fa1	08		php				php
.018fa2	88		dey				dey
.018fa3	28		plp				plp
.018fa4	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018fa5					Command_PRINT:
.018fa5					_CPR_Loop:
.018fa5	b7 18		lda [$18],y			lda 	[zCodePtr],y
.018fa7	c9 00		cmp #$00			cmp 	#0 							; end
.018fa9	f0 24		beq $018fcf			beq 	_CPR_GoNewLine
.018fab	c9 c0		cmp #$c0			cmp 	#token_Colon
.018fad	f0 20		beq $018fcf			beq 	_CPR_GoNewLine
.018faf	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018fb1	f0 74		beq $019027			beq 	_CPR_Skip
.018fb3	c9 bf		cmp #$bf			cmp 	#token_Comma
.018fb5	f0 57		beq $01900e			beq 	_CPR_Tab
.018fb7	20 0a 92	jsr $01920a			jsr 	EvaluateExpression 			; get expression.
.018fba	a5 85		lda $85				lda 	XS_Type 					; get type.
.018fbc	29 02		and #$02			and 	#2
.018fbe	d0 27		bne $018fe7			bne 	_CPR_String 				; if type = 2 output as string.
.018fc0					_CPR_Number:
.018fc0	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018fc2	8d 14 03	sta $0314			sta 	NumBufX
.018fc5	a5 85		lda $85				lda 	XS_Type 					; get type
.018fc7	4a		lsr a				lsr 	a
.018fc8	b0 08		bcs $018fd2			bcs 	_CPRInt 					; if msb set do as integer
.018fca	20 0e a7	jsr $01a70e			jsr 	FPToString 					; call fp to str otherwise
.018fcd	80 06		bra $018fd5			bra 	_CPRNPrint
.018fcf					_CPR_GoNewLine:
.018fcf	4c 35 90	jmp $019035			jmp 	_CPR_NewLine
.018fd2	20 94 a1	jsr $01a194	_CPRInt:jsr 	IntToString
.018fd5					_CPRNPrint:
.018fd5	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018fd8	c9 2d		cmp #$2d			cmp 	#"-"
.018fda	f0 05		beq $018fe1			beq 	_CPRNoSpace
.018fdc	a9 20		lda #$20			lda 	#" "						; print the leading space
.018fde	20 3c 85	jsr $01853c			jsr 	VIOCharPrint 				; so beloved of MS Basics.
.018fe1					_CPRNoSpace:
.018fe1	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018fe3	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018fe5	80 04		bra $018feb			bra 	_CPRPrint
.018fe7					_CPR_String:
.018fe7	a6 80		ldx $80				ldx 	XS_Mantissa
.018fe9	a5 81		lda $81				lda 	XS_Mantissa+1
.018feb					_CPRPrint:
.018feb	86 20		stx $20				stx 	zGenPtr
.018fed	85 21		sta $21				sta 	zGenPtr+1
.018fef	5a		phy				phy
.018ff0	a0 00		ldy #$00			ldy 	#0							; get length into X
.018ff2	b1 20		lda ($20),y			lda 	(zGenPtr),y
.018ff4	aa		tax				tax
.018ff5	f0 09		beq $019000			beq 	_CPREndPrint 				; nothing to print
.018ff7					_CPRLoop:
.018ff7	c8		iny				iny
.018ff8	b1 20		lda ($20),y			lda 	(zGenPtr),y
.018ffa	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.018ffd	ca		dex				dex
.018ffe	d0 f7		bne $018ff7			bne 	_CPRLoop
.019000					_CPREndPrint:
.019000	a5 85		lda $85				lda 	XS_Type 					; if numeric add trailing space
.019002	29 02		and #$02			and 	#2
.019004	d0 05		bne $01900b			bne 	_CPRNoTrail
.019006	a9 20		lda #$20			lda 	#" "
.019008	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.01900b					_CPRNoTrail:
.01900b	7a		ply				ply
.01900c	80 97		bra $018fa5			bra 	_CPR_Loop
.01900e					_CPR_Tab:
.01900e	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; print until position % 8 = 0
.019011					_CPR_CalcSpaces:
.019011	38		sec				sec 								; calculate position mod 10.
.019012	e9 0a		sbc #$0a			sbc 	#10
.019014	b0 fb		bcs $019011			bcs 	_CPR_CalcSpaces
.019016	69 0a		adc #$0a			adc 	#10
.019018	f0 0d		beq $019027			beq 	_CPR_Skip 					; nothing to print
.01901a	aa		tax				tax 								; print out spaces to mod 10
.01901b					_CPRTabSpaces:
.01901b	a9 20		lda #$20			lda 	#" "
.01901d	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.019020	e8		inx				inx
.019021	e0 0a		cpx #$0a			cpx 	#10
.019023	d0 f6		bne $01901b			bne 	_CPRTabSpaces
.019025	80 e7		bra $01900e			bra 	_CPR_Tab
.019027					_CPR_Skip:
.019027	c8		iny				iny
.019028	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01902a	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.01902c	f0 0c		beq $01903a			beq 	_CPR_Exit
.01902e	c9 00		cmp #$00			cmp 	#0
.019030	f0 08		beq $01903a			beq 	_CPR_Exit 					; if not go round again.
.019032	4c a5 8f	jmp $018fa5			jmp 	_CPR_Loop
.019035					_CPR_NewLine:
.019035	a9 0d		lda #$0d			lda 	#13
.019037	20 3c 85	jsr $01853c			jsr 	VIOCharPrint
.01903a					_CPR_Exit:
.01903a	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.01903b					Command_ASSERT:
.01903b	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; calculate thing being asserted, 0=>X
.01903e	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.019040	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019042	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019044	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019046	f0 01		beq $019049			beq 	_ASFail
.019048	60		rts				rts
.019049					_ASFail:
.019049	20 83 85	jsr $018583			jsr ERR_Handler
>01904c	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.019053					Command_POKE:
.019053	a9 01		lda #$01			lda 	#1 							; 1 byte
.019055	80 06		bra $01905d			bra 	CmdPoke_Main
.019057					Command_DOKE:
.019057	a9 02		lda #$02			lda 	#2 							; 2 bytes
.019059	80 02		bra $01905d			bra 	CmdPoke_Main
.01905b					Command_LOKE:
.01905b	a9 04		lda #$04			lda 	#4							; 4 bytes
.01905d					CmdPoke_Main:
.01905d	48		pha				pha
.01905e	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; get two parameters. First is address
.019061	e8		inx				inx
.019062	e8		inx				inx
.019063	e8		inx				inx
.019064	e8		inx				inx
.019065	e8		inx				inx
.019066	e8		inx				inx
.019067	20 fe 99	jsr $0199fe			jsr 	CheckNextComma
.01906a	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX 			; second is the data.
.01906d	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy the mantissa into ZLTemp1 (address)
.01906f	85 1c		sta $1c				sta 	zLTemp1
.019071	a5 81		lda $81				lda 	XS_Mantissa+1
.019073	85 1d		sta $1d				sta 	zLTemp1+1
.019075	a5 82		lda $82				lda 	XS_Mantissa+2
.019077	85 1e		sta $1e				sta 	zLTemp1+2
.019079	a5 83		lda $83				lda 	XS_Mantissa+3
.01907b	85 1f		sta $1f				sta 	zLTemp1+3
.01907d	68		pla				pla 								; get count
.01907e	5a		phy				phy 								; save Y
.01907f	20 89 99	jsr $019989			jsr 	MemWrite 					; write it out
.019082	7a		ply				ply 								; restore Y and done.
.019083	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.019084					Command_NEW:
.019084	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019086	85 18		sta $18				sta 	zCodePtr+0
.019088	a9 10		lda #$10			lda 	#BasicProgram >> 8
.01908a	85 19		sta $19				sta 	zCodePtr+1
.01908c	a9 00		lda #$00			lda 	#0
.01908e	85 1a		sta $1a				sta 	zCodePtr+2
.019090	85 1b		sta $1b				sta 	zCodePtr+3
.019092	a0 03		ldy #$03			ldy 	#3
.019094	a0 00		ldy #$00			ldy 	#0
.019096	a9 00		lda #$00			lda 	#0 							; write a 0 there, null first offset
.019098	97 18		sta [$18],y			sta 	[zCodePtr],y
.01909a	20 9a 99	jsr $01999a			jsr 	UpdateProgramEnd 			; update program end.
.01909d	4c 3c 88	jmp $01883c			jmp 	WarmStart 					; and always warmstart, can't be running program.
.0190a0					Command_OLD:
.0190a0	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0190a2	85 18		sta $18				sta 	zCodePtr+0
.0190a4	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0190a6	85 19		sta $19				sta 	zCodePtr+1
.0190a8	a9 00		lda #$00			lda 	#0
.0190aa	85 1a		sta $1a				sta 	zCodePtr+2
.0190ac	85 1b		sta $1b				sta 	zCodePtr+3
.0190ae	a0 03		ldy #$03			ldy 	#3
.0190b0					_COL_Find:
.0190b0	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0190b2	c8		iny				iny
.0190b3	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.0190b5	f0 18		beq $0190cf			beq 	_COL_Found
.0190b7	98		tya				tya
.0190b8	c9 00		cmp #$00			cmp 	#0 							; e.g. there is no program line end.
.0190ba	d0 f4		bne $0190b0			bne 	_COL_Find 					; can't find old EOL, give up.
.0190bc	20 83 85	jsr $018583			jsr ERR_Handler
>0190bf	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>0190c7	43 6f 72 72 75 70 74 00
.0190cf					_COL_Found:
.0190cf	98		tya				tya
.0190d0	48		pha				pha
.0190d1	a0 00		ldy #$00			ldy 	#0
.0190d3	68		pla				pla
.0190d4	97 18		sta [$18],y			sta 	[zCodePtr],y
.0190d6	20 9a 99	jsr $01999a			jsr 	UpdateProgramEnd 			; reset variable pointer
.0190d9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.0190da					Command_GOTO:
.0190da	20 2f 91	jsr $01912f			jsr 	GotoGetLineNumber 			; get line number
.0190dd					CmdGOTO:
.0190dd	a2 00		ldx #$00			ldx 	#0 							; go to that line number
.0190df	4c 4c 91	jmp $01914c			jmp 	GotoChangeToLineNumberX
.0190e2					Command_GOSUB:
.0190e2	20 2f 91	jsr $01912f			jsr 	GotoGetLineNumber 			; get line number
.0190e5					CmdGOSUB:
.0190e5	20 03 85	jsr $018503			jsr 	StackSavePosition 			; save position on stack and push frame
.0190e8	a9 15		lda #$15			lda 	#(SMark_Gosub << 4)+SourcePosSize
.0190ea	20 bc 84	jsr $0184bc			jsr 	StackPushFrame
.0190ed	a2 00		ldx #$00			ldx		#0 							; go to that line number
.0190ef	4c 4c 91	jmp $01914c			jmp 	GotoChangeToLineNumberX
.0190f2					Command_RETURN:
.0190f2	a9 10		lda #$10			lda 	#(SMark_Gosub << 4) 		; pop frame
.0190f4	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.0190f7	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; restore position.
.0190fa	60		rts				rts
.0190fb					Command_ON:
.0190fb	a2 00		ldx #$00			ldx 	#0 							; get the ON value into mantissa.0
.0190fd	20 4c 98	jsr $01984c			jsr 	SLIByteParameter
.019100	a5 80		lda $80				lda 	XS_Mantissa+0 				; get the count
.019102	f0 28		beq $01912c			beq 	_CONFail 					; can't be zero, error if it is.
.019104	aa		tax				tax 								; save in X.
.019105	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019107	c8		iny				iny
.019108	48		pha				pha 								; so we can check what we're doing later.
.019109	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; must be GOTO or GOSUB
.01910b	f0 07		beq $019114			beq 	_CONOkayToken
.01910d	c9 ca		cmp #$ca			cmp 	#token_GOSUB
.01910f	f0 03		beq $019114			beq 	_CONOkayToken
.019111	4c 54 85	jmp $018554			jmp 	SyntaxError
.019114					_CONOkayToken:
.019114	da		phx				phx 								; count on top, GOTO/GOSUB token 2nd.
.019115					_CONFindNumber:
.019115	20 2f 91	jsr $01912f			jsr 	GotoGetLineNumber 			; get a line number.
.019118	fa		plx				plx 								; restore count
.019119	ca		dex				dex  								; decrement, exit if zero.
.01911a	f0 06		beq $019122			beq 	_CONFound
.01911c	da		phx				phx 								; push back
.01911d	20 fe 99	jsr $0199fe			jsr 	CheckNextComma				; check for comma
.019120	80 f3		bra $019115			bra 	_CONFindNumber 				; go round again.
.019122					_CONFound:
.019122	68		pla				pla 								; get token to decide what to do
.019123	c9 cc		cmp #$cc			cmp 	#token_GOTO 				; if GOTO
.019125	f0 b6		beq $0190dd			beq		CmdGOTO 					; then just branch.
.019127	20 8a 84	jsr $01848a			jsr 	SkipEndOfCommand 			; go to end of command
.01912a	80 b9		bra $0190e5			bra 	CmdGOSUB 					; and do a GOSUB.
.01912c					_CONFail:
.01912c	4c 72 85	jmp $018572			jmp 	BadParamError
.01912f					GotoGetLineNumber:
.01912f	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; get integer into mantissa.0
.019132	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.019134	05 83		ora $83				ora 	XS_Mantissa+3 				; check it is 0-32767
.019136	d0 01		bne $019139			bne 	_GLINError
.019138	60		rts				rts
.019139					_GLINError:
.019139	20 83 85	jsr $018583			jsr ERR_Handler
>01913c	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019144	20 4e 75 6d 62 65 72 00
.01914c					GotoChangeToLineNumberX:
.01914c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check line number not zero
.01914e	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019150	f0 37		beq $019189			beq 	_GCTLFail 					; if so, no can do.
.019152	a9 00		lda #$00			lda 	#BasicProgram & $FF
.019154	85 18		sta $18				sta 	zCodePtr+0
.019156	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019158	85 19		sta $19				sta 	zCodePtr+1
.01915a	a9 00		lda #$00			lda 	#0
.01915c	85 1a		sta $1a				sta 	zCodePtr+2
.01915e	85 1b		sta $1b				sta 	zCodePtr+3
.019160	a0 03		ldy #$03			ldy 	#3
.019162					_GCTLLoop:
.019162	a0 00		ldy #$00			ldy 	#0
.019164	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019166	c9 00		cmp #$00			cmp 	#0
.019168	f0 1f		beq $019189			beq 	_GCTLFail
.01916a	c8		iny				iny
.01916b	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01916d	d5 80		cmp $80,x			cmp 	XS_Mantissa+0,x
.01916f	d0 07		bne $019178			bne 	_GCTLNext
.019171	c8		iny				iny
.019172	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019174	d5 81		cmp $81,x			cmp 	XS_Mantissa+1,x
.019176	f0 0f		beq $019187			beq 	_GCTLExit
.019178					_GCTLNext:
.019178	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01917a	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.01917c	18		clc				clc
.01917d	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.01917f	85 18		sta $18				sta 	zCodePtr
.019181	90 02		bcc $019185			bcc 	_SNLNoCarry
.019183	e6 19		inc $19				inc 	zCodePtr+1
.019185					_SNLNoCarry:
.019185	80 db		bra $019162			bra 	_GCTLLoop 					; try next line.
.019187					_GCTLExit:
.019187	c8		iny				iny
.019188	60		rts				rts
.019189					_GCTLFail:
.019189	20 83 85	jsr $018583			jsr ERR_Handler
>01918c	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>019194	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.01919c					Command_CLR:
.01919c					ResetRunStatus:
.01919c	20 ee 9c	jsr $019cee			jsr 	VariableClear
.01919f	20 aa 84	jsr $0184aa			jsr 	StackReset
.0191a2	a9 00		lda #$00			lda 	#HighMemory & $FF
.0191a4	8d 00 03	sta $0300			sta 	StringPtr
.0191a7	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.0191a9	8d 01 03	sta $0301			sta 	StringPtr+1
.0191ac	20 b8 9e	jsr $019eb8			jsr 	ArrayResetDefault
.0191af	20 fc 8a	jsr $018afc			jsr 	Command_RESTORE
.0191b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.0191b3					Command_STOP:
.0191b3	20 83 85	jsr $018583			jsr ERR_Handler
>0191b6	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.0191bb					Command_WHILE:
.0191bb	20 03 85	jsr $018503			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.0191be	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 			; calculate the while loop value.
.0191c1	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.0191c3	05 81		ora $81				ora 	XS_Mantissa+1
.0191c5	05 82		ora $82				ora 	XS_Mantissa+2
.0191c7	05 83		ora $83				ora 	XS_Mantissa+3
.0191c9	f0 06		beq $0191d1			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.0191cb	a9 35		lda #$35			lda 	#(SMark_While << 4)+SourcePosSize
.0191cd	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on stack
.0191d0	60		rts				rts
.0191d1					_CWHSkip:
.0191d1	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.0191d3	20 fd 83	jsr $0183fd			jsr 	StructureSearchSingle
.0191d6	c8		iny				iny
.0191d7	60		rts				rts
.0191d8					Command_WEND:
.0191d8	a9 30		lda #$30			lda 	#(SMark_While << 4)			; remove the frame
.0191da	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.0191dd	20 20 85	jsr $018520			jsr 	StackRestorePosition
.0191e0	80 d9		bra $0191bb			bra 	Command_WHILE 				; and do the while again.
.0191e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.0191e3					Command_REPEAT:
.0191e3	20 03 85	jsr $018503			jsr 	StackSavePosition			; save position into stack
.0191e6	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.0191e8	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; push on stack
.0191eb	60		rts				rts
.0191ec					Command_UNTIL:
.0191ec	a9 20		lda #$20			lda 	#(SMark_Repeat << 4)		; remove the frame, checking it.
.0191ee	20 d3 84	jsr $0184d3			jsr 	StackPopFrame
.0191f1	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger				; work out the UNTIL expression.
.0191f4	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.0191f6	05 81		ora $81				ora 	XS_Mantissa+1
.0191f8	05 82		ora $82				ora 	XS_Mantissa+2
.0191fa	05 83		ora $83				ora 	XS_Mantissa+3
.0191fc	d0 08		bne $019206			bne 	_CUTExit 					; if not, just exit
.0191fe	20 20 85	jsr $018520			jsr 	StackRestorePosition 		; otherwise loop round again.
.019201	a9 25		lda #$25			lda 	#(SMark_Repeat << 4)+SourcePosSize
.019203	20 bc 84	jsr $0184bc			jsr 	StackPushFrame 				; fix the stack back so we can pop it again.
.019206					_CUTExit:
.019206	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.019207					EVESyntax:
.019207	4c 54 85	jmp $018554			jmp 	SyntaxError
.01920a					EvaluateExpression:
.01920a	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.01920c					EvaluateExpressionX:
.01920c	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.01920e					EvaluateExpressionXA:
.01920e	48		pha				pha 								; save precedence on stack.
.01920f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019211	f0 f4		beq $019207			beq 	EVESyntax 					; end of line, syntax error.
.019213	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.019215	b0 03		bcs $01921a			bcs 	_EVNotVariable
.019217	4c e4 92	jmp $0192e4			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.01921a					_EVNotVariable:
.01921a	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.01921c	90 e9		bcc $019207			bcc 	EVESyntax
.01921e	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.019220	b0 58		bcs $01927a			bcs 	_EVNotInteger
.019222	20 12 93	jsr $019312			jsr 	EvaluateGetInteger
.019225					_EVCheckDecimal:
.019225	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019227	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.019229	d0 05		bne $019230			bne 	_EVGotAtom 					; no, get atom.
.01922b					_EVIsDecimal:
.01922b	20 38 93	jsr $019338			jsr 	EVGetDecimal 				; extend to the decimal part.
.01922e	80 00		bra $019230			bra 	_EVGotAtom 					; and continue to got atom.
.019230					_EVGotAtom:
.019230	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019232	10 44		bpl $019278			bpl 	_EVExitDrop 				; must be a token.
.019234	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.019236	b0 40		bcs $019278			bcs 	_EVExitDrop
.019238	68		pla				pla 								; get current precedence
.019239	85 20		sta $20				sta 	zGenPtr 					; save in zGenPtr as temp.
.01923b	da		phx				phx 								; save X
.01923c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01923e	aa		tax				tax 								; put in X
.01923f	bf 38 86 01	lda $018638,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.019243	85 21		sta $21				sta 	zGenPtr+1 					; save it.
.019245	fa		plx				plx 								; restore X
.019246	c5 20		cmp $20				cmp 	zGenPtr 					; compared against the current precedence
.019248	90 2f		bcc $019279			bcc 	_EVExit 					; exit if too low.
.01924a	f0 2d		beq $019279			beq 	_EVExit 					; exit if equals
.01924c	a5 20		lda $20				lda 	zGenPtr 					; push precedence
.01924e	48		pha				pha
.01924f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019251	48		pha				pha
.019252	c8		iny				iny
.019253	da		phx				phx 								; save current position
.019254	e8		inx				inx
.019255	e8		inx				inx
.019256	e8		inx				inx
.019257	e8		inx				inx
.019258	e8		inx				inx
.019259	e8		inx				inx
.01925a	a5 21		lda $21				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.01925c	20 0e 92	jsr $01920e			jsr 	EvaluateExpressionXA 		; do the RHS.
.01925f	fa		plx				plx 								; restore X
.019260	68		pla				pla 								; get the binary operator in A.
.019261					_EVCallA:
.019261	da		phx				phx 								; save X again
.019262	0a		asl a				asl 	a 							; double, lose the MSB.
.019263	aa		tax				tax									; put in X
.019264	bf e7 85 01	lda $0185e7,x			lda 	VectorTable,x 				; copy address into zGenPtr
.019268	8d 11 03	sta $0311			sta 	LocalVector+1
.01926b	bf e8 85 01	lda $0185e8,x			lda 	VectorTable+1,x
.01926f	8d 12 03	sta $0312			sta 	LocalVector+2
.019272	fa		plx				plx 								; restore X
.019273	20 ed 92	jsr $0192ed			jsr 	EVCallLocalVector
.019276	80 b8		bra $019230			bra 	_EVGotAtom 					; and loop back.
.019278					_EVExitDrop:
.019278	68		pla				pla
.019279					_EVExit:
.019279	60		rts				rts
.01927a					_EVNotInteger:
.01927a	c8		iny				iny
.01927b	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.01927d	d0 16		bne $019295			bne 	_EVNotMinus
.01927f	20 81 93	jsr $019381			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.019282	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.019284	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019286	f0 05		beq $01928d			beq 	_EVMinusFloat
.019288	20 77 a1	jsr $01a177			jsr 	IntegerNegateAlways 		; negation
.01928b	80 a3		bra $019230			bra 	_EVGotAtom 					; and go back.
.01928d					_EVMinusFloat:
.01928d	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.01928f	49 80		eor #$80			eor 	#$80
.019291	95 85		sta $85,x			sta 	XS_Type,x
.019293	80 9b		bra $019230			bra 	_EVGotAtom
.019295					_EVNotMinus:
.019295	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.019297	d0 17		bne $0192b0			bne 	_EVNotParenthesis
.019299	20 0c 92	jsr $01920c			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.01929c	b7 18		lda [$18],y			lda 	[zCodePtr],y
.01929e	c8		iny				iny
.01929f	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.0192a1	f0 8d		beq $019230			beq 	_EVGotAtom
.0192a3	20 83 85	jsr $018583			jsr ERR_Handler
>0192a6	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>0192ae	29 00
.0192b0					_EVNotParenthesis:
.0192b0	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.0192b2	d0 0c		bne $0192c0			bne 	_EVNotNot
.0192b4	20 81 93	jsr $019381			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.0192b7	20 0f a6	jsr $01a60f			jsr 	FPUToInteger 				; make it an integer - if possible.
.0192ba	20 66 93	jsr $019366			jsr 	NotInteger 					; do the not calculation
.0192bd	4c 30 92	jmp $019230			jmp 	_EVGotAtom
.0192c0					_EVNotNot:
.0192c0	c9 fe		cmp #$fe			cmp 	#$FE
.0192c2	d0 12		bne $0192d6			bne 	_EVNotString
.0192c4	20 7e 9a	jsr $019a7e			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.0192c7	a5 22		lda $22				lda 	zTempStr 					; copy address of string into mantissa
.0192c9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0192cb	a5 23		lda $23				lda 	zTempStr+1
.0192cd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0192cf	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.0192d1	95 85		sta $85,x			sta 	XS_Type,x
.0192d3	4c 30 92	jmp $019230			jmp 	_EVGotAtom
.0192d6					_EVNotString:
.0192d6	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.0192d8	90 04		bcc $0192de			bcc 	_EVBadElement
.0192da	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.0192dc	90 03		bcc $0192e1			bcc 	_EVUnaryFunction
.0192de					_EVBadElement:
.0192de	4c 54 85	jmp $018554			jmp 	SyntaxError
.0192e1					_EVUnaryFunction:
.0192e1	4c 61 92	jmp $019261			jmp 	_EVCallA
.0192e4					_EVVariableHandler:
.0192e4	20 b2 9c	jsr $019cb2			jsr 	VariableFind 				; locate a variable
.0192e7	20 fa 9f	jsr $019ffa			jsr 	VariableGet 				; copy into memory.
.0192ea	4c 30 92	jmp $019230			jmp 	_EVGotAtom 					; and go round.
.0192ed					EVCallLocalVector:
.0192ed	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.0192f0					EVShiftMantissaLeft6:
.0192f0	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.0192f2	95 84		sta $84,x			sta 	XS_Exponent,x
.0192f4	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0192f6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0192f8	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0192fa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0192fc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0192fe	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019300	a9 00		lda #$00			lda 	#0
.019302	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019304	20 07 93	jsr $019307			jsr 	_EVSMLShift 					; call it here to do it twice
.019307					_EVSMLShift:
.019307	56 84		lsr $84,x			lsr 	XS_Exponent,x
.019309	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.01930b	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.01930d	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.01930f	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.019311	60		rts				rts
.019312					EvaluateGetInteger:
.019312	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019314	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.019316	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.019318	a9 00		lda #$00			lda 	#0
.01931a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01931c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01931e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019320	1a		inc a				inc 	a 							; set to type 1 (integer)
.019321	95 85		sta $85,x			sta 	XS_Type,x
.019323					_EVCheckNextInteger:
.019323	c8		iny				iny
.019324	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019326	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.019328	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.01932a	b0 0b		bcs $019337			bcs 	_EVEndInteger
.01932c	48		pha				pha 								; save it.
.01932d	20 f0 92	jsr $0192f0			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.019330	68		pla				pla
.019331	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.019333	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019335	80 ec		bra $019323			bra 	_EVCheckNextInteger
.019337					_EVEndInteger:
.019337	60		rts				rts
.019338					EVGetDecimal:
.019338	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.01933a	8d 15 03	sta $0315			sta 	Num_Buffer
.01933d	da		phx				phx
.01933e	c8		iny				iny
.01933f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019341	c8		iny				iny
.019342	3a		dec a				dec 	a								; convert to a string length.
.019343	3a		dec a				dec 	a
.019344	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.019346					_EVGDCopy:
.019346	48		pha				pha 									; save count
.019347	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019349	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01934c	e8		inx				inx 									; forward ....
.01934d	c8		iny				iny
.01934e	68		pla				pla 									; get count
.01934f	3a		dec a				dec 	a 								; until zero
.019350	d0 f4		bne $019346			bne 	_EVGDCopy
.019352	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.019355	fa		plx				plx 									; restore X
.019356	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.019358	85 20		sta $20				sta 	zGenPtr
.01935a	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01935c	85 21		sta $21				sta 	zGenPtr+1
.01935e	5a		phy				phy 									; save Y
.01935f	a0 00		ldy #$00			ldy 	#0 								; start position
.019361	20 c9 a7	jsr $01a7c9			jsr 	FPFromString 					; convert current
.019364	7a		ply				ply 									; restore Y
.019365	60		rts				rts
.019366					NotInteger:
.019366	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019368	49 ff		eor #$ff			eor 	#$FF
.01936a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01936c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01936e	49 ff		eor #$ff			eor 	#$FF
.019370	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019372	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019374	49 ff		eor #$ff			eor 	#$FF
.019376	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019378	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01937a	49 ff		eor #$ff			eor 	#$FF
.01937c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01937e	60		rts				rts
.01937f					EvaluateGetAtom:
.01937f	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.019381					EvaluateGetAtomX:
.019381	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.019383	20 0e 92	jsr $01920e			jsr 	EvaluateExpressionXA
.019386	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.019388	29 0f		and #$0f			and 	#15
.01938a	c9 02		cmp #$02			cmp 	#2
.01938c	b0 01		bcs $01938f			bcs 	EvaluateType
.01938e	60		rts				rts
.01938f					EvaluateType:
.01938f	4c 64 85	jmp $018564			jmp 	TypeError
.019392					EvaluateNumber:
.019392	a2 00		ldx #$00			ldx 	#0
.019394					EvaluateNumberX:
.019394	20 0c 92	jsr $01920c			jsr 	EvaluateExpressionX
.019397	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.019399	29 0f		and #$0f			and 	#15
.01939b	c9 02		cmp #$02			cmp 	#2
.01939d	b0 f0		bcs $01938f			bcs 	EvaluateType
.01939f	60		rts				rts
.0193a0					EvaluateInteger:
.0193a0	a2 00		ldx #$00			ldx 	#0
.0193a2					EvaluateIntegerX:
.0193a2	20 94 93	jsr $019394			jsr 	EvaluateNumberX
.0193a5	20 0f a6	jsr $01a60f			jsr 	FPUToInteger
.0193a8	60		rts				rts
.0193a9					EvaluateString:
.0193a9	a2 00		ldx #$00			ldx 	#0
.0193ab					EvaluateStringX:
.0193ab	20 0c 92	jsr $01920c			jsr 	EvaluateExpressionX
.0193ae	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.0193b0	29 0f		and #$0f			and 	#15
.0193b2	c9 02		cmp #$02			cmp 	#2
.0193b4	d0 d9		bne $01938f			bne 	EvaluateType
.0193b6	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.0193b8	85 20		sta $20				sta 	zGenPtr
.0193ba	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193bc	85 21		sta $21				sta 	zGenPtr+1
.0193be	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.0193bf					BinaryOp_And:
.0193bf	20 13 94	jsr $019413			jsr 	BinaryMakeBothInteger
.0193c2	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193c4	35 86		and $86,x			and 	XS2_Mantissa+0,x
.0193c6	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193c8	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0193ca	35 87		and $87,x			and 	XS2_Mantissa+1,x
.0193cc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193ce	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0193d0	35 88		and $88,x			and 	XS2_Mantissa+2,x
.0193d2	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193d4	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0193d6	35 89		and $89,x			and 	XS2_Mantissa+3,x
.0193d8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193da	60		rts				rts
.0193db					BinaryOp_Or:
.0193db	20 13 94	jsr $019413			jsr 	BinaryMakeBothInteger
.0193de	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193e0	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.0193e2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0193e4	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.0193e6	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.0193e8	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0193ea	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.0193ec	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.0193ee	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0193f0	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.0193f2	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.0193f4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0193f6	60		rts				rts
.0193f7					BinaryOp_Eor:
.0193f7					BinaryOp_Xor:
.0193f7	20 13 94	jsr $019413			jsr 	BinaryMakeBothInteger
.0193fa	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.0193fc	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.0193fe	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019400	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.019402	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.019404	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019406	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.019408	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.01940a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01940c	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01940e	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.019410	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019412	60		rts				rts
.019413					BinaryMakeBothInteger:
.019413	da		phx				phx 								; save X
.019414	e8		inx				inx
.019415	e8		inx				inx
.019416	e8		inx				inx
.019417	e8		inx				inx
.019418	e8		inx				inx
.019419	e8		inx				inx
.01941a	20 1e 94	jsr $01941e			jsr 	BinaryMakeInteger 			; convert to integer.
.01941d	fa		plx				plx 								; restore X and fall through.
.01941e					BinaryMakeInteger:
.01941e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019420	29 0f		and #$0f			and 	#15 						; check type zero
.019422	f0 04		beq $019428			beq 	_BMIConvert 				; if float convert to integer.
.019424	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.019425	90 04		bcc $01942b			bcc 	_BMIError
.019427	60		rts				rts
.019428					_BMIConvert:
.019428	4c 0f a6	jmp $01a60f			jmp 	FPUToInteger 				; convert to integer
.01942b					_BMIError:
.01942b	4c 64 85	jmp $018564			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.01942e					Binary_Equal:
.01942e	20 77 94	jsr $019477			jsr 	CompareValues 				; compare the values
.019431	09 00		ora #$00			ora 	#0 							; true if 0
.019433	f0 33		beq $019468			beq 	CCTrue
.019435	80 2d		bra $019464			bra 	CCFalse
.019437					Binary_NotEqual:
.019437	20 77 94	jsr $019477			jsr 	CompareValues
.01943a	09 00		ora #$00			ora 	#0 							; true if -1 or 1
.01943c	f0 26		beq $019464			beq 	CCFalse
.01943e	80 28		bra $019468			bra 	CCTrue
.019440					Binary_Less:
.019440	20 77 94	jsr $019477			jsr 	CompareValues
.019443	09 00		ora #$00			ora 	#0 							; true if -1
.019445	30 21		bmi $019468			bmi 	CCTrue
.019447	80 1b		bra $019464			bra 	CCFalse
.019449					Binary_LessEqual:
.019449	20 77 94	jsr $019477			jsr 	CompareValues
.01944c	c9 01		cmp #$01			cmp 	#1 							; true if 0 or -1
.01944e	d0 18		bne $019468			bne 	CCTrue
.019450	80 12		bra $019464			bra 	CCFalse
.019452					Binary_GreaterEqual:
.019452	20 77 94	jsr $019477			jsr 	CompareValues
.019455	09 00		ora #$00			ora 	#0 							; true if 0 or 1
.019457	10 0f		bpl $019468			bpl 	CCTrue
.019459	80 09		bra $019464			bra 	CCFalse
.01945b					Binary_Greater:
.01945b	20 77 94	jsr $019477			jsr 	CompareValues 				; true if 1
.01945e	c9 01		cmp #$01			cmp 	#1
.019460	f0 06		beq $019468			beq 	CCTrue
.019462	80 00		bra $019464			bra 	CCFalse
.019464	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.019466	80 02		bra $01946a			bra 	CCWrite
.019468	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.01946a	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.01946c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01946e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019470	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019472	a9 01		lda #$01			lda 	#1
.019474	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.019476	60		rts				rts
.019477					CompareValues:
.019477	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.019479	35 8b		and $8b,x			and 	XS2_Type,x
.01947b	c9 02		cmp #$02			cmp 	#2 							; is it a string, then do the string
.01947d	f0 11		beq $019490			beq 	_CVString					; comparison routine.
.01947f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019481	35 8b		and $8b,x			and 	XS2_Type,x
.019483	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019484	90 03		bcc $019489			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019486	4c d2 94	jmp $0194d2			jmp 	CompareInteger32 							; so execute code at \1
.019489					_BCFloat:
.019489	20 76 95	jsr $019576			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01948c	4c 08 a5	jmp $01a508			jmp 	FPCompare 							; and execute code at \2
.01948f	60		rts				rts
.019490					_CVString:
.019490	da		phx				phx 								; save XY
.019491	5a		phy				phy
.019492	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019494	85 1c		sta $1c				sta		zLTemp1+0
.019496	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019498	85 1d		sta $1d				sta 	zLTemp1+1
.01949a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01949c	85 1e		sta $1e				sta 	zLTemp1+2
.01949e	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0194a0	85 1f		sta $1f				sta 	zLTemp1+3
.0194a2	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.0194a4	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194a6	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194a8	90 02		bcc $0194ac			bcc 	_CVCommon
.0194aa	b1 1e		lda ($1e),y			lda 	(zLTemp1+2),y
.0194ac					_CVCommon:
.0194ac	aa		tax				tax 								; put shorter string length in zero.
.0194ad	f0 0c		beq $0194bb			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.0194af					_CVCompare:
.0194af	c8		iny				iny 								; next character
.0194b0	b1 1c		lda ($1c),y			lda 	(zLTemp1),y 				; compare characters
.0194b2	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y 				; handle different values, < or >
.0194b4	90 13		bcc $0194c9			bcc 	_CVReturnLess 				; <
.0194b6	d0 15		bne $0194cd			bne 	_CVReturnGreater 			; >
.0194b8	ca		dex				dex 								; until common length matched.
.0194b9	d0 f4		bne $0194af			bne 	_CVCompare
.0194bb					_CVMatch:
.0194bb	a0 00		ldy #$00			ldy 	#0
.0194bd	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0194bf	d1 1e		cmp ($1e),y			cmp 	(zLTemp1+2),y
.0194c1	90 06		bcc $0194c9			bcc 	_CVReturnLess 				; <
.0194c3	d0 08		bne $0194cd			bne 	_CVReturnGreater 			; >
.0194c5	a9 00		lda #$00			lda 	#0
.0194c7	80 06		bra $0194cf			bra 	_CVExit
.0194c9					_CVReturnLess:
.0194c9	a9 ff		lda #$ff			lda 	#$FF
.0194cb	80 02		bra $0194cf			bra 	_CVExit
.0194cd					_CVReturnGreater:
.0194cd	a9 01		lda #$01			lda 	#$01
.0194cf					_CVExit:
.0194cf	7a		ply				ply
.0194d0	fa		plx				plx
.0194d1	60		rts				rts
.0194d2					CompareInteger32:
.0194d2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.0194d4	49 80		eor #$80			eor 	#$80
.0194d6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0194d8	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.0194da	49 80		eor #$80			eor 	#$80
.0194dc	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.0194de	20 5c 95	jsr $01955c			jsr 	SubInteger32 				; subtraction
.0194e1	90 0d		bcc $0194f0			bcc 	_CI32Less 					; cc return -1
.0194e3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.0194e5	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0194e7	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194e9	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0194eb	f0 02		beq $0194ef			beq 	_CI32Exit
.0194ed	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.0194ef					_CI32Exit:
.0194ef	60		rts				rts
.0194f0					_CI32Less:
.0194f0	a9 ff		lda #$ff			lda 	#$FF
.0194f2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.0194f3					BinaryOp_Add:
.0194f3	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.0194f5	35 8b		and $8b,x			and 	XS2_Type,x
.0194f7	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.0194f9	d0 11		bne $01950c			bne 	_BOAString 					; so go do the string code.
.0194fb	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0194fd	35 8b		and $8b,x			and 	XS2_Type,x
.0194ff	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019500	90 03		bcc $019505			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019502	4c 42 95	jmp $019542			jmp 	AddInteger32 							; so execute code at \1
.019505					_BCFloat:
.019505	20 76 95	jsr $019576			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019508	4c e3 a2	jmp $01a2e3			jmp 	FPAdd 							; and execute code at \2
.01950b	60		rts				rts
.01950c					_BOAString:
.01950c	4c 90 95	jmp $019590			jmp 	ConcatenateString 			; concatenate two strings.
.01950f					BinaryOp_Subtract:
.01950f	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019511	35 8b		and $8b,x			and 	XS2_Type,x
.019513	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019514	90 03		bcc $019519			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019516	4c 5c 95	jmp $01955c			jmp 	SubInteger32 							; so execute code at \1
.019519					_BCFloat:
.019519	20 76 95	jsr $019576			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01951c	4c db a2	jmp $01a2db			jmp 	FPSubtract 							; and execute code at \2
.01951f	60		rts				rts
.019520					BinaryOp_Multiply:
.019520	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019522	35 8b		and $8b,x			and 	XS2_Type,x
.019524	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019525	90 03		bcc $01952a			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019527	4c b2 a0	jmp $01a0b2			jmp 	MulInteger32 							; so execute code at \1
.01952a					_BCFloat:
.01952a	20 76 95	jsr $019576			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01952d	4c 0a a4	jmp $01a40a			jmp 	FPMultiply 							; and execute code at \2
.019530	60		rts				rts
.019531					BinaryOp_Divide:
.019531	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.019533	35 8b		and $8b,x			and 	XS2_Type,x
.019535	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019536	90 03		bcc $01953b			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019538	4c f0 a0	jmp $01a0f0			jmp 	DivInteger32 							; so execute code at \1
.01953b					_BCFloat:
.01953b	20 76 95	jsr $019576			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.01953e	4c 97 a3	jmp $01a397			jmp 	FPDivide 							; and execute code at \2
.019541	60		rts				rts
.019542					AddInteger32:
.019542	18		clc				clc
.019543	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019545	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019547	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019549	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01954b	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01954d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01954f	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019551	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019553	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019555	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019557	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019559	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01955b	60		rts				rts
.01955c					SubInteger32:
.01955c	38		sec				sec
.01955d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01955f	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019561	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019563	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019565	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019567	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019569	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01956b	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01956d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01956f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019571	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019573	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019575	60		rts				rts
.019576					BinaryMakeBothFloat:
.019576	da		phx				phx 								; save X
.019577	e8		inx				inx
.019578	e8		inx				inx
.019579	e8		inx				inx
.01957a	e8		inx				inx
.01957b	e8		inx				inx
.01957c	e8		inx				inx
.01957d	20 81 95	jsr $019581			jsr 	BinaryMakeFloat 			; convert to float.
.019580	fa		plx				plx 								; restore X and fall through.
.019581					BinaryMakeFloat:
.019581	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019583	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019584	b0 04		bcs $01958a			bcs 	_BMFConvert
.019586	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019587	b0 04		bcs $01958d			bcs 	_BMFError
.019589	60		rts				rts
.01958a					_BMFConvert:
.01958a	4c c3 a5	jmp $01a5c3			jmp 	FPUToFloat 					; convert to float, only float builds of course
.01958d					_BMFError:
.01958d	4c 64 85	jmp $018564			jmp 	TypeError
.019590					ConcatenateString:
.019590	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019592	85 1c		sta $1c				sta		zLTemp1+0
.019594	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019596	85 1d		sta $1d				sta 	zLTemp1+1
.019598	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.01959a	85 1e		sta $1e				sta 	zLTemp1+2
.01959c	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01959e	85 1f		sta $1f				sta 	zLTemp1+3
.0195a0	5a		phy				phy
.0195a1	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.0195a3	b1 1c		lda ($1c),y			lda 	(zlTemp1),y
.0195a5	71 1e		adc ($1e),y			adc 	(zlTemp1+2),y
.0195a7	7a		ply				ply
.0195a8	b0 33		bcs $0195dd			bcs 	_CSError					; check in range.
.0195aa	c9 fe		cmp #$fe			cmp 	#maxString+1
.0195ac	b0 2f		bcs $0195dd			bcs 	_CSError
.0195ae	20 43 9a	jsr $019a43			jsr 	AllocateTempString 			; store the result
.0195b1	20 c8 95	jsr $0195c8			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195b4	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.0195b6	85 1c		sta $1c				sta 	zLTemp1
.0195b8	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.0195ba	85 1d		sta $1d				sta 	zLTemp1+1
.0195bc	20 c8 95	jsr $0195c8			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.0195bf	a5 22		lda $22				lda 	zTempStr 					; point current to new string
.0195c1	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0195c3	a5 23		lda $23				lda 	zTempStr+1
.0195c5	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0195c7	60		rts				rts
.0195c8					_CSCopyString:
.0195c8	da		phx				phx
.0195c9	5a		phy				phy
.0195ca	a0 00		ldy #$00			ldy 	#0 							; get length
.0195cc	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0195ce	f0 0a		beq $0195da			beq 	_CSCSExit 					; if zero, exit immediately
.0195d0	aa		tax				tax 								; put in X which is the counter.
.0195d1					_CSCSLoop:
.0195d1	c8		iny				iny 								; get next char
.0195d2	b1 1c		lda ($1c),y			lda 	(zLTemp1),y
.0195d4	20 6e 9a	jsr $019a6e			jsr		WriteTempString 			; copy out to new string
.0195d7	ca		dex				dex 								; do whole string
.0195d8	d0 f7		bne $0195d1			bne 	_CSCSLoop
.0195da					_CSCSExit:
.0195da	7a		ply				ply
.0195db	fa		plx				plx
.0195dc	60		rts				rts
.0195dd					_CSError:
.0195dd	20 83 85	jsr $018583			jsr ERR_Handler
>0195e0	53 74 72 69 6e 67 20 74			.text "String too long",0
>0195e8	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.0195f0					Unary_Sgn:
.0195f0	20 94 93	jsr $019394			jsr 	EvaluateNumberX 			; get value
.0195f3	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; check right bracket.
.0195f6	20 14 96	jsr $019614			jsr 	GetSignCurrent 				; get sign.
.0195f9	09 00		ora #$00			ora 	#0
.0195fb	10 08		bpl $019605			bpl		UnarySetAInteger			; if 0,1 return that.
.0195fd	80 00		bra $0195ff			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.0195ff					UnarySetAMinus1:
.0195ff	a9 ff		lda #$ff			lda 	#$FF 						; put -1 in all four slots.
.019601	95 80		sta $80,x			sta 	XS_Mantissa,x
.019603	80 04		bra $019609			bra 	UnarySetAFill
.019605					UnarySetAInteger:
.019605	95 80		sta $80,x			sta 	XS_Mantissa,x
.019607	a9 00		lda #$00			lda 	#0
.019609					UnarySetAFill:
.019609	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01960b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01960d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01960f	a9 01		lda #$01			lda 	#1 							; set type to integer.
.019611	95 85		sta $85,x			sta 	XS_Type,x
.019613	60		rts				rts
.019614					GetSignCurrent:
.019614	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.019616	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.019617	90 15		bcc $01962e			bcc 	_GSCFloat 					; if clear do the float code.
.019619	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; if msb of integer set, it's negative
.01961b	30 0e		bmi $01962b			bmi 	_GSCMinus1
.01961d	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01961f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019621	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019623	d0 03		bne $019628			bne 	_GSCPlus1 					; check if zero by oring all together.
.019625					_GSCZero:
.019625	a9 00		lda #$00			lda 	#0
.019627	60		rts				rts
.019628					_GSCPlus1:
.019628	a9 01		lda #$01			lda 	#$01
.01962a	60		rts				rts
.01962b					_GSCMinus1:
.01962b	a9 ff		lda #$ff			lda 	#$FF
.01962d	60		rts				rts
.01962e					_GSCFloat:
.01962e	34 85		bit $85,x			bit 	XS_Type,x 					; check bits
.019630	70 f3		bvs $019625			bvs 	_GSCZero 					; if zero flag set return zero
.019632	30 f7		bmi $01962b			bmi 	_GSCMinus1 					; if sign set return -1
.019634	80 f2		bra $019628			bra 	_GSCPlus1		 			; else return +1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.019636					Unary_Abs:
.019636	20 94 93	jsr $019394			jsr 	EvaluateNumberX 			; get value
.019639	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; check right bracket.
.01963c	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01963e	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.019640	f0 07		beq $019649			beq 	_UAMinusFloat
.019642	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB of upper byte to see if negative
.019644	10 09		bpl $01964f			bpl 	_UAExit
.019646	4c 77 a1	jmp $01a177			jmp 	IntegerNegateAlways 		; if so negate it.
.019649					_UAMinusFloat:
.019649	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.01964b	29 7f		and #$7f			and		#$7F
.01964d	95 85		sta $85,x			sta 	XS_Type,x
.01964f					_UAExit:
.01964f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.019650					Unary_Peek:
.019650	a9 01		lda #$01			lda 	#1 							; 1 byte
.019652	80 06		bra $01965a			bra 	UPMain
.019654					Unary_Deek:
.019654	a9 02		lda #$02			lda 	#2 							; 2 bytes
.019656	80 02		bra $01965a			bra 	UPMain
.019658					Unary_Leek:
.019658	a9 04		lda #$04			lda 	#4 							; 4 bytes
.01965a					UPMain:
.01965a	48		pha				pha 								; save bytes to copy.
.01965b	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX 			; numeric parameter, the address to xEEK
.01965e	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.019661	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.019663	85 1c		sta $1c				sta 	zLTemp1
.019665	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019667	85 1d		sta $1d				sta 	zLTemp1+1
.019669	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01966b	85 1e		sta $1e				sta 	zLTemp1+2
.01966d	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01966f	85 1f		sta $1f				sta 	zLTemp1+3
.019671	a9 00		lda #$00			lda 	#0 							; clear target area, which might get
.019673	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; 1,2 or 4 bytes.
.019675	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019677	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019679	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01967b	68		pla				pla 								; restore bytes to copy
.01967c	da		phx				phx 								; save XY
.01967d	5a		phy				phy
.01967e	20 78 99	jsr $019978			jsr 	MemRead 					; read the bytes in, processor dependent routine.
.019681	7a		ply				ply 								; restore and exit
.019682	fa		plx				plx
.019683	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/pos.asm

.019684					Unary_Pos:
.019684	20 94 93	jsr $019394			jsr 	EvaluateNumberX 			; get value, which is a dummy.
.019687	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; check right bracket.
.01968a	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; get the position
.01968d	4c 05 96	jmp $019605			jmp		UnarySetAInteger			; and return that.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019690					Unary_Mod:
.019690	20 b8 96	jsr $0196b8			jsr 	_UMParameter 				; first parameter, get |param|
.019693	20 fe 99	jsr $0199fe			jsr 	CheckNextComma
.019696	da		phx				phx 								; second parameter, get |param|
.019697	e8		inx				inx
.019698	e8		inx				inx
.019699	e8		inx				inx
.01969a	e8		inx				inx
.01969b	e8		inx				inx
.01969c	e8		inx				inx
.01969d	20 b8 96	jsr $0196b8			jsr 	_UMParameter
.0196a0	fa		plx				plx
.0196a1	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen
.0196a4	20 f0 a0	jsr $01a0f0			jsr 	DivInteger32 				; divide, which handily leaves ....
.0196a7	a5 1c		lda $1c				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.0196a9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0196ab	a5 1d		lda $1d				lda 	zLTemp1+1
.0196ad	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0196af	a5 1e		lda $1e				lda 	zLTemp1+2
.0196b1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0196b3	a5 1f		lda $1f				lda 	zLTemp1+3
.0196b5	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0196b7	60		rts				rts
.0196b8					_UMParameter:
.0196b8	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX 			; get value
.0196bb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.0196bd	10 03		bpl $0196c2			bpl 	_UMNotSigned
.0196bf	20 77 a1	jsr $01a177			jsr 	IntegerNegateAlways
.0196c2					_UMNotSigned:
.0196c2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.0196c3					Unary_Usr:
.0196c3	20 94 93	jsr $019394			jsr 	EvaluateNumberX 			; numeric parameter
.0196c6	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.0196c9	da		phx				phx 								; save XY
.0196ca	5a		phy				phy
.0196cb	22 0c 03 00	jsl $00030c			jsl 	UserVector 					; with the parameter in the base mantissa
.0196cf	7a		ply				ply 								; restore YX and exit with whatever the
.0196d0	fa		plx				plx 								; routine called has chosen to do with it.
.0196d1	60		rts				rts
.0196d2					USRDefault:
.0196d2	20 83 85	jsr $018583			jsr ERR_Handler
>0196d5	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>0196dd	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.0196e4					Unary_Val:
.0196e4	20 ab 93	jsr $0193ab			jsr 	EvaluateStringX 			; get string
.0196e7	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; check right bracket.
.0196ea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.0196ec	85 20		sta $20				sta 	zGenPtr
.0196ee	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0196f0	85 21		sta $21				sta 	zGenPtr+1
.0196f2	da		phx				phx
.0196f3	5a		phy				phy
.0196f4	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.0196f6	b1 20		lda ($20),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.0196f8	f0 1b		beq $019715			beq 	UVBadNumber
.0196fa	aa		tax				tax
.0196fb					_UVCopy1:
.0196fb	c8		iny				iny
.0196fc	c0 18		cpy #$18			cpy 	#24 						; too long
.0196fe	f0 15		beq $019715			beq 	UVBadNumber
.019700	b1 20		lda ($20),y			lda 	(zGenPtr),y					; copy character
.019702	99 14 03	sta $0314,y			sta 	Num_Buffer-1,y
.019705	a9 00		lda #$00			lda 	#0 							; make string ASCIIZ.
.019707	99 15 03	sta $0315,y			sta 	Num_Buffer,y
.01970a	ca		dex				dex
.01970b	d0 ee		bne $0196fb			bne 	_UVCopy1
.01970d	7a		ply				ply
.01970e	fa		plx				plx
.01970f	20 23 97	jsr $019723			jsr 	ConvertNumBuffer 			; convert string in NumBuffer to mantissa,x
.019712	b0 01		bcs $019715			bcs 	UVBadNumber
.019714	60		rts				rts
.019715					UVBadNumber:
.019715	20 83 85	jsr $018583			jsr ERR_Handler
>019718	42 61 64 20 4e 75 6d 62			.text "Bad Number",0
>019720	65 72 00
.019723					ConvertNumBuffer:
.019723	5a		phy				phy
.019724	a9 15		lda #$15			lda 	#Num_Buffer & $FF 			; set zGenPtr to point to buffer.
.019726	85 20		sta $20				sta 	zGenPtr
.019728	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.01972a	85 21		sta $21				sta 	zGenPtr+1
.01972c	ad 15 03	lda $0315			lda 	Num_Buffer 					; first character is - ?
.01972f	c9 2d		cmp #$2d			cmp 	#"-"
.019731	d0 02		bne $019735			bne 	_UVNotMinus1
.019733	e6 20		inc $20				inc 	zGenPtr 					; this time just fix the pointer.
.019735					_UVNotMinus1:
.019735	20 49 a2	jsr $01a249			jsr 	IntFromString 				; get integer
.019738	b0 22		bcs $01975c			bcs 	_UVFail
.01973a	20 c9 a7	jsr $01a7c9			jsr 	FPFromString 				; possibly float it.
.01973d	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; done the whole string
.01973f	d0 1b		bne $01975c			bne 	_UVFail 					; no, exit.
.019741	ad 15 03	lda $0315			lda 	Num_Buffer 					; look at numbuffer
.019744	c9 2d		cmp #$2d			cmp 	#"-"
.019746	d0 11		bne $019759			bne 	_UVNotMinus2
.019748	b5 85		lda $85,x			lda 	XS_Type,x 					; type is float ?
.01974a	29 0f		and #$0f			and 	#$0F
.01974c	f0 05		beq $019753			beq 	_UVNegateFloat
.01974e	20 77 a1	jsr $01a177			jsr 	IntegerNegateAlways
.019751	80 06		bra $019759			bra 	_UVNotMinus2
.019753					_UVNegateFloat:
.019753	b5 85		lda $85,x			lda 	XS_Type,x 					; set the sign bit.
.019755	09 80		ora #$80			ora 	#$80
.019757	95 85		sta $85,x			sta 	XS_Type,x
.019759					_UVNotMinus2:
.019759	7a		ply				ply
.01975a	18		clc				clc
.01975b	60		rts				rts
.01975c	7a		ply		_UVFail:ply
.01975d	38		sec				sec
.01975e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.01975f					Unary_Str:
.01975f	20 94 93	jsr $019394			jsr 	EvaluateNumberX 			; numeric parameter
.019762	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.019765	a9 00		lda #$00			lda 	#0 							; reset buffer index
.019767	8d 14 03	sta $0314			sta 	NumBufX
.01976a	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.01976c	4a		lsr a				lsr 	a 							; bit 0 identifies an integer.
.01976d	b0 05		bcs $019774			bcs 	_USInt 						; if msb set do as integer
.01976f	20 0e a7	jsr $01a70e			jsr 	FPToString 					; call fp to str otherwise
.019772	80 03		bra $019777			bra 	_USDuplicate
.019774	20 94 a1	jsr $01a194	_USInt:	jsr 	IntToString					; call int to str.
.019777					_USDuplicate:
.019777	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.01977a	1a		inc a				inc 	a 							; one more for length
.01977b	20 43 9a	jsr $019a43			jsr 	AllocateTempString 			; allocate space for it.
.01977e	5a		phy				phy 								; save Y
.01977f	a0 00		ldy #$00			ldy 	#0 							; start copying
.019781	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.019784	20 6e 9a	jsr $019a6e			jsr 	WriteTempString
.019787	c8		iny				iny
.019788	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.01978b	d0 f4		bne $019781			bne 	_USCopy
.01978d	7a		ply				ply 								; restore Y
.01978e	4c 6b 99	jmp $01996b			jmp 	UnaryReturnTempStr 			; return newly created temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019791					Unary_Asc:
.019791	20 ab 93	jsr $0193ab			jsr 	EvaluateStringX 			; string parameter
.019794	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.019797	5a		phy				phy 								; get the string length
.019798	a0 00		ldy #$00			ldy 	#0
.01979a	b1 20		lda ($20),y			lda 	(zGenPtr),y
.01979c	f0 07		beq $0197a5			beq 	_UAIllegal 					; must be at least one character, 0 => error
.01979e	c8		iny				iny
.01979f	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; read the first character
.0197a1	7a		ply				ply
.0197a2	4c 05 96	jmp $019605			jmp 	UnarySetAInteger 			; return that as an integer 0-255.
.0197a5					_UAIllegal:
.0197a5	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.0197a8					Unary_Len:
.0197a8	20 ab 93	jsr $0193ab			jsr 	EvaluateStringX 			; string parameter
.0197ab	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.0197ae	5a		phy				phy 								; get the string length
.0197af	a0 00		ldy #$00			ldy 	#0
.0197b1	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0197b3	7a		ply				ply
.0197b4	4c 05 96	jmp $019605			jmp 	UnarySetAInteger 			; return as an integer.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.0197b7					Unary_Mid:
.0197b7	20 ab 93	jsr $0193ab			jsr 	EvaluateStringX 				; get string.
.0197ba	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197bc	48		pha				pha
.0197bd	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197bf	48		pha				pha
.0197c0	20 fe 99	jsr $0199fe			jsr 	CheckNextComma 					; skip comma
.0197c3	20 4c 98	jsr $01984c			jsr 	SLIByteParameter 				; get a byte parameter (start)
.0197c6	48		pha				pha 									; and push it.
.0197c7	20 fe 99	jsr $0199fe			jsr 	CheckNextComma 					; skip comma
.0197ca	20 4c 98	jsr $01984c			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.0197cd	48		pha				pha 									; and push it.
.0197ce	80 41		bra $019811			bra 	SLIProcess
.0197d0					Unary_Left:
.0197d0	20 ab 93	jsr $0193ab			jsr 	EvaluateStringX 				; get string.
.0197d3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197d5	48		pha				pha
.0197d6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197d8	48		pha				pha
.0197d9	a9 01		lda #$01			lda 	#1 								; push start position (1)
.0197db	48		pha				pha
.0197dc	20 fe 99	jsr $0199fe			jsr 	CheckNextComma 					; skip comma
.0197df	20 4c 98	jsr $01984c			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.0197e2	48		pha				pha 									; and push it.
.0197e3	80 2c		bra $019811			bra 	SLIProcess
.0197e5					Unary_Right:
.0197e5	20 ab 93	jsr $0193ab			jsr 	EvaluateStringX 				; get string.
.0197e8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.0197ea	48		pha				pha
.0197eb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197ed	48		pha				pha
.0197ee	da		phx				phx 									; get the string length and push on stack.
.0197ef	a2 00		ldx #$00			ldx 	#0
.0197f1	a1 20		lda ($20,x)			lda		(zGenPtr,x)
.0197f3	fa		plx				plx
.0197f4	48		pha				pha
.0197f5	20 fe 99	jsr $0199fe			jsr 	CheckNextComma 					; skip comma
.0197f8	20 4c 98	jsr $01984c			jsr 	SLIByteParameter 				; get a byte parameter.
.0197fb	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.0197fe	68		pla				pla 									; restore string length.
.0197ff	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019800	38		sec				sec
.019801	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019804	f0 02		beq $019808			beq 	_URStart 						; if <= 0 start from 1.
.019806	10 02		bpl $01980a			bpl 	_UROkay
.019808					_URStart:
.019808	a9 01		lda #$01			lda 	#1
.01980a					_UROkay:
.01980a	48		pha				pha 									; push start
.01980b	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.01980e	48		pha				pha
.01980f	80 00		bra $019811			bra 	SLIProcess
.019811					SLIProcess:
.019811	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 				; closing right bracket.
.019814	68		pla				pla
.019815	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.019818	1a		inc a				inc 	a 								; allocate +1 for it.
.019819	20 43 9a	jsr $019a43			jsr 	AllocateTempString
.01981c	68		pla				pla 									; pop start number off stack.
.01981d	f0 3b		beq $01985a			beq 	SLIError 						; exit if start = 0
.01981f	8d a1 03	sta $03a1			sta 	SliceStart
.019822	68		pla				pla  									; pop string address.
.019823	85 21		sta $21				sta 	zGenPtr+1
.019825	68		pla				pla
.019826	85 20		sta $20				sta 	zGenPtr
.019828	da		phx				phx
.019829	5a		phy				phy
.01982a	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01982c	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.01982f					_SLICopy:
.01982f	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.019832	f0 12		beq $019846			beq 	_SLIExit
.019834	ce a2 03	dec $03a2			dec 	SliceCount
.019837	98		tya				tya 									; index of character
.019838	c1 20		cmp ($20,x)			cmp 	(zGenPtr,x)						; compare against length
.01983a	f0 02		beq $01983e			beq 	_SLIOk 							; if equal, okay.
.01983c	b0 08		bcs $019846			bcs 	_SLIExit 						; if past end, then exit.
.01983e	b1 20		lda ($20),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.019840	c8		iny				iny
.019841	20 6e 9a	jsr $019a6e			jsr 	WriteTempString
.019844	80 e9		bra $01982f			bra 	_SLICopy 						; go round till copied characters
.019846					_SLIExit:
.019846	7a		ply				ply 									; restore YX
.019847	fa		plx				plx
.019848	4c 6b 99	jmp $01996b			jmp 	UnaryReturnTempStr 				; return new temporary string.
.01984b	ea		nop				nop
.01984c					SLIByteParameter:
.01984c	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX 				; get integer
.01984f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.019851	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019853	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019855	d0 03		bne $01985a			bne 	SLIError
.019857	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019859	60		rts				rts
.01985a					SLIError:
.01985a	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.01985d					Unary_Hex:
.01985d	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX 			; numeric parameter
.019860	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.019863	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.019865	20 43 9a	jsr $019a43			jsr 	AllocateTempString			; allocate string space
.019868	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.01986a	20 8e 98	jsr $01988e			jsr 	_UHConvert
.01986d	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01986f	20 8e 98	jsr $01988e			jsr 	_UHConvert
.019872	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019874	20 8e 98	jsr $01988e			jsr 	_UHConvert
.019877	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019879	20 8e 98	jsr $01988e			jsr 	_UHConvert
.01987c	5a		phy				phy 								; get length of new string
.01987d	a0 00		ldy #$00			ldy 	#0
.01987f	b1 22		lda ($22),y			lda 	(zTempStr),y
.019881	7a		ply				ply
.019882	c9 00		cmp #$00			cmp 	#0 							; if it was non zero okay
.019884	d0 05		bne $01988b			bne 	_UHExit 					; otherwise suppressed all leading zeros !
.019886	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.019888	20 6e 9a	jsr $019a6e			jsr 	WriteTempString
.01988b					_UHExit:
.01988b	4c 6b 99	jmp $01996b			jmp 	UnaryReturnTempStr 			; return new temporary string.
.01988e					_UHConvert:
.01988e	48		pha				pha
.01988f	4a		lsr a				lsr 	a 							; do MSB
.019890	4a		lsr a				lsr 	a
.019891	4a		lsr a				lsr 	a
.019892	4a		lsr a				lsr 	a
.019893	20 97 98	jsr $019897			jsr 	_UHNibble
.019896	68		pla				pla 								; do LSB
.019897					_UHNibble:
.019897	29 0f		and #$0f			and 	#15 						; get nibble
.019899	d0 0c		bne $0198a7			bne 	_UHNonZero 					; if not zero, write it out anyway.
.01989b	5a		phy				phy									; get the length
.01989c	a0 00		ldy #$00			ldy 	#0
.01989e	b1 22		lda ($22),y			lda 	(zTempStr),y
.0198a0	7a		ply				ply
.0198a1	c9 00		cmp #$00			cmp 	#0 							; length = 0 => suppress leading zeros.
.0198a3	f0 0d		beq $0198b2			beq 	_UHExit2
.0198a5	a9 00		lda #$00			lda 	#0 							; length > 0, so can't suppress any more.
.0198a7					_UHNonZero:
.0198a7	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0198a9	90 02		bcc $0198ad			bcc 	_UHDigit
.0198ab	69 06		adc #$06			adc 	#7-1
.0198ad					_UHDigit:
.0198ad	69 30		adc #$30			adc 	#48
.0198af	20 6e 9a	jsr $019a6e			jsr 	WriteTempString				; output to temp string.
.0198b2					_UHExit2:
.0198b2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.0198b3					Unary_Dec:
.0198b3	20 ab 93	jsr $0193ab			jsr 	EvaluateStringX 			; string parameter
.0198b6	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.0198b9	5a		phy				phy
.0198ba	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.0198bc	b1 20		lda ($20),y			lda 	(zGenPtr),y
.0198be	f0 43		beq $019903			beq 	_UDFail 					; must fail if zero.
.0198c0	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter of chars to process.
.0198c3	a9 00		lda #$00			lda 	#0 							; set result to zero
.0198c5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198c7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0198c9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0198cb	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0198cd	a9 01		lda #$01			lda 	#1 							; set type to integer.
.0198cf	95 85		sta $85,x			sta 	XS_Type,x
.0198d1					_UDConvertLoop:
.0198d1	5a		phy				phy 								; shift mantissa left 4
.0198d2	a0 04		ldy #$04			ldy 	#4
.0198d4					_UDShift:
.0198d4	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.0198d6	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.0198d8	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.0198da	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.0198dc	88		dey				dey
.0198dd	d0 f5		bne $0198d4			bne 	_UDShift
.0198df	7a		ply				ply
.0198e0	c8		iny				iny 								; next character
.0198e1	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; fetch it.
.0198e3	20 06 99	jsr $019906			jsr 	ConvertUpper 				; convert to U/C
.0198e6	c9 30		cmp #$30			cmp 	#"0" 						; range 0-9
.0198e8	90 19		bcc $019903			bcc 	_UDFail
.0198ea	c9 3a		cmp #$3a			cmp 	#"9"+1
.0198ec	90 08		bcc $0198f6			bcc 	_UDOkay
.0198ee	e9 37		sbc #$37			sbc 	#7+"0" 						; A-F fudge
.0198f0	90 11		bcc $019903			bcc 	_UDFail 					; fails if between 9 and @
.0198f2	c9 10		cmp #$10			cmp 	#16 						; must be < 16 as hexadecimal.
.0198f4	b0 0d		bcs $019903			bcs 	_UDFail
.0198f6					_UDOkay:
.0198f6	29 0f		and #$0f			and 	#15 						; nibble only
.0198f8	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; OR into the bottom byte.
.0198fa	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0198fc	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character in the string.
.0198ff	d0 d0		bne $0198d1			bne 	_UDConvertLoop
.019901	7a		ply				ply
.019902	60		rts				rts
.019903					_UDFail:
.019903	4c 72 85	jmp $018572			jmp 	BadParamError
.019906					ConvertUpper:
.019906	c9 61		cmp #$61			cmp 	#"a"
.019908	90 07		bcc $019911			bcc 	_CUExit
.01990a	c9 7b		cmp #$7b			cmp 	#"z"+1
.01990c	b0 03		bcs $019911			bcs 	_CUExit
.01990e	38		sec				sec
.01990f	e9 20		sbc #$20			sbc 	#32
.019911	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019912					Unary_Chr:
.019912	20 a2 93	jsr $0193a2			jsr 	EvaluateIntegerX			; numeric parameter which is the character we want
.019915	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; right bracket.
.019918	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01991a	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01991c	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01991e	d0 0d		bne $01992d			bne 	_UCChar
.019920	a9 02		lda #$02			lda 	#1+1 						; one character string. 2 bytes - size+char
.019922	20 43 9a	jsr $019a43			jsr 	AllocateTempString			; allocate it.
.019925	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019927	20 6e 9a	jsr $019a6e			jsr 	WriteTempString
.01992a	4c 6b 99	jmp $01996b			jmp 	UnaryReturnTempStr 			; and return that string.
.01992d					_UCChar:
.01992d	4c 72 85	jmp $018572			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.019930					Unary_Spc:
.019930	20 4c 98	jsr $01984c			jsr 	SLIByteParameter 			; get number of spaces
.019933	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; skip )
.019936	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; count of spaces
.019938					UnarySpcCreate:
.019938	c9 fe		cmp #$fe			cmp 	#maxString+1				; validate
.01993a	b0 14		bcs $019950			bcs 	_USSize
.01993c	48		pha				pha 								; save length
.01993d	1a		inc a				inc 	a 							; allocate one more.
.01993e	20 43 9a	jsr $019a43			jsr 	AllocateTempString
.019941	68		pla				pla 								; get length
.019942	f0 27		beq $01996b			beq 	UnaryReturnTempStr 			; if zero (spc(0)) return the current temp string
.019944					_USLoop:
.019944	48		pha				pha
.019945	a9 20		lda #$20			lda 	#" "
.019947	20 6e 9a	jsr $019a6e			jsr 	WriteTempString
.01994a	68		pla				pla
.01994b	3a		dec a				dec 	a
.01994c	d0 f6		bne $019944			bne 	_USLoop
.01994e	80 1b		bra $01996b			bra 	UnaryReturnTempStr 			; and return the temporary space.
.019950					_USSize:
.019950	4c 72 85	jmp $018572			jmp 	BadParamError
.019953					Unary_Tab:
.019953	a2 00		ldx #$00			ldx 	#0 							; required TAB position.
.019955	20 4c 98	jsr $01984c			jsr 	SLIByteParameter
.019958	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen
.01995b	20 4d 85	jsr $01854d			jsr 	VIOCharGetPosition 			; were are we ?
.01995e	85 10		sta $10				sta 	zTemp1 						; calculate required-current
.019960	38		sec				sec
.019961	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; return chars required.
.019963	e5 10		sbc $10				sbc 	zTemp1
.019965	b0 d1		bcs $019938			bcs 	UnarySpcCreate 				; if not there, use SPC() code to generate string
.019967	a9 00		lda #$00			lda 	#0 							; if there or better, no characters required.
.019969	80 cd		bra $019938			bra 	UnarySpcCreate
.01996b					UnaryReturnTempStr:
.01996b	a5 22		lda $22				lda 	zTempStr 					; copy temp string addr -> mantissa
.01996d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01996f	a5 23		lda $23				lda 	zTempStr+1
.019971	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019973	a9 02		lda #$02			lda 	#2 							; set type to string
.019975	95 85		sta $85,x			sta 	XS_Type,x
.019977	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.019978					MemRead:
.019978	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01997b	a0 00		ldy #$00			ldy 	#0 							; start from here
.01997d	b7 1c		lda [$1c],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.01997f	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.019981	c8		iny				iny 								; next to copy
.019982	e8		inx				inx
.019983	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019986	d0 f5		bne $01997d			bne 	_MLoop1
.019988	60		rts				rts
.019989					MemWrite:
.019989	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.01998c	a0 00		ldy #$00			ldy 	#0 							; start from here
.01998e	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.019990	97 1c		sta [$1c],y			sta 	[zlTemp1],y 				; write it out
.019992	c8		iny				iny 								; next to copy
.019993	e8		inx				inx
.019994	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.019997	d0 f5		bne $01998e			bne 	_MLoop1
.019999	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.01999a					UpdateProgramEnd:
.01999a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.01999c	85 18		sta $18				sta 	zCodePtr+0
.01999e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0199a0	85 19		sta $19				sta 	zCodePtr+1
.0199a2	a9 00		lda #$00			lda 	#0
.0199a4	85 1a		sta $1a				sta 	zCodePtr+2
.0199a6	85 1b		sta $1b				sta 	zCodePtr+3
.0199a8	a0 03		ldy #$03			ldy 	#3
.0199aa					_UPDLoop:
.0199aa	a0 00		ldy #$00			ldy 	#0
.0199ac	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199ae	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.0199b0	f0 0f		beq $0199c1			beq 	_UPDFoundEnd
.0199b2	a0 00		ldy #$00			ldy 	#0 							; point to offset
.0199b4	b7 18		lda [$18],y			lda 	[zCodePtr],y 				; read it
.0199b6	18		clc				clc
.0199b7	65 18		adc $18				adc 	zCodePtr 					; add to code pointer
.0199b9	85 18		sta $18				sta 	zCodePtr
.0199bb	90 02		bcc $0199bf			bcc 	_SNLNoCarry
.0199bd	e6 19		inc $19				inc 	zCodePtr+1
.0199bf					_SNLNoCarry:
.0199bf	80 e9		bra $0199aa			bra 	_UPDLoop
.0199c1					_UPDFoundEnd:
.0199c1	18		clc				clc 								; end of program 2 on.
.0199c2	a5 18		lda $18				lda 	zCodePtr
.0199c4	69 02		adc #$02			adc 	#2
.0199c6	8d 04 03	sta $0304			sta 	endOfProgram
.0199c9	a5 19		lda $19				lda 	zCodePtr+1
.0199cb	69 00		adc #$00			adc 	#0
.0199cd	8d 05 03	sta $0305			sta 	endOfProgram+1
.0199d0	a5 1a		lda $1a				lda 	zCodePtr+2
.0199d2	69 00		adc #$00			adc		#0
.0199d4	8d 06 03	sta $0306			sta 	endOfProgram+2
.0199d7	a5 1b		lda $1b				lda 	zCodePtr+3
.0199d9	69 00		adc #$00			adc 	#0
.0199db	8d 07 03	sta $0307			sta 	endOfProgram+3
.0199de	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.0199df					CheckNextToken:
.0199df	d7 18		cmp [$18],y			cmp 	[zCodePtr],y
.0199e1	d0 02		bne $0199e5			bne 	CTFail 						; no, then fail
.0199e3	c8		iny				iny
.0199e4	60		rts				rts
.0199e5					CTFail:
.0199e5	20 83 85	jsr $018583			jsr ERR_Handler
>0199e8	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>0199f0	74 6f 6b 65 6e 00
.0199f6					CheckNextRParen:
.0199f6	b7 18		lda [$18],y			lda 	[zCodePtr],y
.0199f8	c9 be		cmp #$be			cmp 	#token_rparen 						; does it match
.0199fa	d0 e9		bne $0199e5			bne 	CTFail 						; fail if not
.0199fc	c8		iny				iny
.0199fd	60		rts				rts
.0199fe					CheckNextComma:
.0199fe	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a00	c9 bf		cmp #$bf			cmp 	#token_comma 						; does it match
.019a02	d0 e1		bne $0199e5			bne 	CTFail 						; fail if not
.019a04	c8		iny				iny
.019a05	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019a06					StringConcrete:
.019a06	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source string to zTemp1
.019a08	85 10		sta $10				sta 	zTemp1
.019a0a	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019a0c	85 11		sta $11				sta 	zTemp1+1
.019a0e	a0 00		ldy #$00			ldy 	#0 							; empty string, return default empty
.019a10	b1 10		lda ($10),y			lda 	(zTemp1),y
.019a12	f0 26		beq $019a3a			beq		_SCEmpty 					; concreting it wastes memory.
.019a14	18		clc				clc 								; from the string pointer
.019a15	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019a18	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019a1a	8d 00 03	sta $0300			sta 	StringPtr
.019a1d	85 12		sta $12				sta 	zTemp2
.019a1f	ad 01 03	lda $0301			lda 	StringPtr+1
.019a22	e9 00		sbc #$00			sbc 	#0
.019a24	8d 01 03	sta $0301			sta 	StringPtr+1
.019a27	85 13		sta $13				sta 	zTemp2+1
.019a29	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019a2b	1a		inc a				inc 	a
.019a2c	aa		tax				tax
.019a2d	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.019a2f	91 12		sta ($12),y			sta 	(zTemp2),y
.019a31	c8		iny				iny
.019a32	ca		dex				dex
.019a33	d0 f8		bne $019a2d			bne 	_SCCopy
.019a35	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019a37	a6 12		ldx $12				ldx 	zTemp2
.019a39	60		rts				rts
.019a3a					_SCEmpty:
.019a3a	a9 00		lda #$00			lda 	#0
.019a3c	85 27		sta $27				sta 	zNullString
.019a3e	a9 00		lda #$00			lda 	#zNullString >> 8
.019a40	a2 27		ldx #$27			ldx 	#zNulLString & $FF
.019a42	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019a43					AllocateTempString:
.019a43	48		pha				pha 								; save required count.
.019a44	a5 23		lda $23				lda 	zTempStr+1 					; check if initialised yet ?
.019a46	d0 0b		bne $019a53			bne 	_ATSInitialised
.019a48	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.019a4b	85 22		sta $22				sta 	zTempStr					; space, this is for strings to be concreted.
.019a4d	ad 01 03	lda $0301			lda 	StringPtr+1
.019a50	3a		dec a				dec 	a 							; allow the page.
.019a51	85 23		sta $23				sta 	zTempStr+1
.019a53					_ATSInitialised:
.019a53	68		pla				pla 								; get required count back.
.019a54	49 ff		eor #$ff			eor 	#$FF 						; negate and add 2's complement.
.019a56	1a		inc a				inc 	a
.019a57	18		clc				clc
.019a58	65 22		adc $22				adc 	zTempStr 					; "add" to the temp string pointer
.019a5a	85 22		sta $22				sta 	zTempStr					; which means the tsp is also the current.
.019a5c	a9 ff		lda #$ff			lda 	#$FF
.019a5e	65 23		adc $23				adc 	zTempStr+1
.019a60	85 23		sta $23				sta 	zTempStr+1
.019a62	a9 00		lda #$00			lda 	#0 							; clear temp string by zeroing length.
.019a64	5a		phy				phy
.019a65	a8		tay				tay
.019a66	91 22		sta ($22),y			sta 	(zTempStr),y
.019a68	7a		ply				ply
.019a69	1a		inc a				inc 	a 							; reset the write index to 1 (first character)
.019a6a	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.019a6d	60		rts				rts
.019a6e					WriteTempString:
.019a6e	5a		phy				phy 								; save Y
.019a6f	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.019a72	91 22		sta ($22),y			sta 	(zTempStr),y 				; write character out.
.019a74	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.019a77	98		tya				tya 								; unchanged Y is now length
.019a78	a0 00		ldy #$00			ldy 	#0
.019a7a	91 22		sta ($22),y			sta 	(zTempStr),y
.019a7c	7a		ply				ply 								; restore Y and exit
.019a7d	60		rts				rts
.019a7e					CreateTempStringCopy:
.019a7e	da		phx				phx 								; save X
.019a7f	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a81	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.019a82	20 43 9a	jsr $019a43			jsr 	AllocateTempString 			; allocate memory for temporary string.
.019a85	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a87	c8		iny				iny
.019a88	3a		dec a				dec 	a 							; make the actual length in characters, allowing
.019a89	3a		dec a				dec 	a 							; for the marker and the length.
.019a8a	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.019a8c	81 22		sta ($22,x)			sta 	(zTempStr,x)
.019a8e	85 1c		sta $1c				sta 	zLTemp1 					; that's used as a count.
.019a90	09 00		ora #$00			ora 	#0 							; if zero already, exit
.019a92	f0 0e		beq $019aa2			beq 	_CTSCExit
.019a94					_CTSCLoop:
.019a94	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019a96	c8		iny				iny
.019a97	5a		phy				phy 								; save Y
.019a98	e8		inx				inx 								; bump index
.019a99	da		phx				phx 								; save that
.019a9a	7a		ply				ply 								; index into Y
.019a9b	91 22		sta ($22),y			sta 	(zTempStr),y 				; save at index position
.019a9d	7a		ply				ply 								; restore Y
.019a9e	c6 1c		dec $1c				dec 	zLTemp1 					; do for each character, this is the counter.
.019aa0	d0 f2		bne $019a94			bne 	_CTSCLoop
.019aa2					_CTSCExit:
.019aa2	fa		plx				plx 								; restore X
.019aa3	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokkeyword.asm

.019aa4					TokeniseKeyword:
.019aa4	98		tya				tya 								; fix up genptr so Y = 0 access the current one.
.019aa5	18		clc				clc
.019aa6	65 20		adc $20				adc 	zGenPtr
.019aa8	85 20		sta $20				sta 	zGenPtr
.019aaa	90 02		bcc $019aae			bcc 	_TKWNoBump
.019aac	e6 21		inc $21				inc 	zGenPtr+1
.019aae					_TKWNoBump:
.019aae	a0 00		ldy #$00			ldy 	#0 							; this adds Y to genPtr, so it will still scan
.019ab0	da		phx				phx
.019ab1	a9 c7		lda #$c7			lda 	#KeyWordText & $FF 			; scan this table.
.019ab3	a2 86		ldx #$86			ldx 	#(KeyWordText >> 8) & $FF
.019ab5	20 c0 9a	jsr $019ac0			jsr 	TKWScanTokenTable
.019ab8	fa		plx				plx
.019ab9	90 04		bcc $019abf			bcc 	_TKWNoWrite
.019abb	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write the token out.
.019abe	e8		inx				inx
.019abf					_TKWNoWrite:
.019abf	60		rts				rts
.019ac0					TKWScanTokenTable:
.019ac0	86 1d		stx $1d				stx 	zLTemp1+1
.019ac2	85 1c		sta $1c				sta 	zLTemp1+0 						; store at zLTemp1
.019ac4	a9 01		lda #$01			lda 	#KeywordText >> 16 				; 24 bit addresses in the 65816
.019ac6	85 1e		sta $1e				sta 	zLTemp1+2 						; lovely.
.019ac8	a0 00		ldy #$00			ldy 	#0 								; read and capitalise the first character
.019aca	84 12		sty $12				sty 	zTemp2 							; zero the longest length match.
.019acc	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019ace	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise 					; save this in zTemp3
.019ad1	85 14		sta $14				sta 	zTemp3
.019ad3	a9 80		lda #$80			lda 	#$80 							; current token in zTemp3+1
.019ad5	85 15		sta $15				sta 	zTemp3+1
.019ad7					_TKWScanLoop:
.019ad7	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019ad9	29 7f		and #$7f			and 	#$7F 							; drop bit 7, it might be 1 character long.
.019adb	c5 14		cmp $14				cmp 	zTemp3 							; compare against got character.
.019add	d0 26		bne $019b05			bne		_TKWNext 						; if it doesn't match, go to next.
.019adf	20 24 9b	jsr $019b24			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019ae2	a0 00		ldy #$00			ldy 	#0 								; compare the tokens directly
.019ae4					_TKWCompareFull:
.019ae4	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019ae6	29 7f		and #$7f			and 	#$7F 							; drop bit 7
.019ae8	85 16		sta $16				sta 	zTemp4
.019aea	b1 20		lda ($20),y			lda 	(zGenPtr),y 					; compare against keyword in text.
.019aec	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise 					; make it U/C
.019aef	c5 16		cmp $16				cmp 	zTemp4 							; compare against table char w/o bit 7.
.019af1	d0 12		bne $019b05			bne 	_TKWNext 						; failed, go to next slot.
.019af3	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019af5	c8		iny				iny 									; bump pointer
.019af6	0a		asl a				asl 	a 								; shift bit 7 into C
.019af7	90 eb		bcc $019ae4			bcc 	_TKWCompareFull					; keep going till that bit is 7 e.g. token matches
.019af9	c4 12		cpy $12				cpy 	zTemp2 							; compare against longest match
.019afb	90 08		bcc $019b05			bcc 	_TKWNext 						; if shorter, the original was better
.019afd	84 12		sty $12				sty 	zTemp2							; update longest match.
.019aff	a5 15		lda $15				lda 	zTemp3+1 						; copy current token
.019b01	85 13		sta $13				sta 	zTemp2+1 						; into matched token slot.
.019b03	a0 00		ldy #$00			ldy 	#0 								; reset to start of matched token for forward
.019b05					_TKWNext:
.019b05	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b07	c8		iny				iny 									; next one.
.019b08	0a		asl a				asl 	a 								; if bit 7 clear loop back.
.019b09	90 fa		bcc $019b05			bcc 	_TKWNext
.019b0b	e6 15		inc $15				inc 	zTemp3+1 						; increment current token.
.019b0d	98		tya				tya 									; has Y gone negative.
.019b0e	10 03		bpl $019b13			bpl 	_TKWNoYZero
.019b10	20 24 9b	jsr $019b24			jsr 	_TKWClearY 						; make it so (zTemp1),y now points to zTemp1
.019b13					_TKWNoYZero:
.019b13	b7 1c		lda [$1c],y			lda 	[zLTemp1],y
.019b15	d0 c0		bne $019ad7			bne 	_TKWScanLoop 					; if not, try the next one.
.019b17	a5 12		lda $12				lda 	zTemp2 							; length of longest match
.019b19	f0 05		beq $019b20			beq 	_TKWFail 						; if zero, none found.
.019b1b	a8		tay				tay 									; return the token in zTemp2, length => y
.019b1c	a5 13		lda $13				lda 	zTemp2+1 						; so the offset is right.
.019b1e	38		sec				sec
.019b1f	60		rts				rts
.019b20					_TKWFail:
.019b20	a0 00		ldy #$00			ldy 	#0 								; return with Y = 0 and carry clear.
.019b22	18		clc				clc
.019b23	60		rts				rts
.019b24					_TKWClearY:
.019b24	98		tya				tya
.019b25	18		clc				clc
.019b26	65 1c		adc $1c				adc 	zLTemp1
.019b28	85 1c		sta $1c				sta 	zLTemp1
.019b2a	90 02		bcc $019b2e			bcc 	_TKWCNoBump
.019b2c	e6 1d		inc $1d				inc 	zLTemp1+1
.019b2e					_TKWCNoBump:
.019b2e	a0 00		ldy #$00			ldy 	#0
.019b30	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokenise.asm

.019b31					TokeniseString:
.019b31	85 20		sta $20				sta 	zGenPtr 					; save source
.019b33	86 21		stx $21				stx 	zGenPtr+1
.019b35	a0 00		ldy #$00			ldy 	#0 							; source
.019b37	a2 00		ldx #$00			ldx 	#0 							; target
.019b39					_TSMainLoop:
.019b39					_TSSkipSpaces:
.019b39	b1 20		lda ($20),y			lda 	(zGenPtr),y					; skip over spaces.
.019b3b	c8		iny				iny
.019b3c	c9 20		cmp #$20			cmp 	#" "
.019b3e	f0 f9		beq $019b39			beq 	_TSSkipSpaces
.019b40	c9 30		cmp #$30			cmp 	#"0" 						; is it a constant
.019b42	90 0a		bcc $019b4e			bcc 	_TSNotConstant
.019b44	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b46	b0 06		bcs $019b4e			bcs 	_TSNotConstant
.019b48	88		dey				dey 								; point back to start
.019b49	20 6d 9c	jsr $019c6d			jsr 	TokeniseConstant 			; tokenise a constant
.019b4c	80 eb		bra $019b39			bra 	_TSMainLoop			 		; and loop back.
.019b4e					_TSNotConstant:
.019b4e	c9 20		cmp #$20			cmp 	#32 						; end of line.
.019b50	90 52		bcc $019ba4			bcc 	_TSExit
.019b52	c9 22		cmp #$22			cmp		#'"'						; quoted string
.019b54	f0 55		beq $019bab			beq 	_TSQuotedString
.019b56	c9 2e		cmp #$2e			cmp 	#'.' 						; decimal.
.019b58	f0 56		beq $019bb0			beq 	_TSDecimal
.019b5a	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise 				; make U/C
.019b5d	c9 52		cmp #$52			cmp 	#"R" 						; is it R, if so check for REM ?
.019b5f	d0 05		bne $019b66			bne 	_TSNoRemCheck
.019b61	20 b5 9b	jsr $019bb5			jsr 	TOKCheckREM
.019b64	b0 d3		bcs $019b39			bcs 	_TSMainLoop 				; and if REM okay, go back.
.019b66					_TSNoRemCheck:
.019b66	88		dey				dey 								; point to character
.019b67	20 a4 9a	jsr $019aa4			jsr 	TokeniseKeyword 			; try to tokenise a keyword.
.019b6a	b0 cd		bcs $019b39			bcs 	_TSMainLoop					; true if tokenised okay.
.019b6c	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get character
.019b6e	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise
.019b71	c9 41		cmp #$41			cmp 	#"A"						; is it A-Z, if so it's an alphanumeric sequence.
.019b73	90 04		bcc $019b79			bcc 	_TSSingle
.019b75	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019b77	90 0d		bcc $019b86			bcc 	_TSAlphaNumeric
.019b79					_TSSingle:
.019b79	c8		iny				iny 								; skip over output
.019b7a	29 3f		and #$3f			and 	#63 						; make 6 bit ASCII
.019b7c	09 80		ora #$80			ora 	#128
.019b7e	f0 b9		beq $019b39			beq 	_TSMainLoop 				; ignore @, which doesn't tokenise.
.019b80	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019b83	e8		inx				inx
.019b84	80 b3		bra $019b39			bra 	_TSMainLoop
.019b86					_TSAlphaNumeric:
.019b86	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get
.019b88	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise
.019b8b	c9 30		cmp #$30			cmp 	#"0" 	 					; check 0-9
.019b8d	90 aa		bcc $019b39			bcc 	_TSMainLoop
.019b8f	c9 3a		cmp #$3a			cmp 	#"9"+1
.019b91	90 0a		bcc $019b9d			bcc 	_TSANOkay
.019b93	c9 41		cmp #$41			cmp 	#"A"						; check A-Z
.019b95	90 a2		bcc $019b39			bcc 	_TSMainLoop
.019b97	c9 5b		cmp #$5b			cmp 	#"Z"+1
.019b99	b0 9e		bcs $019b39			bcs 	_TSMainLoop
.019b9b	29 3f		and #$3f			and 	#63 						; write it out
.019b9d					_TSANOkay:
.019b9d	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019ba0	e8		inx				inx
.019ba1	c8		iny				iny
.019ba2	80 e2		bra $019b86			bra 	_TSAlphaNumeric
.019ba4	a9 00		lda #$00	_TSExit:lda 	#0 							; mark end of line.
.019ba6	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019ba9	8a		txa				txa 								; return length of tokenised line in bytes.
.019baa	60		rts				rts
.019bab					_TSQuotedString:
.019bab	20 0b 9c	jsr $019c0b			jsr 	TokeniseQuotedString
.019bae	80 89		bra $019b39			bra 	_TSMainLoop
.019bb0					_TSDecimal:
.019bb0	20 31 9c	jsr $019c31			jsr 	TokeniseDecimalString
.019bb3	80 84		bra $019b39			bra 	_TSMainLoop
.019bb5					TOKCheckREM:
.019bb5	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check E
.019bb7	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise
.019bba	c9 45		cmp #$45			cmp 	#"E"
.019bbc	d0 12		bne $019bd0			bne 	_TCRFail
.019bbe	c8		iny				iny
.019bbf	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; check M
.019bc1	88		dey				dey
.019bc2	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise
.019bc5	c9 4d		cmp #$4d			cmp 	#"M"
.019bc7	d0 07		bne $019bd0			bne 	_TCRFail
.019bc9	c8		iny				iny									; point to first character
.019bca	c8		iny				iny
.019bcb	20 dd 9b	jsr $019bdd			jsr 	TokeniseREMString 			; tokenise REM
.019bce	38		sec				sec
.019bcf	60		rts				rts
.019bd0					_TCRFail:
.019bd0	18		clc				clc
.019bd1	60		rts				rts
.019bd2					TOKCapitalise:
.019bd2	c9 61		cmp #$61			cmp 	#"a"
.019bd4	90 06		bcc $019bdc			bcc 	_TOKCExit
.019bd6	c9 7b		cmp #$7b			cmp 	#"z"+1
.019bd8	b0 02		bcs $019bdc			bcs 	_TOKCExit
.019bda	49 20		eor #$20			eor 	#$20
.019bdc					_TOKCExit:
.019bdc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokseq.asm

.019bdd					TokeniseREMString:
.019bdd	86 10		stx $10				stx 	zTemp1 						; save position
.019bdf	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019be1	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019be4	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x 			; stops space removal.
.019be7	e8		inx				inx 								; bump, and one space for the count.
.019be8	e8		inx				inx
.019be9					_TSRSkip:
.019be9	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019beb	c8		iny				iny
.019bec	c9 20		cmp #$20			cmp 	#" "
.019bee	f0 f9		beq $019be9			beq 	_TSRSkip
.019bf0	c9 3a		cmp #$3a			cmp 	#":"						; first char is a colon
.019bf2	f0 31		beq $019c25			beq 	SequenceExit 				; ... that's it.
.019bf4					_TSRCopy:
.019bf4	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out
.019bf7	e8		inx				inx
.019bf8	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.019bfa	f0 05		beq $019c01			beq 	_TSRExit 					; zero is exit
.019bfc	c8		iny				iny 								; bump pointer
.019bfd	c9 3a		cmp #$3a			cmp 	#":"						; loop back if not colon.
.019bff	d0 f3		bne $019bf4			bne 	_TSRCopy
.019c01					_TSRExit:
.019c01	bd ff 03	lda $03ff,x			lda 	TokeniseBuffer-1,x 			; previous char space ?
.019c04	c9 20		cmp #$20			cmp 	#" "
.019c06	d0 1d		bne $019c25			bne 	SequenceExit
.019c08	ca		dex				dex 								; go back - will bump into $FE eventually.
.019c09	80 f6		bra $019c01			bra 	_TSRExit
.019c0b					TokeniseQuotedString:
.019c0b	86 10		stx $10				stx 	zTemp1 						; save position
.019c0d	a9 fe		lda #$fe			lda 	#$FE 						; write marker
.019c0f	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c12	e8		inx				inx 								; bump, and one space for the count.
.019c13	e8		inx				inx
.019c14					_TSQCopy:
.019c14	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c16	c9 20		cmp #$20			cmp 	#" "
.019c18	90 0b		bcc $019c25			bcc 	SequenceExit 				; if < ' ' then exit, didn't find end.
.019c1a	c8		iny				iny
.019c1b	c9 22		cmp #$22			cmp 	#'"'						; if = quote, consume it and exit.
.019c1d	f0 06		beq $019c25			beq 	SequenceExit
.019c1f	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write out and loop
.019c22	e8		inx				inx
.019c23	80 ef		bra $019c14			bra 	_TSQCopy
.019c25					SequenceExit:
.019c25	8a		txa				txa 								; current position
.019c26	38		sec				sec 								; subtract start.
.019c27	e5 10		sbc $10				sbc 	zTemp1
.019c29	da		phx				phx 								; copy that in
.019c2a	a6 10		ldx $10				ldx 	zTemp1
.019c2c	9d 01 04	sta $0401,x			sta 	TokeniseBuffer+1,x
.019c2f	fa		plx				plx
.019c30	60		rts				rts
.019c31					TokeniseDecimalString:
.019c31	86 10		stx $10				stx 	zTemp1 						; save position
.019c33	a9 fd		lda #$fd			lda 	#$FD 						; write marker
.019c35	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c38	e8		inx				inx 								; bump, and one space for the count.
.019c39	e8		inx				inx
.019c3a	20 5b 9c	jsr $019c5b			jsr 	_TDSCopyNumber 				; copy a number.
.019c3d	b1 20		lda ($20),y			lda 	(zGenPtr),y	 				; next letter.
.019c3f	20 d2 9b	jsr $019bd2			jsr 	TOKCapitalise
.019c42	c9 45		cmp #$45			cmp 	#"E" 						; if not an exponent.
.019c44	d0 df		bne $019c25			bne 	SequenceExit 				; exit now.
.019c46	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write E out
.019c49	e8		inx				inx
.019c4a	c8		iny				iny
.019c4b	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; followed by a minus ?
.019c4d	c9 2d		cmp #$2d			cmp 	#"-"
.019c4f	d0 05		bne $019c56			bne 	_TDSNoMinusExponent
.019c51	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x 			; write - out
.019c54	e8		inx				inx
.019c55	c8		iny				iny
.019c56					_TDSNoMinusExponent:
.019c56	20 5b 9c	jsr $019c5b			jsr 	_TDSCopyNumber 				; do the exponent
.019c59	80 ca		bra $019c25			bra 	SequenceExit
.019c5b					_TDSCopyNumber:
.019c5b	b1 20		lda ($20),y			lda 	(zGenPtr),y
.019c5d	c9 30		cmp #$30			cmp 	#"0"
.019c5f	90 0b		bcc $019c6c			bcc 	_TDSCNExit
.019c61	c9 3a		cmp #$3a			cmp 	#"9"+1
.019c63	b0 07		bcs $019c6c			bcs 	_TDSCNExit
.019c65	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019c68	e8		inx				inx
.019c69	c8		iny				iny
.019c6a	80 ef		bra $019c5b			bra 	_TDSCopyNumber
.019c6c					_TDSCNExit:
.019c6c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/tokenise/tokconst.asm

.019c6d					TokeniseConstant:
.019c6d	da		phx				phx 								; save X
.019c6e	a2 00		ldx #$00			ldx 	#0
.019c70	20 4b a2	jsr $01a24b			jsr 	IntFromStringY 				; get the integer out.
.019c73	b0 37		bcs $019cac			bcs 	_TCQ 						; should not happen.
.019c75	fa		plx				plx 								; restore X.
.019c76	a9 00		lda #$00			lda 	#0 							; zero count of restores.
.019c78	85 10		sta $10				sta 	zTemp1
.019c7a					_TCRotate:
.019c7a	a5 80		lda $80				lda 	XS_Mantissa+0 				; check bits 6/7 of 0
.019c7c	29 c0		and #$c0			and 	#$C0
.019c7e	05 81		ora $81				ora 	XS_Mantissa+1	 			; and 1/2/3 all zero
.019c80	05 82		ora $82				ora 	XS_Mantissa+2
.019c82	05 83		ora $83				ora 	XS_Mantissa+3
.019c84	f0 16		beq $019c9c			beq 	_TCDone						; if so, at the bottom.
.019c86	a5 80		lda $80				lda 	XS_Mantissa+0 				; push lower 6 bits of 0
.019c88	29 3f		and #$3f			and 	#$3F
.019c8a	48		pha				pha
.019c8b	e6 10		inc $10				inc 	zTemp1 						; increment the pop count.
.019c8d	a9 06		lda #$06			lda 	#6 							; shift right 6 times
.019c8f					_TCShiftRight:
.019c8f	46 83		lsr $83				lsr 	XS_Mantissa+3
.019c91	66 82		ror $82				ror 	XS_Mantissa+2
.019c93	66 81		ror $81				ror 	XS_Mantissa+1
.019c95	66 80		ror $80				ror 	XS_Mantissa+0
.019c97	3a		dec a				dec 	a
.019c98	d0 f5		bne $019c8f			bne 	_TCShiftRight
.019c9a	80 de		bra $019c7a			bra 	_TCRotate 					; and go round again.
.019c9c	a5 80		lda $80		_TCDone:lda 	XS_Mantissa+0
.019c9e					_TCWrite:
.019c9e	09 40		ora #$40			ora 	#$40						; write it out as inttoken
.019ca0	9d 00 04	sta $0400,x			sta 	TokeniseBuffer,x
.019ca3	e8		inx				inx
.019ca4	c6 10		dec $10				dec 	zTemp1 						; done all of them
.019ca6	30 03		bmi $019cab			bmi 	_TCExit 					; no , more to pop
.019ca8	68		pla				pla
.019ca9	80 f3		bra $019c9e			bra 	_TCWrite 					; until everything's off.
.019cab					_TCExit:
.019cab	60		rts				rts
.019cac					_TCQ:
.019cac	20 83 85	jsr $018583			jsr ERR_Handler
>019caf	54 4b 00				.text "TK",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.019cb2					VariableFind:
.019cb2	20 1d 9d	jsr $019d1d			jsr 	VariableExtract 		; find out all about it ....
.019cb5	20 b6 9f	jsr $019fb6			jsr 	VariableLocate 			; does it already exist ?
.019cb8	b0 03		bcs $019cbd			bcs 	_VFExists 				; if so, use that.
.019cba	20 a9 9d	jsr $019da9			jsr 	VariableCreate 			; otherwise create it.
.019cbd					_VFExists:
.019cbd	a5 26		lda $26				lda 	zVarType 				; is it still an array ?
.019cbf	29 01		and #$01			and 	#1
.019cc1	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019cc3	d0 28		bne $019ced			bne 	_VFSingleElement
.019cc5					_VFNextIndex:
.019cc5	a5 24		lda $24				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.019cc7	48		pha				pha
.019cc8	a5 25		lda $25				lda 	zVarDataPtr+1
.019cca	48		pha				pha
.019ccb	a5 26		lda $26				lda 	zVarType
.019ccd	48		pha				pha
.019cce	20 a0 93	jsr $0193a0			jsr 	EvaluateInteger 		; calculate the index.
.019cd1	68		pla				pla 							; restore and index.
.019cd2	85 26		sta $26				sta 	zVarType
.019cd4	68		pla				pla
.019cd5	85 25		sta $25				sta 	zVarDataPtr+1
.019cd7	68		pla				pla
.019cd8	85 24		sta $24				sta 	zVarDataPtr
.019cda	20 34 9e	jsr $019e34			jsr 	ArrayIndexFollow 		; do the index.
.019cdd	a5 26		lda $26				lda 	zVarType 				; is it still an array ??
.019cdf	29 01		and #$01			and 	#1
.019ce1	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019ce3	d0 05		bne $019cea			bne 	_VFArrayDone 			; if so then exit.
.019ce5	20 fe 99	jsr $0199fe			jsr 	CheckNextComma 			; comma should follow
.019ce8	80 db		bra $019cc5			bra 	_VFNextIndex
.019cea					_VFArrayDone:
.019cea	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 		; check closing right bracket.
.019ced					_VFSingleElement:
.019ced	60		rts				rts
.019cee					VariableClear:
.019cee	48		pha				pha 							; save registers
.019cef	da		phx				phx
.019cf0	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019cf2	8a		txa				txa
.019cf3	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.019cf6	e8		inx				inx
.019cf7	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.019cf9	d0 f8		bne $019cf3			bne 	_VCLoop
.019cfb	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019cfd	8d 02 03	sta $0302			sta 	VarMemPtr
.019d00	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019d02	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019d05	fa		plx				plx 							; restore registers
.019d06	68		pla				pla
.019d07	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.019d08					VariableNameError:
.019d08	20 83 85	jsr $018583			jsr ERR_Handler
>019d0b	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019d13	61 62 6c 65 20 4e 61 6d 65 00
.019d1d					VariableExtract:
.019d1d	da		phx				phx 							; save X.
.019d1e	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019d20	8d 95 03	sta $0395			sta 	Var_Type
.019d23	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.019d26	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d28	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019d2a	f0 dc		beq $019d08			beq 	VariableNameError
.019d2c	c9 1b		cmp #$1b			cmp 	#26+1
.019d2e	b0 d8		bcs $019d08			bcs 	VariableNameError
.019d30	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019d32					_VECopyBuffer:
.019d32	e8		inx				inx
.019d33	e0 1f		cpx #$1f			cpx 	#31 					; too long
.019d35	f0 d1		beq $019d08			beq 	VariableNameError
.019d37	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019d3a	18		clc				clc  							; update the hash value for it.
.019d3b	6d 96 03	adc $0396			adc 	Var_Hash
.019d3e	8d 96 03	sta $0396			sta 	Var_Hash
.019d41	c8		iny				iny
.019d42	b7 18		lda [$18],y			lda 	[zCodePtr],y
.019d44	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.019d46	f0 0e		beq $019d56			beq 	_VECopyEnd
.019d48	30 0c		bmi $019d56			bmi 	_VECopyEnd
.019d4a	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019d4c	90 e4		bcc $019d32			bcc 	_VECopyBuffer
.019d4e	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019d50	90 04		bcc $019d56			bcc 	_VECopyEnd
.019d52	c9 3a		cmp #$3a			cmp 	#"9"+1
.019d54	90 dc		bcc $019d32			bcc 	_VECopyBuffer
.019d56					_VECopyEnd:
.019d56	c8		iny				iny
.019d57	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.019d59	90 04		bcc $019d5f			bcc 	_VEDefaultRequired
.019d5b	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.019d5d	90 0b		bcc $019d6a			bcc 	_VEHaveType
.019d5f					_VEDefaultRequired:
.019d5f	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.019d61	f0 04		beq $019d67			beq 	_VESetType 				; default set above.
.019d63	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.019d66	88		dey				dey
.019d67					_VESetType:
.019d67	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.019d6a					_VEHaveType:
.019d6a	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.019d6d	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.019d70	09 80		ora #$80			ora 	#$80
.019d72	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.019d75	e8		inx				inx 							; offset 3 => length 4.
.019d76	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.019d79	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.019d7c	38		sec				sec
.019d7d	e9 b7		sbc #$b7			sbc 	#token_Dollar
.019d7f	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.019d80	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.019d81	0a		asl a				asl 	a
.019d82	0a		asl a				asl 	a
.019d83	8d 98 03	sta $0398			sta 	Var_HashAddress
.019d86	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.019d89	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.019d8b	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.019d8c	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.019d8f	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.019d91	8d 98 03	sta $0398			sta 	Var_HashAddress
.019d94	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.019d96	ad 95 03	lda $0395			lda 	Var_Type
.019d99	c9 b9		cmp #$b9			cmp 	#token_Hash
.019d9b	f0 07		beq $019da4			beq 	_VEHaveSize
.019d9d	ca		dex				dex
.019d9e	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.019da0	f0 02		beq $019da4			beq 	_VEHaveSize
.019da2	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.019da4					_VEHaveSize:
.019da4	8e 99 03	stx $0399			stx 	Var_DataSize
.019da7	fa		plx				plx
.019da8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.019da9					VariableCreate:
.019da9	da		phx				phx
.019daa	5a		phy				phy
.019dab	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.019dae	85 10		sta $10				sta 	zTemp1
.019db0	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019db3	85 11		sta $11				sta 	zTemp1+1
.019db5	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.019db8	18		clc				clc
.019db9	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019dbc	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019dbe	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019dc1	8d 02 03	sta $0302			sta 	VarMemPtr
.019dc4	90 03		bcc $019dc9			bcc 	_VCNoCarry
.019dc6	ee 03 03	inc $0303			inc 	VarMemPtr+1
.019dc9					_VCNoCarry:
.019dc9	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019dcc	85 12		sta $12				sta 	zTemp2
.019dce	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019dd0	85 13		sta $13				sta 	zTemp2+1
.019dd2	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.019dd4	b1 12		lda ($12),y			lda 	(zTemp2),y
.019dd6	91 10		sta ($10),y			sta 	(zTemp1),y
.019dd8	c8		iny				iny
.019dd9	b1 12		lda ($12),y			lda 	(zTemp2),y
.019ddb	91 10		sta ($10),y			sta 	(zTemp1),y
.019ddd	c8		iny				iny
.019dde	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019de1	91 10		sta ($10),y			sta 	(zTemp1),y
.019de3	c8		iny				iny
.019de4	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.019de6					_VCCopyName:
.019de6	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.019de9	91 10		sta ($10),y			sta 	(zTemp1),y
.019deb	e8		inx				inx
.019dec	c8		iny				iny
.019ded	ec 97 03	cpx $0397			cpx 	Var_Length
.019df0	d0 f4		bne $019de6			bne 	_VCCopyName
.019df2	5a		phy				phy 								; save the data offset.
.019df3	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.019df6	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.019df8					_VCClearData:
.019df8	91 10		sta ($10),y			sta 	(zTemp1),y
.019dfa	c8		iny				iny
.019dfb	ca		dex				dex
.019dfc	d0 fa		bne $019df8			bne 	_VCClearData
.019dfe	68		pla				pla 								; offset to the data
.019dff	18		clc				clc
.019e00	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019e02	85 24		sta $24				sta 	zVarDataPtr
.019e04	a5 11		lda $11				lda 	zTemp1+1
.019e06	69 00		adc #$00			adc 	#0
.019e08	85 25		sta $25				sta 	zVarDataPtr+1
.019e0a	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019e0d	85 26		sta $26				sta 	zVarType
.019e0f	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019e11	a0 00		ldy #$00			ldy 	#0
.019e13	91 12		sta ($12),y			sta 	(zTemp2),y
.019e15	c8		iny				iny
.019e16	a5 11		lda $11				lda 	zTemp1+1
.019e18	91 12		sta ($12),y			sta 	(zTemp2),y
.019e1a	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019e1d	29 01		and #$01			and 	#1
.019e1f	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019e21	d0 0e		bne $019e31			bne 	_VCNotArray
.019e23	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.019e25	20 cb 9e	jsr $019ecb			jsr 	ArrayCreate
.019e28	5a		phy				phy 								; save YA at zVarDataPtr
.019e29	a0 00		ldy #$00			ldy 	#0
.019e2b	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e2d	c8		iny				iny
.019e2e	68		pla				pla
.019e2f	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.019e31					_VCNotArray:
.019e31	7a		ply				ply
.019e32	fa		plx				plx
.019e33	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.019e34					ArrayIndexFollow:
.019e34	5a		phy				phy
.019e35	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.019e37	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.019e39	48		pha				pha
.019e3a	c8		iny				iny
.019e3b	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e3d	85 25		sta $25				sta 	zVarDataPtr+1
.019e3f	68		pla				pla
.019e40	85 24		sta $24				sta 	zVarDataPtr
.019e42	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.019e44	29 80		and #$80			and 	#$80 						; must be zero.
.019e46	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e48	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e4a	d0 59		bne $019ea5			bne 	_AIFError
.019e4c	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019e4e	18		clc				clc
.019e4f	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e51	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019e53	c8		iny				iny
.019e54	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019e56	08		php				php 								; clear bit 7 retaining borrow.
.019e57	29 7f		and #$7f			and 	#$7F
.019e59	28		plp				plp
.019e5a	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019e5c	90 47		bcc $019ea5			bcc 	_AIFError 					; eror if size-current < 0
.019e5e	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.019e60	0a		asl a				asl 	a 							; (e.g. index * 2)
.019e61	85 10		sta $10				sta 	zTemp1
.019e63	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e65	2a		rol a				rol 	a
.019e66	85 11		sta $11				sta 	zTemp1+1
.019e68	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.019e6a	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.019e6c	30 1d		bmi $019e8b			bmi 	_AIFCalculate
.019e6e	c6 26		dec $26				dec 	zVarType 					; converts from an array to a type.
.019e70	a5 26		lda $26				lda 	zVarType 					; check that type
.019e72	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.019e74	f0 15		beq $019e8b			beq 	_AIFCalculate
.019e76	06 10		asl $10				asl 	zTemp1			 			; double the index
.019e78	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.019e7a	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.019e7c	f0 0d		beq $019e8b			beq 	_AIFCalculate
.019e7e	18		clc				clc 								; add the original mantissa in again
.019e7f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.019e81	65 10		adc $10				adc 	zTemp1
.019e83	85 10		sta $10				sta 	zTemp1
.019e85	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019e87	65 11		adc $11				adc 	zTemp1+1
.019e89	85 11		sta $11				sta 	zTemp1+1
.019e8b					_AIFCalculate:
.019e8b	18		clc				clc 								; add index x 2,4 or 5 to base
.019e8c	a5 24		lda $24				lda 	zVarDataPtr
.019e8e	65 10		adc $10				adc 	zTemp1
.019e90	85 24		sta $24				sta 	zVarDataPtr
.019e92	a5 25		lda $25				lda 	zVarDataPtr+1
.019e94	65 11		adc $11				adc 	zTemp1+1
.019e96	85 25		sta $25				sta 	zVarDataPtr+1
.019e98	18		clc				clc 								; add 2 more for the length prefix.
.019e99	a5 24		lda $24				lda 	zVarDataPtr
.019e9b	69 02		adc #$02			adc 	#2
.019e9d	85 24		sta $24				sta 	zVarDataPtr
.019e9f	90 02		bcc $019ea3			bcc 	_AIFNoBump
.019ea1	e6 25		inc $25				inc 	zVarDataPtr+1
.019ea3					_AIFNoBump:
.019ea3	7a		ply				ply
.019ea4	60		rts				rts
.019ea5					_AIFError:
.019ea5	20 83 85	jsr $018583			jsr ERR_Handler
>019ea8	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019eb0	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.019eb8					ArrayResetDefault:
.019eb8	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019eba	8d a9 03	sta $03a9			sta 	ArrayDef+0
.019ebd	a9 00		lda #$00			lda 	#0
.019ebf	8d aa 03	sta $03aa			sta 	ArrayDef+1
.019ec2	a9 ff		lda #$ff			lda 	#$FF
.019ec4	8d ab 03	sta $03ab			sta 	ArrayDef+2 					; $FFFF implies no second element.
.019ec7	8d ac 03	sta $03ac			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019eca	60		rts				rts
.019ecb					ArrayCreate:
.019ecb	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019ece	0a		asl a				asl 	a
.019ecf	85 10		sta $10				sta 	zTemp1
.019ed1	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019ed4	2a		rol a				rol 	a
.019ed5	85 11		sta $11				sta 	zTemp1+1
.019ed7	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019eda	10 22		bpl $019efe			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019edc	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019edf	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019ee1	f0 1b		beq $019efe			beq 	_ACSized
.019ee3	06 10		asl $10				asl 	zTemp1 						; double again
.019ee5	26 11		rol $11				rol 	zTemp1+1
.019ee7	b0 6f		bcs $019f58			bcs 	ArrayIndexError 			; too large.
.019ee9	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019eeb	f0 11		beq $019efe			beq 	_ACSized
.019eed	18		clc				clc 								; add original value x 5 for reals.
.019eee	a5 10		lda $10				lda 	zTemp1
.019ef0	7d a9 03	adc $03a9,x			adc 	ArrayDef+0,x
.019ef3	85 10		sta $10				sta 	zTemp1
.019ef5	a5 11		lda $11				lda 	zTemp1+1
.019ef7	7d aa 03	adc $03aa,x			adc 	ArrayDef+1,x
.019efa	85 11		sta $11				sta 	zTemp1+1
.019efc	b0 5a		bcs $019f58			bcs 	ArrayIndexError
.019efe					_ACSized:
.019efe	18		clc				clc
.019eff	a5 10		lda $10				lda 	zTemp1
.019f01	69 02		adc #$02			adc 	#2
.019f03	85 10		sta $10				sta 	zTemp1
.019f05	90 04		bcc $019f0b			bcc 	_ACNoBump
.019f07	e6 10		inc $10				inc 	zTemp1
.019f09	f0 4d		beq $019f58			beq 	ArrayIndexError
.019f0b					_ACNoBump:
.019f0b	18		clc				clc
.019f0c	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019f0f	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019f11	85 14		sta $14				sta 	zTemp3
.019f13	65 10		adc $10				adc 	zTemp1
.019f15	8d 02 03	sta $0302			sta 	VarMemPtr
.019f18	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019f1b	85 13		sta $13				sta 	zTemp2+1
.019f1d	85 15		sta $15				sta 	zTemp3+1
.019f1f	65 11		adc $11				adc 	zTemp1+1
.019f21	8d 03 03	sta $0303			sta 	VarMemPtr+1
.019f24	85 11		sta $11				sta 	zTemp1+1
.019f26	b0 30		bcs $019f58			bcs 	ArrayIndexError
.019f28	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019f2a					_ACClear:
.019f2a	98		tya				tya
.019f2b	91 12		sta ($12),y			sta 	(zTemp2),y
.019f2d	e6 12		inc $12				inc 	zTemp2
.019f2f	d0 02		bne $019f33			bne 	_ACCBump
.019f31	e6 13		inc $13				inc 	zTemp2+1
.019f33					_ACCBump:
.019f33	a5 12		lda $12				lda 	zTemp2
.019f35	cd 02 03	cmp $0302			cmp 	VarMemPtr
.019f38	d0 f0		bne $019f2a			bne 	_ACClear
.019f3a	a5 13		lda $13				lda 	zTemp2+1
.019f3c	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019f3f	d0 e9		bne $019f2a			bne 	_ACClear
.019f41	a0 00		ldy #$00			ldy 	#0
.019f43	bd a9 03	lda $03a9,x			lda 	ArrayDef+0,x 				; copy the size into the start
.019f46	91 14		sta ($14),y			sta 	(zTemp3),y
.019f48	c8		iny				iny
.019f49	bd aa 03	lda $03aa,x			lda 	ArrayDef+1,x
.019f4c	91 14		sta ($14),y			sta 	(zTemp3),y
.019f4e	bd ac 03	lda $03ac,x			lda 	ArrayDef+3,x 				; have we reached the end
.019f51	10 18		bpl $019f6b			bpl 	ACCFillRecursive
.019f53	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.019f55	a5 14		lda $14				lda 	zTemp3
.019f57	60		rts				rts
.019f58					ArrayIndexError:
.019f58	20 83 85	jsr $018583			jsr ERR_Handler
>019f5b	42 61 64 20 61 72 72 61			.text "Bad array index",0
>019f63	79 20 69 6e 64 65 78 00
.019f6b					ACCFillRecursive:
.019f6b	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.019f6d	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.019f6f	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.019f71	c8		iny				iny
.019f72	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.019f74	09 80		ora #$80			ora 	#$80 						; an array of pointers
.019f76	91 14		sta ($14),y			sta 	(zTemp3),y
.019f78	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.019f7a	48		pha				pha
.019f7b	a5 15		lda $15				lda 	zTemp3+1
.019f7d	48		pha				pha
.019f7e					_ACCFillLoop:
.019f7e	18		clc				clc
.019f7f	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.019f81	69 02		adc #$02			adc 	#2
.019f83	85 14		sta $14				sta 	zTemp3
.019f85	90 02		bcc $019f89			bcc 	_ACCSkip2
.019f87	e6 15		inc $15				inc 	zTemp3+1
.019f89					_ACCSkip2:
.019f89	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.019f8b	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.019f8d	c8		iny				iny
.019f8e	11 14		ora ($14),y			ora 	(zTemp3),y
.019f90	d0 21		bne $019fb3			bne 	_ACCExit
.019f92	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.019f94	48		pha				pha
.019f95	a5 15		lda $15				lda 	zTemp3+1
.019f97	48		pha				pha
.019f98	e8		inx				inx
.019f99	e8		inx				inx
.019f9a	20 cb 9e	jsr $019ecb			jsr 	ArrayCreate 				; create array recursively.
.019f9d	ca		dex				dex
.019f9e	ca		dex				dex
.019f9f	85 12		sta $12				sta 	zTemp2 						; save A
.019fa1	68		pla				pla
.019fa2	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.019fa4	68		pla				pla
.019fa5	85 14		sta $14				sta 	zTemp3
.019fa7	98		tya				tya 								; write high bye from Y
.019fa8	a0 01		ldy #$01			ldy 	#1
.019faa	91 14		sta ($14),y			sta 	(zTemp3),y
.019fac	88		dey				dey 								; write low byte out.
.019fad	a5 12		lda $12				lda 	zTemp2
.019faf	91 14		sta ($14),y			sta 	(zTemp3),y
.019fb1	80 cb		bra $019f7e			bra 	_ACCFillLoop 				; and try again.
.019fb3					_ACCExit:
.019fb3	7a		ply				ply 								; restore the original address
.019fb4	68		pla				pla
.019fb5	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.019fb6					VariableLocate:
.019fb6	da		phx				phx
.019fb7	5a		phy				phy
.019fb8	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019fbb	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019fbd	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019fbf	85 13		sta $13				sta 	zTemp2+1
.019fc1	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019fc3	b1 12		lda ($12),y			lda 	(zTemp2),y
.019fc5	aa		tax				tax
.019fc6	c8		iny				iny
.019fc7	b1 12		lda ($12),y			lda 	(zTemp2),y
.019fc9	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019fcb	86 12		stx $12				stx 	zTemp2
.019fcd	05 12		ora $12				ora 	zTemp2 						; got zero
.019fcf	18		clc				clc
.019fd0	f0 25		beq $019ff7			beq 	_VLExit 					; if so, then fail as end of chain.
.019fd2	c8		iny				iny 								; point to hash (offset + 2)
.019fd3	b1 12		lda ($12),y			lda 	(zTemp2),y
.019fd5	cd 96 03	cmp $0396			cmp 	Var_Hash
.019fd8	d0 e7		bne $019fc1			bne 	_VLNext 					; try next if different.
.019fda					_VLCompare:
.019fda	c8		iny				iny 								; next character
.019fdb	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019fdd	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019fe0	d0 df		bne $019fc1			bne 	_VLNext 					; fail if different, try next.
.019fe2	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019fe3	90 f5		bcc $019fda			bcc 	_VLCompare
.019fe5	98		tya				tya
.019fe6	38		sec				sec 								; add 1 as Y points to last character
.019fe7	65 12		adc $12				adc 	zTemp2 						; add to the current address
.019fe9	85 24		sta $24				sta 	zVarDataPtr
.019feb	a5 13		lda $13				lda 	zTemp2+1
.019fed	69 00		adc #$00			adc 	#0
.019fef	85 25		sta $25				sta 	zVarDataPtr+1
.019ff1	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019ff4	85 26		sta $26				sta 	zVarType
.019ff6	38		sec				sec 								; return CS
.019ff7	7a		ply		_VLExit:ply
.019ff8	fa		plx				plx
.019ff9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019ffa					VariableGet:
.019ffa	5a		phy				phy
.019ffb	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019ffd	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.019fff	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a001	c8		iny				iny
.01a002	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a004	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a006	c8		iny				iny
.01a007	a5 26		lda $26				lda 	zVarType 					; if it is a string, set up for that.
.01a009	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a00b	f0 2c		beq $01a039			beq 	_VGString
.01a00d	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.01a00f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a011	c8		iny				iny
.01a012	b1 24		lda ($24),y			lda 	(zVarDataPtr),y
.01a014	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a016	c8		iny				iny
.01a017	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01a019	95 85		sta $85,x			sta 	XS_Type,x
.01a01b	a5 26		lda $26				lda 	zVarType
.01a01d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.01a01f	f0 28		beq $01a049			beq 	_VGExit
.01a021	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.01a023	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01a025	b1 24		lda ($24),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01a027	95 84		sta $84,x			sta 	XS_Exponent,x
.01a029	f0 1e		beq $01a049			beq 	_VGExit 					; if exponent is zero ... it's zero.
.01a02b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.01a02d	48		pha				pha
.01a02e	29 80		and #$80			and 	#$80
.01a030	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.01a032	68		pla				pla
.01a033	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.01a035	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01a037	80 10		bra $01a049			bra 	_VGExit
.01a039					_VGString:
.01a039	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.01a03b	95 85		sta $85,x			sta 	XS_Type,x
.01a03d	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.01a03f	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a041	d0 06		bne $01a049			bne 	_VGExit 					; if not, exit.
.01a043	85 27		sta $27				sta 	zNullString 				; make zNullString a 00 string.
.01a045	a9 27		lda #$27			lda 	#zNullString
.01a047	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01a049					_VGExit:
.01a049	7a		ply				ply
.01a04a	60		rts				rts
.01a04b					VariableSet:
.01a04b	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.01a04d	29 02		and #$02			and 	#2 							; if so, it has to be
.01a04f	d0 4b		bne $01a09c			bne 	_VSString
.01a051	a5 26		lda $26				lda 	zVarType 					; if type is $ there's an error.
.01a053	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a055	f0 42		beq $01a099			beq 	_VSBadType
.01a057	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01a059	f0 05		beq $01a060			beq 	_VSMakeInt
.01a05b	20 c3 a5	jsr $01a5c3			jsr 	FPUToFloat
.01a05e	80 03		bra $01a063			bra 	_VSCopy
.01a060					_VSMakeInt:
.01a060	20 0f a6	jsr $01a60f			jsr 	FPUToInteger
.01a063					_VSCopy:
.01a063	5a		phy				phy
.01a064	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.01a066	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a068	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a06a	c8		iny				iny
.01a06b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a06d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a06f	c8		iny				iny
.01a070	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a072	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a074	c8		iny				iny
.01a075	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a077	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a079	a5 26		lda $26				lda 	zVarType 					; if target is integer, alrady done.
.01a07b	c9 bb		cmp #$bb			cmp 	#token_Percent
.01a07d	f0 18		beq $01a097			beq 	_VSExit
.01a07f	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.01a081	0a		asl a				asl 	a
.01a082	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.01a084	08		php				php
.01a085	0a		asl a				asl 	a
.01a086	28		plp				plp
.01a087	6a		ror a				ror 	a
.01a088	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a08a	c8		iny				iny
.01a08b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.01a08d	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a08f	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.01a091	50 04		bvc $01a097			bvc 	_VSExit
.01a093	a9 00		lda #$00			lda 	#0 							; zero exponent indicating 0.
.01a095	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a097					_VSExit:
.01a097	7a		ply				ply
.01a098	60		rts				rts
.01a099					_VSBadType:
.01a099	4c 64 85	jmp $018564			jmp 	TypeError
.01a09c					_VSString:
.01a09c	a5 26		lda $26				lda 	zVarType 					; type must be $
.01a09e	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01a0a0	d0 f7		bne $01a099			bne 	_VSBadType
.01a0a2	da		phx				phx
.01a0a3	5a		phy				phy
.01a0a4	20 06 9a	jsr $019a06			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.01a0a7	a0 01		ldy #$01			ldy 	#1 							; save high byte
.01a0a9	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0ab	88		dey				dey 								; save low byte
.01a0ac	8a		txa				txa
.01a0ad	91 24		sta ($24),y			sta 	(zVarDataPtr),y
.01a0af	7a		ply				ply 								; and exit.
.01a0b0	fa		plx				plx
.01a0b1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.01a0b2					MulInteger32:
.01a0b2	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.01a0b4	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.01a0b6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a0b8	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.01a0ba	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a0bc	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.01a0be	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a0c0	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.01a0c2	a9 00		lda #$00			lda 	#0
.01a0c4	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0, where the result goes.
.01a0c6	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a0c8	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a0ca	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a0cc					_BFMMultiply:
.01a0cc	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.01a0ce	29 01		and #$01			and 	#1
.01a0d0	f0 03		beq $01a0d5			beq 	_BFMNoAdd
.01a0d2	20 42 95	jsr $019542			jsr 	AddInteger32 					; co-opt this code
.01a0d5					_BFMNoAdd:
.01a0d5	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.01a0d7	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.01a0d9	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.01a0db	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.01a0dd	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.01a0df	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.01a0e1	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.01a0e3	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.01a0e5	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.01a0e7	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.01a0e9	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.01a0eb	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.01a0ed	d0 dd		bne $01a0cc			bne 	_BFMMultiply
.01a0ef	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.01a0f0					DivInteger32:
.01a0f0	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for division by zero.
.01a0f2	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.01a0f4	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a0f6	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a0f8	d0 14		bne $01a10e			bne 	_BFDOkay
.01a0fa	20 83 85	jsr $018583			jsr ERR_Handler
>01a0fd	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>01a105	20 62 79 20 5a 65 72 6f 00
.01a10e					_BFDOkay:
.01a10e	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.01a110	85 1c		sta $1c				sta 	zLTemp1 					; Q/Dividend/Left in +0
.01a112	85 1d		sta $1d				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.01a114	85 1e		sta $1e				sta 	zLTemp1+2
.01a116	85 1f		sta $1f				sta 	zLTemp1+3
.01a118	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.01a11b	20 72 a1	jsr $01a172			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.01a11e	da		phx				phx
.01a11f	e8		inx				inx
.01a120	e8		inx				inx
.01a121	e8		inx				inx
.01a122	e8		inx				inx
.01a123	e8		inx				inx
.01a124	e8		inx				inx
.01a125	20 72 a1	jsr $01a172			jsr 	CheckIntegerNegate
.01a128	fa		plx				plx
.01a129	5a		phy				phy 								; Y is the counter
.01a12a	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.01a12c					_BFDLoop:
.01a12c	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.01a12e	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a130	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a132	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a134	26 1c		rol $1c				rol 	zLTemp1
.01a136	26 1d		rol $1d				rol 	zLTemp1+1
.01a138	26 1e		rol $1e				rol 	zLTemp1+2
.01a13a	26 1f		rol $1f				rol 	zLTemp1+3
.01a13c	38		sec				sec
.01a13d	a5 1c		lda $1c				lda 	zLTemp1+0 					; Calculate A-M on stack.
.01a13f	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a141	48		pha				pha
.01a142	a5 1d		lda $1d				lda 	zLTemp1+1
.01a144	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a146	48		pha				pha
.01a147	a5 1e		lda $1e				lda 	zLTemp1+2
.01a149	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a14b	48		pha				pha
.01a14c	a5 1f		lda $1f				lda 	zLTemp1+3
.01a14e	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a150	90 13		bcc $01a165			bcc 	_BFDNoAdd
.01a152	85 1f		sta $1f				sta 	zLTemp1+3 					; update A
.01a154	68		pla				pla
.01a155	85 1e		sta $1e				sta 	zLTemp1+2
.01a157	68		pla				pla
.01a158	85 1d		sta $1d				sta 	zLTemp1+1
.01a15a	68		pla				pla
.01a15b	85 1c		sta $1c				sta 	zLTemp1+0
.01a15d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.01a15f	09 01		ora #$01			ora 	#1
.01a161	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a163	80 03		bra $01a168			bra 	_BFDNext
.01a165					_BFDNoAdd:
.01a165	68		pla				pla 								; Throw away the intermediate calculations
.01a166	68		pla				pla
.01a167	68		pla				pla
.01a168					_BFDNext:
.01a168	88		dey				dey
.01a169	d0 c1		bne $01a12c			bne 	_BFDLoop
.01a16b	7a		ply				ply 								; restore Y
.01a16c	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.01a16f	b0 06		bcs $01a177			bcs		IntegerNegateAlways 		; negate the result
.01a171	60		rts				rts
.01a172					CheckIntegerNegate:
.01a172	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is it -ve = MSB set ?
.01a174	30 01		bmi $01a177			bmi 	IntegerNegateAlways 		; if so negate it
.01a176	60		rts				rts
.01a177					IntegerNegateAlways:
.01a177	ee 9e 03	inc $039e			inc 	SignCount 					; bump the count of signs
.01a17a	38		sec				sec 								; 0-mantissa,x -> mantissa,x
.01a17b	a9 00		lda #$00			lda 	#0
.01a17d	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a17f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a181	a9 00		lda #$00			lda 	#0
.01a183	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a185	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a187	a9 00		lda #$00			lda 	#0
.01a189	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a18b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a18d	a9 00		lda #$00			lda 	#0
.01a18f	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a191	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a193	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.01a194					INTToString:
.01a194	48		pha				pha
.01a195	5a		phy				phy
.01a196	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.01a198	10 08		bpl $01a1a2			bpl 		_ITSNotMinus
.01a19a	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a19c	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter
.01a19f	20 77 a1	jsr $01a177			jsr 		IntegerNegateAlways 	; negate the number.
.01a1a2					_ITSNotMinus:
.01a1a2	a9 00		lda #$00			lda 		#0
.01a1a4	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.01a1a7	8a		txa				txa 								; use Y for the mantissa index.
.01a1a8	a8		tay				tay
.01a1a9	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.01a1ab					_ITSNextSubtractor:
.01a1ab	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.01a1ad	8d 9b 03	sta $039b			sta 		NumConvCount
.01a1b0					_ITSSubtract:
.01a1b0	38		sec				sec
.01a1b1	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.01a1b4	ff 12 a2 01	sbc $01a212,x			sbc 		_ITSSubtractors+0,x
.01a1b8	48		pha				pha
.01a1b9	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.01a1bc	ff 13 a2 01	sbc $01a213,x			sbc 		_ITSSubtractors+1,x
.01a1c0	48		pha				pha
.01a1c1	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.01a1c4	ff 14 a2 01	sbc $01a214,x			sbc 		_ITSSubtractors+2,x
.01a1c8	48		pha				pha
.01a1c9	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.01a1cc	ff 15 a2 01	sbc $01a215,x			sbc 		_ITSSubtractors+3,x
.01a1d0	90 14		bcc $01a1e6			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.01a1d2	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.01a1d5	68		pla				pla
.01a1d6	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.01a1d9	68		pla				pla
.01a1da	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.01a1dd	68		pla				pla
.01a1de	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.01a1e1	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.01a1e4	80 ca		bra $01a1b0			bra 		_ITSSubtract 			; go round again.
.01a1e6					_ITSCantSubtract:
.01a1e6	68		pla				pla 								; throw away interim answers
.01a1e7	68		pla				pla
.01a1e8	68		pla				pla
.01a1e9	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.01a1ec	c9 30		cmp #$30			cmp 		#"0"
.01a1ee	d0 05		bne $01a1f5			bne 		_ITSOutputDigit
.01a1f0	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.01a1f3	10 09		bpl $01a1fe			bpl	 		_ITSGoNextSubtractor
.01a1f5					_ITSOutputDigit:
.01a1f5	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.01a1f8	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.01a1fb	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter 		; output it.
.01a1fe					_ITSGoNextSubtractor:
.01a1fe	e8		inx				inx 								; next dword
.01a1ff	e8		inx				inx
.01a200	e8		inx				inx
.01a201	e8		inx				inx
.01a202	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.01a204	d0 a5		bne $01a1ab			bne 		_ITSNextSubtractor 		; do all the subtractors.
.01a206	98		tya				tya 								; X is back as the mantissa index
.01a207	aa		tax				tax
.01a208	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.01a20a	09 30		ora #$30			ora 		#"0"
.01a20c	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter
.01a20f	7a		ply				ply 								; and exit
.01a210	68		pla				pla
.01a211	60		rts				rts
.01a212					_ITSSubtractors:
>01a212	00 ca 9a 3b					.dword 		1000000000
>01a216	00 e1 f5 05					.dword 		100000000
>01a21a	80 96 98 00					.dword 		10000000
>01a21e	40 42 0f 00					.dword 		1000000
>01a222	a0 86 01 00					.dword 		100000
>01a226	10 27 00 00					.dword 		10000
>01a22a	e8 03 00 00					.dword 		1000
>01a22e	64 00 00 00					.dword 		100
>01a232	0a 00 00 00					.dword 		10
.01a236					_ITSSubtractorsEnd:
.01a236					ITSOutputCharacter:
.01a236	48		pha				pha
.01a237	da		phx				phx
.01a238	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.01a23b	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.01a23e	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.01a240	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.01a243	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.01a246	fa		plx				plx
.01a247	68		pla				pla
.01a248	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.01a249					IntFromString:
.01a249	a0 00		ldy #$00			ldy 	#0
.01a24b					IntFromStringY:
.01a24b	a9 00		lda #$00			lda 	#0
.01a24d	8d 9c 03	sta $039c			sta 	ExpTemp 					; this is the converted digit count.
.01a250	48		pha				pha
.01a251	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.01a253	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a255	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a257	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a259	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a25b	a9 01		lda #$01			lda 	#1
.01a25d	95 85		sta $85,x			sta 	XS_Type,x
.01a25f					_IFSLoop:
.01a25f	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; get next
.01a261	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.01a263	90 4e		bcc $01a2b3			bcc 	_IFSExit
.01a265	c9 3a		cmp #$3a			cmp 	#"9"+1
.01a267	b0 4a		bcs $01a2b3			bcs 	_IFSExit
.01a269	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.01a26b	c9 0c		cmp #$0c			cmp 	#12
.01a26d	b0 4e		bcs $01a2bd			bcs 	_IFSOverflow
.01a26f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.01a271	48		pha				pha
.01a272	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a274	48		pha				pha
.01a275	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a277	48		pha				pha
.01a278	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a27a	48		pha				pha
.01a27b	20 d2 a2	jsr $01a2d2			jsr 	IFSX1ShiftLeft 				; double
.01a27e	20 d2 a2	jsr $01a2d2			jsr 	IFSX1ShiftLeft 				; x 4
.01a281	18		clc				clc 								; add saved value x 5
.01a282	68		pla				pla
.01a283	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a285	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a287	68		pla				pla
.01a288	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.01a28a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a28c	68		pla				pla
.01a28d	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.01a28f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a291	68		pla				pla
.01a292	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.01a294	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a296	20 d2 a2	jsr $01a2d2			jsr 	IFSX1ShiftLeft 				; x 10
.01a299	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.01a29c	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; add digit
.01a29e	29 0f		and #$0f			and 	#15
.01a2a0	c8		iny				iny
.01a2a1	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.01a2a3	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a2a5	90 b8		bcc $01a25f			bcc 	_IFSLoop
.01a2a7	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.01a2a9	d0 b4		bne $01a25f			bne 	_IFSLoop
.01a2ab	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.01a2ad	d0 b0		bne $01a25f			bne 	_IFSLoop
.01a2af	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.01a2b1	80 ac		bra $01a25f			bra 	_IFSLoop
.01a2b3					_IFSExit:
.01a2b3	98		tya				tya 								; get offset
.01a2b4					_IFSOkay:
.01a2b4	38		sec				sec
.01a2b5	ad 9c 03	lda $039c			lda 	ExpTemp
.01a2b8	f0 01		beq $01a2bb			beq 	_IFSSkipFail
.01a2ba	18		clc				clc
.01a2bb					_IFSSkipFail:
.01a2bb	68		pla				pla 								; and exit.
.01a2bc	60		rts				rts
.01a2bd					_IFSOverflow:
.01a2bd	20 83 85	jsr $018583			jsr 	ERR_Handler
>01a2c0	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>01a2c8	20 6f 76 65 72 66 6c 6f 77 00
.01a2d2					IFSX1ShiftLeft:
.01a2d2	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.01a2d4	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01a2d6	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01a2d8	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01a2da	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.01a2db					FPSubtract:
.01a2db	48		pha				pha
.01a2dc	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.01a2de	49 80		eor #$80			eor 	#$80
.01a2e0	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a2e2	68		pla				pla 								; --- and fall through ---
.01a2e3					FPAdd:
.01a2e3	48		pha				pha
.01a2e4	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.01a2e6	d0 05		bne $01a2ed			bne 	_FPA_NegativeLHS
.01a2e8	20 04 a3	jsr $01a304			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.01a2eb	68		pla				pla
.01a2ec	60		rts				rts
.01a2ed					_FPA_NegativeLHS:
.01a2ed	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.01a2ef	49 80		eor #$80			eor 	#$80
.01a2f1	95 85		sta $85,x			sta 	XS_Type,x
.01a2f3	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.01a2f5	49 80		eor #$80			eor 	#$80
.01a2f7	95 8b		sta $8b,x			sta 	XS2_Type,x
.01a2f9	20 04 a3	jsr $01a304			jsr 	FPAdd_Worker 				; do the add calculation.
.01a2fc	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.01a2fe	49 80		eor #$80			eor 	#$80
.01a300	95 85		sta $85,x			sta 	XS_Type,x
.01a302	68		pla				pla
.01a303	60		rts				rts
.01a304					FPAdd_Worker:
.01a304	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.01a306	70 07		bvs $01a30f			bvs 	_FPAWExit 					; no change.
.01a308	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.01a30a	50 07		bvc $01a313			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.01a30c	20 81 a5	jsr $01a581			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.01a30f					_FPAWExit:
.01a30f	20 f0 a5	jsr $01a5f0			jsr 	FPUNormalise 				; normalise the result.
.01a312	60		rts				rts
.01a313					_FPAWMakeSame:
.01a313	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.01a315	38		sec				sec
.01a316	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.01a318	f0 16		beq $01a330			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.01a31a	da		phx				phx 								; save X
.01a31b	90 06		bcc $01a323			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.01a31d	e8		inx				inx
.01a31e	e8		inx				inx
.01a31f	e8		inx				inx
.01a320	e8		inx				inx
.01a321	e8		inx				inx
.01a322	e8		inx				inx
.01a323					_FPAWShiftA:
.01a323	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a325	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a327	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a329	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a32b	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a32d	fa		plx				plx 								; restore original X
.01a32e	80 e3		bra $01a313			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.01a330					_FPAW_DoArithmetic:
.01a330	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.01a332	30 28		bmi $01a35c			bmi 	_FPAW_BNegative
.01a334	18		clc				clc
.01a335	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a337	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a339	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a33b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a33d	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a33f	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a341	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a343	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a345	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a347	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a349	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a34b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a34d	90 c0		bcc $01a30f			bcc 	_FPAWExit 					; no carry.
.01a34f	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.01a351	38		sec				sec
.01a352	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a354	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a356	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a358	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a35a	80 b3		bra $01a30f			bra 	_FPAWExit
.01a35c					_FPAW_BNegative:
.01a35c	38		sec				sec
.01a35d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.01a35f	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.01a361	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a363	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a365	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a367	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a369	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a36b	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a36d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a36f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a371	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a373	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a375	b0 09		bcs $01a380			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.01a377	20 a7 a5	jsr $01a5a7			jsr 	FPUNegateInteger			; negate the mantissa
.01a37a	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.01a37c	49 80		eor #$80			eor 	#$80
.01a37e	95 85		sta $85,x			sta 	XS_Type,x
.01a380					_FPAWGoExit:
.01a380	4c 0f a3	jmp $01a30f			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.01a383					FPD_IsDivZero:
.01a383	20 83 85	jsr $018583			jsr ERR_Handler
>01a386	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>01a38e	20 62 79 20 7a 65 72 6f 00
.01a397					FPDivide:
.01a397	48		pha				pha
.01a398	5a		phy				phy
.01a399	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.01a39b	70 e6		bvs $01a383			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.01a39d	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.01a39f	f0 03		beq $01a3a4			beq 	_FPDCalculateExp
.01a3a1					_FPD_Exit:
.01a3a1	7a		ply				ply
.01a3a2	68		pla				pla
.01a3a3	60		rts				rts
.01a3a4					_FPDCalculateExp:
.01a3a4	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.01a3a6	49 ff		eor #$ff			eor 	#$FF
.01a3a8	1a		inc a				inc 	a
.01a3a9	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.01a3ab	20 7b a4	jsr $01a47b			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.01a3ae	18		clc				clc 	 							; add 1 to the resulting exponent
.01a3af	69 01		adc #$01			adc 	#1
.01a3b1	b0 54		bcs $01a407			bcs 	_FPD_Overflow 				; which can overflow.
.01a3b3	95 84		sta $84,x			sta 	XS_Exponent,x
.01a3b5	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.01a3b7	85 1c		sta $1c				sta 	zLTemp1+0
.01a3b9	85 1d		sta $1d				sta 	zLTemp1+1
.01a3bb	85 1e		sta $1e				sta 	zLTemp1+2
.01a3bd	85 1f		sta $1f				sta 	zLTemp1+3
.01a3bf	a0 20		ldy #$20			ldy 	#32 						; times round.
.01a3c1					_FPD_Loop:
.01a3c1	38		sec				sec 								; calculate X1-X2 stacking result because we might
.01a3c2	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.01a3c4	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.01a3c6	48		pha				pha
.01a3c7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a3c9	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.01a3cb	48		pha				pha
.01a3cc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a3ce	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.01a3d0	48		pha				pha
.01a3d1	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a3d3	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.01a3d5	90 13		bcc $01a3ea			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.01a3d7	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.01a3d9	68		pla				pla
.01a3da	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a3dc	68		pla				pla
.01a3dd	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a3df	68		pla				pla
.01a3e0	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a3e2	a5 1f		lda $1f				lda 	zLTemp1+3 					; set high bit of result
.01a3e4	09 80		ora #$80			ora 	#$80
.01a3e6	85 1f		sta $1f				sta 	zLTemp1+3
.01a3e8	80 03		bra $01a3ed			bra 	_FPD_Rotates
.01a3ea					_FPD_NoSubtract:
.01a3ea	68		pla				pla 								; throw away unwanted results
.01a3eb	68		pla				pla
.01a3ec	68		pla				pla
.01a3ed					_FPD_Rotates:
.01a3ed	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.01a3ef	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.01a3f1	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.01a3f3	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.01a3f5	06 1c		asl $1c				asl 	zLTemp1 					; rotate result round left
.01a3f7	26 1d		rol $1d				rol 	zLTemp1+1
.01a3f9	26 1e		rol $1e				rol 	zLTemp1+2
.01a3fb	26 1f		rol $1f				rol 	zLTemp1+3
.01a3fd	90 02		bcc $01a401			bcc 	_FPD_NoCarry
.01a3ff	e6 1c		inc $1c				inc 	zLTemp1 					; if rotated out, set LSB.
.01a401					_FPD_NoCarry:
.01a401	88		dey				dey 								; do 32 times
.01a402	d0 bd		bne $01a3c1			bne 	_FPD_Loop
.01a404	4c 5f a4	jmp $01a45f			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.01a407					_FPD_Overflow:
.01a407	4c 4d a6	jmp $01a64d			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.01a40a					FPMultiply:
.01a40a	48		pha				pha
.01a40b	5a		phy				phy
.01a40c	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.01a40e	70 07		bvs $01a417			bvs 	_FPM_Exit
.01a410	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.01a412	50 06		bvc $01a41a			bvc 	_FPM_CalcExponent
.01a414	20 81 a5	jsr $01a581			jsr 	FPUCopyX2ToX1
.01a417					_FPM_Exit:
.01a417	7a		ply				ply
.01a418	68		pla				pla
.01a419	60		rts				rts
.01a41a					_FPM_CalcExponent:
.01a41a	18		clc				clc
.01a41b	20 7b a4	jsr $01a47b			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.01a41e	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.01a420	a9 00		lda #$00			lda 	#0
.01a422	85 1c		sta $1c				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.01a424	85 1d		sta $1d				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.01a426	85 1e		sta $1e				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.01a428	85 1f		sta $1f				sta 	zLTemp1+3
.01a42a	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.01a42c					_FPM_Loop:
.01a42c	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.01a42e	29 01		and #$01			and 	#1
.01a430	18		clc				clc 								; clear carry for the long rotate.
.01a431	f0 19		beq $01a44c			beq 	_FPM_NoAddition
.01a433	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.01a434	a5 1c		lda $1c				lda 	zLTemp1+0
.01a436	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.01a438	85 1c		sta $1c				sta 	zLTemp1+0
.01a43a	a5 1d		lda $1d				lda 	zLTemp1+1
.01a43c	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.01a43e	85 1d		sta $1d				sta 	zLTemp1+1
.01a440	a5 1e		lda $1e				lda 	zLTemp1+2
.01a442	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.01a444	85 1e		sta $1e				sta 	zLTemp1+2
.01a446	a5 1f		lda $1f				lda 	zLTemp1+3
.01a448	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.01a44a	85 1f		sta $1f				sta 	zLTemp1+3
.01a44c					_FPM_NoAddition:
.01a44c	66 1f		ror $1f				ror 	3+zLTemp1
.01a44e	66 1e		ror $1e				ror 	2+zLTemp1
.01a450	66 1d		ror $1d				ror 	1+zLTemp1
.01a452	66 1c		ror $1c				ror 	0+zLTemp1
.01a454	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a456	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a458	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a45a	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a45c	88		dey				dey
.01a45d	d0 cd		bne $01a42c			bne 	_FPM_Loop 					; do this 32 times.
.01a45f					FPM_CopySignNormalize:
.01a45f	a5 1c		lda $1c				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.01a461	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.01a463	a5 1d		lda $1d				lda 	zLTemp1+1
.01a465	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a467	a5 1e		lda $1e				lda 	zLTemp1+2
.01a469	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a46b	a5 1f		lda $1f				lda 	zLTemp1+3
.01a46d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a46f	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.01a471	55 8b		eor $8b,x			eor 	XS2_Type,x
.01a473	95 85		sta $85,x			sta 	XS_Type,x
.01a475	20 f0 a5	jsr $01a5f0			jsr 	FPUNormalise 				; normalise and exit.
.01a478	7a		ply				ply
.01a479	68		pla				pla
.01a47a	60		rts				rts
.01a47b					FPCalculateExponent:
.01a47b	18		clc				clc
.01a47c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.01a47e	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.01a480	b0 08		bcs $01a48a			bcs 	_FPCECarry 					; carry out ?
.01a482	10 03		bpl $01a487			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.01a484	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.01a486	60		rts				rts
.01a487					_FPCEExpZero:
.01a487	a9 00		lda #$00			lda 	#0
.01a489	60		rts				rts
.01a48a					_FPCECarry:
.01a48a	30 03		bmi $01a48f			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.01a48c	09 80		ora #$80			ora 	#$80 						; put in right range
.01a48e	60		rts				rts
.01a48f					_FPCEOverflow:
.01a48f	4c 4d a6	jmp $01a64d			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.01a492					FPFractionalPart:
.01a492	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.01a494	38		sec				sec 								; this flag tells us to keep the fractional part
.01a495	30 0d		bmi $01a4a4			bmi 	FPGetPart
.01a497	60		rts				rts
.01a498					FPIntegerPart:
.01a498	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.01a49a	18		clc				clc 								; this flag says keep the integer part.
.01a49b	30 07		bmi $01a4a4			bmi 	FPGetPart 					; -ve exponents are 0..127
.01a49d	48		pha				pha
.01a49e	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.01a4a0	95 85		sta $85,x			sta 	XS_Type,x
.01a4a2	68		pla				pla
.01a4a3	60		rts				rts
.01a4a4					FPGetPart:
.01a4a4	48		pha				pha
.01a4a5	5a		phy				phy 								; save Y
.01a4a6	08		php				php 								; save action
.01a4a7	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.01a4a9	70 59		bvs $01a504			bvs 	_FPGP_Exit 					; then do nothing.
.01a4ab	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.01a4ad	85 1c		sta $1c				sta 	zLTemp1+0 					; this mask is applied to chop out the
.01a4af	85 1d		sta $1d				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.01a4b1	85 1e		sta $1e				sta 	zLTemp1+2
.01a4b3	85 1f		sta $1f				sta 	zLTemp1+3
.01a4b5	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.01a4b7	38		sec				sec
.01a4b8	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.01a4ba	f0 12		beq $01a4ce			beq 	_FPGP_NoShift 				; ... if any
.01a4bc	c9 20		cmp #$20			cmp 	#32
.01a4be	90 02		bcc $01a4c2			bcc 	_FPGP_NotMax
.01a4c0	a9 20		lda #$20			lda 	#32 						; max of 32.
.01a4c2					_FPGP_NotMax:
.01a4c2	a8		tay				tay 								; Y is the mask shift count.
.01a4c3					_FPGP_ShiftMask:
.01a4c3	46 1f		lsr $1f				lsr 	3+zLTemp1
.01a4c5	66 1e		ror $1e				ror 	2+zLTemp1
.01a4c7	66 1d		ror $1d				ror 	1+zLTemp1
.01a4c9	66 1c		ror $1c				ror 	0+zLTemp1
.01a4cb	88		dey				dey
.01a4cc	d0 f5		bne $01a4c3			bne 	_FPGP_ShiftMask
.01a4ce					_FPGP_NoShift:
.01a4ce	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.01a4d0	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.01a4d3					_FPGP_MaskLoop:
.01a4d3	b9 1c 00	lda $001c,y			lda 	zlTemp1,y 					; get mask byte
.01a4d6	28		plp				plp 								; if CC we keep the top part, so we
.01a4d7	08		php				php		 							; flip the mask.
.01a4d8	b0 02		bcs $01a4dc			bcs		_FPGP_NoFlip
.01a4da	49 ff		eor #$ff			eor 	#$FF
.01a4dc					_FPGP_NoFlip:
.01a4dc	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.01a4de	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a4e0	e8		inx				inx
.01a4e1	c8		iny				iny
.01a4e2	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.01a4e4	d0 ed		bne $01a4d3			bne 	_FPGP_MaskLoop
.01a4e6	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.01a4e9	28		plp				plp
.01a4ea	08		php				php 								; get action flag on the stack
.01a4eb	90 04		bcc $01a4f1			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.01a4ed	a9 00		lda #$00			lda 	#0
.01a4ef	95 85		sta $85,x			sta 	XS_Type,x
.01a4f1					_FPGP_NotFractional:
.01a4f1	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.01a4f3	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a4f5	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a4f7	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a4f9	f0 05		beq $01a500			beq 	_FPGP_Zero 					; if zero, return zero
.01a4fb	20 f0 a5	jsr $01a5f0			jsr 	FPUNormalise
.01a4fe	80 04		bra $01a504			bra 	_FPGP_Exit 					; and exit
.01a500					_FPGP_Zero:
.01a500	a9 40		lda #$40			lda 	#$40 						; set zero flag
.01a502	95 85		sta $85,x			sta 	XS_Type,x
.01a504					_FPGP_Exit:
.01a504	68		pla				pla 								; throw saved action flag.
.01a505	7a		ply				ply
.01a506	68		pla				pla
.01a507	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.01a508					FPCompare:
.01a508	20 49 a5	jsr $01a549			jsr 	FPFastCompare 				; fast compare try first
.01a50b	b0 3b		bcs $01a548			bcs 	_FPCExit 					; that worked.
.01a50d	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.01a50f	48		pha				pha
.01a510	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.01a512	48		pha				pha
.01a513	20 db a2	jsr $01a2db			jsr 	FPSubtract 					; calculate X1-X2
.01a516	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.01a518	70 2a		bvs $01a544			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.01a51a	68		pla				pla
.01a51b	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.01a51e	68		pla				pla
.01a51f	38		sec				sec
.01a520	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.01a523	70 14		bvs $01a539			bvs 	_FPCNotEqual				; overflow, can't be equal.
.01a525	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.01a526	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.01a528	b0 0f		bcs $01a539			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.01a52a	38		sec				sec
.01a52b	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.01a52e	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.01a530	b0 02		bcs $01a534			bcs 	_FPCNotRange 				; keep in range.
.01a532	a9 01		lda #$01			lda 	#1
.01a534					_FPCNotRange:
.01a534	38		sec				sec
.01a535	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.01a537	b0 0d		bcs $01a546			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.01a539					_FPCNotEqual:
.01a539	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.01a53b	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.01a53d	f0 02		beq $01a541			beq 	_FPCNE2
.01a53f	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.01a541	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.01a542	80 04		bra $01a548			bra 	_FPCExit
.01a544					_FPCPullZero:
.01a544	68		pla				pla 								; throw saved exponents
.01a545	68		pla				pla
.01a546					_FPCZero:
.01a546	a9 00		lda #$00			lda 	#0 							; and return zero
.01a548					_FPCExit:
.01a548	60		rts				rts
.01a549					FPFastCompare:
.01a549	34 85		bit $85,x			bit 	XS_Type,x 					; n1 is zero.
.01a54b	70 23		bvs $01a570			bvs 	_FPFLeftZero
.01a54d	34 8b		bit $8b,x			bit 	XS2_Type,x 					; n2 is zero
.01a54f	b5 85		lda $85,x			lda 	XS_Type,x 					; if so, return sign bit of 1 (n-0)
.01a551	70 25		bvs $01a578			bvs 	_FPFSignBit
.01a553	55 8b		eor $8b,x			eor 	XS2_Type,x 					; eor 2 type bits. now know both non-zero
.01a555	0a		asl a				asl 	a 							; put in CS if different.
.01a556	b5 85		lda $85,x			lda 	XS_Type,x 					; if signs different return sign of first
.01a558	b0 1e		bcs $01a578			bcs 	_FPFSignBit
.01a55a	38		sec				sec 								; same sign and not-zero. compare exponents
.01a55b	b5 84		lda $84,x			lda 	XS_Exponent,x 				; compare exponents. if the same, then fail.
.01a55d	f5 8a		sbc $8a,x			sbc 	XS2_Exponent,x 				; e.g. we have to do it via subtraction.
.01a55f	f0 09		beq $01a56a			beq 	_FPNoFastCompare
.01a561	6a		ror a				ror 	a 							; put carry into bit 7.
.01a562	34 85		bit $85,x			bit 	XS_Type,X 					; if it is +x then flip it.
.01a564	30 02		bmi $01a568			bmi		_FPFCNotMinus
.01a566	49 80		eor #$80			eor 	#$80
.01a568					_FPFCNotMinus:
.01a568	80 0e		bra $01a578			bra		_FPFSignBit
.01a56a					_FPNoFastCompare:
.01a56a	18		clc				clc
.01a56b	60		rts				rts
.01a56c					_FPFZero:
.01a56c	a9 00		lda #$00			lda 	#0
.01a56e					_FPFExitSet:
.01a56e	38		sec				sec
.01a56f	60		rts				rts
.01a570					_FPFLeftZero:
.01a570	34 8b		bit $8b,x			bit 	XS2_Type,x 					; if right is zero, return zero.
.01a572	70 f8		bvs $01a56c			bvs 	_FPFZero
.01a574	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip sign bit
.01a576	49 80		eor #$80			eor 	#$80						; return that as a sign.
.01a578					_FPFSignBit:
.01a578	0a		asl a				asl 	a
.01a579	a9 01		lda #$01			lda 	#1
.01a57b	90 f1		bcc $01a56e			bcc		_FPFExitSet
.01a57d	a9 ff		lda #$ff			lda 	#$FF
.01a57f	38		sec				sec
.01a580	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.01a581					FPUCopyX2ToX1:
.01a581	48		pha				pha
.01a582	da		phx				phx
.01a583	5a		phy				phy
.01a584	a0 08		ldy #$08			ldy 	#8
.01a586	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.01a588	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a58a	e8		inx				inx
.01a58b	88		dey				dey
.01a58c	10 f8		bpl $01a586			bpl 	_FPUC21
.01a58e	7a		ply				ply
.01a58f	fa		plx				plx
.01a590	68		pla				pla
.01a591	60		rts				rts
.01a592					FPUSetInteger:
.01a592	48		pha				pha
.01a593	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.01a595	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.01a597	10 02		bpl $01a59b			bpl 	_FPUSIExtend
.01a599	a9 ff		lda #$ff			lda 	#$FF
.01a59b					_FPUSIExtend:
.01a59b	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.01a59d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a59f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5a1	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.01a5a3	95 85		sta $85,x			sta 	XS_Type,x
.01a5a5	68		pla				pla
.01a5a6	60		rts				rts
.01a5a7					FPUNegateInteger:
.01a5a7	48		pha				pha
.01a5a8	38		sec				sec
.01a5a9	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.01a5ab	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.01a5ad	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a5af	a9 00		lda #$00			lda 	#0
.01a5b1	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.01a5b3	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a5b5	a9 00		lda #$00			lda 	#0
.01a5b7	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.01a5b9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a5bb	a9 00		lda #$00			lda 	#0
.01a5bd	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.01a5bf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a5c1	68		pla				pla
.01a5c2	60		rts				rts
.01a5c3					FPUToFloat:
.01a5c3	48		pha				pha
.01a5c4	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.01a5c6	29 0f		and #$0f			and 	#$0F
.01a5c8	f0 24		beq $01a5ee			beq 	_FPUFExit
.01a5ca	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.01a5cc	95 85		sta $85,x			sta 	XS_Type,x
.01a5ce	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.01a5d0	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.01a5d2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.01a5d4	10 07		bpl $01a5dd			bpl		_FPUFPositive
.01a5d6	20 a7 a5	jsr $01a5a7			jsr 	FPUNegateInteger 			; negate the mantissa
.01a5d9	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.01a5db	95 85		sta $85,x			sta 	XS_Type,x
.01a5dd					_FPUFPositive:
.01a5dd	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.01a5df	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.01a5e1	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01a5e3	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01a5e5	d0 04		bne $01a5eb			bne 	_FPUFNonZero
.01a5e7	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.01a5e9	95 85		sta $85,x			sta 	XS_Type,x
.01a5eb					_FPUFNonZero:
.01a5eb	20 f0 a5	jsr $01a5f0			jsr 	FPUNormalise 				; normalise the floating point.
.01a5ee					_FPUFExit:
.01a5ee	68		pla				pla
.01a5ef	60		rts				rts
.01a5f0					FPUNormalise:
.01a5f0	48		pha				pha
.01a5f1	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.01a5f3	70 18		bvs $01a60d			bvs 	_FPUNExit
.01a5f5	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.01a5f7	f0 10		beq $01a609			beq 	_FPUNSetZero
.01a5f9					_FPUNLoop:
.01a5f9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.01a5fb	30 10		bmi $01a60d			bmi 	_FPUNExit 					; if so, we are normalised.
.01a5fd	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.01a5ff	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.01a601	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.01a603	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.01a605	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.01a607	d0 f0		bne $01a5f9			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.01a609					_FPUNSetZero:
.01a609	a9 40		lda #$40			lda 	#$40
.01a60b	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.01a60d					_FPUNExit:
.01a60d	68		pla				pla
.01a60e	60		rts				rts
.01a60f					FPUToInteger:
.01a60f	48		pha				pha
.01a610	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.01a612	29 01		and #$01			and 	#1
.01a614	d0 31		bne $01a647			bne 	_FPUTOI_Exit
.01a616	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.01a618	70 23		bvs $01a63d			bvs 	_FPUTOI_Zero
.01a61a	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.01a61c	10 1f		bpl $01a63d			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.01a61e	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.01a620	b0 2b		bcs $01a64d			bcs 	FP_Overflow
.01a622					_FPUToIToInteger:
.01a622	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.01a624	c9 a0		cmp #$a0			cmp 	#128+32
.01a626	f0 0c		beq $01a634			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.01a628	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.01a62a	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.01a62c	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a62e	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a630	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a632	80 ee		bra $01a622			bra 	_FPUToIToInteger 			; keep going.
.01a634					_FPUToICheckSign:
.01a634	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.01a636	10 0f		bpl $01a647			bpl 	_FPUToI_Exit 				; exit if unsigned.
.01a638	20 a7 a5	jsr $01a5a7			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.01a63b	80 0a		bra $01a647			bra 	_FPUTOI_Exit
.01a63d					_FPUTOI_Zero:
.01a63d	a9 00		lda #$00			lda 	#0 							; return zero integer.
.01a63f	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a641	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a643	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a645	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a647					_FPUToI_Exit:
.01a647	a9 01		lda #$01			lda 	#1 							; set type to integer
.01a649	95 85		sta $85,x			sta 	XS_Type,x
.01a64b	68		pla				pla
.01a64c	60		rts				rts
.01a64d					FP_Overflow:
.01a64d	20 83 85	jsr $018583			jsr ERR_Handler
>01a650	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>01a658	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.01a668					FPUTimes10:
.01a668	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.01a66a	85 1c		sta $1c				sta 	ZLTemp1+0
.01a66c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a66e	85 1d		sta $1d				sta 	ZLTemp1+1
.01a670	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a672	85 1e		sta $1e				sta 	ZLTemp1+2
.01a674	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a676	85 1f		sta $1f				sta 	ZLTemp1+3
.01a678	20 ad a6	jsr $01a6ad			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.01a67b	20 ad a6	jsr $01a6ad			jsr 	_FPUT_LSR_ZLTemp1
.01a67e	18		clc				clc
.01a67f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.01a681	65 1c		adc $1c				adc 	ZLTemp1+0
.01a683	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a685	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01a687	65 1d		adc $1d				adc 	ZLTemp1+1
.01a689	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a68b	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.01a68d	65 1e		adc $1e				adc 	ZLTemp1+2
.01a68f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a691	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.01a693	65 1f		adc $1f				adc 	ZLTemp1+3
.01a695	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a697	90 0a		bcc $01a6a3			bcc 	_FPUTimes10
.01a699	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.01a69b	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.01a69d	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.01a69f	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.01a6a1	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.01a6a3					_FPUTimes10:
.01a6a3	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.01a6a5	18		clc				clc
.01a6a6	69 03		adc #$03			adc 	#3
.01a6a8	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6aa	b0 a1		bcs $01a64d			bcs 	FP_Overflow 				; error
.01a6ac	60		rts				rts
.01a6ad					_FPUT_LSR_ZLTemp1:
.01a6ad	46 1f		lsr $1f				lsr 	ZLTemp1+3
.01a6af	66 1e		ror $1e				ror 	ZLTemp1+2
.01a6b1	66 1d		ror $1d				ror 	ZLTemp1+1
.01a6b3	66 1c		ror $1c				ror 	ZLTemp1+0
.01a6b5	60		rts				rts
.01a6b6					FPUScale10A:
.01a6b6	5a		phy				phy
.01a6b7	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.01a6b9	f0 37		beq $01a6f2			beq 	_FPUScaleExit
.01a6bb	da		phx				phx 								; save X
.01a6bc	e8		inx				inx
.01a6bd	e8		inx				inx
.01a6be	e8		inx				inx
.01a6bf	e8		inx				inx
.01a6c0	e8		inx				inx
.01a6c1	e8		inx				inx
.01a6c2	a8		tay				tay 								; save power scalar in Y.
.01a6c3	a9 00		lda #$00			lda 	#0
.01a6c5	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.01a6c7	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a6c9	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a6cb	95 85		sta $85,x			sta 	XS_Type,x
.01a6cd	a9 80		lda #$80			lda 	#$80
.01a6cf	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a6d1	a9 81		lda #$81			lda 	#$81
.01a6d3	95 84		sta $84,x			sta 	XS_Exponent,x
.01a6d5	5a		phy				phy 								; save 10^n on stack.
.01a6d6	c0 00		cpy #$00			cpy 	#0
.01a6d8	10 05		bpl $01a6df			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.01a6da	98		tya				tya
.01a6db	49 ff		eor #$ff			eor 	#$FF
.01a6dd	1a		inc a				inc 	a
.01a6de	a8		tay				tay
.01a6df					_FPUSAbs:
.01a6df	20 68 a6	jsr $01a668			jsr 	FPUTimes10
.01a6e2	88		dey				dey
.01a6e3	d0 fa		bne $01a6df			bne 	_FPUSAbs 					; tos is now 10^|AC|
.01a6e5	68		pla				pla 								; restore count in A
.01a6e6	fa		plx				plx 								; restore X pointing to number to scale.
.01a6e7	0a		asl a				asl 	a
.01a6e8	b0 05		bcs $01a6ef			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.01a6ea	20 0a a4	jsr $01a40a			jsr 	FPMultiply 					; if clear multiply.
.01a6ed	80 03		bra $01a6f2			bra		_FPUScaleExit
.01a6ef					_FPUSDivide:
.01a6ef	20 97 a3	jsr $01a397			jsr 	FPDivide
.01a6f2					_FPUScaleExit:
.01a6f2	7a		ply				ply
.01a6f3	60		rts				rts
.01a6f4					FPUCopyToNext:
.01a6f4	a0 06		ldy #$06			ldy 		#6
.01a6f6	da		phx				phx
.01a6f7					_FPUCopy1:
.01a6f7	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a6f9	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a6fb	e8		inx				inx
.01a6fc	88		dey				dey
.01a6fd	d0 f8		bne $01a6f7			bne 	_FPUCopy1
.01a6ff	fa		plx				plx
.01a700	60		rts				rts
.01a701					FPUCopyFromNext:
.01a701	a0 06		ldy #$06			ldy 		#6
.01a703	da		phx				phx
.01a704					_FPUCopy1:
.01a704	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a706	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a708	e8		inx				inx
.01a709	88		dey				dey
.01a70a	d0 f8		bne $01a704			bne 	_FPUCopy1
.01a70c	fa		plx				plx
.01a70d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a70e					FPToString:
.01a70e	48		pha				pha
.01a70f	5a		phy				phy
.01a710	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a712	50 0a		bvc $01a71e			bvc 		_FPTSIsFloat 			; if zero,
.01a714					_FPTSZero:
.01a714	a9 30		lda #$30			lda 		#"0"
.01a716	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter
.01a719					_FPTSExit:
.01a719	7a		ply				ply
.01a71a	68		pla				pla
.01a71b	60		rts				rts
.01a71c	80 fb		bra $01a719			bra 		_FPTSExit
.01a71e					_FPTSIsFloat:
.01a71e	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a720	10 09		bpl $01a72b			bpl 		_FPTSNotSigned
.01a722	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a724	95 85		sta $85,x			sta 		XS_Type,x
.01a726	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a728	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter
.01a72b					_FPTSNotSigned:
.01a72b	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a72d	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a72f	b0 09		bcs $01a73a			bcs 		_FPTSExponent
.01a731	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a733	90 05		bcc $01a73a			bcc 		_FPTSExponent 			;
.01a735					_FPTSStandard:
.01a735	20 79 a7	jsr $01a779			jsr 		FPTOutputBody 			; output the body.
.01a738	80 df		bra $01a719			bra 		_FPTSExit
.01a73a					_FPTSExponent:
.01a73a	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a73c	8d 9d 03	sta $039d			sta 		ExpCount
.01a73f					_FPTSExponentLoop:
.01a73f	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a741	10 0e		bpl $01a751			bpl 		_FPTSTimes
.01a743	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a745	90 14		bcc $01a75b			bcc 		_FPTSScaledToExp
.01a747	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a749	20 b6 a6	jsr $01a6b6			jsr 		FPUScale10A
.01a74c	ee 9d 03	inc $039d			inc 		ExpCount
.01a74f	80 ee		bra $01a73f			bra 		_FPTSExponentLoop
.01a751					_FPTSTimes:
.01a751	a9 01		lda #$01			lda 		#1
.01a753	20 b6 a6	jsr $01a6b6			jsr 		FPUScale10A
.01a756	ce 9d 03	dec $039d			dec 		ExpCount
.01a759	80 e4		bra $01a73f			bra 		_FPTSExponentLoop
.01a75b					_FPTSScaledToExp:
.01a75b	20 79 a7	jsr $01a779			jsr 		FPTOutputBody 			; output the body.
.01a75e	a9 65		lda #$65			lda 		#"e"					; output E
.01a760	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter
.01a763	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a766	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a768	29 80		and #$80			and 		#$80 					; sign extend it
.01a76a	f0 02		beq $01a76e			beq 		_FPTSSExt
.01a76c	a9 ff		lda #$ff			lda 		#$FF
.01a76e					_FPTSSExt:
.01a76e	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a770	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a772	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a774	20 94 a1	jsr $01a194			jsr 		INTToString 			; output the exponent.
.01a777	80 a0		bra $01a719			bra			_FPTSExit 				; and exit.
.01a779					FPTOutputBody:
.01a779	20 f4 a6	jsr $01a6f4			jsr 		FPUCopyToNext 			; copy to next slot.
.01a77c	20 0f a6	jsr $01a60f			jsr 		FPUToInteger 			; convert to an integer
.01a77f	20 94 a1	jsr $01a194			jsr 		INTToString 			; output the main integer part.
.01a782	20 01 a7	jsr $01a701			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a785	20 92 a4	jsr $01a492			jsr 		FPFractionalPart 		; get the decimal part.
.01a788	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a78a	70 3c		bvs $01a7c8			bvs 		_FPTOExit 				; if not, exit now.
.01a78c	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a78e	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter
.01a791					_FPOutLoop:
.01a791	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a793	70 1d		bvs $01a7b2			bvs 		_FPStripZeros 			; strip trailing zeros
.01a795	20 68 a6	jsr $01a668			jsr 		FPUTimes10 				; multiply by 10
.01a798	20 f4 a6	jsr $01a6f4			jsr 		FPUCopyToNext			; copy to next slot.
.01a79b	20 0f a6	jsr $01a60f			jsr 		FPUToInteger 			; convert to integer
.01a79e	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a7a0	09 30		ora #$30			ora 		#"0"
.01a7a2	20 36 a2	jsr $01a236			jsr 		ITSOutputCharacter
.01a7a5	20 01 a7	jsr $01a701			jsr 		FPUCopyFromNext 		; get it back
.01a7a8	20 92 a4	jsr $01a492			jsr 		FPFractionalPart 		; get fractional part
.01a7ab	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a7ae	c9 0b		cmp #$0b			cmp 	 	#11
.01a7b0	90 df		bcc $01a791			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a7b2					_FPStripZeros:
.01a7b2	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a7b5					_FPStripLoop:
.01a7b5	88		dey				dey 								; back one, if at start then no strip
.01a7b6	f0 10		beq $01a7c8			beq 		_FPToExit
.01a7b8	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a7bb	c9 30		cmp #$30			cmp 		#"0"
.01a7bd	f0 f6		beq $01a7b5			beq 		_FPStripLoop
.01a7bf	c8		iny				iny
.01a7c0	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a7c2	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a7c5	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a7c8					_FPTOExit:
.01a7c8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a7c9					FPFromString:
.01a7c9	48		pha				pha 								; push A
.01a7ca	b1 20		lda ($20),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a7cc	c9 2e		cmp #$2e			cmp 	#"."
.01a7ce	f0 03		beq $01a7d3			beq	 	_FPFIsDecimal
.01a7d0	4c 2f a8	jmp $01a82f			jmp 	_FPFNotDecimal
.01a7d3					_FPFIsDecimal:
.01a7d3	c8		iny				iny 								; consume the decimal.
.01a7d4	20 c3 a5	jsr $01a5c3			jsr 	FPUToFloat 					; convert the integer to float.
.01a7d7	da		phx				phx 								; save X.
.01a7d8	5a		phy				phy 								; save decimal start position
.01a7d9	e8		inx				inx
.01a7da	e8		inx				inx
.01a7db	e8		inx				inx
.01a7dc	e8		inx				inx
.01a7dd	e8		inx				inx
.01a7de	e8		inx				inx
.01a7df	20 4b a2	jsr $01a24b			jsr 	INTFromStringY 				; get the part after the DP.
.01a7e2	20 c3 a5	jsr $01a5c3			jsr 	FPUToFloat 					; convert that to a float.
.01a7e5	68		pla				pla 								; calculate - chars consumed.
.01a7e6	8c 9c 03	sty $039c			sty 	ExpTemp
.01a7e9	38		sec				sec
.01a7ea	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a7ed	20 b6 a6	jsr $01a6b6			jsr 	FPUScale10A 				; scale it by 10^AC
.01a7f0	fa		plx				plx 								; restore original X
.01a7f1	20 e3 a2	jsr $01a2e3			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a7f4	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; exponent ?
.01a7f6	c9 45		cmp #$45			cmp 	#"E"
.01a7f8	f0 04		beq $01a7fe			beq 	_FPFExponent
.01a7fa	c9 65		cmp #$65			cmp 	#"e"
.01a7fc	d0 31		bne $01a82f			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a7fe					_FPFExponent:
.01a7fe	c8		iny				iny 								; skip over E symbol.
.01a7ff	b1 20		lda ($20),y			lda 	(zGenPtr),y 				; look at next
.01a801	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a803	d0 01		bne $01a806			bne 	_FPFGotSign
.01a805	c8		iny				iny 								; if it was - skip over it.
.01a806					_FPFGotSign:
.01a806	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a807	da		phx				phx
.01a808	e8		inx				inx
.01a809	e8		inx				inx
.01a80a	e8		inx				inx
.01a80b	e8		inx				inx
.01a80c	e8		inx				inx
.01a80d	e8		inx				inx
.01a80e	20 4b a2	jsr $01a24b			jsr 	INTFromStringY 				; get the exponent
.01a811	fa		plx				plx 								; restore X.
.01a812	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a814	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a816	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a818	d0 17		bne $01a831			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a81a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a81c	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a81e	b0 11		bcs $01a831			bcs 	_FPFXOverflow
.01a820	68		pla				pla 								; get direction
.01a821	d0 07		bne $01a82a			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a823	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a825	49 ff		eor #$ff			eor 	#$FF
.01a827	1a		inc a				inc 	a
.01a828	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a82a					_FPFXScale:
.01a82a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a82c	20 b6 a6	jsr $01a6b6			jsr 	FPUScale10A 				; scale by the exponent.
.01a82f					_FPFNotDecimal:
.01a82f	68		pla				pla
.01a830	60		rts				rts
.01a831					_FPFXOverflow:
.01a831	20 83 85	jsr $018583			jsr 	ERR_Handler
>01a834	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a83c	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a843					Unary_Rnd:
.01a843	20 94 93	jsr $019394			jsr 	EvaluateNumberX 			; get value
.01a846	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; check right bracket.
.01a849	20 14 96	jsr $019614			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a84c	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a84e	30 10		bmi $01a860			bmi 	_URSetSeed
.01a850	f0 28		beq $01a87a			beq 	_URMakeRandom 				; if zero return same number, don't advance sequence
.01a852	da		phx				phx
.01a853	a2 00		ldx #$00			ldx 	#0 							; run 16 bit RNG procession on upper/lower
.01a855	20 b1 a8	jsr $01a8b1			jsr 	Random16
.01a858	a2 02		ldx #$02			ldx 	#2
.01a85a	20 b1 a8	jsr $01a8b1			jsr 	Random16
.01a85d	fa		plx				plx
.01a85e	80 1a		bra $01a87a			bra 	_URMakeRandom
.01a860					_URSetSeed:
.01a860	20 c3 a5	jsr $01a5c3			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a863	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a865	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a868	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a86a	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a86d	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a86f	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a872	b5 83		lda $83,x			lda		XS_Mantissa+3,x 			; this is to make the seed bear not much
.01a874	0a		asl a				asl 	a 							; resemblance to the seed value.
.01a875	49 db		eor #$db			eor 	#$DB
.01a877	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a87a					_URMakeRandom:
.01a87a	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a87d	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a880	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a883	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a886	d0 0a		bne $01a892			bne 	_URNotZero
.01a888	a9 47		lda #$47			lda 	#$47						; if it is, make it non zero.
.01a88a	8d a4 03	sta $03a4			sta 	RandomSeed+1				; in both parts.
.01a88d	a9 3d		lda #$3d			lda 	#$3D
.01a88f	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a892					_URNotZero:
.01a892	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a895	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a897	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a89a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a89c	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a89f	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a8a1	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a8a4	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a8a6	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a8a8	95 85		sta $85,x			sta 	XS_Type,x
.01a8aa	a9 80		lda #$80			lda 	#$80
.01a8ac	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a8ae	4c f0 a5	jmp $01a5f0			jmp 	FPUNormalise 				; and normalise.
.01a8b1					Random16:
.01a8b1	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a8b4	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a8b7	90 08		bcc $01a8c1			bcc 	_R16_NoXor
.01a8b9	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a8bc	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a8be	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a8c1					_R16_NoXor:
.01a8c1	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a8c2					Unary_Int:
.01a8c2	20 94 93	jsr $019394			jsr 	EvaluateNumberX 			; get value
.01a8c5	20 f6 99	jsr $0199f6			jsr 	CheckNextRParen 			; check right bracket.
.01a8c8	4c 0f a6	jmp $01a60f			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a8cb	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM 					; Reset vector
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
