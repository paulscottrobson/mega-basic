
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -X -b -q -L rom.lst -o rom.bin basic.asm
; Fri Aug 30 08:39:12 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: _include.asm

="65816"				cpu = "65816"
="em65816"				hardware = "em65816"
=1					exitonend = 1
=0					autorun = 0
=1					loadtest = 1
=1					hasfloat = 1
=1					hasinteger = 1
=253					maxstring = 253

;******  Processing file: modules/basic/pointer/em65816/src_em65816.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/handlers.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stackmarkers.inc

=5					SourcePosSize   =   5 							; Source position stack space needed.
=0					SMark_Gosub 	= 	0 							; 0 is GOSUB/RETURN.
=1					SMark_Repeat 	= 	1 							; 1 is REPEAT/UNTIL.
=2					SMark_While 	= 	2 							; 2 is WHILE/WEND.
=3					SMark_If 		= 	3 							; 3 is IF/ENDIF

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/common.inc


;******  Return to file: _include.asm


;******  Processing file: modules/hardware/common/macros32.inc


;******  Return to file: _include.asm


;******  Processing file: modules/basic/data/data.asm

.0000	ea		nop				nop 								; just in cases.....
>0010					zTemp1:		.word ?							; temporary pointers
>0012					zTemp2:		.word ?
>0014					zTemp3:		.word ?
>0016					zCodePtr:	.dword ? 						; code pointer.
>001a					zLTemp1:	.dword ?						; long word (used in multiply)
>001e					zGenPtr:	.word ? 						; general pointer.
>0020					zTempStr:	.word ?							; temporary string allocator. When high zero, not initialised.
>0022					zVarDataPtr: .word ? 						; position of variable data.
>0024					zVarType: 	.byte ? 						; type of data (token)
>0025					zNullString:.byte ? 						; represents a NULL string.
>0026					zBasicSP:	.word ? 						; stack pointer
>0080					XS_Mantissa .dword ? 						; 4 byte mantissa, bit 31 set.
>0084					XS_Exponent .byte ?							; 1 byte exponent, 128 == 2^0 (float only)
>0085					XS_Type 	.byte ? 						; bit 7 sign (float only)
=6					XS_Size = 6
=134					XS2_Mantissa = XS_Mantissa+XS_Size
=138					XS2_Exponent = XS_Exponent+XS_Size
=139					XS2_Type = XS_Type+XS_Size
=140					XS3_Mantissa = XS_Mantissa+XS_Size*2
=144					XS3_Exponent = XS_Exponent+XS_Size*2
=145					XS3_Type = XS_Type+XS_Size*2
>0300					StringPtr:	.word ? 						; Top of free memory (for string allocation)
>0302					VarMemPtr: 	.word ?							; Bottom of free memory (for variables)
>0304					endOfProgram: .dword ? 						; End of Program Memory (long)
>0308					vecPrintCharacter .word ?
>030a					vecInputCharacter .word ?
>030c					UserVector .fill 4 							; USR(x) calls this.
>0310					LocalVector .fill 4 						; Indirect calls call this.
>0314					NumBufX 	.byte 	?						; buffer index position
>0315					Num_Buffer	.fill 	32 						; buffer for numeric conversions
=6					HashTableCount = 6 							; there are 6 hash tables, in token order.
=8					HashTableSize = 8 							; each hash table as 8 links.
.0335					HashTableBase:
>0335								.fill	HashTableCount * HashTableSize * 2
.0395					HashTableEnd:
=$315					Var_Buffer 	= Num_Buffer 					; buffer for variable name (same space)
>0395					Var_Type    .byte ? 						; type of variable (as a type token)
>0396					Var_Hash 	.byte ? 						; hash of identifier name.
>0397					Var_Length 	.byte ? 						; length of variable name
>0398					Var_HashAddress .byte ?						; low byte of hash table entry.
>0399					Var_DataSize .byte ?						; size of one element.
>039a					NumSuppress	.byte 	?						; leading zero suppression flag
>039b					NumConvCount .byte 	? 						; count for conversions.
>039c					ExpTemp:	.byte ?							; Working temp for exponents.
>039d					ExpCount:	.byte ? 						; Count of decimal exponents.
>039e					SignCount:	.byte ?							; Integer Divide Sign Counts.
>039f					TempStringWriteIndex: .byte ? 				; Write offset.
>03a0					ValSign: 	.byte ? 						; sign flag for val()
>03a1					SliceStart:	.byte ? 						; string slice parts
>03a2					SliceCount:	.byte ?
>03a3					RandomSeed:	.dword ? 						; Random seed.
>03a7					BreakCount:	.byte ? 						; Counter, avoid checking break every command.
=3					ArrayMaxDim = 3 							; number of dimensions.
>03a8					ArrayDef:	.fill (ArrayMaxDim+1)*2 		; dimensions for auto-creation
>03b0					UsrArrayDef:.fill (ArrayMaxDim+1)*2 		; dimensions created in DIM
>03b8					UsrArrayIdx:.byte ? 						; index into UsrArrayDef
>03b9					Tim_PC:		.word ?							; program counter on BRK (Hi/Lo order)
>03bb					Tim_IRQ:	.word ?							; IRQ Vector (Hi/Lo order)
>03bd					Tim_SR:		.byte ? 						; Processor Status
>03be					Tim_A:		.byte ? 						; Processor Registers
>03bf					Tim_X:		.byte ?
>03c0					Tim_Y:		.byte ?
>03c1					Tim_Z:		.byte ?
>03c2					Tim_SP:		.word ?							; Stack Pointer (just in cases)
>0400					BasicStack:	.fill 	256 					; and occupy whole pages.
.0500					EndBasicStack:
>0500					IFT_XCursor:.byte ?							; current logical position on screen
>0501					IFT_YCursor:.byte ?
>0502					IFT_Buffer:	.fill 100 						; scroll copy buffer.
>0566					IFT_LineBuffer: .fill 100 					; line input buffer.

;******  Return to file: _include.asm


;******  Processing file: modules/hardware/em65816.asm

=$7f00					HighMemory = $7F00
=$3000					VariableMemory = $3000
.1000					BasicProgram:

;******  Processing file: modules/hardware/../basic/testcode/testcode.src

>1000	08 14 00 cf 0b 84 40 00			.byte	$08,$14,$00,$cf,$0b,$84,$40,$00
>1008	0a 1e 00 cf 0b 84 0b 8a			.byte	$0a,$1e,$00,$cf,$0b,$84,$0b,$8a
>1010	41 00 10 28 00 cf 01 84			.byte	$41,$00,$10,$28,$00,$cf,$01,$84
>1018	0b 8d 42 8c 43 8a 44 8b			.byte	$0b,$8d,$42,$8c,$43,$8a,$44,$8b
>1020	45 00 07 2d 00 ca 4a 7c			.byte	$45,$00,$07,$2d,$00,$ca,$4a,$7c
>1028	00 0c 32 00 8f 0b 86 4f			.byte	$00,$0c,$32,$00,$8f,$0b,$86,$4f
>1030	68 93 cc 5e 00 05 37 00			.byte	$68,$93,$cc,$5e,$00,$05,$37,$00
>1038	cd 00 05 bc 02 cb 00 00			.byte	$cd,$00,$05,$bc,$02,$cb,$00,$00

;******  Return to file: modules/hardware/em65816.asm

.c000					StartROM:
.c000	18		clc				clc
.c001	fb		xce				xce
.c002	c2 30		rep #$30			rep 	#$30
.c004	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.c007	1b		tcs				tcs
.c008	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.c00b	e2 30		sep #$30			sep 	#$30
.c00d	c2 30		rep #$30			rep 	#$30						; clear AXY in 16 bit.
.c00f	a9 00		lda #$00			lda 	#$0000
.c011	aa		tax				tax
.c012	a8		tay				tay
.c013	e2 30		sep #$30			sep 	#$30
.c015	5c df 87 01	jmp $0187df		jmp BASIC_Start
.c019					TIM_BreakHandler:
.c019	5c 76 83 01	jmp $018376			jmp 	TIM_BreakVector

;******  Return to file: _include.asm


;******  Processing file: modules/interface/common/interface_tools.asm

.018000					IFT_ClearScreen:
.018000	48		pha				pha
.018001	da		phx				phx
.018002	5a		phy				phy
.018003	20 a9 81	jsr $0181a9			jsr 	IF_Home 					; home cursor
.018006	a2 20		ldx #$20			ldx 	#IF_Height 					; this many lines.
.018008					_IFT_CS0:
.018008	a0 40		ldy #$40			ldy 	#IF_Width 					; this many chars/line
.01800a					_IFT_CS1:
.01800a	a9 20		lda #$20			lda 	#' '						; clear line.
.01800c	20 d5 81	jsr $0181d5			jsr 	IF_Write
.01800f	88		dey				dey
.018010	d0 f8		bne $01800a			bne 	_IFT_CS1
.018012	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; next line down
.018015	ca		dex				dex
.018016	d0 f0		bne $018008			bne 	_IFT_CS0
.018018	7a		ply				ply
.018019	fa		plx				plx
.01801a	68		pla				pla
.01801b					IFT_HomeCursor:
.01801b	48		pha				pha
.01801c	20 a9 81	jsr $0181a9			jsr 	IF_Home
.01801f	a9 00		lda #$00			lda 	#0
.018021	8d 00 05	sta $0500			sta 	IFT_XCursor
.018024	8d 01 05	sta $0501			sta 	IFT_YCursor
.018027	68		pla				pla
.018028	60		rts				rts
.018029					IFT_UpLine:
.018029	48		pha				pha
.01802a	ad 01 05	lda $0501			lda  	IFT_YCursor 				; get Y
.01802d	3a		dec a				dec 	a 							; line above
.01802e	30 03		bmi $018033			bmi 	_IFTULExit 					; too far, abort
.018030	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos					; set to that line.
.018033					_IFTULExit:
.018033	68		pla				pla
.018034	60		rts				rts
.018035					IFT_PrintCharacter:
.018035	c9 0d		cmp #$0d			cmp 	#13 						; handle newline.
.018037	f0 23		beq $01805c			beq 	IFT_NewLine
.018039	48		pha				pha
.01803a	20 74 80	jsr $018074			jsr 	IFT_UpperCase 				; make upper case
.01803d	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write out.
.018040	ee 00 05	inc $0500			inc 	IFT_XCursor 				; bump x cursor
.018043	ad 00 05	lda $0500			lda 	IFT_XCursor 				; reached RHS ?
.018046	c9 40		cmp #$40			cmp 	#IF_Width
.018048	d0 03		bne $01804d			bne 	_IFT_PCNotEOL
.01804a	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; if so do new line.
.01804d					_IFT_PCNotEOL:
.01804d	68		pla				pla
.01804e	60		rts				rts
.01804f					IFT_Tab:
.01804f	a9 20		lda #$20			lda 	#" " 						; space
.018051	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018054	ad 00 05	lda $0500			lda 	IFT_XCursor 				; until x % 8 == 0
.018057	29 07		and #$07			and 	#7
.018059	d0 f4		bne $01804f			bne 	IFT_Tab
.01805b	60		rts				rts
.01805c					IFT_NewLine:
.01805c	48		pha				pha
.01805d	20 bc 81	jsr $0181bc			jsr 	IF_NewLine 					; new line on actual screen.
.018060	a9 00		lda #$00			lda 	#0 							; reset x position
.018062	8d 00 05	sta $0500			sta 	IFT_XCursor
.018065	ee 01 05	inc $0501			inc 	IFT_YCursor 				; move down.
.018068	ad 01 05	lda $0501			lda 	IFT_YCursor
.01806b	c9 20		cmp #$20			cmp 	#IF_Height 					; reached bottom.
.01806d	d0 03		bne $018072			bne 	_IFT_NL_NotEOS
.01806f	20 7f 80	jsr $01807f			jsr 	IFT_Scroll 					; scroll screen up.
.018072					_IFT_NL_NotEOS:
.018072	68		pla				pla
.018073	60		rts				rts
.018074					IFT_UpperCase:
.018074	c9 61		cmp #$61			cmp 	#"a"
.018076	90 06		bcc $01807e			bcc 	_IFT_UCExit
.018078	c9 7b		cmp #$7b			cmp 	#"z"+1
.01807a	b0 02		bcs $01807e			bcs 	_IFT_UCExit
.01807c	49 20		eor #$20			eor 	#$20
.01807e					_IFT_UCExit:
.01807e	60		rts				rts
.01807f					IFT_Scroll:
.01807f	48		pha				pha 								; save AXY
.018080	da		phx				phx
.018081	5a		phy				phy
.018082	a2 00		ldx #$00			ldx 	#0 							; start scrolling.
.018084					_IFT_SLoop:
.018084	20 a4 80	jsr $0180a4			jsr 	_IFT_ScrollLine 			; scroll line X+1 => X
.018087	e8		inx				inx
.018088	e0 1f		cpx #$1f			cpx 	#IF_Height-1				; do whole screen
.01808a	d0 f8		bne $018084			bne 	_IFT_SLoop
.01808c	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01808e	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018091	a2 40		ldx #$40			ldx 	#IF_Width 					; blank line
.018093					_IFT_SBlank:
.018093	a9 20		lda #$20			lda 	#32
.018095	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018098	ca		dex				dex
.018099	d0 f8		bne $018093			bne 	_IFT_SBlank
.01809b	a9 1f		lda #$1f			lda 	#IF_Height-1 				; move to X = 0,Y = A
.01809d	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180a0	7a		ply				ply
.0180a1	fa		plx				plx
.0180a2	68		pla				pla
.0180a3	60		rts				rts
.0180a4					_IFT_ScrollLine:
.0180a4	da		phx				phx
.0180a5	da		phx				phx
.0180a6	8a		txa				txa 								; copy line into buffer.
.0180a7	1a		inc a				inc 	a 							; next line down.
.0180a8	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180ab	a2 00		ldx #$00			ldx 	#0
.0180ad					_IFTScrollCopy1:
.0180ad	20 cc 81	jsr $0181cc			jsr 	IF_Read
.0180b0	9d 02 05	sta $0502,x			sta 	IFT_Buffer,x
.0180b3	e8		inx				inx
.0180b4	e0 40		cpx #$40			cpx 	#IF_Width
.0180b6	d0 f5		bne $0180ad			bne 	_IFTScrollCopy1
.0180b8	68		pla				pla
.0180b9	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.0180bc	a2 00		ldx #$00			ldx 	#0
.0180be					_IFTScrollCopy2:
.0180be	bd 02 05	lda $0502,x			lda 	IFT_Buffer,x
.0180c1	20 d5 81	jsr $0181d5			jsr 	IF_Write
.0180c4	e8		inx				inx
.0180c5	e0 40		cpx #$40			cpx 	#IF_Width
.0180c7	d0 f5		bne $0180be			bne 	_IFTScrollCopy2
.0180c9	fa		plx				plx
.0180ca	60		rts				rts
.0180cb					IFT_SetYPos:
.0180cb	48		pha				pha
.0180cc	da		phx				phx
.0180cd	aa		tax				tax
.0180ce	20 1b 80	jsr $01801b			jsr 	IFT_HomeCursor
.0180d1	e0 00		cpx #$00			cpx 	#0
.0180d3	f0 09		beq $0180de			beq 	_IFT_MOAExit
.0180d5					_IFT_MOALoop:
.0180d5	20 bc 81	jsr $0181bc			jsr 	IF_NewLine
.0180d8	ee 01 05	inc $0501			inc 	IFT_YCursor
.0180db	ca		dex				dex
.0180dc	d0 f7		bne $0180d5			bne		_IFT_MOALoop
.0180de					_IFT_MOAExit:
.0180de	fa		plx				plx
.0180df	68		pla				pla
.0180e0	60		rts				rts
.0180e1					IFT_GetKeyCursor:
.0180e1	20 e9 80	jsr $0180e9			jsr 	_IFT_FlipCursor 			; reverse current
.0180e4					_IFT_GKCWait:
.0180e4	20 e6 81	jsr $0181e6			jsr 	IF_GetKey 					; get key
.0180e7	f0 fb		beq $0180e4			beq 	_IFT_GKCWait
.0180e9					_IFT_FlipCursor:
.0180e9	48		pha				pha 								; save
.0180ea	20 cc 81	jsr $0181cc			jsr 	IF_Read 					; read
.0180ed	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f0	49 80		eor #$80			eor 	#$80 						; reverse
.0180f2	20 d5 81	jsr $0181d5			jsr 	IF_Write 					; write
.0180f5	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.0180f8	68		pla				pla
.0180f9	60		rts				rts
.0180fa					IFT_ReadLine:
.0180fa	48		pha				pha
.0180fb					_IFT_RLLoop:
.0180fb	20 e1 80	jsr $0180e1			jsr 	IFT_GetKeyCursor 			; get keystroke
.0180fe	c9 0d		cmp #$0d			cmp 	#13							; return
.018100	f0 7d		beq $01817f			beq 	_IFT_RLExit
.018102	c9 20		cmp #$20			cmp 	#32 						; control character
.018104	90 05		bcc $01810b			bcc 	_IFT_Control
.018106	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018109	80 f0		bra $0180fb			bra 	_IFT_RLLoop
.01810b					_IFT_Control:
.01810b	c9 01		cmp #$01			cmp 	#"A"-64
.01810d	f0 26		beq $018135			beq 	_IFT_Left
.01810f	c9 04		cmp #$04			cmp 	#"D"-64
.018111	f0 2e		beq $018141			beq 	_IFT_Right
.018113	c9 17		cmp #$17			cmp 	#"W"-64
.018115	f0 36		beq $01814d			beq 	_IFT_Up
.018117	c9 13		cmp #$13			cmp 	#"S"-64
.018119	f0 3e		beq $018159			beq 	_IFT_Down
.01811b	c9 08		cmp #$08			cmp 	#"H"-64
.01811d	f0 09		beq $018128			beq 	_IFT_Backspace
.01811f	c9 1a		cmp #$1a			cmp 	#"Z"-64
.018121	d0 d8		bne $0180fb			bne 	_IFT_RLLoop
.018123	20 00 80	jsr $018000			jsr 	IFT_ClearScreen				; clear CTL-Z
.018126	80 d3		bra $0180fb			bra 	_IFT_RLLoop
.018128					_IFT_Backspace:
.018128	ad 00 05	lda $0500			lda 	IFT_XCursor 				; check not start of line.
.01812b	f0 ce		beq $0180fb			beq 	_IFT_RLLoop
.01812d	20 de 81	jsr $0181de			jsr 	IF_LeftOne
.018130	a9 20		lda #$20			lda 	#" "						; overwrite with space, drop through to left
.018132	20 d5 81	jsr $0181d5			jsr 	IF_Write
.018135					_IFT_Left:
.018135	ce 00 05	dec $0500			dec 	IFT_XCursor 				; left CTL-W
.018138	10 29		bpl $018163			bpl 	_IFT_Reposition
.01813a	a9 3f		lda #$3f			lda 	#IF_Width-1
.01813c					_IFT_SetX:
.01813c	8d 00 05	sta $0500			sta 	IFT_XCursor
.01813f	80 22		bra $018163			bra 	_IFT_Reposition
.018141					_IFT_Right:
.018141	ee 00 05	inc $0500			inc 	IFT_XCursor
.018144	ad 00 05	lda $0500			lda 	IFT_XCursor
.018147	49 40		eor #$40			eor 	#IF_Width
.018149	f0 f1		beq $01813c			beq 	_IFT_SetX
.01814b	80 16		bra $018163			bra 	_IFT_Reposition
.01814d					_IFT_Up:
.01814d	ce 01 05	dec $0501			dec 	IFT_YCursor
.018150	10 11		bpl $018163			bpl 	_IFT_Reposition
.018152	a9 1f		lda #$1f			lda 	#IF_Height-1
.018154					_IFT_SetY:
.018154	8d 01 05	sta $0501			sta 	IFT_YCursor
.018157	80 0a		bra $018163			bra 	_IFT_Reposition
.018159					_IFT_Down:
.018159	ee 01 05	inc $0501			inc 	IFT_YCursor
.01815c	ad 01 05	lda $0501			lda 	IFT_YCursor
.01815f	49 20		eor #$20			eor 	#IF_Height
.018161	f0 f1		beq $018154			beq 	_IFT_SetY
.018163					_IFT_Reposition:
.018163	ad 00 05	lda $0500			lda 	IFT_XCursor 				; put cursor at xCursor,yCursor
.018166	48		pha				pha
.018167	ad 01 05	lda $0501			lda 	IFT_YCursor
.01816a	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.01816d	68		pla				pla
.01816e	aa		tax				tax
.01816f	e0 00		cpx #$00			cpx 	#0
.018171	f0 88		beq $0180fb			beq 	_IFT_RLLoop
.018173					_IFT_MoveRight:
.018173	20 cc 81	jsr $0181cc			jsr 	IF_Read
.018176	ee 00 05	inc $0500			inc 	IFT_XCursor
.018179	ca		dex				dex
.01817a	d0 f7		bne $018173			bne 	_IFT_MoveRight
.01817c	4c fb 80	jmp $0180fb			jmp 	_IFT_RLLoop
.01817f					_IFT_RLExit:
.01817f	ad 01 05	lda $0501			lda 	IFT_YCursor 				; go to start of line.
.018182	20 cb 80	jsr $0180cb			jsr 	IFT_SetYPos
.018185	a2 00		ldx #$00			ldx 	#0 							; read text into line.
.018187					_IFT_RLRead:
.018187	20 cc 81	jsr $0181cc			jsr 	IF_Read
.01818a	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.01818d	e8		inx				inx
.01818e	e0 40		cpx #$40			cpx 	#IF_Width
.018190	d0 f5		bne $018187			bne 	_IFT_RLRead
.018192					_IFT_RL_Trim:
.018192	ca		dex				dex 	 							; previous char
.018193	30 07		bmi $01819c			bmi 	_IFT_Found 					; gone too far
.018195	bd 66 05	lda $0566,x			lda 	IFT_LineBuffer,x			; go back if space
.018198	c9 20		cmp #$20			cmp 	#" "
.01819a	f0 f6		beq $018192			beq 	_IFT_RL_Trim
.01819c					_IFT_Found:
.01819c	e8		inx				inx 								; forward to non-space
.01819d	a9 00		lda #$00			lda 	#0							; make it ASCIIZ
.01819f	9d 66 05	sta $0566,x			sta 	IFT_LineBuffer,x
.0181a2	68		pla				pla
.0181a3	a2 66		ldx #$66			ldx 	#IFT_LineBuffer & $FF 		; put address in YX
.0181a5	a0 05		ldy #$05			ldy 	#IFT_LineBuffer >> 8
.0181a7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/interface/drivers/interface_em65816.asm

=64					IF_Width 	= 64 							; characters across
=32					IF_Height 	= 32 							; characters down.
=4					IF_Pos 		= 4 							; current position, start of line.
=8					IF_XPos 	= 8 							; current position, horizontal.
=$f0000					IF_Screen = $F0000							; 2k screen RAM here
=$f8010					IF_PKeyboard = $F8010						; Keyboard port.
=$f8000					IF_PBreak = $F8000 							; Break key.
.0181a8					IF_Reset:
.0181a8	60		rts				rts
.0181a9					IF_Home:
.0181a9	48		pha				pha
.0181aa	64 08		stz $08				stz 	IF_XPos 					; zero X position
.0181ac	a9 00		lda #$00			lda 	#IF_Screen & $FF 			; set r/w pos.
.0181ae	85 04		sta $04				sta 	IF_Pos
.0181b0	a9 00		lda #$00			lda 	#(IF_Screen >> 8) & $FF
.0181b2	85 05		sta $05				sta 	IF_Pos+1
.0181b4	a9 0f		lda #$0f			lda 	#IF_Screen >> 16
.0181b6	85 06		sta $06				sta 	IF_Pos+2
.0181b8	64 07		stz $07				stz 	IF_Pos+3
.0181ba	68		pla				pla
.0181bb	60		rts				rts
.0181bc					IF_NewLine:
.0181bc	48		pha				pha
.0181bd	64 08		stz $08				stz 	IF_XPos						; back to start of line
.0181bf	18		clc				clc 								; down one line
.0181c0	a5 04		lda $04				lda 	IF_Pos
.0181c2	69 40		adc #$40			adc 	#64
.0181c4	85 04		sta $04				sta 	IF_Pos
.0181c6	90 02		bcc $0181ca			bcc 	_IF_NoCarry 				; carry through.
.0181c8	e6 05		inc $05				inc 	IF_Pos+1
.0181ca					_IF_NoCarry:
.0181ca	68		pla				pla
.0181cb	60		rts				rts
.0181cc					IF_Read:
.0181cc	5a		phy				phy 								; save current Y
.0181cd	a4 08		ldy $08				ldy 	IF_XPos 					; read character at current position
.0181cf	b7 04		lda [$04],y			lda 	[IF_Pos],y
.0181d1	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181d3	7a		ply				ply									; restore Y
.0181d4	60		rts				rts
.0181d5					IF_Write:
.0181d5	5a		phy				phy 								; save current Y
.0181d6	a4 08		ldy $08				ldy 	IF_XPos 					; write character at current position
.0181d8	97 04		sta [$04],y			sta 	[IF_Pos],y
.0181da	e6 08		inc $08				inc 	IF_XPos 					; step right.
.0181dc	7a		ply				ply									; restore Y
.0181dd	60		rts				rts
.0181de					IF_LeftOne:
.0181de	c6 08		dec $08				dec 	IF_XPos
.0181e0	60		rts				rts
.0181e1					IF_CheckBreak:
.0181e1	af 00 80 0f	lda $0f8000			lda 	IF_PBreak					; non-zero if Ctrl+C pressed.
.0181e5	60		rts				rts
.0181e6					IF_GetKey:
.0181e6	af 10 80 0f	lda $0f8010			lda 	IF_PKeyboard				; read keyboard
.0181ea	f0 08		beq $0181f4			beq		_IFGK_NoKey 				; skip if zero,no key pressed
.0181ec	48		pha				pha 								; key pressed, clear queue.
.0181ed	a9 00		lda #$00			lda 	#0
.0181ef	8f 10 80 0f	sta $0f8010			sta 	IF_PKeyboard
.0181f3	68		pla				pla
.0181f4					_IFGK_NoKey:
.0181f4	09 00		ora #$00			ora 	#0							; set Z flag appropriately.
.0181f6	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/utility/tim.asm

.0181f7					TIM_Error:
.0181f7	20 29 80	jsr $018029			jsr 	IFT_UpLine 					; go up one line.
.0181fa	a9 3f		lda #$3f			lda 	#"?"						; ? prompt
.0181fc	80 02		bra $018200			bra 	TIM_ShowPrompt
.0181fe					TIM_NewCommand:
.0181fe	a9 2e		lda #$2e			lda 	#"."						; dot prompt
.018200					TIM_ShowPrompt:
.018200	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter			; display . or ? prompt.
.018203	20 fa 80	jsr $0180fa			jsr 	IFT_ReadLine	 			; get character, go to next line
.018206	20 5c 80	jsr $01805c			jsr 	IFT_NewLine					; go to next line.
.018209	86 10		stx $10				stx 	zTemp1 						; save line read address
.01820b	84 11		sty $11				sty 	zTemp1+1
.01820d	a0 00		ldy #$00			ldy 	#0 							; get first character after the prompt.
.01820f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018211	c9 3f		cmp #$3f			cmp 	#"?"
.018213	f0 04		beq $018219			beq 	TIM_SkipFirst
.018215	c9 2e		cmp #$2e			cmp 	#"."						; if . skip it
.018217	d0 01		bne $01821a			bne 	TIM_NotDot
.018219					TIM_SkipFirst:
.018219	c8		iny				iny
.01821a					TIM_NotDot:
.01821a	b1 10		lda ($10),y			lda 	(zTemp1),y 					; get character
.01821c	c9 52		cmp #$52			cmp 	#"R"						; show registers
.01821e	f0 6b		beq $01828b			beq 	TIM_ShowRegisters
.018220	c9 4d		cmp #$4d			cmp 	#"M" 						; show memory
.018222	f0 12		beq $018236			beq 	TIM_ShowMemory
.018224	c9 47		cmp #$47			cmp 	#"G"						; execute
.018226	f0 49		beq $018271			beq 	TIM_Execute
.018228	c9 3a		cmp #$3a			cmp 	#":"						; load memory
.01822a	f0 07		beq $018233			beq 	TIM_GoLoadMemory
.01822c	c9 3b		cmp #$3b			cmp 	#";" 						; load registers
.01822e	d0 c7		bne $0181f7			bne 	TIM_Error
.018230	4c af 83	jmp $0183af			jmp 	TIM_UpdateRegisters
.018233					TIM_GoLoadMemory:
.018233	4c df 83	jmp $0183df			jmp 	TIM_LoadMemory
.018236					TIM_ShowMemory:
.018236	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018239	b0 bc		bcs $0181f7			bcs 	TIM_Error
.01823b	a5 14		lda $14				lda 	zTemp3 						; copy zTemp3 => zTemp2
.01823d	85 12		sta $12				sta 	zTemp2
.01823f	a5 15		lda $15				lda 	zTemp3+1
.018241	85 13		sta $13				sta 	zTemp2+1
.018243	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get a hex value out => zTemp3
.018246	90 08		bcc $018250			bcc 	_TIMSM_Start 				; okay, display zTemp2 ... zTemp3 as value ok
.018248	a5 12		lda $12				lda 	zTemp2 						; single value set zTemp2 => zTemp3 so just one line.
.01824a	85 14		sta $14				sta 	zTemp3
.01824c	a5 13		lda $13				lda 	zTemp2+1
.01824e	85 15		sta $15				sta 	zTemp3+1
.018250					_TIMSM_Start:
.018250	20 03 83	jsr $018303			jsr 	TIM_WriteLine 				; write one line of hex out
.018253	a5 12		lda $12				lda 	zTemp2 						; bump ZTemp2 by 16
.018255	18		clc				clc
.018256	69 10		adc #$10			adc 	#16
.018258	85 12		sta $12				sta 	zTemp2
.01825a	90 02		bcc $01825e			bcc 	_TIMSM_NoCarry
.01825c	e6 13		inc $13				inc 	zTemp2+1
.01825e					_TIMSM_NoCarry:
.01825e	20 e1 81	jsr $0181e1			jsr 	IF_CheckBreak 				; check CTL+C
.018261	d0 0b		bne $01826e			bne 	_TIMSM_Ends 				; if pressed break out.
.018263	38		sec				sec 								; check past the end address in zTemp3
.018264	a5 14		lda $14				lda 	zTemp3
.018266	e5 12		sbc $12				sbc 	zTemp2
.018268	a5 15		lda $15				lda 	zTemp3+1
.01826a	e5 13		sbc $13				sbc 	zTemp2+1
.01826c	10 e2		bpl $018250			bpl 	_TIMSM_Start
.01826e					_TIMSM_Ends:
.01826e	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.018271					TIM_Execute:
.018271	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; get the execute address
.018274	b0 81		bcs $0181f7			bcs 	TIM_Error 					; not legitimate
.018276	ae c2 03	ldx $03c2			ldx 	TIM_SP 						; set up SP
.018279	9a		txs				txs
.01827a	ad bd 03	lda $03bd			lda 	TIM_SR 						; Status for PLP
.01827d	48		pha				pha
.01827e	ad be 03	lda $03be			lda 	TIM_A 						; restore AXYZ
.018281	ae bf 03	ldx $03bf			ldx 	TIM_X
.018284	ac c0 03	ldy $03c0			ldy 	TIM_Y
.018287	28		plp				plp 								; and PS Byte.
.018288	6c 14 00	jmp ($0014)			jmp 	(zTemp3)					; go execute
.01828b					TIM_Start:
.01828b					TIM_ShowRegisters:
.01828b	ad fe ff	lda $fffe			lda 	$FFFE 						; copy IRQx which is in ROM.
.01828e	8d bc 03	sta $03bc			sta 	TIM_IRQ+1
.018291	ad ff ff	lda $ffff			lda 	$FFFF
.018294	8d bb 03	sta $03bb			sta 	TIM_IRQ
.018297	a2 00		ldx #$00			ldx 	#0 							; display register prompt
.018299					_TIMSR_Text:
.018299	bf ca 82 01	lda $0182ca,x			lda 	_TIMSR_Label,x
.01829d	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182a0	e8		inx				inx
.0182a1	e0 20		cpx #$20			cpx 	#_TIMSR_LabelEnd-_TIMSR_Label
.0182a3	d0 f4		bne $018299			bne 	_TIMSR_Text
.0182a5	a2 ff		ldx #$ff			ldx 	#-1							; output Register Line.
.0182a7					_TIMSR_Skip:
.0182a7	e8		inx				inx
.0182a8					_TIMSR_LoopSpace:
.0182a8	e0 04		cpx #$04			cpx 	#4 							; this checks if we need a space to
.0182aa	b0 04		bcs $0182b0			bcs 	_TIMSR_Space 				; batten the 16 bit registers together.
.0182ac	8a		txa				txa
.0182ad	4a		lsr a				lsr 	a
.0182ae	b0 05		bcs $0182b5			bcs 	_TIMSR_NoSpace
.0182b0					_TIMSR_Space:
.0182b0	a9 20		lda #$20			lda 	#" "
.0182b2	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.0182b5					_TIMSR_NoSpace:
.0182b5	bd b9 03	lda $03b9,x			lda 	TIM_PC,x 					; output hex value.
.0182b8	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.0182bb	e8		inx				inx
.0182bc	e0 08		cpx #$08			cpx 	#TIM_Z-TIM_PC
.0182be	f0 e7		beq $0182a7			beq 	_TIMSR_Skip
.0182c0	e0 0a		cpx #$0a			cpx 	#TIM_SP-TIM_PC+1
.0182c2	d0 e4		bne $0182a8			bne 	_TimSR_LoopSpace
.0182c4	20 5c 80	jsr $01805c			jsr 	IFT_NewLine 				; new line
.0182c7	4c fe 81	jmp $0181fe			jmp	 	TIM_NewCommand 				; new command.
.0182ca					_TIMSR_Label:
>0182ca	20 20 20 20 50 43 20 20				.text 	"    PC   IRQ  SR AC XR YR"
>0182d2	20 49 52 51 20 20 53 52 20 41 43 20 58 52 20 59
>0182e2	52
>0182e3	20 53 50 0d 2e 3b 20				.text 	" SP",13,".; "
.0182ea					_TIMSR_LabelEnd:
.0182ea					TIM_WriteHex:
.0182ea	48		pha				pha 								; save A
.0182eb	4a		lsr a				lsr 	a 							; shift MSB->LSB
.0182ec	4a		lsr a				lsr 	a
.0182ed	4a		lsr a				lsr 	a
.0182ee	4a		lsr a				lsr 	a
.0182ef	20 f3 82	jsr $0182f3			jsr 	_TIMWH_Nibble 				; print MSB
.0182f2	68		pla				pla 								; restore and print LSB
.0182f3					_TIMWH_Nibble:
.0182f3	48		pha				pha
.0182f4	29 0f		and #$0f			and 	#15 						; mask out
.0182f6	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.0182f8	90 02		bcc $0182fc			bcc 	_TIMWHNoLetter
.0182fa	69 06		adc #$06			adc 	#6
.0182fc					_TIMWHNoLetter:
.0182fc	69 30		adc #$30			adc 	#48
.0182fe	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter 			; print it out.
.018301	68		pla				pla
.018302	60		rts				rts
.018303					TIM_WriteLine:
.018303	a9 2e		lda #$2e			lda 	#"." 						; prompt
.018305	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.018308	a9 3a		lda #$3a			lda 	#":" 						; input line command so we can edit it
.01830a	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01830d	a5 13		lda $13				lda 	zTemp2+1 					; write address
.01830f	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018312	a5 12		lda $12				lda 	zTemp2
.018314	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018317	a0 00		ldy #$00			ldy 	#0							; write 16 bytes of data from (zTemp2)
.018319					_TIMWL_Loop:
.018319	a9 20		lda #$20			lda 	#" "
.01831b	20 35 80	jsr $018035			jsr 	IFT_PrintCharacter
.01831e	b1 12		lda ($12),y			lda 	(zTemp2),y
.018320	20 ea 82	jsr $0182ea			jsr 	TIM_WriteHex
.018323	c8		iny				iny
.018324	c0 10		cpy #$10			cpy 	#16
.018326	d0 f1		bne $018319			bne 	_TIMWL_Loop
.018328	4c 5c 80	jmp $01805c			jmp 	IFT_NewLine 				; new line and exit
.01832b					TIM_GetHex:
.01832b	c8		iny				iny
.01832c	b1 10		lda ($10),y			lda 	(zTemp1),y 					; skip over spaces.
.01832e	c9 20		cmp #$20			cmp 	#32
.018330	f0 f9		beq $01832b			beq 	TIM_GetHex
.018332	c9 2c		cmp #$2c			cmp 	#"," 						; skip over commas
.018334	f0 f5		beq $01832b			beq 	TIM_GetHex
.018336	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; extract one hex character.
.018339	b0 23		bcs $01835e			bcs 	_TIMGH_Exit					; if first bad then exit now.
.01833b	a9 00		lda #$00			lda 	#0 							; zero result
.01833d	85 14		sta $14				sta 	zTemp3
.01833f	85 15		sta $15				sta 	zTemp3+1
.018341					_TIM_GHLoop:
.018341	20 5f 83	jsr $01835f			jsr 	TIM_GetHexCharacter 		; get next character
.018344	b0 17		bcs $01835d			bcs 	_TIMGH_Okay 				; if bad, exit as we have one good one.
.018346	c8		iny				iny 								; skip over it.
.018347	06 14		asl $14				asl 	zTemp3 						; x zTemp3 by 16
.018349	26 15		rol $15				rol 	zTemp3+1
.01834b	06 14		asl $14				asl 	zTemp3 						; now x 2
.01834d	26 15		rol $15				rol 	zTemp3+1
.01834f	06 14		asl $14				asl 	zTemp3						; now x 4
.018351	26 15		rol $15				rol 	zTemp3+1
.018353	06 14		asl $14				asl 	zTemp3 						; now x 8
.018355	26 15		rol $15				rol 	zTemp3+1
.018357	05 14		ora $14				ora 	zTemp3 						; OR result in
.018359	85 14		sta $14				sta 	zTemp3
.01835b	80 e4		bra $018341			bra 	_TIM_GHLoop 				; loop round again.
.01835d					_TIMGH_Okay:
.01835d	18		clc				clc
.01835e					_TIMGH_Exit:
.01835e	60		rts				rts
.01835f					TIM_GetHexCharacter:
.01835f	b1 10		lda ($10),y			lda 	(zTemp1),y
.018361	38		sec				sec
.018362	e9 30		sbc #$30			sbc 	#"0" 						; < 0 exit with CS
.018364	90 0e		bcc $018374			bcc 	_TIM_GHCFail
.018366	c9 0a		cmp #$0a			cmp 	#10 						; 0-9 exit with CC
.018368	90 0b		bcc $018375			bcc 	_TIM_GHCExit
.01836a	c9 11		cmp #$11			cmp 	#65-48						; < A
.01836c	90 06		bcc $018374			bcc		_TIM_GHCFail
.01836e	e9 07		sbc #$07			sbc 	#7 							; adjust for gap from 9-A
.018370	c9 10		cmp #$10			cmp 	#16 						; result in range okay.
.018372	90 01		bcc $018375			bcc		_TIM_GHCExit
.018374					_TIM_GHCFail:
.018374	38		sec				sec
.018375					_TIM_GHCExit:
.018375	60		rts				rts
.018376					TIM_BreakVector:
.018376	da		phx				phx									; save X/A on stack
.018377	48		pha				pha
.018378	ba		tsx				tsx 								; X points to S
.018379	bd 03 01	lda $0103,x			lda 	$0103,x 					; PSW saved on stack, this retrieves it
.01837c	29 10		and #$10			and 	#$10 						; check stacked B Flag - only set on the stacked reg
.01837e	d0 03		bne $018383			bne 	_TIMBreak					; if set, it's BRK
.018380	68		pla				pla 								; abandon routine.
.018381	fa		plx				plx
.018382	40		rti				rti
.018383					_TIMBreak:
.018383	68		pla				pla 								; save A X Y and maybe Z
.018384	8d be 03	sta $03be			sta 	TIM_A
.018387	fa		plx				plx
.018388	8e bf 03	stx $03bf			stx 	TIM_X
.01838b	8c c0 03	sty $03c0			sty 	TIM_Y
.01838e	68		pla				pla 								; get Status Register
.01838f	8d bd 03	sta $03bd			sta 	TIM_SR
.018392	68		pla				pla
.018393	8d ba 03	sta $03ba			sta 	TIM_PC+1 					; save calling address
.018396	68		pla				pla
.018397	8d b9 03	sta $03b9			sta 	TIM_PC 						; high byte
.01839a	ad ba 03	lda $03ba			lda 	TIM_PC+1 					; dec PC to point right.
.01839d	d0 03		bne $0183a2			bne 	_TIMDecrement 				; brk bumps it.
.01839f	ce b9 03	dec $03b9			dec 	TIM_PC
.0183a2					_TIMDecrement:
.0183a2	ce ba 03	dec $03ba			dec 	TIM_PC+1
.0183a5	ba		tsx				tsx 								; and copy SP
.0183a6	8e c2 03	stx $03c2			stx 	TIM_SP
.0183a9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset SP
.0183ab	9a		txs				txs
.0183ac	4c 8b 82	jmp $01828b			jmp 	TIM_Start 					; and start up TIM monitor.
.0183af					TIM_UpdateRegisters:
.0183af	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; PC
.0183b2	b0 28		bcs $0183dc			bcs 	_TIMURFail
.0183b4	a5 14		lda $14				lda 	zTemp3
.0183b6	8d ba 03	sta $03ba			sta 	Tim_PC+1
.0183b9	a5 15		lda $15				lda 	zTemp3+1
.0183bb	8d b9 03	sta $03b9			sta 	Tim_PC
.0183be	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; ignore IRQ
.0183c1	b0 19		bcs $0183dc			bcs 	_TIMURFail
.0183c3	a2 00		ldx #$00			ldx 	#0
.0183c5					_TIM_URLoop:
.0183c5	e0 04		cpx #$04			cpx 	#Tim_Z-Tim_SR
.0183c7	d0 01		bne $0183ca			bne 	_TIM_1
.0183c9	e8		inx				inx
.0183ca					_TIM_1:
.0183ca	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; registers
.0183cd	b0 0d		bcs $0183dc			bcs 	_TIMURFail
.0183cf	a5 14		lda $14				lda 	zTemp3
.0183d1	9d bd 03	sta $03bd,x			sta 	Tim_SR,x
.0183d4	e8		inx				inx
.0183d5	e0 06		cpx #$06			cpx 	#Tim_SP-Tim_SR+1
.0183d7	d0 ec		bne $0183c5			bne 	_TIM_URLoop
.0183d9	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand
.0183dc					_TIMURFail:
.0183dc	4c f7 81	jmp $0181f7			jmp 	TIM_Error
.0183df					TIM_LoadMemory:
.0183df	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; target address => zTemp2
.0183e2	a5 14		lda $14				lda 	zTemp3
.0183e4	85 12		sta $12				sta 	zTemp2
.0183e6	a5 15		lda $15				lda 	zTemp3+1
.0183e8	85 13		sta $13				sta 	zTemp2+1
.0183ea					_TIM_LMLoop:
.0183ea	20 2b 83	jsr $01832b			jsr 	TIM_GetHex 					; next byte ?
.0183ed	b0 0e		bcs $0183fd			bcs 	_TIMLMDone 					; no more
.0183ef	a2 00		ldx #$00			ldx 	#0							; write out.
.0183f1	a5 14		lda $14				lda 	zTemp3
.0183f3	81 12		sta ($12,x)			sta 	(zTemp2,x)
.0183f5	e6 12		inc $12				inc 	zTemp2 						; bump address
.0183f7	d0 f1		bne $0183ea			bne 	_TIM_LMLoop
.0183f9	e6 13		inc $13				inc 	zTemp2+1
.0183fb	80 ed		bra $0183ea			bra 	_TIM_LMLoop
.0183fd					_TIMLMDone:
.0183fd	4c fe 81	jmp $0181fe			jmp 	TIM_NewCommand

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/skip.asm

.018400					StructureSearchSingle:
.018400	a2 00		ldx #$00			ldx 	#0
.018402					StructureSearchDouble:
.018402	85 10		sta $10				sta 	zTemp1 						; save the target on zTemp1,zTemp1+1
.018404	86 11		stx $11				stx 	zTemp1+1
.018406	a9 00		lda #$00			lda 	#0 							; set the structure depth to zero (zTemp2)
.018408	85 12		sta $12				sta 	zTemp2
.01840a	80 18		bra $018424			bra 	_SSWLoop 					; jump in, start scanning from here.
.01840c					_SSWNextLine:
.01840c	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01840e	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018410	18		clc				clc
.018411	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018413	85 16		sta $16				sta 	zCodePtr
.018415	90 02		bcc $018419			bcc 	_SNLNoCarry
.018417	e6 17		inc $17				inc 	zCodePtr+1
.018419					_SNLNoCarry:
.018419	a0 00		ldy #$00			ldy 	#0
.01841b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01841d	c9 00		cmp #$00			cmp 	#0					 		; if zero, fail.
.01841f	f0 54		beq $018475			beq 	_SSWFail
.018421	c8		iny				iny
.018422	c8		iny				iny
.018423					_SSWNextSimple:
.018423	c8		iny				iny
.018424					_SSWLoop:
.018424	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018426	c9 00		cmp #$00			cmp 	#0 							; end of line ?
.018428	f0 e2		beq $01840c			beq 	_SSWNextLine 				; if so, then next line
.01842a	10 f7		bpl $018423			bpl 	_SSWNextSimple 				; needs to be a token, just skip char/number.
.01842c	a6 12		ldx $12				ldx 	zTemp2 						; check structure count
.01842e	d0 08		bne $018438			bne 	_SSWCheckUpDown 			; if it's non zero, then a match doesn't work.
.018430	c5 10		cmp $10				cmp 	zTemp1 						; found the right keyword, either choice.
.018432	f0 2d		beq $018461			beq 	_SSWFound 					; so exit.
.018434	c5 11		cmp $11				cmp 	zTemp1+1
.018436	f0 29		beq $018461			beq 	_SSWFound
.018438					_SSWCheckUpDown:
.018438	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus 			; if < keyword +
.01843a	90 10		bcc $01844c			bcc 	_SSWNext
.01843c	c9 93		cmp #$93			cmp 	#firstKeywordMinus 			; if < keyword - then as keyword +
.01843e	90 08		bcc $018448			bcc 	_SSWPlus
.018440	c9 98		cmp #$98			cmp 	#firstUnaryFunction			; if < first unary down as keyword -
.018442	b0 08		bcs $01844c			bcs 	_SSWNext
.018444	c6 12		dec $12				dec 	zTemp2 						; reduce structure count.
.018446	c6 12		dec $12				dec 	zTemp2
.018448					_SSWPlus:
.018448	e6 12		inc $12				inc 	zTemp2
.01844a	30 16		bmi $018462			bmi 	_SSWUnder					; error if driven -ve
.01844c					_SSWNext:
.01844c	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.01844e	c8		iny				iny 								; skip
.01844f	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018451	90 0c		bcc $01845f			bcc 	_SEDone 					; so just skip over it.
.018453	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.018455	90 07		bcc $01845e			bcc 	_SEDouble
.018457	98		tya				tya 								; this is Y + 1
.018458	18		clc				clc
.018459	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.01845b	a8		tay				tay 								; back in Y.
.01845c	88		dey				dey 								; fix up, one for the +1, one for the iny
.01845d	88		dey				dey
.01845e					_SEDouble:
.01845e	c8		iny				iny
.01845f					_SEDone:
.01845f	80 c3		bra $018424			bra 	_SSWLoop
.018461					_SSWFound:
.018461	60		rts				rts
.018462					_SSWUnder:
.018462	20 57 85	jsr $018557			jsr ERR_Handler
>018465	53 74 72 75 63 74 75 72			.text "Structure order",0
>01846d	65 20 6f 72 64 65 72 00
.018475					_SSWFail:
.018475	20 57 85	jsr $018557			jsr ERR_Handler
>018478	43 61 6e 27 74 20 66 69			.text "Can't find structure",0
>018480	6e 64 20 73 74 72 75 63 74 75 72 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/stack.asm

.01848d					StackReset:
.01848d	48		pha				pha
.01848e	5a		phy				phy
.01848f	a9 00		lda #$00			lda 	#(BasicStack & $FF) 		; reset pointer
.018491	85 26		sta $26				sta 	zBasicSP
.018493	a9 04		lda #$04			lda 	#(BasicStack >> 8)
.018495	85 27		sta $27				sta 	zBasicSP+1
.018497	a0 00		ldy #$00			ldy 	#0 							; reset stack top to $00 which cannot
.018499	98		tya				tya 								; be a legal token.
.01849a	91 26		sta ($26),y			sta 	(zBasicSP),y
.01849c	7a		ply				ply
.01849d	68		pla				pla
.01849e	60		rts				rts
.01849f					StackPushFrame:
.01849f	48		pha				pha
.0184a0	5a		phy				phy
.0184a1	1a		inc a				inc 	a 							; one extra byte in frame, for the marker.
.0184a2	48		pha				pha 								; save it.
.0184a3	29 0f		and #$0f			and 	#$0F 						; lower 4 bits
.0184a5	18		clc				clc 								; add to Basic Stack
.0184a6	65 26		adc $26				adc 	zBasicSP
.0184a8	85 26		sta $26				sta 	zBasicSP
.0184aa	90 02		bcc $0184ae			bcc 	_SPFNoBump
.0184ac	e6 27		inc $27				inc 	zBasicSP+1
.0184ae					_SPFNoBump:
.0184ae	a0 00		ldy #$00			ldy 	#0
.0184b0	68		pla				pla
.0184b1	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184b3	7a		ply				ply
.0184b4	68		pla				pla
.0184b5	60		rts				rts
.0184b6					StackPopFrame:
.0184b6	48		pha				pha
.0184b7	5a		phy				phy
.0184b8	a0 00		ldy #$00			ldy 	#0 							; compare with top of stack using EOR
.0184ba	51 26		eor ($26),y			eor 	(zBasicSP),y
.0184bc	29 f0		and #$f0			and 	#$F0 						; top 4 bits zero, match
.0184be	d0 12		bne $0184d2			bne 	_SPFError 					; mixed structures
.0184c0	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; get size from byte
.0184c2	29 0f		and #$0f			and 	#$0F
.0184c4	49 ff		eor #$ff			eor 	#$FF						; 2's complement
.0184c6	38		sec				sec
.0184c7	65 26		adc $26				adc 	zBasicSP
.0184c9	85 26		sta $26				sta 	zBasicSP
.0184cb	b0 02		bcs $0184cf			bcs 	_SPFNoBump
.0184cd	c6 27		dec $27				dec 	zBasicSP+1
.0184cf					_SPFNoBump:
.0184cf	7a		ply				ply
.0184d0	68		pla				pla
.0184d1	60		rts				rts
.0184d2					_SPFError:
.0184d2	20 57 85	jsr $018557			jsr ERR_Handler
>0184d5	4d 69 78 65 64 20 53 74			.text "Mixed Structures",0
>0184dd	72 75 63 74 75 72 65 73 00
.0184e6					StackSavePosition:
.0184e6	98		tya				tya
.0184e7	5a		phy				phy
.0184e8	a0 05		ldy #$05			ldy 	#5
.0184ea	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184ec	a0 01		ldy #$01			ldy 	#1
.0184ee	a5 16		lda $16				lda 	zCodePtr+0 					; 4 bytes, could reduce this for 65816/6502
.0184f0	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f2	c8		iny				iny
.0184f3	a5 17		lda $17				lda 	zCodePtr+1
.0184f5	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184f7	c8		iny				iny
.0184f8	a5 18		lda $18				lda 	zCodePtr+2
.0184fa	91 26		sta ($26),y			sta 	(zBasicSP),y
.0184fc	c8		iny				iny
.0184fd	a5 19		lda $19				lda 	zCodePtr+3
.0184ff	91 26		sta ($26),y			sta 	(zBasicSP),y
.018501	7a		ply				ply
.018502	60		rts				rts
.018503					StackRestorePosition:
.018503	5a		phy				phy
.018504	a0 01		ldy #$01			ldy 	#1 							; copy 4 bytes that are the pointer
.018506	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018508	85 16		sta $16				sta 	zCodePtr+0
.01850a	c8		iny				iny
.01850b	b1 26		lda ($26),y			lda 	(zBasicSP),y
.01850d	85 17		sta $17				sta 	zCodePtr+1
.01850f	c8		iny				iny
.018510	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018512	85 18		sta $18				sta 	zCodePtr+2
.018514	c8		iny				iny
.018515	b1 26		lda ($26),y			lda 	(zBasicSP),y
.018517	85 19		sta $19				sta 	zCodePtr+3
.018519	c8		iny				iny
.01851a	b1 26		lda ($26),y			lda 	(zBasicSP),y 				; offset
.01851c	7a		ply				ply 								; restore Y
.01851d	a8		tay				tay
.01851e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/vectors.asm

.01851f					CharPrint:
.01851f	4c 35 80	jmp $018035			jmp 	IFT_PrintCharacter
.018522					CharGet:
.018522	4c e6 81	jmp $0181e6			jmp 	IF_GetKey
.018525					CheckBreak:
.018525	4c e1 81	jmp $0181e1			jmp 	IF_CheckBreak

;******  Return to file: _include.asm


;******  Processing file: modules/basic/common/errors.asm

.018528					SyntaxError:
.018528	20 57 85	jsr $018557			jsr 	ERR_Handler
>01852b	53 79 6e 74 61 78 20 45				.text 	"Syntax Error",0
>018533	72 72 6f 72 00
.018538					TypeError:
.018538	20 57 85	jsr $018557			jsr 	ERR_Handler
>01853b	57 72 6f 6e 67 20 74 79				.text 	"Wrong type",0
>018543	70 65 00
.018546					BadParamError:
.018546	20 57 85	jsr $018557			jsr 	ERR_Handler
>018549	42 61 64 20 50 61 72 61				.text 	"Bad Parameter",0
>018551	6d 65 74 65 72 00
.018557					ERR_Handler:
.018557	a0 00		ldy #$00			ldy 	#0
.018559	c8		iny				iny
.01855a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01855c	85 80		sta $80				sta 	XS_Mantissa
.01855e	c8		iny				iny
.01855f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018561	85 81		sta $81				sta 	XS_Mantissa+1
.018563	fa		plx				plx 								; address in XY
.018564	7a		ply				ply
.018565	e8		inx				inx 								; bump, because of RTS/JSR address -1
.018566	d0 01		bne $018569			bne 	_EHNoSkip
.018568	c8		iny				iny
.018569					_EHNoSkip:
.018569	20 88 85	jsr $018588			jsr 	PrintROMMessage 			; print message from ROM.
.01856c	a5 80		lda $80				lda 	XS_Mantissa					; line number = 0
.01856e	05 81		ora $81				ora 	XS_Mantissa+1
.018570	f0 0c		beq $01857e			beq 	_EHNoLine
.018572	a2 83		ldx #$83			ldx 	#_EHAt & $FF 				; print " at "
.018574	a0 85		ldy #$85			ldy 	#(_EHAt >> 8) & $FF
.018576	20 88 85	jsr $018588			jsr 	PrintROMMessage
.018579	a2 00		ldx #$00			ldx 	#0 							; Print line number
.01857b	20 9d 85	jsr $01859d			jsr 	Print16BitInteger
.01857e					_EHNoLine:
.01857e	80 fe		bra $01857e			bra 	_EHNoLine
.018580	4c 10 88	jmp $018810			jmp 	WarmStart
>018583	20 61 74 20 00			_EHAt:	.text 	" at ",0
.018588					PrintROMMessage:
.018588	86 1a		stx $1a				stx 	zLTemp1 					; save addres
.01858a	84 1b		sty $1b				sty 	zLTemp1+1
.01858c	4b		phk				phk
.01858d	68		pla				pla
.01858e	85 1c		sta $1c				sta 	ZLTemp1+2
.018590	a0 00		ldy #$00			ldy 	#0
.018592					_PRMLoop:
.018592	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018594	f0 06		beq $01859c			beq		_PRMExit
.018596	c8		iny				iny
.018597	20 1f 85	jsr $01851f			jsr 	CharPrint
.01859a	80 f6		bra $018592			bra 	_PRMLoop
.01859c					_PRMExit:
.01859c	60		rts				rts
.01859d					Print16BitInteger:
.01859d	a9 00		lda #$00			lda 	#0 							; make 32 bit
.01859f	85 82		sta $82				sta 	XS_Mantissa+2
.0185a1	85 83		sta $83				sta 	XS_Mantissa+3
.0185a3					Print32BitInteger:
.0185a3	a9 00		lda #$00			lda 	#0
.0185a5	8d 14 03	sta $0314			sta 	NumBufX 					; reset the conversion pointer
.0185a8	aa		tax				tax 								; convert bottom level.
.0185a9	20 da 9a	jsr $019ada			jsr 	INTToString 				; make string
.0185ac	a2 00		ldx #$00			ldx 	#0 							; print buffer
.0185ae	bd 15 03	lda $0315,x	_P1Loop:lda 	Num_Buffer,x
.0185b1	f0 06		beq $0185b9			beq 	_P1Exit
.0185b3	20 1f 85	jsr $01851f			jsr 	CharPrint
.0185b6	e8		inx				inx
.0185b7	80 f5		bra $0185ae			bra 	_P1Loop
.0185b9	8a		txa		_P1Exit:txa 								; return chars printed.
.0185ba	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/core.asm


;******  Processing file: modules/basic/../basic/header/header.src

=$93					firstKeywordMinus = $93
=$8f					firstKeywordPlus = $8f
=$98					firstUnaryFunction = $98
=$b6					lastUnaryFunction = $b6
.0185bb					VectorTable:
>0185bb	4e 8f					.word BinaryOp_And         & $FFFF ; $80 and
>0185bd	6a 8f					.word BinaryOp_Or          & $FFFF ; $81 or
>0185bf	86 8f					.word BinaryOp_Xor         & $FFFF ; $82 xor
>0185c1	86 8f					.word BinaryOp_Eor         & $FFFF ; $83 eor
>0185c3	bd 8f					.word Binary_Equal         & $FFFF ; $84 =
>0185c5	d7 8f					.word Binary_NotEqual      & $FFFF ; $85 <>
>0185c7	e0 8f					.word Binary_Less          & $FFFF ; $86 <
>0185c9	e9 8f					.word Binary_LessEqual     & $FFFF ; $87 <=
>0185cb	fb 8f					.word Binary_Greater       & $FFFF ; $88 >
>0185cd	f2 8f					.word Binary_GreaterEqual  & $FFFF ; $89 >=
>0185cf	80 90					.word BinaryOp_Add         & $FFFF ; $8a +
>0185d1	9c 90					.word BinaryOp_Subtract    & $FFFF ; $8b -
>0185d3	ad 90					.word BinaryOp_Multiply    & $FFFF ; $8c *
>0185d5	be 90					.word BinaryOp_Divide      & $FFFF ; $8d /
>0185d7	79 86					.word NotImplemented       & $FFFF ; $8e ^
>0185d9	b1 89					.word Command_IF           & $FFFF ; $8f if
>0185db	4a 8d					.word Command_WHILE        & $FFFF ; $90 while
>0185dd	72 8d					.word Command_REPEAT       & $FFFF ; $91 repeat
>0185df	79 86					.word NotImplemented       & $FFFF ; $92 for
>0185e1	79 86					.word NotImplemented       & $FFFF ; $93 then
>0185e3	0e 8a					.word Command_ENDIF        & $FFFF ; $94 endif
>0185e5	67 8d					.word Command_WEND         & $FFFF ; $95 wend
>0185e7	7b 8d					.word Command_UNTIL        & $FFFF ; $96 until
>0185e9	79 86					.word NotImplemented       & $FFFF ; $97 next
>0185eb	79 86					.word NotImplemented       & $FFFF ; $98 not
>0185ed	79 86					.word NotImplemented       & $FFFF ; $99 fn(
>0185ef	c3 91					.word Unary_Abs            & $FFFF ; $9a abs(
>0185f1	04 93					.word Unary_Asc            & $FFFF ; $9b asc(
>0185f3	c9 a1					.word Unary_Int            & $FFFF ; $9c int(
>0185f5	dd 91					.word Unary_Peek           & $FFFF ; $9d peek(
>0185f7	4a a1					.word Unary_Rnd            & $FFFF ; $9e rnd(
>0185f9	44 92					.word Unary_Usr            & $FFFF ; $9f usr(
>0185fb	43 93					.word Unary_Left           & $FFFF ; $a0 left$(
>0185fd	58 93					.word Unary_Right          & $FFFF ; $a1 right$(
>0185ff	2a 93					.word Unary_Mid            & $FFFF ; $a2 mid$(
>018601	a1 94					.word Unary_Spc            & $FFFF ; $a3 spc(
>018603	d2 92					.word Unary_Str            & $FFFF ; $a4 str$(
>018605	66 92					.word Unary_Val            & $FFFF ; $a5 val(
>018607	1b 93					.word Unary_Len            & $FFFF ; $a6 len(
>018609	d0 93					.word Unary_Hex            & $FFFF ; $a7 hex$(
>01860b	79 86					.word NotImplemented       & $FFFF ; $a8 sin(
>01860d	79 86					.word NotImplemented       & $FFFF ; $a9 cos(
>01860f	79 86					.word NotImplemented       & $FFFF ; $aa tan(
>018611	79 86					.word NotImplemented       & $FFFF ; $ab atn(
>018613	79 86					.word NotImplemented       & $FFFF ; $ac exp(
>018615	79 86					.word NotImplemented       & $FFFF ; $ad log(
>018617	79 86					.word NotImplemented       & $FFFF ; $ae sqr(
>018619	26 94					.word Unary_Dec            & $FFFF ; $af dec(
>01861b	e1 91					.word Unary_Deek           & $FFFF ; $b0 deek(
>01861d	e5 91					.word Unary_Leek           & $FFFF ; $b1 leek(
>01861f	11 92					.word Unary_Mod            & $FFFF ; $b2 mod(
>018621	7d 91					.word Unary_Sgn            & $FFFF ; $b3 sgn(
>018623	83 94					.word Unary_Chr            & $FFFF ; $b4 chr$(
>018625	79 86					.word NotImplemented       & $FFFF ; $b5 pos(
>018627	79 86					.word NotImplemented       & $FFFF ; $b6 tab(
>018629	79 86					.word NotImplemented       & $FFFF ; $b7 $
>01862b	79 86					.word NotImplemented       & $FFFF ; $b8 $(
>01862d	79 86					.word NotImplemented       & $FFFF ; $b9 #
>01862f	79 86					.word NotImplemented       & $FFFF ; $ba #(
>018631	79 86					.word NotImplemented       & $FFFF ; $bb %
>018633	79 86					.word NotImplemented       & $FFFF ; $bc %(
>018635	79 86					.word NotImplemented       & $FFFF ; $bd (
>018637	79 86					.word NotImplemented       & $FFFF ; $be )
>018639	79 86					.word NotImplemented       & $FFFF ; $bf ,
>01863b	71 89					.word Command_COLON        & $FFFF ; $c0 :
>01863d	79 86					.word NotImplemented       & $FFFF ; $c1 ;
>01863f	79 86					.word NotImplemented       & $FFFF ; $c2 def
>018641	2e 8d					.word Command_CLR          & $FFFF ; $c3 clr
>018643	42 8d					.word Command_STOP         & $FFFF ; $c4 stop
>018645	79 86					.word NotImplemented       & $FFFF ; $c5 data
>018647	79 86					.word NotImplemented       & $FFFF ; $c6 read
>018649	1d 88					.word Command_DIM          & $FFFF ; $c7 dim
>01864b	79 86					.word NotImplemented       & $FFFF ; $c8 to
>01864d	79 86					.word NotImplemented       & $FFFF ; $c9 step
>01864f	aa 8c					.word Command_GOSUB        & $FFFF ; $ca gosub
>018651	b8 8c					.word Command_RETURN       & $FFFF ; $cb return
>018653	a4 8c					.word Command_GOTO         & $FFFF ; $cc goto
>018655	ad 89					.word Command_END          & $FFFF ; $cd end
>018657	79 86					.word NotImplemented       & $FFFF ; $ce input
>018659	72 89					.word Command_LET          & $FFFF ; $cf let
>01865b	14 8a					.word Command_LIST         & $FFFF ; $d0 list
>01865d	4d 8c					.word Command_NEW          & $FFFF ; $d1 new
>01865f	69 8c					.word Command_OLD          & $FFFF ; $d2 old
>018661	79 86					.word NotImplemented       & $FFFF ; $d3 on
>018663	79 86					.word NotImplemented       & $FFFF ; $d4 restore
>018665	1c 8c					.word Command_POKE         & $FFFF ; $d5 poke
>018667	95 8b					.word Command_PRINT        & $FFFF ; $d6 print
>018669	e3 88					.word Command_RUN          & $FFFF ; $d7 run
>01866b	a5 88					.word Command_WAIT         & $FFFF ; $d8 wait
>01866d	93 89					.word Command_SYS          & $FFFF ; $d9 sys
>01866f	20 8c					.word Command_DOKE         & $FFFF ; $da doke
>018671	24 8c					.word Command_LOKE         & $FFFF ; $db loke
>018673	04 8c					.word Command_ASSERT       & $FFFF ; $dc assert
>018675	79 86					.word NotImplemented       & $FFFF ; $dd get
>018677	08 8a					.word Command_ELSE         & $FFFF ; $de else
.018679					NotImplemented:
.018679	20 57 85	jsr $018557			jsr ERR_Handler
>01867c	4e 6f 74 20 69 6d 70 6c			.text "Not implemented",0
>018684	65 6d 65 6e 74 65 64 00
.01868c					BinaryPrecedence:
>01868c	01					.byte 1    ; $80 and
>01868d	01					.byte 1    ; $81 or
>01868e	01					.byte 1    ; $82 xor
>01868f	01					.byte 1    ; $83 eor
>018690	02					.byte 2    ; $84 =
>018691	02					.byte 2    ; $85 <>
>018692	02					.byte 2    ; $86 <
>018693	02					.byte 2    ; $87 <=
>018694	02					.byte 2    ; $88 >
>018695	02					.byte 2    ; $89 >=
>018696	03					.byte 3    ; $8a +
>018697	03					.byte 3    ; $8b -
>018698	04					.byte 4    ; $8c *
>018699	04					.byte 4    ; $8d /
>01869a	05					.byte 5    ; $8e ^
.01869b					KeywordText:
>01869b	41 4e c4				.byte $41,$4e,$c4                      ; $80 and
>01869e	4f d2					.byte $4f,$d2                          ; $81 or
>0186a0	58 4f d2				.byte $58,$4f,$d2                      ; $82 xor
>0186a3	45 4f d2				.byte $45,$4f,$d2                      ; $83 eor
>0186a6	bd					.byte $bd                              ; $84 =
>0186a7	3c be					.byte $3c,$be                          ; $85 <>
>0186a9	bc					.byte $bc                              ; $86 <
>0186aa	3c bd					.byte $3c,$bd                          ; $87 <=
>0186ac	be					.byte $be                              ; $88 >
>0186ad	3e bd					.byte $3e,$bd                          ; $89 >=
>0186af	ab					.byte $ab                              ; $8a +
>0186b0	ad					.byte $ad                              ; $8b -
>0186b1	aa					.byte $aa                              ; $8c *
>0186b2	af					.byte $af                              ; $8d /
>0186b3	de					.byte $de                              ; $8e ^
>0186b4	49 c6					.byte $49,$c6                          ; $8f if
>0186b6	57 48 49 4c c5				.byte $57,$48,$49,$4c,$c5              ; $90 while
>0186bb	52 45 50 45 41 d4			.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
>0186c1	46 4f d2				.byte $46,$4f,$d2                      ; $92 for
>0186c4	54 48 45 ce				.byte $54,$48,$45,$ce                  ; $93 then
>0186c8	45 4e 44 49 c6				.byte $45,$4e,$44,$49,$c6              ; $94 endif
>0186cd	57 45 4e c4				.byte $57,$45,$4e,$c4                  ; $95 wend
>0186d1	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc              ; $96 until
>0186d6	4e 45 58 d4				.byte $4e,$45,$58,$d4                  ; $97 next
>0186da	4e 4f d4				.byte $4e,$4f,$d4                      ; $98 not
>0186dd	46 4e a8				.byte $46,$4e,$a8                      ; $99 fn(
>0186e0	41 42 53 a8				.byte $41,$42,$53,$a8                  ; $9a abs(
>0186e4	41 53 43 a8				.byte $41,$53,$43,$a8                  ; $9b asc(
>0186e8	49 4e 54 a8				.byte $49,$4e,$54,$a8                  ; $9c int(
>0186ec	50 45 45 4b a8				.byte $50,$45,$45,$4b,$a8              ; $9d peek(
>0186f1	52 4e 44 a8				.byte $52,$4e,$44,$a8                  ; $9e rnd(
>0186f5	55 53 52 a8				.byte $55,$53,$52,$a8                  ; $9f usr(
>0186f9	4c 45 46 54 24 a8			.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
>0186ff	52 49 47 48 54 24 a8			.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
>018706	4d 49 44 24 a8				.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
>01870b	53 50 43 a8				.byte $53,$50,$43,$a8                  ; $a3 spc(
>01870f	53 54 52 24 a8				.byte $53,$54,$52,$24,$a8              ; $a4 str$(
>018714	56 41 4c a8				.byte $56,$41,$4c,$a8                  ; $a5 val(
>018718	4c 45 4e a8				.byte $4c,$45,$4e,$a8                  ; $a6 len(
>01871c	48 45 58 24 a8				.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
>018721	53 49 4e a8				.byte $53,$49,$4e,$a8                  ; $a8 sin(
>018725	43 4f 53 a8				.byte $43,$4f,$53,$a8                  ; $a9 cos(
>018729	54 41 4e a8				.byte $54,$41,$4e,$a8                  ; $aa tan(
>01872d	41 54 4e a8				.byte $41,$54,$4e,$a8                  ; $ab atn(
>018731	45 58 50 a8				.byte $45,$58,$50,$a8                  ; $ac exp(
>018735	4c 4f 47 a8				.byte $4c,$4f,$47,$a8                  ; $ad log(
>018739	53 51 52 a8				.byte $53,$51,$52,$a8                  ; $ae sqr(
>01873d	44 45 43 a8				.byte $44,$45,$43,$a8                  ; $af dec(
>018741	44 45 45 4b a8				.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
>018746	4c 45 45 4b a8				.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
>01874b	4d 4f 44 a8				.byte $4d,$4f,$44,$a8                  ; $b2 mod(
>01874f	53 47 4e a8				.byte $53,$47,$4e,$a8                  ; $b3 sgn(
>018753	43 48 52 24 a8				.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
>018758	50 4f 53 a8				.byte $50,$4f,$53,$a8                  ; $b5 pos(
>01875c	54 41 42 a8				.byte $54,$41,$42,$a8                  ; $b6 tab(
>018760	a4					.byte $a4                              ; $b7 $
>018761	24 a8					.byte $24,$a8                          ; $b8 $(
>018763	a3					.byte $a3                              ; $b9 #
>018764	23 a8					.byte $23,$a8                          ; $ba #(
>018766	a5					.byte $a5                              ; $bb %
>018767	25 a8					.byte $25,$a8                          ; $bc %(
>018769	a8					.byte $a8                              ; $bd (
>01876a	a9					.byte $a9                              ; $be )
>01876b	ac					.byte $ac                              ; $bf ,
>01876c	ba					.byte $ba                              ; $c0 :
>01876d	bb					.byte $bb                              ; $c1 ;
>01876e	44 45 c6				.byte $44,$45,$c6                      ; $c2 def
>018771	43 4c d2				.byte $43,$4c,$d2                      ; $c3 clr
>018774	53 54 4f d0				.byte $53,$54,$4f,$d0                  ; $c4 stop
>018778	44 41 54 c1				.byte $44,$41,$54,$c1                  ; $c5 data
>01877c	52 45 41 c4				.byte $52,$45,$41,$c4                  ; $c6 read
>018780	44 49 cd				.byte $44,$49,$cd                      ; $c7 dim
>018783	54 cf					.byte $54,$cf                          ; $c8 to
>018785	53 54 45 d0				.byte $53,$54,$45,$d0                  ; $c9 step
>018789	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2              ; $ca gosub
>01878e	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce          ; $cb return
>018794	47 4f 54 cf				.byte $47,$4f,$54,$cf                  ; $cc goto
>018798	45 4e c4				.byte $45,$4e,$c4                      ; $cd end
>01879b	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4              ; $ce input
>0187a0	4c 45 d4				.byte $4c,$45,$d4                      ; $cf let
>0187a3	4c 49 53 d4				.byte $4c,$49,$53,$d4                  ; $d0 list
>0187a7	4e 45 d7				.byte $4e,$45,$d7                      ; $d1 new
>0187aa	4f 4c c4				.byte $4f,$4c,$c4                      ; $d2 old
>0187ad	4f ce					.byte $4f,$ce                          ; $d3 on
>0187af	52 45 53 54 4f 52 c5			.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d4 restore
>0187b6	50 4f 4b c5				.byte $50,$4f,$4b,$c5                  ; $d5 poke
>0187ba	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4              ; $d6 print
>0187bf	52 55 ce				.byte $52,$55,$ce                      ; $d7 run
>0187c2	57 41 49 d4				.byte $57,$41,$49,$d4                  ; $d8 wait
>0187c6	53 59 d3				.byte $53,$59,$d3                      ; $d9 sys
>0187c9	44 4f 4b c5				.byte $44,$4f,$4b,$c5                  ; $da doke
>0187cd	4c 4f 4b c5				.byte $4c,$4f,$4b,$c5                  ; $db loke
>0187d1	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4          ; $dc assert
>0187d7	47 45 d4				.byte $47,$45,$d4                      ; $dd get
>0187da	45 4c 53 c5				.byte $45,$4c,$53,$c5                  ; $de else
>0187de	00					.byte $00
=$80					token_and = $80
=$81					token_or = $81
=$82					token_xor = $82
=$83					token_eor = $83
=$84					token_equal = $84
=$85					token_lessgreater = $85
=$86					token_less = $86
=$87					token_lessequal = $87
=$88					token_greater = $88
=$89					token_greaterequal = $89
=$8a					token_plus = $8a
=$8b					token_minus = $8b
=$8c					token_star = $8c
=$8d					token_slash = $8d
=$8e					token_hat = $8e
=$8f					token_if = $8f
=$90					token_while = $90
=$91					token_repeat = $91
=$92					token_for = $92
=$93					token_then = $93
=$94					token_endif = $94
=$95					token_wend = $95
=$96					token_until = $96
=$97					token_next = $97
=$98					token_not = $98
=$99					token_fn = $99
=$9a					token_abs = $9a
=$9b					token_asc = $9b
=$9c					token_int = $9c
=$9d					token_peek = $9d
=$9e					token_rnd = $9e
=$9f					token_usr = $9f
=$a0					token_leftdollarlparen = $a0
=$a1					token_rightdollarlparen = $a1
=$a2					token_middollarlparen = $a2
=$a3					token_spc = $a3
=$a4					token_strdollarlparen = $a4
=$a5					token_val = $a5
=$a6					token_len = $a6
=$a7					token_hexdollarlparen = $a7
=$a8					token_sin = $a8
=$a9					token_cos = $a9
=$aa					token_tan = $aa
=$ab					token_atn = $ab
=$ac					token_exp = $ac
=$ad					token_log = $ad
=$ae					token_sqr = $ae
=$af					token_dec = $af
=$b0					token_deek = $b0
=$b1					token_leek = $b1
=$b2					token_mod = $b2
=$b3					token_sgn = $b3
=$b4					token_chrdollarlparen = $b4
=$b5					token_pos = $b5
=$b6					token_tab = $b6
=$b7					token_dollar = $b7
=$b8					token_dollarlparen = $b8
=$b9					token_hash = $b9
=$ba					token_hashlparen = $ba
=$bb					token_percent = $bb
=$bc					token_percentlparen = $bc
=$bd					token_lparen = $bd
=$be					token_rparen = $be
=$bf					token_comma = $bf
=$c0					token_colon = $c0
=$c1					token_semicolon = $c1
=$c2					token_def = $c2
=$c3					token_clr = $c3
=$c4					token_stop = $c4
=$c5					token_data = $c5
=$c6					token_read = $c6
=$c7					token_dim = $c7
=$c8					token_to = $c8
=$c9					token_step = $c9
=$ca					token_gosub = $ca
=$cb					token_return = $cb
=$cc					token_goto = $cc
=$cd					token_end = $cd
=$ce					token_input = $ce
=$cf					token_let = $cf
=$d0					token_list = $d0
=$d1					token_new = $d1
=$d2					token_old = $d2
=$d3					token_on = $d3
=$d4					token_restore = $d4
=$d5					token_poke = $d5
=$d6					token_print = $d6
=$d7					token_run = $d7
=$d8					token_wait = $d8
=$d9					token_sys = $d9
=$da					token_doke = $da
=$db					token_loke = $db
=$dc					token_assert = $dc
=$dd					token_get = $dd
=$de					token_else = $de

;******  Return to file: modules/basic/core.asm

.0187df					BASIC_Start:
.0187df	20 a8 81	jsr $0181a8			jsr 	IF_Reset 					; set up and clear screen.
.0187e2	20 00 80	jsr $018000			jsr 	IFT_ClearScreen
.0187e5	a9 5c		lda #$5c			lda 	#$5C 						; JMP Long opcode
.0187e7	8d 10 03	sta $0310			sta 	LocalVector
.0187ea	8d 0c 03	sta $030c			sta 	UserVector
.0187ed	a9 54		lda #$54			lda 	#USRDefault & $FF 			; reset USR vector
.0187ef	8d 0d 03	sta $030d			sta 	UserVector+1
.0187f2	a9 92		lda #$92			lda 	#(USRDefault >> 8) & $FF
.0187f4	8d 0e 03	sta $030e			sta 	UserVector+2
.0187f7	a9 01		lda #$01			lda 	#(USRDefault >> 16) & $FF
.0187f9	8d 0f 03	sta $030f			sta 	UserVector+3
.0187fc	20 fb 94	jsr $0194fb			jsr 	UpdateProgramEnd 			; update the program end.
.0187ff	20 2e 8d	jsr $018d2e			jsr 	ResetRunStatus 				; clear everything (CLR command)
.018802	c2 30		rep #$30			rep 	#$30
.018804	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018807	1b		tcs				tcs
.018808	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.01880b	e2 30		sep #$30			sep 	#$30
.01880d	4c e3 88	jmp $0188e3			jmp 	COMMAND_Run
.018810					WarmStart:
.018810	c2 30		rep #$30			rep 	#$30
.018812	a9 ff 01	lda #$01ff			lda 	#$01FF 						; empty stack
.018815	1b		tcs				tcs
.018816	a9 00 00	lda #$0000			lda 	#$0000 						; make sure A zero.
.018819	e2 30		sep #$30			sep 	#$30
.01881b	80 f3		bra $018810			bra 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/dim.asm

.01881d					Command_DIM:
.01881d	98		tya				tya
.01881e	48		pha				pha 								; push on stack.
.01881f	20 63 96	jsr $019663			jsr 	VariableExtract 			; get the identifier
.018822	ad 95 03	lda $0395			lda 	Var_Type 					; check it is an array
.018825	29 01		and #$01			and 	#1
.018827	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.018829	d0 6c		bne $018897			bne 	_CDIError
.01882b	a9 00		lda #$00			lda 	#0 							; reset the DIM index. The dimensions are
.01882d	8d b8 03	sta $03b8			sta 	UsrArrayIdx 				; built up here and copied in case we autodim
.018830					_CDIGetDimension:
.018830	ad b8 03	lda $03b8			lda 	UsrArrayIdx 				; done too many ?
.018833	c9 06		cmp #$06			cmp 	#ArrayMaxDim*2
.018835	f0 60		beq $018897			beq 	_CDIError
.018837	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger 			; evaluate an index size
.01883a	a5 81		lda $81				lda 	XS_Mantissa+1 				; check in range 0-7FFF
.01883c	29 80		and #$80			and 	#$80
.01883e	05 82		ora $82				ora 	XS_Mantissa+2
.018840	05 83		ora $83				ora 	XS_Mantissa+3
.018842	d0 53		bne $018897			bne 	_CDIError
.018844	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy into the array table.
.018847	18		clc				clc 								; add 1 - max index => size.
.018848	a5 80		lda $80				lda 	XS_Mantissa+0
.01884a	69 01		adc #$01			adc 	#1
.01884c	9d b0 03	sta $03b0,x			sta 	UsrArrayDef+0,x
.01884f	a5 81		lda $81				lda 	XS_Mantissa+1
.018851	69 00		adc #$00			adc 	#0
.018853	9d b1 03	sta $03b1,x			sta 	UsrArrayDef+1,x
.018856	30 3f		bmi $018897			bmi 	_CDIError 					; could be dim a(32767)
.018858	e8		inx				inx 								; bump index.
.018859	e8		inx				inx
.01885a	8e b8 03	stx $03b8			stx 	UsrArrayIdx
.01885d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01885f	c8		iny				iny
.018860	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another dimension
.018862	f0 cc		beq $018830			beq 	_CDIGetDimension
.018864	88		dey				dey
.018865	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; closing ) present ?
.018868	ae b8 03	ldx $03b8			ldx 	UsrArrayIdx 				; copy USR array to default
.01886b	a9 ff		lda #$ff			lda 	#$FF 						; put end marker in ArrayDef
.01886d	9d a9 03	sta $03a9,x			sta 	ArrayDef+1,x
.018870					_CDICopy:
.018870	bd b0 03	lda $03b0,x			lda 	UsrArrayDef,x
.018873	9d a8 03	sta $03a8,x			sta 	ArrayDef,x
.018876	ca		dex				dex
.018877	10 f7		bpl $018870			bpl 	_CDICopy
.018879	68		pla				pla									; position of array identifier
.01887a	85 10		sta $10				sta 	zTemp1
.01887c	98		tya				tya
.01887d	48		pha				pha
.01887e	a5 10		lda $10				lda 	zTemp1 						; point to identifier
.018880	a8		tay				tay
.018881	20 63 96	jsr $019663			jsr 	VariableExtract 			; get the identifier
.018884	20 fc 98	jsr $0198fc			jsr 	VariableLocate 				; check if it exists already.
.018887	b0 0e		bcs $018897			bcs 	_CDIError
.018889	20 ef 96	jsr $0196ef			jsr 	VariableCreate 				; create it using the current ArrayDef
.01888c	68		pla				pla 								; restore code position
.01888d	a8		tay				tay
.01888e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018890	c8		iny				iny
.018891	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma, do another DIM
.018893	f0 88		beq $01881d			beq 	Command_DIM
.018895	88		dey				dey
.018896	60		rts				rts
.018897					_CDIError:
.018897	20 57 85	jsr $018557			jsr ERR_Handler
>01889a	42 61 64 20 44 49 4d 00			.text "Bad DIM",0
.0188a2					_CDISyntax:
.0188a2	4c 28 85	jmp $018528			jmp 	SyntaxError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/wait.asm

.0188a5					Command_WAIT:
.0188a5	20 2f 8f	jsr $018f2f			jsr		EvaluateInteger 			; address
.0188a8	a2 06		ldx #$06			ldx 	#XS_Size 					; and mask.
.0188aa	20 5f 95	jsr $01955f			jsr 	CheckNextComma
.0188ad	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX
.0188b0	a9 00		lda #$00			lda 	#0							; set default xor.
.0188b2	85 8c		sta $8c				sta 	XS_Mantissa+XS_Size*2
.0188b4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188b6	c9 bf		cmp #$bf			cmp 	#token_Comma 				; no use the default
.0188b8	d0 06		bne $0188c0			bne 	_CWAXorDefault
.0188ba	c8		iny				iny
.0188bb	a2 0c		ldx #$0c			ldx 	#XS_Size*2
.0188bd	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX
.0188c0					_CWAXorDefault:
.0188c0	a5 80		lda $80				lda 	XS_Mantissa 				; copy 24 bits of mantissa to ZLTemp1
.0188c2	85 1a		sta $1a				sta 	zLTemp1
.0188c4	a5 81		lda $81				lda 	XS_Mantissa+1
.0188c6	85 1b		sta $1b				sta 	zLTemp1+1
.0188c8	a5 82		lda $82				lda 	XS_Mantissa+2
.0188ca	85 1c		sta $1c				sta 	zLTemp1+2
.0188cc					_CWAWaitLoop:
.0188cc	20 25 85	jsr $018525			jsr 	CheckBreak 					; exit on break.
.0188cf	c9 00		cmp #$00			cmp 	#0
.0188d1	d0 0f		bne $0188e2			bne 	_CWAWaitExit
.0188d3	a9 01		lda #$01			lda 	#1							; read 1 byte to mantissa/0
.0188d5	a2 00		ldx #$00			ldx 	#0
.0188d7	5a		phy				phy 								; this is the same routine as PEEK.
.0188d8	20 d9 94	jsr $0194d9			jsr 	MemRead
.0188db	7a		ply				ply
.0188dc	25 86		and $86				and 	XS_Mantissa+XS_Size 		; process it
.0188de	45 8c		eor $8c				eor 	XS_Mantissa+XS_Size*2
.0188e0	f0 ea		beq $0188cc			beq 	_CWAWaitLoop
.0188e2					_CWAWaitExit:
.0188e2	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/run.asm

.0188e3					Command_RUN:
.0188e3	20 2e 8d	jsr $018d2e			jsr 	ResetRunStatus 				; clear, reset stacks etc.
.0188e6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0188e8	85 16		sta $16				sta 	zCodePtr+0
.0188ea	a9 10		lda #$10			lda 	#BasicProgram >> 8
.0188ec	85 17		sta $17				sta 	zCodePtr+1
.0188ee	a9 00		lda #$00			lda 	#0
.0188f0	85 18		sta $18				sta 	zCodePtr+2
.0188f2	85 19		sta $19				sta 	zCodePtr+3
.0188f4	a0 03		ldy #$03			ldy 	#3
.0188f6					RUN_NewLine:
.0188f6	a0 00		ldy #$00			ldy 	#0
.0188f8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0188fa	c8		iny				iny
.0188fb	c8		iny				iny
.0188fc	c8		iny				iny
.0188fd	c9 00		cmp #$00			cmp 	#0 							; if the offset is zero then END.
.0188ff	d0 16		bne $018917			bne 	RUN_NextCommand
.018901	4c ad 89	jmp $0189ad			jmp 	Command_END 				; go do the command code.
.018904					RUN_Skip:
.018904	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.018906	c8		iny				iny 								; skip
.018907	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.018909	90 0c		bcc $018917			bcc 	_SEDone 					; so just skip over it.
.01890b	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.01890d	90 07		bcc $018916			bcc 	_SEDouble
.01890f	98		tya				tya 								; this is Y + 1
.018910	18		clc				clc
.018911	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.018913	a8		tay				tay 								; back in Y.
.018914	88		dey				dey 								; fix up, one for the +1, one for the iny
.018915	88		dey				dey
.018916					_SEDouble:
.018916	c8		iny				iny
.018917					_SEDone:
.018917					RUN_NextCommand:
.018917	ad a7 03	lda $03a7			lda 	BreakCount 					; break counter
.01891a	69 10		adc #$10			adc 	#16 						; one time in 16
.01891c	8d a7 03	sta $03a7			sta 	BreakCount
.01891f	90 0a		bcc $01892b			bcc 	RUN_NoCheckBreak
.018921	20 25 85	jsr $018525			jsr 	CheckBreak 					; check for break
.018924	c9 00		cmp #$00			cmp 	#0
.018926	f0 03		beq $01892b			beq 	RUN_NoCheckBreak
.018928	4c 42 8d	jmp $018d42			jmp 	Command_STOP 				; stop on BREAK.
.01892b					RUN_NoCheckBreak:
.01892b	a9 00		lda #$00			lda 	#0 							; this resets temporary string allocation.
.01892d	85 21		sta $21				sta 	zTempStr+1 					; (initialised when first called)
.01892f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018931	c9 c0		cmp #$c0			cmp 	#token_Colon 				; skip over colons
.018933	f0 cf		beq $018904			beq 	RUN_Skip
.018935	c9 00		cmp #$00			cmp 	#0 							; if non-zero execute whatever
.018937	d0 0f		bne $018948			bne 	RUN_Execute
.018939					RUN_NextLine:
.018939	a0 00		ldy #$00			ldy 	#0 							; point to offset
.01893b	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.01893d	18		clc				clc
.01893e	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018940	85 16		sta $16				sta 	zCodePtr
.018942	90 02		bcc $018946			bcc 	_SNLNoCarry
.018944	e6 17		inc $17				inc 	zCodePtr+1
.018946					_SNLNoCarry:
.018946	80 ae		bra $0188f6			bra 	RUN_NewLine 				; go do the new line code
.018948					RUN_Execute:
.018948	c9 f8		cmp #$f8			cmp 	#$F8 						; handle shifts, REM etc.
.01894a	b0 1e		bcs $01896a			bcs 	RUN_Extension
.01894c	c8		iny				iny
.01894d	0a		asl a				asl 	a 							; double the character read.
.01894e	90 14		bcc $018964			bcc 	RUN_Default 				; if carry clear was $00-$7F, so try LET.
.018950	aa		tax				tax 								; ready to look up.
.018951	bf bb 85 01	lda $0185bb,x			lda 	VectorTable,x 				; copy address into LocalVector
.018955	8d 11 03	sta $0311			sta 	LocalVector+1
.018958	bf bc 85 01	lda $0185bc,x			lda 	VectorTable+1,x
.01895c	8d 12 03	sta $0312			sta 	LocalVector+2
.01895f	20 7c 8e	jsr $018e7c			jsr 	EVCallLocalVector 			; execute the appropriate code.
.018962	80 b3		bra $018917			bra 	RUN_NextCommand 			; do the next command.
.018964					RUN_Default:
.018964	88		dey				dey
.018965	20 72 89	jsr $018972			jsr 	Command_LET 				; and try LET.
.018968	80 ad		bra $018917			bra 	RUN_NextCommand
.01896a					RUN_Extension:
.01896a	c9 ff		cmp #$ff			cmp 	#$FF 						; if $FF (REM)
.01896c	f0 96		beq $018904			beq 	RUN_Skip 					; skip over it.
.01896e	4c 28 85	jmp $018528			jmp 	SyntaxError
.018971					Command_COLON:
.018971	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/let.asm

.018972					Command_LET:
.018972	20 f8 95	jsr $0195f8			jsr 	VariableFind 				; get reference to one variable.
.018975	a9 84		lda #$84			lda 	#token_Equal  				; get equals
.018977	20 40 95	jsr $019540			jsr 	CheckNextToken
.01897a	a5 22		lda $22				lda 	zVarDataPtr 				; save variable info on stack
.01897c	48		pha				pha
.01897d	a5 23		lda $23				lda 	zVarDataPtr+1
.01897f	48		pha				pha
.018980	a5 24		lda $24				lda 	zVarType
.018982	48		pha				pha
.018983	20 99 8d	jsr $018d99			jsr 	EvaluateExpression 			; evaluate the RHS.
.018986	68		pla				pla 								; restore target variable information.
.018987	85 24		sta $24				sta 	zVarType
.018989	68		pla				pla
.01898a	85 23		sta $23				sta 	zVarDataPtr+1
.01898c	68		pla				pla
.01898d	85 22		sta $22				sta 	zVarDataPtr
.01898f	20 91 99	jsr $019991			jsr 	VariableSet 				; set the value out.
.018992	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/sys.asm

.018993					Command_SYS:
.018993	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger 			; address
.018996	a5 80		lda $80				lda 	XS_Mantissa+0				; copy to localvector
.018998	8d 10 03	sta $0310			sta 	LocalVector+0 				; only three, can only do 24 bit calls
.01899b	a5 81		lda $81				lda 	XS_Mantissa+1 				; and that only on 65816
.01899d	8d 11 03	sta $0311			sta 	LocalVector+1
.0189a0	a5 82		lda $82				lda 	XS_Mantissa+2
.0189a2	8d 12 03	sta $0312			sta 	LocalVector+2
.0189a5	22 aa 89 01	jsl $0189aa			jsl 	_CSYLocalCall
.0189a9	60		rts				rts
.0189aa					_CSYLocalCall:
.0189aa	dc 10 03	jmp [$0310]			jmp 	[LocalVector]

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/end.asm

.0189ad					Command_END:
>0189ad	02						.byte 	2
.0189ae	4c 10 88	jmp $018810			jmp 	WarmStart

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/if.asm

.0189b1					Command_IF:
.0189b1	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger 			; check success.
.0189b4	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.0189b6	05 81		ora $81				ora 	XS_Mantissa+1
.0189b8	05 82		ora $82				ora 	XS_Mantissa+2
.0189ba	05 83		ora $83				ora 	XS_Mantissa+3
.0189bc	aa		tax				tax 								; put into X.
.0189bd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189bf	c9 93		cmp #$93			cmp 	#token_Then 				; then found.
.0189c1	d0 2c		bne $0189ef			bne 	_FIFExtended
.0189c3	c8		iny				iny
.0189c4	e0 00		cpx #$00			cpx 	#0 							; was it successful.
.0189c6	f0 0b		beq $0189d3			beq 	_FIFEndOfLine 				; if not, go to the end of the line.
.0189c8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189ca	29 c0		and #$c0			and 	#$C0 						; is it a number
.0189cc	c9 40		cmp #$40			cmp 	#$40
.0189ce	d0 1e		bne $0189ee			bne 	_FIFContinue 				; if not, do what ever follows.
.0189d0	4c a4 8c	jmp $018ca4			jmp		Command_GOTO 				; we have IF <expr> THEN <number> so we do GOTO code.
.0189d3					_FIFEndOfLine:
.0189d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0189d5	c9 00		cmp #$00			cmp 	#0 							; if zero, end of line, so exit
.0189d7	f0 15		beq $0189ee			beq 	_FIFContinue
.0189d9	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read element
.0189db	c8		iny				iny 								; skip
.0189dc	c9 f8		cmp #$f8			cmp 	#$F8 						; if < $F8 single character,token
.0189de	90 0c		bcc $0189ec			bcc 	_SEDone 					; so just skip over it.
.0189e0	c9 fc		cmp #$fc			cmp 	#$FC 						; if < $FC double character token
.0189e2	90 07		bcc $0189eb			bcc 	_SEDouble
.0189e4	98		tya				tya 								; this is Y + 1
.0189e5	18		clc				clc
.0189e6	77 16		adc [$16],y			adc 	[zCodePtr],y 				; add total length of element
.0189e8	a8		tay				tay 								; back in Y.
.0189e9	88		dey				dey 								; fix up, one for the +1, one for the iny
.0189ea	88		dey				dey
.0189eb					_SEDouble:
.0189eb	c8		iny				iny
.0189ec					_SEDone:
.0189ec	80 e5		bra $0189d3			bra 	_FIFEndOfLine
.0189ee					_FIFContinue:
.0189ee	60		rts				rts
.0189ef					_FIFExtended:
.0189ef	da		phx				phx 								; save result
.0189f0	a9 30		lda #$30			lda 	#(SMark_If << 4) 			; push marker on the stack, nothing else.
.0189f2	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.0189f5	68		pla				pla 								; restore result
.0189f6	f0 01		beq $0189f9			beq 	_FIXSkip 					; if zero then it has failed.
.0189f8	60		rts				rts 								; test passed, so continue executing
.0189f9					_FIXSkip:
.0189f9	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found either ELSE or ENDIF
.0189fb	a2 de		ldx #$de			ldx 	#token_else 				; at the same level.
.0189fd	20 02 84	jsr $018402			jsr 	StructureSearchDouble
.018a00	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a02	c8		iny				iny
.018a03	c9 94		cmp #$94			cmp 	#token_endif 				; if endif, handle endif code.
.018a05	f0 07		beq $018a0e			beq 	Command_ENDIF
.018a07	60		rts				rts
.018a08					Command_ELSE:
.018a08	a9 94		lda #$94			lda 	#token_endif 				; scan forward till found ENDIF
.018a0a	20 00 84	jsr $018400			jsr 	StructureSearchSingle 		; then do the ENDIF pop.
.018a0d	c8		iny				iny
.018a0e					Command_ENDIF:
.018a0e	a9 30		lda #$30			lda 	#(SMark_If << 4)
.018a10	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018a13	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/list.asm

.018a14					Command_LIST:
.018a14	20 2e 8b	jsr $018b2e			jsr 	ListGetRange				; get any parameters
.018a17	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018a19	85 16		sta $16				sta 	zCodePtr+0
.018a1b	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018a1d	85 17		sta $17				sta 	zCodePtr+1
.018a1f	a9 00		lda #$00			lda 	#0
.018a21	85 18		sta $18				sta 	zCodePtr+2
.018a23	85 19		sta $19				sta 	zCodePtr+3
.018a25	a0 03		ldy #$03			ldy 	#3
.018a27					_CILLoop:
.018a27	a0 00		ldy #$00			ldy 	#0
.018a29	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a2b	c9 00		cmp #$00			cmp 	#0 							; if zero, end of program
.018a2d	f0 23		beq $018a52			beq 	_CILExit
.018a2f	20 25 85	jsr $018525			jsr 	CheckBreak 					; check break
.018a32	c9 00		cmp #$00			cmp 	#0
.018a34	d0 1c		bne $018a52			bne 	_CILExit
.018a36	20 75 8b	jsr $018b75			jsr 	ListCheckRange 				; check current line in range.
.018a39	b0 08		bcs $018a43			bcs		_CILNext
.018a3b	a0 00		ldy #$00			ldy 	#0
.018a3d	c8		iny				iny
.018a3e	c8		iny				iny
.018a3f	c8		iny				iny
.018a40	20 55 8a	jsr $018a55			jsr 	ListLine 					; list one line.
.018a43					_CILNext:
.018a43	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018a45	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018a47	18		clc				clc
.018a48	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018a4a	85 16		sta $16				sta 	zCodePtr
.018a4c	90 02		bcc $018a50			bcc 	_SNLNoCarry
.018a4e	e6 17		inc $17				inc 	zCodePtr+1
.018a50					_SNLNoCarry:
.018a50	80 d5		bra $018a27			bra 	_CILLoop
.018a52					_CILExit:
.018a52	4c 10 88	jmp $018810			jmp 	WarmStart
.018a55					ListLine:
.018a55	a0 00		ldy #$00			ldy 	#0
.018a57	c8		iny				iny
.018a58	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a5a	85 80		sta $80				sta 	XS_Mantissa
.018a5c	c8		iny				iny
.018a5d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a5f	85 81		sta $81				sta 	XS_Mantissa+1
.018a61	20 9d 85	jsr $01859d			jsr 	Print16BitInteger 			; print integer.
.018a64	aa		tax				tax 								; print spaces to column 6
.018a65					_LISpace:
.018a65	a9 20		lda #$20			lda 	#" "
.018a67	20 1f 85	jsr $01851f			jsr 	CharPrint
.018a6a	e8		inx				inx
.018a6b	e0 06		cpx #$06			cpx 	#6
.018a6d	d0 f6		bne $018a65			bne 	_LISpace
.018a6f					_LIDecode:
.018a6f	c8		iny				iny
.018a70	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018a72	c9 00		cmp #$00			cmp 	#0 							; zero, exit.
.018a74	f0 0f		beq $018a85			beq 	_LIExit
.018a76	30 12		bmi $018a8a			bmi 	_LIToken
.018a78	c9 40		cmp #$40			cmp 	#$40 						; 01-$3F, character.
.018a7a	b0 50		bcs $018acc			bcs 	_LIInteger
.018a7c	49 20		eor #$20			eor 	#$20 						; make 7 bit
.018a7e	69 20		adc #$20			adc 	#$20
.018a80	20 21 8b	jsr $018b21			jsr 	ListPrintLC 				; print in LC
.018a83	80 ea		bra $018a6f			bra 	_LIDecode
.018a85					_LIExit:
.018a85	a9 0d		lda #$0d			lda 	#13 						; print new line.
.018a87	4c 1f 85	jmp $01851f			jmp 	CharPrint
.018a8a					_LIToken:
.018a8a	c9 fc		cmp #$fc			cmp 	#$FC 						; $FC-$FF ?
.018a8c	90 49		bcc $018ad7			bcc		_LICommandToken
.018a8e	48		pha				pha 								; save in case end
.018a8f	a2 22		ldx #$22			ldx 	#'"'						; print if $FE quoted string
.018a91	c9 fe		cmp #$fe			cmp 	#$FE
.018a93	f0 17		beq $018aac			beq 	_LIPrint
.018a95	a2 2e		ldx #$2e			ldx 	#'.'						; print if $FD decimals
.018a97	c9 fd		cmp #$fd			cmp 	#$FD
.018a99	f0 11		beq $018aac			beq 	_LIPrint
.018a9b	a9 52		lda #$52			lda 	#'R'						; must be REM
.018a9d	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018aa0	a9 45		lda #$45			lda 	#'E'
.018aa2	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018aa5	a9 4d		lda #$4d			lda 	#'M'
.018aa7	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018aaa	a2 20		ldx #$20			ldx 	#' '
.018aac					_LIPrint:
.018aac	8a		txa				txa
.018aad	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018ab0	c8		iny				iny
.018ab1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ab3	aa		tax				tax 								; put in X
.018ab4	ca		dex				dex
.018ab5					_LILoop:
.018ab5	ca		dex				dex 								; exit when count reached zero.
.018ab6	f0 08		beq $018ac0			beq 	_LIEnd
.018ab8	c8		iny				iny
.018ab9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018abb	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018abe	80 f5		bra $018ab5			bra 	_LILoop
.018ac0	68		pla		_LIEnd:	pla 								; get A back
.018ac1	c9 fe		cmp #$fe			cmp 	#$FE 						; if '"' need closing quotes
.018ac3	d0 aa		bne $018a6f			bne 	_LIDecode
.018ac5	a9 22		lda #$22			lda 	#'"'
.018ac7	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018aca	80 a3		bra $018a6f			bra 	_LIDecode
.018acc					_LIInteger:
.018acc	a2 00		ldx #$00			ldx 	#0
.018ace	20 a1 8e	jsr $018ea1			jsr 	EvaluateGetInteger 			; get an atom
.018ad1	88		dey				dey
.018ad2	20 a3 85	jsr $0185a3			jsr 	Print32BitInteger 			; print integer.
.018ad5	80 98		bra $018a6f			bra 	_LIDecode
.018ad7					_LICommandToken:
.018ad7	5a		phy				phy 								; save Y
.018ad8	48		pha				pha 								; save token
.018ad9	a2 9b		ldx #$9b			ldx  	#KeywordText & $FF 			; address of keyword text table.
.018adb	a9 86		lda #$86			lda 	(#KeywordText >> 8) & $FF
.018add	86 1a		stx $1a				stx 	zLTemp1
.018adf	85 1b		sta $1b				sta 	zLTemp1+1
.018ae1	a9 01		lda #$01			lda 	(#KeywordText >> 16) & $FF 	; this is for 65816 (it's a table in code
.018ae3	85 1c		sta $1c				sta 	zLTemp1+2 					; space) and won't affect a 6502 at all.
.018ae5	68		pla				pla 								; get token, chuck bit 7.
.018ae6	29 7f		and #$7f			and 	#127
.018ae8	f0 16		beq $018b00			beq 	_LIFoundToken
.018aea	aa		tax				tax
.018aeb					_LITokenLoop:
.018aeb	a0 00		ldy #$00			ldy 	#0
.018aed					_LIFindEnd:
.018aed	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018aef	c8		iny				iny
.018af0	0a		asl a				asl 	a
.018af1	90 fa		bcc $018aed			bcc 	_LIFindEnd
.018af3	98		tya				tya 								; that is step to the next
.018af4	18		clc				clc 								; we don't bother bumping the 3rd byte
.018af5	65 1a		adc $1a				adc 	zLTemp1 					; here.
.018af7	85 1a		sta $1a				sta 	zLTemp1
.018af9	90 02		bcc $018afd			bcc 	_LINoBump
.018afb	e6 1b		inc $1b				inc 	zLTemp1+1
.018afd					_LINoBump:
.018afd	ca		dex				dex 								; no go round again.
.018afe	d0 eb		bne $018aeb			bne 	_LITokenLoop
.018b00					_LIFoundToken:
.018b00	a0 00		ldy #$00			ldy 	#0
.018b02					_LIPrintToken:
.018b02	b7 1a		lda [$1a],y			lda 	[zLTemp1],y
.018b04	c8		iny				iny
.018b05	48		pha				pha 								; save it
.018b06	29 7f		and #$7f			and 	#$7F
.018b08	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018b0b	68		pla				pla
.018b0c	10 f4		bpl $018b02			bpl 	_LIPrintToken 				; go back if not end
.018b0e	7a		ply				ply 								; restore Y
.018b0f	29 7f		and #$7f			and 	#$7F 						; if last char is a letter
.018b11	c9 41		cmp #$41			cmp 	#"A"
.018b13	90 09		bcc $018b1e			bcc 	_LINotLetter
.018b15	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018b17	b0 05		bcs $018b1e			bcs 	_LINotLetter
.018b19	a9 20		lda #$20			lda 	#" " 						; add spacing
.018b1b	20 21 8b	jsr $018b21			jsr 	ListPrintLC
.018b1e					_LINotLetter:
.018b1e	4c 6f 8a	jmp $018a6f			jmp 	_LIDecode
.018b21					ListPrintLC:
.018b21	c9 41		cmp #$41			cmp 	#"A"
.018b23	90 06		bcc $018b2b			bcc 	_LPLC0
.018b25	c9 5b		cmp #$5b			cmp 	#"Z"+1
.018b27	b0 02		bcs $018b2b			bcs 	_LPLC0
.018b29	69 20		adc #$20			adc 	#$20
.018b2b	4c 1f 85	jmp $01851f	_LPLC0:	jmp 	CharPrint
.018b2e					ListGetRange:
.018b2e	a2 0b		ldx #$0b			ldx 	#XS_Size*2-1 				; clear first 2 slots back to defaults.
.018b30					_LGRClear:
.018b30	a9 00		lda #$00			lda 	#0
.018b32	95 80		sta $80,x			sta 	XS_Mantissa,x
.018b34	ca		dex				dex
.018b35	10 f9		bpl $018b30			bpl 	_LGRClear
.018b37	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b39	c9 00		cmp #$00			cmp 	#0 							; nothing
.018b3b	f0 21		beq $018b5e			beq 	_LGRBlank
.018b3d	c9 c0		cmp #$c0			cmp 	#token_Colon 				; or colon
.018b3f	f0 1d		beq $018b5e			beq 	_LGRBlank
.018b41	c9 bf		cmp #$bf			cmp 	#token_Comma 				; comma
.018b43	f0 18		beq $018b5d			beq 	_LGREnd 					; then it's LIST ,x
.018b45	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger 			; get the first number into bottom
.018b48	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b4a	c9 bf		cmp #$bf			cmp 	#token_Comma
.018b4c	f0 0f		beq $018b5d			beq 	_LGREnd 					; then it is LIST a,b
.018b4e	a5 80		lda $80				lda 	XS_Mantissa+0 				; copy first to second LIST n is n,n
.018b50	85 86		sta $86				sta 	XS_Mantissa+XS_Size+0
.018b52	a5 81		lda $81				lda 	XS_Mantissa+1
.018b54	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018b56					_LGRBumpExit:
.018b56	e6 86		inc $86				inc 	XS_Mantissa+XS_Size 		; bump it so we can use cc.
.018b58	d0 02		bne $018b5c			bne 	_LGRBump2
.018b5a	e6 87		inc $87				inc 	XS_Mantissa+XS_Size+1
.018b5c					_LGRBump2:
.018b5c	60		rts				rts
.018b5d					_LGREnd:
.018b5d	c8		iny				iny
.018b5e					_LGRBlank:
.018b5e	a9 ff		lda #$ff			lda 	#$FF 						; default to the end.
.018b60	85 86		sta $86				sta 	XS_Mantissa+XS_Size
.018b62	85 87		sta $87				sta 	XS_Mantissa+XS_Size+1
.018b64	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b66	c9 00		cmp #$00			cmp 	#0
.018b68	f0 f2		beq $018b5c			beq 	_LGRBump2
.018b6a	0a		asl a				asl 	a 							; if not a number, then exit (to end)
.018b6b	b0 ef		bcs $018b5c			bcs 	_LGRBump2
.018b6d	a2 06		ldx #$06			ldx 	#XS_Size 					; get to range
.018b6f	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX
.018b72	80 e2		bra $018b56			bra 	_LGRBumpExit
.018b74	60		rts				rts
.018b75					ListCheckRange:
.018b75	c8		iny				iny
.018b76	a2 00		ldx #$00			ldx 	#0 							; test low
.018b78	20 85 8b	jsr $018b85			jsr 	_LCRCompare
.018b7b	90 06		bcc $018b83			bcc 	_LCRFail
.018b7d	a2 06		ldx #$06			ldx 	#XS_Size 					; test high
.018b7f	20 85 8b	jsr $018b85			jsr 	_LCRCompare
.018b82	60		rts				rts
.018b83					_LCRFail:
.018b83	38		sec				sec
.018b84	60		rts				rts
.018b85					_LCRCompare:
.018b85	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b87	38		sec				sec
.018b88	f5 80		sbc $80,x			sbc	 	XS_Mantissa+0,x
.018b8a	08		php				php
.018b8b	c8		iny				iny
.018b8c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b8e	28		plp				plp
.018b8f	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.018b91	08		php				php
.018b92	88		dey				dey
.018b93	28		plp				plp
.018b94	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/print.asm

.018b95					Command_PRINT:
.018b95	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018b97	c9 00		cmp #$00			cmp 	#0 							; end
.018b99	f0 65		beq $018c00			beq 	_CPR_NewLine
.018b9b	c9 c0		cmp #$c0			cmp 	#token_Colon
.018b9d	f0 61		beq $018c00			beq 	_CPR_NewLine
.018b9f	c9 c1		cmp #$c1			cmp 	#token_SemiColon
.018ba1	f0 50		beq $018bf3			beq 	_CPR_Skip
.018ba3	c9 bf		cmp #$bf			cmp 	#token_Comma
.018ba5	f0 49		beq $018bf0			beq 	_CPR_Tab
.018ba7	20 99 8d	jsr $018d99			jsr 	EvaluateExpression 			; get expression.
.018baa	a5 85		lda $85				lda 	XS_Type 					; get type.
.018bac	29 02		and #$02			and 	#2
.018bae	d0 24		bne $018bd4			bne 	_CPR_String 				; if type = 2 output as string.
.018bb0					_CPR_Number:
.018bb0	a9 00		lda #$00			lda 	#0 							; reset buffer index
.018bb2	8d 14 03	sta $0314			sta 	NumBufX
.018bb5	a5 85		lda $85				lda 	XS_Type 					; get type
.018bb7	4a		lsr a				lsr 	a
.018bb8	b0 05		bcs $018bbf			bcs 	_CPRInt 					; if msb set do as integer
.018bba	20 15 a0	jsr $01a015			jsr 	FPToString 					; call fp to str otherwise
.018bbd	80 03		bra $018bc2			bra 	_CPRNPrint
.018bbf	20 da 9a	jsr $019ada	_CPRInt:jsr 	IntToString
.018bc2					_CPRNPrint:
.018bc2	ad 15 03	lda $0315			lda 	Num_Buffer 					; is first character -
.018bc5	c9 2d		cmp #$2d			cmp 	#"-"
.018bc7	f0 05		beq $018bce			beq 	_CPRNoSpace
.018bc9	a9 20		lda #$20			lda 	#" "						; print the leading space
.018bcb	20 1f 85	jsr $01851f			jsr 	CharPrint 					; so beloved of MS Basics.
.018bce					_CPRNoSpace:
.018bce	a2 14		ldx #$14			ldx 	#(Num_Buffer-1) & $FF
.018bd0	a9 03		lda #$03			lda 	#(Num_Buffer-1) >> 8
.018bd2	80 04		bra $018bd8			bra 	_CPRPrint
.018bd4					_CPR_String:
.018bd4	a6 80		ldx $80				ldx 	XS_Mantissa
.018bd6	a5 81		lda $81				lda 	XS_Mantissa+1
.018bd8					_CPRPrint:
.018bd8	86 1e		stx $1e				stx 	zGenPtr
.018bda	85 1f		sta $1f				sta 	zGenPtr+1
.018bdc	5a		phy				phy
.018bdd	a0 00		ldy #$00			ldy 	#0							; get length into X
.018bdf	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018be1	aa		tax				tax
.018be2	f0 09		beq $018bed			beq 	_CPREndPrint 				; nothing to print
.018be4					_CPRLoop:
.018be4	c8		iny				iny
.018be5	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.018be7	20 1f 85	jsr $01851f			jsr 	CharPrint
.018bea	ca		dex				dex
.018beb	d0 f7		bne $018be4			bne 	_CPRLoop
.018bed					_CPREndPrint:
.018bed	7a		ply				ply
.018bee	80 a5		bra $018b95			bra 	Command_Print
.018bf0					_CPR_Tab:
.018bf0	20 4f 80	jsr $01804f			jsr 	IFT_Tab
.018bf3					_CPR_Skip:
.018bf3	c8		iny				iny
.018bf4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018bf6	c9 c0		cmp #$c0			cmp 	#token_Colon 				; colon or $00, exit
.018bf8	f0 09		beq $018c03			beq 	_CPR_Exit
.018bfa	c9 00		cmp #$00			cmp 	#0
.018bfc	d0 97		bne $018b95			bne 	Command_PRINT 				; if not go round again.
.018bfe	80 03		bra $018c03			bra 	_CPR_Exit
.018c00					_CPR_NewLine:
.018c00	20 5c 80	jsr $01805c			jsr 	IFT_NewLine
.018c03					_CPR_Exit:
.018c03	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/assert.asm

.018c04					Command_ASSERT:
.018c04	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger 			; calculate thing being asserted
.018c07	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; check if true (non-zero)
.018c09	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.018c0b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.018c0d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.018c0f	f0 01		beq $018c12			beq 	_ASFail
.018c11	60		rts				rts
.018c12					_ASFail:
.018c12	20 57 85	jsr $018557			jsr ERR_Handler
>018c15	41 73 73 65 72 74 00			.text "Assert",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/poke.asm

.018c1c					Command_POKE:
.018c1c	a9 01		lda #$01			lda 	#1
.018c1e	80 06		bra $018c26			bra 	CmdPoke_Main
.018c20					Command_DOKE:
.018c20	a9 02		lda #$02			lda 	#2
.018c22	80 02		bra $018c26			bra 	CmdPoke_Main
.018c24					Command_LOKE:
.018c24	a9 04		lda #$04			lda 	#4
.018c26					CmdPoke_Main:
.018c26	48		pha				pha
.018c27	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger 			; get two parameters.
.018c2a	e8		inx				inx
.018c2b	e8		inx				inx
.018c2c	e8		inx				inx
.018c2d	e8		inx				inx
.018c2e	e8		inx				inx
.018c2f	e8		inx				inx
.018c30	20 5f 95	jsr $01955f			jsr 	CheckNextComma
.018c33	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX
.018c36	a5 80		lda $80				lda 	XS_Mantissa+0 			; copy the mantissa into ZLTemp1 (address)
.018c38	85 1a		sta $1a				sta 	zLTemp1
.018c3a	a5 81		lda $81				lda 	XS_Mantissa+1
.018c3c	85 1b		sta $1b				sta 	zLTemp1+1
.018c3e	a5 82		lda $82				lda 	XS_Mantissa+2
.018c40	85 1c		sta $1c				sta 	zLTemp1+2
.018c42	a5 83		lda $83				lda 	XS_Mantissa+3
.018c44	85 1d		sta $1d				sta 	zLTemp1+3
.018c46	68		pla				pla 								; get count
.018c47	5a		phy				phy 								; save Y
.018c48	20 ea 94	jsr $0194ea			jsr 	MemWrite 					; write it out
.018c4b	7a		ply				ply 								; restore Y and done.
.018c4c	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/newold.asm

.018c4d					Command_NEW:
.018c4d	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018c4f	85 16		sta $16				sta 	zCodePtr+0
.018c51	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018c53	85 17		sta $17				sta 	zCodePtr+1
.018c55	a9 00		lda #$00			lda 	#0
.018c57	85 18		sta $18				sta 	zCodePtr+2
.018c59	85 19		sta $19				sta 	zCodePtr+3
.018c5b	a0 03		ldy #$03			ldy 	#3
.018c5d	a0 00		ldy #$00			ldy 	#0
.018c5f	a9 00		lda #$00			lda 	#0 							; write a 0 there.
.018c61	97 16		sta [$16],y			sta 	[zCodePtr],y
.018c63	20 fb 94	jsr $0194fb			jsr 	UpdateProgramEnd 			; update program end.
.018c66	4c 10 88	jmp $018810			jmp 	WarmStart
.018c69					Command_OLD:
.018c69	ea		nop				nop
.018c6a	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018c6c	85 16		sta $16				sta 	zCodePtr+0
.018c6e	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018c70	85 17		sta $17				sta 	zCodePtr+1
.018c72	a9 00		lda #$00			lda 	#0
.018c74	85 18		sta $18				sta 	zCodePtr+2
.018c76	85 19		sta $19				sta 	zCodePtr+3
.018c78	a0 03		ldy #$03			ldy 	#3
.018c7a					_COL_Find:
.018c7a	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018c7c	c8		iny				iny
.018c7d	c9 00		cmp #$00			cmp 	#0 							; if zero, then the position Y/Z is new offset
.018c7f	f0 18		beq $018c99			beq 	_COL_Found
.018c81	98		tya				tya
.018c82	c9 00		cmp #$00			cmp 	#0
.018c84	d0 f4		bne $018c7a			bne 	_COL_Find 					; can't find old EOL, give up.
.018c86	20 57 85	jsr $018557			jsr ERR_Handler
>018c89	50 72 6f 67 72 61 6d 20			.text "Program Corrupt",0
>018c91	43 6f 72 72 75 70 74 00
.018c99					_COL_Found:
.018c99	98		tya				tya
.018c9a	48		pha				pha
.018c9b	a0 00		ldy #$00			ldy 	#0
.018c9d	68		pla				pla
.018c9e	97 16		sta [$16],y			sta 	[zCodePtr],y
.018ca0	20 fb 94	jsr $0194fb			jsr 	UpdateProgramEnd 			; reset variable pointer
.018ca3	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/branch.asm

.018ca4					Command_GOTO:
.018ca4	20 c1 8c	jsr $018cc1			jsr 	GotoGetLineNumber
.018ca7	4c de 8c	jmp $018cde			jmp 	GotoChangeToLineNumber
.018caa					Command_GOSUB:
.018caa	20 c1 8c	jsr $018cc1			jsr 	GotoGetLineNumber
.018cad	20 e6 84	jsr $0184e6			jsr 	StackSavePosition
.018cb0	a9 05		lda #$05			lda 	#(SMark_Gosub << 4)+SourcePosSize
.018cb2	20 9f 84	jsr $01849f			jsr 	StackPushFrame
.018cb5	4c de 8c	jmp $018cde			jmp 	GotoChangeToLineNumber
.018cb8					Command_RETURN:
.018cb8	a9 00		lda #$00			lda 	#(SMark_Gosub << 4)
.018cba	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018cbd	20 03 85	jsr $018503			jsr 	StackRestorePosition
.018cc0	60		rts				rts
.018cc1					GotoGetLineNumber:
.018cc1	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger
.018cc4	a5 82		lda $82				lda 	XS_Mantissa+2 				; check range
.018cc6	05 83		ora $83				ora 	XS_Mantissa+3
.018cc8	d0 01		bne $018ccb			bne 	_GLINError
.018cca	60		rts				rts
.018ccb					_GLINError:
.018ccb	20 57 85	jsr $018557			jsr ERR_Handler
>018cce	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018cd6	20 4e 75 6d 62 65 72 00
.018cde					GotoChangeToLineNumber:
.018cde	a5 80		lda $80				lda 	XS_Mantissa+0 				; check line number not zero
.018ce0	05 81		ora $81				ora 	XS_Mantissa+1
.018ce2	f0 37		beq $018d1b			beq 	_GCTLFail
.018ce4	a9 00		lda #$00			lda 	#BasicProgram & $FF
.018ce6	85 16		sta $16				sta 	zCodePtr+0
.018ce8	a9 10		lda #$10			lda 	#BasicProgram >> 8
.018cea	85 17		sta $17				sta 	zCodePtr+1
.018cec	a9 00		lda #$00			lda 	#0
.018cee	85 18		sta $18				sta 	zCodePtr+2
.018cf0	85 19		sta $19				sta 	zCodePtr+3
.018cf2	a0 03		ldy #$03			ldy 	#3
.018cf4					_GCTLLoop:
.018cf4	a0 00		ldy #$00			ldy 	#0
.018cf6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cf8	c9 00		cmp #$00			cmp 	#0
.018cfa	f0 1f		beq $018d1b			beq 	_GCTLFail
.018cfc	c8		iny				iny
.018cfd	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018cff	c5 80		cmp $80				cmp 	XS_Mantissa+0
.018d01	d0 07		bne $018d0a			bne 	_GCTLNext
.018d03	c8		iny				iny
.018d04	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018d06	c5 81		cmp $81				cmp 	XS_Mantissa+1
.018d08	f0 0f		beq $018d19			beq 	_GCTLExit
.018d0a					_GCTLNext:
.018d0a	a0 00		ldy #$00			ldy 	#0 							; point to offset
.018d0c	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.018d0e	18		clc				clc
.018d0f	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.018d11	85 16		sta $16				sta 	zCodePtr
.018d13	90 02		bcc $018d17			bcc 	_SNLNoCarry
.018d15	e6 17		inc $17				inc 	zCodePtr+1
.018d17					_SNLNoCarry:
.018d17	80 db		bra $018cf4			bra 	_GCTLLoop 					; try next line.
.018d19					_GCTLExit:
.018d19	c8		iny				iny
.018d1a	60		rts				rts
.018d1b					_GCTLFail:
.018d1b	20 57 85	jsr $018557			jsr ERR_Handler
>018d1e	42 61 64 20 4c 69 6e 65			.text "Bad Line Number",0
>018d26	20 4e 75 6d 62 65 72 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/clr.asm

.018d2e					Command_CLR:
.018d2e					ResetRunStatus:
.018d2e	20 34 96	jsr $019634			jsr 	VariableClear
.018d31	20 8d 84	jsr $01848d			jsr 	StackReset
.018d34	a9 00		lda #$00			lda 	#HighMemory & $FF
.018d36	8d 00 03	sta $0300			sta 	StringPtr
.018d39	a9 7f		lda #$7f			lda 	#HighMemory >> 8
.018d3b	8d 01 03	sta $0301			sta 	StringPtr+1
.018d3e	20 fe 97	jsr $0197fe			jsr 	ArrayResetDefault
.018d41	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/stop.asm

.018d42					Command_STOP:
.018d42	20 57 85	jsr $018557			jsr ERR_Handler
>018d45	53 74 6f 70 00				.text "Stop",0

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/while.asm

.018d4a					Command_WHILE:
.018d4a	20 e6 84	jsr $0184e6			jsr 	StackSavePosition			; save position into stack, but don't yet push.
.018d4d	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger 			; calculate the while loop value.
.018d50	a5 80		lda $80				lda 	XS_Mantissa+0				; check the result if zero
.018d52	05 81		ora $81				ora 	XS_Mantissa+1
.018d54	05 82		ora $82				ora 	XS_Mantissa+2
.018d56	05 83		ora $83				ora 	XS_Mantissa+3
.018d58	f0 06		beq $018d60			beq 	_CWHSkip 					; if it is zero, then skip to WEND.
.018d5a	a9 25		lda #$25			lda 	#(SMark_While << 4)+SourcePosSize
.018d5c	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on stack
.018d5f	60		rts				rts
.018d60					_CWHSkip:
.018d60	a9 95		lda #$95			lda 	#token_Wend 				; look for the WEND token.
.018d62	20 00 84	jsr $018400			jsr 	StructureSearchSingle
.018d65	c8		iny				iny
.018d66	60		rts				rts
.018d67					Command_WEND:
.018d67	a9 20		lda #$20			lda 	#(SMark_While << 4)			; remove the frame
.018d69	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018d6c	20 03 85	jsr $018503			jsr 	StackRestorePosition
.018d6f	80 d9		bra $018d4a			bra 	Command_WHILE 				; and do the while again.
.018d71	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/commands/structure/repeat.asm

.018d72					Command_REPEAT:
.018d72	20 e6 84	jsr $0184e6			jsr 	StackSavePosition			; save position into stack
.018d75	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018d77	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; push on stack
.018d7a	60		rts				rts
.018d7b					Command_UNTIL:
.018d7b	a9 10		lda #$10			lda 	#(SMark_Repeat << 4)		; remove the frame
.018d7d	20 b6 84	jsr $0184b6			jsr 	StackPopFrame
.018d80	20 2f 8f	jsr $018f2f			jsr 	EvaluateInteger				; work out UNTIL
.018d83	a5 80		lda $80				lda 	XS_Mantissa+0 				; check if zero.
.018d85	05 81		ora $81				ora 	XS_Mantissa+1
.018d87	05 82		ora $82				ora 	XS_Mantissa+2
.018d89	05 83		ora $83				ora 	XS_Mantissa+3
.018d8b	d0 08		bne $018d95			bne 	_CUTExit 					; if not, just exit
.018d8d	20 03 85	jsr $018503			jsr 	StackRestorePosition 		; otherwise loop round again.
.018d90	a9 15		lda #$15			lda 	#(SMark_Repeat << 4)+SourcePosSize
.018d92	20 9f 84	jsr $01849f			jsr 	StackPushFrame 				; fix the stack back.
.018d95					_CUTExit:
.018d95	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/evaluate.asm

.018d96					EVESyntax:
.018d96	4c 28 85	jmp $018528			jmp 	SyntaxError
.018d99					EvaluateExpression:
.018d99	a2 00		ldx #$00			ldx 	#0 							; start with stack at 0.
.018d9b					EvaluateExpressionX:
.018d9b	a9 00		lda #$00			lda 	#0 							; start at precedence level 0.
.018d9d					EvaluateExpressionXA:
.018d9d	48		pha				pha 								; save precedence on stack.
.018d9e	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018da0	f0 f4		beq $018d96			beq 	EVESyntax 					; end of line, syntax error.
.018da2	c9 1b		cmp #$1b			cmp 	#26+1 						; is it A-Z ?
.018da4	b0 03		bcs $018da9			bcs 	_EVNotVariable
.018da6	4c 73 8e	jmp $018e73			jmp 	_EVVariableHandler 			; if so, go to the variable handler.
.018da9					_EVNotVariable:
.018da9	c9 40		cmp #$40			cmp 	#$40 						; up to $40, syntax error.
.018dab	90 e9		bcc $018d96			bcc 	EVESyntax
.018dad	c9 80		cmp #$80			cmp 	#$80 						; $40-$7F not integer
.018daf	b0 58		bcs $018e09			bcs 	_EVNotInteger
.018db1	20 a1 8e	jsr $018ea1			jsr 	EvaluateGetInteger
.018db4					_EVCheckDecimal:
.018db4	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018db6	c9 fd		cmp #$fd			cmp 	#$FD 						; decimal ?
.018db8	d0 05		bne $018dbf			bne 	_EVGotAtom 					; no, get atom.
.018dba					_EVIsDecimal:
.018dba	20 c7 8e	jsr $018ec7			jsr 	EVGetDecimal 				; extend to the decimal part.
.018dbd	80 00		bra $018dbf			bra 	_EVGotAtom 					; and continue to got atom.
.018dbf					_EVGotAtom:
.018dbf	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dc1	10 44		bpl $018e07			bpl 	_EVExitDrop 				; must be a token.
.018dc3	c9 8f		cmp #$8f			cmp 	#firstKeywordPlus  			; check it's in the binary token range (they're first)
.018dc5	b0 40		bcs $018e07			bcs 	_EVExitDrop
.018dc7	68		pla				pla 								; get current precedence
.018dc8	85 1e		sta $1e				sta 	zGenPtr 					; save in zGenPtr as temp.
.018dca	da		phx				phx 								; save X
.018dcb	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018dcd	aa		tax				tax 								; put in X
.018dce	bf 0c 86 01	lda $01860c,x			lda 	BinaryPrecedence-$80,x 		; read the binary precedence.
.018dd2	85 1f		sta $1f				sta 	zGenPtr+1 					; save it.
.018dd4	fa		plx				plx 								; restore X
.018dd5	c5 1e		cmp $1e				cmp 	zGenPtr 					; compared against the current precedence
.018dd7	90 2f		bcc $018e08			bcc 	_EVExit 					; exit if too low.
.018dd9	f0 2d		beq $018e08			beq 	_EVExit 					; exit if equals
.018ddb	a5 1e		lda $1e				lda 	zGenPtr 					; push precedence
.018ddd	48		pha				pha
.018dde	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018de0	48		pha				pha
.018de1	c8		iny				iny
.018de2	da		phx				phx 								; save current position
.018de3	e8		inx				inx
.018de4	e8		inx				inx
.018de5	e8		inx				inx
.018de6	e8		inx				inx
.018de7	e8		inx				inx
.018de8	e8		inx				inx
.018de9	a5 1f		lda $1f				lda 	zGenPtr+1 					; get the precedence of the operator in A.
.018deb	20 9d 8d	jsr $018d9d			jsr 	EvaluateExpressionXA 		; do the RHS.
.018dee	fa		plx				plx 								; restore X
.018def	68		pla				pla 								; get the binary operator in A.
.018df0					_EVCallA:
.018df0	da		phx				phx 								; save X again
.018df1	0a		asl a				asl 	a 							; double, lose the MSB.
.018df2	aa		tax				tax									; put in X
.018df3	bf bb 85 01	lda $0185bb,x			lda 	VectorTable,x 				; copy address into zGenPtr
.018df7	8d 11 03	sta $0311			sta 	LocalVector+1
.018dfa	bf bc 85 01	lda $0185bc,x			lda 	VectorTable+1,x
.018dfe	8d 12 03	sta $0312			sta 	LocalVector+2
.018e01	fa		plx				plx 								; restore X
.018e02	20 7c 8e	jsr $018e7c			jsr 	EVCallLocalVector
.018e05	80 b8		bra $018dbf			bra 	_EVGotAtom 					; and loop back.
.018e07					_EVExitDrop:
.018e07	68		pla				pla
.018e08					_EVExit:
.018e08	60		rts				rts
.018e09					_EVNotInteger:
.018e09	c8		iny				iny
.018e0a	c9 8b		cmp #$8b			cmp 	#token_minus 				; is it unary minus ?
.018e0c	d0 16		bne $018e24			bne 	_EVNotMinus
.018e0e	20 10 8f	jsr $018f10			jsr 	EvaluateGetAtomX 			; get a numeric value into X.
.018e11	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.018e13	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.018e15	f0 05		beq $018e1c			beq 	_EVMinusFloat
.018e17	20 bd 9a	jsr $019abd			jsr 	IntegerNegateAlways 		; negation
.018e1a	80 a3		bra $018dbf			bra 	_EVGotAtom 					; and go back.
.018e1c					_EVMinusFloat:
.018e1c	b5 85		lda $85,x			lda 	XS_Type,x 					; invert the sign bit.
.018e1e	49 80		eor #$80			eor 	#$80
.018e20	95 85		sta $85,x			sta 	XS_Type,x
.018e22	80 9b		bra $018dbf			bra 	_EVGotAtom
.018e24					_EVNotMinus:
.018e24	c9 bd		cmp #$bd			cmp 	#token_lparen 				; is it left parenthesis
.018e26	d0 17		bne $018e3f			bne 	_EVNotParenthesis
.018e28	20 9b 8d	jsr $018d9b			jsr 	EvaluateExpressionX 		; full evaluate at level x.
.018e2b	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018e2d	c8		iny				iny
.018e2e	c9 be		cmp #$be			cmp 	#token_rparen 				; okay if right bracket.
.018e30	f0 8d		beq $018dbf			beq 	_EVGotAtom
.018e32	20 57 85	jsr $018557			jsr ERR_Handler
>018e35	4d 69 73 73 69 6e 67 20			.text "Missing )",0
>018e3d	29 00
.018e3f					_EVNotParenthesis:
.018e3f	c9 98		cmp #$98			cmp 	#token_not 					; is it not ?
.018e41	d0 0c		bne $018e4f			bne 	_EVNotNot
.018e43	20 10 8f	jsr $018f10			jsr 	EvaluateGetAtomX 			; get expression in parenthesis.
.018e46	20 16 9f	jsr $019f16			jsr 	FPUToInteger 				; make it an integer - if possible.
.018e49	20 f5 8e	jsr $018ef5			jsr 	NotInteger 					; do the not calculation
.018e4c	4c bf 8d	jmp $018dbf			jmp 	_EVGotAtom
.018e4f					_EVNotNot:
.018e4f	c9 fe		cmp #$fe			cmp 	#$FE
.018e51	d0 12		bne $018e65			bne 	_EVNotString
.018e53	20 d2 95	jsr $0195d2			jsr 	CreateTempStringCopy 		; copy of string in code in temporary memory.
.018e56	a5 20		lda $20				lda 	zTempStr 					; copy address of string into mantissa
.018e58	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018e5a	a5 21		lda $21				lda 	zTempStr+1
.018e5c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018e5e	a9 02		lda #$02			lda 	#2 							; set to type 2 (e.g. string)
.018e60	95 85		sta $85,x			sta 	XS_Type,x
.018e62	4c bf 8d	jmp $018dbf			jmp 	_EVGotAtom
.018e65					_EVNotString:
.018e65	c9 98		cmp #$98			cmp 	#firstUnaryFunction
.018e67	90 04		bcc $018e6d			bcc 	_EVBadElement
.018e69	c9 b7		cmp #$b7			cmp 	#lastUnaryFunction+1
.018e6b	90 03		bcc $018e70			bcc 	_EVUnaryFunction
.018e6d					_EVBadElement:
.018e6d	4c 28 85	jmp $018528			jmp 	SyntaxError
.018e70					_EVUnaryFunction:
.018e70	4c f0 8d	jmp $018df0			jmp 	_EVCallA
.018e73					_EVVariableHandler:
.018e73	20 f8 95	jsr $0195f8			jsr 	VariableFind 				; locate a variable
.018e76	20 40 99	jsr $019940			jsr 	VariableGet 				; copy into memory.
.018e79	4c bf 8d	jmp $018dbf			jmp 	_EVGotAtom 					; and go round.
.018e7c					EVCallLocalVector:
.018e7c	6c 11 03	jmp ($0311)			jmp 	(LocalVector+1)
.018e7f					EVShiftMantissaLeft6:
.018e7f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 				; copy up, using exponent as a temp
.018e81	95 84		sta $84,x			sta 	XS_Exponent,x
.018e83	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018e85	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018e87	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018e89	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018e8b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018e8d	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018e8f	a9 00		lda #$00			lda 	#0
.018e91	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018e93	20 96 8e	jsr $018e96			jsr 	_EVSMLShift 					; call it here to do it twice
.018e96					_EVSMLShift:
.018e96	56 84		lsr $84,x			lsr 	XS_Exponent,x
.018e98	76 83		ror $83,x			ror 	XS_Mantissa+3,x
.018e9a	76 82		ror $82,x			ror 	XS_Mantissa+2,x
.018e9c	76 81		ror $81,x			ror 	XS_Mantissa+1,x
.018e9e	76 80		ror $80,x			ror 	XS_Mantissa+0,x
.018ea0	60		rts				rts
.018ea1					EvaluateGetInteger:
.018ea1	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ea3	29 3f		and #$3f			and 	#$3F 						; it's a constant 0-63
.018ea5	95 80		sta $80,x			sta 	XS_Mantissa,x 				; put into the mantissa space (32 bit integer)
.018ea7	a9 00		lda #$00			lda 	#0
.018ea9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018eab	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018ead	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018eaf	1a		inc a				inc 	a 							; set to type 1 (integer)
.018eb0	95 85		sta $85,x			sta 	XS_Type,x
.018eb2					_EVCheckNextInteger:
.018eb2	c8		iny				iny
.018eb3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018eb5	49 40		eor #$40			eor 	#$40 						; 40-7F now 00-3F.
.018eb7	c9 40		cmp #$40			cmp 	#$40 						; if not, we have an atom.
.018eb9	b0 0b		bcs $018ec6			bcs 	_EVEndInteger
.018ebb	48		pha				pha 								; save it.
.018ebc	20 7f 8e	jsr $018e7f			jsr 	EVShiftMantissaLeft6 		; shift the mantissa left 6.
.018ebf	68		pla				pla
.018ec0	15 80		ora $80,x			ora 	XS_Mantissa+0,x 			; put in lower 6 bits.
.018ec2	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018ec4	80 ec		bra $018eb2			bra 	_EVCheckNextInteger
.018ec6					_EVEndInteger:
.018ec6	60		rts				rts
.018ec7					EVGetDecimal:
.018ec7	a9 2e		lda #$2e			lda 	#'.'							; put DP in NUM_Buffer
.018ec9	8d 15 03	sta $0315			sta 	Num_Buffer
.018ecc	da		phx				phx
.018ecd	c8		iny				iny
.018ece	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ed0	c8		iny				iny
.018ed1	3a		dec a				dec 	a								; convert to a string length.
.018ed2	3a		dec a				dec 	a
.018ed3	a2 01		ldx #$01			ldx 	#1 								; offset in X.
.018ed5					_EVGDCopy:
.018ed5	48		pha				pha 									; save count
.018ed6	b7 16		lda [$16],y			lda 	[zCodePtr],y
.018ed8	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.018edb	e8		inx				inx 									; forward ....
.018edc	c8		iny				iny
.018edd	68		pla				pla 									; get count
.018ede	3a		dec a				dec 	a 								; until zero
.018edf	d0 f4		bne $018ed5			bne 	_EVGDCopy
.018ee1	9d 15 03	sta $0315,x			sta 	Num_Buffer,x 					; make string ASCIIZ.
.018ee4	fa		plx				plx 									; restore X
.018ee5	a9 15		lda #$15			lda 	#Num_Buffer & $FF 				; set zGenPtr
.018ee7	85 1e		sta $1e				sta 	zGenPtr
.018ee9	a9 03		lda #$03			lda 	#Num_Buffer >> 8
.018eeb	85 1f		sta $1f				sta 	zGenPtr+1
.018eed	5a		phy				phy 									; save Y
.018eee	a0 00		ldy #$00			ldy 	#0 								; start position
.018ef0	20 d0 a0	jsr $01a0d0			jsr 	FPFromString 					; convert current
.018ef3	7a		ply				ply 									; restore Y
.018ef4	60		rts				rts
.018ef5					NotInteger:
.018ef5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.018ef7	49 ff		eor #$ff			eor 	#$FF
.018ef9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018efb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018efd	49 ff		eor #$ff			eor 	#$FF
.018eff	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f01	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.018f03	49 ff		eor #$ff			eor 	#$FF
.018f05	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018f07	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.018f09	49 ff		eor #$ff			eor 	#$FF
.018f0b	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018f0d	60		rts				rts
.018f0e					EvaluateGetAtom:
.018f0e	a2 00		ldx #$00			ldx 	#0 								; start at the bottom :)
.018f10					EvaluateGetAtomX:
.018f10	a9 08		lda #$08			lda 	#8 								; very high precedence so no binary operations.
.018f12	20 9d 8d	jsr $018d9d			jsr 	EvaluateExpressionXA
.018f15	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0 (float) 1 (integer)
.018f17	29 0f		and #$0f			and 	#15
.018f19	c9 02		cmp #$02			cmp 	#2
.018f1b	b0 01		bcs $018f1e			bcs 	EvaluateType
.018f1d	60		rts				rts
.018f1e					EvaluateType:
.018f1e	4c 38 85	jmp $018538			jmp 	TypeError
.018f21					EvaluateNumber:
.018f21	a2 00		ldx #$00			ldx 	#0
.018f23					EvaluateNumberX:
.018f23	20 9b 8d	jsr $018d9b			jsr 	EvaluateExpressionX
.018f26	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 0/1
.018f28	29 0f		and #$0f			and 	#15
.018f2a	c9 02		cmp #$02			cmp 	#2
.018f2c	b0 f0		bcs $018f1e			bcs 	EvaluateType
.018f2e	60		rts				rts
.018f2f					EvaluateInteger:
.018f2f	a2 00		ldx #$00			ldx 	#0
.018f31					EvaluateIntegerX:
.018f31	20 23 8f	jsr $018f23			jsr 	EvaluateNumberX
.018f34	20 16 9f	jsr $019f16			jsr 	FPUToInteger
.018f37	60		rts				rts
.018f38					EvaluateString:
.018f38	a2 00		ldx #$00			ldx 	#0
.018f3a					EvaluateStringX:
.018f3a	20 9b 8d	jsr $018d9b			jsr 	EvaluateExpressionX
.018f3d	b5 85		lda $85,x			lda 	XS_Type,x 						; check type is 2
.018f3f	29 0f		and #$0f			and 	#15
.018f41	c9 02		cmp #$02			cmp 	#2
.018f43	d0 d9		bne $018f1e			bne 	EvaluateType
.018f45	b5 80		lda $80,x			lda 	XS_Mantissa,x 					; copy to zGenPtr
.018f47	85 1e		sta $1e				sta 	zGenPtr
.018f49	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.018f4b	85 1f		sta $1f				sta 	zGenPtr+1
.018f4d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/logical.asm

.018f4e					BinaryOp_And:
.018f4e	20 a2 8f	jsr $018fa2			jsr 	BinaryMakeBothInteger
.018f51	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018f53	35 86		and $86,x			and 	XS2_Mantissa+0,x
.018f55	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018f57	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018f59	35 87		and $87,x			and 	XS2_Mantissa+1,x
.018f5b	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f5d	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018f5f	35 88		and $88,x			and 	XS2_Mantissa+2,x
.018f61	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018f63	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018f65	35 89		and $89,x			and 	XS2_Mantissa+3,x
.018f67	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018f69	60		rts				rts
.018f6a					BinaryOp_Or:
.018f6a	20 a2 8f	jsr $018fa2			jsr 	BinaryMakeBothInteger
.018f6d	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018f6f	15 86		ora $86,x			ora 	XS2_Mantissa+0,x
.018f71	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018f73	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018f75	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.018f77	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f79	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018f7b	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.018f7d	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018f7f	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018f81	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.018f83	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018f85	60		rts				rts
.018f86					BinaryOp_Eor:
.018f86					BinaryOp_Xor:
.018f86	20 a2 8f	jsr $018fa2			jsr 	BinaryMakeBothInteger
.018f89	b5 80		lda $80,x			lda		XS_Mantissa+0,x
.018f8b	55 86		eor $86,x			eor 	XS2_Mantissa+0,x
.018f8d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.018f8f	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.018f91	55 87		eor $87,x			eor 	XS2_Mantissa+1,x
.018f93	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018f95	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.018f97	55 88		eor $88,x			eor 	XS2_Mantissa+2,x
.018f99	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018f9b	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.018f9d	55 89		eor $89,x			eor 	XS2_Mantissa+3,x
.018f9f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018fa1	60		rts				rts
.018fa2					BinaryMakeBothInteger:
.018fa2	da		phx				phx 								; save X
.018fa3	e8		inx				inx
.018fa4	e8		inx				inx
.018fa5	e8		inx				inx
.018fa6	e8		inx				inx
.018fa7	e8		inx				inx
.018fa8	e8		inx				inx
.018fa9	20 ad 8f	jsr $018fad			jsr 	BinaryMakeInteger 			; convert to integer.
.018fac	fa		plx				plx 								; restore X and fall through.
.018fad					BinaryMakeInteger:
.018fad	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.018faf	29 0f		and #$0f			and 	#15 						; check type zero
.018fb1	f0 04		beq $018fb7			beq 	_BMIConvert 				; if float convert to integer.
.018fb3	4a		lsr a				lsr 	a 							; if bit 0 clear it's not an integer
.018fb4	90 04		bcc $018fba			bcc 	_BMIError
.018fb6	60		rts				rts
.018fb7					_BMIConvert:
.018fb7	4c 16 9f	jmp $019f16			jmp 	FPUToInteger 				; convert to integer
.018fba					_BMIError:
.018fba	4c 38 85	jmp $018538			jmp 	TypeError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/compare.asm

.018fbd					Binary_Equal:
.018fbd	20 04 90	jsr $019004			jsr 	CompareValues
.018fc0	09 00		ora #$00			ora 	#0
.018fc2	f0 04		beq $018fc8			beq 	CCTrue
.018fc4	a9 00		lda #$00	CCFalse:lda 	#0							; set false
.018fc6	80 02		bra $018fca			bra 	CCWrite
.018fc8	a9 ff		lda #$ff	CCTrue:	lda 	#$FF 						; set true
.018fca	95 80		sta $80,x	CCWrite:sta 	XS_Mantissa+0,x 			; write into integer slot
.018fcc	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.018fce	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.018fd0	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.018fd2	a9 01		lda #$01			lda 	#1
.018fd4	95 85		sta $85,x			sta 	XS_Type,x 					; set type to integer whatever.
.018fd6	60		rts				rts
.018fd7					Binary_NotEqual:
.018fd7	20 04 90	jsr $019004			jsr 	CompareValues
.018fda	09 00		ora #$00			ora 	#0
.018fdc	f0 e6		beq $018fc4			beq 	CCFalse
.018fde	80 e8		bra $018fc8			bra 	CCTrue
.018fe0					Binary_Less:
.018fe0	20 04 90	jsr $019004			jsr 	CompareValues
.018fe3	09 00		ora #$00			ora 	#0
.018fe5	30 e1		bmi $018fc8			bmi 	CCTrue
.018fe7	80 db		bra $018fc4			bra 	CCFalse
.018fe9					Binary_LessEqual:
.018fe9	20 04 90	jsr $019004			jsr 	CompareValues
.018fec	c9 01		cmp #$01			cmp 	#1
.018fee	d0 d8		bne $018fc8			bne 	CCTrue
.018ff0	80 d2		bra $018fc4			bra 	CCFalse
.018ff2					Binary_GreaterEqual:
.018ff2	20 04 90	jsr $019004			jsr 	CompareValues
.018ff5	09 00		ora #$00			ora 	#0
.018ff7	10 cf		bpl $018fc8			bpl 	CCTrue
.018ff9	80 c9		bra $018fc4			bra 	CCFalse
.018ffb					Binary_Greater:
.018ffb	20 04 90	jsr $019004			jsr 	CompareValues
.018ffe	c9 01		cmp #$01			cmp 	#1
.019000	f0 c6		beq $018fc8			beq 	CCTrue
.019002	80 c0		bra $018fc4			bra 	CCFalse
.019004					CompareValues:
.019004	b5 85		lda $85,x			lda 	XS_Type,x 					; and the types together
.019006	35 8b		and $8b,x			and 	XS2_Type,x
.019008	c9 02		cmp #$02			cmp 	#2
.01900a	f0 11		beq $01901d			beq 	_CVString
.01900c	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01900e	35 8b		and $8b,x			and 	XS2_Type,x
.019010	4a		lsr a				lsr 	a 							; shift bit 0 into C
.019011	90 03		bcc $019016			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.019013	4c 5f 90	jmp $01905f			jmp 	CompareInteger32 							; so execute code at \1
.019016					_BCFloat:
.019016	20 03 91	jsr $019103			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019019	4c 4c 9e	jmp $019e4c			jmp 	FPCompare 							; and execute code at \2
.01901c	60		rts				rts
.01901d					_CVString:
.01901d	da		phx				phx 								; save XY
.01901e	5a		phy				phy
.01901f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.019021	85 1a		sta $1a				sta		zLTemp1+0
.019023	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019025	85 1b		sta $1b				sta 	zLTemp1+1
.019027	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019029	85 1c		sta $1c				sta 	zLTemp1+2
.01902b	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01902d	85 1d		sta $1d				sta 	zLTemp1+3
.01902f	a0 00		ldy #$00			ldy 	#0 							; find the shorter string length, we compare this.
.019031	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019033	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019035	90 02		bcc $019039			bcc 	_CVCommon
.019037	b1 1c		lda ($1c),y			lda 	(zLTemp1+2),y
.019039					_CVCommon:
.019039	aa		tax				tax 								; put shorter string length in zero.
.01903a	f0 0c		beq $019048			beq 	_CVMatch 					; if the shorter is zero, then the 'common parts' match
.01903c					_CVCompare:
.01903c	c8		iny				iny 								; next character
.01903d	b1 1a		lda ($1a),y			lda 	(zLTemp1),y 				; compare characters
.01903f	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.019041	90 13		bcc $019056			bcc 	_CVReturnLess 				; <
.019043	d0 15		bne $01905a			bne 	_CVReturnGreater 			; >
.019045	ca		dex				dex 								; until common length matched.
.019046	d0 f4		bne $01903c			bne 	_CVCompare
.019048					_CVMatch:
.019048	a0 00		ldy #$00			ldy 	#0
.01904a	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01904c	d1 1c		cmp ($1c),y			cmp 	(zLTemp1+2),y
.01904e	90 06		bcc $019056			bcc 	_CVReturnLess 				; <
.019050	d0 08		bne $01905a			bne 	_CVReturnGreater 			; >
.019052	a9 00		lda #$00			lda 	#0
.019054	80 06		bra $01905c			bra 	_CVExit 					; same common, same length, same string
.019056					_CVReturnLess:
.019056	a9 ff		lda #$ff			lda 	#$FF
.019058	80 02		bra $01905c			bra 	_CVExit
.01905a					_CVReturnGreater:
.01905a	a9 01		lda #$01			lda 	#$01
.01905c					_CVExit:
.01905c	7a		ply				ply
.01905d	fa		plx				plx
.01905e	60		rts				rts
.01905f					CompareInteger32:
.01905f	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; invert both sign flags, makes compare signed
.019061	49 80		eor #$80			eor 	#$80
.019063	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019065	b5 89		lda $89,x			lda 	XS2_Mantissa+3,x
.019067	49 80		eor #$80			eor 	#$80
.019069	95 89		sta $89,x			sta 	XS2_Mantissa+3,x
.01906b	20 e9 90	jsr $0190e9			jsr 	SubInteger32 				; subtraction
.01906e	90 0d		bcc $01907d			bcc 	_CI32Less 					; cc return -1
.019070	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; check if zero
.019072	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019074	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019076	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019078	f0 02		beq $01907c			beq 	_CI32Exit
.01907a	a9 01		lda #$01			lda 	#1							; otherwise it's positive
.01907c					_CI32Exit:
.01907c	60		rts				rts
.01907d					_CI32Less:
.01907d	a9 ff		lda #$ff			lda 	#$FF
.01907f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/arithmetic.asm

.019080					BinaryOp_Add:
.019080	b5 85		lda $85,x			lda 	XS_Type,x  					; and types together
.019082	35 8b		and $8b,x			and 	XS2_Type,x
.019084	29 02		and #$02			and 	#2 							; if bit 1 set they are both strings
.019086	d0 11		bne $019099			bne 	_BOAString
.019088	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01908a	35 8b		and $8b,x			and 	XS2_Type,x
.01908c	4a		lsr a				lsr 	a 							; shift bit 0 into C
.01908d	90 03		bcc $019092			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.01908f	4c cf 90	jmp $0190cf			jmp 	AddInteger32 							; so execute code at \1
.019092					_BCFloat:
.019092	20 03 91	jsr $019103			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.019095	4c 27 9c	jmp $019c27			jmp 	FPAdd 							; and execute code at \2
.019098	60		rts				rts
.019099					_BOAString:
.019099	4c 1d 91	jmp $01911d			jmp 	ConcatenateString 			; concatenate two strings.
.01909c					BinaryOp_Subtract:
.01909c	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.01909e	35 8b		and $8b,x			and 	XS2_Type,x
.0190a0	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0190a1	90 03		bcc $0190a6			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0190a3	4c e9 90	jmp $0190e9			jmp 	SubInteger32 							; so execute code at \1
.0190a6					_BCFloat:
.0190a6	20 03 91	jsr $019103			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0190a9	4c 1f 9c	jmp $019c1f			jmp 	FPSubtract 							; and execute code at \2
.0190ac	60		rts				rts
.0190ad					BinaryOp_Multiply:
.0190ad	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0190af	35 8b		and $8b,x			and 	XS2_Type,x
.0190b1	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0190b2	90 03		bcc $0190b7			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0190b4	4c f8 99	jmp $0199f8			jmp 	MulInteger32 							; so execute code at \1
.0190b7					_BCFloat:
.0190b7	20 03 91	jsr $019103			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0190ba	4c 4e 9d	jmp $019d4e			jmp 	FPMultiply 							; and execute code at \2
.0190bd	60		rts				rts
.0190be					BinaryOp_Divide:
.0190be	b5 85		lda $85,x			lda 	XS_Type,x 					; and 2 type bytes together.
.0190c0	35 8b		and $8b,x			and 	XS2_Type,x
.0190c2	4a		lsr a				lsr 	a 							; shift bit 0 into C
.0190c3	90 03		bcc $0190c8			bcc 	_BCFloat 					; if zero, they aren't both integer, so do it as float
.0190c5	4c 36 9a	jmp $019a36			jmp 	DivInteger32 							; so execute code at \1
.0190c8					_BCFloat:
.0190c8	20 03 91	jsr $019103			jsr 	BinaryMakeBothFloat 		; validate they are floats, make them both float.
.0190cb	4c db 9c	jmp $019cdb			jmp 	FPDivide 							; and execute code at \2
.0190ce	60		rts				rts
.0190cf					AddInteger32:
.0190cf	18		clc				clc
.0190d0	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0190d2	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.0190d4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190d6	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190d8	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.0190da	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190dc	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0190de	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.0190e0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190e2	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0190e4	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.0190e6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.0190e8	60		rts				rts
.0190e9					SubInteger32:
.0190e9	38		sec				sec
.0190ea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0190ec	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.0190ee	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0190f0	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0190f2	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.0190f4	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0190f6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0190f8	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.0190fa	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.0190fc	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0190fe	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019100	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019102	60		rts				rts
.019103					BinaryMakeBothFloat:
.019103	da		phx				phx 								; save X
.019104	e8		inx				inx
.019105	e8		inx				inx
.019106	e8		inx				inx
.019107	e8		inx				inx
.019108	e8		inx				inx
.019109	e8		inx				inx
.01910a	20 0e 91	jsr $01910e			jsr 	BinaryMakeFloat 			; convert to float.
.01910d	fa		plx				plx 								; restore X and fall through.
.01910e					BinaryMakeFloat:
.01910e	b5 85		lda $85,x			lda 	XS_Type,x 					; get type byte.
.019110	4a		lsr a				lsr 	a 							; if bit 0 set, it's integer so convert
.019111	b0 04		bcs $019117			bcs 	_BMFConvert
.019113	4a		lsr a				lsr 	a 							; if bit 1 set, it's a string so error (type)
.019114	b0 04		bcs $01911a			bcs 	_BMFError
.019116	60		rts				rts
.019117					_BMFConvert:
.019117	4c ca 9e	jmp $019eca			jmp 	FPUToFloat 					; convert to float
.01911a					_BMFError:
.01911a	4c 38 85	jmp $018538			jmp 	TypeError
.01911d					ConcatenateString:
.01911d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy string addresses to ZLTemp and ZLTemp+2
.01911f	85 1a		sta $1a				sta		zLTemp1+0
.019121	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019123	85 1b		sta $1b				sta 	zLTemp1+1
.019125	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x
.019127	85 1c		sta $1c				sta 	zLTemp1+2
.019129	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.01912b	85 1d		sta $1d				sta 	zLTemp1+3
.01912d	5a		phy				phy
.01912e	a0 00		ldy #$00			ldy 	#0 							; work out total length.
.019130	b1 1a		lda ($1a),y			lda 	(zlTemp1),y
.019132	71 1c		adc ($1c),y			adc 	(zlTemp1+2),y
.019134	7a		ply				ply
.019135	b0 33		bcs $01916a			bcs 	_CSError					; check in range.
.019137	c9 fe		cmp #$fe			cmp 	#maxString+1
.019139	b0 2f		bcs $01916a			bcs 	_CSError
.01913b	20 97 95	jsr $019597			jsr 	AllocateTempString 			; store the result
.01913e	20 55 91	jsr $019155			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.019141	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; point zLTemp1 to second string
.019143	85 1a		sta $1a				sta 	zLTemp1
.019145	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x
.019147	85 1b		sta $1b				sta 	zLTemp1+1
.019149	20 55 91	jsr $019155			jsr 	_CSCopyString 				; copy zlTemp1 string in.
.01914c	a5 20		lda $20				lda 	zTempStr 					; point current to new string
.01914e	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019150	a5 21		lda $21				lda 	zTempStr+1
.019152	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019154	60		rts				rts
.019155					_CSCopyString:
.019155	da		phx				phx
.019156	5a		phy				phy
.019157	a0 00		ldy #$00			ldy 	#0 							; get length
.019159	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.01915b	f0 0a		beq $019167			beq 	_CSCSExit 					; if zero, exit
.01915d	aa		tax				tax 								; put in X
.01915e					_CSCSLoop:
.01915e	c8		iny				iny 								; get next char
.01915f	b1 1a		lda ($1a),y			lda 	(zLTemp1),y
.019161	20 c2 95	jsr $0195c2			jsr		WriteTempString 			; copy out
.019164	ca		dex				dex 								; do whole string
.019165	d0 f7		bne $01915e			bne 	_CSCSLoop
.019167					_CSCSExit:
.019167	7a		ply				ply
.019168	fa		plx				plx
.019169	60		rts				rts
.01916a					_CSError:
.01916a	20 57 85	jsr $018557			jsr ERR_Handler
>01916d	53 74 72 69 6e 67 20 74			.text "String too long",0
>019175	6f 6f 20 6c 6f 6e 67 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/sgn.asm

.01917d					Unary_Sgn:
.01917d	20 23 8f	jsr $018f23			jsr 	EvaluateNumberX 			; get value
.019180	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; check right bracket.
.019183	20 a1 91	jsr $0191a1			jsr 	GetSignCurrent 				; get sign.
.019186	09 00		ora #$00			ora 	#0
.019188	10 08		bpl $019192			bpl		UnarySetAInteger			; if 0,1 return that.
.01918a	80 00		bra $01918c			bra 	UnarySetAMinus1 			; -1 return $FFFFF...
.01918c					UnarySetAMinus1:
.01918c	a9 ff		lda #$ff			lda 	#$FF
.01918e	95 80		sta $80,x			sta 	XS_Mantissa,x
.019190	80 04		bra $019196			bra 	UnarySetAFill
.019192					UnarySetAInteger:
.019192	95 80		sta $80,x			sta 	XS_Mantissa,x
.019194	a9 00		lda #$00			lda 	#0
.019196					UnarySetAFill:
.019196	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019198	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01919a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01919c	a9 01		lda #$01			lda 	#1
.01919e	95 85		sta $85,x			sta 	XS_Type,x
.0191a0	60		rts				rts
.0191a1					GetSignCurrent:
.0191a1	b5 85		lda $85,x			lda 	XS_Type,x 					; identify type.
.0191a3	4a		lsr a				lsr 	a 							; if LSB set it is integer.
.0191a4	90 15		bcc $0191bb			bcc 	_GSCFloat
.0191a6	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0191a8	30 0e		bmi $0191b8			bmi 	_GSCMinus1
.0191aa	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.0191ac	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.0191ae	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0191b0	d0 03		bne $0191b5			bne 	_GSCPlus1
.0191b2					_GSCZero:
.0191b2	a9 00		lda #$00			lda 	#0
.0191b4	60		rts				rts
.0191b5					_GSCPlus1:
.0191b5	a9 01		lda #$01			lda 	#$01
.0191b7	60		rts				rts
.0191b8					_GSCMinus1:
.0191b8	a9 ff		lda #$ff			lda 	#$FF
.0191ba	60		rts				rts
.0191bb					_GSCFloat:
.0191bb	34 85		bit $85,x			bit 	XS_Type,x
.0191bd	70 f3		bvs $0191b2			bvs 	_GSCZero
.0191bf	30 f7		bmi $0191b8			bmi 	_GSCMinus1
.0191c1	80 f2		bra $0191b5			bra 	_GSCPlus1

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/abs.asm

.0191c3					Unary_Abs:
.0191c3	20 23 8f	jsr $018f23			jsr 	EvaluateNumberX 			; get value
.0191c6	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; check right bracket.
.0191c9	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0191cb	29 0f		and #$0f			and 	#15 						; if type bits zero, it's float.
.0191cd	f0 07		beq $0191d6			beq 	_UAMinusFloat
.0191cf	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; check MSB
.0191d1	10 09		bpl $0191dc			bpl 	_UAExit
.0191d3	4c bd 9a	jmp $019abd			jmp 	IntegerNegateAlways 		; negation
.0191d6					_UAMinusFloat:
.0191d6	b5 85		lda $85,x			lda 	XS_Type,x 					; clear the sign bit.
.0191d8	29 7f		and #$7f			and		#$7F
.0191da	95 85		sta $85,x			sta 	XS_Type,x
.0191dc					_UAExit:
.0191dc	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/peek.asm

.0191dd					Unary_Peek:
.0191dd	a9 01		lda #$01			lda 	#1
.0191df	80 06		bra $0191e7			bra 	UPMain
.0191e1					Unary_Deek:
.0191e1	a9 02		lda #$02			lda 	#2
.0191e3	80 02		bra $0191e7			bra 	UPMain
.0191e5					Unary_Leek:
.0191e5	a9 04		lda #$04			lda 	#4
.0191e7					UPMain:
.0191e7	48		pha				pha 								; set bytes to copy.
.0191e8	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX 			; numeric parameter
.0191eb	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.0191ee	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy the mantissa into ZLTemp1 (address)
.0191f0	85 1a		sta $1a				sta 	zLTemp1
.0191f2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0191f4	85 1b		sta $1b				sta 	zLTemp1+1
.0191f6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0191f8	85 1c		sta $1c				sta 	zLTemp1+2
.0191fa	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0191fc	85 1d		sta $1d				sta 	zLTemp1+3
.0191fe	a9 00		lda #$00			lda 	#0 							; clear target area
.019200	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019202	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019204	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019206	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019208	68		pla				pla 								; restore bytes to copy
.019209	da		phx				phx 								; save XY
.01920a	5a		phy				phy
.01920b	20 d9 94	jsr $0194d9			jsr 	MemRead 					; read the bytes in
.01920e	7a		ply				ply 								; restore and exit
.01920f	fa		plx				plx
.019210	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/mod.asm

.019211					Unary_Mod:
.019211	20 39 92	jsr $019239			jsr 	_UMParameter 				; first parameter
.019214	20 5f 95	jsr $01955f			jsr 	CheckNextComma
.019217	da		phx				phx 								; second parameter
.019218	e8		inx				inx
.019219	e8		inx				inx
.01921a	e8		inx				inx
.01921b	e8		inx				inx
.01921c	e8		inx				inx
.01921d	e8		inx				inx
.01921e	20 39 92	jsr $019239			jsr 	_UMParameter
.019221	fa		plx				plx
.019222	20 57 95	jsr $019557			jsr 	CheckNextRParen
.019225	20 36 9a	jsr $019a36			jsr 	DivInteger32 				; divide
.019228	a5 1a		lda $1a				lda 	zLTemp1+0 					; modulus is in zLTemp, copy it.
.01922a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01922c	a5 1b		lda $1b				lda 	zLTemp1+1
.01922e	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019230	a5 1c		lda $1c				lda 	zLTemp1+2
.019232	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019234	a5 1d		lda $1d				lda 	zLTemp1+3
.019236	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019238	60		rts				rts
.019239					_UMParameter:
.019239	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX 			; get value
.01923c	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; absolute value
.01923e	10 03		bpl $019243			bpl 	_UMNotSigned
.019240	20 bd 9a	jsr $019abd			jsr 	IntegerNegateAlways
.019243					_UMNotSigned:
.019243	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/number/usr.asm

.019244					Unary_Usr:
.019244	20 23 8f	jsr $018f23			jsr 	EvaluateNumberX 			; numeric parameter
.019247	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.01924a	da		phx				phx 								; save XY
.01924b	5a		phy				phy
.01924c	ea		nop				nop
.01924d	22 0c 03 00	jsl $00030c			jsl 	UserVector
.019251	7a		ply				ply 								; and exit
.019252	fa		plx				plx
.019253	60		rts				rts
.019254					USRDefault:
.019254	20 57 85	jsr $018557			jsr ERR_Handler
>019257	4e 6f 20 55 53 52 20 76			.text "No USR vector.",0
>01925f	65 63 74 6f 72 2e 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/val.asm

.019266					Unary_Val:
.019266	20 3a 8f	jsr $018f3a			jsr 	EvaluateStringX 			; get string
.019269	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; check right bracket.
.01926c	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; put string address +1 into zGenPtr
.01926e	85 1e		sta $1e				sta 	zGenPtr
.019270	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019272	85 1f		sta $1f				sta 	zGenPtr+1
.019274	5a		phy				phy
.019275	a0 00		ldy #$00			ldy 	#0 							; get count of characters.
.019277	b1 1e		lda ($1e),y			lda 	(zGenPtr),y  				; if zero, it's bad obviously :)
.019279	f0 54		beq $0192cf			beq 	_UVBadNumber
.01927b	48		pha				pha 								; save length.
.01927c	1a		inc a				inc 	a 							; one for the length, one for the terminator
.01927d	1a		inc a				inc 	a
.01927e	20 97 95	jsr $019597			jsr 	AllocateTempString
.019281	c8		iny				iny 								; move to the next.
.019282	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get character
.019284	49 2d		eor #$2d			eor 	#"-"						; zero if minus sign
.019286	8d a0 03	sta $03a0			sta 	ValSign
.019289	d0 04		bne $01928f			bne 	_UVNotMinus
.01928b	c8		iny				iny 								; skip over it.
.01928c	68		pla				pla 								; decrement character count.
.01928d	3a		dec a				dec 	a
.01928e	48		pha				pha
.01928f					_UVNotMinus:
.01928f	68		pla				pla 								; this is the count.
.019290	48		pha		_UVCopy:pha									; copy into new temp string which is ASCIIZ
.019291	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019293	c8		iny				iny
.019294	20 c2 95	jsr $0195c2			jsr 	WriteTempString
.019297	68		pla				pla
.019298	3a		dec a				dec 	a
.019299	d0 f5		bne $019290			bne 	_UVCopy
.01929b	20 c2 95	jsr $0195c2			jsr 	WriteTempString 			; make it ASCIIZ
.01929e	18		clc				clc
.01929f	a5 20		lda $20				lda 	zTempStr 					; tempstring +1 => genptr
.0192a1	69 01		adc #$01			adc 	#1
.0192a3	85 1e		sta $1e				sta 	zGenPtr
.0192a5	a5 21		lda $21				lda 	zTempStr+1
.0192a7	69 00		adc #$00			adc 	#0
.0192a9	85 1f		sta $1f				sta 	zGenPtr+1
.0192ab	18		clc				clc
.0192ac	20 8f 9b	jsr $019b8f			jsr 	IntFromString 				; first bit.
.0192af	b0 1e		bcs $0192cf			bcs 	_UVBadNumber
.0192b1	20 d0 a0	jsr $01a0d0			jsr 	FPFromString				; try for a float part.
.0192b4	ad a0 03	lda $03a0			lda 	ValSign 					; was it negative
.0192b7	d0 10		bne $0192c9			bne 	_UVNotNegative
.0192b9	b5 85		lda $85,x			lda 	XS_Type,x 					; check if integer
.0192bb	4a		lsr a				lsr 	a
.0192bc	b0 08		bcs $0192c6			bcs 	_UVInteger
.0192be	b5 85		lda $85,x			lda 	XS_Type,x 					; set sign bit
.0192c0	09 80		ora #$80			ora 	#$80
.0192c2	95 85		sta $85,x			sta 	XS_Type,x
.0192c4	80 03		bra $0192c9			bra 	_UVNotNegative
.0192c6					_UVInteger:
.0192c6	20 bd 9a	jsr $019abd			jsr 	IntegerNegateAlways 		; sign it.
.0192c9					_UVNotNegative:
.0192c9	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; used everything
.0192cb	d0 02		bne $0192cf			bne 	_UVBadNumber
.0192cd	7a		ply				ply
.0192ce	60		rts				rts
.0192cf					_UVBadNumber:
.0192cf	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/str.asm

.0192d2					Unary_Str:
.0192d2	20 23 8f	jsr $018f23			jsr 	EvaluateNumberX 			; numeric parameter
.0192d5	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.0192d8	a9 00		lda #$00			lda 	#0 							; reset buffer index
.0192da	8d 14 03	sta $0314			sta 	NumBufX
.0192dd	b5 85		lda $85,x			lda 	XS_Type,x 					; get type
.0192df	4a		lsr a				lsr 	a
.0192e0	b0 05		bcs $0192e7			bcs 	_USInt 						; if msb set do as integer
.0192e2	20 15 a0	jsr $01a015			jsr 	FPToString 					; call fp to str otherwise
.0192e5	80 03		bra $0192ea			bra 	_USDuplicate
.0192e7	20 da 9a	jsr $019ada	_USInt:	jsr 	IntToString
.0192ea					_USDuplicate:
.0192ea	ad 14 03	lda $0314			lda 	NumBufX 					; chars in buffer
.0192ed	1a		inc a				inc 	a 							; one more for length
.0192ee	20 97 95	jsr $019597			jsr 	AllocateTempString 			; allocate space for it.
.0192f1	5a		phy				phy 								; save Y
.0192f2	a0 00		ldy #$00			ldy 	#0 							; start copying
.0192f4	b9 15 03	lda $0315,y	_USCopy:lda 	Num_Buffer,y 				; get and write
.0192f7	20 c2 95	jsr $0195c2			jsr 	WriteTempString
.0192fa	c8		iny				iny
.0192fb	cc 14 03	cpy $0314			cpy 	NumBufX 					; done the lot
.0192fe	d0 f4		bne $0192f4			bne 	_USCopy
.019300	7a		ply				ply 								; restore Y
.019301	4c cc 94	jmp $0194cc			jmp 	UnaryReturnTempStr 			; return new temporary string.

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/asc.asm

.019304					Unary_Asc:
.019304	20 3a 8f	jsr $018f3a			jsr 	EvaluateStringX 			; string parameter
.019307	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.01930a	5a		phy				phy 								; get the string length
.01930b	a0 00		ldy #$00			ldy 	#0
.01930d	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.01930f	f0 07		beq $019318			beq 	_UAIllegal 					; must be at least one character
.019311	c8		iny				iny
.019312	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; read it.
.019314	7a		ply				ply
.019315	4c 92 91	jmp $019192			jmp 	UnarySetAInteger
.019318					_UAIllegal:
.019318	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/len.asm

.01931b					Unary_Len:
.01931b	20 3a 8f	jsr $018f3a			jsr 	EvaluateStringX 			; string parameter
.01931e	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.019321	5a		phy				phy 								; get the string length
.019322	a0 00		ldy #$00			ldy 	#0
.019324	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019326	7a		ply				ply
.019327	4c 92 91	jmp $019192			jmp 	UnarySetAInteger

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/slice.asm

.01932a					Unary_Mid:
.01932a	20 3a 8f	jsr $018f3a			jsr 	EvaluateStringX 				; get string.
.01932d	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01932f	48		pha				pha
.019330	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019332	48		pha				pha
.019333	20 5f 95	jsr $01955f			jsr 	CheckNextComma 					; skip comma
.019336	20 bf 93	jsr $0193bf			jsr 	SLIByteParameter 				; get a byte parameter (start)
.019339	48		pha				pha 									; and push it.
.01933a	20 5f 95	jsr $01955f			jsr 	CheckNextComma 					; skip comma
.01933d	20 bf 93	jsr $0193bf			jsr 	SLIByteParameter 				; get a byte parameter (#chars)
.019340	48		pha				pha 									; and push it.
.019341	80 41		bra $019384			bra 	SLIProcess
.019343					Unary_Left:
.019343	20 3a 8f	jsr $018f3a			jsr 	EvaluateStringX 				; get string.
.019346	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.019348	48		pha				pha
.019349	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01934b	48		pha				pha
.01934c	a9 01		lda #$01			lda 	#1 								; push start position (1)
.01934e	48		pha				pha
.01934f	20 5f 95	jsr $01955f			jsr 	CheckNextComma 					; skip comma
.019352	20 bf 93	jsr $0193bf			jsr 	SLIByteParameter 				; get a byte parameter (# chars)
.019355	48		pha				pha 									; and push it.
.019356	80 2c		bra $019384			bra 	SLIProcess
.019358					Unary_Right:
.019358	20 3a 8f	jsr $018f3a			jsr 	EvaluateStringX 				; get string.
.01935b	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 				; push address on stack
.01935d	48		pha				pha
.01935e	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019360	48		pha				pha
.019361	da		phx				phx 									; get the string length and push on stack.
.019362	a2 00		ldx #$00			ldx 	#0
.019364	a1 1e		lda ($1e,x)			lda		(zGenPtr,x)
.019366	fa		plx				plx
.019367	48		pha				pha
.019368	20 5f 95	jsr $01955f			jsr 	CheckNextComma 					; skip comma
.01936b	20 bf 93	jsr $0193bf			jsr 	SLIByteParameter 				; get a byte parameter.
.01936e	8d 9e 03	sta $039e			sta 	SignCount 						; save in temporary.
.019371	68		pla				pla 									; restore string length.
.019372	1a		inc a				inc 	a 								; we add one. length 5, right 2, we start at 4.
.019373	38		sec				sec
.019374	ed 9e 03	sbc $039e			sbc 	SignCount 						; subtract characters needed, gives start position.
.019377	f0 02		beq $01937b			beq 	_URStart 						; if <= 0 start from 1.
.019379	10 02		bpl $01937d			bpl 	_UROkay
.01937b					_URStart:
.01937b	a9 01		lda #$01			lda 	#1
.01937d					_UROkay:
.01937d	48		pha				pha 									; push start
.01937e	ad 9e 03	lda $039e			lda 	SignCount 						; push count of characters
.019381	48		pha				pha
.019382	80 00		bra $019384			bra 	SLIProcess
.019384					SLIProcess:
.019384	20 57 95	jsr $019557			jsr 	CheckNextRParen 				; closing right bracket.
.019387	68		pla				pla
.019388	8d a2 03	sta $03a2			sta 	SliceCount 						; count in signcount
.01938b	1a		inc a				inc 	a 								; allocate +1 for it.
.01938c	20 97 95	jsr $019597			jsr 	AllocateTempString
.01938f	68		pla				pla 									; pop start number off stack.
.019390	f0 3b		beq $0193cd			beq 	SLIError 						; exit if start = 0
.019392	8d a1 03	sta $03a1			sta 	SliceStart
.019395	68		pla				pla  									; pop string address.
.019396	85 1f		sta $1f				sta 	zGenPtr+1
.019398	68		pla				pla
.019399	85 1e		sta $1e				sta 	zGenPtr
.01939b	da		phx				phx
.01939c	5a		phy				phy
.01939d	a2 00		ldx #$00			ldx 	#0 								; point to string length.
.01939f	ac a1 03	ldy $03a1			ldy 	SliceStart 						; start of the string (+1 for count)
.0193a2					_SLICopy:
.0193a2	ad a2 03	lda $03a2			lda 	SliceCount 						; done count characters
.0193a5	f0 12		beq $0193b9			beq 	_SLIExit
.0193a7	ce a2 03	dec $03a2			dec 	SliceCount
.0193aa	98		tya				tya 									; index of character
.0193ab	c1 1e		cmp ($1e,x)			cmp 	(zGenPtr,x)						; compare against length
.0193ad	f0 02		beq $0193b1			beq 	_SLIOk 							; if equal, okay.
.0193af	b0 08		bcs $0193b9			bcs 	_SLIExit 						; if past end, then exit.
.0193b1	b1 1e		lda ($1e),y	_SLIOk:	lda 	(zGenPtr),y 					; copy one character
.0193b3	c8		iny				iny
.0193b4	20 c2 95	jsr $0195c2			jsr 	WriteTempString
.0193b7	80 e9		bra $0193a2			bra 	_SLICopy 						; go round till copied characters
.0193b9					_SLIExit:
.0193b9	7a		ply				ply 									; restore YX
.0193ba	fa		plx				plx
.0193bb	4c cc 94	jmp $0194cc			jmp 	UnaryReturnTempStr 				; return new temporary string.
.0193be	ea		nop				nop
.0193bf					SLIByteParameter:
.0193bf	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX 				; get integer
.0193c2	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 				; check high bytes zero
.0193c4	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0193c6	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0193c8	d0 03		bne $0193cd			bne 	SLIError
.0193ca	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193cc	60		rts				rts
.0193cd					SLIError:
.0193cd	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/hex.asm

.0193d0					Unary_Hex:
.0193d0	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX 			; numeric parameter
.0193d3	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.0193d6	a9 09		lda #$09			lda 	#9 							; allocate 9 bytes (8 chars + length)
.0193d8	20 97 95	jsr $019597			jsr 	AllocateTempString			; allocate string space
.0193db	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; do each byte in turn.
.0193dd	20 01 94	jsr $019401			jsr 	_UHConvert
.0193e0	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0193e2	20 01 94	jsr $019401			jsr 	_UHConvert
.0193e5	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0193e7	20 01 94	jsr $019401			jsr 	_UHConvert
.0193ea	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0193ec	20 01 94	jsr $019401			jsr 	_UHConvert
.0193ef	5a		phy				phy 								; get length of new string
.0193f0	a0 00		ldy #$00			ldy 	#0
.0193f2	b1 20		lda ($20),y			lda 	(zTempStr),y
.0193f4	7a		ply				ply
.0193f5	c9 00		cmp #$00			cmp 	#0
.0193f7	d0 05		bne $0193fe			bne 	_UHExit 					; if it was non zero okay
.0193f9	a9 30		lda #$30			lda 	#"0" 						; empty, output one zero.
.0193fb	20 c2 95	jsr $0195c2			jsr 	WriteTempString
.0193fe					_UHExit:
.0193fe	4c cc 94	jmp $0194cc			jmp 	UnaryReturnTempStr 			; return new temporary string.
.019401					_UHConvert:
.019401	48		pha				pha
.019402	4a		lsr a				lsr 	a 							; do MSB
.019403	4a		lsr a				lsr 	a
.019404	4a		lsr a				lsr 	a
.019405	4a		lsr a				lsr 	a
.019406	20 0a 94	jsr $01940a			jsr 	_UHNibble
.019409	68		pla				pla 								; do LSB
.01940a					_UHNibble:
.01940a	29 0f		and #$0f			and 	#15 						; get nibble
.01940c	d0 0c		bne $01941a			bne 	_UHNonZero
.01940e	5a		phy				phy									; get the length
.01940f	a0 00		ldy #$00			ldy 	#0
.019411	b1 20		lda ($20),y			lda 	(zTempStr),y
.019413	7a		ply				ply
.019414	c9 00		cmp #$00			cmp 	#0 							; suppress leading zeros.
.019416	f0 0d		beq $019425			beq 	_UHExit2
.019418	a9 00		lda #$00			lda 	#0
.01941a					_UHNonZero:
.01941a	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.01941c	90 02		bcc $019420			bcc 	_UHDigit
.01941e	69 06		adc #$06			adc 	#7-1
.019420					_UHDigit:
.019420	69 30		adc #$30			adc 	#48
.019422	20 c2 95	jsr $0195c2			jsr 	WriteTempString				; output.
.019425					_UHExit2:
.019425	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/dec.asm

.019426					Unary_Dec:
.019426	20 3a 8f	jsr $018f3a			jsr 	EvaluateStringX 			; string parameter
.019429	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.01942c	5a		phy				phy
.01942d	a0 00		ldy #$00			ldy 	#0 							; get length of hex string.
.01942f	b1 1e		lda ($1e),y			lda 	(zGenPtr),y
.019431	f0 41		beq $019474			beq 	_UDFail 					; must fail if zero.
.019433	8d 9e 03	sta $039e			sta 	SignCount 					; use SignCount as a counter
.019436	a9 00		lda #$00			lda 	#0 							; set result to zero integer.
.019438	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01943a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01943c	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01943e	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019440	a9 01		lda #$01			lda 	#1
.019442	95 85		sta $85,x			sta 	XS_Type,x
.019444					_UDConvertLoop:
.019444	5a		phy				phy 								; shift mantissa left 4
.019445	a0 04		ldy #$04			ldy 	#4
.019447					_UDShift:
.019447	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019449	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.01944b	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.01944d	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.01944f	88		dey				dey
.019450	d0 f5		bne $019447			bne 	_UDShift
.019452	7a		ply				ply
.019453	c8		iny				iny 								; next character
.019454	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; fetch it.
.019456	20 77 94	jsr $019477			jsr 	ConvertUpper 				; convert to U/C
.019459	c9 30		cmp #$30			cmp 	#"0"
.01945b	90 17		bcc $019474			bcc 	_UDFail
.01945d	c9 3a		cmp #$3a			cmp 	#"9"+1
.01945f	90 06		bcc $019467			bcc 	_UDOkay
.019461	e9 37		sbc #$37			sbc 	#7+"0" 						; alpha fudge
.019463	c9 10		cmp #$10			cmp 	#16
.019465	b0 0d		bcs $019474			bcs 	_UDFail
.019467					_UDOkay:
.019467	29 0f		and #$0f			and 	#15 						; nibble only
.019469	15 80		ora $80,x			ora 	XS_Mantissa+0,x
.01946b	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01946d	ce 9e 03	dec $039e			dec 	SignCount 					; do it for each character
.019470	d0 d2		bne $019444			bne 	_UDConvertLoop
.019472	7a		ply				ply
.019473	60		rts				rts
.019474					_UDFail:
.019474	4c 46 85	jmp $018546			jmp 	BadParamError
.019477					ConvertUpper:
.019477	c9 61		cmp #$61			cmp 	#"a"
.019479	90 07		bcc $019482			bcc 	_CUExit
.01947b	c9 7b		cmp #$7b			cmp 	#"z"+1
.01947d	b0 03		bcs $019482			bcs 	_CUExit
.01947f	38		sec				sec
.019480	e9 20		sbc #$20			sbc 	#32
.019482	60		rts		_CUExit:rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/chr.asm

.019483					Unary_Chr:
.019483	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX			; numeric parameter
.019486	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.019489	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.01948b	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01948d	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.01948f	d0 0d		bne $01949e			bne 	_UCChar
.019491	a9 01		lda #$01			lda 	#1 							; one character string
.019493	20 97 95	jsr $019597			jsr 	AllocateTempString
.019496	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; get char# and write it.
.019498	20 c2 95	jsr $0195c2			jsr 	WriteTempString
.01949b	4c cc 94	jmp $0194cc			jmp 	UnaryReturnTempStr
.01949e					_UCChar:
.01949e	4c 46 85	jmp $018546			jmp 	BadParamError

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/string/spc.asm

.0194a1					Unary_Spc:
.0194a1	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX 			; numeric parameter
.0194a4	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; right bracket.
.0194a7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; check upper bytes 0
.0194a9	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.0194ab	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.0194ad	d0 1a		bne $0194c9			bne 	_USSize
.0194af	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0194b1	c9 fe		cmp #$fe			cmp 	#maxString+1
.0194b3	b0 14		bcs $0194c9			bcs 	_USSize
.0194b5	48		pha				pha 								; save length
.0194b6	1a		inc a				inc 	a 							; allocate one more.
.0194b7	20 97 95	jsr $019597			jsr 	AllocateTempString
.0194ba	68		pla				pla 								; get length
.0194bb	f0 0f		beq $0194cc			beq 	UnaryReturnTempStr 			; return the current temp string
.0194bd					_USLoop:
.0194bd	48		pha				pha
.0194be	a9 20		lda #$20			lda 	#" "
.0194c0	20 c2 95	jsr $0195c2			jsr 	WriteTempString
.0194c3	68		pla				pla
.0194c4	3a		dec a				dec 	a
.0194c5	d0 f6		bne $0194bd			bne 	_USLoop
.0194c7	80 03		bra $0194cc			bra 	UnaryReturnTempStr
.0194c9					_USSize:
.0194c9	4c 46 85	jmp $018546			jmp 	BadParamError
.0194cc					UnaryReturnTempStr:
.0194cc	a5 20		lda $20				lda 	zTempStr 					; copy temp string addr -> mantissa
.0194ce	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.0194d0	a5 21		lda $21				lda 	zTempStr+1
.0194d2	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.0194d4	a9 02		lda #$02			lda 	#2 							; set type to string
.0194d6	95 85		sta $85,x			sta 	XS_Type,x
.0194d8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/memory/65816.asm

.0194d9					MemRead:
.0194d9	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0194dc	a0 00		ldy #$00			ldy 	#0 							; start from here
.0194de	b7 1a		lda [$1a],y	_MLoop1:lda 	[zlTemp1],y 				; read the long address
.0194e0	95 80		sta $80,x			sta 	XS_Mantissa,x 				; copy into mantissa
.0194e2	c8		iny				iny 								; next to copy
.0194e3	e8		inx				inx
.0194e4	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0194e7	d0 f5		bne $0194de			bne 	_MLoop1
.0194e9	60		rts				rts
.0194ea					MemWrite:
.0194ea	8d 9e 03	sta $039e			sta 	SignCount 					; save count
.0194ed	a0 00		ldy #$00			ldy 	#0 							; start from here
.0194ef	b5 80		lda $80,x	_MLoop1:lda 	XS_Mantissa,x 				; read mantisssa
.0194f1	97 1a		sta [$1a],y			sta 	[zlTemp1],y 				; write it out
.0194f3	c8		iny				iny 								; next to copy
.0194f4	e8		inx				inx
.0194f5	cc 9e 03	cpy $039e			cpy 	SignCount 					; do required # of bytes.
.0194f8	d0 f5		bne $0194ef			bne 	_MLoop1
.0194fa	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/programend.asm

.0194fb					UpdateProgramEnd:
.0194fb	a9 00		lda #$00			lda 	#BasicProgram & $FF
.0194fd	85 16		sta $16				sta 	zCodePtr+0
.0194ff	a9 10		lda #$10			lda 	#BasicProgram >> 8
.019501	85 17		sta $17				sta 	zCodePtr+1
.019503	a9 00		lda #$00			lda 	#0
.019505	85 18		sta $18				sta 	zCodePtr+2
.019507	85 19		sta $19				sta 	zCodePtr+3
.019509	a0 03		ldy #$03			ldy 	#3
.01950b					_UPDLoop:
.01950b	a0 00		ldy #$00			ldy 	#0
.01950d	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01950f	c9 00		cmp #$00			cmp 	#0 							; end if offset is zero.
.019511	f0 0f		beq $019522			beq 	_UPDFoundEnd
.019513	a0 00		ldy #$00			ldy 	#0 							; point to offset
.019515	b7 16		lda [$16],y			lda 	[zCodePtr],y 				; read it
.019517	18		clc				clc
.019518	65 16		adc $16				adc 	zCodePtr 					; add to code pointer
.01951a	85 16		sta $16				sta 	zCodePtr
.01951c	90 02		bcc $019520			bcc 	_SNLNoCarry
.01951e	e6 17		inc $17				inc 	zCodePtr+1
.019520					_SNLNoCarry:
.019520	80 e9		bra $01950b			bra 	_UPDLoop
.019522					_UPDFoundEnd:
.019522	18		clc				clc 								; end of program 2 on.
.019523	a5 16		lda $16				lda 	zCodePtr
.019525	69 02		adc #$02			adc 	#2
.019527	8d 04 03	sta $0304			sta 	endOfProgram
.01952a	a5 17		lda $17				lda 	zCodePtr+1
.01952c	69 00		adc #$00			adc 	#0
.01952e	8d 05 03	sta $0305			sta 	endOfProgram+1
.019531	a5 18		lda $18				lda 	zCodePtr+2
.019533	69 00		adc #$00			adc		#0
.019535	8d 06 03	sta $0306			sta 	endOfProgram+2
.019538	a5 19		lda $19				lda 	zCodePtr+3
.01953a	69 00		adc #$00			adc 	#0
.01953c	8d 07 03	sta $0307			sta 	endOfProgram+3
.01953f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/pointer/checks.asm

.019540					CheckNextToken:
.019540	d7 16		cmp [$16],y			cmp 	[zCodePtr],y
.019542	d0 02		bne $019546			bne 	CTFail 						; no, then fail
.019544	c8		iny				iny
.019545	60		rts				rts
.019546					CTFail:
.019546	20 57 85	jsr $018557			jsr ERR_Handler
>019549	4d 69 73 73 69 6e 67 20			.text "Missing token",0
>019551	74 6f 6b 65 6e 00
.019557					CheckNextRParen:
.019557	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019559	c9 be		cmp #$be			cmp 	#token_rparen
.01955b	d0 e9		bne $019546			bne 	CTFail
.01955d	c8		iny				iny
.01955e	60		rts				rts
.01955f					CheckNextComma:
.01955f	b7 16		lda [$16],y			lda 	[zCodePtr],y
.019561	c9 bf		cmp #$bf			cmp 	#token_comma
.019563	d0 e1		bne $019546			bne 	CTFail
.019565	c8		iny				iny
.019566	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/concrete.asm

.019567					StringConcrete:
.019567	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; save source to zTemp1
.019569	85 10		sta $10				sta 	zTemp1
.01956b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.01956d	85 11		sta $11				sta 	zTemp1+1
.01956f	a0 00		ldy #$00			ldy 	#0 							; subtract the length+1 (clc) of the string.
.019571	18		clc				clc 								; from the string pointer
.019572	ad 00 03	lda $0300			lda 	StringPtr 					; and put in zTemp2 as well
.019575	f1 10		sbc ($10),y			sbc 	(zTemp1),y
.019577	8d 00 03	sta $0300			sta 	StringPtr
.01957a	85 12		sta $12				sta 	zTemp2
.01957c	ad 01 03	lda $0301			lda 	StringPtr+1
.01957f	e9 00		sbc #$00			sbc 	#0
.019581	8d 01 03	sta $0301			sta 	StringPtr+1
.019584	85 13		sta $13				sta 	zTemp2+1
.019586	b1 10		lda ($10),y			lda 	(zTemp1),y 					; length add one for count
.019588	1a		inc a				inc 	a
.019589	aa		tax				tax
.01958a	b1 10		lda ($10),y	_SCCopy:lda 	(zTemp1),y 					; copy whole thing including length
.01958c	91 12		sta ($12),y			sta 	(zTemp2),y
.01958e	c8		iny				iny
.01958f	ca		dex				dex
.019590	d0 f8		bne $01958a			bne 	_SCCopy
.019592	a5 13		lda $13				lda 	zTemp2+1 					; return concrete string in AX
.019594	a6 12		ldx $12				ldx 	zTemp2
.019596	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/stringmem/tempalloc.asm

.019597					AllocateTempString:
.019597	48		pha				pha 								; save required count.
.019598	a5 21		lda $21				lda 	zTempStr+1 					; check if initialised yet ?
.01959a	d0 0b		bne $0195a7			bne 	_ATSInitialised
.01959c	ad 00 03	lda $0300			lda 	StringPtr 					; set temporary string ptr 1 page below available
.01959f	85 20		sta $20				sta 	zTempStr					; space, this is for strings to be concreted.
.0195a1	ad 01 03	lda $0301			lda 	StringPtr+1
.0195a4	3a		dec a				dec 	a
.0195a5	85 21		sta $21				sta 	zTempStr+1
.0195a7					_ATSInitialised:
.0195a7	68		pla				pla 								; get required count back.
.0195a8	49 ff		eor #$ff			eor 	#$FF 						; negate 2's complement.
.0195aa	1a		inc a				inc 	a
.0195ab	18		clc				clc
.0195ac	65 20		adc $20				adc 	zTempStr 					; "add" to the temp string pointer
.0195ae	85 20		sta $20				sta 	zTempStr
.0195b0	a9 ff		lda #$ff			lda 	#$FF
.0195b2	65 21		adc $21				adc 	zTempStr+1
.0195b4	85 21		sta $21				sta 	zTempStr+1
.0195b6	a9 00		lda #$00			lda 	#0 							; clear temp string.
.0195b8	5a		phy				phy
.0195b9	a8		tay				tay
.0195ba	91 20		sta ($20),y			sta 	(zTempStr),y
.0195bc	7a		ply				ply
.0195bd	1a		inc a				inc 	a 							; reset the write index.
.0195be	8d 9f 03	sta $039f			sta 	TempStringWriteIndex
.0195c1	60		rts				rts
.0195c2					WriteTempString:
.0195c2	5a		phy				phy 								; save Y
.0195c3	ac 9f 03	ldy $039f			ldy 	TempStringWriteIndex	 	; write position.
.0195c6	91 20		sta ($20),y			sta 	(zTempStr),y 				; write character out.
.0195c8	ee 9f 03	inc $039f			inc 	TempStringWriteIndex 		; increment the write position.
.0195cb	98		tya				tya 								; unchanged Y is now length
.0195cc	a0 00		ldy #$00			ldy 	#0
.0195ce	91 20		sta ($20),y			sta 	(zTempStr),y
.0195d0	7a		ply				ply 								; restore Y and exit
.0195d1	60		rts				rts
.0195d2					CreateTempStringCopy:
.0195d2	da		phx				phx 								; save X
.0195d3	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0195d5	3a		dec a				dec 	a 							; we need one more than actual length for temp str
.0195d6	20 97 95	jsr $019597			jsr 	AllocateTempString 			; allocate memory for temporary string.
.0195d9	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0195db	c8		iny				iny
.0195dc	3a		dec a				dec 	a 							; make the actual length in charactes
.0195dd	3a		dec a				dec 	a
.0195de	a2 00		ldx #$00			ldx 	#0 							; set that as the length of the string.
.0195e0	81 20		sta ($20,x)			sta 	(zTempStr,x)
.0195e2	85 1a		sta $1a				sta 	zLTemp1 					; that's used as a count.
.0195e4	09 00		ora #$00			ora 	#0 							; if zero already, exit
.0195e6	f0 0e		beq $0195f6			beq 	_CTSCExit
.0195e8					_CTSCLoop:
.0195e8	b7 16		lda [$16],y			lda 	[zCodePtr],y
.0195ea	c8		iny				iny
.0195eb	5a		phy				phy 								; save in Y
.0195ec	e8		inx				inx 								; bump index
.0195ed	da		phx				phx 								; index into Y
.0195ee	7a		ply				ply
.0195ef	91 20		sta ($20),y			sta 	(zTempStr),y 				; save at index
.0195f1	7a		ply				ply 								; restore Y
.0195f2	c6 1a		dec $1a				dec 	zLTemp1 					; do for each character
.0195f4	d0 f2		bne $0195e8			bne 	_CTSCLoop
.0195f6					_CTSCExit:
.0195f6	fa		plx				plx 								; restore X
.0195f7	60		rts				rts 								; exit

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/variables.asm

.0195f8					VariableFind:
.0195f8	20 63 96	jsr $019663			jsr 	VariableExtract 		; find out all about it ....
.0195fb	20 fc 98	jsr $0198fc			jsr 	VariableLocate 			; does it already exist ?
.0195fe	b0 03		bcs $019603			bcs 	_VFExists 				; if so, use that.
.019600	20 ef 96	jsr $0196ef			jsr 	VariableCreate 			; otherwise create it.
.019603					_VFExists:
.019603	a5 24		lda $24				lda 	zVarType 				; is it still an array ?
.019605	29 01		and #$01			and 	#1
.019607	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019609	d0 28		bne $019633			bne 	_VFSingleElement
.01960b					_VFNextIndex:
.01960b	a5 22		lda $22				lda 	zVarDataPtr 			; push the data ptr and type on the stack.
.01960d	48		pha				pha
.01960e	a5 23		lda $23				lda 	zVarDataPtr+1
.019610	48		pha				pha
.019611	a5 24		lda $24				lda 	zVarType
.019613	48		pha				pha
.019614	20 31 8f	jsr $018f31			jsr 	EvaluateIntegerX 		; calculate the index.
.019617	68		pla				pla 							; restore and index.
.019618	85 24		sta $24				sta 	zVarType
.01961a	68		pla				pla
.01961b	85 23		sta $23				sta 	zVarDataPtr+1
.01961d	68		pla				pla
.01961e	85 22		sta $22				sta 	zVarDataPtr
.019620	20 7a 97	jsr $01977a			jsr 	ArrayIndexFollow 		; do the index.
.019623	a5 24		lda $24				lda 	zVarType 				; is it still an array ??
.019625	29 01		and #$01			and 	#1
.019627	c9 00		cmp #$00			cmp 	#(token_DollarLParen) & 1
.019629	d0 05		bne $019630			bne 	_VFArrayDone 			; if so then exit.
.01962b	20 5f 95	jsr $01955f			jsr 	CheckNextComma 			; comma should follow
.01962e	80 db		bra $01960b			bra 	_VFNextIndex
.019630					_VFArrayDone:
.019630	20 57 95	jsr $019557			jsr 	CheckNextRParen 		; check closing right bracket.
.019633					_VFSingleElement:
.019633	60		rts				rts
.019634					VariableClear:
.019634	48		pha				pha 							; save registers
.019635	da		phx				phx
.019636	a2 00		ldx #$00			ldx 	#0 						; clear out the hash table.
.019638	8a		txa				txa
.019639	9d 35 03	sta $0335,x	_VCLoop:sta 	HashTableBase,x
.01963c	e8		inx				inx
.01963d	e0 60		cpx #$60			cpx 	#HashTableEnd-HashTableBase
.01963f	d0 f8		bne $019639			bne 	_VCLoop
.019641	a9 00		lda #$00			lda 	#VariableMemory & $FF
.019643	8d 02 03	sta $0302			sta 	VarMemPtr
.019646	a9 30		lda #$30			lda 	#VariableMemory >> 8
.019648	8d 03 03	sta $0303			sta 	VarMemPtr+1
.01964b	fa		plx				plx 							; restore registers
.01964c	68		pla				pla
.01964d	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/extract.asm

.01964e					VariableNameError:
.01964e	20 57 85	jsr $018557			jsr ERR_Handler
>019651	42 61 64 20 56 61 72 69			.text "Bad Variable Name",0
>019659	61 62 6c 65 20 4e 61 6d 65 00
.019663					VariableExtract:
.019663	da		phx				phx 							; save X.
.019664	a9 ba		lda #$ba			lda 	#token_hashlParen  		; set the type to #( e.g. real array.
.019666	8d 95 03	sta $0395			sta 	Var_Type
.019669	8d 96 03	sta $0396			sta 	Var_Hash 				; we initialise the hash with this. It doesn't matter
.01966c	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01966e	c9 00		cmp #$00			cmp 	#0 						; first one must be A-Z
.019670	f0 dc		beq $01964e			beq 	VariableNameError
.019672	c9 1b		cmp #$1b			cmp 	#26+1
.019674	b0 d8		bcs $01964e			bcs 	VariableNameError
.019676	a2 ff		ldx #$ff			ldx 	#255 					; now copy it into the variable buffer.
.019678					_VECopyBuffer:
.019678	e8		inx				inx
.019679	e0 1f		cpx #$1f			cpx 	#31 					; too long
.01967b	f0 d1		beq $01964e			beq 	VariableNameError
.01967d	9d 15 03	sta $0315,x			sta 	Var_Buffer,x 			; save character
.019680	18		clc				clc  							; update the hash value for it.
.019681	6d 96 03	adc $0396			adc 	Var_Hash
.019684	8d 96 03	sta $0396			sta 	Var_Hash
.019687	c8		iny				iny
.019688	b7 16		lda [$16],y			lda 	[zCodePtr],y
.01968a	c9 00		cmp #$00			cmp 	#0 						; zero or token, end of variable
.01968c	f0 0e		beq $01969c			beq 	_VECopyEnd
.01968e	30 0c		bmi $01969c			bmi 	_VECopyEnd
.019690	c9 1b		cmp #$1b			cmp 	#26+1 					; A-Z continue copying
.019692	90 e4		bcc $019678			bcc 	_VECopyBuffer
.019694	c9 30		cmp #$30			cmp 	#"0" 					; 0-9 copy as well.
.019696	90 04		bcc $01969c			bcc 	_VECopyEnd
.019698	c9 3a		cmp #$3a			cmp 	#"9"+1
.01969a	90 dc		bcc $019678			bcc 	_VECopyBuffer
.01969c					_VECopyEnd:
.01969c	c8		iny				iny
.01969d	c9 b7		cmp #$b7			cmp 	#token_Dollar 			; first type token.
.01969f	90 04		bcc $0196a5			bcc 	_VEDefaultRequired
.0196a1	c9 bd		cmp #$bd			cmp 	#token_PercentLParen+1	; last type token.
.0196a3	90 0b		bcc $0196b0			bcc 	_VEHaveType
.0196a5					_VEDefaultRequired:
.0196a5	c9 bd		cmp #$bd			cmp 	#token_LParen 			; if it ends in ( then use the real array
.0196a7	f0 04		beq $0196ad			beq 	_VESetType 				; default set above.
.0196a9	ce 95 03	dec $0395			dec 	Var_Type 				; this changes that default to the variable default
.0196ac	88		dey				dey
.0196ad					_VESetType:
.0196ad	ad 95 03	lda $0395			lda 	Var_Type 				; get type ....
.0196b0					_VEHaveType:
.0196b0	8d 95 03	sta $0395			sta 	Var_Type 				; save as type.
.0196b3	bd 15 03	lda $0315,x			lda 	Var_Buffer,x 			; set bit 7 of name, marks the end.
.0196b6	09 80		ora #$80			ora 	#$80
.0196b8	9d 15 03	sta $0315,x			sta 	Var_Buffer,x
.0196bb	e8		inx				inx 							; offset 3 => length 4.
.0196bc	8e 97 03	stx $0397			stx 	Var_Length 				; save length of variable name.
.0196bf	ad 95 03	lda $0395			lda 	Var_Type 				; get offset of var type from first type token
.0196c2	38		sec				sec
.0196c3	e9 b7		sbc #$b7			sbc 	#token_Dollar
.0196c5	0a		asl a				asl 	a 						; multiply by 16. This requires HashTableSize
.0196c6	0a		asl a				asl 	a 						; in data.asm to be 8 (8 sets of links,2 bytes each)
.0196c7	0a		asl a				asl 	a
.0196c8	0a		asl a				asl 	a
.0196c9	8d 98 03	sta $0398			sta 	Var_HashAddress
.0196cc	ad 96 03	lda $0396			lda 	Var_Hash 				; get the hash
.0196cf	29 07		and #$07			and 	#(HashTableSize-1) 		; force into range 0-tableSize-1
.0196d1	0a		asl a				asl 	a 						; double it (2 bytes per entry) & clears carry
.0196d2	6d 98 03	adc $0398			adc 	Var_HashAddress 		; add table offset.
.0196d5	69 35		adc #$35			adc 	#HashTableBase & $FF 	; now the low byte of the actual table address
.0196d7	8d 98 03	sta $0398			sta 	Var_HashAddress
.0196da	a2 05		ldx #$05			ldx 	#5 						; hash is 5 bytes (real)
.0196dc	ad 95 03	lda $0395			lda 	Var_Type
.0196df	c9 b9		cmp #$b9			cmp 	#token_Hash
.0196e1	f0 07		beq $0196ea			beq 	_VEHaveSize
.0196e3	ca		dex				dex
.0196e4	c9 bb		cmp #$bb			cmp 	#token_Percent 			; percent is 4 bytes (integer)
.0196e6	f0 02		beq $0196ea			beq 	_VEHaveSize
.0196e8	a2 02		ldx #$02			ldx 	#2 						; everything else is two.
.0196ea					_VEHaveSize:
.0196ea	8e 99 03	stx $0399			stx 	Var_DataSize
.0196ed	fa		plx				plx
.0196ee	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varcreate.asm

.0196ef					VariableCreate:
.0196ef	da		phx				phx
.0196f0	5a		phy				phy
.0196f1	ad 02 03	lda $0302			lda 	VarMemPtr 					; get address of next free into zTemp1
.0196f4	85 10		sta $10				sta 	zTemp1
.0196f6	ad 03 03	lda $0303			lda 	VarMemPtr+1
.0196f9	85 11		sta $11				sta 	zTemp1+1
.0196fb	ad 99 03	lda $0399			lda 	Var_DataSize 				; bytes for the data bit
.0196fe	18		clc				clc
.0196ff	6d 97 03	adc $0397			adc 	Var_Length 					; add the length of the name
.019702	69 03		adc #$03			adc 	#3 							; 3 for the link and the hash.
.019704	6d 02 03	adc $0302			adc 	VarMemPtr 					; add to variable memory pointer
.019707	8d 02 03	sta $0302			sta 	VarMemPtr
.01970a	90 03		bcc $01970f			bcc 	_VCNoCarry
.01970c	ee 03 03	inc $0303			inc 	VarMemPtr+1
.01970f					_VCNoCarry:
.01970f	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019712	85 12		sta $12				sta 	zTemp2
.019714	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019716	85 13		sta $13				sta 	zTemp2+1
.019718	a0 00		ldy #$00			ldy 	#0 							; put current hash link in position.
.01971a	b1 12		lda ($12),y			lda 	(zTemp2),y
.01971c	91 10		sta ($10),y			sta 	(zTemp1),y
.01971e	c8		iny				iny
.01971f	b1 12		lda ($12),y			lda 	(zTemp2),y
.019721	91 10		sta ($10),y			sta 	(zTemp1),y
.019723	c8		iny				iny
.019724	ad 96 03	lda $0396			lda 	Var_Hash 					; write the hash out.
.019727	91 10		sta ($10),y			sta 	(zTemp1),y
.019729	c8		iny				iny
.01972a	a2 00		ldx #$00			ldx 	#0 							; copy the name out.
.01972c					_VCCopyName:
.01972c	bd 15 03	lda $0315,x			lda 	Var_Buffer,x
.01972f	91 10		sta ($10),y			sta 	(zTemp1),y
.019731	e8		inx				inx
.019732	c8		iny				iny
.019733	ec 97 03	cpx $0397			cpx 	Var_Length
.019736	d0 f4		bne $01972c			bne 	_VCCopyName
.019738	5a		phy				phy 								; save the data offset.
.019739	ae 99 03	ldx $0399			ldx 	Var_DataSize 				; and write the data out.
.01973c	a9 00		lda #$00			lda 	#0 							; which is all zeroes.
.01973e					_VCClearData:
.01973e	91 10		sta ($10),y			sta 	(zTemp1),y
.019740	c8		iny				iny
.019741	ca		dex				dex
.019742	d0 fa		bne $01973e			bne 	_VCClearData
.019744	68		pla				pla 								; offset to the data
.019745	18		clc				clc
.019746	65 10		adc $10				adc 	zTemp1 						; add to start and save as data pointer.
.019748	85 22		sta $22				sta 	zVarDataPtr
.01974a	a5 11		lda $11				lda 	zTemp1+1
.01974c	69 00		adc #$00			adc 	#0
.01974e	85 23		sta $23				sta 	zVarDataPtr+1
.019750	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.019753	85 24		sta $24				sta 	zVarType
.019755	a5 10		lda $10				lda 	zTemp1 						; fix hash link to point to new record
.019757	a0 00		ldy #$00			ldy 	#0
.019759	91 12		sta ($12),y			sta 	(zTemp2),y
.01975b	c8		iny				iny
.01975c	a5 11		lda $11				lda 	zTemp1+1
.01975e	91 12		sta ($12),y			sta 	(zTemp2),y
.019760	ad 95 03	lda $0395			lda 	Var_Type 					; array ? if so create the empty one.
.019763	29 01		and #$01			and 	#1
.019765	c9 00		cmp #$00			cmp 	#(token_DollarLParen & 1)
.019767	d0 0e		bne $019777			bne 	_VCNotArray
.019769	a2 00		ldx #$00			ldx 	#0 							; call recursive array creator
.01976b	20 11 98	jsr $019811			jsr 	ArrayCreate
.01976e	5a		phy				phy 								; save YA at zVarDataPtr
.01976f	a0 00		ldy #$00			ldy 	#0
.019771	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019773	c8		iny				iny
.019774	68		pla				pla
.019775	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.019777					_VCNotArray:
.019777	7a		ply				ply
.019778	fa		plx				plx
.019779	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arrayidx.asm

.01977a					ArrayIndexFollow:
.01977a	5a		phy				phy
.01977b	a0 00		ldy #$00			ldy 	#0 							; make zVarDataPtr point to the array.
.01977d	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; e.g. it points to itself.
.01977f	48		pha				pha
.019780	c8		iny				iny
.019781	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019783	85 23		sta $23				sta 	zVarDataPtr+1
.019785	68		pla				pla
.019786	85 22		sta $22				sta 	zVarDataPtr
.019788	b5 81		lda $81,x			lda 	XS_Mantissa+1,x 			; MSB of 16 bit integer and bytes 2&3
.01978a	29 80		and #$80			and 	#$80 						; must be zero.
.01978c	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.01978e	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019790	d0 59		bne $0197eb			bne 	_AIFError
.019792	a0 00		ldy #$00			ldy 	#0 							; calculate size - current - 1
.019794	18		clc				clc
.019795	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019797	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019799	c8		iny				iny
.01979a	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01979c	08		php				php 								; clear bit 7 retaining borrow.
.01979d	29 7f		and #$7f			and 	#$7F
.01979f	28		plp				plp
.0197a0	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.0197a2	90 47		bcc $0197eb			bcc 	_AIFError 					; eror if size-current < 0
.0197a4	b5 80		lda $80,x			lda  	XS_Mantissa+0,x 			; copy and double the index
.0197a6	0a		asl a				asl 	a 							; (e.g. index * 2)
.0197a7	85 10		sta $10				sta 	zTemp1
.0197a9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197ab	2a		rol a				rol 	a
.0197ac	85 11		sta $11				sta 	zTemp1+1
.0197ae	a0 01		ldy #$01			ldy 	#1 							; is this a data entry.
.0197b0	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; if so, then type is unchanged, offset set
.0197b2	30 1d		bmi $0197d1			bmi 	_AIFCalculate
.0197b4	c6 24		dec $24				dec 	zVarType 					; converts from an array to a type.
.0197b6	a5 24		lda $24				lda 	zVarType 					; check that type
.0197b8	c9 b7		cmp #$b7			cmp 	#token_Dollar 				; if string, use x 2
.0197ba	f0 15		beq $0197d1			beq 	_AIFCalculate
.0197bc	06 10		asl $10				asl 	zTemp1			 			; double the index
.0197be	26 11		rol $11				rol 	zTemp1+1					; (e.g. index * 4)
.0197c0	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if integer, use x 4
.0197c2	f0 0d		beq $0197d1			beq 	_AIFCalculate
.0197c4	18		clc				clc 								; add the original mantissa in again
.0197c5	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; which makes it x5, for float.
.0197c7	65 10		adc $10				adc 	zTemp1
.0197c9	85 10		sta $10				sta 	zTemp1
.0197cb	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0197cd	65 11		adc $11				adc 	zTemp1+1
.0197cf	85 11		sta $11				sta 	zTemp1+1
.0197d1					_AIFCalculate:
.0197d1	18		clc				clc 								; add index x 2,4 or 5 to base
.0197d2	a5 22		lda $22				lda 	zVarDataPtr
.0197d4	65 10		adc $10				adc 	zTemp1
.0197d6	85 22		sta $22				sta 	zVarDataPtr
.0197d8	a5 23		lda $23				lda 	zVarDataPtr+1
.0197da	65 11		adc $11				adc 	zTemp1+1
.0197dc	85 23		sta $23				sta 	zVarDataPtr+1
.0197de	18		clc				clc 								; add 2 more for the length prefix.
.0197df	a5 22		lda $22				lda 	zVarDataPtr
.0197e1	69 02		adc #$02			adc 	#2
.0197e3	85 22		sta $22				sta 	zVarDataPtr
.0197e5	90 02		bcc $0197e9			bcc 	_AIFNoBump
.0197e7	e6 23		inc $23				inc 	zVarDataPtr+1
.0197e9					_AIFNoBump:
.0197e9	7a		ply				ply
.0197ea	60		rts				rts
.0197eb					_AIFError:
.0197eb	20 57 85	jsr $018557			jsr ERR_Handler
>0197ee	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0197f6	79 20 69 6e 64 65 78 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/arraydef.asm

.0197fe					ArrayResetDefault:
.0197fe	a9 0b		lda #$0b			lda 	#11 						; 0..10 one array
.019800	8d a8 03	sta $03a8			sta 	ArrayDef+0
.019803	a9 00		lda #$00			lda 	#0
.019805	8d a9 03	sta $03a9			sta 	ArrayDef+1
.019808	a9 ff		lda #$ff			lda 	#$FF
.01980a	8d aa 03	sta $03aa			sta 	ArrayDef+2 					; $FFFF implies no second element.
.01980d	8d ab 03	sta $03ab			sta 	ArrayDef+3					; (test bit 7 of 2nd byte)
.019810	60		rts				rts
.019811					ArrayCreate:
.019811	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; put size x 2 in zTemp1
.019814	0a		asl a				asl 	a
.019815	85 10		sta $10				sta 	zTemp1
.019817	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.01981a	2a		rol a				rol 	a
.01981b	85 11		sta $11				sta 	zTemp1+1
.01981d	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; if this is the last element it's array of ptrs.
.019820	10 22		bpl $019844			bpl 	_ACSized 					; if not multiply size x 2 (str) 4 (int) 5 (real)
.019822	ad 95 03	lda $0395			lda 	Var_Type 					; check the type
.019825	c9 b8		cmp #$b8			cmp 	#token_DollarLParen 		; also if it is an array of strings $(
.019827	f0 1b		beq $019844			beq 	_ACSized
.019829	06 10		asl $10				asl 	zTemp1 						; double again
.01982b	26 11		rol $11				rol 	zTemp1+1
.01982d	b0 6f		bcs $01989e			bcs 	ArrayIndexError 			; too large.
.01982f	c9 bc		cmp #$bc			cmp 	#token_PercentLParen 		; if %( four bytes/entry is enough.
.019831	f0 11		beq $019844			beq 	_ACSized
.019833	18		clc				clc 								; add original value x 5 for reals.
.019834	a5 10		lda $10				lda 	zTemp1
.019836	7d a8 03	adc $03a8,x			adc 	ArrayDef+0,x
.019839	85 10		sta $10				sta 	zTemp1
.01983b	a5 11		lda $11				lda 	zTemp1+1
.01983d	7d a9 03	adc $03a9,x			adc 	ArrayDef+1,x
.019840	85 11		sta $11				sta 	zTemp1+1
.019842	b0 5a		bcs $01989e			bcs 	ArrayIndexError
.019844					_ACSized:
.019844	18		clc				clc
.019845	a5 10		lda $10				lda 	zTemp1
.019847	69 02		adc #$02			adc 	#2
.019849	85 10		sta $10				sta 	zTemp1
.01984b	90 04		bcc $019851			bcc 	_ACNoBump
.01984d	e6 10		inc $10				inc 	zTemp1
.01984f	f0 4d		beq $01989e			beq 	ArrayIndexError
.019851					_ACNoBump:
.019851	18		clc				clc
.019852	ad 02 03	lda $0302			lda 	VarMemPtr 					; add this allocated count to VarMemPtr
.019855	85 12		sta $12				sta 	zTemp2						; save start in zTemp2/zTemp3
.019857	85 14		sta $14				sta 	zTemp3
.019859	65 10		adc $10				adc 	zTemp1
.01985b	8d 02 03	sta $0302			sta 	VarMemPtr
.01985e	ad 03 03	lda $0303			lda 	VarMemPtr+1
.019861	85 13		sta $13				sta 	zTemp2+1
.019863	85 15		sta $15				sta 	zTemp3+1
.019865	65 11		adc $11				adc 	zTemp1+1
.019867	8d 03 03	sta $0303			sta 	VarMemPtr+1
.01986a	85 11		sta $11				sta 	zTemp1+1
.01986c	b0 30		bcs $01989e			bcs 	ArrayIndexError
.01986e	a0 00		ldy #$00			ldy 	#0							; write $00 out.
.019870					_ACClear:
.019870	98		tya				tya
.019871	91 12		sta ($12),y			sta 	(zTemp2),y
.019873	e6 12		inc $12				inc 	zTemp2
.019875	d0 02		bne $019879			bne 	_ACCBump
.019877	e6 13		inc $13				inc 	zTemp2+1
.019879					_ACCBump:
.019879	a5 12		lda $12				lda 	zTemp2
.01987b	cd 02 03	cmp $0302			cmp 	VarMemPtr
.01987e	d0 f0		bne $019870			bne 	_ACClear
.019880	a5 13		lda $13				lda 	zTemp2+1
.019882	cd 03 03	cmp $0303			cmp 	VarMemPtr+1
.019885	d0 e9		bne $019870			bne 	_ACClear
.019887	a0 00		ldy #$00			ldy 	#0
.019889	bd a8 03	lda $03a8,x			lda 	ArrayDef+0,x 				; copy the size into the start
.01988c	91 14		sta ($14),y			sta 	(zTemp3),y
.01988e	c8		iny				iny
.01988f	bd a9 03	lda $03a9,x			lda 	ArrayDef+1,x
.019892	91 14		sta ($14),y			sta 	(zTemp3),y
.019894	bd ab 03	lda $03ab,x			lda 	ArrayDef+3,x 				; have we reached the end
.019897	10 18		bpl $0198b1			bpl 	ACCFillRecursive
.019899	a4 15		ldy $15				ldy 	zTemp3+1 					; return address
.01989b	a5 14		lda $14				lda 	zTemp3
.01989d	60		rts				rts
.01989e					ArrayIndexError:
.01989e	20 57 85	jsr $018557			jsr ERR_Handler
>0198a1	42 61 64 20 61 72 72 61			.text "Bad array index",0
>0198a9	79 20 69 6e 64 65 78 00
.0198b1					ACCFillRecursive:
.0198b1	a9 ff		lda #$ff			lda 	#$FF 						; we mark the end, this is free space.
.0198b3	a0 00		ldy #$00			ldy 	#0 							; this is overwritten by size of next allocated
.0198b5	91 12		sta ($12),y			sta 	(zTemp2),y 					; array, but we might change that.
.0198b7	c8		iny				iny
.0198b8	b1 14		lda ($14),y			lda 	(zTemp3),y 					; set bit 15 of the max index indicating
.0198ba	09 80		ora #$80			ora 	#$80 						; an array of pointers
.0198bc	91 14		sta ($14),y			sta 	(zTemp3),y
.0198be	a5 14		lda $14				lda 	zTemp3 						; push the start on the stack
.0198c0	48		pha				pha
.0198c1	a5 15		lda $15				lda 	zTemp3+1
.0198c3	48		pha				pha
.0198c4					_ACCFillLoop:
.0198c4	18		clc				clc
.0198c5	a5 14		lda $14				lda 	zTemp3 						; and work forwards.
.0198c7	69 02		adc #$02			adc 	#2
.0198c9	85 14		sta $14				sta 	zTemp3
.0198cb	90 02		bcc $0198cf			bcc 	_ACCSkip2
.0198cd	e6 15		inc $15				inc 	zTemp3+1
.0198cf					_ACCSkip2:
.0198cf	a0 00		ldy #$00			ldy 	#0 							; reached the end ?
.0198d1	b1 14		lda ($14),y			lda 	(zTemp3),y					; (looking for FF marker, everything else 00)
.0198d3	c8		iny				iny
.0198d4	11 14		ora ($14),y			ora 	(zTemp3),y
.0198d6	d0 21		bne $0198f9			bne 	_ACCExit
.0198d8	a5 14		lda $14				lda 	zTemp3 						; push zTemp3
.0198da	48		pha				pha
.0198db	a5 15		lda $15				lda 	zTemp3+1
.0198dd	48		pha				pha
.0198de	e8		inx				inx
.0198df	e8		inx				inx
.0198e0	20 11 98	jsr $019811			jsr 	ArrayCreate 				; create array recursively.
.0198e3	ca		dex				dex
.0198e4	ca		dex				dex
.0198e5	85 12		sta $12				sta 	zTemp2 						; save A
.0198e7	68		pla				pla
.0198e8	85 15		sta $15				sta 	zTemp3+1 					; restore zTemp3
.0198ea	68		pla				pla
.0198eb	85 14		sta $14				sta 	zTemp3
.0198ed	98		tya				tya 								; write high bye from Y
.0198ee	a0 01		ldy #$01			ldy 	#1
.0198f0	91 14		sta ($14),y			sta 	(zTemp3),y
.0198f2	88		dey				dey 								; write low byte out.
.0198f3	a5 12		lda $12				lda 	zTemp2
.0198f5	91 14		sta ($14),y			sta 	(zTemp3),y
.0198f7	80 cb		bra $0198c4			bra 	_ACCFillLoop 				; and try again.
.0198f9					_ACCExit:
.0198f9	7a		ply				ply 								; restore the original address
.0198fa	68		pla				pla
.0198fb	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/varfind.asm

.0198fc					VariableLocate:
.0198fc	da		phx				phx
.0198fd	5a		phy				phy
.0198fe	ad 98 03	lda $0398			lda 	Var_HashAddress 			; hash table pointer in zTemp2
.019901	85 12		sta $12				sta 	zTemp2 						; points to first address.
.019903	a9 03		lda #$03			lda 	#HashTableBase >> 8
.019905	85 13		sta $13				sta 	zTemp2+1
.019907	a0 00		ldy #$00	_VLNext:ldy 	#0 							; get next link into AX
.019909	b1 12		lda ($12),y			lda 	(zTemp2),y
.01990b	aa		tax				tax
.01990c	c8		iny				iny
.01990d	b1 12		lda ($12),y			lda 	(zTemp2),y
.01990f	85 13		sta $13				sta 	zTemp2+1 					; save in zTemp
.019911	86 12		stx $12				stx 	zTemp2
.019913	05 12		ora $12				ora 	zTemp2 						; got zero
.019915	18		clc				clc
.019916	f0 25		beq $01993d			beq 	_VLExit 					; if so, then fail as end of chain.
.019918	c8		iny				iny 								; point to hash (offset + 2)
.019919	b1 12		lda ($12),y			lda 	(zTemp2),y
.01991b	cd 96 03	cmp $0396			cmp 	Var_Hash
.01991e	d0 e7		bne $019907			bne 	_VLNext 					; try next if different.
.019920					_VLCompare:
.019920	c8		iny				iny 								; next character
.019921	b1 12		lda ($12),y			lda 	(zTemp2),y 					; compare variable field against buffer.
.019923	d9 12 03	cmp $0312,y			cmp 	Var_Buffer-3,y 				; the -3 is because name starts at 3.
.019926	d0 df		bne $019907			bne 	_VLNext 					; fail if different, try next.
.019928	0a		asl a				asl 	a 							; until end character (bit 7 set) matched
.019929	90 f5		bcc $019920			bcc 	_VLCompare
.01992b	98		tya				tya
.01992c	38		sec				sec 								; add 1 as Y points to last character
.01992d	65 12		adc $12				adc 	zTemp2 						; add to the current address
.01992f	85 22		sta $22				sta 	zVarDataPtr
.019931	a5 13		lda $13				lda 	zTemp2+1
.019933	69 00		adc #$00			adc 	#0
.019935	85 23		sta $23				sta 	zVarDataPtr+1
.019937	ad 95 03	lda $0395			lda 	Var_Type 					; and set the type.
.01993a	85 24		sta $24				sta 	zVarType
.01993c	38		sec				sec 								; return CS
.01993d	7a		ply		_VLExit:ply
.01993e	fa		plx				plx
.01993f	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/variables/vargetset.asm

.019940					VariableGet:
.019940	5a		phy				phy
.019941	a0 00		ldy #$00			ldy 	#0 							; copy first two bytes
.019943	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.019945	95 80		sta $80,x			sta 	XS_Mantissa,x
.019947	c8		iny				iny
.019948	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01994a	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01994c	c8		iny				iny
.01994d	a5 24		lda $24				lda 	zVarType 					; if it is a string, set up for that.
.01994f	c9 b7		cmp #$b7			cmp 	#token_Dollar
.019951	f0 2c		beq $01997f			beq 	_VGString
.019953	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; copy the next two bytes.
.019955	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019957	c8		iny				iny
.019958	b1 22		lda ($22),y			lda 	(zVarDataPtr),y
.01995a	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01995c	c8		iny				iny
.01995d	a9 01		lda #$01			lda 	#1 							; set type to 1.
.01995f	95 85		sta $85,x			sta 	XS_Type,x
.019961	a5 24		lda $24				lda 	zVarType
.019963	c9 bb		cmp #$bb			cmp 	#token_Percent 				; if it is a %, then exit with default integer.
.019965	f0 28		beq $01998f			beq 	_VGExit
.019967	a9 40		lda #$40			lda 	#$40 						; set type byte to zero
.019969	95 85		sta $85,x			sta 	XS_Type,x 					; which is the code for zero/float.
.01996b	b1 22		lda ($22),y			lda 	(zVarDataPtr),y 			; the last value to copy is the exponent.
.01996d	95 84		sta $84,x			sta 	XS_Exponent,x
.01996f	f0 1e		beq $01998f			beq 	_VGExit 					; if exponent is zero ... it's zero.
.019971	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; the sign bit is the top mantissa bit.
.019973	48		pha				pha
.019974	29 80		and #$80			and 	#$80
.019976	95 85		sta $85,x			sta 	XS_Type,x 					; this is the type byte.
.019978	68		pla				pla
.019979	09 80		ora #$80			ora 	#$80 						; set the MSB as you would expect.
.01997b	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; so it's a normalised float.
.01997d	80 10		bra $01998f			bra 	_VGExit
.01997f					_VGString:
.01997f	a9 02		lda #$02			lda 	#2 							; set type to 2, a string
.019981	95 85		sta $85,x			sta 	XS_Type,x
.019983	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; is the value there $0000
.019985	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019987	d0 06		bne $01998f			bne 	_VGExit 					; if not, exit.
.019989	85 25		sta $25				sta 	zNullString 				; make zNullString a 00 string.
.01998b	a9 25		lda #$25			lda 	#zNullString
.01998d	95 80		sta $80,x			sta 	XS_Mantissa,x 				; make it point to it.
.01998f					_VGExit:
.01998f	7a		ply				ply
.019990	60		rts				rts
.019991					VariableSet:
.019991	b5 85		lda $85,x			lda 	XS_Type,x 					; is the result a string
.019993	29 02		and #$02			and 	#2 							; if so, it has to be
.019995	d0 4b		bne $0199e2			bne 	_VSString
.019997	a5 24		lda $24				lda 	zVarType 					; if type is $ there's an error.
.019999	c9 b7		cmp #$b7			cmp 	#token_Dollar
.01999b	f0 42		beq $0199df			beq 	_VSBadType
.01999d	c9 bb		cmp #$bb			cmp 	#token_Percent 				; type convert to float/int
.01999f	f0 05		beq $0199a6			beq 	_VSMakeInt
.0199a1	20 ca 9e	jsr $019eca			jsr 	FPUToFloat
.0199a4	80 03		bra $0199a9			bra 	_VSCopy
.0199a6					_VSMakeInt:
.0199a6	20 16 9f	jsr $019f16			jsr 	FPUToInteger
.0199a9					_VSCopy:
.0199a9	5a		phy				phy
.0199aa	a0 00		ldy #$00			ldy 	#0 							; copy mantissa to target.
.0199ac	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.0199ae	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199b0	c8		iny				iny
.0199b1	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199b3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199b5	c8		iny				iny
.0199b6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.0199b8	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199ba	c8		iny				iny
.0199bb	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.0199bd	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199bf	a5 24		lda $24				lda 	zVarType 					; if target is integer, alrady done.
.0199c1	c9 bb		cmp #$bb			cmp 	#token_Percent
.0199c3	f0 18		beq $0199dd			beq 	_VSExit
.0199c5	b5 85		lda $85,x			lda 	XS_Type,x 					; get the sign bit into carry flag.
.0199c7	0a		asl a				asl 	a
.0199c8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; shift the sign into the mantissa high.
.0199ca	08		php				php
.0199cb	0a		asl a				asl 	a
.0199cc	28		plp				plp
.0199cd	6a		ror a				ror 	a
.0199ce	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199d0	c8		iny				iny
.0199d1	b5 84		lda $84,x			lda 	XS_Exponent,x 				; copy the exponent in
.0199d3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199d5	34 85		bit $85,x			bit 	XS_Type,x 					; if the result is non zero
.0199d7	50 04		bvc $0199dd			bvc 	_VSExit
.0199d9	a9 00		lda #$00			lda 	#00 						; zero exponent indicating 0.
.0199db	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199dd					_VSExit:
.0199dd	7a		ply				ply
.0199de	60		rts				rts
.0199df					_VSBadType:
.0199df	4c 38 85	jmp $018538			jmp 	TypeError
.0199e2					_VSString:
.0199e2	a5 24		lda $24				lda 	zVarType 					; type must be $
.0199e4	c9 b7		cmp #$b7			cmp 	#token_Dollar
.0199e6	d0 f7		bne $0199df			bne 	_VSBadType
.0199e8	da		phx				phx
.0199e9	5a		phy				phy
.0199ea	20 67 95	jsr $019567			jsr 	StringConcrete 				; concrete the string in the mantissa -> AX
.0199ed	a0 01		ldy #$01			ldy 	#1 							; save high byte
.0199ef	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199f1	88		dey				dey 								; save low byte
.0199f2	8a		txa				txa
.0199f3	91 22		sta ($22),y			sta 	(zVarDataPtr),y
.0199f5	7a		ply				ply 								; and exit.
.0199f6	fa		plx				plx
.0199f7	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/multiply.asm

.0199f8					MulInteger32:
.0199f8	b5 80		lda $80,x			lda 	XS_Mantissa+0,x					; copy +0 to +8
.0199fa	95 8c		sta $8c,x			sta 	XS3_Mantissa,x
.0199fc	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.0199fe	95 8d		sta $8d,x			sta 	XS3_Mantissa+1,x
.019a00	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019a02	95 8e		sta $8e,x			sta 	XS3_Mantissa+2,x
.019a04	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019a06	95 8f		sta $8f,x			sta 	XS3_Mantissa+3,x
.019a08	a9 00		lda #$00			lda 	#0
.019a0a	95 80		sta $80,x			sta 	XS_Mantissa+0,x 				; zero +0
.019a0c	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019a0e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019a10	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019a12					_BFMMultiply:
.019a12	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; get LSBit of 8-11
.019a14	29 01		and #$01			and 	#1
.019a16	f0 03		beq $019a1b			beq 	_BFMNoAdd
.019a18	20 cf 90	jsr $0190cf			jsr 	AddInteger32
.019a1b					_BFMNoAdd:
.019a1b	16 86		asl $86,x			asl 	XS2_Mantissa+0,x 				; shift +4 left
.019a1d	36 87		rol $87,x			rol 	XS2_Mantissa+1,x
.019a1f	36 88		rol $88,x			rol 	XS2_Mantissa+2,x
.019a21	36 89		rol $89,x			rol 	XS2_Mantissa+3,x
.019a23	56 8f		lsr $8f,x			lsr 	XS3_Mantissa+3,x 				; shift +8 right
.019a25	76 8e		ror $8e,x			ror 	XS3_Mantissa+2,x
.019a27	76 8d		ror $8d,x			ror 	XS3_Mantissa+1,x
.019a29	76 8c		ror $8c,x			ror 	XS3_Mantissa,x
.019a2b	b5 8c		lda $8c,x			lda 	XS3_Mantissa,x 					; continue if +8 is nonzero
.019a2d	15 8d		ora $8d,x			ora 	XS3_Mantissa+1,x
.019a2f	15 8e		ora $8e,x			ora 	XS3_Mantissa+2,x
.019a31	15 8f		ora $8f,x			ora 	XS3_Mantissa+3,x
.019a33	d0 dd		bne $019a12			bne 	_BFMMultiply
.019a35	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/divide.asm

.019a36					DivInteger32:
.019a36	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; check for /0
.019a38	15 87		ora $87,x			ora 	XS2_Mantissa+1,x
.019a3a	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.019a3c	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.019a3e	d0 14		bne $019a54			bne 	_BFDOkay
.019a40	20 57 85	jsr $018557			jsr ERR_Handler
>019a43	44 69 76 69 73 69 6f 6e			.text "Division by Zero",0
>019a4b	20 62 79 20 5a 65 72 6f 00
.019a54					_BFDOkay:
.019a54	a9 00		lda #$00			lda 	#0 							; zLTemp1 is 'A' (and holds the remainder)
.019a56	85 1a		sta $1a				sta 	zLTemp1 					; Q/Dividend/Left in +0
.019a58	85 1b		sta $1b				sta 	zLTemp1+1 					; M/Divisor/Right in +4
.019a5a	85 1c		sta $1c				sta 	zLTemp1+2
.019a5c	85 1d		sta $1d				sta 	zLTemp1+3
.019a5e	8d 9e 03	sta $039e			sta 	SignCount 					; Count of signs.
.019a61	20 b8 9a	jsr $019ab8			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.019a64	da		phx				phx
.019a65	e8		inx				inx
.019a66	e8		inx				inx
.019a67	e8		inx				inx
.019a68	e8		inx				inx
.019a69	e8		inx				inx
.019a6a	e8		inx				inx
.019a6b	20 b8 9a	jsr $019ab8			jsr 	CheckIntegerNegate
.019a6e	fa		plx				plx
.019a6f	5a		phy				phy 								; Y is the counter
.019a70	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.019a72					_BFDLoop:
.019a72	16 80		asl $80,x			asl 	XS_Mantissa+0,x 			; shift AQ left.
.019a74	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019a76	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019a78	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019a7a	26 1a		rol $1a				rol 	zLTemp1
.019a7c	26 1b		rol $1b				rol 	zLTemp1+1
.019a7e	26 1c		rol $1c				rol 	zLTemp1+2
.019a80	26 1d		rol $1d				rol 	zLTemp1+3
.019a82	38		sec				sec
.019a83	a5 1a		lda $1a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.019a85	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019a87	48		pha				pha
.019a88	a5 1b		lda $1b				lda 	zLTemp1+1
.019a8a	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019a8c	48		pha				pha
.019a8d	a5 1c		lda $1c				lda 	zLTemp1+2
.019a8f	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019a91	48		pha				pha
.019a92	a5 1d		lda $1d				lda 	zLTemp1+3
.019a94	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019a96	90 13		bcc $019aab			bcc 	_BFDNoAdd
.019a98	85 1d		sta $1d				sta 	zLTemp1+3 					; update A
.019a9a	68		pla				pla
.019a9b	85 1c		sta $1c				sta 	zLTemp1+2
.019a9d	68		pla				pla
.019a9e	85 1b		sta $1b				sta 	zLTemp1+1
.019aa0	68		pla				pla
.019aa1	85 1a		sta $1a				sta 	zLTemp1+0
.019aa3	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; set Q bit 1.
.019aa5	09 01		ora #$01			ora 	#1
.019aa7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019aa9	80 03		bra $019aae			bra 	_BFDNext
.019aab					_BFDNoAdd:
.019aab	68		pla				pla 								; Throw away the intermediate calculations
.019aac	68		pla				pla
.019aad	68		pla				pla
.019aae					_BFDNext:
.019aae	88		dey				dey
.019aaf	d0 c1		bne $019a72			bne 	_BFDLoop
.019ab1	7a		ply				ply 								; restore Y and exit
.019ab2	4e 9e 03	lsr $039e			lsr 	SignCount 					; if sign count odd,
.019ab5	b0 06		bcs $019abd			bcs		IntegerNegateAlways 			; negate the result
.019ab7	60		rts				rts
.019ab8					CheckIntegerNegate:
.019ab8	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019aba	30 01		bmi $019abd			bmi 	IntegerNegateAlways
.019abc	60		rts				rts
.019abd					IntegerNegateAlways:
.019abd	ee 9e 03	inc $039e			inc 	SignCount
.019ac0	38		sec				sec
.019ac1	a9 00		lda #$00			lda 	#0
.019ac3	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019ac5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ac7	a9 00		lda #$00			lda 	#0
.019ac9	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019acb	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019acd	a9 00		lda #$00			lda 	#0
.019acf	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019ad1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ad3	a9 00		lda #$00			lda 	#0
.019ad5	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019ad7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ad9	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/inttostr.asm

.019ada					INTToString:
.019ada	48		pha				pha
.019adb	5a		phy				phy
.019adc	b5 83		lda $83,x			lda 		XS_Mantissa+3,x 		; check -ve
.019ade	10 08		bpl $019ae8			bpl 		_ITSNotMinus
.019ae0	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.019ae2	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter
.019ae5	20 bd 9a	jsr $019abd			jsr 		IntegerNegateAlways 	; negate the number.
.019ae8					_ITSNotMinus:
.019ae8	a9 00		lda #$00			lda 		#0
.019aea	8d 9a 03	sta $039a			sta 		NumSuppress 			; clear the suppression flag.
.019aed	8a		txa				txa 								; use Y for the mantissa index.
.019aee	a8		tay				tay
.019aef	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.019af1					_ITSNextSubtractor:
.019af1	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.019af3	8d 9b 03	sta $039b			sta 		NumConvCount
.019af6					_ITSSubtract:
.019af6	38		sec				sec
.019af7	b9 80 00	lda $0080,y			lda 		XS_Mantissa,y 			; subtract number and push on stack
.019afa	ff 58 9b 01	sbc $019b58,x			sbc 		_ITSSubtractors+0,x
.019afe	48		pha				pha
.019aff	b9 81 00	lda $0081,y			lda 		XS_Mantissa+1,y
.019b02	ff 59 9b 01	sbc $019b59,x			sbc 		_ITSSubtractors+1,x
.019b06	48		pha				pha
.019b07	b9 82 00	lda $0082,y			lda 		XS_Mantissa+2,y
.019b0a	ff 5a 9b 01	sbc $019b5a,x			sbc 		_ITSSubtractors+2,x
.019b0e	48		pha				pha
.019b0f	b9 83 00	lda $0083,y			lda 		XS_Mantissa+3,y
.019b12	ff 5b 9b 01	sbc $019b5b,x			sbc 		_ITSSubtractors+3,x
.019b16	90 14		bcc $019b2c			bcc 		_ITSCantSubtract 		; if CC, then gone too far.
.019b18	99 83 00	sta $0083,y			sta 		XS_Mantissa+3,y 		; save subtract off stack
.019b1b	68		pla				pla
.019b1c	99 82 00	sta $0082,y			sta 		XS_Mantissa+2,y
.019b1f	68		pla				pla
.019b20	99 81 00	sta $0081,y			sta 		XS_Mantissa+1,y
.019b23	68		pla				pla
.019b24	99 80 00	sta $0080,y			sta 		XS_Mantissa+0,y
.019b27	ee 9b 03	inc $039b			inc 		NumConvCount 			; bump count.
.019b2a	80 ca		bra $019af6			bra 		_ITSSubtract 			; go round again.
.019b2c					_ITSCantSubtract:
.019b2c	68		pla				pla 								; throw away interim answers
.019b2d	68		pla				pla
.019b2e	68		pla				pla
.019b2f	ad 9b 03	lda $039b			lda 		NumConvCount 			; if not zero then no suppression check
.019b32	c9 30		cmp #$30			cmp 		#"0"
.019b34	d0 05		bne $019b3b			bne 		_ITSOutputDigit
.019b36	ad 9a 03	lda $039a			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.019b39	10 09		bpl $019b44			bpl	 		_ITSGoNextSubtractor
.019b3b					_ITSOutputDigit:
.019b3b	ce 9a 03	dec $039a			dec 		NumSuppress 			; suppression check will be non-zero.
.019b3e	ad 9b 03	lda $039b			lda 		NumConvCount 			; count of subtractions
.019b41	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter 		; output it.
.019b44					_ITSGoNextSubtractor:
.019b44	e8		inx				inx 								; next dword
.019b45	e8		inx				inx
.019b46	e8		inx				inx
.019b47	e8		inx				inx
.019b48	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.019b4a	d0 a5		bne $019af1			bne 		_ITSNextSubtractor 		; do all the subtractors.
.019b4c	98		tya				tya 								; X is back as the mantissa index
.019b4d	aa		tax				tax
.019b4e	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; and the last digit is left.
.019b50	09 30		ora #$30			ora 		#"0"
.019b52	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter
.019b55	7a		ply				ply 								; and exit
.019b56	68		pla				pla
.019b57	60		rts				rts
.019b58					_ITSSubtractors:
>019b58	00 ca 9a 3b					.dword 		1000000000
>019b5c	00 e1 f5 05					.dword 		100000000
>019b60	80 96 98 00					.dword 		10000000
>019b64	40 42 0f 00					.dword 		1000000
>019b68	a0 86 01 00					.dword 		100000
>019b6c	10 27 00 00					.dword 		10000
>019b70	e8 03 00 00					.dword 		1000
>019b74	64 00 00 00					.dword 		100
>019b78	0a 00 00 00					.dword 		10
.019b7c					_ITSSubtractorsEnd:
.019b7c					ITSOutputCharacter:
.019b7c	48		pha				pha
.019b7d	da		phx				phx
.019b7e	ae 14 03	ldx $0314			ldx 	NumBufX 					; save digit
.019b81	9d 15 03	sta $0315,x			sta 	Num_Buffer,x
.019b84	a9 00		lda #$00			lda		#0 							; follow by trailing NULL
.019b86	9d 16 03	sta $0316,x			sta 	Num_Buffer+1,x
.019b89	ee 14 03	inc $0314			inc 	NumBufX						; bump pointer.
.019b8c	fa		plx				plx
.019b8d	68		pla				pla
.019b8e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/integer/convert/intfromstr.asm

.019b8f					IntFromString:
.019b8f	a0 00		ldy #$00			ldy 	#0
.019b91	8c 9c 03	sty $039c			sty 	ExpTemp 					; this is the converted digit count.
.019b94					IntFromStringY:
.019b94	48		pha				pha
.019b95	a9 00		lda #$00			lda 	#0 							; clear the mantissa
.019b97	95 80		sta $80,x			sta 	XS_Mantissa,x
.019b99	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019b9b	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019b9d	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019b9f	a9 01		lda #$01			lda 	#1
.019ba1	95 85		sta $85,x			sta 	XS_Type,x
.019ba3					_IFSLoop:
.019ba3	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; get next
.019ba5	c9 30		cmp #$30			cmp 	#"0"						; validate it.
.019ba7	90 4e		bcc $019bf7			bcc 	_IFSExit
.019ba9	c9 3a		cmp #$3a			cmp 	#"9"+1
.019bab	b0 4a		bcs $019bf7			bcs 	_IFSExit
.019bad	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; is High Byte > $7F/10
.019baf	c9 0c		cmp #$0c			cmp 	#12
.019bb1	b0 4e		bcs $019c01			bcs 	_IFSOverflow
.019bb3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; push mantissa on stack backwards
.019bb5	48		pha				pha
.019bb6	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019bb8	48		pha				pha
.019bb9	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019bbb	48		pha				pha
.019bbc	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019bbe	48		pha				pha
.019bbf	20 16 9c	jsr $019c16			jsr 	IFSX1ShiftLeft 				; double
.019bc2	20 16 9c	jsr $019c16			jsr 	IFSX1ShiftLeft 				; x 4
.019bc5	18		clc				clc 								; add saved value x 5
.019bc6	68		pla				pla
.019bc7	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019bc9	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019bcb	68		pla				pla
.019bcc	75 81		adc $81,x			adc 	XS_Mantissa+1,x
.019bce	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019bd0	68		pla				pla
.019bd1	75 82		adc $82,x			adc 	XS_Mantissa+2,x
.019bd3	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019bd5	68		pla				pla
.019bd6	75 83		adc $83,x			adc 	XS_Mantissa+3,x
.019bd8	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019bda	20 16 9c	jsr $019c16			jsr 	IFSX1ShiftLeft 				; x 10
.019bdd	ee 9c 03	inc $039c			inc 	ExpTemp 					; bump count of digits processed.
.019be0	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; add digit
.019be2	29 0f		and #$0f			and 	#15
.019be4	c8		iny				iny
.019be5	75 80		adc $80,x			adc 	XS_Mantissa+0,x
.019be7	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019be9	90 b8		bcc $019ba3			bcc 	_IFSLoop
.019beb	f6 81		inc $81,x			inc 	XS_Mantissa+1,x 			; propogate carry round.
.019bed	d0 b4		bne $019ba3			bne 	_IFSLoop
.019bef	f6 82		inc $82,x			inc 	XS_Mantissa+2,x
.019bf1	d0 b0		bne $019ba3			bne 	_IFSLoop
.019bf3	f6 83		inc $83,x			inc 	XS_Mantissa+3,x
.019bf5	80 ac		bra $019ba3			bra 	_IFSLoop
.019bf7					_IFSExit:
.019bf7	98		tya				tya 								; get offset
.019bf8					_IFSOkay:
.019bf8	38		sec				sec
.019bf9	ad 9c 03	lda $039c			lda 	ExpTemp
.019bfc	f0 01		beq $019bff			beq 	_IFSSkipFail
.019bfe	18		clc				clc
.019bff					_IFSSkipFail:
.019bff	68		pla				pla 								; and exit.
.019c00	60		rts				rts
.019c01					_IFSOverflow:
.019c01	20 57 85	jsr $018557			jsr 	ERR_Handler
>019c04	43 6f 6e 73 74 61 6e 74				.text 	"Constant overflow",0
>019c0c	20 6f 76 65 72 66 6c 6f 77 00
.019c16					IFSX1ShiftLeft:
.019c16	16 80		asl $80,x			asl 	XS_Mantissa+0,x
.019c18	36 81		rol $81,x			rol 	XS_Mantissa+1,x
.019c1a	36 82		rol $82,x			rol 	XS_Mantissa+2,x
.019c1c	36 83		rol $83,x			rol 	XS_Mantissa+3,x
.019c1e	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpadd.asm

.019c1f					FPSubtract:
.019c1f	48		pha				pha
.019c20	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of X2 and add
.019c22	49 80		eor #$80			eor 	#$80
.019c24	95 8b		sta $8b,x			sta 	XS2_Type,x
.019c26	68		pla				pla 								; --- and fall through ---
.019c27					FPAdd:
.019c27	48		pha				pha
.019c28	b5 85		lda $85,x			lda 	XS_Type,x 					; if X1 is -ve, specialised code
.019c2a	d0 05		bne $019c31			bne 	_FPA_NegativeLHS
.019c2c	20 48 9c	jsr $019c48			jsr 	FPAdd_Worker 				; if +ve use standard worker unchanged.
.019c2f	68		pla				pla
.019c30	60		rts				rts
.019c31					_FPA_NegativeLHS:
.019c31	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 and X2
.019c33	49 80		eor #$80			eor 	#$80
.019c35	95 85		sta $85,x			sta 	XS_Type,x
.019c37	b5 8b		lda $8b,x			lda 	XS2_Type,x 					; flip the sign of B and add
.019c39	49 80		eor #$80			eor 	#$80
.019c3b	95 8b		sta $8b,x			sta 	XS2_Type,x
.019c3d	20 48 9c	jsr $019c48			jsr 	FPAdd_Worker 				; do the add calculation.
.019c40	b5 85		lda $85,x			lda 	XS_Type,x 					; flip sign of X1 back
.019c42	49 80		eor #$80			eor 	#$80
.019c44	95 85		sta $85,x			sta 	XS_Type,x
.019c46	68		pla				pla
.019c47	60		rts				rts
.019c48					FPAdd_Worker:
.019c48	34 8b		bit $8b,x			bit 	XS2_Type,x					; if X2 is zero (e.g. adding zero)
.019c4a	70 07		bvs $019c53			bvs 	_FPAWExit 					; no change.
.019c4c	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 is zero (e.g. 0 + X2)
.019c4e	50 07		bvc $019c57			bvc 	_FPAWMakeSame 				; then return X2, else make same exponent
.019c50	20 88 9e	jsr $019e88			jsr 	FPUCopyX2ToX1 				; copy X2 to X1
.019c53					_FPAWExit:
.019c53	20 f7 9e	jsr $019ef7			jsr 	FPUNormalise 				; normalise the result.
.019c56	60		rts				rts
.019c57					_FPAWMakeSame:
.019c57	b5 84		lda $84,x			lda 	XS_Exponent,x 				; check if exponents are the same.
.019c59	38		sec				sec
.019c5a	f5 8a		sbc $8a,x			sbc	 	XS2_Exponent,x 				; using subtraction
.019c5c	f0 16		beq $019c74			beq 	_FPAW_DoArithmetic 			; if they are, do the actual arithmetic part.
.019c5e	da		phx				phx 								; save X
.019c5f	90 06		bcc $019c67			bcc 	_FPAWShiftA 				; if X1 < X2 then shift X1
.019c61	e8		inx				inx
.019c62	e8		inx				inx
.019c63	e8		inx				inx
.019c64	e8		inx				inx
.019c65	e8		inx				inx
.019c66	e8		inx				inx
.019c67					_FPAWShiftA:
.019c67	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019c69	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019c6b	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019c6d	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019c6f	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019c71	fa		plx				plx 								; restore original X
.019c72	80 e3		bra $019c57			bra 	_FPAWMakeSame 				; keep going till exponents are the same.
.019c74					_FPAW_DoArithmetic:
.019c74	34 8b		bit $8b,x			bit 	XS2_Type,x 					; is it adding a negative to a positive
.019c76	30 28		bmi $019ca0			bmi 	_FPAW_BNegative
.019c78	18		clc				clc
.019c79	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019c7b	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019c7d	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019c7f	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019c81	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019c83	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019c85	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019c87	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019c89	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019c8b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019c8d	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019c8f	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019c91	90 c0		bcc $019c53			bcc 	_FPAWExit 					; no carry.
.019c93	f6 84		inc $84,x			inc 	XS_Exponent,x 				; so shift exponent up.
.019c95	38		sec				sec
.019c96	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019c98	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019c9a	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019c9c	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019c9e	80 b3		bra $019c53			bra 	_FPAWExit
.019ca0					_FPAW_BNegative:
.019ca0	38		sec				sec
.019ca1	b5 80		lda $80,x			lda 	XS_Mantissa+0,x
.019ca3	f5 86		sbc $86,x			sbc 	XS2_Mantissa+0,x
.019ca5	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019ca7	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019ca9	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019cab	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019cad	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019caf	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019cb1	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019cb3	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019cb5	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019cb7	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019cb9	b0 09		bcs $019cc4			bcs		_FPAWGoExit 				; no borrow, e.g. the result is positive.
.019cbb	20 ae 9e	jsr $019eae			jsr 	FPUNegateInteger			; negate the mantissa
.019cbe	b5 85		lda $85,x			lda 	XS_Type,x 					; flip result sign
.019cc0	49 80		eor #$80			eor 	#$80
.019cc2	95 85		sta $85,x			sta 	XS_Type,x
.019cc4					_FPAWGoExit:
.019cc4	4c 53 9c	jmp $019c53			jmp 	_FPAWExit

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpdivide.asm

.019cc7					FPD_IsDivZero:
.019cc7	20 57 85	jsr $018557			jsr ERR_Handler
>019cca	44 69 76 69 73 69 6f 6e			.text "Division by zero",0
>019cd2	20 62 79 20 7a 65 72 6f 00
.019cdb					FPDivide:
.019cdb	48		pha				pha
.019cdc	5a		phy				phy
.019cdd	34 8b		bit $8b,x			bit 	XS2_Type,x 					; check if division by zero
.019cdf	70 e6		bvs $019cc7			bvs 	FPD_IsDivZero 				; if X2 is zero, cause an error.
.019ce1	34 85		bit $85,x			bit 	XS_Type,x 					; if 0/X (X is not zero) return 0
.019ce3	f0 03		beq $019ce8			beq 	_FPDCalculateExp
.019ce5					_FPD_Exit:
.019ce5	7a		ply				ply
.019ce6	68		pla				pla
.019ce7	60		rts				rts
.019ce8					_FPDCalculateExp:
.019ce8	b5 8a		lda $8a,x			lda 	XS2_Exponent,x 				; negate the 2nd exponent
.019cea	49 ff		eor #$ff			eor 	#$FF
.019cec	1a		inc a				inc 	a
.019ced	95 8a		sta $8a,x			sta 	XS2_Exponent,x
.019cef	20 bf 9d	jsr $019dbf			jsr 	FPCalculateExponent 		; then we can use the multiply version.
.019cf2	18		clc				clc 	 							; add 1 to the resulting exponent
.019cf3	69 01		adc #$01			adc 	#1
.019cf5	b0 54		bcs $019d4b			bcs 	_FPD_Overflow 				; which can overflow.
.019cf7	95 84		sta $84,x			sta 	XS_Exponent,x
.019cf9	a9 00		lda #$00			lda 	#0 							; clear result (kept in zLTemp1)
.019cfb	85 1a		sta $1a				sta 	zLTemp1+0
.019cfd	85 1b		sta $1b				sta 	zLTemp1+1
.019cff	85 1c		sta $1c				sta 	zLTemp1+2
.019d01	85 1d		sta $1d				sta 	zLTemp1+3
.019d03	a0 20		ldy #$20			ldy 	#32 						; times round.
.019d05					_FPD_Loop:
.019d05	38		sec				sec 								; calculate X1-X2 stacking result because we might
.019d06	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; not save it.
.019d08	f5 86		sbc $86,x			sbc 	XS2_Mantissa,x
.019d0a	48		pha				pha
.019d0b	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019d0d	f5 87		sbc $87,x			sbc 	XS2_Mantissa+1,x
.019d0f	48		pha				pha
.019d10	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019d12	f5 88		sbc $88,x			sbc 	XS2_Mantissa+2,x
.019d14	48		pha				pha
.019d15	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019d17	f5 89		sbc $89,x			sbc 	XS2_Mantissa+3,x
.019d19	90 13		bcc $019d2e			bcc		_FPD_NoSubtract 			; if CC couldn't subtract without borrowing.
.019d1b	95 83		sta $83,x			sta 	XS_Mantissa+3,x 			; save results out to A
.019d1d	68		pla				pla
.019d1e	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019d20	68		pla				pla
.019d21	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019d23	68		pla				pla
.019d24	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019d26	a5 1d		lda $1d				lda 	zLTemp1+3 					; set high bit of result
.019d28	09 80		ora #$80			ora 	#$80
.019d2a	85 1d		sta $1d				sta 	zLTemp1+3
.019d2c	80 03		bra $019d31			bra 	_FPD_Rotates
.019d2e					_FPD_NoSubtract:
.019d2e	68		pla				pla 								; throw away unwanted results
.019d2f	68		pla				pla
.019d30	68		pla				pla
.019d31					_FPD_Rotates:
.019d31	56 89		lsr $89,x			lsr 	3+XS2_Mantissa,x
.019d33	76 88		ror $88,x			ror 	2+XS2_Mantissa,x
.019d35	76 87		ror $87,x			ror 	1+XS2_Mantissa,x
.019d37	76 86		ror $86,x			ror 	0+XS2_Mantissa,x
.019d39	06 1a		asl $1a				asl 	zLTemp1 					; rotate result round left
.019d3b	26 1b		rol $1b				rol 	zLTemp1+1
.019d3d	26 1c		rol $1c				rol 	zLTemp1+2
.019d3f	26 1d		rol $1d				rol 	zLTemp1+3
.019d41	90 02		bcc $019d45			bcc 	_FPD_NoCarry
.019d43	e6 1a		inc $1a				inc 	zLTemp1 					; if rotated out, set LSB.
.019d45					_FPD_NoCarry:
.019d45	88		dey				dey 								; do 32 times
.019d46	d0 bd		bne $019d05			bne 	_FPD_Loop
.019d48	4c a3 9d	jmp $019da3			jmp 	FPM_CopySignNormalize 		; hijack multiply exit.
.019d4b					_FPD_Overflow:
.019d4b	4c 54 9f	jmp $019f54			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpmultiply.asm

.019d4e					FPMultiply:
.019d4e	48		pha				pha
.019d4f	5a		phy				phy
.019d50	34 85		bit $85,x			bit 	XS_Type,x 					; if X1 = 0, return X1 e.g. zero.
.019d52	70 07		bvs $019d5b			bvs 	_FPM_Exit
.019d54	34 8b		bit $8b,x			bit		XS2_Type,x 					; if X2 = 0, return X2 unchanged, e.g. zero :)
.019d56	50 06		bvc $019d5e			bvc 	_FPM_CalcExponent
.019d58	20 88 9e	jsr $019e88			jsr 	FPUCopyX2ToX1
.019d5b					_FPM_Exit:
.019d5b	7a		ply				ply
.019d5c	68		pla				pla
.019d5d	60		rts				rts
.019d5e					_FPM_CalcExponent:
.019d5e	18		clc				clc
.019d5f	20 bf 9d	jsr $019dbf			jsr 	FPCalculateExponent 		; calc exponent of product. (also used by divide)
.019d62	95 84		sta $84,x			sta 	XS_Exponent,x 				; save the result.
.019d64	a9 00		lda #$00			lda 	#0
.019d66	85 1a		sta $1a				sta 	zLTemp1+0 					; clear the long temp which is upper word of
.019d68	85 1b		sta $1b				sta 	zLTemp1+1 					; long product. lower word is mantissa-A
.019d6a	85 1c		sta $1c				sta 	zLTemp1+2 					; multiplicand is mantissa-B
.019d6c	85 1d		sta $1d				sta 	zLTemp1+3
.019d6e	a0 20		ldy #$20			ldy 	#32							; X is loop counter, do it 32 times.
.019d70					_FPM_Loop:
.019d70	b5 80		lda $80,x			lda 	XS_Mantissa,x				; check LSB of long product
.019d72	29 01		and #$01			and 	#1
.019d74	18		clc				clc 								; clear carry for the long rotate.
.019d75	f0 19		beq $019d90			beq 	_FPM_NoAddition
.019d77	18		clc				clc 								; add X2 mantissa to the MSB of the long product.
.019d78	a5 1a		lda $1a				lda 	zLTemp1+0
.019d7a	75 86		adc $86,x			adc 	XS2_Mantissa+0,x
.019d7c	85 1a		sta $1a				sta 	zLTemp1+0
.019d7e	a5 1b		lda $1b				lda 	zLTemp1+1
.019d80	75 87		adc $87,x			adc 	XS2_Mantissa+1,x
.019d82	85 1b		sta $1b				sta 	zLTemp1+1
.019d84	a5 1c		lda $1c				lda 	zLTemp1+2
.019d86	75 88		adc $88,x			adc 	XS2_Mantissa+2,x
.019d88	85 1c		sta $1c				sta 	zLTemp1+2
.019d8a	a5 1d		lda $1d				lda 	zLTemp1+3
.019d8c	75 89		adc $89,x			adc 	XS2_Mantissa+3,x
.019d8e	85 1d		sta $1d				sta 	zLTemp1+3
.019d90					_FPM_NoAddition:
.019d90	66 1d		ror $1d				ror 	3+zLTemp1
.019d92	66 1c		ror $1c				ror 	2+zLTemp1
.019d94	66 1b		ror $1b				ror 	1+zLTemp1
.019d96	66 1a		ror $1a				ror 	0+zLTemp1
.019d98	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019d9a	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019d9c	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019d9e	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019da0	88		dey				dey
.019da1	d0 cd		bne $019d70			bne 	_FPM_Loop 					; do this 32 times.
.019da3					FPM_CopySignNormalize:
.019da3	a5 1a		lda $1a				lda 	zLTemp1+0 					; copy the left product into Mantissa A.
.019da5	95 80		sta $80,x			sta 	XS_Mantissa,x 				; which is the 32 x 32 product upper bits.
.019da7	a5 1b		lda $1b				lda 	zLTemp1+1
.019da9	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019dab	a5 1c		lda $1c				lda 	zLTemp1+2
.019dad	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019daf	a5 1d		lda $1d				lda 	zLTemp1+3
.019db1	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019db3	b5 85		lda $85,x			lda 	XS_Type,x 					; sign is xor of signs
.019db5	55 8b		eor $8b,x			eor 	XS2_Type,x
.019db7	95 85		sta $85,x			sta 	XS_Type,x
.019db9	20 f7 9e	jsr $019ef7			jsr 	FPUNormalise 				; normalise and exit.
.019dbc	7a		ply				ply
.019dbd	68		pla				pla
.019dbe	60		rts				rts
.019dbf					FPCalculateExponent:
.019dbf	18		clc				clc
.019dc0	b5 84		lda $84,x			lda 	XS_Exponent,x 				; this is with $80 being 2^0.
.019dc2	75 8a		adc $8a,x			adc 	XS2_Exponent,x
.019dc4	b0 08		bcs $019dce			bcs 	_FPCECarry 					; carry out ?
.019dc6	10 03		bpl $019dcb			bpl 	_FPCEExpZero 				; if 0-127 then the product < minimum float
.019dc8	29 7f		and #$7f			and 	#$7F 						; this is the actual exponent.
.019dca	60		rts				rts
.019dcb					_FPCEExpZero:
.019dcb	a9 00		lda #$00			lda 	#0
.019dcd	60		rts				rts
.019dce					_FPCECarry:
.019dce	30 03		bmi $019dd3			bmi 	_FPCEOverflow 				; overflow if say 255 + 129 (2^127+2^1)
.019dd0	09 80		ora #$80			ora 	#$80 						; put in right range
.019dd2	60		rts				rts
.019dd3					_FPCEOverflow:
.019dd3	4c 54 9f	jmp $019f54			jmp 	FP_Overflow

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpparts.asm

.019dd6					FPFractionalPart:
.019dd6	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent $00-$7F then unchanged as fractional.
.019dd8	38		sec				sec 								; this flag tells us to keep the fractional part
.019dd9	30 0d		bmi $019de8			bmi 	FPGetPart
.019ddb	60		rts				rts
.019ddc					FPIntegerPart:
.019ddc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent -ve then the result is zero (must be < 1.0)
.019dde	18		clc				clc 								; this flag says keep the integer part.
.019ddf	30 07		bmi $019de8			bmi 	FPGetPart 					; -ve exponents are 0..127
.019de1	48		pha				pha
.019de2	a9 40		lda #$40			lda 	#$40 						; set the Zero Flag
.019de4	95 85		sta $85,x			sta 	XS_Type,x
.019de6	68		pla				pla
.019de7	60		rts				rts
.019de8					FPGetPart:
.019de8	48		pha				pha
.019de9	5a		phy				phy 								; save Y
.019dea	08		php				php 								; save action
.019deb	34 85		bit $85,x			bit 	XS_Type,x 					; if zero, return zero for int and frac
.019ded	70 59		bvs $019e48			bvs 	_FPGP_Exit 					; then do nothing.
.019def	a9 ff		lda #$ff			lda 	#$FF 						; set the mask long to -1
.019df1	85 1a		sta $1a				sta 	zLTemp1+0 					; this mask is applied to chop out the
.019df3	85 1b		sta $1b				sta 	zLTemp1+1 					; bits you would keep/lose if it was exponent 32.
.019df5	85 1c		sta $1c				sta 	zLTemp1+2
.019df7	85 1d		sta $1d				sta 	zLTemp1+3
.019df9	b5 84		lda $84,x			lda 	XS_Exponent,x				; the number of shifts.
.019dfb	38		sec				sec
.019dfc	e9 80		sbc #$80			sbc 	#128 						; is the exponent value-128
.019dfe	f0 12		beq $019e12			beq 	_FPGP_NoShift 				; ... if any
.019e00	c9 20		cmp #$20			cmp 	#32
.019e02	90 02		bcc $019e06			bcc 	_FPGP_NotMax
.019e04	a9 20		lda #$20			lda 	#32 						; max of 32.
.019e06					_FPGP_NotMax:
.019e06	a8		tay				tay 								; Y is the mask shift count.
.019e07					_FPGP_ShiftMask:
.019e07	46 1d		lsr $1d				lsr 	3+zLTemp1
.019e09	66 1c		ror $1c				ror 	2+zLTemp1
.019e0b	66 1b		ror $1b				ror 	1+zLTemp1
.019e0d	66 1a		ror $1a				ror 	0+zLTemp1
.019e0f	88		dey				dey
.019e10	d0 f5		bne $019e07			bne 	_FPGP_ShiftMask
.019e12					_FPGP_NoShift:
.019e12	a0 00		ldy #$00			ldy 	#0 							; now mask each part in turn.
.019e14	8e 9c 03	stx $039c			stx 	ExpTemp						; save X
.019e17					_FPGP_MaskLoop:
.019e17	b9 1a 00	lda $001a,y			lda 	zlTemp1,y 					; get mask byte
.019e1a	28		plp				plp 								; if CC we keep the top part, so we
.019e1b	08		php				php		 							; flip the mask.
.019e1c	b0 02		bcs $019e20			bcs		_FPGP_NoFlip
.019e1e	49 ff		eor #$ff			eor 	#$FF
.019e20					_FPGP_NoFlip:
.019e20	35 80		and $80,x			and 	XS_Mantissa,x 				; and into the mantissa.
.019e22	95 80		sta $80,x			sta 	XS_Mantissa,x
.019e24	e8		inx				inx
.019e25	c8		iny				iny
.019e26	c0 04		cpy #$04			cpy 	#4 							; until done 32 bits.
.019e28	d0 ed		bne $019e17			bne 	_FPGP_MaskLoop
.019e2a	ae 9c 03	ldx $039c			ldx 	ExpTemp						; restore X
.019e2d	28		plp				plp
.019e2e	08		php				php 								; get action flag on the stack
.019e2f	90 04		bcc $019e35			bcc 	_FPGP_NotFractional 		; if fractional part always return +ve.
.019e31	a9 00		lda #$00			lda 	#0
.019e33	95 85		sta $85,x			sta 	XS_Type,x
.019e35					_FPGP_NotFractional:
.019e35	b5 80		lda $80,x			lda 	XS_Mantissa,x 						; check if \1 zero
.019e37	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019e39	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019e3b	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019e3d	f0 05		beq $019e44			beq 	_FPGP_Zero 					; if zero, return zero
.019e3f	20 f7 9e	jsr $019ef7			jsr 	FPUNormalise
.019e42	80 04		bra $019e48			bra 	_FPGP_Exit 					; and exit
.019e44					_FPGP_Zero:
.019e44	a9 40		lda #$40			lda 	#$40 						; set zero flag
.019e46	95 85		sta $85,x			sta 	XS_Type,x
.019e48					_FPGP_Exit:
.019e48	68		pla				pla 								; throw saved action flag.
.019e49	7a		ply				ply
.019e4a	68		pla				pla
.019e4b	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fpcompare.asm

.019e4c					FPCompare:
.019e4c	b5 84		lda $84,x			lda 	XS_Exponent,x 				; save the exponents on the stack
.019e4e	48		pha				pha
.019e4f	b5 8a		lda $8a,x			lda 	XS2_Exponent,x
.019e51	48		pha				pha
.019e52	20 1f 9c	jsr $019c1f			jsr 	FPSubtract 					; calculate X1-X2
.019e55	34 85		bit $85,x			bit 	XS_Type,x 					; is the result zero ? (e.g. zero flag set)
.019e57	70 2a		bvs $019e83			bvs 	_FPCPullZero 				; if so, then return zero throwing saved exp
.019e59	68		pla				pla
.019e5a	8d 9c 03	sta $039c			sta 	ExpTemp						; save first exponent in temporary reg.
.019e5d	68		pla				pla
.019e5e	38		sec				sec
.019e5f	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; calculate AX-BX
.019e62	70 14		bvs $019e78			bvs 	_FPCNotEqual				; overflow, can't be equal.
.019e64	1a		inc a				inc 	a 							; map -1,0,1 to 0,1,2
.019e65	c9 03		cmp #$03			cmp 	#3 							; if >= 3 e.g. abs difference > 1
.019e67	b0 0f		bcs $019e78			bcs 	_FPCNotEqual  				; exponents can't be more than 2 out.
.019e69	38		sec				sec
.019e6a	ad 9c 03	lda $039c			lda 	ExpTemp 					; get one of the exponents back.
.019e6d	e9 12		sbc #$12			sbc 	#18 						; allow for 2^18 error, relatively.
.019e6f	b0 02		bcs $019e73			bcs 	_FPCNotRange 				; keep in range.
.019e71	a9 01		lda #$01			lda 	#1
.019e73					_FPCNotRange:
.019e73	38		sec				sec
.019e74	f5 84		sbc $84,x			sbc 	XS_Exponent,x  				; if exponent of difference greater than this
.019e76	b0 0d		bcs $019e85			bcs 	_FPCZero 					; then error is nearly zero, so we let it go.
.019e78					_FPCNotEqual:
.019e78	b5 85		lda $85,x			lda 	XS_Type,x					; so this needs to be $FF (-ve) $01 (+ve)
.019e7a	29 80		and #$80			and 	#$80 						; $80 if -ve, $00 if +ve
.019e7c	f0 02		beq $019e80			beq 	_FPCNE2
.019e7e	a9 fe		lda #$fe			lda 	#$FE 						; $FE if -ve, $00 if +ve
.019e80	1a		inc a		_FPCNE2:inc 	a 							; $FF if -ve, $01 if +ve
.019e81	80 04		bra $019e87			bra 	_FPCExit
.019e83					_FPCPullZero:
.019e83	68		pla				pla 								; throw saved exponents
.019e84	68		pla				pla
.019e85					_FPCZero:
.019e85	a9 00		lda #$00			lda 	#0 							; and return zero
.019e87					_FPCExit:
.019e87	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/fputils.asm

.019e88					FPUCopyX2ToX1:
.019e88	48		pha				pha
.019e89	da		phx				phx
.019e8a	5a		phy				phy
.019e8b	a0 08		ldy #$08			ldy 	#8
.019e8d	b5 86		lda $86,x	_FPUC21:lda 	XS2_Mantissa,x
.019e8f	95 80		sta $80,x			sta 	XS_Mantissa,x
.019e91	e8		inx				inx
.019e92	88		dey				dey
.019e93	10 f8		bpl $019e8d			bpl 	_FPUC21
.019e95	7a		ply				ply
.019e96	fa		plx				plx
.019e97	68		pla				pla
.019e98	60		rts				rts
.019e99					FPUSetInteger:
.019e99	48		pha				pha
.019e9a	95 80		sta $80,x			sta 	XS_Mantissa,x 				; set the lowest byte.
.019e9c	29 80		and #$80			and 	#$80 						; make this $00 or $FF dependent on MSB
.019e9e	10 02		bpl $019ea2			bpl 	_FPUSIExtend
.019ea0	a9 ff		lda #$ff			lda 	#$FF
.019ea2					_FPUSIExtend:
.019ea2	95 81		sta $81,x			sta 	XS_Mantissa+1,x 			; copy into the rest of the mantissa
.019ea4	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ea6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ea8	a9 01		lda #$01			lda 	#1 			 				; type is integer (set bit 0)
.019eaa	95 85		sta $85,x			sta 	XS_Type,x
.019eac	68		pla				pla
.019ead	60		rts				rts
.019eae					FPUNegateInteger:
.019eae	48		pha				pha
.019eaf	38		sec				sec
.019eb0	a9 00		lda #$00			lda 	#0 							; simple 32 bit subtraction.
.019eb2	f5 80		sbc $80,x			sbc 	XS_Mantissa+0,x
.019eb4	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019eb6	a9 00		lda #$00			lda 	#0
.019eb8	f5 81		sbc $81,x			sbc 	XS_Mantissa+1,x
.019eba	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019ebc	a9 00		lda #$00			lda 	#0
.019ebe	f5 82		sbc $82,x			sbc 	XS_Mantissa+2,x
.019ec0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019ec2	a9 00		lda #$00			lda 	#0
.019ec4	f5 83		sbc $83,x			sbc 	XS_Mantissa+3,x
.019ec6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019ec8	68		pla				pla
.019ec9	60		rts				rts
.019eca					FPUToFloat:
.019eca	48		pha				pha
.019ecb	b5 85		lda $85,x			lda 	XS_Type,x					; exit if already float.
.019ecd	29 0f		and #$0f			and 	#$0F
.019ecf	f0 24		beq $019ef5			beq 	_FPUFExit
.019ed1	a9 00		lda #$00			lda 	#0  						; zero the type byte, making it a float.
.019ed3	95 85		sta $85,x			sta 	XS_Type,x
.019ed5	a9 a0		lda #$a0			lda 	#128+32 					; and the exponent to 32, makes it * 2^32
.019ed7	95 84		sta $84,x			sta 	XS_Exponent,x 				; x mantissa.
.019ed9	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; signed integer ?
.019edb	10 07		bpl $019ee4			bpl		_FPUFPositive
.019edd	20 ae 9e	jsr $019eae			jsr 	FPUNegateInteger 			; negate the mantissa
.019ee0	a9 80		lda #$80			lda 	#$80 						; set the sign flag.
.019ee2	95 85		sta $85,x			sta 	XS_Type,x
.019ee4					_FPUFPositive:
.019ee4	b5 80		lda $80,x			lda 	XS_Mantissa,x 				; mantissa is zero ?
.019ee6	15 81		ora $81,x			ora 	XS_Mantissa+1,x
.019ee8	15 82		ora $82,x			ora 	XS_Mantissa+2,x
.019eea	15 83		ora $83,x			ora 	XS_Mantissa+3,x
.019eec	d0 04		bne $019ef2			bne 	_FPUFNonZero
.019eee	a9 40		lda #$40			lda 	#$40 						; set the zero flag only in type byte
.019ef0	95 85		sta $85,x			sta 	XS_Type,x
.019ef2					_FPUFNonZero:
.019ef2	20 f7 9e	jsr $019ef7			jsr 	FPUNormalise 				; normalise the floating point.
.019ef5					_FPUFExit:
.019ef5	68		pla				pla
.019ef6	60		rts				rts
.019ef7					FPUNormalise:
.019ef7	48		pha				pha
.019ef8	34 85		bit $85,x			bit 	XS_Type,x 					; if float-zero, don't need to normalise it.
.019efa	70 18		bvs $019f14			bvs 	_FPUNExit
.019efc	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent is zero, then make it zero.
.019efe	f0 10		beq $019f10			beq 	_FPUNSetZero
.019f00					_FPUNLoop:
.019f00	b5 83		lda $83,x			lda 	XS_Mantissa+3,x 			; bit 31 of mantissa set.
.019f02	30 10		bmi $019f14			bmi 	_FPUNExit 					; if so, we are normalised.
.019f04	16 80		asl $80,x			asl 	0+XS_Mantissa+0,x
.019f06	36 81		rol $81,x			rol 	1+XS_Mantissa+0,x
.019f08	36 82		rol $82,x			rol 	2+XS_Mantissa+0,x
.019f0a	36 83		rol $83,x			rol 	3+XS_Mantissa+0,x
.019f0c	d6 84		dec $84,x			dec 	XS_Exponent,x 				; decrement exponent
.019f0e	d0 f0		bne $019f00			bne 	_FPUNLoop 		 			; go round again until bit 31 set.
.019f10					_FPUNSetZero:
.019f10	a9 40		lda #$40			lda 	#$40
.019f12	95 85		sta $85,x			sta 	XS_Type,x 					; the result is now zero.
.019f14					_FPUNExit:
.019f14	68		pla				pla
.019f15	60		rts				rts
.019f16					FPUToInteger:
.019f16	48		pha				pha
.019f17	b5 85		lda $85,x			lda 	XS_Type,x 					; if already integer, exit
.019f19	29 01		and #$01			and 	#1
.019f1b	d0 31		bne $019f4e			bne 	_FPUTOI_Exit
.019f1d	34 85		bit $85,x			bit 	XS_Type,x					; if zero, return zero.
.019f1f	70 23		bvs $019f44			bvs 	_FPUTOI_Zero
.019f21	b5 84		lda $84,x			lda 	XS_Exponent,x 				; if exponent 00-7F
.019f23	10 1f		bpl $019f44			bpl 	_FPUToI_Zero 				; the integer value will be zero (< 1.0)
.019f25	c9 a0		cmp #$a0			cmp 	#128+32 					; sign exponent >= 32, overflow.
.019f27	b0 2b		bcs $019f54			bcs 	FP_Overflow
.019f29					_FPUToIToInteger:
.019f29	b5 84		lda $84,x			lda 	XS_Exponent,x 				; keep right shifting until reached 2^32
.019f2b	c9 a0		cmp #$a0			cmp 	#128+32
.019f2d	f0 0c		beq $019f3b			beq 	_FPUToICheckSign 			; check sign needs fixing up.
.019f2f	f6 84		inc $84,x			inc 	XS_Exponent,X 				; increment Exponent
.019f31	56 83		lsr $83,x			lsr 	3+XS_Mantissa,x
.019f33	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019f35	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019f37	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019f39	80 ee		bra $019f29			bra 	_FPUToIToInteger 			; keep going.
.019f3b					_FPUToICheckSign:
.019f3b	b5 85		lda $85,x			lda 	XS_Type,x 					; check sign
.019f3d	10 0f		bpl $019f4e			bpl 	_FPUToI_Exit 				; exit if unsigned.
.019f3f	20 ae 9e	jsr $019eae			jsr 	FPUNegateInteger 			; otherwise negate the shifted mantissa
.019f42	80 0a		bra $019f4e			bra 	_FPUTOI_Exit
.019f44					_FPUTOI_Zero:
.019f44	a9 00		lda #$00			lda 	#0 							; return zero integer.
.019f46	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f48	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f4a	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f4c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f4e					_FPUToI_Exit:
.019f4e	a9 01		lda #$01			lda 	#1 							; set type to integer
.019f50	95 85		sta $85,x			sta 	XS_Type,x
.019f52	68		pla				pla
.019f53	60		rts				rts
.019f54					FP_Overflow:
.019f54	20 57 85	jsr $018557			jsr ERR_Handler
>019f57	46 6c 6f 61 74 69 6e 67			.text "Floating Point overflow",0
>019f5f	20 50 6f 69 6e 74 20 6f 76 65 72 66 6c 6f 77 00
.019f6f					FPUTimes10:
.019f6f	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; copy mantissa to ZLTemp1
.019f71	85 1a		sta $1a				sta 	ZLTemp1+0
.019f73	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f75	85 1b		sta $1b				sta 	ZLTemp1+1
.019f77	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f79	85 1c		sta $1c				sta 	ZLTemp1+2
.019f7b	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f7d	85 1d		sta $1d				sta 	ZLTemp1+3
.019f7f	20 b4 9f	jsr $019fb4			jsr 	_FPUT_LSR_ZLTemp1 			; divide ZLTemp1 by 4
.019f82	20 b4 9f	jsr $019fb4			jsr 	_FPUT_LSR_ZLTemp1
.019f85	18		clc				clc
.019f86	b5 80		lda $80,x			lda 	XS_Mantissa+0,x 			; add n/4 to n
.019f88	65 1a		adc $1a				adc 	ZLTemp1+0
.019f8a	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.019f8c	b5 81		lda $81,x			lda 	XS_Mantissa+1,x
.019f8e	65 1b		adc $1b				adc 	ZLTemp1+1
.019f90	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019f92	b5 82		lda $82,x			lda 	XS_Mantissa+2,x
.019f94	65 1c		adc $1c				adc 	ZLTemp1+2
.019f96	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019f98	b5 83		lda $83,x			lda 	XS_Mantissa+3,x
.019f9a	65 1d		adc $1d				adc 	ZLTemp1+3
.019f9c	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019f9e	90 0a		bcc $019faa			bcc 	_FPUTimes10
.019fa0	76 83		ror $83,x			ror 	3+XS_Mantissa,x
.019fa2	76 82		ror $82,x			ror 	2+XS_Mantissa,x
.019fa4	76 81		ror $81,x			ror 	1+XS_Mantissa,x
.019fa6	76 80		ror $80,x			ror 	0+XS_Mantissa,x
.019fa8	f6 84		inc $84,x			inc 	XS_Exponent,x				; fix exponent
.019faa					_FPUTimes10:
.019faa	b5 84		lda $84,x			lda 	XS_Exponent,x 				; fix up x 2^3 e.g. multiply by 8.
.019fac	18		clc				clc
.019fad	69 03		adc #$03			adc 	#3
.019faf	95 84		sta $84,x			sta 	XS_Exponent,x
.019fb1	b0 a1		bcs $019f54			bcs 	FP_Overflow 				; error
.019fb3	60		rts				rts
.019fb4					_FPUT_LSR_ZLTemp1:
.019fb4	46 1d		lsr $1d				lsr 	ZLTemp1+3
.019fb6	66 1c		ror $1c				ror 	ZLTemp1+2
.019fb8	66 1b		ror $1b				ror 	ZLTemp1+1
.019fba	66 1a		ror $1a				ror 	ZLTemp1+0
.019fbc	60		rts				rts
.019fbd					FPUScale10A:
.019fbd	5a		phy				phy
.019fbe	c9 00		cmp #$00			cmp 	#0 							; if A = 0, nothing to scale
.019fc0	f0 37		beq $019ff9			beq 	_FPUScaleExit
.019fc2	da		phx				phx 								; save X
.019fc3	e8		inx				inx
.019fc4	e8		inx				inx
.019fc5	e8		inx				inx
.019fc6	e8		inx				inx
.019fc7	e8		inx				inx
.019fc8	e8		inx				inx
.019fc9	a8		tay				tay 								; save power scalar in Y.
.019fca	a9 00		lda #$00			lda 	#0
.019fcc	95 80		sta $80,x			sta 	XS_Mantissa+0,x 			; set slot to 1.0
.019fce	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.019fd0	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.019fd2	95 85		sta $85,x			sta 	XS_Type,x
.019fd4	a9 80		lda #$80			lda 	#$80
.019fd6	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.019fd8	a9 81		lda #$81			lda 	#$81
.019fda	95 84		sta $84,x			sta 	XS_Exponent,x
.019fdc	5a		phy				phy 								; save 10^n on stack.
.019fdd	c0 00		cpy #$00			cpy 	#0
.019fdf	10 05		bpl $019fe6			bpl 	_FPUSAbs 					; set Y = |Y|, we want to multiply that 1.0 x 10
.019fe1	98		tya				tya
.019fe2	49 ff		eor #$ff			eor 	#$FF
.019fe4	1a		inc a				inc 	a
.019fe5	a8		tay				tay
.019fe6					_FPUSAbs:
.019fe6	20 6f 9f	jsr $019f6f			jsr 	FPUTimes10
.019fe9	88		dey				dey
.019fea	d0 fa		bne $019fe6			bne 	_FPUSAbs 					; tos is now 10^|AC|
.019fec	68		pla				pla 								; restore count in A
.019fed	fa		plx				plx 								; restore X pointing to number to scale.
.019fee	0a		asl a				asl 	a
.019fef	b0 05		bcs $019ff6			bcs 	_FPUSDivide 				; if bit 7 of count set, divide
.019ff1	20 4e 9d	jsr $019d4e			jsr 	FPMultiply 					; if clear multiply.
.019ff4	80 03		bra $019ff9			bra		_FPUScaleExit
.019ff6					_FPUSDivide:
.019ff6	20 db 9c	jsr $019cdb			jsr 	FPDivide
.019ff9					_FPUScaleExit:
.019ff9	7a		ply				ply
.019ffa	60		rts				rts
.019ffb					FPUCopyToNext:
.019ffb	a0 06		ldy #$06			ldy 		#6
.019ffd	da		phx				phx
.019ffe					_FPUCopy1:
.019ffe	b5 80		lda $80,x			lda 	XS_Mantissa,x
.01a000	95 86		sta $86,x			sta 	XS2_Mantissa,x
.01a002	e8		inx				inx
.01a003	88		dey				dey
.01a004	d0 f8		bne $019ffe			bne 	_FPUCopy1
.01a006	fa		plx				plx
.01a007	60		rts				rts
.01a008					FPUCopyFromNext:
.01a008	a0 06		ldy #$06			ldy 		#6
.01a00a	da		phx				phx
.01a00b					_FPUCopy1:
.01a00b	b5 86		lda $86,x			lda 	XS2_Mantissa,x
.01a00d	95 80		sta $80,x			sta 	XS_Mantissa,x
.01a00f	e8		inx				inx
.01a010	88		dey				dey
.01a011	d0 f8		bne $01a00b			bne 	_FPUCopy1
.01a013	fa		plx				plx
.01a014	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fptostr.asm

.01a015					FPToString:
.01a015	48		pha				pha
.01a016	5a		phy				phy
.01a017	34 85		bit $85,x			bit 		XS_Type,x 				; check zero flag
.01a019	50 0a		bvc $01a025			bvc 		_FPTSIsFloat 			; if zero,
.01a01b					_FPTSZero:
.01a01b	a9 30		lda #$30			lda 		#"0"
.01a01d	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter
.01a020					_FPTSExit:
.01a020	7a		ply				ply
.01a021	68		pla				pla
.01a022	60		rts				rts
.01a023	80 fb		bra $01a020			bra 		_FPTSExit
.01a025					_FPTSIsFloat:
.01a025	b5 85		lda $85,x			lda 		XS_Type,x 				; is it signed ?
.01a027	10 09		bpl $01a032			bpl 		_FPTSNotSigned
.01a029	a9 00		lda #$00			lda 		#0 						; clear sign flag
.01a02b	95 85		sta $85,x			sta 		XS_Type,x
.01a02d	a9 2d		lda #$2d			lda 		#"-"					; output a minus
.01a02f	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter
.01a032					_FPTSNotSigned:
.01a032	b5 84		lda $84,x			lda 		XS_Exponent,x
.01a034	c9 98		cmp #$98			cmp 		#128+24 				; if > 2^24 do as exponent
.01a036	b0 09		bcs $01a041			bcs 		_FPTSExponent
.01a038	c9 6c		cmp #$6c			cmp 		#128-20 				; if < 2^-20 do as an exponent
.01a03a	90 05		bcc $01a041			bcc 		_FPTSExponent 			;
.01a03c					_FPTSStandard:
.01a03c	20 80 a0	jsr $01a080			jsr 		FPTOutputBody 			; output the body.
.01a03f	80 df		bra $01a020			bra 		_FPTSExit
.01a041					_FPTSExponent:
.01a041	a9 00		lda #$00			lda 		#0 						; zero the exponent count.
.01a043	8d 9d 03	sta $039d			sta 		ExpCount
.01a046					_FPTSExponentLoop:
.01a046	b5 84		lda $84,x			lda 		XS_Exponent,x 			; exponent < 0, x by 10
.01a048	10 0e		bpl $01a058			bpl 		_FPTSTimes
.01a04a	c9 85		cmp #$85			cmp 		#128+5 					; exit when in range 0..4
.01a04c	90 14		bcc $01a062			bcc 		_FPTSScaledToExp
.01a04e	a9 ff		lda #$ff			lda 		#-1 					; divide by 10.
.01a050	20 bd 9f	jsr $019fbd			jsr 		FPUScale10A
.01a053	ee 9d 03	inc $039d			inc 		ExpCount
.01a056	80 ee		bra $01a046			bra 		_FPTSExponentLoop
.01a058					_FPTSTimes:
.01a058	a9 01		lda #$01			lda 		#1
.01a05a	20 bd 9f	jsr $019fbd			jsr 		FPUScale10A
.01a05d	ce 9d 03	dec $039d			dec 		ExpCount
.01a060	80 e4		bra $01a046			bra 		_FPTSExponentLoop
.01a062					_FPTSScaledToExp:
.01a062	20 80 a0	jsr $01a080			jsr 		FPTOutputBody 			; output the body.
.01a065	a9 65		lda #$65			lda 		#"e"					; output E
.01a067	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter
.01a06a	ad 9d 03	lda $039d			lda 		ExpCount 				; get the exponent
.01a06d	95 80		sta $80,x			sta 		XS_Mantissa,x
.01a06f	29 80		and #$80			and 		#$80 					; sign extend it
.01a071	f0 02		beq $01a075			beq 		_FPTSSExt
.01a073	a9 ff		lda #$ff			lda 		#$FF
.01a075					_FPTSSExt:
.01a075	95 81		sta $81,x			sta 		XS_Mantissa+1,x
.01a077	95 82		sta $82,x			sta 		XS_Mantissa+2,x
.01a079	95 83		sta $83,x			sta 		XS_Mantissa+3,x
.01a07b	20 da 9a	jsr $019ada			jsr 		INTToString 			; output the exponent.
.01a07e	80 a0		bra $01a020			bra			_FPTSExit 				; and exit.
.01a080					FPTOutputBody:
.01a080	20 fb 9f	jsr $019ffb			jsr 		FPUCopyToNext 			; copy to next slot.
.01a083	20 16 9f	jsr $019f16			jsr 		FPUToInteger 			; convert to an integer
.01a086	20 da 9a	jsr $019ada			jsr 		INTToString 			; output the main integer part.
.01a089	20 08 a0	jsr $01a008			jsr 		FPUCopyFromNext 		; get the fractional part back.
.01a08c	20 d6 9d	jsr $019dd6			jsr 		FPFractionalPart 		; get the decimal part.
.01a08f	34 85		bit $85,x			bit 		XS_Type,x 				; any fractional part.
.01a091	70 3c		bvs $01a0cf			bvs 		_FPTOExit 				; if not, exit now.
.01a093	a9 2e		lda #$2e			lda 		#"." 					; print out a decimal place.
.01a095	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter
.01a098					_FPOutLoop:
.01a098	34 85		bit $85,x			bit 		XS_Type,x 				; finally reached zero.
.01a09a	70 1d		bvs $01a0b9			bvs 		_FPStripZeros 			; strip trailing zeros
.01a09c	20 6f 9f	jsr $019f6f			jsr 		FPUTimes10 				; multiply by 10
.01a09f	20 fb 9f	jsr $019ffb			jsr 		FPUCopyToNext			; copy to next slot.
.01a0a2	20 16 9f	jsr $019f16			jsr 		FPUToInteger 			; convert to integer
.01a0a5	b5 80		lda $80,x			lda 		XS_Mantissa+0,x 		; print digit.
.01a0a7	09 30		ora #$30			ora 		#"0"
.01a0a9	20 7c 9b	jsr $019b7c			jsr 		ITSOutputCharacter
.01a0ac	20 08 a0	jsr $01a008			jsr 		FPUCopyFromNext 		; get it back
.01a0af	20 d6 9d	jsr $019dd6			jsr 		FPFractionalPart 		; get fractional part
.01a0b2	ad 14 03	lda $0314			lda 		NumBufX 				; done 11 characters yet ?
.01a0b5	c9 0b		cmp #$0b			cmp 	 	#11
.01a0b7	90 df		bcc $01a098			bcc 		_FPOutLoop 				; if so, keep going till zero.
.01a0b9					_FPStripZeros:
.01a0b9	ac 14 03	ldy $0314			ldy 		NumBufX 				; strip trailing zeros.
.01a0bc					_FPStripLoop:
.01a0bc	88		dey				dey 								; back one, if at start then no strip
.01a0bd	f0 10		beq $01a0cf			beq 		_FPToExit
.01a0bf	b9 15 03	lda $0315,y			lda 		Num_Buffer,y 			; keep going if "0"
.01a0c2	c9 30		cmp #$30			cmp 		#"0"
.01a0c4	f0 f6		beq $01a0bc			beq 		_FPStripLoop
.01a0c6	c8		iny				iny
.01a0c7	a9 00		lda #$00			lda 		#0 						; add trailing zero one on
.01a0c9	99 15 03	sta $0315,y			sta 		Num_Buffer,y
.01a0cc	8c 14 03	sty $0314			sty 		NumBufX 				; update position.
.01a0cf					_FPTOExit:
.01a0cf	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/float/convert/fpfromstr.asm

.01a0d0					FPFromString:
.01a0d0	48		pha				pha 								; push A
.01a0d1	b1 1e		lda ($1e),y			lda		(zGenPtr),y					; is it followed by a DP ?
.01a0d3	c9 2e		cmp #$2e			cmp 	#"."
.01a0d5	f0 03		beq $01a0da			beq	 	_FPFIsDecimal
.01a0d7	4c 36 a1	jmp $01a136			jmp 	_FPFNotDecimal
.01a0da					_FPFIsDecimal:
.01a0da	c8		iny				iny 								; consume the decimal.
.01a0db	20 ca 9e	jsr $019eca			jsr 	FPUToFloat 					; convert the integer to float.
.01a0de	da		phx				phx 								; save X.
.01a0df	5a		phy				phy 								; save decimal start position
.01a0e0	e8		inx				inx
.01a0e1	e8		inx				inx
.01a0e2	e8		inx				inx
.01a0e3	e8		inx				inx
.01a0e4	e8		inx				inx
.01a0e5	e8		inx				inx
.01a0e6	20 94 9b	jsr $019b94			jsr 	INTFromStringY 				; get the part after the DP.
.01a0e9	20 ca 9e	jsr $019eca			jsr 	FPUToFloat 					; convert that to a float.
.01a0ec	68		pla				pla 								; calculate - chars consumed.
.01a0ed	8c 9c 03	sty $039c			sty 	ExpTemp
.01a0f0	38		sec				sec
.01a0f1	ed 9c 03	sbc $039c			sbc 	ExpTemp 					; this is the shift amount
.01a0f4	20 bd 9f	jsr $019fbd			jsr 	FPUScale10A 				; scale it by 10^AC
.01a0f7	fa		plx				plx 								; restore original X
.01a0f8	20 27 9c	jsr $019c27			jsr 	FPAdd 						; Add X2 to X1 giving the fractional bit.
.01a0fb	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; exponent ?
.01a0fd	c9 45		cmp #$45			cmp 	#"E"
.01a0ff	f0 04		beq $01a105			beq 	_FPFExponent
.01a101	c9 65		cmp #$65			cmp 	#"e"
.01a103	d0 31		bne $01a136			bne 	_FPFNotDecimal 				; no, then exit normally.
.01a105					_FPFExponent:
.01a105	c8		iny				iny 								; skip over E symbol.
.01a106	b1 1e		lda ($1e),y			lda 	(zGenPtr),y 				; look at next
.01a108	49 2d		eor #$2d			eor 	#"-"						; will be zero if -ve
.01a10a	d0 01		bne $01a10d			bne 	_FPFGotSign
.01a10c	c8		iny				iny 								; if it was - skip over it.
.01a10d					_FPFGotSign:
.01a10d	48		pha				pha 								; push direction : 0 -ve, #0 +ve onto stack.
.01a10e	da		phx				phx
.01a10f	e8		inx				inx
.01a110	e8		inx				inx
.01a111	e8		inx				inx
.01a112	e8		inx				inx
.01a113	e8		inx				inx
.01a114	e8		inx				inx
.01a115	20 94 9b	jsr $019b94			jsr 	INTFromStringY 				; get the exponent
.01a118	fa		plx				plx 								; restore X.
.01a119	b5 87		lda $87,x			lda 	XS2_Mantissa+1,x 			; check exponent low bytes are all zero.
.01a11b	15 89		ora $89,x			ora 	XS2_Mantissa+3,x
.01a11d	15 88		ora $88,x			ora 	XS2_Mantissa+2,x
.01a11f	d0 17		bne $01a138			bne 	_FPFXOverflow 				; if not, must be a bad exponent
.01a121	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get the exponent, the low byte
.01a123	c9 1e		cmp #$1e			cmp 	#30 						; check in range 0-30
.01a125	b0 11		bcs $01a138			bcs 	_FPFXOverflow
.01a127	68		pla				pla 								; get direction
.01a128	d0 07		bne $01a131			bne 	_FPFXScale  				; if non-zero, e.g. +ve skip the next bit
.01a12a	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; negate the exponent
.01a12c	49 ff		eor #$ff			eor 	#$FF
.01a12e	1a		inc a				inc 	a
.01a12f	95 86		sta $86,x			sta 	XS2_Mantissa+0,x
.01a131					_FPFXScale:
.01a131	b5 86		lda $86,x			lda 	XS2_Mantissa+0,x 			; get scale amount
.01a133	20 bd 9f	jsr $019fbd			jsr 	FPUScale10A 				; scale by the exponent.
.01a136					_FPFNotDecimal:
.01a136	68		pla				pla
.01a137	60		rts				rts
.01a138					_FPFXOverflow:
.01a138	20 57 85	jsr $018557			jsr 	ERR_Handler
>01a13b	45 78 70 6f 6e 65 6e 74				.text 	"Exponent Range",0
>01a143	20 52 61 6e 67 65 00

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/rnd.asm

.01a14a					Unary_Rnd:
.01a14a	20 23 8f	jsr $018f23			jsr 	EvaluateNumberX 			; get value
.01a14d	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; check right bracket.
.01a150	20 a1 91	jsr $0191a1			jsr 	GetSignCurrent 				; get sign -1,0,1.
.01a153	09 00		ora #$00			ora 	#0 							; if -ve set seed.
.01a155	30 10		bmi $01a167			bmi 	_URSetSeed
.01a157	f0 28		beq $01a181			beq 	_URMakeRandom 				; if zero return same number.
.01a159	da		phx				phx
.01a15a	a2 00		ldx #$00			ldx 	#0
.01a15c	20 b8 a1	jsr $01a1b8			jsr 	Random16
.01a15f	a2 02		ldx #$02			ldx 	#2
.01a161	20 b8 a1	jsr $01a1b8			jsr 	Random16
.01a164	fa		plx				plx
.01a165	80 1a		bra $01a181			bra 	_URMakeRandom
.01a167					_URSetSeed:
.01a167	20 ca 9e	jsr $019eca			jsr 	FPUToFloat 					; make it a float to twiddle it.
.01a16a	b5 80		lda $80,x			lda		XS_Mantissa+0,x 			; copy mantissa to seed.
.01a16c	8d a3 03	sta $03a3			sta 	RandomSeed+0
.01a16f	b5 81		lda $81,x			lda		XS_Mantissa+1,x
.01a171	8d a4 03	sta $03a4			sta 	RandomSeed+1
.01a174	b5 82		lda $82,x			lda		XS_Mantissa+2,x
.01a176	8d a5 03	sta $03a5			sta 	RandomSeed+2
.01a179	b5 83		lda $83,x			lda		XS_Mantissa+3,x
.01a17b	0a		asl a				asl 	a
.01a17c	49 db		eor #$db			eor 	#$DB
.01a17e	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a181					_URMakeRandom:
.01a181	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; check if seed is zero.
.01a184	0d a4 03	ora $03a4			ora 	RandomSeed+1
.01a187	0d a5 03	ora $03a5			ora 	RandomSeed+2
.01a18a	0d a6 03	ora $03a6			ora 	RandomSeed+3
.01a18d	d0 0a		bne $01a199			bne 	_URNotZero
.01a18f	a9 47		lda #$47			lda 	#$47
.01a191	8d a4 03	sta $03a4			sta 	RandomSeed+1				; if it is, make it non zero.
.01a194	a9 3d		lda #$3d			lda 	#$3D
.01a196	8d a6 03	sta $03a6			sta 	RandomSeed+3
.01a199					_URNotZero:
.01a199	ad a3 03	lda $03a3			lda 	RandomSeed+0 				; copy seed into mantissa.
.01a19c	95 80		sta $80,x			sta 	XS_Mantissa+0,x
.01a19e	ad a4 03	lda $03a4			lda 	RandomSeed+1
.01a1a1	95 81		sta $81,x			sta 	XS_Mantissa+1,x
.01a1a3	ad a5 03	lda $03a5			lda 	RandomSeed+2
.01a1a6	95 82		sta $82,x			sta 	XS_Mantissa+2,x
.01a1a8	ad a6 03	lda $03a6			lda 	RandomSeed+3
.01a1ab	95 83		sta $83,x			sta 	XS_Mantissa+3,x
.01a1ad	a9 00		lda #$00			lda 	#$00 						; set type to float.
.01a1af	95 85		sta $85,x			sta 	XS_Type,x
.01a1b1	a9 80		lda #$80			lda 	#$80
.01a1b3	95 84		sta $84,x			sta	 	XS_Exponent,x				; exponent to 128 (e.g. 0.x 2^0)
.01a1b5	4c f7 9e	jmp $019ef7			jmp 	FPUNormalise
.01a1b8					Random16:
.01a1b8	5e a4 03	lsr $03a4,x			lsr 	RandomSeed+1,x				; shift seed right
.01a1bb	7e a3 03	ror $03a3,x			ror 	RandomSeed,x
.01a1be	90 08		bcc $01a1c8			bcc 	_R16_NoXor
.01a1c0	bd a4 03	lda $03a4,x			lda 	RandomSeed+1,x				; xor MSB with $B4 if bit set.
.01a1c3	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.01a1c5	9d a4 03	sta $03a4,x			sta 	RandomSeed+1,x
.01a1c8					_R16_NoXor:
.01a1c8	60		rts				rts

;******  Return to file: _include.asm


;******  Processing file: modules/basic/expressions/floatonly/int.asm

.01a1c9					Unary_Int:
.01a1c9	20 23 8f	jsr $018f23			jsr 	EvaluateNumberX 			; get value
.01a1cc	20 57 95	jsr $019557			jsr 	CheckNextRParen 			; check right bracket.
.01a1cf	4c 16 9f	jmp $019f16			jmp 	FPUToInteger				; Convert to integer.

;******  Return to file: _include.asm


;******  Return to file: basic.asm

>01a1d2	02						.byte 	2
.fff8					DefaultInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word DefaultInterrupt
>fffc	00 c0						.word 	StartROM
>fffe	19 c0					.word TIM_BreakHandler

;******  End of listing
