firstKeywordMinus = $93
firstKeywordPlus = $8f
firstUnaryFunction = $98
lastUnaryFunction = $b4
;
;	Jump Vector Table
;
VectorTable:
	.word BinaryOp_And         ; $80 and
	.word BinaryOp_Or          ; $81 or
	.word BinaryOp_Xor         ; $82 xor
	.word BinaryOp_Eor         ; $83 eor
	.word Binary_Equal         ; $84 =
	.word Binary_NotEqual      ; $85 <>
	.word Binary_Less          ; $86 <
	.word Binary_LessEqual     ; $87 <=
	.word Binary_Greater       ; $88 >
	.word Binary_GreaterEqual  ; $89 >=
	.word BinaryOp_Add         ; $8a +
	.word BinaryOp_Subtract    ; $8b -
	.word BinaryOp_Multiply    ; $8c *
	.word BinaryOp_Divide      ; $8d /
	.word NotImplemented       ; $8e ^
	.word NotImplemented       ; $8f if
	.word NotImplemented       ; $90 while
	.word NotImplemented       ; $91 repeat
	.word NotImplemented       ; $92 for
	.word NotImplemented       ; $93 then
	.word NotImplemented       ; $94 endif
	.word NotImplemented       ; $95 wend
	.word NotImplemented       ; $96 until
	.word NotImplemented       ; $97 next
	.word NotImplemented       ; $98 not
	.word NotImplemented       ; $99 fn(
	.word Unary_Abs            ; $9a abs(
	.word Unary_Asc            ; $9b asc(
	.word Unary_Int            ; $9c int(
	.word NotImplemented       ; $9d peek(
	.word Unary_Rnd            ; $9e rnd(
	.word NotImplemented       ; $9f usr(
	.word NotImplemented       ; $a0 left$(
	.word NotImplemented       ; $a1 right$(
	.word NotImplemented       ; $a2 mid$(
	.word Unary_Spc            ; $a3 spc(
	.word NotImplemented       ; $a4 str$(
	.word Unary_Val            ; $a5 val(
	.word Unary_Len            ; $a6 len(
	.word NotImplemented       ; $a7 hex$(
	.word NotImplemented       ; $a8 sin(
	.word NotImplemented       ; $a9 cos(
	.word NotImplemented       ; $aa tan(
	.word NotImplemented       ; $ab atn(
	.word NotImplemented       ; $ac exp(
	.word NotImplemented       ; $ad log(
	.word NotImplemented       ; $ae sqr(
	.word NotImplemented       ; $af dec(
	.word NotImplemented       ; $b0 deek(
	.word NotImplemented       ; $b1 leek(
	.word NotImplemented       ; $b2 mod(
	.word Unary_Sgn            ; $b3 sgn(
	.word Unary_Chr            ; $b4 chr$(
	.word NotImplemented       ; $b5 $(
	.word NotImplemented       ; $b6 $
	.word NotImplemented       ; $b7 #(
	.word NotImplemented       ; $b8 #
	.word NotImplemented       ; $b9 %(
	.word NotImplemented       ; $ba %
	.word NotImplemented       ; $bb (
	.word NotImplemented       ; $bc )
	.word NotImplemented       ; $bd ,
	.word NotImplemented       ; $be :
	.word NotImplemented       ; $bf ;
	.word NotImplemented       ; $c0 def
	.word CLR_Command          ; $c1 clr
	.word NotImplemented       ; $c3 data
	.word NotImplemented       ; $c4 read
	.word NotImplemented       ; $c5 dim
	.word NotImplemented       ; $c6 to
	.word NotImplemented       ; $c7 step
	.word NotImplemented       ; $c8 gosub
	.word NotImplemented       ; $c9 return
	.word NotImplemented       ; $ca goto
	.word NotImplemented       ; $cb input
	.word NotImplemented       ; $cc let
	.word NotImplemented       ; $cd list
	.word NotImplemented       ; $ce new
	.word NotImplemented       ; $cf old
	.word NotImplemented       ; $d0 on
	.word NotImplemented       ; $d1 restore
	.word NotImplemented       ; $d2 poke
	.word NotImplemented       ; $d3 print
	.word NotImplemented       ; $d4 run
	.word NotImplemented       ; $d5 stop
	.word NotImplemented       ; $d6 wait
	.word NotImplemented       ; $d7 doke
	.word NotImplemented       ; $d8 loke
	.word NotImplemented       ; $d9 assert
NotImplemented:

	#fatal "Not implemented"

;
;	Binary Precedence Level Table
;
BinaryPrecedence:
	.byte 1    ; $80 and
	.byte 1    ; $81 or
	.byte 1    ; $82 xor
	.byte 1    ; $83 eor
	.byte 2    ; $84 =
	.byte 2    ; $85 <>
	.byte 2    ; $86 <
	.byte 2    ; $87 <=
	.byte 2    ; $88 >
	.byte 2    ; $89 >=
	.byte 3    ; $8a +
	.byte 3    ; $8b -
	.byte 4    ; $8c *
	.byte 4    ; $8d /
	.byte 5    ; $8e ^
;
;	Keyword Text
;
KeywordText:
	.byte $41,$4e,$c4                      ; $80 and
	.byte $4f,$d2                          ; $81 or
	.byte $58,$4f,$d2                      ; $82 xor
	.byte $45,$4f,$d2                      ; $83 eor
	.byte $bd                              ; $84 =
	.byte $3c,$be                          ; $85 <>
	.byte $bc                              ; $86 <
	.byte $3c,$bd                          ; $87 <=
	.byte $be                              ; $88 >
	.byte $3e,$bd                          ; $89 >=
	.byte $ab                              ; $8a +
	.byte $ad                              ; $8b -
	.byte $aa                              ; $8c *
	.byte $af                              ; $8d /
	.byte $de                              ; $8e ^
	.byte $49,$c6                          ; $8f if
	.byte $57,$48,$49,$4c,$c5              ; $90 while
	.byte $52,$45,$50,$45,$41,$d4          ; $91 repeat
	.byte $46,$4f,$d2                      ; $92 for
	.byte $54,$48,$45,$ce                  ; $93 then
	.byte $45,$4e,$44,$49,$c6              ; $94 endif
	.byte $57,$45,$4e,$c4                  ; $95 wend
	.byte $55,$4e,$54,$49,$cc              ; $96 until
	.byte $4e,$45,$58,$d4                  ; $97 next
	.byte $4e,$4f,$d4                      ; $98 not
	.byte $46,$4e,$a8                      ; $99 fn(
	.byte $41,$42,$53,$a8                  ; $9a abs(
	.byte $41,$53,$43,$a8                  ; $9b asc(
	.byte $49,$4e,$54,$a8                  ; $9c int(
	.byte $50,$45,$45,$4b,$a8              ; $9d peek(
	.byte $52,$4e,$44,$a8                  ; $9e rnd(
	.byte $55,$53,$52,$a8                  ; $9f usr(
	.byte $4c,$45,$46,$54,$24,$a8          ; $a0 left$(
	.byte $52,$49,$47,$48,$54,$24,$a8      ; $a1 right$(
	.byte $4d,$49,$44,$24,$a8              ; $a2 mid$(
	.byte $53,$50,$43,$a8                  ; $a3 spc(
	.byte $53,$54,$52,$24,$a8              ; $a4 str$(
	.byte $56,$41,$4c,$a8                  ; $a5 val(
	.byte $4c,$45,$4e,$a8                  ; $a6 len(
	.byte $48,$45,$58,$24,$a8              ; $a7 hex$(
	.byte $53,$49,$4e,$a8                  ; $a8 sin(
	.byte $43,$4f,$53,$a8                  ; $a9 cos(
	.byte $54,$41,$4e,$a8                  ; $aa tan(
	.byte $41,$54,$4e,$a8                  ; $ab atn(
	.byte $45,$58,$50,$a8                  ; $ac exp(
	.byte $4c,$4f,$47,$a8                  ; $ad log(
	.byte $53,$51,$52,$a8                  ; $ae sqr(
	.byte $44,$45,$43,$a8                  ; $af dec(
	.byte $44,$45,$45,$4b,$a8              ; $b0 deek(
	.byte $4c,$45,$45,$4b,$a8              ; $b1 leek(
	.byte $4d,$4f,$44,$a8                  ; $b2 mod(
	.byte $53,$47,$4e,$a8                  ; $b3 sgn(
	.byte $43,$48,$52,$24,$a8              ; $b4 chr$(
	.byte $24,$a8                          ; $b5 $(
	.byte $a4                              ; $b6 $
	.byte $23,$a8                          ; $b7 #(
	.byte $a3                              ; $b8 #
	.byte $25,$a8                          ; $b9 %(
	.byte $a5                              ; $ba %
	.byte $a8                              ; $bb (
	.byte $a9                              ; $bc )
	.byte $ac                              ; $bd ,
	.byte $ba                              ; $be :
	.byte $bb                              ; $bf ;
	.byte $44,$45,$c6                      ; $c0 def
	.byte $43,$4c,$d2                      ; $c1 clr
	.byte $44,$41,$54,$c1                  ; $c3 data
	.byte $52,$45,$41,$c4                  ; $c4 read
	.byte $44,$49,$cd                      ; $c5 dim
	.byte $54,$cf                          ; $c6 to
	.byte $53,$54,$45,$d0                  ; $c7 step
	.byte $47,$4f,$53,$55,$c2              ; $c8 gosub
	.byte $52,$45,$54,$55,$52,$ce          ; $c9 return
	.byte $47,$4f,$54,$cf                  ; $ca goto
	.byte $49,$4e,$50,$55,$d4              ; $cb input
	.byte $4c,$45,$d4                      ; $cc let
	.byte $4c,$49,$53,$d4                  ; $cd list
	.byte $4e,$45,$d7                      ; $ce new
	.byte $4f,$4c,$c4                      ; $cf old
	.byte $4f,$ce                          ; $d0 on
	.byte $52,$45,$53,$54,$4f,$52,$c5      ; $d1 restore
	.byte $50,$4f,$4b,$c5                  ; $d2 poke
	.byte $50,$52,$49,$4e,$d4              ; $d3 print
	.byte $52,$55,$ce                      ; $d4 run
	.byte $53,$54,$4f,$d0                  ; $d5 stop
	.byte $57,$41,$49,$d4                  ; $d6 wait
	.byte $44,$4f,$4b,$c5                  ; $d7 doke
	.byte $4c,$4f,$4b,$c5                  ; $d8 loke
	.byte $41,$53,$53,$45,$52,$d4          ; $d9 assert
	.byte $00
token_and = $80
token_or = $81
token_xor = $82
token_eor = $83
token_equal = $84
token_lessgreater = $85
token_less = $86
token_lessequal = $87
token_greater = $88
token_greaterequal = $89
token_plus = $8a
token_minus = $8b
token_star = $8c
token_slash = $8d
token_hat = $8e
token_if = $8f
token_while = $90
token_repeat = $91
token_for = $92
token_then = $93
token_endif = $94
token_wend = $95
token_until = $96
token_next = $97
token_not = $98
token_fn = $99
token_abs = $9a
token_asc = $9b
token_int = $9c
token_peek = $9d
token_rnd = $9e
token_usr = $9f
token_leftdollarlparen = $a0
token_rightdollarlparen = $a1
token_middollarlparen = $a2
token_spc = $a3
token_strdollarlparen = $a4
token_val = $a5
token_len = $a6
token_hexdollarlparen = $a7
token_sin = $a8
token_cos = $a9
token_tan = $aa
token_atn = $ab
token_exp = $ac
token_log = $ad
token_sqr = $ae
token_dec = $af
token_deek = $b0
token_leek = $b1
token_mod = $b2
token_sgn = $b3
token_chrdollarlparen = $b4
token_dollarlparen = $b5
token_dollar = $b6
token_hashlparen = $b7
token_hash = $b8
token_percentlparen = $b9
token_percent = $ba
token_lparen = $bb
token_rparen = $bc
token_comma = $bd
token_colon = $be
token_semicolon = $bf
token_def = $c0
token_clr = $c1
token_data = $c3
token_read = $c4
token_dim = $c5
token_to = $c6
token_step = $c7
token_gosub = $c8
token_return = $c9
token_goto = $ca
token_input = $cb
token_let = $cc
token_list = $cd
token_new = $ce
token_old = $cf
token_on = $d0
token_restore = $d1
token_poke = $d2
token_print = $d3
token_run = $d4
token_stop = $d5
token_wait = $d6
token_doke = $d7
token_loke = $d8
token_assert = $d9
